<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        /* System fonts - local-first compliant, no external dependencies */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vw, 32px);
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
            font-weight: bold;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2vw, 12px);
        }

        .stats-box {
            display: flex;
            gap: 15px;
            text-align: right;
            flex-wrap: wrap;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: clamp(14px, 3vw, 20px); color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: clamp(8px, 1.5vw, 10px); color: #666; text-transform: uppercase; }

        /* Data Controls - Import/Export */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Player Health Bar */
        .player-health-bar {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 250px);
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #f44;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            pointer-events: none;
        }

        .player-health-fill {
            height: 100%;
            background: linear-gradient(to right, #f44, #ff6666);
            width: 100%;
            transition: width 0.3s;
        }

        .player-health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            line-height: 20px;
            text-shadow: 1px 1px 2px #000;
        }

        /* RPG INTERFACE (Bottom) */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, rgba(5,5,5,0.95), transparent);
            display: none;
            padding: 10px;
            pointer-events: none;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-end;
            gap: 10px;
        }

        .inventory-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: clamp(200px, 40vw, 300px);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .panel-title {
            color: #fb0;
            font-family: Georgia, serif;
            border-bottom: 1px solid #445;
            margin-bottom: 10px;
            padding-bottom: 5px;
            font-size: clamp(12px, 2vw, 14px);
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 3vw, 20px);
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 35px;
            min-height: 35px;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 2px; right: 4px;
            font-size: clamp(9px, 1.5vw, 12px);
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        .player-stats {
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 12px;
            width: clamp(180px, 35vw, 250px);
        }

        .xp-bar-container {
            margin-bottom: 6px;
        }
        .xp-label { font-size: clamp(10px, 1.5vw, 12px); color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 6px; background: #222; border-radius: 3px; overflow: hidden; margin-top: 3px; }
        .xp-bar-fill { height: 100%; width: 0%; transition: width 0.3s; }

        /* Crafting Panel */
        .crafting-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: clamp(150px, 25vw, 200px);
        }

        .craft-btn {
            display: block;
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: clamp(10px, 1.5vw, 12px);
            transition: all 0.2s;
        }

        .craft-btn:hover:not(:disabled) { background: #555; border-color: #fb0; }
        .craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Action Buttons */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: Georgia, serif;
            pointer-events: auto;
            font-size: clamp(11px, 2vw, 14px);
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: clamp(12px, 2vw, 16px);
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: clamp(10px, 1.5vw, 12px);
            pointer-events: none;
            display: none;
            z-index: 100;
            border-radius: 4px;
            max-width: 200px;
        }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
            font-family: Georgia, serif;
        }

        .loading-text {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }

        .loading-bar {
            width: clamp(200px, 50vw, 300px);
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #0f0;
            animation: loadPulse 1s ease-in-out infinite;
        }

        @keyframes loadPulse {
            0%, 100% { width: 20%; margin-left: 0; }
            50% { width: 40%; margin-left: 60%; }
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 200px;
            right: 10px;
            width: clamp(80px, 15vw, 120px);
            height: clamp(80px, 15vw, 120px);
            background: rgba(0,0,0,0.7);
            border: 2px solid #445;
            border-radius: 8px;
            display: none;
            pointer-events: auto;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* v4.8: Combat Abilities */
        .ability-slot {
            width: 50px;
            height: 50px;
            background: rgba(40, 40, 60, 0.9);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .ability-slot:hover {
            border-color: #0ff;
            transform: scale(1.1);
        }
        .ability-slot.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .ability-slot.on-cooldown {
            border-color: #444;
        }
        .ability-slot.active-buff {
            border-color: #ff8800;
            box-shadow: 0 0 10px #ff8800;
        }
        .ability-icon {
            font-size: 20px;
        }
        .ability-key {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
        }

        /* Touch Controls */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
            pointer-events: auto;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* v4.3: Virtual Joystick */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .touch-action-btn {
            position: fixed;
            bottom: 50px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: rgba(255, 100, 0, 0.4);
            border: 3px solid rgba(255, 150, 0, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-action-btn:active {
            background: rgba(255, 150, 0, 0.7);
        }

        /* v4.5: Mobile Dodge Button */
        .touch-dodge-btn {
            position: fixed;
            bottom: 140px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(100, 200, 255, 0.4);
            border: 3px solid rgba(150, 220, 255, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-dodge-btn:active {
            background: rgba(150, 220, 255, 0.7);
        }

        /* Notification Toast */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px 20px;
            border-radius: 4px;
            color: #0f0;
            font-size: 14px;
            z-index: 500;
            animation: notifySlide 3s forwards;
            pointer-events: none;
        }

        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(50, 40, 80, 0.95));
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 600;
            animation: achievementSlide 4s forwards;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .achievement-popup .ach-icon { font-size: 36px; }
        .achievement-popup .ach-title { color: #ffd700; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; }
        .achievement-popup .ach-name { color: #fff; font-size: 16px; font-weight: bold; margin: 3px 0; }
        .achievement-popup .ach-desc { color: #aaa; font-size: 12px; }

        @keyframes achievementSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }

        /* Daily Challenge Box */
        .daily-challenge-box {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 12px 15px;
            width: 180px;
            z-index: 100;
        }

        .daily-challenge-box.completed {
            border-color: #44ff44;
            background: rgba(20, 40, 20, 0.9);
        }

        .daily-title { color: #ffd700; font-size: 11px; text-transform: uppercase; margin-bottom: 8px; }
        .daily-desc { color: #fff; font-size: 12px; margin-bottom: 8px; }
        .daily-progress-bar { background: #333; border-radius: 4px; height: 8px; overflow: hidden; }
        .daily-progress-fill { background: linear-gradient(90deg, #ffd700, #ffaa00); height: 100%; transition: width 0.3s; }
        .daily-progress-text { color: #aaa; font-size: 10px; margin-top: 5px; }
        .daily-streak { color: #ff8800; font-size: 10px; margin-top: 3px; }

        /* Stats Modal */
        .stats-section { margin-bottom: 20px; }
        .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 13px; }
        .stat-row span:last-child { color: #0ff; font-weight: bold; }

        .achievements-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .ach-item {
            display: flex; align-items: center; gap: 6px;
            background: rgba(40,40,60,0.8);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
        }
        .ach-item.unlocked { color: #fff; background: rgba(50, 50, 80, 0.9); border: 1px solid #ffd700; }
        .ach-item.locked .ach-badge { filter: grayscale(1); opacity: 0.4; }
        .ach-badge { font-size: 16px; }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }

        .modal-content {
            background: #1a1a2e;
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
        }

        .modal-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 20px;
            font-family: Georgia, serif;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* v4.6: Settings Panel Styles */
        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-section:last-child { border-bottom: none; }
        .settings-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }
        .setting-row input[type="range"] {
            width: 100px;
            margin: 0 10px;
            accent-color: #0ff;
        }
        .setting-row select {
            background: #222;
            border: 1px solid #445;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .toggle-btn {
            background: rgba(0,100,0,0.5);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            min-width: 50px;
        }
        .toggle-btn.off {
            background: rgba(100,0,0,0.5);
            border-color: #f44;
            color: #f44;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
            }

            .rpg-ui {
                flex-direction: column;
                align-items: center;
                max-height: 50vh;
                overflow-y: auto;
            }

            .inventory-panel, .player-stats, .crafting-panel {
                width: 95%;
                max-width: none;
            }

            .touch-controls {
                display: flex;
            }

            .data-controls {
                top: auto;
                bottom: 10px;
                right: 10px;
            }

            .minimap {
                bottom: auto;
                top: 70px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .inv-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .rpg-ui {
                padding: 5px;
            }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        <div class="loading-text">INITIALIZING OMNIVERSE ENGINE...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>

    <div id="container"></div>

    <div class="ui-layer">
        <!-- Data Controls - Import/Export -->
        <div class="data-controls">
            <button onclick="showStatsPanel()">Stats</button>
            <button onclick="showSettingsModal()">Settings</button>
            <button onclick="quickSave()">Save</button>
            <button onclick="exportData()">Export</button>
            <button onclick="document.getElementById('importFile').click()">Import</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">GALAXY SIMULATION v4.6</div>
            </div>

            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="total-playtime">0:00</span>
                    <span class="stat-lbl">Playtime</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <div class="stat-entry">
                    <span class="stat-val" id="world-name">Terra</span>
                    <span class="stat-lbl">Planet</span>
                </div>
                <button class="action-btn" onclick="returnToGalaxy()">LEAVE PLANET</button>
            </div>
        </div>

        <!-- Player Health Bar -->
        <div id="player-health-bar" class="player-health-bar">
            <div class="player-health-text"><span id="health-text">100 / 100</span></div>
            <div id="player-health-fill" class="player-health-fill"></div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <!-- Minimap -->
        <div id="minimap" class="minimap">
            <canvas id="minimap-canvas" class="minimap-canvas"></canvas>
        </div>

        <!-- v4.8: Combat Abilities Bar -->
        <div id="ability-bar" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 100;">
            <div style="display: flex; gap: 10px; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #333;">
                <div id="ability-q" class="ability-slot" onclick="useAbility('powerStrike')" title="Power Strike (Q) - 3x damage">
                    <span class="ability-icon">‚öîÔ∏è</span>
                    <span class="ability-key">Q</span>
                    <div class="ability-cooldown" id="cooldown-q"></div>
                </div>
                <div id="ability-e" class="ability-slot" onclick="useAbility('whirlwind')" title="Whirlwind (E) - AoE damage">
                    <span class="ability-icon">üåÄ</span>
                    <span class="ability-key">E</span>
                    <div class="ability-cooldown" id="cooldown-e"></div>
                </div>
                <div id="ability-r" class="ability-slot" onclick="useAbility('warcry')" title="War Cry (R) - +50% damage">
                    <span class="ability-icon">üì¢</span>
                    <span class="ability-key">R</span>
                    <div class="ability-cooldown" id="cooldown-r"></div>
                </div>
            </div>
        </div>

        <div id="rpg-ui" class="rpg-ui">
            <div class="player-stats">
                <div class="panel-title">Skills</div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Fishing</span> <span id="lvl-fishing">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-fishing" class="xp-bar-fill" style="background:#44f"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Cooking</span> <span id="lvl-cooking">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-cooking" class="xp-bar-fill" style="background:#f80"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Crafting</span> <span id="lvl-crafting">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-crafting" class="xp-bar-fill" style="background:#a0f"></div></div>
                </div>
            </div>

            <div class="crafting-panel" style="max-height: 280px; overflow-y: auto;">
                <div class="panel-title">Crafting</div>
                <!-- Basic Recipes -->
                <button class="craft-btn" id="craft-pickaxe" onclick="craft('pickaxe')">Pickaxe (3 Ore, 2 Log)</button>
                <button class="craft-btn" id="craft-sword" onclick="craft('sword')">Sword (5 Ore, 1 Log)</button>
                <button class="craft-btn" id="craft-rod" onclick="craft('rod')">Fishing Rod (2 Log)</button>
                <button class="craft-btn" id="craft-cookedFish" onclick="craft('cookedFish')">Cook Fish (1 Raw Fish)</button>
                <button class="craft-btn" id="craft-potion" onclick="craft('potion')">Health Potion (2 Slime)</button>
                <!-- v4.2: Advanced Recipes -->
                <div style="border-top: 1px solid #333; margin: 8px 0; padding-top: 8px;">
                    <small style="color: #888;">Advanced Crafting</small>
                </div>
                <button class="craft-btn" id="craft-chitinArmor" onclick="craft('chitinArmor')">Chitin Armor (Lvl 4)</button>
                <button class="craft-btn" id="craft-frostBlade" onclick="craft('frostBlade')">Frost Blade (Lvl 5)</button>
                <button class="craft-btn" id="craft-crystalPickaxe" onclick="craft('crystalPickaxe')">Crystal Pickaxe (Lvl 6)</button>
                <button class="craft-btn" id="craft-magmaSword" onclick="craft('magmaSword')">Magma Sword (Lvl 7)</button>
                <button class="craft-btn" id="craft-superPotion" onclick="craft('superPotion')">Super Potion (Lvl 8)</button>
                <button class="craft-btn" id="craft-voidDagger" onclick="craft('voidDagger')">Void Dagger (Lvl 10)</button>
                <!-- v4.3: Legendary Recipes (requires boss materials) -->
                <div style="border-top: 1px solid #664400; margin: 8px 0; padding-top: 8px;">
                    <small style="color: #ffd700;">‚öîÔ∏è Legendary Crafting</small>
                </div>
                <button class="craft-btn" id="craft-guardianArmor" onclick="craft('guardianArmor')" style="border-color: #664400;">Guardian Armor (Lvl 12)</button>
                <button class="craft-btn" id="craft-legendaryBlade" onclick="craft('legendaryBlade')" style="border-color: #ffd700;">Legendary Blade (Lvl 15)</button>
            </div>

            <div class="inventory-panel">
                <div class="panel-title">Backpack (<span id="inv-count">0</span>/20)</div>
                <div class="inv-grid" id="inventory-grid"></div>
            </div>
        </div>

        <!-- Touch Controls -->
        <div id="touch-controls" class="touch-controls">
            <div class="touch-btn" id="touch-action">A</div>
        </div>

        <!-- v4.3: Virtual Joystick for Mobile -->
        <div id="virtual-joystick" class="virtual-joystick">
            <div id="joystick-knob" class="joystick-knob"></div>
        </div>
        <div id="touch-action-btn" class="touch-action-btn">ACT</div>
        <div id="touch-dodge-btn" class="touch-dodge-btn">DODGE</div>

    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 50;
        background: radial-gradient(transparent 30%, rgba(255,0,0,0.6));
        opacity: 0; transition: opacity 0.1s;
    "></div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Welcome to LEVIATHAN</div>
            <div style="color: #aaa; line-height: 1.8; margin-bottom: 20px;">
                <p style="margin-bottom: 15px;"><strong style="color: #0ff;">Galaxy Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Click on star systems to explore planets</li>
                    <li>Visited planets show a green ring</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #fb0;">Planet Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Click</strong> to move or interact with objects</li>
                    <li><strong>WASD</strong> keys for movement</li>
                    <li><strong>E</strong> to eat food and heal</li>
                    <li><strong>1-9</strong> to use inventory items</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #0f0;">Tips:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Gather logs and ore to craft tools</li>
                    <li>Tools increase resource yield</li>
                    <li>Green slimes are aggressive!</li>
                    <li>Fish for food, cook it to heal more</li>
                </ul>
            </div>
            <button class="action-btn" onclick="closeTutorial()" style="width: 100%;">START EXPLORING</button>
        </div>
    </div>

    <!-- Daily Challenge Box -->
    <div id="daily-challenge" class="daily-challenge-box" style="display: none;">
        <div class="daily-title">Daily Challenge</div>
        <div id="daily-desc" class="daily-desc">Loading...</div>
        <div class="daily-progress-bar">
            <div id="daily-progress-fill" class="daily-progress-fill" style="width: 0%"></div>
        </div>
        <div id="daily-progress-text" class="daily-progress-text">0/0</div>
        <div id="daily-streak" class="daily-streak">Streak: 0 days</div>
    </div>

    <!-- v4.6: Full Settings Panel -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 380px;">
            <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            <div class="modal-title">Settings</div>

            <!-- Audio Section -->
            <div class="settings-section">
                <h4 style="color: #0ff;">Audio</h4>
                <div class="setting-row">
                    <span>Master Volume</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="30" oninput="setMasterVolume(this.value)">
                    <span id="volume-display" style="width: 35px; text-align: right;">30%</span>
                </div>
                <div class="setting-row">
                    <span>Sound Effects</span>
                    <button id="sfx-toggle" class="toggle-btn" onclick="toggleSFX()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Ambient Audio</span>
                    <button id="ambient-toggle" class="toggle-btn" onclick="toggleAmbient()">ON</button>
                </div>
            </div>

            <!-- Graphics Section -->
            <div class="settings-section">
                <h4 style="color: #fb0;">Graphics</h4>
                <div class="setting-row">
                    <span>Particle Quality</span>
                    <select id="particle-quality" onchange="setParticleQuality(this.value)">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span>Shadows</span>
                    <button id="shadow-toggle" class="toggle-btn" onclick="toggleShadows()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Screen Shake</span>
                    <button id="shake-toggle" class="toggle-btn" onclick="toggleScreenShake()">ON</button>
                </div>
            </div>

            <!-- Game Section -->
            <div class="settings-section">
                <h4 style="color: #0f0;">Game</h4>
                <div class="setting-row">
                    <span>Show Hints</span>
                    <button id="hints-toggle" class="toggle-btn" onclick="toggleHints()">ON</button>
                </div>
                <button class="action-btn" onclick="showTutorial(); closeSettingsModal();" style="width: 100%; margin-top: 10px;">Show Tutorial</button>
            </div>

            <!-- Save Info -->
            <p style="color: #666; font-size: 11px; margin-top: 10px; text-align: center;">
                Last saved: <span id="last-save-time">Never</span>
            </p>
        </div>
    </div>

    <!-- v4.7: Welcome Back Modal -->
    <div id="welcome-back-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-title" style="color: #ffd700;">Welcome Back!</div>
            <p id="welcome-back-message" style="color: #0ff; font-size: 16px; margin: 15px 0;"></p>
            <p id="welcome-back-time" style="color: #888; font-size: 12px; margin-bottom: 20px;"></p>

            <div id="welcome-back-rewards" style="background: rgba(0,255,255,0.1); border: 1px solid #0ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0ff; margin: 0 0 10px;">Your Rewards:</h4>
                <div id="welcome-back-rewards-list" style="text-align: left;"></div>
            </div>

            <button class="action-btn" onclick="claimWelcomeBackRewards()" style="width: 100%; padding: 12px; font-size: 16px; background: linear-gradient(135deg, #ffd700, #ff8800);">
                Claim Rewards!
            </button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="stats-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeStatsModal()">&times;</button>
            <div class="modal-title">Player Statistics</div>

            <!-- v4.2: Player Rank Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(0,255,255,0.1)); border: 1px solid #ffd700; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <h3 style="color: #ffd700; margin: 0 0 10px; font-size: 16px;">Player Rank</h3>
                <div class="stat-row"><span>Current Rank</span><span id="stat-rank" style="font-weight: bold;">Novice Explorer</span></div>
                <div class="stat-row"><span>Total Points</span><span id="stat-points">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #888;">
                    <span style="color: #aaa;">Special Titles: </span><span id="special-titles">None yet</span>
                </div>
            </div>

            <div class="stats-section">
                <h3 style="color: #0ff; margin: 15px 0 10px; font-size: 14px;">Exploration</h3>
                <div class="stat-row"><span>Planets Visited</span><span id="stat-planets">0 / 60</span></div>
                <div class="stat-row"><span>POIs Discovered</span><span id="stat-pois">0</span></div>
                <div class="stat-row"><span>Total Playtime</span><span id="stat-playtime">0h 0m</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #fb0; margin: 15px 0 10px; font-size: 14px;">Gathering</h3>
                <div class="stat-row"><span>Trees Chopped</span><span id="stat-trees">0</span></div>
                <div class="stat-row"><span>Ore Mined</span><span id="stat-ore">0</span></div>
                <div class="stat-row"><span>Fish Caught</span><span id="stat-fish">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #f44; margin: 15px 0 10px; font-size: 14px;">Combat</h3>
                <div class="stat-row"><span>Enemies Defeated</span><span id="stat-mobs">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #a0f; margin: 15px 0 10px; font-size: 14px;">Crafting</h3>
                <div class="stat-row"><span>Items Crafted</span><span id="stat-crafted">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #ffd700; margin: 15px 0 10px; font-size: 14px;">Achievements</h3>
                <div id="achievements-list" class="achievements-grid"></div>
            </div>

            <!-- v4.4: Leaderboard Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,200,0,0.1)); border: 1px solid #ff8800; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #ff8800; margin: 0 0 10px; font-size: 14px;">Leaderboard</h3>
                <div id="leaderboard-list" style="font-size: 12px;"></div>
            </div>

            <!-- v4.4: Prestige Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(150,0,255,0.1), rgba(0,200,255,0.1)); border: 1px solid #aa44ff; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #aa44ff; margin: 0 0 10px; font-size: 14px;">Prestige System</h3>
                <div class="stat-row"><span>Prestige Level</span><span id="prestige-level" style="color: #aa44ff; font-weight: bold;">0</span></div>
                <div class="stat-row"><span>XP Multiplier</span><span id="prestige-xp">x1.0</span></div>
                <div class="stat-row"><span>Lifetime Points</span><span id="prestige-lifetime">0</span></div>
                <div id="prestige-progress" style="margin-top: 10px; font-size: 11px; color: #888;"></div>
                <button id="prestige-btn" onclick="performPrestige()" style="display: none; margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, #aa44ff, #6644ff); border: none; border-radius: 4px; color: #fff; cursor: pointer; width: 100%;">PRESTIGE NOW</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === LEVIATHAN: OMNIVERSE v4.5 ===
        // Enhanced with local-first principles: localStorage persistence & JSON import/export
        // v4.0: Performance optimizations, audio system, particle effects, improved UX
        // v4.1: Achievement system, daily challenges, statistics panel, visual enhancements
        // v4.2: Enemy variety, skill bonuses, POI system, player ranks, combat improvements
        // v4.3: Boss encounters, mobile touch controls, ambient audio, notification queue
        // v4.4: Hit-stop combat, environmental particles, local leaderboard, prestige system, fog of war
        // v4.5: Attack telegraphing, player dodge, recipe discovery, settings panel, boss spawn gates
        // v4.6: Settings persistence, elemental status effects, parry/counter system
        // v4.7: Elite enemy system with affixes, elite gear crafting, session rewards, adaptive performance
        // v4.8: Combo attack system, combat abilities (Q/E/R), ability cooldown UI, item tooltips

        const APP_NAME = 'leviathan-omniverse';
        const VERSION = '4.8.0';

        // --- AUDIO SYSTEM (Web Audio API - No external dependencies) ---
        const AudioSystem = {
            ctx: null,
            enabled: true,
            masterVolume: 0.3,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone(freq, duration, type = 'sine', volume = 1) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(this.masterVolume * volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain).connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            hit() { this.playTone(200, 0.08, 'square', 0.5); },
            collect() { this.playTone(600, 0.12, 'sine', 0.6); },
            damage() { this.playTone(80, 0.15, 'sawtooth', 0.7); },
            kill() {
                this.playTone(150, 0.1, 'square', 0.5);
                setTimeout(() => this.playTone(100, 0.15, 'square', 0.4), 50);
            },
            // v4.7: Explosion sound for explosive elite death
            explosion() {
                this.playTone(80, 0.3, 'sawtooth', 0.6);
                setTimeout(() => this.playTone(60, 0.2, 'sawtooth', 0.4), 50);
                setTimeout(() => this.playTone(40, 0.15, 'square', 0.3), 100);
            },
            levelUp() {
                [400, 500, 600, 800].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.15, 'sine', 0.5), i * 80);
                });
            },
            craft() { this.playTone(440, 0.1, 'triangle', 0.4); },
            click() { this.playTone(800, 0.03, 'sine', 0.2); },
            error() { this.playTone(100, 0.2, 'sawtooth', 0.3); },
            heal() { this.playTone(520, 0.2, 'sine', 0.4); },
            // v4.5: Dodge and telegraph sounds
            dodge() { this.playTone(300, 0.08, 'sine', 0.4); this.playTone(450, 0.06, 'sine', 0.3); },
            telegraph() { this.playTone(150, 0.1, 'square', 0.25); },

            // v4.3: Ambient Audio System
            ambientNode: null,
            ambientGain: null,
            currentBiome: null,

            // Biome-specific ambient audio configurations
            biomeAmbient: {
                Terra: { baseFreq: 80, modFreq: 0.3, type: 'sine', volume: 0.08 },
                Desert: { baseFreq: 120, modFreq: 0.1, type: 'sine', volume: 0.06 },
                Ice: { baseFreq: 200, modFreq: 0.5, type: 'sine', volume: 0.07 },
                Volcanic: { baseFreq: 60, modFreq: 0.2, type: 'triangle', volume: 0.09 },
                Alien: { baseFreq: 150, modFreq: 0.8, type: 'sawtooth', volume: 0.05 }
            },

            startAmbient(biome) {
                if (!this.enabled || !this.ctx || this.currentBiome === biome) return;
                this.stopAmbient();
                this.currentBiome = biome;
                this.resume();

                const config = this.biomeAmbient[biome] || this.biomeAmbient.Terra;

                // Create ambient drone
                this.ambientNode = this.ctx.createOscillator();
                this.ambientGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                // LFO for subtle modulation
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = config.modFreq;
                lfoGain.gain.value = config.baseFreq * 0.1;
                lfo.connect(lfoGain);
                lfoGain.connect(this.ambientNode.frequency);
                lfo.start();

                this.ambientNode.type = config.type;
                this.ambientNode.frequency.value = config.baseFreq;

                filter.type = 'lowpass';
                filter.frequency.value = 300;
                filter.Q.value = 1;

                this.ambientGain.gain.value = config.volume * this.masterVolume;

                this.ambientNode.connect(filter);
                filter.connect(this.ambientGain);
                this.ambientGain.connect(this.ctx.destination);
                this.ambientNode.start();

                // Store LFO for cleanup
                this.ambientLfo = lfo;
                this.ambientLfoGain = lfoGain;
            },

            stopAmbient() {
                if (this.ambientNode) {
                    try {
                        this.ambientNode.stop();
                        this.ambientNode.disconnect();
                        if (this.ambientLfo) {
                            this.ambientLfo.stop();
                            this.ambientLfo.disconnect();
                        }
                    } catch (e) {}
                    this.ambientNode = null;
                    this.ambientLfo = null;
                    this.currentBiome = null;
                }
            },

            bossSpawn() {
                // Dramatic boss spawn sound
                [100, 80, 60, 40].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.3, 'sawtooth', 0.6), i * 100);
                });
            },

            // v4.5: Dodge and telegraph sounds
            dodge() {
                this.playTone(400, 0.08, 'sine', 0.3);
                this.playTone(600, 0.06, 'sine', 0.2);
            },
            telegraph() {
                this.playTone(200, 0.15, 'square', 0.2);
            },
            recipeDiscovered() {
                [600, 800, 1000].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.12, 'triangle', 0.4), i * 60);
                });
            }
        };

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 200;
            }

            emit(position, count, color, options = {}) {
                const spread = options.spread || 3;
                const lifetime = options.lifetime || 1000;
                const size = options.size || 0.2;
                const gravity = options.gravity !== undefined ? options.gravity : 10;

                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(size, 4, 4),
                            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * spread,
                            Math.random() * spread * 0.8 + spread * 0.2,
                            (Math.random() - 0.5) * spread
                        ),
                        lifetime,
                        startTime: performance.now(),
                        gravity
                    };
                    particle.mesh.position.copy(position);
                    particle.mesh.position.y += 1;
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }

            update(dt) {
                const now = performance.now();
                this.particles = this.particles.filter(p => {
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.lifetime;

                    if (progress >= 1) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    // Physics
                    p.velocity.y -= p.gravity * dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                    p.mesh.material.opacity = 1 - progress;
                    p.mesh.scale.setScalar(1 - progress * 0.5);

                    return true;
                });
            }
        }

        let particles;

        // v4.4: Hit-Stop System - Freezes game briefly on impacts for satisfying combat
        let hitStopUntil = 0;
        const HIT_STOP_LIGHT = 30;   // Normal hits (ms)
        const HIT_STOP_HEAVY = 80;   // Kills (ms)
        const HIT_STOP_BOSS = 150;   // Boss impacts (ms)

        function triggerHitStop(duration) {
            hitStopUntil = performance.now() + duration;
        }

        // v4.4: Enhanced Hit Flash
        function flashTargetHit(target, flashColor = 0xffffff) {
            const originalMaterials = [];
            target.traverse(child => {
                if (child.material && child.material.color) {
                    originalMaterials.push({
                        mesh: child,
                        color: child.material.color.getHex(),
                        emissive: child.material.emissive?.getHex() || 0,
                        emissiveIntensity: child.material.emissiveIntensity || 0
                    });
                    child.material.color.setHex(flashColor);
                    if (child.material.emissive) {
                        child.material.emissive.setHex(flashColor);
                        child.material.emissiveIntensity = 1;
                    }
                }
            });

            setTimeout(() => {
                originalMaterials.forEach(data => {
                    if (data.mesh.material) {
                        data.mesh.material.color.setHex(data.color);
                        if (data.mesh.material.emissive) {
                            data.mesh.material.emissive.setHex(data.emissive);
                            data.mesh.material.emissiveIntensity = data.emissiveIntensity;
                        }
                    }
                });
            }, 50);
        }

        // v4.4: Environmental Particle System
        class EnvironmentParticles {
            constructor() {
                this.particles = [];
                this.maxParticles = 60;
                this.currentBiome = null;
                this.biomeConfigs = {
                    Terra: { color: 0x88aa44, count: 20, speed: 1.5, type: 'leaves', gravity: 2 },
                    Desert: { color: 0xddcc99, count: 30, speed: 3, type: 'dust', gravity: 0.5 },
                    Ice: { color: 0xeeffff, count: 40, speed: 0.8, type: 'snow', gravity: 1 },
                    Volcanic: { color: 0xff4400, count: 25, speed: 4, type: 'embers', gravity: -3 },
                    Alien: { color: 0xff00ff, count: 20, speed: 1, type: 'spores', gravity: -0.5 }
                };
            }

            startBiome(biome) {
                if (this.currentBiome === biome) return;
                this.stop();
                this.currentBiome = biome;
            }

            stop() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                this.particles = [];
                this.currentBiome = null;
            }

            update(dt, playerPos) {
                if (!this.currentBiome) return;
                const config = this.biomeConfigs[this.currentBiome];
                if (!config) return;

                // Spawn new particles near player
                while (this.particles.length < config.count) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * 20;
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 4, 4),
                            new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.6 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * config.speed,
                            config.gravity > 0 ? -Math.abs(config.gravity) : config.gravity,
                            (Math.random() - 0.5) * config.speed
                        ),
                        life: 5 + Math.random() * 5
                    };
                    particle.mesh.position.set(
                        playerPos.x + Math.cos(angle) * dist,
                        playerPos.y + 5 + Math.random() * 10,
                        playerPos.z + Math.sin(angle) * dist
                    );
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.life -= dt;
                    if (p.life <= 0 || p.mesh.position.y < 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    // Sway for leaves/snow
                    if (config.type === 'leaves' || config.type === 'snow') {
                        p.mesh.position.x += Math.sin(performance.now() * 0.002 + p.life) * 0.02;
                    }

                    // Pulse for spores
                    if (config.type === 'spores') {
                        p.mesh.material.opacity = 0.3 + Math.sin(performance.now() * 0.005) * 0.3;
                    }

                    return true;
                });
            }
        }

        let envParticles;

        // v4.5: Player Dodge System
        const DODGE_CONFIG = {
            DISTANCE: 6,
            DURATION: 180,       // ms
            COOLDOWN: 600,       // ms
            IFRAMES: 150         // invincibility duration in ms
        };

        let dodgeState = {
            active: false,
            direction: new THREE.Vector3(),
            startTime: 0,
            cooldownEnd: 0,
            iframesEnd: 0
        };

        // v4.6: Parry/Counter System
        const PARRY_CONFIG = {
            WINDOW: 250,          // ms before attack lands to trigger parry
            STUN_DURATION: 1500,  // ms enemy is stunned
            CRIT_MULTIPLIER: 2.5, // damage multiplier during crit window
            CRIT_WINDOW: 2000     // ms player has to land crits
        };

        let parryState = {
            critWindowEnd: 0,
            lastParryTime: 0
        };

        // v4.8: Combo Attack System
        const COMBO_CONFIG = {
            WINDOW: 1200,           // ms to chain next hit
            MAX_HITS: 5,            // maximum combo length
            DAMAGE_MULT: [1.0, 1.15, 1.35, 1.6, 2.0],  // damage multiplier per hit
            FINISHER_BONUS: 1.5,    // extra multiplier on max combo hit
            BREAK_ON_DAMAGE: true   // combo breaks if player takes damage
        };

        let comboState = {
            count: 0,
            lastHitTime: 0,
            active: false
        };

        function updateCombo(hitTime) {
            const timeSinceLastHit = hitTime - comboState.lastHitTime;

            if (comboState.active && timeSinceLastHit <= COMBO_CONFIG.WINDOW) {
                // Continue combo
                comboState.count = Math.min(comboState.count + 1, COMBO_CONFIG.MAX_HITS - 1);
            } else {
                // Start new combo
                comboState.count = 0;
                comboState.active = true;
            }
            comboState.lastHitTime = hitTime;

            return comboState.count;
        }

        function getComboMultiplier() {
            if (!comboState.active) return 1.0;
            let mult = COMBO_CONFIG.DAMAGE_MULT[comboState.count] || COMBO_CONFIG.DAMAGE_MULT[COMBO_CONFIG.MAX_HITS - 1];
            // Finisher bonus at max combo
            if (comboState.count >= COMBO_CONFIG.MAX_HITS - 1) {
                mult *= COMBO_CONFIG.FINISHER_BONUS;
            }
            return mult;
        }

        function breakCombo() {
            if (comboState.active) {
                comboState.active = false;
                comboState.count = 0;
            }
        }

        // v4.8: Combat Abilities System
        const COMBAT_ABILITIES = {
            powerStrike: {
                name: 'Power Strike',
                key: 'Q',
                icon: '‚öîÔ∏è',
                cooldown: 8000,       // 8 seconds
                unlockLevel: 3,       // Combat level 3
                damageMultiplier: 3,
                description: '3x damage attack'
            },
            whirlwind: {
                name: 'Whirlwind',
                key: 'E',
                icon: 'üåÄ',
                cooldown: 12000,      // 12 seconds
                unlockLevel: 5,       // Combat level 5
                radius: 8,
                damageMultiplier: 1.5,
                description: 'AoE damage to all nearby enemies'
            },
            warcry: {
                name: 'War Cry',
                key: 'R',
                icon: 'üì¢',
                cooldown: 20000,      // 20 seconds
                unlockLevel: 7,       // Combat level 7
                duration: 5000,       // 5 second buff
                damageBoost: 1.5,
                description: '+50% damage for 5 seconds'
            }
        };

        let abilityState = {
            powerStrike: { lastUsed: 0 },
            whirlwind: { lastUsed: 0 },
            warcry: { lastUsed: 0, activeUntil: 0 }
        };

        function isAbilityUnlocked(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return gameData.skills.combat.level >= ability.unlockLevel;
        }

        function isAbilityReady(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return performance.now() - abilityState[abilityKey].lastUsed >= ability.cooldown;
        }

        function getAbilityCooldownRemaining(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            const elapsed = performance.now() - abilityState[abilityKey].lastUsed;
            return Math.max(0, ability.cooldown - elapsed);
        }

        function useAbility(abilityKey) {
            if (!isAbilityUnlocked(abilityKey)) {
                showNotification(`${COMBAT_ABILITIES[abilityKey].name} unlocks at Combat Lv ${COMBAT_ABILITIES[abilityKey].unlockLevel}`, 'warning');
                return false;
            }
            if (!isAbilityReady(abilityKey)) {
                return false;
            }
            if (mode !== 'world' || !worldState.player) return false;

            const ability = COMBAT_ABILITIES[abilityKey];
            const p = worldState.player;
            const now = performance.now();

            abilityState[abilityKey].lastUsed = now;

            if (abilityKey === 'powerStrike') {
                // Find nearest mob and deal massive damage
                let nearestMob = null;
                let nearestDist = 5; // Range limit
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });
                if (nearestMob) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `${ability.icon} POWER STRIKE! -${damage}`, '#ff4400');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.0);
                    if (particles) particles.emit(nearestMob.position, 25, 0xff4400, { spread: 4, lifetime: 800 });
                    AudioSystem.hit();
                    // Check kill
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                } else {
                    showNotification('No enemy in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0; // Refund cooldown
                    return false;
                }
            } else if (abilityKey === 'whirlwind') {
                // AoE damage to all nearby mobs
                let hitCount = 0;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < ability.radius) {
                        const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `${ability.icon} -${damage}`, '#00ffff');
                        hitCount++;
                        if (mob.userData.hp <= 0) {
                            // Queue for death handling
                            setTimeout(() => {
                                if (mob.userData.hp <= 0) performAction(mob);
                            }, 100);
                        }
                    }
                });
                if (hitCount > 0) {
                    spawnFloater(p.position, `${ability.icon} WHIRLWIND! x${hitCount}`, '#00ffff');
                    triggerHitStop(HIT_STOP_HEAVY);
                    screenShake(0.8);
                    if (particles) particles.emit(p.position, 40, 0x00ffff, { spread: ability.radius, lifetime: 600 });
                    AudioSystem.hit();
                } else {
                    showNotification('No enemies nearby!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'warcry') {
                // Activate damage buff
                abilityState.warcry.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} WAR CRY!`, '#ff8800');
                showNotification(`+${Math.floor((ability.damageBoost - 1) * 100)}% damage for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 30, 0xff8800, { spread: 6, lifetime: 1000 });
                AudioSystem.levelUp();
            }

            updateAbilityUI();
            return true;
        }

        function isWarcryActive() {
            return performance.now() < abilityState.warcry.activeUntil;
        }

        function startDodge() {
            if (dodgeState.active || performance.now() < dodgeState.cooldownEnd) return false;
            if (mode !== 'world' || !worldState.player) return false;

            const p = worldState.player;
            dodgeState.active = true;
            dodgeState.startTime = performance.now();
            dodgeState.cooldownEnd = performance.now() + DODGE_CONFIG.COOLDOWN;
            dodgeState.iframesEnd = performance.now() + DODGE_CONFIG.IFRAMES;

            // Direction based on current input or facing
            dodgeState.direction.set(0, 0, 0);
            if (keys.w) dodgeState.direction.z -= 1;
            if (keys.s) dodgeState.direction.z += 1;
            if (keys.a) dodgeState.direction.x -= 1;
            if (keys.d) dodgeState.direction.x += 1;

            // Also check joystick
            if (dodgeState.direction.length() < 0.1 && joystickActive) {
                dodgeState.direction.set(joystickInput.x, 0, joystickInput.y);
            }

            // Default to backward if no input
            if (dodgeState.direction.length() < 0.1) {
                dodgeState.direction.set(-Math.sin(p.rotation.y), 0, -Math.cos(p.rotation.y));
            }
            dodgeState.direction.normalize();

            AudioSystem.dodge();
            if (particles) particles.emit(p.position, 10, 0x88ffff, { spread: 2, lifetime: 300, gravity: 0 });

            // v4.6: Check for parry opportunity
            checkParryTiming();

            return true;
        }

        function updateDodge(dt) {
            if (!dodgeState.active) return;

            const elapsed = performance.now() - dodgeState.startTime;
            const progress = elapsed / DODGE_CONFIG.DURATION;

            if (progress < 1) {
                const eased = 1 - Math.pow(1 - progress, 3);
                const moveAmount = (1 - eased) * DODGE_CONFIG.DISTANCE * dt * 10;
                worldState.player.position.add(dodgeState.direction.clone().multiplyScalar(moveAmount));
            } else {
                dodgeState.active = false;
            }
        }

        function isInvincible() {
            return performance.now() < dodgeState.iframesEnd;
        }

        // v4.6: Check if dodge was timed for a parry
        function checkParryTiming() {
            if (!worldState || !worldState.mobs) return;

            const now = performance.now();
            let parried = false;

            worldState.mobs.forEach(mob => {
                if (mob.userData.telegraphing && !mob.userData.stunned) {
                    const timeToAttack = mob.userData.telegraphEnd - now;
                    // Check if dodge was in the parry window (last PARRY_CONFIG.WINDOW ms before attack)
                    if (timeToAttack > 0 && timeToAttack <= PARRY_CONFIG.WINDOW) {
                        // Perfect parry!
                        mob.userData.stunned = true;
                        mob.userData.stunEnd = now + PARRY_CONFIG.STUN_DURATION;
                        mob.userData.telegraphing = false;

                        // Visual feedback
                        mob.material.emissive.setHex(0xffff00); // Yellow stun
                        mob.scale.setScalar(1);
                        spawnFloater(mob.position, '‚ö° PARRY!', '#ffd700');

                        parried = true;
                    }
                }
            });

            if (parried) {
                // Grant crit window
                parryState.critWindowEnd = now + PARRY_CONFIG.CRIT_WINDOW;
                parryState.lastParryTime = now;

                // Audio feedback
                AudioSystem.levelUp();

                // Screen effect
                screenShake(0.3);
                if (particles) particles.emit(worldState.player.position, 25, 0xffd700, { spread: 4, lifetime: 500 });

                showNotification('PERFECT PARRY! Critical hits enabled!');
            }
        }

        // v4.6: Check if in crit window from parry
        function isInCritWindow() {
            return performance.now() < parryState.critWindowEnd;
        }

        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            WORLD_SIZE: 100,
            TILE_SIZE: 2,
            PLAYER_MAX_HP: 100,
            MOB_DAMAGE: 5,
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            // New v4.0 constants
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 2,
            MOB_ATTACK_COOLDOWN: 1500,
            INTERACTION_RANGE: 3.5,
            INTERACTION_COOLDOWN: 400, // ms between actions
            MOVEMENT_THRESHOLD: 0.5,
            SCREEN_SHAKE_INTENSITY: 0.5,
            SCREEN_SHAKE_DURATION: 150
        };

        // v4.7: Player state for status effects
        const playerState = {
            chilled: false,
            chilledEnd: 0,
            moveSpeedMult: 1.0
        };

        // --- PRE-ALLOCATED REUSABLE OBJECTS ---
        const _tempVec3A = new THREE.Vector3();
        const _tempVec3B = new THREE.Vector3();
        const _camOffset = new THREE.Vector3(0, 25, 25);

        // --- SCREEN EFFECTS ---
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0;
        let originalCameraPos = null;

        function screenShake(intensity = CONFIG.SCREEN_SHAKE_INTENSITY) {
            // v4.6: Check settings
            if (gameData.settings && !gameData.settings.screenShakeEnabled) return;
            screenShakeIntensity = intensity;
            screenShakeDecay = intensity / (CONFIG.SCREEN_SHAKE_DURATION / 16);
            if (!originalCameraPos) originalCameraPos = new THREE.Vector3();
        }

        function updateScreenShake() {
            if (screenShakeIntensity > 0 && mode === 'world') {
                camera.position.x += (Math.random() - 0.5) * screenShakeIntensity;
                camera.position.y += (Math.random() - 0.5) * screenShakeIntensity;
                screenShakeIntensity -= screenShakeDecay;
                if (screenShakeIntensity < 0) screenShakeIntensity = 0;
            }
        }

        // Damage flash overlay
        function flashDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.4';
                setTimeout(() => overlay.style.opacity = '0', 150);
            }
        }

        // v4.1: Create nebula clouds for galaxy atmosphere
        function createNebulae() {
            const nebulaColors = [0xff3366, 0x3366ff, 0x66ff33, 0xff6633, 0x9933ff, 0x33ffff];
            const nebulaCount = 6;

            for (let i = 0; i < nebulaCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Create procedural nebula with radial gradients
                const color = nebulaColors[i % nebulaColors.length];
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;

                // Multiple overlapping gradients for organic look
                for (let j = 0; j < 3; j++) {
                    const cx = 80 + Math.random() * 96;
                    const cy = 80 + Math.random() * 96;
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100 + Math.random() * 56);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.25)`);
                    gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.1)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                }

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    opacity: 0.6
                });

                const geometry = new THREE.PlaneGeometry(600, 600);
                const nebula = new THREE.Mesh(geometry, material);

                // Position nebulae around the galaxy
                const angle = (i / nebulaCount) * Math.PI * 2;
                const dist = 400 + Math.random() * 600;
                nebula.position.set(
                    Math.cos(angle) * dist,
                    (Math.random() - 0.5) * 300,
                    Math.sin(angle) * dist
                );

                // Random rotation
                nebula.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                scene.add(nebula);
            }
        }

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, water: 0x2244aa, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, water: 0x446688, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, water: 0x88aadd, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, water: 0x8800ff, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, water: 0xff4400, name: 'Magma' }
        };

        // v4.2: Enemy Variety System - Biome-specific enemies
        // v4.5: Added attack telegraphing parameters
        const ENEMY_TYPES = {
            Slime: {
                hp: 10, damage: 5, speed: 4, color: 0x44ff44, emissive: 0x003300,
                drops: ['Slime'], xp: 100, biomes: ['Terra', 'Alien'],
                attackWindup: 800, attackRange: 2.5  // v4.5: Telegraph timing
            },
            Scorpion: {
                hp: 15, damage: 8, speed: 5, color: 0xdd9944, emissive: 0x442200,
                drops: ['Chitin'], xp: 150, biomes: ['Desert'],
                attackWindup: 600, attackRange: 3.0
            },
            IceWisp: {
                hp: 8, damage: 6, speed: 7, color: 0x88ccff, emissive: 0x002244,
                drops: ['Frost Shard'], xp: 120, biomes: ['Ice'],
                attackWindup: 500, attackRange: 4.0  // Fast ranged
            },
            MagmaCore: {
                hp: 20, damage: 10, speed: 3, color: 0xff4400, emissive: 0x440000,
                drops: ['Magma Gem'], xp: 180, biomes: ['Volcanic'],
                attackWindup: 1200, attackRange: 3.5  // Slow heavy
            },
            VoidSpawn: {
                hp: 25, damage: 12, speed: 5, color: 0x8800ff, emissive: 0x220044,
                drops: ['Void Fragment'], xp: 250, biomes: ['Alien'],
                attackWindup: 700, attackRange: 3.0
            }
        };

        // v4.6: Elemental Status Effects System
        const STATUS_EFFECTS = {
            ice: {
                name: 'Frozen',
                duration: 3000,
                color: 0x88ccff,
                icon: '‚ùÑÔ∏è',
                speedMod: 0.3  // Slows to 30% speed
            },
            fire: {
                name: 'Burning',
                duration: 4000,
                color: 0xff4400,
                icon: 'üî•',
                tickRate: 500,
                tickDamage: 2
            },
            void: {
                name: 'Weakened',
                duration: 5000,
                color: 0x8800ff,
                icon: 'üíú',
                damageMod: 0.5  // Enemy deals 50% damage
            },
            cosmic: {
                name: 'Annihilated',
                duration: 3000,
                color: 0xffd700,
                icon: '‚ú®',
                tickRate: 250,
                tickDamage: 5,
                speedMod: 0.5
            }
        };

        // v4.7: Elite Enemy System - Affixes that modify enemy behavior
        const ELITE_AFFIXES = {
            swift: {
                name: 'Swift',
                prefix: '‚ö°',
                color: 0x00ffff,
                speedMult: 1.8,
                hpMult: 1.2,
                damageMult: 1.0,
                description: 'Moves much faster'
            },
            armored: {
                name: 'Armored',
                prefix: 'üõ°Ô∏è',
                color: 0x888888,
                speedMult: 0.8,
                hpMult: 3.0,
                damageMult: 1.0,
                description: 'Extremely tough'
            },
            vampiric: {
                name: 'Vampiric',
                prefix: 'ü¶á',
                color: 0x990000,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 1.2,
                lifesteal: 0.3,
                description: 'Heals on hit'
            },
            explosive: {
                name: 'Explosive',
                prefix: 'üí•',
                color: 0xff6600,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 0.8,
                explodeOnDeath: true,
                description: 'Explodes on death'
            },
            berserker: {
                name: 'Berserker',
                prefix: 'üò§',
                color: 0xff0000,
                speedMult: 1.2,
                hpMult: 1.0,
                damageMult: 2.0,
                description: 'Deals double damage'
            },
            regenerating: {
                name: 'Regenerating',
                prefix: 'üíö',
                color: 0x00ff00,
                speedMult: 1.0,
                hpMult: 1.8,
                damageMult: 1.0,
                regenRate: 0.02,
                description: 'Regenerates health'
            },
            teleporter: {
                name: 'Teleporter',
                prefix: 'üåÄ',
                color: 0x9900ff,
                speedMult: 0.9,
                hpMult: 1.3,
                damageMult: 1.3,
                canTeleport: true,
                description: 'Blinks around'
            },
            frozen: {
                name: 'Frozen',
                prefix: '‚ùÑÔ∏è',
                color: 0x88ddff,
                speedMult: 0.7,
                hpMult: 2.0,
                damageMult: 1.1,
                chillingAura: true,
                description: 'Slows nearby player'
            }
        };

        const ELITE_CONFIG = {
            spawnChance: 0.15,        // 15% chance for elite
            minWorldLevel: 2,         // Only spawn in world level 2+
            essenceDropChance: 0.8,   // 80% chance to drop elite essence
            bonusXpMult: 2.5,         // 2.5x XP from elites
            bonusDropMult: 2          // Double drops from elites
        };

        // v4.7: Session Rewards - Welcome back bonuses
        const SESSION_REWARDS = {
            tiers: [
                { minHours: 1, xpBonus: 50, resources: { 'Slime': 2 }, message: 'Quick break bonus!' },
                { minHours: 4, xpBonus: 150, resources: { 'Ore': 3, 'Log': 3 }, message: 'Gone a while bonus!' },
                { minHours: 12, xpBonus: 400, resources: { 'Ore': 8, 'Log': 8, 'Health Potion': 2 }, message: 'Half-day bonus!' },
                { minHours: 24, xpBonus: 1000, resources: { 'Crystal': 2, 'Mystic Orb': 1, 'Health Potion': 3 }, message: 'Daily login bonus!' },
                { minHours: 72, xpBonus: 3000, resources: { 'Elite Essence': 5, 'Legendary Core': 1, 'Super Potion': 2 }, message: 'We missed you bonus!' }
            ],
            maxOfflineHours: 168 // Cap at 1 week
        };

        // v4.6: Get equipped weapon element
        function getEquippedElement() {
            const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade'];
            for (const weapon of weapons) {
                if (hasItem(weapon)) {
                    return ITEMS[weapon].element || null;
                }
            }
            return null;
        }

        // v4.6: Apply status effect to mob
        function applyStatusEffect(mob, element) {
            const effect = STATUS_EFFECTS[element];
            if (!effect) return;

            const data = mob.userData;
            data.statusEffects = data.statusEffects || {};

            // Only apply if not already affected by this element
            if (data.statusEffects[element]) return;

            data.statusEffects[element] = {
                endTime: performance.now() + effect.duration,
                lastTick: performance.now()
            };

            // Apply immediate effects
            if (effect.speedMod) {
                data.speedMultiplier = (data.speedMultiplier || 1) * effect.speedMod;
            }
            if (effect.damageMod) {
                data.damageMultiplier = (data.damageMultiplier || 1) * effect.damageMod;
            }

            // Visual feedback
            mob.material.emissive.setHex(effect.color);
            spawnFloater(mob.position, effect.icon + ' ' + effect.name, '#' + effect.color.toString(16).padStart(6, '0'));
            AudioSystem.hit();
        }

        // v4.6: Update status effects for mob
        function updateMobStatusEffects(mob, time) {
            const data = mob.userData;
            if (!data.statusEffects) return;

            for (const [element, state] of Object.entries(data.statusEffects)) {
                const effect = STATUS_EFFECTS[element];
                if (!effect) continue;

                // Apply DoT
                if (effect.tickDamage && time - state.lastTick >= effect.tickRate) {
                    data.hp -= effect.tickDamage;
                    state.lastTick = time;
                    spawnFloater(mob.position, `-${effect.tickDamage}`, '#' + effect.color.toString(16).padStart(6, '0'));

                    // Check for death by status effect
                    if (data.hp <= 0) {
                        // Will be handled in main mob loop
                    }
                }

                // Check expiration
                if (time >= state.endTime) {
                    // Clear effects
                    if (effect.speedMod) {
                        data.speedMultiplier = (data.speedMultiplier || 1) / effect.speedMod;
                    }
                    if (effect.damageMod) {
                        data.damageMultiplier = (data.damageMultiplier || 1) / effect.damageMod;
                    }
                    delete data.statusEffects[element];

                    // Restore emissive color if no more effects
                    if (Object.keys(data.statusEffects).length === 0) {
                        const originalEmissive = ENEMY_TYPES[data.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }
            }
        }

        // v4.3: Boss Encounter System
        // v4.5: Added gear check requirements and increased mob kill thresholds
        const BOSS_TYPES = {
            'Terra_Boss': {
                name: 'Ancient Guardian',
                hp: 100, damage: 15, speed: 2, scale: 2.5,
                color: 0x228b22, emissive: 0x114411,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Ancient Artifact', count: 3 }],
                xp: 1000, biome: 'Terra',
                spawnCondition: { mobsKilled: 8, minCombatLevel: 2 },
                attackWindup: 1000, attackRange: 4
            },
            'Desert_Boss': {
                name: 'Sandstorm Titan',
                hp: 120, damage: 18, speed: 3, scale: 2.8,
                color: 0xcc8844, emissive: 0x664422,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Chitin', count: 10 }],
                xp: 1200, biome: 'Desert',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 3, requiredItem: 'Sword' },
                attackWindup: 900, attackRange: 4.5
            },
            'Ice_Boss': {
                name: 'Frost Monarch',
                hp: 90, damage: 20, speed: 4, scale: 2.2,
                color: 0x88ddff, emissive: 0x4488aa,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Frost Shard', count: 10 }],
                xp: 1100, biome: 'Ice',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 4 },
                attackWindup: 700, attackRange: 5
            },
            'Volcanic_Boss': {
                name: 'Magma Colossus',
                hp: 150, damage: 25, speed: 1.5, scale: 3,
                color: 0xff4400, emissive: 0xaa2200,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Magma Gem', count: 10 }],
                xp: 1500, biome: 'Volcanic',
                spawnCondition: { mobsKilled: 12, minCombatLevel: 5, requiredItem: 'Frost Blade' },
                attackWindup: 1500, attackRange: 5
            },
            'Alien_Boss': {
                name: 'Void Leviathan',
                hp: 200, damage: 30, speed: 3, scale: 3.5,
                color: 0x8800ff, emissive: 0x440088,
                drops: [{ item: 'Boss Trophy', count: 2 }, { item: 'Void Fragment', count: 15 }, { item: 'Legendary Core', count: 1 }],
                xp: 2500, biome: 'Alien',
                spawnCondition: { mobsKilled: 15, minCombatLevel: 7, requiredItem: 'Magma Sword' },
                attackWindup: 800, attackRange: 6
            }
        };

        // v4.2: Points of Interest System
        const POI_TYPES = {
            'ancient_ruins': {
                name: 'Ancient Ruins', icon: 'üèõÔ∏è', rarity: 0.12,
                rewards: [{ item: 'Ancient Artifact', count: 1 }],
                xpBonus: 200, biomes: null
            },
            'crystal_cave': {
                name: 'Crystal Cavern', icon: 'üíé', rarity: 0.10,
                rewards: [{ item: 'Crystal', count: [2, 5] }],
                xpBonus: 150, biomes: ['Ice', 'Alien']
            },
            'oasis': {
                name: 'Hidden Oasis', icon: 'üå¥', rarity: 0.15,
                rewards: [{ item: 'Healing Spring', count: 1 }],
                xpBonus: 100, biomes: ['Desert']
            },
            'volcano_vent': {
                name: 'Volcanic Vent', icon: 'üåã', rarity: 0.12,
                rewards: [{ item: 'Obsidian', count: [1, 3] }],
                xpBonus: 175, biomes: ['Volcanic']
            },
            'crashed_ship': {
                name: 'Crashed Vessel', icon: 'üõ∏', rarity: 0.06,
                rewards: [{ item: 'Tech Fragment', count: 1 }, { item: 'Power Cell', count: 1 }],
                xpBonus: 300, biomes: null
            },
            'mystic_shrine': {
                name: 'Mystic Shrine', icon: '‚õ©Ô∏è', rarity: 0.08,
                rewards: [{ item: 'Mystic Orb', count: 1 }],
                xpBonus: 250, biomes: ['Terra', 'Alien']
            }
        };

        // v4.2: Player Ranks and Titles
        const PLAYER_RANKS = [
            { points: 0, title: 'Novice Explorer', color: '#888888' },
            { points: 100, title: 'Wanderer', color: '#44ff44' },
            { points: 500, title: 'Pathfinder', color: '#4488ff' },
            { points: 1500, title: 'Star Scout', color: '#ff8844' },
            { points: 5000, title: 'Galaxy Ranger', color: '#ff44ff' },
            { points: 15000, title: 'Cosmic Legend', color: '#ffd700' }
        ];

        const SPECIAL_TITLES = {
            'Slime Bane': { condition: (s, sk) => s.mobsKilled >= 100, color: '#ff4444' },
            'Master Lumberjack': { condition: (s, sk) => sk.wood.level >= 10, color: '#44aa44' },
            'Deep Miner': { condition: (s, sk) => sk.mining.level >= 10, color: '#888888' },
            'Cosmic Wanderer': { condition: (s, sk) => gameData.visitedPlanets.length >= 50, color: '#00ffff' },
            'Combat Master': { condition: (s, sk) => sk.combat.level >= 10, color: '#ff6644' },
            'Master Angler': { condition: (s, sk) => sk.fishing.level >= 10, color: '#4488ff' }
        };

        const ITEMS = {
            // Base resources
            'Log': { icon: 'ü™µ', stackable: true, maxStack: 99 },
            'Ore': { icon: 'ü™®', stackable: true, maxStack: 99 },
            'Slime': { icon: 'üü¢', stackable: true, maxStack: 99 },
            'Raw Fish': { icon: 'üêü', stackable: true, maxStack: 99 },
            'Cooked Fish': { icon: 'üçñ', stackable: true, maxStack: 99, heal: 20 },
            // v4.2: Biome-specific enemy drops
            'Chitin': { icon: 'ü¶Ç', stackable: true, maxStack: 99 },
            'Frost Shard': { icon: '‚ùÑÔ∏è', stackable: true, maxStack: 99 },
            'Magma Gem': { icon: 'üî•', stackable: true, maxStack: 99 },
            'Void Fragment': { icon: 'üåÄ', stackable: true, maxStack: 99 },
            // v4.2: POI rewards
            'Ancient Artifact': { icon: 'üè∫', stackable: true, maxStack: 20 },
            'Crystal': { icon: 'üí†', stackable: true, maxStack: 50 },
            'Healing Spring': { icon: 'üíß', stackable: true, maxStack: 10, heal: 100 },
            'Obsidian': { icon: 'üñ§', stackable: true, maxStack: 50 },
            'Tech Fragment': { icon: 'üîß', stackable: true, maxStack: 20 },
            'Power Cell': { icon: 'üîã', stackable: true, maxStack: 10 },
            'Mystic Orb': { icon: 'üîÆ', stackable: true, maxStack: 10 },
            // Tools
            'Pickaxe': { icon: '‚õèÔ∏è', stackable: false, miningBonus: 2 },
            'Sword': { icon: 'üó°Ô∏è', stackable: false, combatBonus: 5 },
            'Fishing Rod': { icon: 'üé£', stackable: false, fishingBonus: 2 },
            'Health Potion': { icon: 'üß™', stackable: true, maxStack: 10, heal: 50 },
            // v4.2: New craftables
            'Frost Blade': { icon: 'üó°Ô∏è', stackable: false, combatBonus: 8, element: 'ice' },
            'Magma Sword': { icon: 'üó°Ô∏è', stackable: false, combatBonus: 10, element: 'fire' },
            'Void Dagger': { icon: 'üó°Ô∏è', stackable: false, combatBonus: 12, element: 'void' },
            'Crystal Pickaxe': { icon: '‚õèÔ∏è', stackable: false, miningBonus: 3 },
            'Super Potion': { icon: 'üß™', stackable: true, maxStack: 10, heal: 100 },
            'Chitin Armor': { icon: 'üõ°Ô∏è', stackable: false, defenseBonus: 5 },
            // v4.3: Boss rewards
            'Boss Trophy': { icon: 'üèÜ', stackable: true, maxStack: 20 },
            'Legendary Core': { icon: 'üíé', stackable: true, maxStack: 5 },
            // v4.3: Legendary gear (requires boss materials)
            'Legendary Blade': { icon: '‚öîÔ∏è', stackable: false, combatBonus: 20, element: 'cosmic' },
            'Guardian Armor': { icon: 'üõ°Ô∏è', stackable: false, defenseBonus: 15 },
            // v4.7: Elite enemy drops
            'Elite Essence': { icon: 'üí†', stackable: true, maxStack: 99 },
            'Berserker Badge': { icon: 'üî¥', stackable: false, combatBonus: 15, attackSpeedMult: 1.3 },
            'Vampiric Fang': { icon: 'ü¶∑', stackable: false, combatBonus: 10, lifesteal: 0.15 },
            'Frost Heart': { icon: 'üíô', stackable: false, defenseBonus: 10, element: 'ice' }
        };

        const RECIPES = {
            'pickaxe': { result: 'Pickaxe', requires: { 'Ore': 3, 'Log': 2 } },
            'sword': { result: 'Sword', requires: { 'Ore': 5, 'Log': 1 } },
            'rod': { result: 'Fishing Rod', requires: { 'Log': 2 } },
            'cookedFish': { result: 'Cooked Fish', requires: { 'Raw Fish': 1 } },
            'potion': { result: 'Health Potion', requires: { 'Slime': 2 } },
            // v4.2: New recipes using biome materials
            'frostBlade': { result: 'Frost Blade', requires: { 'Ore': 8, 'Frost Shard': 5 }, craftingLevel: 5 },
            'magmaSword': { result: 'Magma Sword', requires: { 'Ore': 10, 'Magma Gem': 5 }, craftingLevel: 7 },
            'voidDagger': { result: 'Void Dagger', requires: { 'Ore': 12, 'Void Fragment': 5 }, craftingLevel: 10 },
            'crystalPickaxe': { result: 'Crystal Pickaxe', requires: { 'Ore': 6, 'Crystal': 3 }, craftingLevel: 6 },
            'superPotion': { result: 'Super Potion', requires: { 'Slime': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'chitinArmor': { result: 'Chitin Armor', requires: { 'Chitin': 10, 'Log': 5 }, craftingLevel: 4 },
            // v4.3: Legendary recipes (requires boss materials)
            'legendaryBlade': { result: 'Legendary Blade', requires: { 'Boss Trophy': 5, 'Legendary Core': 1, 'Ore': 20 }, craftingLevel: 15 },
            'guardianArmor': { result: 'Guardian Armor', requires: { 'Boss Trophy': 3, 'Chitin': 20, 'Crystal': 5 }, craftingLevel: 12 },
            // v4.7: Elite gear recipes
            'berserkerBadge': { result: 'Berserker Badge', requires: { 'Elite Essence': 10, 'Magma Gem': 3 }, craftingLevel: 10 },
            'vampiricFang': { result: 'Vampiric Fang', requires: { 'Elite Essence': 15, 'Void Fragment': 5 }, craftingLevel: 12 },
            'frostHeart': { result: 'Frost Heart', requires: { 'Elite Essence': 12, 'Frost Shard': 8, 'Crystal': 3 }, craftingLevel: 11 }
        };

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isTouchDevice = 'ontouchstart' in window;

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;
        let cycle = 0;

        // Floater pool for performance
        const floaterPool = [];
        const MAX_FLOATERS = 20;

        // RPG State
        let worldState = {
            player: null,
            terrain: [],
            interactables: [],
            fishingSpots: [],
            mobs: [],
            pois: [], // v4.2: Points of Interest
            sun: null,
            ambient: null,
            timeOfDay: 0,
            target: null,
            interactTarget: null,
            lastActionTime: 0, // v4.0: Cooldown-based interactions
            lastPlayerPos: null // v4.2: For distance tracking
        };

        // WASD Keyboard controls
        const keys = { w: false, a: false, s: false, d: false };

        // Persistent Game Data (saved to localStorage)
        let gameData = {
            version: VERSION,
            playtime: 0,
            lastPlayed: null,
            hasSeenTutorial: false, // v4.0: Tutorial tracking
            inventory: [],
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 },
                fishing: { level: 1, xp: 0 },
                cooking: { level: 1, xp: 0 },
                crafting: { level: 1, xp: 0 }
            },
            player: {
                hp: CONFIG.PLAYER_MAX_HP,
                maxHp: CONFIG.PLAYER_MAX_HP
            },
            visitedPlanets: [],
            statistics: {
                treesChopped: 0,
                oresMined: 0,
                mobsKilled: 0,
                fishCaught: 0,
                itemsCrafted: 0,
                fishCooked: 0,
                // v4.2: New stats
                poisDiscovered: 0,
                totalDamageDealt: 0,
                bossesDefeated: 0,
                distanceTraveled: 0
            },
            // v4.2: Player rank tracking
            playerRank: { points: 0, lastTitle: 'Novice Explorer' },
            // v4.2: Discovered POIs by planet
            discoveredPOIs: {},
            // v4.1: Achievement System
            achievements: {},
            // v4.1: Daily Challenge System
            dailyChallenge: {
                lastGenerated: null,
                completed: false,
                current: null,
                streak: 0,
                bestStreak: 0
            },
            // v4.4: Prestige System
            prestige: {
                level: 0,
                totalLifetimePoints: 0,
                bonuses: {
                    xpMultiplier: 1.0,
                    startingSkillBonus: 0
                }
            },
            // v4.4: Fog of War exploration tracking per planet
            exploredTiles: {},
            // v4.6: Settings
            settings: {
                masterVolume: 30,
                sfxEnabled: true,
                ambientEnabled: true,
                particleQuality: 'high',
                shadowsEnabled: true,
                screenShakeEnabled: true,
                hintsEnabled: true
            }
        };

        // v4.4: Simulated Leaderboard Players for local comparison
        const SIMULATED_PLAYERS = [
            { name: 'StarSeeker_X', points: 500, rank: 'Pathfinder' },
            { name: 'CosmicNova', points: 2500, rank: 'Star Scout' },
            { name: 'VoidWalker99', points: 8000, rank: 'Galaxy Ranger' },
            { name: 'AstroLegend', points: 12000, rank: 'Void Hunter' },
            { name: 'NebulaKing', points: 18000, rank: 'Cosmic Legend' },
            { name: 'Explorer42', points: 150, rank: 'Wanderer' },
            { name: 'SpaceCadet', points: 350, rank: 'Wanderer' },
            { name: 'Starlight', points: 1200, rank: 'Pathfinder' }
        ];

        // v4.4: Prestige requirements and rewards
        const PRESTIGE_LEVELS = {
            1: { required: 15000, xpBonus: 0.10, skillBonus: 0 },
            2: { required: 20000, xpBonus: 0.10, skillBonus: 1 },
            3: { required: 30000, xpBonus: 0.15, skillBonus: 1 },
            4: { required: 50000, xpBonus: 0.20, skillBonus: 2 },
            5: { required: 100000, xpBonus: 0.25, skillBonus: 3 }
        };

        function canPrestige() {
            const currentLevel = gameData.prestige?.level || 0;
            const nextLevel = PRESTIGE_LEVELS[currentLevel + 1];
            if (!nextLevel) return false;
            return calculatePlayerPoints() >= nextLevel.required;
        }

        function performPrestige() {
            if (!canPrestige()) return false;

            const currentLevel = gameData.prestige?.level || 0;
            const newLevel = currentLevel + 1;
            const reward = PRESTIGE_LEVELS[newLevel];

            // Store lifetime stats
            const lifetimePoints = (gameData.prestige?.totalLifetimePoints || 0) + calculatePlayerPoints();

            // Calculate cumulative bonuses
            const newXpMultiplier = 1.0 + Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.xpBonus, 0);
            const newSkillBonus = Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.skillBonus, 0);

            // Keep achievements and daily challenge
            const keepData = {
                achievements: { ...gameData.achievements },
                dailyChallenge: { ...gameData.dailyChallenge },
                hasSeenTutorial: true,
                prestige: {
                    level: newLevel,
                    totalLifetimePoints: lifetimePoints,
                    bonuses: {
                        xpMultiplier: newXpMultiplier,
                        startingSkillBonus: newSkillBonus
                    }
                }
            };

            // Reset everything else
            gameData.version = VERSION;
            gameData.playtime = 0;
            gameData.inventory = [];
            gameData.visitedPlanets = [];
            gameData.discoveredPOIs = {};
            gameData.exploredTiles = {};
            gameData.playerRank = { points: 0, lastTitle: 'Novice Explorer' };

            // Reset skills with prestige bonus
            for (const skill of Object.keys(gameData.skills)) {
                gameData.skills[skill] = { level: 1 + newSkillBonus, xp: 0 };
            }

            // Reset statistics
            for (const stat of Object.keys(gameData.statistics)) {
                gameData.statistics[stat] = 0;
            }

            gameData.player = { hp: CONFIG.PLAYER_MAX_HP, maxHp: CONFIG.PLAYER_MAX_HP };

            // Restore kept data
            Object.assign(gameData, keepData);

            saveGameData();
            showNotification(`PRESTIGE ${newLevel}! XP +${Math.round((newXpMultiplier - 1) * 100)}%`, 'success');
            AudioSystem.levelUp();
            return true;
        }

        function getLeaderboardPosition() {
            const myPoints = calculatePlayerPoints();
            const allPlayers = [...SIMULATED_PLAYERS, { name: 'YOU', points: myPoints, rank: getPlayerRank().title }]
                .sort((a, b) => b.points - a.points);
            const myIndex = allPlayers.findIndex(p => p.name === 'YOU');
            return {
                position: myIndex + 1,
                total: allPlayers.length,
                nearby: allPlayers.slice(Math.max(0, myIndex - 2), myIndex + 3)
            };
        }

        // --- ACHIEVEMENT DEFINITIONS ---
        const ACHIEVEMENTS = {
            'first_landing': { name: 'First Contact', desc: 'Land on your first planet', icon: 'üåç' },
            'explorer_10': { name: 'Star Hopper', desc: 'Visit 10 different planets', icon: '‚ú®' },
            'explorer_30': { name: 'Galaxy Wanderer', desc: 'Visit 30 planets', icon: 'üöÄ' },
            'lumberjack_25': { name: 'Woodcutter', desc: 'Chop 25 trees', icon: 'ü™ì' },
            'lumberjack_100': { name: 'Lumberjack', desc: 'Chop 100 trees', icon: 'üå≤' },
            'miner_25': { name: 'Prospector', desc: 'Mine 25 ore veins', icon: '‚õèÔ∏è' },
            'miner_100': { name: 'Master Miner', desc: 'Mine 100 ore veins', icon: 'üíé' },
            'angler_10': { name: 'Fisherman', desc: 'Catch 10 fish', icon: 'üêü' },
            'angler_50': { name: 'Master Angler', desc: 'Catch 50 fish', icon: 'üé£' },
            'slayer_10': { name: 'Slime Slayer', desc: 'Defeat 10 slimes', icon: '‚öîÔ∏è' },
            'slayer_50': { name: 'Exterminator', desc: 'Defeat 50 slimes', icon: 'üíÄ' },
            'crafter_10': { name: 'Apprentice', desc: 'Craft 10 items', icon: 'üî®' },
            'crafter_50': { name: 'Master Craftsman', desc: 'Craft 50 items', icon: 'üèÜ' },
            'max_skill': { name: 'Specialist', desc: 'Reach level 10 in any skill', icon: 'üìà' },
            'playtime_1h': { name: 'Dedicated', desc: 'Play for 1 hour', icon: '‚è∞' },
            'survivor': { name: 'Survivor', desc: 'Heal 500 HP total', icon: '‚ù§Ô∏è' },
            'daily_3': { name: 'Consistent', desc: 'Complete 3 daily challenges', icon: 'üìÖ' },
            'daily_7': { name: 'Weekly Warrior', desc: 'Complete 7 daily challenges', icon: 'üî•' }
        };

        // --- DAILY CHALLENGE DEFINITIONS ---
        const DAILY_CHALLENGES = [
            { type: 'gather_logs', amount: 15, desc: 'Gather 15 logs', reward: { skill: 'wood', xp: 150 } },
            { type: 'gather_ore', amount: 12, desc: 'Mine 12 ore', reward: { skill: 'mining', xp: 150 } },
            { type: 'kill_mobs', amount: 5, desc: 'Defeat 5 slimes', reward: { skill: 'combat', xp: 200 } },
            { type: 'catch_fish', amount: 8, desc: 'Catch 8 fish', reward: { skill: 'fishing', xp: 150 } },
            { type: 'craft_items', amount: 3, desc: 'Craft 3 items', reward: { skill: 'crafting', xp: 100 } },
            { type: 'visit_planets', amount: 2, desc: 'Explore 2 new planets', reward: { skill: 'combat', xp: 200 } },
            { type: 'cook_fish', amount: 3, desc: 'Cook 3 fish', reward: { skill: 'cooking', xp: 120 } }
        ];

        // Tutorial functions
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            gameData.hasSeenTutorial = true;
            saveGameData();
            AudioSystem.click();
        }

        // --- ACHIEVEMENT SYSTEM ---
        function checkAchievements() {
            const s = gameData.statistics;
            const sk = gameData.skills;

            const checks = {
                'first_landing': () => gameData.visitedPlanets.length >= 1,
                'explorer_10': () => gameData.visitedPlanets.length >= 10,
                'explorer_30': () => gameData.visitedPlanets.length >= 30,
                'lumberjack_25': () => s.treesChopped >= 25,
                'lumberjack_100': () => s.treesChopped >= 100,
                'miner_25': () => s.oresMined >= 25,
                'miner_100': () => s.oresMined >= 100,
                'angler_10': () => s.fishCaught >= 10,
                'angler_50': () => s.fishCaught >= 50,
                'slayer_10': () => s.mobsKilled >= 10,
                'slayer_50': () => s.mobsKilled >= 50,
                'crafter_10': () => s.itemsCrafted >= 10,
                'crafter_50': () => s.itemsCrafted >= 50,
                'max_skill': () => Object.values(sk).some(skill => skill.level >= 10),
                'playtime_1h': () => gameData.playtime >= 3600,
                'survivor': () => (s.totalHealed || 0) >= 500,
                'daily_3': () => (gameData.dailyChallenge.completedCount || 0) >= 3,
                'daily_7': () => (gameData.dailyChallenge.completedCount || 0) >= 7
            };

            for (const [id, check] of Object.entries(checks)) {
                if (!gameData.achievements[id] && check()) {
                    unlockAchievement(id);
                }
            }
        }

        function unlockAchievement(id) {
            if (gameData.achievements[id]) return;

            const ach = ACHIEVEMENTS[id];
            if (!ach) return;

            gameData.achievements[id] = { unlockedAt: new Date().toISOString() };

            // Show achievement popup
            showAchievementPopup(ach.icon, ach.name, ach.desc);
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 25, 0xffd700, { spread: 6, lifetime: 1500 });
            }

            saveGameData();
        }

        function showAchievementPopup(icon, name, desc) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div class="ach-icon">${icon}</div>
                <div class="ach-text">
                    <div class="ach-title">Achievement Unlocked!</div>
                    <div class="ach-name">${name}</div>
                    <div class="ach-desc">${desc}</div>
                </div>
            `;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 4000);
        }

        // --- DAILY CHALLENGE SYSTEM ---
        function generateDailyChallenge() {
            const today = new Date().toDateString();

            if (gameData.dailyChallenge.lastGenerated === today && gameData.dailyChallenge.current) {
                return gameData.dailyChallenge.current;
            }

            // Reset streak if missed a day
            if (gameData.dailyChallenge.lastGenerated) {
                const lastDate = new Date(gameData.dailyChallenge.lastGenerated);
                const now = new Date();
                const diffDays = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
                if (diffDays > 1) {
                    gameData.dailyChallenge.streak = 0;
                }
            }

            // Use date as seed for consistent daily challenge
            const seed = new SeededRNG(today);
            const template = seed.pick(DAILY_CHALLENGES);
            const challenge = {
                ...template,
                progress: 0,
                startStats: { ...gameData.statistics },
                startPlanets: gameData.visitedPlanets.length
            };

            gameData.dailyChallenge.lastGenerated = today;
            gameData.dailyChallenge.current = challenge;
            gameData.dailyChallenge.completed = false;
            saveGameData();

            return challenge;
        }

        function updateDailyChallengeProgress() {
            if (!gameData.dailyChallenge.current || gameData.dailyChallenge.completed) return;

            const c = gameData.dailyChallenge.current;
            const start = c.startStats || {};
            const now = gameData.statistics;

            switch (c.type) {
                case 'gather_logs': c.progress = (now.treesChopped || 0) - (start.treesChopped || 0); break;
                case 'gather_ore': c.progress = (now.oresMined || 0) - (start.oresMined || 0); break;
                case 'kill_mobs': c.progress = (now.mobsKilled || 0) - (start.mobsKilled || 0); break;
                case 'catch_fish': c.progress = (now.fishCaught || 0) - (start.fishCaught || 0); break;
                case 'craft_items': c.progress = (now.itemsCrafted || 0) - (start.itemsCrafted || 0); break;
                case 'cook_fish': c.progress = (now.fishCooked || 0) - (start.fishCooked || 0); break;
                case 'visit_planets': c.progress = gameData.visitedPlanets.length - (c.startPlanets || 0); break;
            }

            if (c.progress >= c.amount && !gameData.dailyChallenge.completed) {
                completeDailyChallenge();
            }

            updateDailyChallengeUI();
        }

        function completeDailyChallenge() {
            gameData.dailyChallenge.completed = true;
            gameData.dailyChallenge.streak++;
            gameData.dailyChallenge.completedCount = (gameData.dailyChallenge.completedCount || 0) + 1;
            gameData.dailyChallenge.bestStreak = Math.max(gameData.dailyChallenge.bestStreak || 0, gameData.dailyChallenge.streak);

            // Apply reward with streak bonus
            const reward = gameData.dailyChallenge.current.reward;
            const streakMultiplier = 1 + (gameData.dailyChallenge.streak * 0.1);
            const xpReward = Math.floor(reward.xp * streakMultiplier);

            addXp(reward.skill, xpReward);

            showNotification(`Daily Challenge Complete! +${xpReward} ${reward.skill} XP (Streak: ${gameData.dailyChallenge.streak})`);
            AudioSystem.levelUp();

            checkAchievements();
            saveGameData();
        }

        function updateDailyChallengeUI() {
            const el = document.getElementById('daily-challenge');
            if (!el) return;

            const c = gameData.dailyChallenge.current;
            if (!c) {
                el.style.display = 'none';
                return;
            }

            el.style.display = 'block';
            document.getElementById('daily-desc').textContent = c.desc;
            document.getElementById('daily-progress-text').textContent = `${Math.min(c.progress || 0, c.amount)}/${c.amount}`;
            document.getElementById('daily-progress-fill').style.width = `${Math.min(100, ((c.progress || 0) / c.amount) * 100)}%`;
            document.getElementById('daily-streak').textContent = `Streak: ${gameData.dailyChallenge.streak} days`;

            if (gameData.dailyChallenge.completed) {
                el.classList.add('completed');
            } else {
                el.classList.remove('completed');
            }
        }

        // --- v4.2: PLAYER RANK SYSTEM ---
        function calculatePlayerPoints() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            return (
                gameData.visitedPlanets.length * 50 +
                s.treesChopped * 2 +
                s.oresMined * 2 +
                s.mobsKilled * 10 +
                s.fishCaught * 3 +
                s.itemsCrafted * 5 +
                (s.poisDiscovered || 0) * 100 +
                Object.values(sk).reduce((sum, skill) => sum + skill.level * 20, 0) +
                Math.floor(gameData.playtime / 60)
            );
        }

        function getPlayerRank() {
            const points = calculatePlayerPoints();
            let rank = PLAYER_RANKS[0];
            for (const r of PLAYER_RANKS) {
                if (points >= r.points) rank = r;
            }
            return { ...rank, points };
        }

        function getSpecialTitles() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            const titles = [];
            for (const [name, data] of Object.entries(SPECIAL_TITLES)) {
                if (data.condition(s, sk)) {
                    titles.push({ name, color: data.color });
                }
            }
            return titles;
        }

        function updatePlayerRank() {
            const rank = getPlayerRank();
            const oldTitle = gameData.playerRank?.lastTitle || 'Novice Explorer';

            gameData.playerRank = {
                points: rank.points,
                lastTitle: rank.title
            };

            // Show rank up notification
            if (rank.title !== oldTitle) {
                showNotification(`RANK UP! You are now: ${rank.title}`, 'success');
                AudioSystem.levelUp();
            }

            saveGameData();
        }

        // --- STATISTICS PANEL ---
        function showStatsPanel() {
            updateStatsDisplay();
            document.getElementById('stats-modal').style.display = 'flex';
        }

        function closeStatsModal() {
            document.getElementById('stats-modal').style.display = 'none';
        }

        function updateStatsDisplay() {
            const s = gameData.statistics;

            document.getElementById('stat-planets').textContent = `${gameData.visitedPlanets.length} / ${CONFIG.NUM_CIVS}`;

            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('stat-playtime').textContent = `${hours}h ${mins}m`;

            document.getElementById('stat-trees').textContent = s.treesChopped || 0;
            document.getElementById('stat-ore').textContent = s.oresMined || 0;
            document.getElementById('stat-fish').textContent = s.fishCaught || 0;
            document.getElementById('stat-mobs').textContent = s.mobsKilled || 0;
            document.getElementById('stat-crafted').textContent = s.itemsCrafted || 0;

            // v4.2: Display POIs discovered and player rank
            const poisEl = document.getElementById('stat-pois');
            if (poisEl) poisEl.textContent = s.poisDiscovered || 0;

            const rankEl = document.getElementById('stat-rank');
            if (rankEl) {
                const rank = getPlayerRank();
                rankEl.textContent = rank.title;
                rankEl.style.color = rank.color;
            }

            const pointsEl = document.getElementById('stat-points');
            if (pointsEl) pointsEl.textContent = calculatePlayerPoints();

            // v4.2: Display special titles
            const titlesEl = document.getElementById('special-titles');
            if (titlesEl) {
                const titles = getSpecialTitles();
                if (titles.length > 0) {
                    titlesEl.innerHTML = titles.map(t =>
                        `<span style="color:${t.color}">${t.name}</span>`
                    ).join(' | ');
                } else {
                    titlesEl.innerHTML = '<span style="color:#666">None yet</span>';
                }
            }

            // Render achievements
            const achList = document.getElementById('achievements-list');
            if (achList) {
                achList.innerHTML = '';
                for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
                    const unlocked = gameData.achievements[id];
                    const div = document.createElement('div');
                    div.className = `ach-item ${unlocked ? 'unlocked' : 'locked'}`;
                    div.innerHTML = `<span class="ach-badge">${ach.icon}</span><span>${ach.name}</span>`;
                    div.title = ach.desc;
                    achList.appendChild(div);
                }
            }

            // v4.4: Render leaderboard
            const lbList = document.getElementById('leaderboard-list');
            if (lbList) {
                const lb = getLeaderboardPosition();
                lbList.innerHTML = lb.nearby.map((p, i) => {
                    const isYou = p.name === 'YOU';
                    const bgColor = isYou ? 'rgba(255,215,0,0.2)' : 'transparent';
                    const textColor = isYou ? '#ffd700' : '#aaa';
                    const rank = lb.position - (lb.nearby.indexOf(lb.nearby.find(x => x.name === 'YOU'))) + i;
                    return `<div style="display: flex; justify-content: space-between; padding: 4px 8px; margin: 2px 0; background: ${bgColor}; border-radius: 4px;">
                        <span style="color: ${textColor};">#${rank} ${p.name}</span>
                        <span style="color: #888;">${p.points.toLocaleString()} pts</span>
                    </div>`;
                }).join('');
            }

            // v4.4: Render prestige info
            const prestigeLevel = gameData.prestige?.level || 0;
            const xpMult = gameData.prestige?.bonuses?.xpMultiplier || 1.0;
            const lifetimePoints = gameData.prestige?.totalLifetimePoints || 0;

            document.getElementById('prestige-level').textContent = prestigeLevel;
            document.getElementById('prestige-xp').textContent = `x${xpMult.toFixed(1)}`;
            document.getElementById('prestige-lifetime').textContent = lifetimePoints.toLocaleString();

            const progressEl = document.getElementById('prestige-progress');
            const prestigeBtn = document.getElementById('prestige-btn');
            const nextLevel = PRESTIGE_LEVELS[prestigeLevel + 1];

            if (nextLevel) {
                const currentPts = calculatePlayerPoints();
                const progress = Math.min(100, (currentPts / nextLevel.required) * 100);
                progressEl.innerHTML = `Next prestige: ${currentPts.toLocaleString()} / ${nextLevel.required.toLocaleString()} pts (${progress.toFixed(1)}%)`;

                if (canPrestige()) {
                    prestigeBtn.style.display = 'block';
                } else {
                    prestigeBtn.style.display = 'none';
                }
            } else {
                progressEl.innerHTML = `<span style="color: #aa44ff;">MAX PRESTIGE REACHED!</span>`;
                prestigeBtn.style.display = 'none';
            }
        }

        // --- DATA PERSISTENCE ---
        function loadGameData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle version updates
                    gameData = { ...gameData, ...parsed };
                    // Ensure nested objects exist
                    gameData.skills = { ...gameData.skills, ...parsed.skills };
                    gameData.player = { ...gameData.player, ...parsed.player };
                    gameData.statistics = { ...gameData.statistics, ...parsed.statistics };
                    console.log('Game data loaded successfully');
                }
            } catch (e) {
                console.error('Failed to load game data:', e);
            }
        }

        function saveGameData() {
            try {
                gameData.lastPlayed = new Date().toISOString();
                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                console.log('Game saved');
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.version) {
                        gameData = { ...gameData, ...imported };
                        saveGameData();
                        showNotification('Save imported! Refreshing...');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        alert('Invalid save file format');
                    }
                } catch (error) {
                    alert('Failed to import: Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // v4.6: Quick save function
        function quickSave() {
            saveGameData();
            document.getElementById('last-save-time').textContent = new Date().toLocaleString();
            showNotification('Game saved!');
        }

        // v4.7: Session Rewards System
        let pendingSessionReward = null;

        function checkSessionRewards() {
            if (!gameData.lastPlayed) return null;

            const lastPlayed = new Date(gameData.lastPlayed);
            const now = new Date();
            const hoursAway = Math.min(
                (now - lastPlayed) / (1000 * 60 * 60),
                SESSION_REWARDS.maxOfflineHours
            );

            // Find the best applicable tier
            let bestTier = null;
            for (const tier of SESSION_REWARDS.tiers) {
                if (hoursAway >= tier.minHours) {
                    bestTier = tier;
                }
            }

            if (bestTier) {
                return {
                    tier: bestTier,
                    hoursAway: Math.floor(hoursAway),
                    minutesAway: Math.floor((hoursAway % 1) * 60)
                };
            }
            return null;
        }

        function showWelcomeBackModal(reward) {
            pendingSessionReward = reward;

            document.getElementById('welcome-back-message').textContent = reward.tier.message;

            const timeText = reward.hoursAway > 0
                ? `You were away for ${reward.hoursAway}h ${reward.minutesAway}m`
                : `You were away for ${reward.minutesAway}m`;
            document.getElementById('welcome-back-time').textContent = timeText;

            // Build rewards list
            const rewardsList = document.getElementById('welcome-back-rewards-list');
            let html = '';
            html += `<div style="color: #ffd700; margin-bottom: 8px;">+${reward.tier.xpBonus} XP (all skills)</div>`;
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                const icon = ITEMS[item]?.icon || 'üì¶';
                html += `<div style="color: #aaf; margin-bottom: 4px;">${icon} ${count}x ${item}</div>`;
            }
            rewardsList.innerHTML = html;

            document.getElementById('welcome-back-modal').style.display = 'flex';
            AudioSystem.levelUp();
        }

        function claimWelcomeBackRewards() {
            if (!pendingSessionReward) return;

            const reward = pendingSessionReward;

            // Grant XP to all skills
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(reward.tier.xpBonus / Object.keys(gameData.skills).length));
            });

            // Grant resources
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                for (let i = 0; i < count; i++) {
                    addItem(item);
                }
            }

            // Track the claim
            gameData.statistics.sessionRewardsClaimed = (gameData.statistics.sessionRewardsClaimed || 0) + 1;

            document.getElementById('welcome-back-modal').style.display = 'none';
            showNotification('Rewards claimed! Welcome back!', 'success');
            AudioSystem.collect();

            pendingSessionReward = null;
            saveGameData();
        }

        // v4.6: Settings Modal Functions
        function showSettingsModal() {
            // Sync UI with current settings
            const s = gameData.settings || {};
            document.getElementById('volume-slider').value = s.masterVolume || 30;
            document.getElementById('volume-display').textContent = (s.masterVolume || 30) + '%';
            updateToggleBtn('sfx-toggle', s.sfxEnabled !== false);
            updateToggleBtn('ambient-toggle', s.ambientEnabled !== false);
            updateToggleBtn('shadow-toggle', s.shadowsEnabled !== false);
            updateToggleBtn('shake-toggle', s.screenShakeEnabled !== false);
            updateToggleBtn('hints-toggle', s.hintsEnabled !== false);
            document.getElementById('particle-quality').value = s.particleQuality || 'high';
            document.getElementById('last-save-time').textContent = gameData.lastPlayed ? new Date(gameData.lastPlayed).toLocaleString() : 'Never';
            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveGameData();
        }

        function updateToggleBtn(id, isOn) {
            const btn = document.getElementById(id);
            if (isOn) {
                btn.textContent = 'ON';
                btn.classList.remove('off');
            } else {
                btn.textContent = 'OFF';
                btn.classList.add('off');
            }
        }

        function setMasterVolume(val) {
            gameData.settings = gameData.settings || {};
            gameData.settings.masterVolume = parseInt(val);
            AudioSystem.masterVolume = val / 100;
            document.getElementById('volume-display').textContent = val + '%';
        }

        function toggleSFX() {
            gameData.settings = gameData.settings || {};
            gameData.settings.sfxEnabled = !gameData.settings.sfxEnabled;
            AudioSystem.enabled = gameData.settings.sfxEnabled;
            updateToggleBtn('sfx-toggle', gameData.settings.sfxEnabled);
        }

        function toggleAmbient() {
            gameData.settings = gameData.settings || {};
            gameData.settings.ambientEnabled = !gameData.settings.ambientEnabled;
            if (gameData.settings.ambientEnabled) {
                if (mode === 'world' && activeCiv) AudioSystem.startAmbient(activeCiv.biome);
            } else {
                AudioSystem.stopAmbient();
            }
            updateToggleBtn('ambient-toggle', gameData.settings.ambientEnabled);
        }

        function setParticleQuality(quality) {
            gameData.settings = gameData.settings || {};
            gameData.settings.particleQuality = quality;
            // Adjust particle limits
            if (particles) {
                particles.maxParticles = quality === 'high' ? 100 : quality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = quality === 'high' ? 60 : quality === 'medium' ? 30 : 15;
            }
        }

        function toggleShadows() {
            gameData.settings = gameData.settings || {};
            gameData.settings.shadowsEnabled = !gameData.settings.shadowsEnabled;
            renderer.shadowMap.enabled = gameData.settings.shadowsEnabled;
            updateToggleBtn('shadow-toggle', gameData.settings.shadowsEnabled);
        }

        function toggleScreenShake() {
            gameData.settings = gameData.settings || {};
            gameData.settings.screenShakeEnabled = !gameData.settings.screenShakeEnabled;
            updateToggleBtn('shake-toggle', gameData.settings.screenShakeEnabled);
        }

        function toggleHints() {
            gameData.settings = gameData.settings || {};
            gameData.settings.hintsEnabled = !gameData.settings.hintsEnabled;
            updateToggleBtn('hints-toggle', gameData.settings.hintsEnabled);
        }

        // v4.6: Apply settings on load
        function applySettings() {
            const s = gameData.settings || {};
            AudioSystem.masterVolume = (s.masterVolume || 30) / 100;
            AudioSystem.enabled = s.sfxEnabled !== false;
            if (particles) {
                particles.maxParticles = s.particleQuality === 'high' ? 100 : s.particleQuality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = s.particleQuality === 'high' ? 60 : s.particleQuality === 'medium' ? 30 : 15;
            }
        }

        function closeModal() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        // v4.3: Notification queue to prevent stacking
        const notificationQueue = [];
        let notificationActive = false;
        const MAX_VISIBLE_NOTIFICATIONS = 3;
        let visibleNotifications = [];

        function showNotification(message, type = 'success') {
            // Add to queue
            notificationQueue.push({ message, type });
            processNotificationQueue();
        }

        function processNotificationQueue() {
            // Remove expired notifications
            visibleNotifications = visibleNotifications.filter(n => n.element.parentNode);

            // Process queue while under limit
            while (notificationQueue.length > 0 && visibleNotifications.length < MAX_VISIBLE_NOTIFICATIONS) {
                const { message, type } = notificationQueue.shift();
                displayNotification(message, type);
            }
        }

        function displayNotification(message, type) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;

            // Position based on how many are currently visible
            const offset = visibleNotifications.length * 50;
            notif.style.top = (100 + offset) + 'px';

            if (type === 'error') {
                notif.style.background = 'rgba(100, 0, 0, 0.9)';
                notif.style.borderColor = '#f00';
                notif.style.color = '#f00';
            } else if (type === 'warning') {
                notif.style.background = 'rgba(100, 80, 0, 0.9)';
                notif.style.borderColor = '#fa0';
                notif.style.color = '#fa0';
            }

            document.body.appendChild(notif);
            const notifObj = { element: notif, expires: Date.now() + 2500 };
            visibleNotifications.push(notifObj);

            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    notif.remove();
                    processNotificationQueue();
                }, 300);
            }, 2500);
        }

        // --- INITIALIZATION ---
        function init() {
            loadGameData();

            // v4.7: Check for welcome back rewards
            const sessionReward = checkSessionRewards();
            if (sessionReward) {
                // Delay modal to let game initialize
                setTimeout(() => showWelcomeBackModal(sessionReward), 1500);
            }

            // v4.0: Initialize audio and particle systems
            AudioSystem.init();
            particles = new ParticleSystem();
            envParticles = new EnvironmentParticles(); // v4.4

            // v4.6: Apply saved settings
            applySettings();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize floater pool
            for (let i = 0; i < MAX_FLOATERS; i++) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.display = 'none';
                document.body.appendChild(el);
                floaterPool.push({ el, active: false });
            }

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            // Touch events
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'flex';
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.getElementById('touch-action').addEventListener('touchstart', onTouchAction);

                // v4.3: Virtual Joystick setup
                const joystick = document.getElementById('virtual-joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                const actionBtn = document.getElementById('touch-action-btn');

                joystick.style.display = 'block';
                actionBtn.style.display = 'flex';

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    joystickActive = true;
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (joystickActive) {
                        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickInput = { x: 0, y: 0 };
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });

                actionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world' && worldState.interactTarget) {
                        performAction(worldState.interactTarget);
                    }
                }, { passive: false });

                // v4.5: Dodge button setup
                const dodgeBtn = document.getElementById('touch-dodge-btn');
                dodgeBtn.style.display = 'flex';
                dodgeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world') {
                        startDodge();
                    }
                }, { passive: false });

                function updateJoystick(touchX, touchY) {
                    let dx = touchX - joystickCenter.x;
                    let dy = touchY - joystickCenter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > joystickMaxDist) {
                        dx = (dx / dist) * joystickMaxDist;
                        dy = (dy / dist) * joystickMaxDist;
                    }

                    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    joystickInput = { x: dx / joystickMaxDist, y: dy / joystickMaxDist };
                }
            }

            // Keyboard events (including WASD)
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            initGalaxy();
            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();

            // v4.1: Initialize daily challenge system
            generateDailyChallenge();
            updateDailyChallengeUI();

            document.getElementById('loading').style.display = 'none';

            // v4.0: Show tutorial for first-time players
            if (!gameData.hasSeenTutorial) {
                setTimeout(showTutorial, 500);
            }

            // v4.1: Check achievements on load
            checkAchievements();

            // Autosave
            setInterval(() => {
                if (mode === 'world') {
                    saveGameData();
                    checkAchievements();
                    updateDailyChallengeProgress();
                }
            }, CONFIG.AUTOSAVE_INTERVAL);

            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            mode = 'galaxy';

            // v4.3: Stop ambient audio when leaving planet
            AudioSystem.stopAmbient();

            // v4.4: Stop environmental particles
            if (envParticles) envParticles.stop();

            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield (optimized with BufferGeometry)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<8000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                const c = new THREE.Color().setHSL(Math.random() * 0.2 + 0.55, 0.2, 0.8 + Math.random() * 0.2);
                starColors.push(c.r, c.g, c.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 2, vertexColors: true })));

            // v4.1: Nebula clouds for atmosphere
            createNebulae();

            // Civilizations
            const rng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();

            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(200, 1200);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = rng.range(-100, 100);

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));
                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i)
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);

                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(8, 16, 16),
                    new THREE.MeshBasicMaterial({color: color})
                );
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.2})
                );
                sysGroup.add(glow);

                // Mark visited planets
                if (civ.visited) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(18, 20, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2;
                    sysGroup.add(ring);
                }

                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('civ-count').innerText = CONFIG.NUM_CIVS;

            updatePlaytimeDisplay();
        }

        // --- WORLD MODE ---
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';

            // Mark as visited
            if (!gameData.visitedPlanets.includes(civ.id)) {
                gameData.visitedPlanets.push(civ.id);
                showNotification(`First visit to ${civ.name}!`);
                // v4.1: Check achievements after planet discovery
                checkAchievements();
                updateDailyChallengeProgress();
            }

            while(scene.children.length > 0) scene.remove(scene.children[0]);

            // v4.3: Reset boss spawn tracking for new world
            worldMobKillCount = 0;
            bossSpawned = false;

            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 1024;
            worldState.sun.shadow.mapSize.height = 1024;
            scene.add(worldState.sun);

            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.interactables = [];
            worldState.fishingSpots = [];
            worldState.mobs = [];

            // Merged geometry for better performance
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            const groundMat = new THREE.MeshLambertMaterial({ color: biome.ground });
            const waterMat = new THREE.MeshLambertMaterial({ color: biome.water, transparent: true, opacity: 0.8 });

            const worldGroup = new THREE.Group();

            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    const hVal = noise(x + civ.id, z + civ.id);
                    const height = Math.floor((hVal + 1) * 3);
                    const realY = height * CONFIG.TILE_SIZE/2;

                    const isWater = height < 1;

                    const mesh = new THREE.Mesh(groundGeo, isWater ? waterMat : groundMat);
                    mesh.position.set(
                        (x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE,
                        realY,
                        (z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE
                    );
                    mesh.receiveShadow = true;
                    worldGroup.add(mesh);

                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    // Fishing spots in water
                    if(isWater && rng.next() > 0.95) {
                        createFishingSpot(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                    }

                    // Trees/Rocks
                    if(!isWater && rng.next() > 0.85) {
                        const type = rng.next() > 0.5 ? 'tree' : 'rock';
                        createProp(type, mesh.position.x, mesh.position.y + CONFIG.TILE_SIZE/2, mesh.position.z, biome);
                    }
                }
            }
            scene.add(worldGroup);

            // Player - Using CylinderGeometry since CapsuleGeometry isn't in Three.js r128
            const playerGroup = new THREE.Group();

            // Body (cylinder)
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.6, 8);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.3, roughness: 0.7 });
            const body = new THREE.Mesh(bodyGeo, playerMat);
            body.position.y = 0.8;
            body.castShadow = true;
            playerGroup.add(body);

            // Head (sphere on top)
            const headGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeo, playerMat);
            head.position.y = 1.8;
            head.castShadow = true;
            playerGroup.add(head);

            worldState.player = playerGroup;
            worldState.player.position.set(0, 10, 0);

            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0;
            worldState.player.add(ring);

            scene.add(worldState.player);

            // Mobs
            const mobCount = 5 + Math.floor(rng.next() * 5);
            for(let i=0; i<mobCount; i++) {
                createMob(rng, biome);
            }

            // v4.2: Generate POIs based on biome
            worldState.pois = [];
            const biomeKey = civ.biome;
            for (const [poiType, poiData] of Object.entries(POI_TYPES)) {
                // Check if POI can spawn in this biome
                if (poiData.biomes && !poiData.biomes.includes(biomeKey)) continue;

                // Check rarity
                if (rng.next() < poiData.rarity) {
                    // Check if already discovered on this planet
                    const alreadyDiscovered = gameData.discoveredPOIs[civ.id]?.includes(poiType);
                    createPOI(rng, biome, poiType, poiData);
                    // Mark pre-discovered POIs
                    if (alreadyDiscovered && worldState.pois.length > 0) {
                        const poi = worldState.pois[worldState.pois.length - 1];
                        poi.userData.discovered = true;
                        if (poi.userData.beacon) poi.userData.beacon.material.emissiveIntensity = 0.1;
                        if (poi.userData.iconMesh) poi.userData.iconMesh.material.opacity = 0.3;
                    }
                }
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('world-name').textContent = civ.biomeName;
            document.getElementById('rpg-ui').style.display = 'flex';
            document.getElementById('player-health-bar').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('ability-bar').style.display = 'block';
            updateAbilityUI();

            // v4.3: Start biome ambient audio
            AudioSystem.startAmbient(civ.biome);

            // v4.4: Start environmental particles
            if (envParticles) envParticles.startBiome(civ.biome);

            worldState.target = null;
            worldState.interactTarget = null;

            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();
            updateCraftingUI();
            initMinimap();
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                    new THREE.MeshLambertMaterial({ color: 0x553311 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: biome.tree })
                );
                leaves.position.y = 2.8;
                leaves.castShadow = true;
                group.add(leaves);
                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: 'Ancient Tree' };
            } else {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1),
                    new THREE.MeshLambertMaterial({ color: biome.rock })
                );
                rock.position.y = 0.5;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createFishingSpot(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Ripple effect
            const ripple = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ripple.rotation.x = -Math.PI / 2;
            group.add(ripple);

            group.userData = { type: 'fishing', name: 'Fishing Spot', ripple };
            scene.add(group);
            worldState.fishingSpots.push(group);
            worldState.interactables.push(group);
        }

        function createMob(rng, biome) {
            // v4.2: Select enemy type based on biome
            const biomeKey = biome.name === 'Terra' ? 'Terra' :
                            biome.name === 'Desert' ? 'Desert' :
                            biome.name === 'Tundra' ? 'Ice' :
                            biome.name === 'Xeno' ? 'Alien' :
                            biome.name === 'Magma' ? 'Volcanic' : 'Terra';

            const validEnemies = Object.entries(ENEMY_TYPES)
                .filter(([name, data]) => data.biomes.includes(biomeKey));

            const [enemyName, enemyData] = validEnemies.length > 0
                ? validEnemies[rng.int(0, validEnemies.length - 1)]
                : ['Slime', ENEMY_TYPES.Slime];

            // v4.7: Elite enemy roll
            const prestigeLevel = gameData.prestige?.level || 0;
            const isElite = prestigeLevel >= ELITE_CONFIG.minWorldLevel &&
                           rng.next() < ELITE_CONFIG.spawnChance;

            let eliteAffix = null;
            let eliteData = null;
            if (isElite) {
                const affixKeys = Object.keys(ELITE_AFFIXES);
                const affixKey = affixKeys[rng.int(0, affixKeys.length - 1)];
                eliteAffix = affixKey;
                eliteData = ELITE_AFFIXES[affixKey];
            }

            // Calculate stats with elite multipliers
            const baseHp = enemyData.hp * (eliteData ? eliteData.hpMult : 1);
            const baseDamage = enemyData.damage * (eliteData ? eliteData.damageMult : 1);
            const baseSpeed = enemyData.speed * (eliteData ? eliteData.speedMult : 1);

            const mobGeo = new THREE.SphereGeometry(isElite ? 1.0 : 0.8, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({
                color: eliteData ? eliteData.color : enemyData.color,
                roughness: 0.3,
                emissive: eliteData ? eliteData.color : enemyData.emissive,
                emissiveIntensity: isElite ? 0.5 : 0.2
            });
            const mob = new THREE.Mesh(mobGeo, mobMat);

            const rx = (rng.next() - 0.5) * 60;
            const rz = (rng.next() - 0.5) * 60;
            mob.position.set(rx, 10, rz);
            mob.castShadow = true;

            // v4.7: Add glowing aura ring for elite enemies
            if (isElite) {
                const auraGeo = new THREE.RingGeometry(1.2, 1.5, 32);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: eliteData.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                mob.add(aura);
                mob.userData.auraRing = aura;
            }

            // Health bar above mob (larger for elites)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.0 : 1.5, 0.15),
                new THREE.MeshBasicMaterial({ color: isElite ? 0xffaa00 : 0x00ff00, side: THREE.DoubleSide })
            );
            hpBar.position.y = isElite ? 1.8 : 1.5;
            mob.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.1 : 1.6, 0.2),
                new THREE.MeshBasicMaterial({ color: isElite ? 0x553300 : 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = isElite ? 1.8 : 1.5;
            hpBg.position.z = -0.01;
            mob.add(hpBg);

            mob.userData = {
                type: 'mob',
                hp: baseHp,
                maxHp: baseHp,
                name: enemyName,
                damage: baseDamage,
                speed: baseSpeed,
                drops: enemyData.drops,
                xpReward: enemyData.xp * (isElite ? ELITE_CONFIG.bonusXpMult : 1),
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                // v4.5: Attack telegraph properties
                attackWindup: enemyData.attackWindup || 600,
                attackRange: enemyData.attackRange || 2.5,
                telegraphing: false,
                // v4.7: Elite properties
                isElite: isElite,
                eliteAffix: eliteAffix,
                eliteData: eliteData,
                displayName: isElite ? `${eliteData.prefix} ${eliteData.name} ${enemyName}` : enemyName
            };

            scene.add(mob);
            worldState.mobs.push(mob);

            // v4.7: Announce elite spawn
            if (isElite) {
                showNotification(`${eliteData.prefix} ELITE ${eliteData.name} ${enemyName} appeared!`, 'warning');
            }
        }

        // v4.2: Create Point of Interest
        function createPOI(rng, biome, poiType, poiData) {
            const group = new THREE.Group();

            // Create visual marker based on POI type
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.5, 8);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x886644,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            group.add(base);

            // Add glowing beacon
            const beaconGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 8);
            const beaconMat = new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 2.5;
            group.add(beacon);

            // Floating icon sphere
            const iconGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const iconMat = new THREE.MeshStandardMaterial({
                color: 0x44ffff,
                emissive: 0x22aaaa,
                transparent: true,
                opacity: 0.8
            });
            const icon = new THREE.Mesh(iconGeo, iconMat);
            icon.position.y = 5;
            group.add(icon);

            const rx = (rng.next() - 0.5) * 50;
            const rz = (rng.next() - 0.5) * 50;
            group.position.set(rx, 0, rz);

            group.userData = {
                type: 'poi',
                poiType: poiType,
                name: poiData.name,
                icon: poiData.icon,
                rewards: poiData.rewards,
                xpBonus: poiData.xpBonus,
                discovered: false,
                beacon: beacon,
                iconMesh: icon
            };

            scene.add(group);
            worldState.pois.push(group);
            worldState.interactables.push(group);
        }

        // v4.3: Create Boss
        function createBoss(biomeKey) {
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];
            if (!bossData) return;

            // Create larger, more intimidating boss mesh
            const bossGeo = new THREE.SphereGeometry(0.8 * bossData.scale, 24, 24);
            const bossMat = new THREE.MeshStandardMaterial({
                color: bossData.color,
                roughness: 0.2,
                emissive: bossData.emissive,
                emissiveIntensity: 0.5
            });
            const boss = new THREE.Mesh(bossGeo, bossMat);

            // Position boss away from spawn
            boss.position.set(
                (Math.random() - 0.5) * 40,
                15,
                (Math.random() - 0.5) * 40
            );
            boss.castShadow = true;

            // Boss health bar (larger)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            hpBar.position.y = 3;
            boss.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(3.2, 0.4),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = 3;
            hpBg.position.z = -0.01;
            boss.add(hpBg);

            // Crown/indicator for boss
            const crownGeo = new THREE.ConeGeometry(0.5, 0.8, 4);
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800 });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.y = bossData.scale * 0.8 + 0.5;
            crown.rotation.y = Math.PI / 4;
            boss.add(crown);

            boss.userData = {
                type: 'boss',
                bossId: bossId,
                hp: bossData.hp,
                maxHp: bossData.hp,
                name: bossData.name,
                damage: bossData.damage,
                speed: bossData.speed,
                scale: bossData.scale,
                drops: bossData.drops,
                xpReward: bossData.xp,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                isBoss: true
            };

            scene.add(boss);
            worldState.mobs.push(boss);

            // Announce boss spawn
            showNotification(`BOSS APPEARED: ${bossData.name}!`, 'error');
            AudioSystem.bossSpawn();

            return boss;
        }

        // v4.3: Track world mob kills for boss spawning
        let worldMobKillCount = 0;
        let bossSpawned = false;

        function checkBossSpawn() {
            if (bossSpawned || !activeCiv) return;

            // Find the appropriate boss for this biome
            const biomeKey = activeCiv.biome;
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];

            if (!bossData) return;

            const condition = bossData.spawnCondition;

            // v4.5: Check mob kill requirement
            if (worldMobKillCount < condition.mobsKilled) return;

            // v4.5: Check combat level requirement
            if (condition.minCombatLevel && gameData.skills.combat.level < condition.minCombatLevel) {
                // Show hint if close to spawning
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires Combat Level ${condition.minCombatLevel}!`, 'warning');
                }
                return;
            }

            // v4.5: Check required item
            if (condition.requiredItem && !hasItem(condition.requiredItem)) {
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires ${condition.requiredItem} equipped!`, 'warning');
                }
                return;
            }

            createBoss(biomeKey);
            bossSpawned = true;
        }

        // --- GAME LOOP ---
        // v4.7: Tab visibility handling
        let tabVisible = true;
        let lastFpsTime = 0;
        let frameCount = 0;
        let currentFps = 60;

        document.addEventListener('visibilitychange', () => {
            tabVisible = !document.hidden;
            if (tabVisible) {
                // Reset timing when tab becomes visible to prevent huge dt
                lastTime = performance.now();
                AudioSystem.resume();
            } else {
                // Pause audio when tab is hidden
                if (AudioSystem.ctx && AudioSystem.ctx.state === 'running') {
                    AudioSystem.ctx.suspend();
                }
            }
        });

        function loop(time) {
            requestAnimationFrame(loop);

            // v4.7: Skip updates when tab is not visible (save resources)
            if (!tabVisible) {
                return;
            }

            // v4.7: Track FPS for adaptive performance
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = time;

                // Adaptive performance: reduce particles if FPS drops
                if (currentFps < 30 && particles && particles.maxParticles > 25) {
                    particles.maxParticles = Math.max(25, particles.maxParticles - 10);
                    console.log('Performance: Reduced particles to', particles.maxParticles);
                } else if (currentFps > 55 && particles && particles.maxParticles < 100) {
                    particles.maxParticles = Math.min(100, particles.maxParticles + 5);
                }
            }

            // v4.4: Hit-stop effect - skip game logic during freeze, still render
            if (performance.now() < hitStopUntil) {
                renderer.render(scene, camera);
                return;
            }

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            gameData.playtime += dt;

            if(mode === 'galaxy') {
                galaxyGroup.rotation.y += 0.0005;
                cycle = Math.floor(time / 1000);
                document.getElementById('cycle-count').innerText = cycle;

                if(activeCiv) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);
                }

                if (cycle % 10 === 0) updatePlaytimeDisplay();
            }
            else if(mode === 'world') {
                updateWorld(dt, time);
            }

            renderer.render(scene, camera);
        }

        function updateWorld(dt, time) {
            // Day/Night Cycle
            worldState.timeOfDay = (time * 0.00005) % 1;
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;

            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0.1, Math.sin(angle)) * 1.2;

            const biome = BIOMES[activeCiv.biome];
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x050510);
            scene.background.lerpColors(nightColor, dayColor, Math.max(0.1, Math.sin(angle)));
            scene.fog.color.copy(scene.background);

            // Player Movement
            const p = worldState.player;

            // v4.7: Check and clear chilled status
            if (playerState.chilled && time > playerState.chilledEnd) {
                playerState.chilled = false;
                playerState.moveSpeedMult = 1.0;
            }
            const speed = 12 * playerState.moveSpeedMult;

            // v4.0: WASD keyboard movement + v4.3: Virtual joystick
            const hasKeyInput = keys.w || keys.a || keys.s || keys.d;
            const hasJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);

            if (hasKeyInput || hasJoystickInput) {
                _tempVec3A.set(0, 0, 0);
                if (hasKeyInput) {
                    if (keys.w) _tempVec3A.z -= 1;
                    if (keys.s) _tempVec3A.z += 1;
                    if (keys.a) _tempVec3A.x -= 1;
                    if (keys.d) _tempVec3A.x += 1;
                } else if (hasJoystickInput) {
                    // v4.3: Joystick input (x is left/right, y is up/down on screen = forward/back in 3D)
                    _tempVec3A.x = joystickInput.x;
                    _tempVec3A.z = joystickInput.y;
                }
                _tempVec3A.normalize().multiplyScalar(speed * dt);
                p.position.add(_tempVec3A);
                worldState.target = null;
                worldState.interactTarget = null;
                // Face movement direction
                if (_tempVec3A.length() > 0.01) {
                    p.rotation.y = Math.atan2(_tempVec3A.x, _tempVec3A.z);
                }
            }

            // Click-to-move (using pre-allocated vector)
            if(worldState.target) {
                _tempVec3A.subVectors(worldState.target, p.position);
                _tempVec3A.y = 0;
                const dist = _tempVec3A.length();

                if(dist > CONFIG.MOVEMENT_THRESHOLD) {
                    _tempVec3A.normalize();
                    p.position.add(_tempVec3A.multiplyScalar(speed * dt));
                    p.lookAt(worldState.target.x, p.position.y, worldState.target.z);
                } else {
                    worldState.target = null;
                }
            }

            snapToGround(p);

            // v4.0: Cooldown-based interaction (replaces random chance)
            if(worldState.interactTarget) {
                const t = worldState.interactTarget;
                const dist = p.position.distanceTo(t.position);

                if(dist < CONFIG.INTERACTION_RANGE) {
                    worldState.target = null;

                    const now = performance.now();
                    if(now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(t);
                        worldState.lastActionTime = now;
                    }
                } else if (!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // Camera Follow (using pre-allocated vector)
            camera.position.lerp(p.position.clone().add(_camOffset), 0.08);
            camera.lookAt(p.position);

            // v4.0: Screen shake effect
            updateScreenShake();

            // v4.0: Update particles
            if (particles) particles.update(dt);

            // v4.4: Update environmental particles
            if (envParticles && worldState.player) {
                envParticles.update(dt, worldState.player.position);
            }

            // v4.5: Update dodge movement
            updateDodge(dt);

            // Mob AI with aggro (using CONFIG constants)
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;

                // v4.6: Update status effects
                updateMobStatusEffects(mob, time);

                // Check if mob died from status effect DoT
                if (mob.userData.hp <= 0) {
                    // Handle death - same as combat death but simplified
                    const xpReward = mob.userData.xpReward || 100;
                    addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;
                    worldMobKillCount++;
                    checkBossSpawn();
                    spawnFloater(mob.position, `KILLED! +${xpReward}XP`, '#f00');
                    if (particles) particles.emit(mob.position, 20, ENEMY_TYPES[mob.userData.name]?.color || 0x44ff44);
                    scene.remove(mob);
                    worldState.mobs = worldState.mobs.filter(x => x !== mob);
                    return;
                }

                // v4.6: Handle stun state from parry
                if (mob.userData.stunned) {
                    if (time < mob.userData.stunEnd) {
                        // Still stunned - skip AI behavior, keep yellow glow
                        mob.userData.telegraphing = false;
                        // Update HP bar to face camera
                        if (mob.userData.hpBar) mob.userData.hpBar.lookAt(camera.position);
                        return;
                    } else {
                        // Stun ended
                        mob.userData.stunned = false;
                        // Restore original emissive
                        const originalEmissive = ENEMY_TYPES[mob.userData.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }

                const distToPlayer = mob.position.distanceTo(p.position);

                // Aggro range
                if (distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > CONFIG.MOB_ATTACK_RANGE) {
                    mob.userData.targetPos.copy(p.position);
                    mob.userData.nextMove = time + 500;
                } else if(time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob (using temp vector) - v4.2: Use enemy-specific speed
                // v4.6: Apply status effect speed modifier
                _tempVec3B.subVectors(mob.userData.targetPos, mob.position);
                _tempVec3B.y = 0;
                if(_tempVec3B.length() > 0.1) {
                    _tempVec3B.normalize();
                    const mobSpeed = (mob.userData.speed || 4) * (mob.userData.speedMultiplier || 1);
                    mob.position.add(_tempVec3B.multiplyScalar(mobSpeed * dt));
                }
                snapToGround(mob);

                // v4.5: Attack telegraph system with windup
                const attackRange = mob.userData.attackRange || CONFIG.MOB_ATTACK_RANGE;
                const attackWindup = mob.userData.attackWindup || 600;

                // Start telegraph when in range and ready to attack
                if (distToPlayer < attackRange && time > mob.userData.nextAttack && !mob.userData.telegraphing) {
                    mob.userData.telegraphing = true;
                    mob.userData.telegraphStart = time;
                    mob.userData.telegraphEnd = time + attackWindup;
                    // Show telegraph visual - mob glows red
                    if (mob.material) {
                        mob.userData.originalEmissive = mob.material.emissive.getHex();
                        mob.material.emissive.setHex(0xff0000);
                    }
                    AudioSystem.telegraph();
                }

                // Update telegraph progress
                if (mob.userData.telegraphing) {
                    const telegraphProgress = (time - mob.userData.telegraphStart) / attackWindup;
                    // Pulse effect during windup
                    const pulseScale = 1 + Math.sin(telegraphProgress * Math.PI * 4) * 0.15;
                    mob.scale.setScalar(pulseScale);

                    // Execute attack when windup completes
                    if (time >= mob.userData.telegraphEnd) {
                        mob.userData.telegraphing = false;
                        mob.scale.setScalar(1);
                        // Restore original emissive
                        if (mob.material && mob.userData.originalEmissive !== undefined) {
                            mob.material.emissive.setHex(mob.userData.originalEmissive);
                        }
                        // Only deal damage if still in range
                        if (distToPlayer < attackRange * 1.2) {
                            // v4.6: Apply damage multiplier from status effects
                            const actualDamage = Math.floor(mob.userData.damage * (mob.userData.damageMultiplier || 1));
                            damagePlayer(actualDamage);
                            spawnFloater(p.position, `-${actualDamage} HP`, '#ff4444');

                            // v4.7: Vampiric elite heals on hit
                            if (mob.userData.isElite && mob.userData.eliteData?.lifesteal) {
                                const healAmount = Math.floor(actualDamage * mob.userData.eliteData.lifesteal);
                                mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + healAmount);
                                spawnFloater(mob.position, `ü¶á +${healAmount}`, '#ff00ff');
                                // Update health bar
                                if (mob.userData.hpBar) {
                                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                                    mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                                }
                            }
                        }
                        mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                    }
                }

                // v4.7: Elite affix behaviors
                if (mob.userData.isElite && mob.userData.eliteData) {
                    const eliteData = mob.userData.eliteData;

                    // Regenerating: heal over time
                    if (eliteData.regenRate && mob.userData.hp < mob.userData.maxHp) {
                        const regenAmount = mob.userData.maxHp * eliteData.regenRate * dt;
                        mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + regenAmount);
                        // Update health bar
                        if (mob.userData.hpBar) {
                            const hpPercent = mob.userData.hp / mob.userData.maxHp;
                            mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                        }
                    }

                    // Teleporter: blink towards player when in aggro range
                    if (eliteData.canTeleport && distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > 5) {
                        if (!mob.userData.lastTeleport || time - mob.userData.lastTeleport > 4000) {
                            // Teleport towards player
                            const teleportDist = Math.min(10, distToPlayer - 3);
                            const dir = _tempVec3B.subVectors(p.position, mob.position).normalize();
                            mob.position.add(dir.multiplyScalar(teleportDist));
                            mob.userData.lastTeleport = time;
                            spawnFloater(mob.position, 'üåÄ', '#9900ff');
                            if (particles) particles.emit(mob.position, 15, 0x9900ff, { spread: 3, lifetime: 500 });
                        }
                    }

                    // Chilling Aura: slow player when nearby
                    if (eliteData.chillingAura && distToPlayer < 6) {
                        if (!playerState.chilled || time > playerState.chilledEnd) {
                            playerState.chilled = true;
                            playerState.chilledEnd = time + 500;
                            playerState.moveSpeedMult = 0.5;
                        }
                    }

                    // Animate elite aura ring
                    if (mob.userData.auraRing) {
                        mob.userData.auraRing.rotation.z += dt * 2;
                        const auraScale = 1 + Math.sin(time * 0.005) * 0.2;
                        mob.userData.auraRing.scale.set(auraScale, auraScale, 1);
                    }
                }

                // Update HP bar rotation to face camera
                if (mob.userData.hpBar) {
                    mob.userData.hpBar.lookAt(camera.position);
                }
            });

            // Animate fishing spots
            worldState.fishingSpots.forEach(spot => {
                if (spot.userData.ripple) {
                    const scale = 1 + Math.sin(time * 0.003) * 0.2;
                    spot.userData.ripple.scale.set(scale, scale, 1);
                }
            });

            // Update minimap
            updateMinimap();

            // v4.8: Update ability cooldowns
            updateAbilityUI();
        }

        function snapToGround(obj) {
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;

            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx][gz];
                if(y > -50) {
                    const targetY = y + (obj === worldState.player ? 1.2 : 0.8);
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.15);
                }
            }
        }

        // v4.2: Calculate player damage with weapon bonus and skill levels
        function getPlayerDamage() {
            let baseDamage = 1;
            let weaponBonus = 0;

            // Check all weapons for the best combat bonus
            const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade', 'Sword'];
            for (const weapon of weapons) {
                if (hasItem(weapon)) {
                    weaponBonus = Math.max(weaponBonus, ITEMS[weapon].combatBonus || 0);
                    break; // Use best available
                }
            }

            // Skill bonus: +1 damage every 3 combat levels
            const skillBonus = Math.floor(gameData.skills.combat.level / 3);

            let totalDamage = baseDamage + weaponBonus + skillBonus;

            // v4.6: Apply crit multiplier if in parry crit window
            if (isInCritWindow()) {
                totalDamage = Math.floor(totalDamage * PARRY_CONFIG.CRIT_MULTIPLIER);
            }

            // v4.8: Apply combo multiplier
            const comboMult = getComboMultiplier();
            if (comboMult > 1) {
                totalDamage = Math.floor(totalDamage * comboMult);
            }

            // v4.8: Apply War Cry damage boost
            if (isWarcryActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.warcry.damageBoost);
            }

            return totalDamage;
        }

        // v4.2: Calculate skill bonus for gathering (multiplier)
        function getSkillBonus(skillName) {
            const level = gameData.skills[skillName]?.level || 1;
            return 1 + Math.floor(level / 5) * 0.25; // +25% every 5 levels
        }

        // v4.2: Calculate player defense from armor
        function getPlayerDefense() {
            let defense = 0;
            if (hasItem('Chitin Armor')) defense += ITEMS['Chitin Armor'].defenseBonus;
            defense += Math.floor(gameData.skills.combat.level / 5); // +1 defense every 5 combat levels
            return defense;
        }

        function performAction(target) {
            const data = target.userData;

            // v4.2: Handle POI interactions differently
            if (data.type === 'poi') {
                if (!data.discovered) {
                    data.discovered = true;
                    gameData.statistics.poisDiscovered++;

                    // Mark as discovered for this planet
                    if (!gameData.discoveredPOIs[activeCiv.id]) {
                        gameData.discoveredPOIs[activeCiv.id] = [];
                    }
                    gameData.discoveredPOIs[activeCiv.id].push(data.poiType);

                    // Grant rewards
                    data.rewards.forEach(reward => {
                        const count = Array.isArray(reward.count)
                            ? Math.floor(Math.random() * (reward.count[1] - reward.count[0] + 1)) + reward.count[0]
                            : reward.count;
                        for (let i = 0; i < count; i++) {
                            addItem(reward.item);
                        }
                        spawnFloater(target.position, `+${count} ${reward.item}`, '#ffdd00');
                    });

                    // Grant XP bonus
                    addXp('combat', data.xpBonus);

                    spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.icon} ${data.name} DISCOVERED!`, '#ffdd00');
                    AudioSystem.levelUp();
                    if (particles) particles.emit(target.position, 30, 0xffdd00, { spread: 6, lifetime: 1500, size: 0.3 });

                    // Change POI appearance to show it's been discovered
                    if (data.beacon) data.beacon.material.emissiveIntensity = 0.1;
                    if (data.iconMesh) data.iconMesh.material.opacity = 0.3;

                    checkAchievements();
                    updateDailyChallengeProgress();
                    updatePlayerRank();
                } else {
                    spawnFloater(target.position, "Already discovered", '#888888');
                }
                return;
            }

            // v4.2: Calculate damage based on type
            let damage = 1;
            if (data.type === 'mob') {
                damage = getPlayerDamage();
            }

            // v4.8: Update combo state on combat hit
            const isCombatHit = data.type === 'mob' || data.type === 'boss';
            let comboHit = 0;
            if (isCombatHit) {
                comboHit = updateCombo(performance.now());
            }

            // v4.6: Show crit feedback if in crit window, v4.8: combo feedback
            const isCrit = isInCritWindow() && isCombatHit;
            const isFinisher = comboHit >= COMBO_CONFIG.MAX_HITS - 1;

            let hitText, hitColor;
            if (isFinisher) {
                hitText = `üí• FINISHER x${comboHit + 1}! -${damage}`;
                hitColor = '#ff00ff';
            } else if (isCrit) {
                hitText = `‚öîÔ∏è CRIT! -${damage}`;
                hitColor = '#ffd700';
            } else if (comboHit > 0) {
                hitText = `x${comboHit + 1} COMBO! -${damage}`;
                hitColor = '#00ffff';
            } else {
                hitText = damage > 1 ? `HIT! -${damage}` : "HIT!";
                hitColor = undefined;
            }

            spawnFloater(target.position, hitText, hitColor);
            AudioSystem.hit();

            data.hp -= damage;
            gameData.statistics.totalDamageDealt += damage;

            // v4.4: Hit-stop and flash for satisfying combat
            const isBossTarget = data.type === 'boss' || data.isBoss;
            const isMobTarget = data.type === 'mob';
            if (isBossTarget) {
                triggerHitStop(HIT_STOP_BOSS);
                flashTargetHit(target, 0xff4400);
            } else if (isMobTarget) {
                triggerHitStop(HIT_STOP_LIGHT);
                flashTargetHit(target, 0xff0000);
            }

            // v4.6: Apply elemental status effect on hit
            if (isMobTarget || isBossTarget) {
                const element = getEquippedElement();
                if (element) {
                    applyStatusEffect(target, element);
                }
            }

            // Visual feedback
            target.scale.setScalar(0.85);
            setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

            // v4.0: Hit particles based on type
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 :
                                     data.type === 'rock' ? 0x888888 :
                                     data.type === 'mob' ? (ENEMY_TYPES[data.name]?.color || 0x44ff44) : 0x4488ff;
                particles.emit(target.position, 5, particleColor, { spread: 2, lifetime: 600, size: 0.15 });
            }

            // Update mob health bar
            if (data.type === 'mob' && data.hpBar) {
                const hpPercent = data.hp / data.maxHp;
                data.hpBar.scale.x = Math.max(0.01, hpPercent);
                data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
            }

            if(data.hp <= 0) {
                if(data.type === 'tree') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('wood');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Log');
                    addXp('wood', 50);
                    gameData.statistics.treesChopped++;
                    spawnFloater(target.position, `+${totalYield} LOG`, '#da5');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 12, 0xdd9955, { spread: 4, lifetime: 1000 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'rock') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('mining');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Ore');
                    addXp('mining', 50);
                    gameData.statistics.oresMined++;
                    spawnFloater(target.position, `+${totalYield} ORE`, '#888');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 15, 0x888888, { spread: 3, lifetime: 800 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob' || data.type === 'boss') {
                    // v4.3: Handle both regular mobs and bosses
                    const isBoss = data.type === 'boss' || data.isBoss;

                    // v4.2/4.3: Drop items from enemy data
                    const drops = data.drops || ['Slime'];
                    // v4.7: Elite enemies drop more items
                    const dropMultiplier = data.isElite ? ELITE_CONFIG.bonusDropMult : 1;

                    drops.forEach(drop => {
                        // Handle boss drop format { item, count }
                        if (typeof drop === 'object') {
                            const count = drop.count * dropMultiplier;
                            for (let i = 0; i < count; i++) addItem(drop.item);
                            spawnFloater(target.position.clone().add(new THREE.Vector3(Math.random(), 1, Math.random())), `+${count} ${drop.item}`, '#ffd700');
                        } else {
                            for (let i = 0; i < dropMultiplier; i++) addItem(drop);
                        }
                    });

                    // v4.7: Elite essence drop
                    if (data.isElite && Math.random() < ELITE_CONFIG.essenceDropChance) {
                        const essenceCount = 1 + Math.floor(Math.random() * 3); // 1-3 essence
                        for (let i = 0; i < essenceCount; i++) addItem('Elite Essence');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1.5, 0)), `+${essenceCount} Elite Essence`, '#aa00ff');
                    }

                    const xpReward = data.xpReward || 100;
                    addXp('combat', xpReward);

                    // v4.7: Handle explosive affix death
                    if (data.isElite && data.eliteData?.explodeOnDeath) {
                        const explosionDamage = Math.floor(data.damage * 2);
                        const explosionRange = 5;
                        const distToPlayer = target.position.distanceTo(p.position);
                        if (distToPlayer < explosionRange) {
                            damagePlayer(explosionDamage, 'explosion');
                            spawnFloater(p.position, `üí• EXPLOSION! -${explosionDamage}`, '#ff6600');
                        }
                        if (particles) particles.emit(target.position, 40, 0xff6600, { spread: 8, lifetime: 1000, size: 0.4 });
                        screenShake(1.2);
                        AudioSystem.explosion && AudioSystem.explosion();
                    }

                    if (isBoss) {
                        gameData.statistics.bossesDefeated++;
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `BOSS DEFEATED! +${xpReward}XP`, '#ffd700');
                        showNotification(`${data.name} has been defeated!`, 'success');
                        // v4.4: Extra long hit-stop for boss kill
                        triggerHitStop(HIT_STOP_BOSS * 2);
                        screenShake(1.5);
                        // Extra celebration
                        if (particles) particles.emit(target.position, 50, 0xffd700, { spread: 8, lifetime: 2000, size: 0.4 });
                    } else {
                        gameData.statistics.mobsKilled++;
                        // v4.7: Track elite kills
                        if (data.isElite) {
                            gameData.statistics.elitesKilled = (gameData.statistics.elitesKilled || 0) + 1;
                            spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.eliteData.prefix} ELITE SLAIN! +${xpReward}XP`, '#ffaa00');
                            showNotification(`Elite ${data.name} defeated!`, 'success');
                            triggerHitStop(HIT_STOP_BOSS);
                        } else {
                            spawnFloater(target.position, `KILLED! +${xpReward}XP`, '#f00');
                            triggerHitStop(HIT_STOP_HEAVY);
                        }
                        worldMobKillCount++; // v4.3: Track for boss spawning
                        checkBossSpawn(); // v4.3: Check if boss should spawn
                    }

                    AudioSystem.kill();
                    const mobColor = data.isElite ? (data.eliteData?.color || 0xffaa00) :
                                    isBoss ? (BOSS_TYPES[data.bossId]?.color || 0xffd700) :
                                    (ENEMY_TYPES[data.name]?.color || 0x44ff44);
                    if (particles && !isBoss) particles.emit(target.position, data.isElite ? 30 : 20, mobColor, { spread: data.isElite ? 7 : 5, lifetime: 1200, size: data.isElite ? 0.35 : 0.25 });
                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                else if(data.type === 'fishing') {
                    if (hasItem('Fishing Rod')) {
                        // v4.2: Skill bonus for fishing
                        const skillMultiplier = getSkillBonus('fishing');
                        const fishCount = Math.floor(1 * skillMultiplier);
                        for (let i = 0; i < fishCount; i++) addItem('Raw Fish');
                        addXp('fishing', 40);
                        gameData.statistics.fishCaught += fishCount;
                        spawnFloater(target.position, `+${fishCount} FISH`, '#44f');
                        AudioSystem.collect();
                        if (particles) particles.emit(target.position, 8, 0x4488ff, { spread: 2, lifetime: 800, gravity: 5 });
                    } else {
                        spawnFloater(target.position, "Need Rod!", '#f44');
                        AudioSystem.error();
                    }
                    data.hp = data.maxHp = 1;
                    return;
                }
                worldState.interactTarget = null;

                checkAchievements();
                updateDailyChallengeProgress();
                updatePlayerRank();
            }
        }

        function damagePlayer(amount) {
            // v4.5: Check for dodge i-frames
            if (isInvincible()) {
                spawnFloater(worldState.player.position, 'DODGE!', '#88ffff');
                return;
            }

            // v4.8: Break combo on taking damage
            if (COMBO_CONFIG.BREAK_ON_DAMAGE && comboState.active) {
                breakCombo();
            }

            // v4.2: Apply defense reduction
            const defense = getPlayerDefense();
            const actualDamage = Math.max(1, amount - defense);
            gameData.player.hp = Math.max(0, gameData.player.hp - actualDamage);
            updateHealthUI();

            // v4.0: Enhanced damage feedback
            AudioSystem.damage();
            screenShake(amount * 0.1);
            flashDamageOverlay();

            if (gameData.player.hp <= 0) {
                playerDeath();
            }
        }

        function healPlayer(amount) {
            gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
            updateHealthUI();
            spawnFloater(worldState.player.position, `+${amount} HP`, '#44ff44');
            AudioSystem.heal(); // v4.0
        }

        function playerDeath() {
            showNotification('You died! Respawning...', 'error');
            gameData.player.hp = gameData.player.maxHp;
            worldState.player.position.set(0, 10, 0);
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();
        }

        function spawnFloater(pos, text, color='#fff') {
            // Use pool
            let floater = floaterPool.find(f => !f.active);
            if (!floater) {
                floater = floaterPool[0]; // Reuse oldest
            }

            floater.active = true;
            floater.el.textContent = text;
            floater.el.style.color = color;
            floater.el.style.display = 'block';
            floater.el.style.animation = 'none';
            floater.el.offsetHeight; // Trigger reflow
            floater.el.style.animation = 'floatUp 1.5s forwards';

            const v = pos.clone();
            v.y += 2;
            v.project(camera);

            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;

            floater.el.style.left = x + 'px';
            floater.el.style.top = y + 'px';

            setTimeout(() => {
                floater.el.style.display = 'none';
                floater.active = false;
            }, 1400);
        }

        // --- INPUT HANDLERS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong>${civ.name}</strong><br>Biome: ${civ.biomeName}<br>Pop: ${civ.pop}M${civ.visited ? '<br><span style="color:#0f0">Visited</span>' : ''}<br><span style="color:#888">Click to Land</span>`;
                        document.body.style.cursor = 'pointer';

                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
            } else if (mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        const hpText = obj.userData.hp !== undefined ? `<br>HP: ${obj.userData.hp}/${obj.userData.maxHp}` : '';
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong>${hpText}<br><span style="color:#888">Click to Interact</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy') selectionRing.visible = false;
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        initWorld(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    spawnFloater(obj.position, "Targeting...", '#0ff');
                    return;
                }

                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null;

                    const m = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                    );
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(() => scene.remove(m), 400);
                }
            }
        }

        // Touch handlers
        let touchStartPos = null;

        // v4.3: Virtual Joystick state
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        const joystickMaxDist = 40;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            if (touchStartPos) {
                raycaster.setFromCamera(mouse, camera);
                onMouseDown({ clientX: touchStartPos.x, clientY: touchStartPos.y });
                touchStartPos = null;
            }
        }

        function onTouchAction() {
            // Quick action button - interact with nearest target
            if (mode === 'world' && worldState.interactTarget) {
                performAction(worldState.interactTarget);
            }
        }

        function onKeyDown(e) {
            // WASD movement
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                e.preventDefault();
            }

            // Number keys 1-9 to use inventory items
            if (mode === 'world' && e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                useInventoryItem(idx);
            }
            // E to eat food
            if (e.key === 'e' || e.key === 'E') {
                const foodIdx = gameData.inventory.findIndex(item =>
                    item && (item.name === 'Cooked Fish' || item.name === 'Health Potion')
                );
                if (foodIdx >= 0) useInventoryItem(foodIdx);
            }
            // H for help/tutorial
            if (e.key === 'h' || e.key === 'H') {
                showTutorial();
            }
            // v4.5: Space or Shift to dodge
            if (e.key === ' ' || e.key === 'Shift') {
                if (mode === 'world') {
                    startDodge();
                    e.preventDefault();
                }
            }
            // v4.8: Combat abilities Q/E/R
            if (mode === 'world') {
                if (e.key === 'q' || e.key === 'Q') {
                    useAbility('powerStrike');
                    e.preventDefault();
                }
                if (e.key === 'e' || e.key === 'E') {
                    // E is now abilities, but keep food eating as fallback if no ability ready
                    if (!useAbility('whirlwind')) {
                        const foodIdx = gameData.inventory.findIndex(item =>
                            item && (item.name === 'Cooked Fish' || item.name === 'Health Potion' || item.name === 'Super Potion')
                        );
                        if (foodIdx >= 0) useInventoryItem(foodIdx);
                    }
                    e.preventDefault();
                }
                if (e.key === 'r' || e.key === 'R') {
                    useAbility('warcry');
                    e.preventDefault();
                }
            }
        }

        function onKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            saveGameData();
            initGalaxy();
            activeCiv = null;
        }

        // --- INVENTORY & RPG ---
        function addItem(name) {
            const itemDef = ITEMS[name];
            if (!itemDef) return false;

            // Find existing stack
            if (itemDef.stackable) {
                const existing = gameData.inventory.find(item =>
                    item && item.name === name && item.count < (itemDef.maxStack || 99)
                );
                if (existing) {
                    existing.count++;
                    updateInventoryUI();
                    return true;
                }
            }

            // Add new slot
            if (gameData.inventory.length < 20) {
                gameData.inventory.push({ name, count: 1 });
                updateInventoryUI();
                return true;
            }

            spawnFloater(worldState.player.position, "Inventory full!", '#f44');
            return false;
        }

        function removeItem(name, count = 1) {
            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (item && item.name === name) {
                    item.count -= count;
                    if (item.count <= 0) {
                        gameData.inventory.splice(i, 1);
                    }
                    updateInventoryUI();
                    return true;
                }
            }
            return false;
        }

        function hasItem(name, count = 1) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item && item.count >= count;
        }

        function countItem(name) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item ? item.count : 0;
        }

        function useInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const def = ITEMS[item.name];
            if (def && def.heal) {
                if (gameData.player.hp < gameData.player.maxHp) {
                    healPlayer(def.heal);
                    removeItem(item.name, 1);
                } else {
                    showNotification('Health is already full!');
                }
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            gameData.inventory.forEach((item, idx) => {
                if (!item) return;
                const def = ITEMS[item.name] || { icon: '?' };
                const slot = document.createElement('div');
                slot.className = 'inv-slot';

                // v4.8: Build detailed tooltip
                const tooltip = buildItemTooltip(item.name, def, item.count);
                slot.title = tooltip;

                slot.innerHTML = `${def.icon}<div class="inv-count">${item.count}</div>`;
                slot.onclick = () => useInventoryItem(idx);
                grid.appendChild(slot);
            });

            // Fill empty slots
            for (let i = gameData.inventory.length; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }

            document.getElementById('inv-count').textContent = gameData.inventory.length;
        }

        // v4.8: Build detailed item tooltip
        function buildItemTooltip(name, def, count) {
            let lines = [name];

            // Add quantity for stackable items
            if (def.stackable && count > 1) {
                lines[0] += ` (x${count})`;
            }

            // Healing items
            if (def.heal) {
                lines.push(`Heals ${def.heal} HP`);
                lines.push('Click or press E to use');
            }

            // Combat bonuses
            if (def.combatBonus) {
                lines.push(`Combat: +${def.combatBonus} damage`);
            }

            // Defense
            if (def.defenseBonus) {
                lines.push(`Defense: +${def.defenseBonus}`);
            }

            // Mining/Tool bonuses
            if (def.miningBonus) {
                lines.push(`Mining: x${def.miningBonus} yield`);
            }
            if (def.fishingBonus) {
                lines.push(`Fishing: x${def.fishingBonus} yield`);
            }

            // Elemental
            if (def.element) {
                const elementNames = { ice: 'Ice (Slow)', fire: 'Fire (Burn)', void: 'Void (Weaken)', cosmic: 'Cosmic (All)' };
                lines.push(`Element: ${elementNames[def.element] || def.element}`);
            }

            // Lifesteal
            if (def.lifesteal) {
                lines.push(`Lifesteal: ${Math.floor(def.lifesteal * 100)}%`);
            }

            // Attack speed
            if (def.attackSpeedMult) {
                lines.push(`Attack Speed: +${Math.floor((def.attackSpeedMult - 1) * 100)}%`);
            }

            // Max stack info for materials
            if (def.stackable && def.maxStack) {
                lines.push(`Max Stack: ${def.maxStack}`);
            }

            return lines.join('\\n');
        }

        function addXp(skill, amt) {
            if (!gameData.skills[skill]) return;

            // v4.4: Apply prestige XP multiplier
            const multiplier = gameData.prestige?.bonuses?.xpMultiplier || 1.0;
            const adjustedAmt = Math.round(amt * multiplier);

            const oldLevel = gameData.skills[skill].level;
            gameData.skills[skill].xp += adjustedAmt;

            // Check level up
            const newLevel = Math.floor(Math.sqrt(gameData.skills[skill].xp / 100)) + 1;
            gameData.skills[skill].level = newLevel;

            if (newLevel > oldLevel) {
                showNotification(`${skill.charAt(0).toUpperCase() + skill.slice(1)} leveled up to ${newLevel}!`);
                AudioSystem.levelUp(); // v4.0
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `LEVEL UP!`, '#ffff00');
                    // v4.0: Level up particle burst
                    if (particles) particles.emit(worldState.player.position, 25, 0xffff00, { spread: 6, lifetime: 1500, gravity: 3 });
                }
            }

            updateSkillsUI();
        }

        function updateSkillsUI() {
            const skills = ['mining', 'wood', 'combat', 'fishing', 'cooking', 'crafting'];

            skills.forEach(skill => {
                const data = gameData.skills[skill];
                if (!data) return;

                const level = data.level;
                const xp = data.xp;
                const nextLevelXp = Math.pow(level, 2) * 100;
                const prevLevelXp = Math.pow(level - 1, 2) * 100;
                const progress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

                const lvlEl = document.getElementById(`lvl-${skill}`);
                const barEl = document.getElementById(`bar-${skill}`);

                if (lvlEl) lvlEl.textContent = level;
                if (barEl) barEl.style.width = Math.min(100, progress) + '%';
            });
        }

        function updateHealthUI() {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const percent = (hp / maxHp) * 100;

            document.getElementById('player-health-fill').style.width = percent + '%';
            document.getElementById('health-text').textContent = `${Math.round(hp)} / ${maxHp}`;
        }

        // v4.8: Update ability UI cooldowns and states
        function updateAbilityUI() {
            const abilities = [
                { key: 'q', id: 'powerStrike', slot: 'ability-q', cooldown: 'cooldown-q' },
                { key: 'e', id: 'whirlwind', slot: 'ability-e', cooldown: 'cooldown-e' },
                { key: 'r', id: 'warcry', slot: 'ability-r', cooldown: 'cooldown-r' }
            ];

            abilities.forEach(({ key, id, slot, cooldown }) => {
                const slotEl = document.getElementById(slot);
                const cdEl = document.getElementById(cooldown);
                const ability = COMBAT_ABILITIES[id];

                if (!slotEl || !cdEl) return;

                // Check if unlocked
                const unlocked = isAbilityUnlocked(id);
                slotEl.classList.toggle('locked', !unlocked);

                // Check cooldown
                const cdRemaining = getAbilityCooldownRemaining(id);
                const onCooldown = cdRemaining > 0;
                slotEl.classList.toggle('on-cooldown', onCooldown);

                // Show cooldown overlay
                if (onCooldown) {
                    const cdPercent = (cdRemaining / ability.cooldown) * 100;
                    cdEl.style.height = cdPercent + '%';
                } else {
                    cdEl.style.height = '0%';
                }

                // Special: War Cry active state
                if (id === 'warcry' && isWarcryActive()) {
                    slotEl.classList.add('active-buff');
                } else if (id === 'warcry') {
                    slotEl.classList.remove('active-buff');
                }
            });
        }

        function updatePlaytimeDisplay() {
            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('total-playtime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
        }

        // --- CRAFTING ---
        function craft(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            // v4.2: Check crafting level requirement
            if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                showNotification(`Requires Crafting level ${recipe.craftingLevel}!`, 'error');
                AudioSystem.error();
                return;
            }

            // Check requirements
            for (const [item, count] of Object.entries(recipe.requires)) {
                if (!hasItem(item, count)) {
                    showNotification(`Need ${count}x ${item}!`, 'error');
                    AudioSystem.error(); // v4.0
                    return;
                }
            }

            // Consume materials
            for (const [item, count] of Object.entries(recipe.requires)) {
                removeItem(item, count);
            }

            // Add result
            addItem(recipe.result);
            addXp('crafting', 30);
            if (recipeId === 'cookedFish') {
                addXp('cooking', 25);
                gameData.statistics.fishCooked = (gameData.statistics.fishCooked || 0) + 1;
            }
            gameData.statistics.itemsCrafted++;

            // v4.1: Check achievements and daily progress
            checkAchievements();
            updateDailyChallengeProgress();

            showNotification(`Crafted ${recipe.result}!`);
            AudioSystem.craft(); // v4.0
            updateCraftingUI();
        }

        // v4.2: Enhanced crafting UI with level requirements and new recipes
        function updateCraftingUI() {
            const recipeDisplayNames = {
                'pickaxe': 'Pickaxe',
                'sword': 'Sword',
                'rod': 'Fishing Rod',
                'cookedFish': 'Cooked Fish',
                'potion': 'Health Potion',
                'frostBlade': 'Frost Blade',
                'magmaSword': 'Magma Sword',
                'voidDagger': 'Void Dagger',
                'crystalPickaxe': 'Crystal Pickaxe',
                'superPotion': 'Super Potion',
                'chitinArmor': 'Chitin Armor'
            };

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const btn = document.getElementById(`craft-${id}`);
                if (!btn) continue;

                let canCraft = true;
                let reqParts = [];

                // v4.2: Check level requirement
                if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                    canCraft = false;
                    reqParts.push(`Lvl ${recipe.craftingLevel} req`);
                }

                for (const [item, count] of Object.entries(recipe.requires)) {
                    const have = countItem(item);
                    if (have < count) canCraft = false;
                    reqParts.push(`${have}/${count} ${item}`);
                }
                btn.disabled = !canCraft;
                btn.innerHTML = `${recipeDisplayNames[id] || recipe.result}<br><small style="opacity:0.7">${reqParts.join(', ')}</small>`;
            }
        }

        // --- MINIMAP ---
        let minimapCtx;

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 100;
            canvas.height = 100;
            minimapCtx = canvas.getContext('2d');
        }

        // v4.4: Update fog of war exploration
        function updateExploration() {
            if (!worldState.player || !activeCiv) return;

            const planetId = activeCiv.id;
            if (!gameData.exploredTiles[planetId]) {
                gameData.exploredTiles[planetId] = {};
            }

            // Mark tiles within vision radius as explored
            const px = Math.floor(worldState.player.position.x / 10);
            const pz = Math.floor(worldState.player.position.z / 10);
            const visionRadius = 3;

            for (let dx = -visionRadius; dx <= visionRadius; dx++) {
                for (let dz = -visionRadius; dz <= visionRadius; dz++) {
                    if (dx * dx + dz * dz <= visionRadius * visionRadius) {
                        const key = `${px + dx},${pz + dz}`;
                        gameData.exploredTiles[planetId][key] = 1;
                    }
                }
            }
        }

        function isTileExplored(planetId, worldX, worldZ) {
            const tx = Math.floor(worldX / 10);
            const tz = Math.floor(worldZ / 10);
            const key = `${tx},${tz}`;
            return gameData.exploredTiles[planetId]?.[key] === 1;
        }

        function updateMinimap() {
            if (!minimapCtx || !worldState.player) return;

            // v4.4: Update exploration tracking
            updateExploration();

            const ctx = minimapCtx;
            const size = 100;
            const scale = size / (CONFIG.WORLD_SIZE * 2);
            const planetId = activeCiv?.id;

            // Clear with fog of war (darker)
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, size, size);

            // v4.4: Draw explored areas lighter
            if (planetId && gameData.exploredTiles[planetId]) {
                ctx.fillStyle = '#181818';
                for (const key in gameData.exploredTiles[planetId]) {
                    const [tx, tz] = key.split(',').map(Number);
                    const x = (tx * 10 + CONFIG.WORLD_SIZE) * scale;
                    const y = (tz * 10 + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 5 * scale, y - 5 * scale, 10 * scale, 10 * scale);
                }
            }

            // Draw terrain bounds
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0, 0, size, size);

            // Draw interactables (only in explored areas)
            ctx.fillStyle = '#0a0';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'tree') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            ctx.fillStyle = '#888';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'rock') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            // Draw mobs
            ctx.fillStyle = '#f00';
            worldState.mobs.forEach(mob => {
                const x = (mob.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (mob.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // v4.2: Draw POIs
            worldState.pois.forEach(poi => {
                const x = (poi.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (poi.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.fillStyle = poi.userData.discovered ? '#666' : '#ffd700';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                if (!poi.userData.discovered) {
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Draw player
            ctx.fillStyle = '#ff0';
            const px = (worldState.player.position.x + CONFIG.WORLD_SIZE) * scale;
            const py = (worldState.player.position.z + CONFIG.WORLD_SIZE) * scale;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start
        init();
    </script>
</body>
</html>
