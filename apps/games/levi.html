<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        /* System fonts - local-first compliant, no external dependencies */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vw, 32px);
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
            font-weight: bold;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2vw, 12px);
        }

        .stats-box {
            display: flex;
            gap: 15px;
            text-align: right;
            flex-wrap: wrap;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: clamp(14px, 3vw, 20px); color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: clamp(8px, 1.5vw, 10px); color: #666; text-transform: uppercase; }

        /* Data Controls - Import/Export */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Player Health Bar */
        .player-health-bar {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 250px);
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #f44;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            pointer-events: none;
        }

        .player-health-fill {
            height: 100%;
            background: linear-gradient(to right, #f44, #ff6666);
            width: 100%;
            transition: width 0.3s;
        }

        .player-health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            line-height: 20px;
            text-shadow: 1px 1px 2px #000;
        }

        /* RPG INTERFACE (Bottom) */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, rgba(5,5,5,0.95), transparent);
            display: none;
            padding: 10px;
            pointer-events: none;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-end;
            gap: 10px;
        }

        .inventory-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: clamp(200px, 40vw, 300px);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .panel-title {
            color: #fb0;
            font-family: Georgia, serif;
            border-bottom: 1px solid #445;
            margin-bottom: 10px;
            padding-bottom: 5px;
            font-size: clamp(12px, 2vw, 14px);
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 3vw, 20px);
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 35px;
            min-height: 35px;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 2px; right: 4px;
            font-size: clamp(9px, 1.5vw, 12px);
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        .player-stats {
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 12px;
            width: clamp(180px, 35vw, 250px);
        }

        .xp-bar-container {
            margin-bottom: 6px;
        }
        .xp-label { font-size: clamp(10px, 1.5vw, 12px); color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 6px; background: #222; border-radius: 3px; overflow: hidden; margin-top: 3px; }
        .xp-bar-fill { height: 100%; width: 0%; transition: width 0.3s; }

        /* Crafting Panel */
        .crafting-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: clamp(150px, 25vw, 200px);
        }

        .craft-btn {
            display: block;
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: clamp(10px, 1.5vw, 12px);
            transition: all 0.2s;
        }

        .craft-btn:hover:not(:disabled) { background: #555; border-color: #fb0; }
        .craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Action Buttons */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: Georgia, serif;
            pointer-events: auto;
            font-size: clamp(11px, 2vw, 14px);
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: clamp(12px, 2vw, 16px);
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: clamp(10px, 1.5vw, 12px);
            pointer-events: none;
            display: none;
            z-index: 100;
            border-radius: 4px;
            max-width: 200px;
        }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
            font-family: Georgia, serif;
        }

        .loading-text {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }

        .loading-bar {
            width: clamp(200px, 50vw, 300px);
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #0f0;
            animation: loadPulse 1s ease-in-out infinite;
        }

        @keyframes loadPulse {
            0%, 100% { width: 20%; margin-left: 0; }
            50% { width: 40%; margin-left: 60%; }
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 200px;
            right: 10px;
            width: clamp(80px, 15vw, 120px);
            height: clamp(80px, 15vw, 120px);
            background: rgba(0,0,0,0.7);
            border: 2px solid #445;
            border-radius: 8px;
            display: none;
            pointer-events: auto;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Touch Controls */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
            pointer-events: auto;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* Notification Toast */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px 20px;
            border-radius: 4px;
            color: #0f0;
            font-size: 14px;
            z-index: 500;
            animation: notifySlide 3s forwards;
            pointer-events: none;
        }

        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }

        .modal-content {
            background: #1a1a2e;
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
        }

        .modal-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 20px;
            font-family: Georgia, serif;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
            }

            .rpg-ui {
                flex-direction: column;
                align-items: center;
                max-height: 50vh;
                overflow-y: auto;
            }

            .inventory-panel, .player-stats, .crafting-panel {
                width: 95%;
                max-width: none;
            }

            .touch-controls {
                display: flex;
            }

            .data-controls {
                top: auto;
                bottom: 10px;
                right: 10px;
            }

            .minimap {
                bottom: auto;
                top: 70px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .inv-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .rpg-ui {
                padding: 5px;
            }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        <div class="loading-text">INITIALIZING OMNIVERSE ENGINE...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>

    <div id="container"></div>

    <div class="ui-layer">
        <!-- Data Controls - Import/Export -->
        <div class="data-controls">
            <button onclick="showSaveMenu()">Save</button>
            <button onclick="exportData()">Export</button>
            <button onclick="document.getElementById('importFile').click()">Import</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">GALAXY SIMULATION v4.0</div>
            </div>

            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="total-playtime">0:00</span>
                    <span class="stat-lbl">Playtime</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <div class="stat-entry">
                    <span class="stat-val" id="world-name">Terra</span>
                    <span class="stat-lbl">Planet</span>
                </div>
                <button class="action-btn" onclick="returnToGalaxy()">LEAVE PLANET</button>
            </div>
        </div>

        <!-- Player Health Bar -->
        <div id="player-health-bar" class="player-health-bar">
            <div class="player-health-text"><span id="health-text">100 / 100</span></div>
            <div id="player-health-fill" class="player-health-fill"></div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <!-- Minimap -->
        <div id="minimap" class="minimap">
            <canvas id="minimap-canvas" class="minimap-canvas"></canvas>
        </div>

        <div id="rpg-ui" class="rpg-ui">
            <div class="player-stats">
                <div class="panel-title">Skills</div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Fishing</span> <span id="lvl-fishing">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-fishing" class="xp-bar-fill" style="background:#44f"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Cooking</span> <span id="lvl-cooking">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-cooking" class="xp-bar-fill" style="background:#f80"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Crafting</span> <span id="lvl-crafting">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-crafting" class="xp-bar-fill" style="background:#a0f"></div></div>
                </div>
            </div>

            <div class="crafting-panel">
                <div class="panel-title">Crafting</div>
                <button class="craft-btn" id="craft-pickaxe" onclick="craft('pickaxe')">Pickaxe (3 Ore, 2 Log)</button>
                <button class="craft-btn" id="craft-sword" onclick="craft('sword')">Sword (5 Ore, 1 Log)</button>
                <button class="craft-btn" id="craft-rod" onclick="craft('rod')">Fishing Rod (2 Log)</button>
                <button class="craft-btn" id="craft-food" onclick="craft('cookedFish')">Cook Fish (1 Raw Fish)</button>
                <button class="craft-btn" id="craft-potion" onclick="craft('potion')">Health Potion (2 Slime)</button>
            </div>

            <div class="inventory-panel">
                <div class="panel-title">Backpack (<span id="inv-count">0</span>/20)</div>
                <div class="inv-grid" id="inventory-grid"></div>
            </div>
        </div>

        <!-- Touch Controls -->
        <div id="touch-controls" class="touch-controls">
            <div class="touch-btn" id="touch-action">A</div>
        </div>

    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 50;
        background: radial-gradient(transparent 30%, rgba(255,0,0,0.6));
        opacity: 0; transition: opacity 0.1s;
    "></div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Welcome to LEVIATHAN</div>
            <div style="color: #aaa; line-height: 1.8; margin-bottom: 20px;">
                <p style="margin-bottom: 15px;"><strong style="color: #0ff;">Galaxy Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Click on star systems to explore planets</li>
                    <li>Visited planets show a green ring</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #fb0;">Planet Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Click</strong> to move or interact with objects</li>
                    <li><strong>WASD</strong> keys for movement</li>
                    <li><strong>E</strong> to eat food and heal</li>
                    <li><strong>1-9</strong> to use inventory items</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #0f0;">Tips:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Gather logs and ore to craft tools</li>
                    <li>Tools increase resource yield</li>
                    <li>Green slimes are aggressive!</li>
                    <li>Fish for food, cook it to heal more</li>
                </ul>
            </div>
            <button class="action-btn" onclick="closeTutorial()" style="width: 100%;">START EXPLORING</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div class="modal-title">Game Saved</div>
            <p style="color: #aaa; margin-bottom: 15px;">Your progress has been saved to local storage.</p>
            <p style="color: #666; font-size: 12px;">Last saved: <span id="last-save-time">Never</span></p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === LEVIATHAN: OMNIVERSE v4.0 ===
        // Enhanced with local-first principles: localStorage persistence & JSON import/export
        // v4.0: Performance optimizations, audio system, particle effects, improved UX

        const APP_NAME = 'leviathan-omniverse';
        const VERSION = '4.0.0';

        // --- AUDIO SYSTEM (Web Audio API - No external dependencies) ---
        const AudioSystem = {
            ctx: null,
            enabled: true,
            masterVolume: 0.3,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone(freq, duration, type = 'sine', volume = 1) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(this.masterVolume * volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain).connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            hit() { this.playTone(200, 0.08, 'square', 0.5); },
            collect() { this.playTone(600, 0.12, 'sine', 0.6); },
            damage() { this.playTone(80, 0.15, 'sawtooth', 0.7); },
            kill() {
                this.playTone(150, 0.1, 'square', 0.5);
                setTimeout(() => this.playTone(100, 0.15, 'square', 0.4), 50);
            },
            levelUp() {
                [400, 500, 600, 800].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.15, 'sine', 0.5), i * 80);
                });
            },
            craft() { this.playTone(440, 0.1, 'triangle', 0.4); },
            click() { this.playTone(800, 0.03, 'sine', 0.2); },
            error() { this.playTone(100, 0.2, 'sawtooth', 0.3); },
            heal() { this.playTone(520, 0.2, 'sine', 0.4); }
        };

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 200;
            }

            emit(position, count, color, options = {}) {
                const spread = options.spread || 3;
                const lifetime = options.lifetime || 1000;
                const size = options.size || 0.2;
                const gravity = options.gravity !== undefined ? options.gravity : 10;

                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(size, 4, 4),
                            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * spread,
                            Math.random() * spread * 0.8 + spread * 0.2,
                            (Math.random() - 0.5) * spread
                        ),
                        lifetime,
                        startTime: performance.now(),
                        gravity
                    };
                    particle.mesh.position.copy(position);
                    particle.mesh.position.y += 1;
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }

            update(dt) {
                const now = performance.now();
                this.particles = this.particles.filter(p => {
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.lifetime;

                    if (progress >= 1) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    // Physics
                    p.velocity.y -= p.gravity * dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                    p.mesh.material.opacity = 1 - progress;
                    p.mesh.scale.setScalar(1 - progress * 0.5);

                    return true;
                });
            }
        }

        let particles;

        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            WORLD_SIZE: 100,
            TILE_SIZE: 2,
            PLAYER_MAX_HP: 100,
            MOB_DAMAGE: 5,
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            // New v4.0 constants
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 2,
            MOB_ATTACK_COOLDOWN: 1500,
            INTERACTION_RANGE: 3.5,
            INTERACTION_COOLDOWN: 400, // ms between actions
            MOVEMENT_THRESHOLD: 0.5,
            SCREEN_SHAKE_INTENSITY: 0.5,
            SCREEN_SHAKE_DURATION: 150
        };

        // --- PRE-ALLOCATED REUSABLE OBJECTS ---
        const _tempVec3A = new THREE.Vector3();
        const _tempVec3B = new THREE.Vector3();
        const _camOffset = new THREE.Vector3(0, 25, 25);

        // --- SCREEN EFFECTS ---
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0;
        let originalCameraPos = null;

        function screenShake(intensity = CONFIG.SCREEN_SHAKE_INTENSITY) {
            screenShakeIntensity = intensity;
            screenShakeDecay = intensity / (CONFIG.SCREEN_SHAKE_DURATION / 16);
            if (!originalCameraPos) originalCameraPos = new THREE.Vector3();
        }

        function updateScreenShake() {
            if (screenShakeIntensity > 0 && mode === 'world') {
                camera.position.x += (Math.random() - 0.5) * screenShakeIntensity;
                camera.position.y += (Math.random() - 0.5) * screenShakeIntensity;
                screenShakeIntensity -= screenShakeDecay;
                if (screenShakeIntensity < 0) screenShakeIntensity = 0;
            }
        }

        // Damage flash overlay
        function flashDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.4';
                setTimeout(() => overlay.style.opacity = '0', 150);
            }
        }

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, water: 0x2244aa, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, water: 0x446688, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, water: 0x88aadd, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, water: 0x8800ff, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, water: 0xff4400, name: 'Magma' }
        };

        const ITEMS = {
            'Log': { icon: 'ü™µ', stackable: true, maxStack: 99 },
            'Ore': { icon: 'ü™®', stackable: true, maxStack: 99 },
            'Slime': { icon: 'üü¢', stackable: true, maxStack: 99 },
            'Raw Fish': { icon: 'üêü', stackable: true, maxStack: 99 },
            'Cooked Fish': { icon: 'üçñ', stackable: true, maxStack: 99, heal: 20 },
            'Pickaxe': { icon: '‚õèÔ∏è', stackable: false, miningBonus: 2 },
            'Sword': { icon: 'üó°Ô∏è', stackable: false, combatBonus: 5 },
            'Fishing Rod': { icon: 'üé£', stackable: false, fishingBonus: 2 },
            'Health Potion': { icon: 'üß™', stackable: true, maxStack: 10, heal: 50 }
        };

        const RECIPES = {
            'pickaxe': { result: 'Pickaxe', requires: { 'Ore': 3, 'Log': 2 } },
            'sword': { result: 'Sword', requires: { 'Ore': 5, 'Log': 1 } },
            'rod': { result: 'Fishing Rod', requires: { 'Log': 2 } },
            'cookedFish': { result: 'Cooked Fish', requires: { 'Raw Fish': 1 } },
            'potion': { result: 'Health Potion', requires: { 'Slime': 2 } }
        };

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isTouchDevice = 'ontouchstart' in window;

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;
        let cycle = 0;

        // Floater pool for performance
        const floaterPool = [];
        const MAX_FLOATERS = 20;

        // RPG State
        let worldState = {
            player: null,
            terrain: [],
            interactables: [],
            fishingSpots: [],
            mobs: [],
            sun: null,
            ambient: null,
            timeOfDay: 0,
            target: null,
            interactTarget: null,
            lastActionTime: 0 // v4.0: Cooldown-based interactions
        };

        // WASD Keyboard controls
        const keys = { w: false, a: false, s: false, d: false };

        // Persistent Game Data (saved to localStorage)
        let gameData = {
            version: VERSION,
            playtime: 0,
            lastPlayed: null,
            hasSeenTutorial: false, // v4.0: Tutorial tracking
            inventory: [],
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 },
                fishing: { level: 1, xp: 0 },
                cooking: { level: 1, xp: 0 },
                crafting: { level: 1, xp: 0 }
            },
            player: {
                hp: CONFIG.PLAYER_MAX_HP,
                maxHp: CONFIG.PLAYER_MAX_HP
            },
            visitedPlanets: [],
            statistics: {
                treesChopped: 0,
                oresMined: 0,
                mobsKilled: 0,
                fishCaught: 0,
                itemsCrafted: 0
            }
        };

        // Tutorial functions
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            gameData.hasSeenTutorial = true;
            saveGameData();
            AudioSystem.click();
        }

        // --- DATA PERSISTENCE ---
        function loadGameData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle version updates
                    gameData = { ...gameData, ...parsed };
                    // Ensure nested objects exist
                    gameData.skills = { ...gameData.skills, ...parsed.skills };
                    gameData.player = { ...gameData.player, ...parsed.player };
                    gameData.statistics = { ...gameData.statistics, ...parsed.statistics };
                    console.log('Game data loaded successfully');
                }
            } catch (e) {
                console.error('Failed to load game data:', e);
            }
        }

        function saveGameData() {
            try {
                gameData.lastPlayed = new Date().toISOString();
                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                console.log('Game saved');
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.version) {
                        gameData = { ...gameData, ...imported };
                        saveGameData();
                        showNotification('Save imported! Refreshing...');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        alert('Invalid save file format');
                    }
                } catch (error) {
                    alert('Failed to import: Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function showSaveMenu() {
            saveGameData();
            document.getElementById('last-save-time').textContent = new Date().toLocaleString();
            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeModal() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        function showNotification(message, type = 'success') {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            if (type === 'error') {
                notif.style.background = 'rgba(100, 0, 0, 0.9)';
                notif.style.borderColor = '#f00';
                notif.style.color = '#f00';
            }
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        // --- INITIALIZATION ---
        function init() {
            loadGameData();

            // v4.0: Initialize audio and particle systems
            AudioSystem.init();
            particles = new ParticleSystem();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize floater pool
            for (let i = 0; i < MAX_FLOATERS; i++) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.display = 'none';
                document.body.appendChild(el);
                floaterPool.push({ el, active: false });
            }

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            // Touch events
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'flex';
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.getElementById('touch-action').addEventListener('touchstart', onTouchAction);
            }

            // Keyboard events (including WASD)
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            initGalaxy();
            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();

            document.getElementById('loading').style.display = 'none';

            // v4.0: Show tutorial for first-time players
            if (!gameData.hasSeenTutorial) {
                setTimeout(showTutorial, 500);
            }

            // Autosave
            setInterval(() => {
                if (mode === 'world') {
                    saveGameData();
                }
            }, CONFIG.AUTOSAVE_INTERVAL);

            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            mode = 'galaxy';

            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield (optimized with BufferGeometry)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<8000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                const c = new THREE.Color().setHSL(Math.random() * 0.2 + 0.55, 0.2, 0.8 + Math.random() * 0.2);
                starColors.push(c.r, c.g, c.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 2, vertexColors: true })));

            // Civilizations
            const rng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();

            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(200, 1200);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = rng.range(-100, 100);

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));
                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i)
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);

                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(8, 16, 16),
                    new THREE.MeshBasicMaterial({color: color})
                );
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.2})
                );
                sysGroup.add(glow);

                // Mark visited planets
                if (civ.visited) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(18, 20, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2;
                    sysGroup.add(ring);
                }

                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('civ-count').innerText = CONFIG.NUM_CIVS;

            updatePlaytimeDisplay();
        }

        // --- WORLD MODE ---
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';

            // Mark as visited
            if (!gameData.visitedPlanets.includes(civ.id)) {
                gameData.visitedPlanets.push(civ.id);
                showNotification(`First visit to ${civ.name}!`);
            }

            while(scene.children.length > 0) scene.remove(scene.children[0]);

            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 1024;
            worldState.sun.shadow.mapSize.height = 1024;
            scene.add(worldState.sun);

            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.interactables = [];
            worldState.fishingSpots = [];
            worldState.mobs = [];

            // Merged geometry for better performance
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            const groundMat = new THREE.MeshLambertMaterial({ color: biome.ground });
            const waterMat = new THREE.MeshLambertMaterial({ color: biome.water, transparent: true, opacity: 0.8 });

            const worldGroup = new THREE.Group();

            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    const hVal = noise(x + civ.id, z + civ.id);
                    const height = Math.floor((hVal + 1) * 3);
                    const realY = height * CONFIG.TILE_SIZE/2;

                    const isWater = height < 1;

                    const mesh = new THREE.Mesh(groundGeo, isWater ? waterMat : groundMat);
                    mesh.position.set(
                        (x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE,
                        realY,
                        (z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE
                    );
                    mesh.receiveShadow = true;
                    worldGroup.add(mesh);

                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    // Fishing spots in water
                    if(isWater && rng.next() > 0.95) {
                        createFishingSpot(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                    }

                    // Trees/Rocks
                    if(!isWater && rng.next() > 0.85) {
                        const type = rng.next() > 0.5 ? 'tree' : 'rock';
                        createProp(type, mesh.position.x, mesh.position.y + CONFIG.TILE_SIZE/2, mesh.position.z, biome);
                    }
                }
            }
            scene.add(worldGroup);

            // Player
            const playerGeo = new THREE.CapsuleGeometry(0.8, 1.6, 4, 8);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.3, roughness: 0.7 });
            worldState.player = new THREE.Mesh(playerGeo, playerMat);
            worldState.player.position.set(0, 10, 0);
            worldState.player.castShadow = true;

            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = -0.8;
            worldState.player.add(ring);

            scene.add(worldState.player);

            // Mobs
            const mobCount = 5 + Math.floor(rng.next() * 5);
            for(let i=0; i<mobCount; i++) {
                createMob(rng, biome);
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('world-name').textContent = civ.biomeName;
            document.getElementById('rpg-ui').style.display = 'flex';
            document.getElementById('player-health-bar').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';

            worldState.target = null;
            worldState.interactTarget = null;

            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();
            updateCraftingUI();
            initMinimap();
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                    new THREE.MeshLambertMaterial({ color: 0x553311 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: biome.tree })
                );
                leaves.position.y = 2.8;
                leaves.castShadow = true;
                group.add(leaves);
                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: 'Ancient Tree' };
            } else {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1),
                    new THREE.MeshLambertMaterial({ color: biome.rock })
                );
                rock.position.y = 0.5;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createFishingSpot(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Ripple effect
            const ripple = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ripple.rotation.x = -Math.PI / 2;
            group.add(ripple);

            group.userData = { type: 'fishing', name: 'Fishing Spot', ripple };
            scene.add(group);
            worldState.fishingSpots.push(group);
            worldState.interactables.push(group);
        }

        function createMob(rng, biome) {
            const mobGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({ color: 0x44ff44, roughness: 0.3, emissive: 0x003300 });
            const mob = new THREE.Mesh(mobGeo, mobMat);

            const rx = (rng.next() - 0.5) * 60;
            const rz = (rng.next() - 0.5) * 60;
            mob.position.set(rx, 10, rz);
            mob.castShadow = true;

            // Health bar above mob
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.15),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide })
            );
            hpBar.position.y = 1.5;
            mob.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(1.6, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = 1.5;
            hpBg.position.z = -0.01;
            mob.add(hpBg);

            mob.userData = {
                type: 'mob',
                hp: 10,
                maxHp: 10,
                name: 'Slime',
                damage: CONFIG.MOB_DAMAGE,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar
            };

            scene.add(mob);
            worldState.mobs.push(mob);
        }

        // --- GAME LOOP ---
        function loop(time) {
            requestAnimationFrame(loop);

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            gameData.playtime += dt;

            if(mode === 'galaxy') {
                galaxyGroup.rotation.y += 0.0005;
                cycle = Math.floor(time / 1000);
                document.getElementById('cycle-count').innerText = cycle;

                if(activeCiv) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);
                }

                if (cycle % 10 === 0) updatePlaytimeDisplay();
            }
            else if(mode === 'world') {
                updateWorld(dt, time);
            }

            renderer.render(scene, camera);
        }

        function updateWorld(dt, time) {
            // Day/Night Cycle
            worldState.timeOfDay = (time * 0.00005) % 1;
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;

            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0.1, Math.sin(angle)) * 1.2;

            const biome = BIOMES[activeCiv.biome];
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x050510);
            scene.background.lerpColors(nightColor, dayColor, Math.max(0.1, Math.sin(angle)));
            scene.fog.color.copy(scene.background);

            // Player Movement
            const p = worldState.player;
            const speed = 12;

            // v4.0: WASD keyboard movement
            if (keys.w || keys.a || keys.s || keys.d) {
                _tempVec3A.set(0, 0, 0);
                if (keys.w) _tempVec3A.z -= 1;
                if (keys.s) _tempVec3A.z += 1;
                if (keys.a) _tempVec3A.x -= 1;
                if (keys.d) _tempVec3A.x += 1;
                _tempVec3A.normalize().multiplyScalar(speed * dt);
                p.position.add(_tempVec3A);
                worldState.target = null;
                worldState.interactTarget = null;
                // Face movement direction
                if (_tempVec3A.length() > 0.01) {
                    p.rotation.y = Math.atan2(_tempVec3A.x, _tempVec3A.z);
                }
            }

            // Click-to-move (using pre-allocated vector)
            if(worldState.target) {
                _tempVec3A.subVectors(worldState.target, p.position);
                _tempVec3A.y = 0;
                const dist = _tempVec3A.length();

                if(dist > CONFIG.MOVEMENT_THRESHOLD) {
                    _tempVec3A.normalize();
                    p.position.add(_tempVec3A.multiplyScalar(speed * dt));
                    p.lookAt(worldState.target.x, p.position.y, worldState.target.z);
                } else {
                    worldState.target = null;
                }
            }

            snapToGround(p);

            // v4.0: Cooldown-based interaction (replaces random chance)
            if(worldState.interactTarget) {
                const t = worldState.interactTarget;
                const dist = p.position.distanceTo(t.position);

                if(dist < CONFIG.INTERACTION_RANGE) {
                    worldState.target = null;

                    const now = performance.now();
                    if(now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(t);
                        worldState.lastActionTime = now;
                    }
                } else if (!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // Camera Follow (using pre-allocated vector)
            camera.position.lerp(p.position.clone().add(_camOffset), 0.08);
            camera.lookAt(p.position);

            // v4.0: Screen shake effect
            updateScreenShake();

            // v4.0: Update particles
            if (particles) particles.update(dt);

            // Mob AI with aggro (using CONFIG constants)
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;

                const distToPlayer = mob.position.distanceTo(p.position);

                // Aggro range
                if (distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > CONFIG.MOB_ATTACK_RANGE) {
                    mob.userData.targetPos.copy(p.position);
                    mob.userData.nextMove = time + 500;
                } else if(time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob (using temp vector)
                _tempVec3B.subVectors(mob.userData.targetPos, mob.position);
                _tempVec3B.y = 0;
                if(_tempVec3B.length() > 0.1) {
                    _tempVec3B.normalize();
                    mob.position.add(_tempVec3B.multiplyScalar(4 * dt));
                }
                snapToGround(mob);

                // Attack player
                if (distToPlayer < CONFIG.MOB_ATTACK_RANGE && time > mob.userData.nextAttack) {
                    damagePlayer(mob.userData.damage);
                    spawnFloater(p.position, `-${mob.userData.damage} HP`, '#ff4444');
                    mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                }

                // Update HP bar rotation to face camera
                if (mob.userData.hpBar) {
                    mob.userData.hpBar.lookAt(camera.position);
                }
            });

            // Animate fishing spots
            worldState.fishingSpots.forEach(spot => {
                if (spot.userData.ripple) {
                    const scale = 1 + Math.sin(time * 0.003) * 0.2;
                    spot.userData.ripple.scale.set(scale, scale, 1);
                }
            });

            // Update minimap
            updateMinimap();
        }

        function snapToGround(obj) {
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;

            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx][gz];
                if(y > -50) {
                    const targetY = y + (obj === worldState.player ? 1.2 : 0.8);
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.15);
                }
            }
        }

        function performAction(target) {
            const data = target.userData;

            spawnFloater(target.position, "HIT!");
            AudioSystem.hit(); // v4.0: Audio feedback

            data.hp--;

            // Visual feedback
            target.scale.setScalar(0.85);
            setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

            // v4.0: Hit particles based on type
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 :
                                     data.type === 'rock' ? 0x888888 :
                                     data.type === 'mob' ? 0x44ff44 : 0x4488ff;
                particles.emit(target.position, 5, particleColor, { spread: 2, lifetime: 600, size: 0.15 });
            }

            // Update mob health bar
            if (data.type === 'mob' && data.hpBar) {
                const hpPercent = data.hp / data.maxHp;
                data.hpBar.scale.x = Math.max(0.01, hpPercent);
                data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
            }

            if(data.hp <= 0) {
                if(data.type === 'tree') {
                    const bonus = hasItem('Pickaxe') ? 2 : 1;
                    for (let i = 0; i < bonus; i++) addItem('Log');
                    addXp('wood', 50);
                    gameData.statistics.treesChopped++;
                    spawnFloater(target.position, `+${bonus} LOG`, '#da5');
                    AudioSystem.collect(); // v4.0
                    if (particles) particles.emit(target.position, 12, 0xdd9955, { spread: 4, lifetime: 1000 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'rock') {
                    const bonus = hasItem('Pickaxe') ? 2 : 1;
                    for (let i = 0; i < bonus; i++) addItem('Ore');
                    addXp('mining', 50);
                    gameData.statistics.oresMined++;
                    spawnFloater(target.position, `+${bonus} ORE`, '#888');
                    AudioSystem.collect(); // v4.0
                    if (particles) particles.emit(target.position, 15, 0x888888, { spread: 3, lifetime: 800 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob') {
                    const bonus = hasItem('Sword') ? 2 : 1;
                    for (let i = 0; i < bonus; i++) addItem('Slime');
                    addXp('combat', 100);
                    gameData.statistics.mobsKilled++;
                    spawnFloater(target.position, "KILLED!", '#f00');
                    AudioSystem.kill(); // v4.0
                    if (particles) particles.emit(target.position, 20, 0x44ff44, { spread: 5, lifetime: 1200, size: 0.25 });
                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                else if(data.type === 'fishing') {
                    if (hasItem('Fishing Rod')) {
                        addItem('Raw Fish');
                        addXp('fishing', 40);
                        gameData.statistics.fishCaught++;
                        spawnFloater(target.position, "+1 FISH", '#44f');
                        AudioSystem.collect(); // v4.0
                        if (particles) particles.emit(target.position, 8, 0x4488ff, { spread: 2, lifetime: 800, gravity: 5 });
                    } else {
                        spawnFloater(target.position, "Need Rod!", '#f44');
                        AudioSystem.error(); // v4.0
                    }
                    // Fishing spots respawn HP
                    data.hp = data.maxHp = 1;
                    return;
                }
                worldState.interactTarget = null;
            }
        }

        function damagePlayer(amount) {
            gameData.player.hp = Math.max(0, gameData.player.hp - amount);
            updateHealthUI();

            // v4.0: Enhanced damage feedback
            AudioSystem.damage();
            screenShake(amount * 0.1);
            flashDamageOverlay();

            if (gameData.player.hp <= 0) {
                playerDeath();
            }
        }

        function healPlayer(amount) {
            gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
            updateHealthUI();
            spawnFloater(worldState.player.position, `+${amount} HP`, '#44ff44');
            AudioSystem.heal(); // v4.0
        }

        function playerDeath() {
            showNotification('You died! Respawning...', 'error');
            gameData.player.hp = gameData.player.maxHp;
            worldState.player.position.set(0, 10, 0);
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();
        }

        function spawnFloater(pos, text, color='#fff') {
            // Use pool
            let floater = floaterPool.find(f => !f.active);
            if (!floater) {
                floater = floaterPool[0]; // Reuse oldest
            }

            floater.active = true;
            floater.el.textContent = text;
            floater.el.style.color = color;
            floater.el.style.display = 'block';
            floater.el.style.animation = 'none';
            floater.el.offsetHeight; // Trigger reflow
            floater.el.style.animation = 'floatUp 1.5s forwards';

            const v = pos.clone();
            v.y += 2;
            v.project(camera);

            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;

            floater.el.style.left = x + 'px';
            floater.el.style.top = y + 'px';

            setTimeout(() => {
                floater.el.style.display = 'none';
                floater.active = false;
            }, 1400);
        }

        // --- INPUT HANDLERS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong>${civ.name}</strong><br>Biome: ${civ.biomeName}<br>Pop: ${civ.pop}M${civ.visited ? '<br><span style="color:#0f0">Visited</span>' : ''}<br><span style="color:#888">Click to Land</span>`;
                        document.body.style.cursor = 'pointer';

                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
            } else if (mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        const hpText = obj.userData.hp !== undefined ? `<br>HP: ${obj.userData.hp}/${obj.userData.maxHp}` : '';
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong>${hpText}<br><span style="color:#888">Click to Interact</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy') selectionRing.visible = false;
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        initWorld(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    spawnFloater(obj.position, "Targeting...", '#0ff');
                    return;
                }

                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null;

                    const m = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                    );
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(() => scene.remove(m), 400);
                }
            }
        }

        // Touch handlers
        let touchStartPos = null;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            if (touchStartPos) {
                raycaster.setFromCamera(mouse, camera);
                onMouseDown({ clientX: touchStartPos.x, clientY: touchStartPos.y });
                touchStartPos = null;
            }
        }

        function onTouchAction() {
            // Quick action button - interact with nearest target
            if (mode === 'world' && worldState.interactTarget) {
                performAction(worldState.interactTarget);
            }
        }

        function onKeyDown(e) {
            // WASD movement
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                e.preventDefault();
            }

            // Number keys 1-9 to use inventory items
            if (mode === 'world' && e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                useInventoryItem(idx);
            }
            // E to eat food
            if (e.key === 'e' || e.key === 'E') {
                const foodIdx = gameData.inventory.findIndex(item =>
                    item && (item.name === 'Cooked Fish' || item.name === 'Health Potion')
                );
                if (foodIdx >= 0) useInventoryItem(foodIdx);
            }
            // H for help/tutorial
            if (e.key === 'h' || e.key === 'H') {
                showTutorial();
            }
        }

        function onKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            saveGameData();
            initGalaxy();
            activeCiv = null;
        }

        // --- INVENTORY & RPG ---
        function addItem(name) {
            const itemDef = ITEMS[name];
            if (!itemDef) return false;

            // Find existing stack
            if (itemDef.stackable) {
                const existing = gameData.inventory.find(item =>
                    item && item.name === name && item.count < (itemDef.maxStack || 99)
                );
                if (existing) {
                    existing.count++;
                    updateInventoryUI();
                    return true;
                }
            }

            // Add new slot
            if (gameData.inventory.length < 20) {
                gameData.inventory.push({ name, count: 1 });
                updateInventoryUI();
                return true;
            }

            spawnFloater(worldState.player.position, "Inventory full!", '#f44');
            return false;
        }

        function removeItem(name, count = 1) {
            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (item && item.name === name) {
                    item.count -= count;
                    if (item.count <= 0) {
                        gameData.inventory.splice(i, 1);
                    }
                    updateInventoryUI();
                    return true;
                }
            }
            return false;
        }

        function hasItem(name, count = 1) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item && item.count >= count;
        }

        function countItem(name) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item ? item.count : 0;
        }

        function useInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const def = ITEMS[item.name];
            if (def && def.heal) {
                if (gameData.player.hp < gameData.player.maxHp) {
                    healPlayer(def.heal);
                    removeItem(item.name, 1);
                } else {
                    showNotification('Health is already full!');
                }
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            gameData.inventory.forEach((item, idx) => {
                if (!item) return;
                const def = ITEMS[item.name] || { icon: '?' };
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                slot.title = `${item.name}${def.heal ? ' (Click to use)' : ''}`;
                slot.innerHTML = `${def.icon}<div class="inv-count">${item.count}</div>`;
                slot.onclick = () => useInventoryItem(idx);
                grid.appendChild(slot);
            });

            // Fill empty slots
            for (let i = gameData.inventory.length; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }

            document.getElementById('inv-count').textContent = gameData.inventory.length;
        }

        function addXp(skill, amt) {
            if (!gameData.skills[skill]) return;

            const oldLevel = gameData.skills[skill].level;
            gameData.skills[skill].xp += amt;

            // Check level up
            const newLevel = Math.floor(Math.sqrt(gameData.skills[skill].xp / 100)) + 1;
            gameData.skills[skill].level = newLevel;

            if (newLevel > oldLevel) {
                showNotification(`${skill.charAt(0).toUpperCase() + skill.slice(1)} leveled up to ${newLevel}!`);
                AudioSystem.levelUp(); // v4.0
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `LEVEL UP!`, '#ffff00');
                    // v4.0: Level up particle burst
                    if (particles) particles.emit(worldState.player.position, 25, 0xffff00, { spread: 6, lifetime: 1500, gravity: 3 });
                }
            }

            updateSkillsUI();
        }

        function updateSkillsUI() {
            const skills = ['mining', 'wood', 'combat', 'fishing', 'cooking', 'crafting'];

            skills.forEach(skill => {
                const data = gameData.skills[skill];
                if (!data) return;

                const level = data.level;
                const xp = data.xp;
                const nextLevelXp = Math.pow(level, 2) * 100;
                const prevLevelXp = Math.pow(level - 1, 2) * 100;
                const progress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

                const lvlEl = document.getElementById(`lvl-${skill}`);
                const barEl = document.getElementById(`bar-${skill}`);

                if (lvlEl) lvlEl.textContent = level;
                if (barEl) barEl.style.width = Math.min(100, progress) + '%';
            });
        }

        function updateHealthUI() {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const percent = (hp / maxHp) * 100;

            document.getElementById('player-health-fill').style.width = percent + '%';
            document.getElementById('health-text').textContent = `${Math.round(hp)} / ${maxHp}`;
        }

        function updatePlaytimeDisplay() {
            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('total-playtime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
        }

        // --- CRAFTING ---
        function craft(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            // Check requirements
            for (const [item, count] of Object.entries(recipe.requires)) {
                if (!hasItem(item, count)) {
                    showNotification(`Need ${count}x ${item}!`, 'error');
                    AudioSystem.error(); // v4.0
                    return;
                }
            }

            // Consume materials
            for (const [item, count] of Object.entries(recipe.requires)) {
                removeItem(item, count);
            }

            // Add result
            addItem(recipe.result);
            addXp('crafting', 30);
            if (recipeId === 'cookedFish') {
                addXp('cooking', 25);
            }
            gameData.statistics.itemsCrafted++;

            showNotification(`Crafted ${recipe.result}!`);
            AudioSystem.craft(); // v4.0
            updateCraftingUI();
        }

        // v4.0: Enhanced crafting UI showing current resource counts
        function updateCraftingUI() {
            const recipeDisplayNames = {
                'pickaxe': 'Pickaxe',
                'sword': 'Sword',
                'rod': 'Fishing Rod',
                'cookedFish': 'Cooked Fish',
                'potion': 'Health Potion'
            };

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const btn = document.getElementById(`craft-${id}`);
                if (!btn) continue;

                let canCraft = true;
                let reqParts = [];
                for (const [item, count] of Object.entries(recipe.requires)) {
                    const have = countItem(item);
                    if (have < count) canCraft = false;
                    reqParts.push(`${have}/${count} ${item}`);
                }
                btn.disabled = !canCraft;
                btn.innerHTML = `${recipeDisplayNames[id] || recipe.result}<br><small style="opacity:0.7">${reqParts.join(', ')}</small>`;
            }
        }

        // --- MINIMAP ---
        let minimapCtx;

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 100;
            canvas.height = 100;
            minimapCtx = canvas.getContext('2d');
        }

        function updateMinimap() {
            if (!minimapCtx || !worldState.player) return;

            const ctx = minimapCtx;
            const size = 100;
            const scale = size / (CONFIG.WORLD_SIZE * 2);

            // Clear
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, size, size);

            // Draw terrain bounds
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0, 0, size, size);

            // Draw interactables
            ctx.fillStyle = '#0a0';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'tree') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            ctx.fillStyle = '#888';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'rock') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            // Draw mobs
            ctx.fillStyle = '#f00';
            worldState.mobs.forEach(mob => {
                const x = (mob.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (mob.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw player
            ctx.fillStyle = '#ff0';
            const px = (worldState.player.position.x + CONFIG.WORLD_SIZE) * scale;
            const py = (worldState.player.position.z + CONFIG.WORLD_SIZE) * scale;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start
        init();
    </script>
</body>
</html>
