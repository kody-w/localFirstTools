<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        /* System fonts - local-first compliant, no external dependencies */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vw, 32px);
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
            font-weight: bold;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2vw, 12px);
        }

        .stats-box {
            display: flex;
            gap: 15px;
            text-align: right;
            flex-wrap: wrap;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: clamp(14px, 3vw, 20px); color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: clamp(8px, 1.5vw, 10px); color: #666; text-transform: uppercase; }

        /* Data Controls - Import/Export */
        .data-controls {
            position: fixed;
            top: 8px;
            left: 220px;
            right: 180px;
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            pointer-events: auto;
            justify-content: center;
            align-items: flex-start;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        /* v5.7: Menu toggle for dropdown */
        .data-controls .menu-toggle {
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid #fff !important;
            color: #fff !important;
        }

        .data-controls .menu-toggle:hover {
            background: rgba(255, 255, 255, 0.3) !important;
        }

        .data-controls .menu-secondary {
            display: none;
            position: fixed;
            top: 40px;
            right: 180px;
            background: rgba(10, 10, 30, 0.98);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 8px;
            flex-direction: column;
            gap: 5px;
            min-width: 130px;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3);
            z-index: 1001;
        }

        .data-controls .menu-secondary.show {
            display: flex;
        }

        .data-controls .menu-secondary button {
            width: 100%;
            text-align: left;
            padding: 8px 12px;
        }

        /* v5.7: AI Companion Settings Modal - Tabbed Interface */
        .ai-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .ai-settings-modal.active { display: flex; }
        .ai-settings-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid #7b2cbf;
            border-radius: 20px;
            width: 94%;
            max-width: 580px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(123, 44, 191, 0.5), inset 0 0 100px rgba(123, 44, 191, 0.1);
            position: relative;
        }
        .ai-settings-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(123, 44, 191, 0.1) 0%, transparent 50%);
            animation: ai-glow-rotate 20s linear infinite;
            pointer-events: none;
        }
        @keyframes ai-glow-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .ai-settings-header {
            padding: 25px 25px 20px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        .ai-settings-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            font-style: italic;
            background: linear-gradient(135deg, #06ffa5, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .ai-settings-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 2;
        }
        .ai-settings-close:hover { opacity: 1; transform: scale(1.1); }

        /* Tabs */
        .ai-settings-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 20px 20px;
            position: relative;
            z-index: 1;
        }
        .ai-settings-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-settings-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-settings-tab.active {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            border-color: #06ffa5;
            color: #000;
            font-weight: bold;
        }

        /* Tab Content */
        .ai-settings-body {
            padding: 0 25px 20px;
            max-height: calc(90vh - 250px);
            overflow-y: auto;
            position: relative;
            z-index: 1;
        }
        .ai-tab-content {
            display: none;
        }
        .ai-tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Sections */
        .ai-section {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(123, 44, 191, 0.2);
        }
        .ai-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: bold;
            color: #06ffa5;
        }

        /* Form Elements */
        .ai-form-group {
            margin-bottom: 15px;
        }
        .ai-form-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }
        .ai-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .ai-input:focus {
            outline: none;
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }
        .ai-input::placeholder {
            color: #555;
        }
        .ai-select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
        }
        .ai-select:focus {
            outline: none;
            border-color: #06ffa5;
        }

        /* Toggle Switch */
        .ai-toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        .ai-toggle-label {
            font-size: 14px;
            color: #ddd;
        }
        .ai-toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        .ai-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .ai-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 26px;
            transition: 0.3s;
        }
        .ai-toggle-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }
        .ai-toggle input:checked + .ai-toggle-slider {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }
        .ai-toggle input:checked + .ai-toggle-slider::before {
            transform: translateX(24px);
        }

        /* Endpoint Cards */
        .ai-endpoint-card {
            padding: 15px;
            background: rgba(6, 255, 165, 0.05);
            border: 1px solid rgba(6, 255, 165, 0.2);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-endpoint-card:hover {
            background: rgba(6, 255, 165, 0.1);
            border-color: rgba(6, 255, 165, 0.4);
        }
        .ai-endpoint-card.active {
            background: rgba(6, 255, 165, 0.15);
            border-color: #06ffa5;
            box-shadow: 0 0 20px rgba(6, 255, 165, 0.2);
        }
        .ai-endpoint-name {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .ai-endpoint-url {
            font-size: 11px;
            color: #666;
            word-break: break-all;
        }
        .ai-endpoint-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 10px;
            margin-top: 8px;
            font-weight: bold;
        }
        .ai-endpoint-badge.active {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
        }
        .ai-endpoint-badge.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        /* Color Picker Row */
        .ai-color-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .ai-color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .ai-color-input {
            flex: 1;
        }

        /* Actions Footer */
        .ai-settings-footer {
            display: flex;
            gap: 15px;
            padding: 20px 25px;
            border-top: 1px solid rgba(123, 44, 191, 0.3);
            position: relative;
            z-index: 1;
        }
        .ai-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            font-family: inherit;
        }
        .ai-btn-save {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }
        .ai-btn-save:hover {
            box-shadow: 0 0 25px rgba(6, 255, 165, 0.5);
            transform: translateY(-2px);
        }
        .ai-btn-cancel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
        }
        .ai-btn-cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-btn-import {
            background: linear-gradient(135deg, #7b2cbf, #3a0ca3);
            color: #fff;
        }
        .ai-btn-import:hover {
            box-shadow: 0 0 20px rgba(123, 44, 191, 0.5);
        }

        /* Status Message */
        .ai-status-msg {
            text-align: center;
            padding: 10px;
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
        .ai-status-msg.success { color: #06ffa5; }
        .ai-status-msg.error { color: #f44; }

        /* Player Health Bar */
        .player-health-bar {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 250px);
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #f44;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            pointer-events: none;
        }

        .player-health-fill {
            height: 100%;
            background: linear-gradient(to right, #f44, #ff6666);
            width: 100%;
            transition: width 0.3s;
        }

        .player-health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            line-height: 20px;
            text-shadow: 1px 1px 2px #000;
        }

        /* v5.11: RTS-Style RPG INTERFACE - Edge Docked Panels */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            display: none;
            padding: 0;
            pointer-events: none;
        }

        /* RTS Panel Toggle Buttons - Bottom Left Corner */
        .rts-panel-toggles {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 4px;
            z-index: 1003;
            pointer-events: auto;
        }
        .rts-toggle-btn {
            width: 36px;
            height: 36px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 6px;
            color: #fb0;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .rts-toggle-btn:hover { border-color: #fb0; background: rgba(30, 35, 40, 0.95); }
        .rts-toggle-btn.active { border-color: #0ff; background: rgba(0, 60, 80, 0.5); }
        .rts-toggle-btn .toggle-key {
            position: absolute;
            bottom: -1px;
            right: 2px;
            font-size: 8px;
            color: #666;
        }

        /* Skills Panel - Left Edge Dock */
        .player-stats {
            position: fixed;
            bottom: 55px;
            left: 0;
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 8px 10px;
            width: 160px;
            max-height: 240px;
            overflow-y: auto;
            z-index: 1001;
            transform: translateX(-100%);
            transition: transform 0.2s ease;
        }
        .player-stats.visible { transform: translateX(0); }

        /* Crafting Panel - Left Edge Dock (Below Skills) */
        .crafting-panel {
            position: fixed;
            bottom: 55px;
            left: 170px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            width: 150px;
            max-height: 280px;
            overflow-y: auto;
            z-index: 1001;
            transform: translateX(-300px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }
        .crafting-panel.visible { transform: translateX(0); opacity: 1; }

        /* Inventory Panel - Bottom Center Dock */
        .inventory-panel {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            width: 200px;
            z-index: 1001;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            transition: transform 0.2s ease;
        }
        .inventory-panel.visible { transform: translateX(-50%) translateY(0); }

        /* Equipment Panel - Right of Inventory */
        .equipment-panel {
            position: fixed;
            bottom: 10px;
            right: 80px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            width: 160px;
            z-index: 1001;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            transform: translateY(100%);
            transition: transform 0.2s ease;
        }
        .equipment-panel.visible { transform: translateY(0); }

        .panel-title {
            color: #fb0;
            font-family: Georgia, serif;
            border-bottom: 1px solid #445;
            margin-bottom: 6px;
            padding-bottom: 4px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-title .close-panel {
            cursor: pointer;
            color: #666;
            font-size: 14px;
            line-height: 1;
        }
        .panel-title .close-panel:hover { color: #f44; }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 32px;
            min-height: 32px;
            border-radius: 3px;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 1px; right: 2px;
            font-size: 9px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        /* v5.1: Equipment Slots - Compact */
        .equip-slot {
            background: #1a1a2a;
            border: 1px solid #334;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .equip-slot:hover { border-color: #fb0; background: #2a2a3a; }
        .equip-slot.equipped { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .equip-icon { font-size: 16px; margin-bottom: 2px; }
        .equip-name { font-size: 8px; color: #aaa; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60px; }
        .equip-slot.equipped .equip-name { color: #4f4; }

        .xp-bar-container {
            margin-bottom: 4px;
        }
        .xp-label { font-size: 9px; color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 4px; background: #222; border-radius: 2px; overflow: hidden; margin-top: 2px; }
        .xp-bar-fill { height: 100%; width: 0%; transition: width 0.3s; }

        .craft-btn {
            display: block;
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px 6px;
            margin-bottom: 3px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 9px;
            transition: all 0.2s;
        }

        .craft-btn:hover:not(:disabled) { background: #555; border-color: #fb0; }
        .craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Action Buttons */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: Georgia, serif;
            pointer-events: auto;
            font-size: clamp(11px, 2vw, 14px);
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: clamp(12px, 2vw, 16px);
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: clamp(10px, 1.5vw, 12px);
            pointer-events: none;
            display: none;
            z-index: 100;
            border-radius: 4px;
            max-width: 200px;
        }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
            font-family: Georgia, serif;
        }

        .loading-text {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }

        .loading-bar {
            width: clamp(200px, 50vw, 300px);
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #0f0;
            animation: loadPulse 1s ease-in-out infinite;
        }

        @keyframes loadPulse {
            0%, 100% { width: 20%; margin-left: 0; }
            50% { width: 40%; margin-left: 60%; }
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 200px;
            right: 10px;
            width: clamp(80px, 15vw, 120px);
            height: clamp(80px, 15vw, 120px);
            background: rgba(0,0,0,0.7);
            border: 2px solid #445;
            border-radius: 8px;
            display: none;
            pointer-events: auto;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* v4.8: Combat Abilities (v4.9: Enhanced styling) */
        @keyframes ability-ready-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); }
        }
        @keyframes berserk-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.9); }
        }
        .ability-slot {
            width: 50px;
            height: 50px;
            background: rgba(40, 40, 60, 0.9);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .ability-slot:hover:not(.locked):not(.on-cooldown) {
            border-color: #0ff;
            transform: scale(1.1);
        }
        .ability-slot.locked {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .ability-slot.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            font-size: 12px;
            top: 2px;
            right: 2px;
        }
        .ability-slot.on-cooldown {
            border-color: #444;
            opacity: 0.7;
        }
        .ability-slot:not(.locked):not(.on-cooldown) {
            animation: ability-ready-pulse 2s infinite;
            border-color: #0aa;
        }
        .ability-slot.active-buff {
            border-color: #ff8800;
            box-shadow: 0 0 10px #ff8800;
            animation: none;
        }
        .ability-slot.active-buff[id="ability-c"] {
            animation: berserk-pulse 0.5s infinite;
        }
        .ability-icon {
            font-size: 20px;
        }
        .ability-key {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
            border-radius: 0 0 6px 6px;
        }

        /* Touch Controls */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
            pointer-events: auto;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* v4.3: Virtual Joystick */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .touch-action-btn {
            position: fixed;
            bottom: 50px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: rgba(255, 100, 0, 0.4);
            border: 3px solid rgba(255, 150, 0, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-action-btn:active {
            background: rgba(255, 150, 0, 0.7);
        }

        /* v4.5: Mobile Dodge Button */
        .touch-dodge-btn {
            position: fixed;
            bottom: 140px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(100, 200, 255, 0.4);
            border: 3px solid rgba(150, 220, 255, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-dodge-btn:active {
            background: rgba(150, 220, 255, 0.7);
        }

        /* Notification Toast */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px 20px;
            border-radius: 4px;
            color: #0f0;
            font-size: 14px;
            z-index: 500;
            animation: notifySlide 3s forwards;
            pointer-events: none;
        }

        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(50, 40, 80, 0.95));
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 600;
            animation: achievementSlide 4s forwards;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .achievement-popup .ach-icon { font-size: 36px; }
        .achievement-popup .ach-title { color: #ffd700; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; }
        .achievement-popup .ach-name { color: #fff; font-size: 16px; font-weight: bold; margin: 3px 0; }
        .achievement-popup .ach-desc { color: #aaa; font-size: 12px; }

        @keyframes achievementSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }

        /* Daily Challenge Box */
        .daily-challenge-box {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 12px 15px;
            width: 180px;
            z-index: 100;
        }

        .daily-challenge-box.completed {
            border-color: #44ff44;
            background: rgba(20, 40, 20, 0.9);
        }

        .daily-title { color: #ffd700; font-size: 11px; text-transform: uppercase; margin-bottom: 8px; }
        .daily-desc { color: #fff; font-size: 12px; margin-bottom: 8px; }
        .daily-progress-bar { background: #333; border-radius: 4px; height: 8px; overflow: hidden; }
        .daily-progress-fill { background: linear-gradient(90deg, #ffd700, #ffaa00); height: 100%; transition: width 0.3s; }
        .daily-progress-text { color: #aaa; font-size: 10px; margin-top: 5px; }
        .daily-streak { color: #ff8800; font-size: 10px; margin-top: 3px; }

        /* Stats Modal */
        .stats-section { margin-bottom: 20px; }
        .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 13px; }
        .stat-row span:last-child { color: #0ff; font-weight: bold; }

        .achievements-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .ach-item {
            display: flex; align-items: center; gap: 6px;
            background: rgba(40,40,60,0.8);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
        }
        .ach-item.unlocked { color: #fff; background: rgba(50, 50, 80, 0.9); border: 1px solid #ffd700; }
        .ach-item.locked .ach-badge { filter: grayscale(1); opacity: 0.4; }
        .ach-badge { font-size: 16px; }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }

        .modal-content {
            background: #1a1a2e;
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
        }

        .modal-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 20px;
            font-family: Georgia, serif;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* v4.9: Collection Codex Styles */
        .codex-tab {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #444;
            color: #aaa;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .codex-tab:hover { border-color: #0ff; color: #fff; }
        .codex-tab.active {
            background: linear-gradient(135deg, #0aa, #088);
            border-color: #0ff;
            color: #fff;
        }
        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .codex-entry {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .codex-entry:hover { border-color: #0ff; transform: translateY(-2px); }
        .codex-entry.discovered { border-color: #4a4; }
        .codex-entry.undiscovered {
            filter: grayscale(1);
            opacity: 0.5;
        }
        .codex-entry .entry-icon {
            font-size: 28px;
            margin-bottom: 5px;
            display: block;
        }
        .codex-entry .entry-name {
            font-size: 11px;
            color: #ccc;
            display: block;
        }
        .codex-entry.undiscovered .entry-name { color: #666; }
        .codex-entry .entry-count {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        /* v5.0: Quest System Styles */
        .quest-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quest-item {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
        }
        .quest-item:hover { border-color: #ff8c00; }
        .quest-item.completed {
            border-color: #4a4;
            background: rgba(40, 80, 40, 0.3);
        }
        .quest-item.claimed {
            opacity: 0.5;
            border-color: #333;
        }
        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .quest-title {
            font-size: 14px;
            color: #fff;
            font-weight: bold;
        }
        .quest-reward {
            font-size: 12px;
            color: #ffd700;
        }
        .quest-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        .quest-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8c00, #ffd700);
            transition: width 0.3s;
        }
        .quest-progress-text {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            text-align: right;
        }
        .quest-claim-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #4a4, #2a2);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        .quest-claim-btn:hover { background: linear-gradient(135deg, #5b5, #3b3); }
        .quest-claim-btn:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* v4.6: Settings Panel Styles */
        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-section:last-child { border-bottom: none; }
        .settings-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }
        .setting-row input[type="range"] {
            width: 100px;
            margin: 0 10px;
            accent-color: #0ff;
        }
        .setting-row select {
            background: #222;
            border: 1px solid #445;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .toggle-btn {
            background: rgba(0,100,0,0.5);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            min-width: 50px;
        }
        .toggle-btn.off {
            background: rgba(100,0,0,0.5);
            border-color: #f44;
            color: #f44;
        }

        /* v5.3: Mastery System Styles */
        .mastery-card {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .mastery-card:hover { border-color: #ffd700; }
        .mastery-card.mastered { border-color: #ffd700; background: rgba(50, 45, 30, 0.9); }
        .mastery-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .mastery-skill { font-size: 16px; font-weight: bold; }
        .mastery-level { color: #ffd700; font-size: 14px; }
        .mastery-progress-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
        .mastery-progress-fill { height: 100%; background: linear-gradient(90deg, #8844ff, #ff44ff); transition: width 0.3s; }
        .mastery-milestones { display: flex; gap: 8px; flex-wrap: wrap; }
        .milestone { padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(0,0,0,0.3); border: 1px solid #333; }
        .milestone.achieved { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; color: #ffd700; }
        .milestone.next { background: rgba(136, 68, 255, 0.2); border-color: #8844ff; color: #aaf; }

        /* v5.3: Realm Portal Styles */
        .portal-card {
            background: linear-gradient(135deg, rgba(40, 20, 60, 0.95), rgba(20, 40, 60, 0.95));
            border: 2px solid #8844ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .portal-card:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(136, 68, 255, 0.4); }
        .portal-card.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.5); }
        .portal-card.active { border-color: #ff4400; animation: portal-pulse 1.5s infinite; }
        @keyframes portal-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.6); }
        }
        .portal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .portal-name { font-size: 18px; font-weight: bold; color: #fff; }
        .portal-tier { padding: 4px 10px; border-radius: 12px; font-size: 11px; background: linear-gradient(135deg, #8844ff, #4488ff); }
        .portal-desc { color: #aaa; font-size: 12px; margin-bottom: 10px; }
        .portal-rewards { display: flex; gap: 10px; flex-wrap: wrap; }
        .portal-reward { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .portal-requirement { color: #888; font-size: 11px; margin-top: 8px; }

        /* v5.3: Loot Rarity Styles */
        .rarity-common { color: #aaaaaa; }
        .rarity-uncommon { color: #44ff44; }
        .rarity-rare { color: #4488ff; }
        .rarity-epic { color: #aa44ff; }
        .rarity-legendary { color: #ff8800; text-shadow: 0 0 5px rgba(255, 136, 0, 0.5); }
        .rarity-mythic { color: #ff4488; text-shadow: 0 0 8px rgba(255, 68, 136, 0.6); animation: mythic-glow 2s infinite; }
        @keyframes mythic-glow {
            0%, 100% { text-shadow: 0 0 5px rgba(255, 68, 136, 0.4); }
            50% { text-shadow: 0 0 15px rgba(255, 68, 136, 0.8); }
        }
        .item-modifiers { font-size: 10px; color: #88ff88; margin-top: 4px; }
        .loot-drop-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            min-width: 250px;
            text-align: center;
            animation: loot-appear 0.3s ease-out;
        }
        @keyframes loot-appear {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* v5.4: Companion Evolution Styles */
        .evolution-card {
            background: linear-gradient(135deg, rgba(40, 30, 60, 0.95), rgba(60, 40, 80, 0.95));
            border: 2px solid #aa44ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        .evolution-card:hover { box-shadow: 0 0 20px rgba(170, 68, 255, 0.4); }
        .evolution-card.can-evolve { border-color: #ffd700; animation: evolve-pulse 1.5s infinite; }
        @keyframes evolve-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); }
        }
        .evolution-header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
        .evolution-icon { font-size: 40px; }
        .evolution-info { flex: 1; }
        .evolution-name { font-size: 16px; font-weight: bold; color: #fff; }
        .evolution-stage { font-size: 12px; color: #aa88ff; }
        .evolution-bond { margin: 10px 0; }
        .bond-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .bond-fill { height: 100%; background: linear-gradient(90deg, #ff44aa, #aa44ff); transition: width 0.3s; }
        .evolution-abilities { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
        .evolution-ability { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .evolution-ability.locked { opacity: 0.4; }
        .evolve-btn {
            display: block; width: 100%; margin-top: 10px; padding: 10px;
            background: linear-gradient(135deg, #ffd700, #ff8800);
            border: none; border-radius: 6px; color: #000; font-weight: bold;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .evolve-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .evolve-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

        /* v5.4: World Events Styles */
        .event-notification {
            position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.95), rgba(200, 50, 0, 0.95));
            border: 2px solid #ffd700; border-radius: 12px; padding: 15px 25px;
            z-index: 1500; text-align: center; animation: event-slide 0.5s ease-out;
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.5);
        }
        @keyframes event-slide {
            0% { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .event-title { font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 5px; }
        .event-desc { font-size: 12px; color: #ffd700; }
        .event-timer { font-size: 14px; color: #fff; margin-top: 8px; }
        .world-event-marker {
            position: absolute; pointer-events: none;
            animation: event-marker-pulse 1s infinite;
        }
        @keyframes event-marker-pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        .event-indicator {
            position: fixed; top: 130px; right: 10px;
            background: rgba(0,0,0,0.8); border: 2px solid #ff8800;
            border-radius: 8px; padding: 10px; z-index: 100;
            display: none; min-width: 150px;
        }
        .event-indicator.active { display: block; animation: event-pulse 2s infinite; }
        @keyframes event-pulse {
            0%, 100% { border-color: #ff8800; }
            50% { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 136, 0, 0.5); }
        }
        .event-indicator-icon { font-size: 24px; text-align: center; margin-bottom: 5px; }
        .event-indicator-name { font-size: 12px; color: #ffd700; text-align: center; }
        .event-indicator-time { font-size: 11px; color: #fff; text-align: center; margin-top: 4px; }
        .event-indicator-progress { height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 6px; overflow: hidden; }
        .event-indicator-fill { height: 100%; background: #ff8800; transition: width 0.5s; }

        /* v5.4: Achievement Showcase Styles */
        .showcase-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 15px; }
        .showcase-badge {
            background: rgba(30, 30, 50, 0.9); border: 2px solid #333;
            border-radius: 8px; padding: 10px; text-align: center;
            cursor: pointer; transition: all 0.2s;
        }
        .showcase-badge:hover { border-color: #ffd700; transform: translateY(-2px); }
        .showcase-badge.earned { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .showcase-badge.rare { border-color: #4488ff; background: rgba(68, 136, 255, 0.15); }
        .showcase-badge.legendary { border-color: #ff8800; background: rgba(255, 136, 0, 0.15); animation: legendary-badge 2s infinite; }
        @keyframes legendary-badge {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 136, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 136, 0, 0.6); }
        }
        .showcase-badge-icon { font-size: 28px; margin-bottom: 5px; }
        .showcase-badge-name { font-size: 10px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .showcase-badge.earned .showcase-badge-name { color: #4f4; }
        .achievement-points-display {
            text-align: center; padding: 15px; margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 136, 0, 0.1));
            border: 1px solid #ffd700; border-radius: 8px;
        }
        .ap-value { font-size: 32px; font-weight: bold; color: #ffd700; }
        .ap-label { font-size: 12px; color: #aaa; }
        .ap-milestone { margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; }
        .ap-milestone-progress { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-top: 5px; }
        .ap-milestone-fill { height: 100%; background: linear-gradient(90deg, #ffd700, #ff8800); }
        .cosmetic-effect { position: absolute; pointer-events: none; z-index: 5; }
        .cosmetic-aura { animation: aura-rotate 3s linear infinite; }
        @keyframes aura-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
            }

            .rpg-ui {
                flex-direction: column;
                align-items: center;
                max-height: 50vh;
                overflow-y: auto;
            }

            .inventory-panel, .player-stats, .crafting-panel {
                width: 95%;
                max-width: none;
            }

            .touch-controls {
                display: flex;
            }

            .data-controls {
                top: auto;
                bottom: 60px;
                right: 10px;
                left: 10px;
                justify-content: center;
            }

            .data-controls button {
                padding: 4px 8px;
                font-size: 9px;
            }

            .data-controls .menu-secondary {
                top: auto;
                bottom: 40px;
                right: 10px;
                left: auto;
                transform: none;
            }

            .minimap {
                bottom: auto;
                top: 70px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .inv-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .rpg-ui {
                padding: 5px;
            }

            .data-controls button {
                padding: 3px 6px;
                font-size: 8px;
            }
        }

        /* v5.10: RTS-Style Command Bar - Compact Bottom-Right Toolbar */
        .rts-command-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1002;
            pointer-events: auto;
        }

        /* v5.6: Copilot Companion System Styles - RTS Compact */
        .copilot-button {
            width: 44px;
            height: 44px;
            background: rgba(138, 43, 226, 0.4);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(138, 43, 226, 0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(138, 43, 226, 0.3);
        }

        .copilot-button:hover {
            background: rgba(138, 43, 226, 0.6);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.5);
        }

        .copilot-button.active {
            background: rgba(6, 255, 165, 0.5);
            border-color: rgba(6, 255, 165, 0.9);
            box-shadow: 0 2px 15px rgba(6, 255, 165, 0.4);
        }

        .copilot-button svg {
            width: 22px;
            height: 22px;
            color: white;
        }

        .copilot-chat-interface {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 320px;
            height: 380px;
            background: rgba(8, 12, 20, 0.96);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            pointer-events: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .copilot-chat-interface.active {
            display: flex;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-chat-header {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.1));
            border-radius: 14px 14px 0 0;
        }

        .copilot-chat-title {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .copilot-chat-title::before {
            content: 'ðŸŒŸ';
        }

        .copilot-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 0 5px;
        }

        .copilot-close-btn:hover {
            opacity: 1;
            color: #ff6a88;
            transform: rotate(90deg);
        }

        .copilot-chat-messages {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .copilot-message {
            margin: 8px 0;
            padding: 10px 12px;
            border-radius: 12px;
            max-width: 90%;
            word-wrap: break-word;
            font-size: 13px;
            line-height: 1.5;
            animation: message-slide 0.3s ease;
        }

        @keyframes message-slide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-message.user {
            background: rgba(138, 43, 226, 0.3);
            margin-left: auto;
            text-align: right;
            border: 1px solid rgba(138, 43, 226, 0.4);
        }

        .copilot-message.ai {
            background: rgba(6, 255, 165, 0.15);
            margin-right: auto;
            border: 1px solid rgba(6, 255, 165, 0.3);
            text-align: left;
        }

        /* v5.9: Markdown formatting in chat messages */
        .copilot-message.ai a {
            color: #06ffa5;
            text-decoration: underline;
            cursor: pointer;
            word-break: break-word;
        }

        .copilot-message.ai a:hover {
            color: #4fffbc;
            text-decoration: none;
        }

        .copilot-message.ai strong, .copilot-message.ai b {
            color: #fff;
            font-weight: 600;
        }

        .copilot-message.ai em, .copilot-message.ai i {
            font-style: italic;
            color: #ccc;
        }

        .copilot-message.ai code {
            background: rgba(0, 0, 0, 0.4);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: #ff9500;
        }

        .copilot-message.ai pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 6px 0;
            font-size: 11px;
        }

        .copilot-message.ai pre code {
            background: none;
            padding: 0;
        }

        .copilot-message.ai ul, .copilot-message.ai ol {
            margin: 6px 0;
            padding-left: 18px;
        }

        .copilot-message.ai li {
            margin: 3px 0;
        }

        .copilot-message.ai h1, .copilot-message.ai h2, .copilot-message.ai h3 {
            margin: 8px 0 4px 0;
            color: #06ffa5;
            font-size: 14px;
        }

        .copilot-message.ai h1 { font-size: 15px; }
        .copilot-message.ai h2 { font-size: 14px; }
        .copilot-message.ai h3 { font-size: 13px; }

        .copilot-message.ai hr {
            border: none;
            border-top: 1px solid rgba(6, 255, 165, 0.3);
            margin: 8px 0;
        }

        .copilot-message.ai blockquote {
            border-left: 3px solid #06ffa5;
            padding-left: 10px;
            margin: 6px 0;
            color: #aaa;
            font-style: italic;
        }

        .copilot-message.ai p {
            margin: 4px 0;
        }

        .copilot-message.ai p:first-child {
            margin-top: 0;
        }

        .copilot-message.ai p:last-child {
            margin-bottom: 0;
        }

        .copilot-typing {
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(6, 255, 165, 0.15);
            display: flex;
            align-items: center;
            gap: 5px;
            width: fit-content;
            margin: 10px 0;
        }

        .copilot-typing-dot {
            width: 7px;
            height: 7px;
            background: rgba(6, 255, 165, 0.7);
            border-radius: 50%;
            animation: typing-pulse 1.4s infinite ease-in-out;
        }

        .copilot-typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .copilot-typing-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing-pulse {
            0%, 80%, 100% { transform: scale(0.7); opacity: 0.4; }
            40% { transform: scale(1); opacity: 1; }
        }

        .copilot-chat-input-container {
            padding: 12px;
            border-top: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .copilot-chat-input {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 20px;
            color: white;
            font-size: 13px;
            outline: none;
            transition: all 0.2s;
        }

        .copilot-chat-input:focus {
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }

        .copilot-chat-send {
            background: linear-gradient(135deg, #8a2be2, #06ffa5);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s;
        }

        .copilot-chat-send:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(6, 255, 165, 0.4);
        }

        /* v5.9: Hotkey hint */
        .copilot-hotkey-hint {
            font-size: 10px;
            color: #666;
            text-align: center;
            padding: 6px 12px 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .copilot-hotkey-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 10px;
            color: #06ffa5;
        }

        /* v5.9: Copilot Task System UI - RTS Compact Style */
        .copilot-task-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(138, 43, 226, 0.6);
            border-radius: 8px;
            padding: 10px 14px;
            min-width: 180px;
            max-width: 220px;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.4);
        }

        .copilot-task-panel.active {
            display: block;
            animation: task-slide-in 0.2s ease;
        }

        @keyframes task-slide-in {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .copilot-task-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .copilot-task-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #06ffa5;
            font-weight: 600;
        }

        .copilot-task-title .task-icon {
            font-size: 18px;
        }

        .copilot-task-recall {
            background: rgba(255, 68, 68, 0.3);
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-task-recall:hover {
            background: rgba(255, 68, 68, 0.5);
            color: #fff;
        }

        .copilot-task-status {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .copilot-task-progress {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .copilot-task-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #06ffa5);
            border-radius: 3px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.5);
        }

        .copilot-task-progress-bar.hunting {
            background: linear-gradient(90deg, #ff4444, #ff8800);
        }

        .copilot-task-progress-bar.scouting {
            background: linear-gradient(90deg, #4488ff, #44ffff);
        }

        .copilot-task-progress-bar.protecting {
            background: linear-gradient(90deg, #ffcc00, #ff8800);
            animation: protect-pulse 1.5s infinite;
        }

        @keyframes protect-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .copilot-task-results {
            font-size: 11px;
            color: #888;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
            margin-top: 4px;
        }

        .copilot-task-results .result-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 3px 0;
        }

        .copilot-task-results .result-item.positive {
            color: #06ffa5;
        }

        /* Task indicator on copilot button */
        .copilot-button.has-task::after {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            background: #06ffa5;
            border-radius: 50%;
            animation: task-indicator-pulse 1s infinite;
        }

        @keyframes task-indicator-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* Copilot visual state when on task */
        .copilot-on-task {
            filter: hue-rotate(60deg);
        }

        /* v5.10: Multi-Agent Fleet System - RTS Style */
        .agent-fleet-panel {
            position: fixed;
            top: 60px;
            right: 0;
            background: rgba(5, 8, 15, 0.95);
            border-left: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 0;
            width: 280px;
            max-height: calc(100vh - 120px);
            z-index: 1001;
            display: none;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .agent-fleet-panel.active {
            display: flex;
            flex-direction: column;
            animation: fleet-slide-in 0.25s ease;
        }

        @keyframes fleet-slide-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }

        .agent-fleet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.05));
            border-bottom: 1px solid rgba(138, 43, 226, 0.4);
        }

        .agent-fleet-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
        }

        .agent-fleet-title span.icon {
            font-size: 16px;
        }

        .agent-fleet-count {
            font-size: 10px;
            color: #06ffa5;
            background: rgba(6, 255, 165, 0.12);
            padding: 2px 6px;
            border-radius: 8px;
        }

        .agent-fleet-close {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 2px;
        }

        .agent-fleet-close:hover {
            color: #ff4444;
        }

        .agent-fleet-spawn {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .agent-spawn-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .agent-spawn-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 2px;
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .agent-spawn-btn:hover:not(:disabled) {
            background: rgba(138, 43, 226, 0.35);
            border-color: #06ffa5;
        }

        .agent-spawn-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .agent-spawn-btn .icon {
            font-size: 18px;
        }

        .agent-spawn-btn .label {
            font-size: 8px;
            color: #888;
            text-align: center;
        }

        .agent-fleet-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
        }

        .agent-card {
            background: rgba(15, 18, 25, 0.9);
            border: 1px solid rgba(138, 43, 226, 0.25);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .agent-card:hover {
            border-color: rgba(6, 255, 165, 0.5);
        }

        .agent-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .agent-identity {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .agent-avatar {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
        }

        .agent-info {
            display: flex;
            flex-direction: column;
        }

        .agent-name {
            font-size: 11px;
            font-weight: 600;
            color: #fff;
        }

        .agent-role {
            font-size: 9px;
            color: #666;
        }

        .agent-actions {
            display: flex;
            gap: 4px;
        }

        .agent-action-btn {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
            color: #666;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .agent-action-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #aaa;
        }

        .agent-action-btn.recall {
            border-color: rgba(255, 68, 68, 0.3);
        }

        .agent-action-btn.recall:hover {
            background: rgba(255, 68, 68, 0.25);
            border-color: #ff4444;
            color: #ff4444;
        }

        .agent-card-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 10px;
            color: #888;
        }

        .agent-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #06ffa5;
            animation: pulse 1.5s infinite;
        }

        .agent-status-dot.thinking {
            background: #ffaa00;
        }

        .agent-status-dot.idle {
            background: #666;
            animation: none;
        }

        .agent-card-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .agent-progress-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .agent-last-msg {
            font-size: 11px;
            color: #666;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-results-mini {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .agent-result-tag {
            font-size: 10px;
            background: rgba(6, 255, 165, 0.15);
            color: #06ffa5;
            padding: 2px 6px;
            border-radius: 8px;
        }

        /* Fleet button - RTS Compact Style */
        .fleet-button {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(68, 170, 255, 0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            box-shadow: 0 2px 10px rgba(68, 170, 255, 0.2);
            position: relative;
        }

        .fleet-button:hover {
            transform: scale(1.05);
            border-color: #06ffa5;
            background: rgba(30, 45, 70, 0.9);
        }

        .fleet-button.has-agents {
            border-color: #06ffa5;
            box-shadow: 0 2px 15px rgba(6, 255, 165, 0.3);
        }

        .fleet-button.has-agents::after {
            content: attr(data-count);
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 16px;
            height: 16px;
            background: #06ffa5;
            color: #000;
            font-size: 10px;
            font-weight: 700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Agent colors */
        .agent-color-gatherer { color: #44ff88; }
        .agent-color-hunter { color: #ff4444; }
        .agent-color-scout { color: #44aaff; }
        .agent-color-protector { color: #ffcc00; }
        .agent-color-healer { color: #ff88ff; }
        .agent-color-fisher { color: #44ffff; }
        .agent-color-miner { color: #ffaa44; }
        .agent-color-explorer { color: #aa88ff; }

        /* Agent transcript export */
        .agent-action-btn.export {
            border-color: rgba(68, 170, 255, 0.4);
        }

        .agent-action-btn.export:hover {
            background: rgba(68, 170, 255, 0.3);
            border-color: #44aaff;
            color: #44aaff;
        }

        .fleet-export-btn {
            background: rgba(68, 170, 255, 0.2);
            border: 1px solid rgba(68, 170, 255, 0.4);
            color: #44aaff;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 8px;
        }

        .fleet-export-btn:hover {
            background: rgba(68, 170, 255, 0.4);
            color: #fff;
        }

        .fleet-import-btn {
            background: rgba(106, 255, 165, 0.2);
            border: 1px solid rgba(106, 255, 165, 0.4);
            color: #06ffa5;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .fleet-import-btn:hover {
            background: rgba(106, 255, 165, 0.4);
            color: #fff;
        }

        /* Transcript viewer modal - RTS Style */
        .transcript-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .transcript-modal.active {
            display: flex;
            animation: fade-in 0.15s ease;
        }

        .transcript-modal-content {
            background: rgba(10, 12, 20, 0.98);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6);
        }

        .transcript-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(68, 170, 255, 0.1));
            border-bottom: 1px solid rgba(138, 43, 226, 0.5);
        }

        .transcript-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .transcript-modal-actions {
            display: flex;
            gap: 8px;
        }

        .transcript-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .transcript-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .transcript-action-btn.primary {
            background: rgba(68, 170, 255, 0.3);
            border-color: #44aaff;
            color: #44aaff;
        }

        .transcript-action-btn.primary:hover {
            background: rgba(68, 170, 255, 0.5);
            color: #fff;
        }

        .transcript-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-json {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.5;
            background: #0d0d1a;
            border-radius: 8px;
            padding: 16px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 60vh;
            overflow-y: auto;
        }

        .transcript-json .key { color: #ff88ff; }
        .transcript-json .string { color: #06ffa5; }
        .transcript-json .number { color: #44aaff; }
        .transcript-json .boolean { color: #ffcc00; }
        .transcript-json .null { color: #888; }

        .transcript-tabs {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
        }

        .transcript-tab {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #888;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .transcript-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
        }

        .transcript-tab.active {
            background: rgba(138, 43, 226, 0.3);
            border-color: #8a2be2;
            color: #fff;
        }

        .transcript-agent-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .transcript-info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .transcript-info-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
        }

        .transcript-info-value {
            font-size: 13px;
            color: #fff;
        }

        .copilot-quick-actions {
            display: flex;
            gap: 6px;
            padding: 0 12px 10px;
            flex-wrap: wrap;
        }

        .copilot-quick-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 14px;
            padding: 5px 10px;
            font-size: 11px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-quick-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: rgba(138, 43, 226, 0.5);
            color: #fff;
        }

        .copilot-voice-btn {
            background: linear-gradient(135deg, #ff006e, #ff4488);
            border: none;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .copilot-voice-btn:hover {
            transform: scale(1.1);
        }

        .copilot-voice-btn.recording {
            background: linear-gradient(135deg, #ff0000, #ff4444);
            animation: voice-record-pulse 1.5s infinite;
        }

        @keyframes voice-record-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.6); }
            70% { box-shadow: 0 0 0 12px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .copilot-voice-btn svg {
            width: 18px;
            height: 18px;
            color: white;
        }

        /* v5.9: Real-time transcription overlay */
        .stt-transcription-overlay {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff006e;
            border-radius: 16px;
            padding: 16px 24px;
            min-width: 300px;
            max-width: 500px;
            z-index: 10001;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(255, 0, 110, 0.3);
        }

        .stt-transcription-overlay.active {
            display: flex;
        }

        .stt-header {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ff006e;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stt-header .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            animation: stt-pulse 1s infinite;
        }

        @keyframes stt-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .stt-waveform {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 30px;
        }

        .stt-waveform .bar {
            width: 4px;
            background: linear-gradient(to top, #ff006e, #ff4488);
            border-radius: 2px;
            animation: stt-wave 0.5s ease-in-out infinite;
        }

        .stt-waveform .bar:nth-child(1) { animation-delay: 0s; }
        .stt-waveform .bar:nth-child(2) { animation-delay: 0.1s; }
        .stt-waveform .bar:nth-child(3) { animation-delay: 0.2s; }
        .stt-waveform .bar:nth-child(4) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(5) { animation-delay: 0.4s; }
        .stt-waveform .bar:nth-child(6) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(7) { animation-delay: 0.2s; }

        @keyframes stt-wave {
            0%, 100% { height: 8px; }
            50% { height: 25px; }
        }

        .stt-transcript-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.5;
            min-height: 24px;
            text-align: center;
        }

        .stt-transcript-text.interim {
            color: #aaa;
            font-style: italic;
        }

        .stt-transcript-text.final {
            color: #06ffa5;
        }

        .stt-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .stt-actions button {
            padding: 8px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .stt-actions .stt-send {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }

        .stt-actions .stt-send:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.4);
        }

        .stt-actions .stt-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stt-actions .stt-cancel:hover {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff4444;
        }

        .stt-actions .stt-retry {
            background: rgba(255, 0, 110, 0.3);
            color: #ff006e;
            border: 1px solid #ff006e;
        }

        .stt-actions .stt-retry:hover {
            background: rgba(255, 0, 110, 0.5);
        }

        /* v5.9: Auto-send toggle */
        .stt-auto-send {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 4px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stt-auto-send label {
            font-size: 12px;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stt-auto-send input[type="checkbox"] {
            display: none;
        }

        .stt-toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
        }

        .stt-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .stt-auto-send input[type="checkbox"]:checked + .stt-toggle {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }

        .stt-auto-send input[type="checkbox"]:checked + .stt-toggle::after {
            left: 18px;
        }

        .stt-auto-send .auto-label {
            color: #aaa;
            transition: color 0.3s;
        }

        .stt-auto-send input[type="checkbox"]:checked ~ .auto-label {
            color: #06ffa5;
        }

        /* Copilot Companion 3D Indicator */
        .copilot-3d-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: #06ffa5;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            z-index: 1010;
            border: 1px solid rgba(6, 255, 165, 0.4);
        }

        .copilot-3d-tooltip.visible {
            opacity: 1;
        }

        /* Voice Status Indicator */
        .copilot-voice-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1004;
            font-size: 12px;
            animation: fade-in 0.3s ease;
        }

        .copilot-voice-indicator.active {
            display: flex;
        }

        .copilot-voice-indicator svg {
            width: 16px;
            height: 16px;
            animation: voice-wave 1s infinite;
        }

        @keyframes voice-wave {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .copilot-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                height: 350px;
                bottom: 170px;
            }

            .copilot-button {
                width: 55px;
                height: 55px;
                bottom: 95px;
            }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        <div class="loading-text">INITIALIZING OMNIVERSE ENGINE...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>

    <div id="container"></div>

    <div class="ui-layer">
        <!-- Data Controls - Two rows for better organization -->
        <div class="data-controls">
            <!-- Row 1: Game Features -->
            <button onclick="showStatsPanel()">Stats</button>
            <button onclick="openCodexModal()" style="background: linear-gradient(135deg, #ffd700, #ff8c00);">Codex</button>
            <button onclick="openQuestModal()" style="background: linear-gradient(135deg, #ff8c00, #ff4400);">Quests</button>
            <button onclick="openMasteryModal()" style="background: linear-gradient(135deg, #ff44ff, #8844ff);">Mastery</button>
            <button onclick="openPortalModal()" style="background: linear-gradient(135deg, #8844ff, #4488ff);">Portals</button>
            <button onclick="openEvolutionModal()" style="background: linear-gradient(135deg, #aa44ff, #ff44aa);">Evolve</button>
            <button onclick="showSettingsModal()">Settings</button>
            <!-- RAPPID prominently visible -->
            <button onclick="openRappidModal()" style="background: linear-gradient(135deg, #7b2cbf, #3a0ca3); border-color: #7b2cbf; color: #fff;">RAPPID</button>
            <!-- More menu for less used features -->
            <button class="menu-toggle" onclick="toggleSecondaryMenu()" style="background: rgba(255,255,255,0.1); border-color: #fff; color: #fff;">More â–¾</button>
            <!-- Secondary dropdown menu -->
            <div class="menu-secondary" id="menu-secondary">
                <button onclick="openShowcaseModal()" style="background: linear-gradient(135deg, #ffd700, #ffaa00);">Showcase</button>
                <button onclick="quickSave()">Save</button>
                <button onclick="exportData()">Export Game</button>
                <button onclick="document.getElementById('importFile').click()">Import Game</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            <input type="file" id="rappidImportFile" accept=".json" style="display: none;" onchange="importRappidSettings(event)">
        </div>

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">GALAXY SIMULATION v5.9</div>
            </div>

            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="total-playtime">0:00</span>
                    <span class="stat-lbl">Playtime</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <div class="stat-entry">
                    <span class="stat-val" id="world-name">Terra</span>
                    <span class="stat-lbl">Planet</span>
                </div>
                <button class="action-btn" onclick="returnToGalaxy()">LEAVE PLANET</button>
                <!-- v5.5: Autopilot Toggle -->
                <button id="auto-explore-btn" class="action-btn" onclick="toggleAutoExplore()" style="background: #00ff88; color: #000; margin-top: 5px;">Take Manual Control</button>
                <div id="auto-explore-indicator" style="text-align: center; margin-top: 5px; font-size: 12px; color: #00ff88;">ðŸ¤– AUTOPILOT</div>
            </div>
        </div>

        <!-- Player Health Bar -->
        <div id="player-health-bar" class="player-health-bar">
            <div class="player-health-text"><span id="health-text">100 / 100</span></div>
            <div id="player-health-fill" class="player-health-fill"></div>
        </div>

        <!-- v5.13: Ship Status Panel -->
        <div id="ship-status" style="display: none; position: fixed; top: 80px; left: 10px; z-index: 100;
            background: rgba(10, 20, 30, 0.9); padding: 12px; border-radius: 10px; border: 1px solid #0ff;
            min-width: 160px; backdrop-filter: blur(5px);">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <span style="font-size: 20px;">ðŸš€</span>
                <span style="color: #0ff; font-weight: bold; font-size: 14px;">SHIP STATUS</span>
            </div>
            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 3px;">
                    <span>Hull Integrity</span>
                    <span id="ship-hp-text">100/100</span>
                </div>
                <div style="height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;">
                    <div id="ship-hp-fill" style="width: 100%; height: 100%; background: #00ff88; transition: width 0.3s, background 0.3s;"></div>
                </div>
            </div>
            <div style="display: flex; gap: 5px;">
                <button id="ship-defense-btn" onclick="toggleShipAutoDefend()" style="flex: 1; padding: 6px 8px; background: rgba(0, 255, 136, 0.2); border: 1px solid #00ff88; color: #00ff88; border-radius: 5px; cursor: pointer; font-size: 11px;">ðŸ›¡ï¸ Defense: ON</button>
                <button onclick="repairShip()" style="padding: 6px 8px; background: rgba(255, 170, 0, 0.2); border: 1px solid #ffaa00; color: #ffaa00; border-radius: 5px; cursor: pointer; font-size: 11px;">ðŸ”§ Repair</button>
            </div>
            <div style="margin-top: 6px; font-size: 10px; color: #666; text-align: center;">
                Laser Range: 35m | DMG: 15
            </div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <!-- Minimap -->
        <div id="minimap" class="minimap">
            <canvas id="minimap-canvas" class="minimap-canvas"></canvas>
        </div>

        <!-- v5.0: Weather Indicator -->
        <div id="weather-indicator" style="position: fixed; bottom: 325px; right: 10px; display: none; z-index: 100;
            background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #445;
            font-size: 14px; min-width: 100px; text-align: center;">
            <div style="font-size: 24px; margin-bottom: 4px;" id="weather-icon">â˜€ï¸</div>
            <div id="weather-name" style="color: #aaa; font-size: 12px;">Clear</div>
            <div id="weather-effect" style="color: #666; font-size: 10px; margin-top: 4px;"></div>
        </div>

        <!-- v4.8: Combat Abilities Bar (v4.9: Extended with Tier 2) -->
        <div id="ability-bar" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 100;">
            <div style="display: flex; gap: 8px; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #333;">
                <!-- Tier 1 Abilities -->
                <div id="ability-q" class="ability-slot" onclick="useAbility('powerStrike')" title="Power Strike (Q) - 3x damage">
                    <span class="ability-icon">âš”ï¸</span>
                    <span class="ability-key">Q</span>
                    <div class="ability-cooldown" id="cooldown-q"></div>
                </div>
                <div id="ability-e" class="ability-slot" onclick="useAbility('whirlwind')" title="Whirlwind (E) - AoE damage">
                    <span class="ability-icon">ðŸŒ€</span>
                    <span class="ability-key">E</span>
                    <div class="ability-cooldown" id="cooldown-e"></div>
                </div>
                <div id="ability-r" class="ability-slot" onclick="useAbility('warcry')" title="War Cry (R) - +50% damage">
                    <span class="ability-icon">ðŸ“¢</span>
                    <span class="ability-key">R</span>
                    <div class="ability-cooldown" id="cooldown-r"></div>
                </div>
                <!-- v4.9: Tier 2 Abilities -->
                <div style="width: 1px; background: #444; margin: 0 4px;"></div>
                <div id="ability-t" class="ability-slot" onclick="useAbility('heal')" title="Battle Heal (T) - Restore 30% HP">
                    <span class="ability-icon">ðŸ’š</span>
                    <span class="ability-key">T</span>
                    <div class="ability-cooldown" id="cooldown-t"></div>
                </div>
                <div id="ability-f" class="ability-slot" onclick="useAbility('dash')" title="Combat Dash (F) - Dash forward">
                    <span class="ability-icon">ðŸ’¨</span>
                    <span class="ability-key">F</span>
                    <div class="ability-cooldown" id="cooldown-f"></div>
                </div>
                <div id="ability-z" class="ability-slot" onclick="useAbility('shieldWall')" title="Shield Wall (Z) - 70% damage reduction">
                    <span class="ability-icon">ðŸ›¡ï¸</span>
                    <span class="ability-key">Z</span>
                    <div class="ability-cooldown" id="cooldown-z"></div>
                </div>
                <div id="ability-x" class="ability-slot" onclick="useAbility('execute')" title="Execute (X) - 5x damage to low HP">
                    <span class="ability-icon">ðŸ’€</span>
                    <span class="ability-key">X</span>
                    <div class="ability-cooldown" id="cooldown-x"></div>
                </div>
                <div id="ability-c" class="ability-slot" onclick="useAbility('berserk')" title="Berserker Rage (C) - ULTIMATE">
                    <span class="ability-icon">ðŸ”¥</span>
                    <span class="ability-key">C</span>
                    <div class="ability-cooldown" id="cooldown-c"></div>
                </div>
            </div>
        </div>

        <!-- v5.11: RTS-Style Panel System -->
        <div id="rpg-ui" class="rpg-ui">
            <!-- RTS Toggle Buttons - Bottom Left -->
            <div class="rts-panel-toggles" id="rts-panel-toggles">
                <div class="rts-toggle-btn" id="toggle-skills" onclick="toggleRTSPanel('skills')" title="Skills (K)">ðŸ“Š</div>
                <div class="rts-toggle-btn" id="toggle-crafting" onclick="toggleRTSPanel('crafting')" title="Crafting (C)">ðŸ”¨</div>
                <div class="rts-toggle-btn" id="toggle-inventory" onclick="toggleRTSPanel('inventory')" title="Backpack (I)">ðŸŽ’</div>
                <div class="rts-toggle-btn" id="toggle-equipment" onclick="toggleRTSPanel('equipment')" title="Equipment (E)">âš”ï¸</div>
            </div>

            <!-- Skills Panel - Left Edge Dock -->
            <div id="skills-panel" class="player-stats">
                <div class="panel-title"><span>Skills</span><span class="close-panel" onclick="toggleRTSPanel('skills')">Ã—</span></div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Fishing</span> <span id="lvl-fishing">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-fishing" class="xp-bar-fill" style="background:#44f"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Cooking</span> <span id="lvl-cooking">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-cooking" class="xp-bar-fill" style="background:#f80"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Crafting</span> <span id="lvl-crafting">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-crafting" class="xp-bar-fill" style="background:#a0f"></div></div>
                </div>
                <button onclick="showTalentModal()" style="width: 100%; margin-top: 6px; padding: 5px; cursor: pointer;
                    background: linear-gradient(135deg, #664, #442); border: 1px solid #ffd700; border-radius: 3px; color: #ffd700; font-size: 9px;">
                    ðŸŒŸ Talents (<span id="talent-points-btn">0</span>)
                </button>
            </div>

            <!-- Crafting Panel - Left Edge Dock -->
            <div id="crafting-panel" class="crafting-panel">
                <div class="panel-title"><span>Crafting</span><span class="close-panel" onclick="toggleRTSPanel('crafting')">Ã—</span></div>
                <button class="craft-btn" id="craft-pickaxe" onclick="craft('pickaxe')">â›ï¸ Pickaxe</button>
                <button class="craft-btn" id="craft-sword" onclick="craft('sword')">âš”ï¸ Sword</button>
                <button class="craft-btn" id="craft-rod" onclick="craft('rod')">ðŸŽ£ Rod</button>
                <button class="craft-btn" id="craft-cookedFish" onclick="craft('cookedFish')">ðŸ³ Cook Fish</button>
                <button class="craft-btn" id="craft-potion" onclick="craft('potion')">ðŸ§ª Potion</button>
                <div style="border-top: 1px solid #333; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #888; font-size: 8px;">Advanced</small>
                </div>
                <button class="craft-btn" id="craft-chitinArmor" onclick="craft('chitinArmor')">Chitin Armor</button>
                <button class="craft-btn" id="craft-frostBlade" onclick="craft('frostBlade')">Frost Blade</button>
                <button class="craft-btn" id="craft-crystalPickaxe" onclick="craft('crystalPickaxe')">Crystal Pick</button>
                <button class="craft-btn" id="craft-magmaSword" onclick="craft('magmaSword')">Magma Sword</button>
                <button class="craft-btn" id="craft-superPotion" onclick="craft('superPotion')">Super Potion</button>
                <button class="craft-btn" id="craft-voidDagger" onclick="craft('voidDagger')">Void Dagger</button>
                <div style="border-top: 1px solid #664400; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #ffd700; font-size: 8px;">âš”ï¸ Legendary</small>
                </div>
                <button class="craft-btn" id="craft-guardianArmor" onclick="craft('guardianArmor')" style="border-color: #664400;">Guardian Armor</button>
                <button class="craft-btn" id="craft-legendaryBlade" onclick="craft('legendaryBlade')" style="border-color: #ffd700;">Legendary Blade</button>
                <div style="border-top: 1px solid #448844; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #88ff88; font-size: 8px;">ðŸ›¡ï¸ Equipment</small>
                </div>
                <button class="craft-btn" id="craft-ironArmor" onclick="craft('ironArmor')" style="border-color: #448844;">Iron Armor</button>
                <button class="craft-btn" id="craft-swiftBoots" onclick="craft('swiftBoots')" style="border-color: #448844;">Swift Boots</button>
                <button class="craft-btn" id="craft-luckyCharm" onclick="craft('luckyCharm')" style="border-color: #448844;">Lucky Charm</button>
                <button class="craft-btn" id="craft-powerRing" onclick="craft('powerRing')" style="border-color: #448844;">Power Ring</button>
                <button class="craft-btn" id="craft-steelArmor" onclick="craft('steelArmor')" style="border-color: #448844;">Steel Armor</button>
                <button class="craft-btn" id="craft-masterRod" onclick="craft('masterRod')" style="border-color: #448844;">Master Rod</button>
            </div>

            <!-- Inventory Panel - Bottom Center -->
            <div id="inventory-panel" class="inventory-panel">
                <div class="panel-title"><span>ðŸŽ’ (<span id="inv-count">0</span>/20)</span><span class="close-panel" onclick="toggleRTSPanel('inventory')">Ã—</span></div>
                <div class="inv-grid" id="inventory-grid"></div>
            </div>

            <!-- Equipment Panel - Bottom Right -->
            <div id="equipment-panel" class="equipment-panel">
                <div class="panel-title"><span>âš”ï¸ Gear</span><span class="close-panel" onclick="toggleRTSPanel('equipment')">Ã—</span></div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                    <div id="equip-slot-weapon" class="equip-slot" onclick="unequipItem('weapon')" title="Weapon">
                        <span class="equip-icon">âš”ï¸</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-armor" class="equip-slot" onclick="unequipItem('armor')" title="Armor">
                        <span class="equip-icon">ðŸ›¡ï¸</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-accessory" class="equip-slot" onclick="unequipItem('accessory')" title="Accessory">
                        <span class="equip-icon">ðŸ’</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-tool" class="equip-slot" onclick="unequipItem('tool')" title="Tool">
                        <span class="equip-icon">ðŸ”§</span>
                        <span class="equip-name">Empty</span>
                    </div>
                </div>
                <div id="equipment-stats" style="font-size: 9px; padding: 4px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                    <div style="color: #f44;">âš”ï¸ +0</div>
                    <div style="color: #4af;">ðŸ›¡ï¸ +0</div>
                </div>
                <button onclick="showEnchantModal()" style="width: 100%; margin-top: 4px; padding: 4px; cursor: pointer;
                    background: linear-gradient(135deg, #448, #226); border: 1px solid #66a; border-radius: 3px; color: #adf; font-size: 8px;">
                    âœ¨ Enchant
                </button>
            </div>
        </div>

        <!-- Touch Controls -->
        <div id="touch-controls" class="touch-controls">
            <div class="touch-btn" id="touch-action">A</div>
        </div>

        <!-- v4.3: Virtual Joystick for Mobile -->
        <div id="virtual-joystick" class="virtual-joystick">
            <div id="joystick-knob" class="joystick-knob"></div>
        </div>
        <div id="touch-action-btn" class="touch-action-btn">ACT</div>
        <div id="touch-dodge-btn" class="touch-dodge-btn">DODGE</div>

    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 50;
        background: radial-gradient(transparent 30%, rgba(255,0,0,0.6));
        opacity: 0; transition: opacity 0.1s;
    "></div>

    <!-- v4.9: Berserk Rage Overlay -->
    <div id="berserk-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 40%, rgba(255,68,0,0.25));
        border: 4px solid rgba(255,68,0,0.5);
        box-shadow: inset 0 0 50px rgba(255,68,0,0.3);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- v4.9: Shield Wall Overlay -->
    <div id="shield-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 50%, rgba(68,136,255,0.2));
        border: 4px solid rgba(68,136,255,0.6);
        box-shadow: inset 0 0 40px rgba(68,136,255,0.2);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Welcome to LEVIATHAN</div>
            <div style="color: #aaa; line-height: 1.8; margin-bottom: 20px;">
                <p style="margin-bottom: 15px;"><strong style="color: #0ff;">Galaxy Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Click on star systems to explore planets</li>
                    <li>Visited planets show a green ring</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #fb0;">Planet Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Click</strong> to move or interact with objects</li>
                    <li><strong>WASD</strong> keys for movement</li>
                    <li><strong>E</strong> to eat food and heal</li>
                    <li><strong>1-9</strong> to use inventory items</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #0f0;">Tips:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Gather logs and ore to craft tools</li>
                    <li>Tools increase resource yield</li>
                    <li>Green slimes are aggressive!</li>
                    <li>Fish for food, cook it to heal more</li>
                </ul>
            </div>
            <button class="action-btn" onclick="closeTutorial()" style="width: 100%;">START EXPLORING</button>
        </div>
    </div>

    <!-- v5.10: RTS-Style Command Bar (Bottom-Right) -->
    <div class="rts-command-bar">
        <!-- v5.6: Copilot Button -->
        <div id="copilot-button" class="copilot-button" onclick="toggleCopilotChat()" title="AI Companion (V)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
            </svg>
        </div>
        <!-- v5.10: Agent Fleet Button -->
        <div id="fleet-button" class="fleet-button" onclick="toggleAgentFleetPanel()" title="Agent Fleet">ðŸ¤–</div>
    </div>

    <!-- Copilot Voice Indicator -->
    <div id="copilot-voice-indicator" class="copilot-voice-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        </svg>
        <span>Speaking...</span>
    </div>

    <!-- v5.9: Real-time STT Transcription Overlay -->
    <div id="stt-transcription-overlay" class="stt-transcription-overlay">
        <div class="stt-header">
            <div class="recording-dot"></div>
            <span id="stt-status">Listening...</span>
        </div>
        <div class="stt-waveform" id="stt-waveform">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div id="stt-transcript-text" class="stt-transcript-text interim">Speak now...</div>
        <div class="stt-actions" id="stt-actions" style="display: none;">
            <button class="stt-cancel" onclick="cancelSTTMessage()">Cancel</button>
            <button class="stt-retry" onclick="retrySTT()">ðŸŽ¤ Retry</button>
            <button class="stt-send" onclick="sendSTTMessage()">Send âœ“</button>
        </div>
        <div class="stt-auto-send">
            <label>
                <input type="checkbox" id="stt-auto-send-toggle" onchange="toggleAutoSend(this.checked)">
                <span class="stt-toggle"></span>
                <span class="auto-label">Auto-send messages</span>
            </label>
        </div>
    </div>

    <!-- Copilot 3D Tooltip -->
    <div id="copilot-3d-tooltip" class="copilot-3d-tooltip">Click to chat</div>

    <!-- Copilot Chat Interface -->
    <div id="copilot-chat-interface" class="copilot-chat-interface">
        <div class="copilot-chat-header">
            <div class="copilot-chat-title">Copilot Companion</div>
            <button class="copilot-close-btn" onclick="toggleCopilotChat()">Ã—</button>
        </div>
        <div class="copilot-quick-actions">
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('What should I do next?')">What next?</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Give me a tip')">Tips</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Where are the enemies?')">Enemies</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('How do I get stronger?')">Get Stronger</button>
        </div>
        <div id="copilot-chat-messages" class="copilot-chat-messages">
            <div class="copilot-message ai">Hello, Explorer! I'm your Copilot Companion. I'll follow you on your journey and help with advice. What would you like to know?</div>
        </div>
        <div class="copilot-chat-input-container">
            <input type="text" id="copilot-chat-input" class="copilot-chat-input" placeholder="Ask your Copilot... (Press V for voice)" onkeypress="if(event.key==='Enter') sendCopilotMessage()">
            <button id="copilot-voice-btn" class="copilot-voice-btn" onclick="toggleCopilotVoice()" title="Voice input (Spacebar)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                </svg>
            </button>
            <button class="copilot-chat-send" onclick="sendCopilotMessage()">Send</button>
        </div>
        <div class="copilot-hotkey-hint">Press <kbd>V</kbd> to voice chat â€¢ <kbd>Space</kbd> while open to speak â€¢ <kbd>Esc</kbd> to close</div>
    </div>

    <!-- v5.9: Copilot Task Panel -->
    <div id="copilot-task-panel" class="copilot-task-panel">
        <div class="copilot-task-header">
            <div class="copilot-task-title">
                <span class="task-icon" id="task-icon">ðŸ”§</span>
                <span id="task-name">Working...</span>
            </div>
            <button class="copilot-task-recall" onclick="recallCopilot()">Recall</button>
        </div>
        <div class="copilot-task-status" id="task-status">Preparing...</div>
        <div class="copilot-task-progress">
            <div class="copilot-task-progress-bar" id="task-progress-bar" style="width: 0%"></div>
        </div>
        <div class="copilot-task-results" id="task-results" style="display: none;"></div>
    </div>

    <!-- v5.10: Agent Fleet Management Panel -->
    <div id="agent-fleet-panel" class="agent-fleet-panel">
        <div class="agent-fleet-header">
            <div class="agent-fleet-title">
                <span class="icon">ðŸš€</span>
                Agent Fleet
                <span class="agent-fleet-count" id="fleet-count">0/10</span>
            </div>
            <div style="display: flex; align-items: center;">
                <button class="fleet-export-btn" onclick="openTranscriptViewer()" title="View/Export Transcripts">ðŸ“‹ Transcripts</button>
                <button class="agent-fleet-close" onclick="toggleAgentFleetPanel()">Ã—</button>
            </div>
        </div>
        <div class="agent-fleet-spawn">
            <div class="agent-spawn-grid">
                <button class="agent-spawn-btn" onclick="spawnAgent('gatherer')" title="Gather resources">
                    <span class="icon">ðŸªµ</span>
                    <span class="label">Gatherer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('hunter')" title="Hunt enemies">
                    <span class="icon">âš”ï¸</span>
                    <span class="label">Hunter</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('scout')" title="Scout area">
                    <span class="icon">ðŸ”</span>
                    <span class="label">Scout</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('protector')" title="Protect player">
                    <span class="icon">ðŸ›¡ï¸</span>
                    <span class="label">Protector</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('healer')" title="Heal support">
                    <span class="icon">ðŸ’š</span>
                    <span class="label">Healer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('fisher')" title="Fish for food">
                    <span class="icon">ðŸŽ£</span>
                    <span class="label">Fisher</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('miner')" title="Mine ore">
                    <span class="icon">â›ï¸</span>
                    <span class="label">Miner</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgent('explorer')" title="Explore unknown areas">
                    <span class="icon">ðŸ§­</span>
                    <span class="label">Explorer</span>
                </button>
            </div>
        </div>
        <div class="agent-fleet-list" id="agent-fleet-list">
            <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                No agents deployed yet.<br>Click an agent type above to spawn.
            </div>
        </div>
    </div>

    <!-- v5.10: Agent Transcript Viewer Modal -->
    <div id="transcript-modal" class="transcript-modal">
        <div class="transcript-modal-content">
            <div class="transcript-modal-header">
                <div class="transcript-modal-title">
                    <span>ðŸ“‹</span>
                    Agent Transcripts
                </div>
                <div class="transcript-modal-actions">
                    <button class="transcript-action-btn" onclick="copyTranscriptToClipboard()">ðŸ“‹ Copy</button>
                    <button class="transcript-action-btn primary" onclick="downloadCurrentTranscript()">ðŸ’¾ Download</button>
                    <button class="transcript-action-btn" onclick="downloadAllTranscripts()">ðŸ“¦ Export All</button>
                    <button class="transcript-action-btn" onclick="closeTranscriptViewer()">âœ•</button>
                </div>
            </div>
            <div class="transcript-tabs" id="transcript-tabs">
                <!-- Tabs populated dynamically -->
            </div>
            <div class="transcript-modal-body">
                <div class="transcript-agent-info" id="transcript-agent-info">
                    <!-- Agent info populated dynamically -->
                </div>
                <div class="transcript-json" id="transcript-json-view">
                    <!-- JSON content -->
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for import -->
    <input type="file" id="transcript-import-input" accept=".json" style="display: none;" onchange="importTranscriptFile(event)">

    <!-- v5.7: AI Companion Settings Modal - Tabbed Interface -->
    <div id="ai-settings-modal" class="ai-settings-modal">
        <div class="ai-settings-content">
            <div class="ai-settings-header">
                <h2>AI Companion Settings</h2>
                <button class="ai-settings-close" onclick="closeAISettingsModal()">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="ai-settings-tabs">
                <button class="ai-settings-tab active" onclick="switchAITab('general')">General</button>
                <button class="ai-settings-tab" onclick="switchAITab('voice')">Voice</button>
                <button class="ai-settings-tab" onclick="switchAITab('3dview')">3D View</button>
                <button class="ai-settings-tab" onclick="switchAITab('import')">Import/Export</button>
            </div>

            <div class="ai-settings-body">
                <!-- General Tab -->
                <div id="ai-tab-general" class="ai-tab-content active">
                    <div class="ai-section">
                        <h3>API Configuration</h3>
                        <div class="ai-form-group">
                            <label>API Key</label>
                            <input type="password" id="ai-api-key" class="ai-input" placeholder="Enter your API key">
                        </div>
                        <div class="ai-form-group">
                            <label>API Endpoint</label>
                            <input type="text" id="ai-api-endpoint" class="ai-input" placeholder="http://localhost:7071/api/businessinsightbot_function">
                        </div>
                        <div id="ai-endpoints-list"></div>
                    </div>
                    <div class="ai-section">
                        <h3>World Settings</h3>
                        <div class="ai-form-group">
                            <label>Companion Name</label>
                            <input type="text" id="ai-companion-name" class="ai-input" value="Copilot" placeholder="AI Companion">
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Personality</label>
                            <select id="ai-companion-personality" class="ai-select">
                                <option value="helpful">Helpful & Friendly</option>
                                <option value="adventurous">Adventurous Explorer</option>
                                <option value="wise">Wise Sage</option>
                                <option value="playful">Playful Companion</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Voice Tab -->
                <div id="ai-tab-voice" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Voice Output</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Response</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Auto-speak Responses</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-auto-speak">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Azure TTS API Key</label>
                            <input type="password" id="ai-tts-key" class="ai-input" placeholder="Enter Azure TTS key for premium voices">
                        </div>
                        <div class="ai-form-group">
                            <label>Azure Region</label>
                            <input type="text" id="ai-tts-region" class="ai-input" placeholder="eastus2">
                        </div>
                        <div class="ai-form-group">
                            <label>TTS Voice</label>
                            <select id="ai-tts-voice" class="ai-select">
                                <option value="en-US-JennyNeural">Jenny (Female)</option>
                                <option value="en-US-GuyNeural">Guy (Male)</option>
                                <option value="en-US-AriaNeural">Aria (Female)</option>
                                <option value="en-US-DavisNeural">Davis (Male)</option>
                                <option value="en-US-AmberNeural">Amber (Female)</option>
                                <option value="en-US-AnaNeural">Ana (Female - Child)</option>
                                <option value="en-US-BrandonNeural">Brandon (Male)</option>
                                <option value="en-US-ChristopherNeural">Christopher (Male)</option>
                                <option value="en-US-CoraNeural">Cora (Female)</option>
                                <option value="en-US-ElizabethNeural">Elizabeth (Female)</option>
                            </select>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Voice Input</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Input</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-input-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Continuous Conversation Mode</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-continuous-mode">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Push-to-Talk Key</label>
                            <select id="ai-ptt-key" class="ai-select">
                                <option value="Space">Space</option>
                                <option value="KeyV">V</option>
                                <option value="KeyT">T</option>
                                <option value="KeyC">C</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- 3D View Tab -->
                <div id="ai-tab-3dview" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Companion Appearance</h3>
                        <div class="ai-form-group">
                            <label>Primary Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-primary-color" class="ai-color-preview" value="#8a2be2">
                                <input type="text" id="ai-primary-color-hex" class="ai-input ai-color-input" value="#8a2be2">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Glow Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-glow-color" class="ai-color-preview" value="#06ffa5">
                                <input type="text" id="ai-glow-color-hex" class="ai-input ai-color-input" value="#06ffa5">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Size</label>
                            <select id="ai-companion-size" class="ai-select">
                                <option value="small">Small</option>
                                <option value="medium" selected>Medium</option>
                                <option value="large">Large</option>
                            </select>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Show Particles</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-show-particles" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Glow Effect</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-enable-glow" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Behavior</h3>
                        <div class="ai-form-group">
                            <label>Follow Distance</label>
                            <select id="ai-follow-distance" class="ai-select">
                                <option value="2">Close (2m)</option>
                                <option value="3" selected>Normal (3m)</option>
                                <option value="5">Far (5m)</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label>Float Height</label>
                            <select id="ai-float-height" class="ai-select">
                                <option value="1.5">Low (1.5m)</option>
                                <option value="2.5" selected>Normal (2.5m)</option>
                                <option value="3.5">High (3.5m)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Import/Export Tab -->
                <div id="ai-tab-import" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>RAPPID Settings</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
                            Import your RAPPID configuration file to automatically configure API endpoints and Azure TTS settings.
                        </p>
                        <div id="ai-endpoints-preview"></div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="ai-btn ai-btn-import" onclick="document.getElementById('rappidImportFile').click()" style="flex: 1;">
                                Import RAPPID Config
                            </button>
                            <button class="ai-btn ai-btn-cancel" onclick="exportRappidSettings()" style="flex: 1;">
                                Export Settings
                            </button>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Connection Status</h3>
                        <div id="ai-connection-status" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center;">
                            <span style="color: #888;">No endpoint configured</span>
                        </div>
                        <button class="ai-btn ai-btn-cancel" onclick="testRappidConnection()" style="width: 100%; margin-top: 15px;">
                            Test Connection
                        </button>
                    </div>
                    <div class="ai-section">
                        <h3>Reset</h3>
                        <button class="ai-btn" onclick="clearRappidSettings()" style="width: 100%; background: rgba(255,68,68,0.1); border: 1px solid #f44; color: #f44;">
                            Clear All Settings
                        </button>
                    </div>
                    <div id="ai-status-message" class="ai-status-msg"></div>
                </div>
            </div>

            <div class="ai-settings-footer">
                <button class="ai-btn ai-btn-save" onclick="saveAISettings()">Save Changes</button>
                <button class="ai-btn ai-btn-cancel" onclick="closeAISettingsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Box -->
    <div id="daily-challenge" class="daily-challenge-box" style="display: none;">
        <div class="daily-title">Daily Challenge</div>
        <div id="daily-desc" class="daily-desc">Loading...</div>
        <div class="daily-progress-bar">
            <div id="daily-progress-fill" class="daily-progress-fill" style="width: 0%"></div>
        </div>
        <div id="daily-progress-text" class="daily-progress-text">0/0</div>
        <div id="daily-streak" class="daily-streak">Streak: 0 days</div>
    </div>

    <!-- v4.6: Full Settings Panel -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 380px;">
            <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            <div class="modal-title">Settings</div>

            <!-- Audio Section -->
            <div class="settings-section">
                <h4 style="color: #0ff;">Audio</h4>
                <div class="setting-row">
                    <span>Master Volume</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="30" oninput="setMasterVolume(this.value)">
                    <span id="volume-display" style="width: 35px; text-align: right;">30%</span>
                </div>
                <div class="setting-row">
                    <span>Sound Effects</span>
                    <button id="sfx-toggle" class="toggle-btn" onclick="toggleSFX()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Ambient Audio</span>
                    <button id="ambient-toggle" class="toggle-btn" onclick="toggleAmbient()">ON</button>
                </div>
            </div>

            <!-- Graphics Section -->
            <div class="settings-section">
                <h4 style="color: #fb0;">Graphics</h4>
                <div class="setting-row">
                    <span>Particle Quality</span>
                    <select id="particle-quality" onchange="setParticleQuality(this.value)">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span>Shadows</span>
                    <button id="shadow-toggle" class="toggle-btn" onclick="toggleShadows()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Screen Shake</span>
                    <button id="shake-toggle" class="toggle-btn" onclick="toggleScreenShake()">ON</button>
                </div>
            </div>

            <!-- Game Section -->
            <div class="settings-section">
                <h4 style="color: #0f0;">Game</h4>
                <div class="setting-row">
                    <span>Show Hints</span>
                    <button id="hints-toggle" class="toggle-btn" onclick="toggleHints()">ON</button>
                </div>
                <button class="action-btn" onclick="showTutorial(); closeSettingsModal();" style="width: 100%; margin-top: 10px;">Show Tutorial</button>
            </div>

            <!-- Save Info -->
            <p style="color: #666; font-size: 11px; margin-top: 10px; text-align: center;">
                Last saved: <span id="last-save-time">Never</span>
            </p>
        </div>
    </div>

    <!-- v4.7: Welcome Back Modal -->
    <div id="welcome-back-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-title" style="color: #ffd700;">Welcome Back!</div>
            <p id="welcome-back-message" style="color: #0ff; font-size: 16px; margin: 15px 0;"></p>
            <p id="welcome-back-time" style="color: #888; font-size: 12px; margin-bottom: 20px;"></p>

            <div id="welcome-back-rewards" style="background: rgba(0,255,255,0.1); border: 1px solid #0ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0ff; margin: 0 0 10px;">Your Rewards:</h4>
                <div id="welcome-back-rewards-list" style="text-align: left;"></div>
            </div>

            <button class="action-btn" onclick="claimWelcomeBackRewards()" style="width: 100%; padding: 12px; font-size: 16px; background: linear-gradient(135deg, #ffd700, #ff8800);">
                Claim Rewards!
            </button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="stats-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeStatsModal()">&times;</button>
            <div class="modal-title">Player Statistics</div>

            <!-- v4.2: Player Rank Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(0,255,255,0.1)); border: 1px solid #ffd700; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <h3 style="color: #ffd700; margin: 0 0 10px; font-size: 16px;">Player Rank</h3>
                <div class="stat-row"><span>Current Rank</span><span id="stat-rank" style="font-weight: bold;">Novice Explorer</span></div>
                <div class="stat-row"><span>Total Points</span><span id="stat-points">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #888;">
                    <span style="color: #aaa;">Special Titles: </span><span id="special-titles">None yet</span>
                </div>
            </div>

            <div class="stats-section">
                <h3 style="color: #0ff; margin: 15px 0 10px; font-size: 14px;">Exploration</h3>
                <div class="stat-row"><span>Planets Visited</span><span id="stat-planets">0 / 60</span></div>
                <div class="stat-row"><span>POIs Discovered</span><span id="stat-pois">0</span></div>
                <div class="stat-row"><span>Total Playtime</span><span id="stat-playtime">0h 0m</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #fb0; margin: 15px 0 10px; font-size: 14px;">Gathering</h3>
                <div class="stat-row"><span>Trees Chopped</span><span id="stat-trees">0</span></div>
                <div class="stat-row"><span>Ore Mined</span><span id="stat-ore">0</span></div>
                <div class="stat-row"><span>Fish Caught</span><span id="stat-fish">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #f44; margin: 15px 0 10px; font-size: 14px;">Combat</h3>
                <div class="stat-row"><span>Enemies Defeated</span><span id="stat-mobs">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #a0f; margin: 15px 0 10px; font-size: 14px;">Crafting</h3>
                <div class="stat-row"><span>Items Crafted</span><span id="stat-crafted">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #ffd700; margin: 15px 0 10px; font-size: 14px;">Achievements</h3>
                <div id="achievements-list" class="achievements-grid"></div>
            </div>

            <!-- v4.4: Leaderboard Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,200,0,0.1)); border: 1px solid #ff8800; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #ff8800; margin: 0 0 10px; font-size: 14px;">Leaderboard</h3>
                <div id="leaderboard-list" style="font-size: 12px;"></div>
            </div>

            <!-- v4.4: Prestige Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(150,0,255,0.1), rgba(0,200,255,0.1)); border: 1px solid #aa44ff; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #aa44ff; margin: 0 0 10px; font-size: 14px;">Prestige System</h3>
                <div class="stat-row"><span>Prestige Level</span><span id="prestige-level" style="color: #aa44ff; font-weight: bold;">0</span></div>
                <div class="stat-row"><span>XP Multiplier</span><span id="prestige-xp">x1.0</span></div>
                <div class="stat-row"><span>Lifetime Points</span><span id="prestige-lifetime">0</span></div>
                <div id="prestige-progress" style="margin-top: 10px; font-size: 11px; color: #888;"></div>
                <button id="prestige-btn" onclick="performPrestige()" style="display: none; margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, #aa44ff, #6644ff); border: none; border-radius: 4px; color: #fff; cursor: pointer; width: 100%;">PRESTIGE NOW</button>
            </div>
        </div>
    </div>

    <!-- v4.9: Collection Codex Modal -->
    <div id="codex-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeCodexModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Collection Codex</div>

            <!-- Codex Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                <button class="codex-tab active" data-tab="creatures" onclick="switchCodexTab('creatures')">Creatures</button>
                <button class="codex-tab" data-tab="items" onclick="switchCodexTab('items')">Items</button>
                <button class="codex-tab" data-tab="biomes" onclick="switchCodexTab('biomes')">Biomes</button>
                <button class="codex-tab" data-tab="abilities" onclick="switchCodexTab('abilities')">Abilities</button>
                <button class="codex-tab" data-tab="pets" onclick="switchCodexTab('pets')" style="background: linear-gradient(135deg, rgba(255,136,0,0.3), rgba(255,68,0,0.3));">Pets</button>
            </div>

            <!-- Creatures Tab -->
            <div id="codex-creatures" class="codex-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-creatures-count">0</span> / <span id="codex-creatures-total">0</span>
                </div>
                <div id="codex-creatures-grid" class="codex-grid"></div>
            </div>

            <!-- Items Tab -->
            <div id="codex-items" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-items-count">0</span> / <span id="codex-items-total">0</span>
                </div>
                <div id="codex-items-grid" class="codex-grid"></div>
            </div>

            <!-- Biomes Tab -->
            <div id="codex-biomes" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Explored: <span id="codex-biomes-count">0</span> / <span id="codex-biomes-total">0</span>
                </div>
                <div id="codex-biomes-grid" class="codex-grid"></div>
            </div>

            <!-- Abilities Tab -->
            <div id="codex-abilities" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Unlocked: <span id="codex-abilities-count">0</span> / <span id="codex-abilities-total">0</span>
                </div>
                <div id="codex-abilities-grid" class="codex-grid"></div>
            </div>

            <!-- v5.0: Pets Tab -->
            <div id="codex-pets" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Collected: <span id="codex-pets-count">0</span> / <span id="codex-pets-total">0</span>
                    <span style="margin-left: 15px;">Active: <span id="active-pet-name" style="color: #ff8c00;">None</span></span>
                </div>
                <div id="codex-pets-grid" class="codex-grid"></div>
            </div>
        </div>
    </div>

    <!-- v5.0: Quest System Modal -->
    <div id="quest-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeQuestModal()">&times;</button>
            <div class="modal-title" style="color: #ff8c00;">Quest Board</div>

            <!-- Quest Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px;">
                <button class="codex-tab active" data-tab="daily" onclick="switchQuestTab('daily')">Daily</button>
                <button class="codex-tab" data-tab="weekly" onclick="switchQuestTab('weekly')">Weekly</button>
                <button class="codex-tab" data-tab="story" onclick="switchQuestTab('story')">Story</button>
            </div>

            <!-- Daily Quests -->
            <div id="quest-daily" class="quest-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="daily-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="daily-quests-list" class="quest-list"></div>
            </div>

            <!-- Weekly Quests -->
            <div id="quest-weekly" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="weekly-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="weekly-quests-list" class="quest-list"></div>
            </div>

            <!-- Story Quests -->
            <div id="quest-story" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Progress through the story to unlock rewards!
                </div>
                <div id="story-quests-list" class="quest-list"></div>
            </div>
        </div>
    </div>

    <!-- v5.1: Enchantment Modal -->
    <div id="enchant-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEnchantModal()">&times;</button>
            <div class="modal-title" style="color: #8af;">âœ¨ Enchanting Table</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px;">
                Add magical enhancements to your equipped gear!
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Your Gear:</div>
                    <div id="enchant-items"></div>
                </div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Enchantments:</div>
                    <div id="enchant-options"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- v5.2: Talent Tree Modal -->
    <div id="talent-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeTalentModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">ðŸŒŸ Talent Trees</div>
            <div id="talent-points-display" style="color: #aaa; font-size: 14px; margin-bottom: 15px; text-align: center;">
                Talent Points: 0/0
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <div style="text-align: center; font-weight: bold; color: #ff4444; margin-bottom: 10px;">âš”ï¸ Combat</div>
                    <div id="talent-tree-combat"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44aaff; margin-bottom: 10px;">ðŸ›¡ï¸ Survival</div>
                    <div id="talent-tree-survival"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44ff44; margin-bottom: 10px;">ðŸ€ Fortune</div>
                    <div id="talent-tree-fortune"></div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px; font-size: 11px; color: #666;">
                Earn 1 talent point per 5 combined skill levels
            </div>
        </div>
    </div>

    <!-- v5.3: Mastery System Modal -->
    <div id="mastery-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeMasteryModal()">&times;</button>
            <div class="modal-title" style="color: #ff44ff;">Skill Mastery</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Reach skill milestones to unlock permanent bonuses!
            </div>
            <div id="mastery-list"></div>
        </div>
    </div>

    <!-- v5.3: Realm Portal Modal -->
    <div id="portal-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closePortalModal()">&times;</button>
            <div class="modal-title" style="color: #8844ff;">Realm Portals</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Enter challenging realms for exclusive rewards!
            </div>
            <div id="portal-status" style="text-align: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <span style="color: #888;">Current Realm:</span>
                <span id="current-realm" style="color: #ff8844; font-weight: bold; margin-left: 8px;">None</span>
            </div>
            <div id="portal-list"></div>
        </div>
    </div>

    <!-- v5.4: Companion Evolution Modal -->
    <div id="evolution-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEvolutionModal()">&times;</button>
            <div class="modal-title" style="color: #aa44ff;">Companion Evolution</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Bond with your companions to unlock powerful evolutions!
            </div>
            <div id="evolution-list"></div>
        </div>
    </div>

    <!-- v5.4: Achievement Showcase Modal -->
    <div id="showcase-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeShowcaseModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Achievement Showcase</div>
            <div class="achievement-points-display">
                <div class="ap-value" id="total-ap">0</div>
                <div class="ap-label">Achievement Points</div>
                <div class="ap-milestone">
                    <div style="display: flex; justify-content: space-between; font-size: 11px;">
                        <span style="color: #aaa;">Next Milestone:</span>
                        <span id="next-milestone-name" style="color: #ffd700;">---</span>
                    </div>
                    <div class="ap-milestone-progress">
                        <div class="ap-milestone-fill" id="milestone-progress" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 10px; font-size: 12px; color: #888;">
                Active Cosmetic: <span id="active-cosmetic" style="color: #aa44ff;">None</span>
            </div>
            <div id="showcase-badges" class="showcase-grid"></div>
        </div>
    </div>

    <!-- v5.4: World Event Indicator -->
    <div id="event-indicator" class="event-indicator">
        <div class="event-indicator-icon" id="event-ind-icon"></div>
        <div class="event-indicator-name" id="event-ind-name">No Event</div>
        <div class="event-indicator-time" id="event-ind-time">--:--</div>
        <div class="event-indicator-progress">
            <div class="event-indicator-fill" id="event-ind-fill" style="width: 100%;"></div>
        </div>
    </div>

    <!-- v5.5: 3D Ship Landing Mini-Game Overlay -->
    <div id="landing-overlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000;">
        <div id="landing-scene-container" style="width: 100%; height: 100%;"></div>

        <!-- Landing HUD -->
        <div id="landing-info" style="position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <div style="font-size: 18px; font-weight: bold; color: #00ff88; margin-bottom: 10px;" id="landing-planet-name">Landing Sequence</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Altitude:</span> <span id="landing-altitude">0</span>m</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Speed:</span> <span id="landing-speed">0</span>m/s</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Fuel:</span> <span id="landing-fuel">100</span>%</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Mode:</span> <span id="landing-mode">Autonomous</span></div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Distance:</span> <span id="landing-distance">0</span>m</div>
        </div>

        <!-- Landing Controls -->
        <div id="landing-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 10px; color: white; display: flex; gap: 20px; align-items: center; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <button onclick="toggleLandingMode()" id="landing-mode-btn" style="background: #00ff88; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #000;">Switch to Manual</button>
            <button onclick="abortLanding()" style="background: #ff4444; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #fff;">Abort Landing</button>
            <div style="color: #888; font-size: 12px;">Manual: Arrow Keys + Space/Shift</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === LEVIATHAN: OMNIVERSE v4.9 ===
        // Enhanced with local-first principles: localStorage persistence & JSON import/export
        // v4.0: Performance optimizations, audio system, particle effects, improved UX
        // v4.1: Achievement system, daily challenges, statistics panel, visual enhancements
        // v4.2: Enemy variety, skill bonuses, POI system, player ranks, combat improvements
        // v4.3: Boss encounters, mobile touch controls, ambient audio, notification queue
        // v4.4: Hit-stop combat, environmental particles, local leaderboard, prestige system, fog of war
        // v4.5: Attack telegraphing, player dodge, recipe discovery, settings panel, boss spawn gates
        // v4.6: Settings persistence, elemental status effects, parry/counter system
        // v4.7: Elite enemy system with affixes, elite gear crafting, session rewards, adaptive performance
        // v4.8: Combo attack system, combat abilities (Q/E/R), ability cooldown UI, item tooltips
        // v4.9: Tier 2 combat abilities (T/F/Z/X/C), visual buff overlays, Collection Codex system
        // v5.0: Quest System (daily/weekly/story), Pet Companions, Weather System
        // v5.1: Equipment System (4 slots), enhanced crafting, enchantment system with 8 enchants
        // v5.2: Talent Tree System (3 trees: Combat/Survival/Fortune, 15 talents)
        // v5.3: Mastery System (skill milestones), Realm Portals (endgame dungeons), Loot Rarity System (item modifiers)
        // v5.4: Companion Evolution System (pets evolve at bond levels), World Events (random spawning events), Achievement Showcase (badges & points)
        // v5.5: Ship Landing Mini-Game (physics-based landing sequence with biome-specific terrain when visiting planets)
        // v5.6: Copilot Companion System (3D AI companion that follows player and provides contextual help)
        // v5.7: RAPPID Integration (AI endpoints, Azure TTS, settings import/export)
        // v5.8: Fixed keyboard input capture when typing in chat, improved API request format
        // v5.9: Updated Azure TTS to use Microsoft Speech SDK for proper voice output
        //       Added Azure STT for microphone input, uses voice_response for TTS
        //       Real-time transcription overlay with auto-send option
        //       Markdown rendering for chat messages with clickable links
        //       Voice hotkeys: V to open chat+voice, Space to speak while chat open, Esc to close
        // v5.10: Multi-Agent Fleet System (spawn up to 10 AI-driven autonomous agents)
        //        Transcript export system for debugging agent conversations
        //        Star Wars-style 3D text crawl for voice responses
        // v5.13: Visible Ship on World Map with Defensive Laser System
        //        Ship HP and damage mechanics - protect your landing zone!

        const APP_NAME = 'leviathan-omniverse';
        const VERSION = '5.13.0';

        // ============================================
        // THREE.js Extensions: FontLoader & TextGeometry
        // Required for 3D text rendering
        // ============================================
        THREE.FontLoader = class FontLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(text) {
                    try {
                        const json = JSON.parse(text);
                        const font = scope.parse(json);
                        if (onLoad) onLoad(font);
                    } catch (e) {
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            }

            parse(json) {
                return new THREE.Font(json);
            }
        };

        THREE.Font = class Font {
            constructor(data) {
                this.type = 'Font';
                this.data = data;
            }

            generateShapes(text, size = 100) {
                const shapes = [];
                const paths = createFontPaths(text, size, this.data);
                for (let p = 0, pl = paths.length; p < pl; p++) {
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                }
                return shapes;
            }
        };

        THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
            constructor(text, parameters = {}) {
                const font = parameters.font;
                if (!font || !font.data) {
                    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                    super();
                    return;
                }
                const shapes = font.generateShapes(text, parameters.size);
                parameters.depth = parameters.height !== undefined ? parameters.height : 50;
                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
                super(shapes, parameters);
                this.type = 'TextGeometry';
            }
        };

        function createFontPaths(text, size, data) {
            const chars = Array.from(text);
            const scale = size / data.resolution;
            const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
            const paths = [];
            let offsetX = 0, offsetY = 0;

            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                if (char === '\n') {
                    offsetX = 0;
                    offsetY -= line_height;
                } else {
                    const ret = createFontPath(char, scale, offsetX, offsetY, data);
                    if (ret) {
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
            }
            return paths;
        }

        function createFontPath(char, scale, offsetX, offsetY, data) {
            const glyph = data.glyphs[char] || data.glyphs['?'];
            if (!glyph) {
                console.error('THREE.Font: character "' + char + '" does not exist in font.');
                return;
            }
            const path = new THREE.ShapePath();
            let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if (glyph.o) {
                const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                for (let i = 0, l = outline.length; i < l;) {
                    const action = outline[i++];
                    switch (action) {
                        case 'm':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;
                        case 'l':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;
                        case 'q':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            break;
                        case 'b':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            break;
                    }
                }
            }
            return { offsetX: glyph.ha * scale, path: path };
        }

        // --- AUDIO SYSTEM (Web Audio API - No external dependencies) ---
        const AudioSystem = {
            ctx: null,
            enabled: true,
            masterVolume: 0.3,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone(freq, duration, type = 'sine', volume = 1) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(this.masterVolume * volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain).connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            hit() { this.playTone(200, 0.08, 'square', 0.5); },
            collect() { this.playTone(600, 0.12, 'sine', 0.6); },
            damage() { this.playTone(80, 0.15, 'sawtooth', 0.7); },
            kill() {
                this.playTone(150, 0.1, 'square', 0.5);
                setTimeout(() => this.playTone(100, 0.15, 'square', 0.4), 50);
            },
            // v4.7: Explosion sound for explosive elite death
            explosion() {
                this.playTone(80, 0.3, 'sawtooth', 0.6);
                setTimeout(() => this.playTone(60, 0.2, 'sawtooth', 0.4), 50);
                setTimeout(() => this.playTone(40, 0.15, 'square', 0.3), 100);
            },
            levelUp() {
                [400, 500, 600, 800].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.15, 'sine', 0.5), i * 80);
                });
            },
            craft() { this.playTone(440, 0.1, 'triangle', 0.4); },
            click() { this.playTone(800, 0.03, 'sine', 0.2); },
            error() { this.playTone(100, 0.2, 'sawtooth', 0.3); },
            heal() { this.playTone(520, 0.2, 'sine', 0.4); },
            // v4.5: Dodge and telegraph sounds
            dodge() { this.playTone(300, 0.08, 'sine', 0.4); this.playTone(450, 0.06, 'sine', 0.3); },
            telegraph() { this.playTone(150, 0.1, 'square', 0.25); },

            // v4.3: Ambient Audio System
            ambientNode: null,
            ambientGain: null,
            currentBiome: null,

            // Biome-specific ambient audio configurations
            biomeAmbient: {
                Terra: { baseFreq: 80, modFreq: 0.3, type: 'sine', volume: 0.08 },
                Desert: { baseFreq: 120, modFreq: 0.1, type: 'sine', volume: 0.06 },
                Ice: { baseFreq: 200, modFreq: 0.5, type: 'sine', volume: 0.07 },
                Volcanic: { baseFreq: 60, modFreq: 0.2, type: 'triangle', volume: 0.09 },
                Alien: { baseFreq: 150, modFreq: 0.8, type: 'sawtooth', volume: 0.05 }
            },

            startAmbient(biome) {
                if (!this.enabled || !this.ctx || this.currentBiome === biome) return;
                this.stopAmbient();
                this.currentBiome = biome;
                this.resume();

                const config = this.biomeAmbient[biome] || this.biomeAmbient.Terra;

                // Create ambient drone
                this.ambientNode = this.ctx.createOscillator();
                this.ambientGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                // LFO for subtle modulation
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = config.modFreq;
                lfoGain.gain.value = config.baseFreq * 0.1;
                lfo.connect(lfoGain);
                lfoGain.connect(this.ambientNode.frequency);
                lfo.start();

                this.ambientNode.type = config.type;
                this.ambientNode.frequency.value = config.baseFreq;

                filter.type = 'lowpass';
                filter.frequency.value = 300;
                filter.Q.value = 1;

                this.ambientGain.gain.value = config.volume * this.masterVolume;

                this.ambientNode.connect(filter);
                filter.connect(this.ambientGain);
                this.ambientGain.connect(this.ctx.destination);
                this.ambientNode.start();

                // Store LFO for cleanup
                this.ambientLfo = lfo;
                this.ambientLfoGain = lfoGain;
            },

            stopAmbient() {
                if (this.ambientNode) {
                    try {
                        this.ambientNode.stop();
                        this.ambientNode.disconnect();
                        if (this.ambientLfo) {
                            this.ambientLfo.stop();
                            this.ambientLfo.disconnect();
                        }
                    } catch (e) {}
                    this.ambientNode = null;
                    this.ambientLfo = null;
                    this.currentBiome = null;
                }
            },

            bossSpawn() {
                // Dramatic boss spawn sound
                [100, 80, 60, 40].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.3, 'sawtooth', 0.6), i * 100);
                });
            },

            // v4.5: Dodge and telegraph sounds
            dodge() {
                this.playTone(400, 0.08, 'sine', 0.3);
                this.playTone(600, 0.06, 'sine', 0.2);
            },
            telegraph() {
                this.playTone(200, 0.15, 'square', 0.2);
            },
            recipeDiscovered() {
                [600, 800, 1000].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.12, 'triangle', 0.4), i * 60);
                });
            }
        };

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 200;
            }

            emit(position, count, color, options = {}) {
                const spread = options.spread || 3;
                const lifetime = options.lifetime || 1000;
                const size = options.size || 0.2;
                const gravity = options.gravity !== undefined ? options.gravity : 10;

                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(size, 4, 4),
                            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * spread,
                            Math.random() * spread * 0.8 + spread * 0.2,
                            (Math.random() - 0.5) * spread
                        ),
                        lifetime,
                        startTime: performance.now(),
                        gravity
                    };
                    particle.mesh.position.copy(position);
                    particle.mesh.position.y += 1;
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }

            update(dt) {
                const now = performance.now();
                this.particles = this.particles.filter(p => {
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.lifetime;

                    if (progress >= 1) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    // Physics
                    p.velocity.y -= p.gravity * dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                    p.mesh.material.opacity = 1 - progress;
                    p.mesh.scale.setScalar(1 - progress * 0.5);

                    return true;
                });
            }
        }

        let particles;

        // v4.4: Hit-Stop System - Freezes game briefly on impacts for satisfying combat
        let hitStopUntil = 0;
        const HIT_STOP_LIGHT = 30;   // Normal hits (ms)
        const HIT_STOP_HEAVY = 80;   // Kills (ms)
        const HIT_STOP_BOSS = 150;   // Boss impacts (ms)

        function triggerHitStop(duration) {
            hitStopUntil = performance.now() + duration;
        }

        // v4.4: Enhanced Hit Flash
        function flashTargetHit(target, flashColor = 0xffffff) {
            const originalMaterials = [];
            target.traverse(child => {
                if (child.material && child.material.color) {
                    originalMaterials.push({
                        mesh: child,
                        color: child.material.color.getHex(),
                        emissive: child.material.emissive?.getHex() || 0,
                        emissiveIntensity: child.material.emissiveIntensity || 0
                    });
                    child.material.color.setHex(flashColor);
                    if (child.material.emissive) {
                        child.material.emissive.setHex(flashColor);
                        child.material.emissiveIntensity = 1;
                    }
                }
            });

            setTimeout(() => {
                originalMaterials.forEach(data => {
                    if (data.mesh.material) {
                        data.mesh.material.color.setHex(data.color);
                        if (data.mesh.material.emissive) {
                            data.mesh.material.emissive.setHex(data.emissive);
                            data.mesh.material.emissiveIntensity = data.emissiveIntensity;
                        }
                    }
                });
            }, 50);
        }

        // v4.4: Environmental Particle System
        class EnvironmentParticles {
            constructor() {
                this.particles = [];
                this.maxParticles = 60;
                this.currentBiome = null;
                this.biomeConfigs = {
                    Terra: { color: 0x88aa44, count: 20, speed: 1.5, type: 'leaves', gravity: 2 },
                    Desert: { color: 0xddcc99, count: 30, speed: 3, type: 'dust', gravity: 0.5 },
                    Ice: { color: 0xeeffff, count: 40, speed: 0.8, type: 'snow', gravity: 1 },
                    Volcanic: { color: 0xff4400, count: 25, speed: 4, type: 'embers', gravity: -3 },
                    Alien: { color: 0xff00ff, count: 20, speed: 1, type: 'spores', gravity: -0.5 }
                };
            }

            startBiome(biome) {
                if (this.currentBiome === biome) return;
                this.stop();
                this.currentBiome = biome;
            }

            stop() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                this.particles = [];
                this.currentBiome = null;
            }

            update(dt, playerPos) {
                if (!this.currentBiome) return;
                const config = this.biomeConfigs[this.currentBiome];
                if (!config) return;

                // Spawn new particles near player
                while (this.particles.length < config.count) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * 20;
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 4, 4),
                            new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.6 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * config.speed,
                            config.gravity > 0 ? -Math.abs(config.gravity) : config.gravity,
                            (Math.random() - 0.5) * config.speed
                        ),
                        life: 5 + Math.random() * 5
                    };
                    particle.mesh.position.set(
                        playerPos.x + Math.cos(angle) * dist,
                        playerPos.y + 5 + Math.random() * 10,
                        playerPos.z + Math.sin(angle) * dist
                    );
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.life -= dt;
                    if (p.life <= 0 || p.mesh.position.y < 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    // Sway for leaves/snow
                    if (config.type === 'leaves' || config.type === 'snow') {
                        p.mesh.position.x += Math.sin(performance.now() * 0.002 + p.life) * 0.02;
                    }

                    // Pulse for spores
                    if (config.type === 'spores') {
                        p.mesh.material.opacity = 0.3 + Math.sin(performance.now() * 0.005) * 0.3;
                    }

                    return true;
                });
            }
        }

        let envParticles;

        // v4.5: Player Dodge System
        const DODGE_CONFIG = {
            DISTANCE: 6,
            DURATION: 180,       // ms
            COOLDOWN: 600,       // ms
            IFRAMES: 150         // invincibility duration in ms
        };

        let dodgeState = {
            active: false,
            direction: new THREE.Vector3(),
            startTime: 0,
            cooldownEnd: 0,
            iframesEnd: 0
        };

        // v4.6: Parry/Counter System
        const PARRY_CONFIG = {
            WINDOW: 250,          // ms before attack lands to trigger parry
            STUN_DURATION: 1500,  // ms enemy is stunned
            CRIT_MULTIPLIER: 2.5, // damage multiplier during crit window
            CRIT_WINDOW: 2000     // ms player has to land crits
        };

        let parryState = {
            critWindowEnd: 0,
            lastParryTime: 0
        };

        // v4.8: Combo Attack System
        const COMBO_CONFIG = {
            WINDOW: 1200,           // ms to chain next hit
            MAX_HITS: 5,            // maximum combo length
            DAMAGE_MULT: [1.0, 1.15, 1.35, 1.6, 2.0],  // damage multiplier per hit
            FINISHER_BONUS: 1.5,    // extra multiplier on max combo hit
            BREAK_ON_DAMAGE: true   // combo breaks if player takes damage
        };

        let comboState = {
            count: 0,
            lastHitTime: 0,
            active: false
        };

        function updateCombo(hitTime) {
            const timeSinceLastHit = hitTime - comboState.lastHitTime;

            if (comboState.active && timeSinceLastHit <= COMBO_CONFIG.WINDOW) {
                // Continue combo
                comboState.count = Math.min(comboState.count + 1, COMBO_CONFIG.MAX_HITS - 1);
            } else {
                // Start new combo
                comboState.count = 0;
                comboState.active = true;
            }
            comboState.lastHitTime = hitTime;

            return comboState.count;
        }

        function getComboMultiplier() {
            if (!comboState.active) return 1.0;
            let mult = COMBO_CONFIG.DAMAGE_MULT[comboState.count] || COMBO_CONFIG.DAMAGE_MULT[COMBO_CONFIG.MAX_HITS - 1];
            // Finisher bonus at max combo
            if (comboState.count >= COMBO_CONFIG.MAX_HITS - 1) {
                mult *= COMBO_CONFIG.FINISHER_BONUS;
            }
            return mult;
        }

        function breakCombo() {
            if (comboState.active) {
                comboState.active = false;
                comboState.count = 0;
            }
        }

        // v4.8: Combat Abilities System
        const COMBAT_ABILITIES = {
            powerStrike: {
                name: 'Power Strike',
                key: 'Q',
                icon: 'âš”ï¸',
                cooldown: 8000,       // 8 seconds
                unlockLevel: 3,       // Combat level 3
                damageMultiplier: 3,
                description: '3x damage attack'
            },
            whirlwind: {
                name: 'Whirlwind',
                key: 'E',
                icon: 'ðŸŒ€',
                cooldown: 12000,      // 12 seconds
                unlockLevel: 5,       // Combat level 5
                radius: 8,
                damageMultiplier: 1.5,
                description: 'AoE damage to all nearby enemies'
            },
            warcry: {
                name: 'War Cry',
                key: 'R',
                icon: 'ðŸ“¢',
                cooldown: 20000,      // 20 seconds
                unlockLevel: 7,       // Combat level 7
                duration: 5000,       // 5 second buff
                damageBoost: 1.5,
                description: '+50% damage for 5 seconds'
            },
            // v4.9: Tier 2 Abilities
            heal: {
                name: 'Battle Heal',
                key: 'T',
                icon: 'ðŸ’š',
                cooldown: 15000,      // 15 seconds
                unlockLevel: 9,       // Combat level 9
                healAmount: 0.3,      // 30% of max HP
                description: 'Restore 30% of max HP'
            },
            dash: {
                name: 'Combat Dash',
                key: 'F',
                icon: 'ðŸ’¨',
                cooldown: 6000,       // 6 seconds
                unlockLevel: 10,      // Combat level 10
                distance: 8,
                damageMultiplier: 1.2,
                description: 'Dash forward, damaging enemies in path'
            },
            shieldWall: {
                name: 'Shield Wall',
                key: 'Z',
                icon: 'ðŸ›¡ï¸',
                cooldown: 25000,      // 25 seconds
                unlockLevel: 12,      // Combat level 12
                duration: 4000,       // 4 seconds
                damageReduction: 0.7, // 70% damage reduction
                description: '70% damage reduction for 4 seconds'
            },
            execute: {
                name: 'Execute',
                key: 'X',
                icon: 'ðŸ’€',
                cooldown: 10000,      // 10 seconds
                unlockLevel: 15,      // Combat level 15
                threshold: 0.3,       // Below 30% HP
                damageMultiplier: 5,  // 5x damage to low HP targets
                description: '5x damage to enemies below 30% HP'
            },
            berserk: {
                name: 'Berserker Rage',
                key: 'C',
                icon: 'ðŸ”¥',
                cooldown: 45000,      // 45 seconds (ultimate)
                unlockLevel: 20,      // Combat level 20
                duration: 8000,       // 8 seconds
                damageBoost: 2.0,     // 100% more damage
                attackSpeedBoost: 1.5,// 50% faster attacks
                description: 'ULTIMATE: +100% damage, +50% attack speed for 8s'
            }
        };

        let abilityState = {
            powerStrike: { lastUsed: 0 },
            whirlwind: { lastUsed: 0 },
            warcry: { lastUsed: 0, activeUntil: 0 },
            // v4.9: Tier 2 ability states
            heal: { lastUsed: 0 },
            dash: { lastUsed: 0 },
            shieldWall: { lastUsed: 0, activeUntil: 0 },
            execute: { lastUsed: 0 },
            berserk: { lastUsed: 0, activeUntil: 0 }
        };

        function isAbilityUnlocked(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return gameData.skills.combat.level >= ability.unlockLevel;
        }

        function isAbilityReady(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return performance.now() - abilityState[abilityKey].lastUsed >= ability.cooldown;
        }

        function getAbilityCooldownRemaining(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            const elapsed = performance.now() - abilityState[abilityKey].lastUsed;
            return Math.max(0, ability.cooldown - elapsed);
        }

        function useAbility(abilityKey) {
            if (!isAbilityUnlocked(abilityKey)) {
                showNotification(`${COMBAT_ABILITIES[abilityKey].name} unlocks at Combat Lv ${COMBAT_ABILITIES[abilityKey].unlockLevel}`, 'warning');
                return false;
            }
            if (!isAbilityReady(abilityKey)) {
                return false;
            }
            if (mode !== 'world' || !worldState.player) return false;

            const ability = COMBAT_ABILITIES[abilityKey];
            const p = worldState.player;
            const now = performance.now();

            abilityState[abilityKey].lastUsed = now;
            // v5.0: Track ability usage for quests
            trackAbilityUsage();

            if (abilityKey === 'powerStrike') {
                // Find nearest mob and deal massive damage
                let nearestMob = null;
                let nearestDist = 5; // Range limit
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });
                if (nearestMob) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `${ability.icon} POWER STRIKE! -${damage}`, '#ff4400');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.0);
                    if (particles) particles.emit(nearestMob.position, 25, 0xff4400, { spread: 4, lifetime: 800 });
                    AudioSystem.hit();
                    // Check kill
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                } else {
                    showNotification('No enemy in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0; // Refund cooldown
                    return false;
                }
            } else if (abilityKey === 'whirlwind') {
                // AoE damage to all nearby mobs
                let hitCount = 0;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < ability.radius) {
                        const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `${ability.icon} -${damage}`, '#00ffff');
                        hitCount++;
                        if (mob.userData.hp <= 0) {
                            // Queue for death handling
                            setTimeout(() => {
                                if (mob.userData.hp <= 0) performAction(mob);
                            }, 100);
                        }
                    }
                });
                if (hitCount > 0) {
                    spawnFloater(p.position, `${ability.icon} WHIRLWIND! x${hitCount}`, '#00ffff');
                    triggerHitStop(HIT_STOP_HEAVY);
                    screenShake(0.8);
                    if (particles) particles.emit(p.position, 40, 0x00ffff, { spread: ability.radius, lifetime: 600 });
                    AudioSystem.hit();
                } else {
                    showNotification('No enemies nearby!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'warcry') {
                // Activate damage buff
                abilityState.warcry.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} WAR CRY!`, '#ff8800');
                showNotification(`+${Math.floor((ability.damageBoost - 1) * 100)}% damage for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 30, 0xff8800, { spread: 6, lifetime: 1000 });
                AudioSystem.levelUp();
            }
            // v4.9: Tier 2 Abilities
            else if (abilityKey === 'heal') {
                // Self heal
                const healAmt = Math.floor(gameData.player.maxHp * ability.healAmount);
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                spawnFloater(p.position, `${ability.icon} +${healAmt} HP`, '#00ff88');
                showNotification(`Healed ${healAmt} HP!`, 'success');
                if (particles) particles.emit(p.position, 20, 0x00ff88, { spread: 3, lifetime: 800 });
                updateHealthUI();
                AudioSystem.levelUp();
            } else if (abilityKey === 'dash') {
                // Combat dash - move forward and damage enemies in path
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(p.quaternion);
                const startPos = p.position.clone();
                const endPos = p.position.clone().add(dir.multiplyScalar(ability.distance));

                // Damage enemies in path
                let dashHits = 0;
                worldState.mobs.forEach(mob => {
                    const mobPos = mob.position.clone();
                    // Check if mob is roughly between start and end
                    const toMob = mobPos.sub(startPos);
                    const projection = toMob.dot(dir.clone().normalize());
                    if (projection > 0 && projection < ability.distance) {
                        const perpDist = toMob.clone().sub(dir.clone().normalize().multiplyScalar(projection)).length();
                        if (perpDist < 2) {
                            const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                            mob.userData.hp -= damage;
                            spawnFloater(mob.position, `${ability.icon} -${damage}`, '#88ffff');
                            dashHits++;
                            if (mob.userData.hp <= 0) {
                                setTimeout(() => { if (mob.userData.hp <= 0) performAction(mob); }, 100);
                            }
                        }
                    }
                });

                // Move player
                p.position.copy(endPos);
                spawnFloater(p.position, `${ability.icon} DASH!`, '#88ffff');
                if (dashHits > 0) {
                    showNotification(`Dash hit ${dashHits} enemies!`, 'success');
                    triggerHitStop(HIT_STOP_LIGHT);
                }
                if (particles) particles.emit(startPos, 15, 0x88ffff, { spread: 2, lifetime: 400 });
                AudioSystem.hit();
            } else if (abilityKey === 'shieldWall') {
                // Activate damage reduction buff
                abilityState.shieldWall.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} SHIELD WALL!`, '#4488ff');
                showNotification(`${Math.floor(ability.damageReduction * 100)}% damage reduction for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 25, 0x4488ff, { spread: 4, lifetime: 1000 });
                AudioSystem.levelUp();
            } else if (abilityKey === 'execute') {
                // High damage to low HP enemies
                let target = null;
                let nearestDist = 6;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                    if (dist < nearestDist && hpPercent <= ability.threshold) {
                        nearestDist = dist;
                        target = mob;
                    }
                });
                if (target) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    target.userData.hp -= damage;
                    spawnFloater(target.position, `${ability.icon} EXECUTE! -${damage}`, '#ff0044');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.2);
                    if (particles) particles.emit(target.position, 35, 0xff0044, { spread: 5, lifetime: 1000 });
                    AudioSystem.hit();
                    if (target.userData.hp <= 0) {
                        performAction(target);
                    }
                } else {
                    showNotification('No low HP enemies in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'berserk') {
                // ULTIMATE: Massive damage and attack speed buff
                abilityState.berserk.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} BERSERKER RAGE!`, '#ff4400');
                showNotification(`BERSERK! +100% DMG, +50% Attack Speed for ${ability.duration / 1000}s!`, 'success');
                screenShake(1.5);
                if (particles) particles.emit(p.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                AudioSystem.levelUp();
            }

            updateAbilityUI();
            return true;
        }

        function isWarcryActive() {
            return performance.now() < abilityState.warcry.activeUntil;
        }

        // v4.9: Check if Shield Wall is active
        function isShieldWallActive() {
            return performance.now() < abilityState.shieldWall.activeUntil;
        }

        // v4.9: Check if Berserk is active
        function isBerserkActive() {
            return performance.now() < abilityState.berserk.activeUntil;
        }

        function startDodge() {
            if (dodgeState.active || performance.now() < dodgeState.cooldownEnd) return false;
            if (mode !== 'world' || !worldState.player) return false;

            const p = worldState.player;
            dodgeState.active = true;
            dodgeState.startTime = performance.now();
            dodgeState.cooldownEnd = performance.now() + DODGE_CONFIG.COOLDOWN;
            dodgeState.iframesEnd = performance.now() + DODGE_CONFIG.IFRAMES;

            // Direction based on current input or facing
            dodgeState.direction.set(0, 0, 0);
            if (keys.w) dodgeState.direction.z -= 1;
            if (keys.s) dodgeState.direction.z += 1;
            if (keys.a) dodgeState.direction.x -= 1;
            if (keys.d) dodgeState.direction.x += 1;

            // Also check joystick
            if (dodgeState.direction.length() < 0.1 && joystickActive) {
                dodgeState.direction.set(joystickInput.x, 0, joystickInput.y);
            }

            // Default to backward if no input
            if (dodgeState.direction.length() < 0.1) {
                dodgeState.direction.set(-Math.sin(p.rotation.y), 0, -Math.cos(p.rotation.y));
            }
            dodgeState.direction.normalize();

            AudioSystem.dodge();
            if (particles) particles.emit(p.position, 10, 0x88ffff, { spread: 2, lifetime: 300, gravity: 0 });

            // v4.6: Check for parry opportunity
            checkParryTiming();

            return true;
        }

        function updateDodge(dt) {
            if (!dodgeState.active) return;

            const elapsed = performance.now() - dodgeState.startTime;
            const progress = elapsed / DODGE_CONFIG.DURATION;

            if (progress < 1) {
                const eased = 1 - Math.pow(1 - progress, 3);
                const moveAmount = (1 - eased) * DODGE_CONFIG.DISTANCE * dt * 10;
                worldState.player.position.add(dodgeState.direction.clone().multiplyScalar(moveAmount));
            } else {
                dodgeState.active = false;
            }
        }

        function isInvincible() {
            return performance.now() < dodgeState.iframesEnd;
        }

        // v4.6: Check if dodge was timed for a parry
        function checkParryTiming() {
            if (!worldState || !worldState.mobs) return;

            const now = performance.now();
            let parried = false;

            worldState.mobs.forEach(mob => {
                if (mob.userData.telegraphing && !mob.userData.stunned) {
                    const timeToAttack = mob.userData.telegraphEnd - now;
                    // Check if dodge was in the parry window (last PARRY_CONFIG.WINDOW ms before attack)
                    if (timeToAttack > 0 && timeToAttack <= PARRY_CONFIG.WINDOW) {
                        // Perfect parry!
                        mob.userData.stunned = true;
                        mob.userData.stunEnd = now + PARRY_CONFIG.STUN_DURATION;
                        mob.userData.telegraphing = false;

                        // Visual feedback
                        mob.material.emissive.setHex(0xffff00); // Yellow stun
                        mob.scale.setScalar(1);
                        spawnFloater(mob.position, 'âš¡ PARRY!', '#ffd700');

                        parried = true;
                    }
                }
            });

            if (parried) {
                // Grant crit window
                parryState.critWindowEnd = now + PARRY_CONFIG.CRIT_WINDOW;
                parryState.lastParryTime = now;

                // Audio feedback
                AudioSystem.levelUp();

                // Screen effect
                screenShake(0.3);
                if (particles) particles.emit(worldState.player.position, 25, 0xffd700, { spread: 4, lifetime: 500 });

                showNotification('PERFECT PARRY! Critical hits enabled!');
            }
        }

        // v4.6: Check if in crit window from parry
        function isInCritWindow() {
            return performance.now() < parryState.critWindowEnd;
        }

        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            WORLD_SIZE: 100,
            TILE_SIZE: 2,
            PLAYER_MAX_HP: 100,
            MOB_DAMAGE: 5,
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            // New v4.0 constants
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 2,
            MOB_ATTACK_COOLDOWN: 1500,
            INTERACTION_RANGE: 3.5,
            INTERACTION_COOLDOWN: 400, // ms between actions
            MOVEMENT_THRESHOLD: 0.5,
            SCREEN_SHAKE_INTENSITY: 0.5,
            SCREEN_SHAKE_DURATION: 150
        };

        // v4.7: Player state for status effects
        const playerState = {
            chilled: false,
            chilledEnd: 0,
            moveSpeedMult: 1.0
        };

        // --- PRE-ALLOCATED REUSABLE OBJECTS ---
        const _tempVec3A = new THREE.Vector3();
        const _tempVec3B = new THREE.Vector3();
        // v5.11: Cinematic camera offset - player higher in frame, more environment visible
        const _camOffset = new THREE.Vector3(0, 38, 32);
        const _camLookOffset = new THREE.Vector3(0, -5, -8); // Look ahead/below player for cinematic framing

        // --- SCREEN EFFECTS ---
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0;
        let originalCameraPos = null;

        function screenShake(intensity = CONFIG.SCREEN_SHAKE_INTENSITY) {
            // v4.6: Check settings
            if (gameData.settings && !gameData.settings.screenShakeEnabled) return;
            screenShakeIntensity = intensity;
            screenShakeDecay = intensity / (CONFIG.SCREEN_SHAKE_DURATION / 16);
            if (!originalCameraPos) originalCameraPos = new THREE.Vector3();
        }

        function updateScreenShake() {
            if (screenShakeIntensity > 0 && mode === 'world') {
                camera.position.x += (Math.random() - 0.5) * screenShakeIntensity;
                camera.position.y += (Math.random() - 0.5) * screenShakeIntensity;
                screenShakeIntensity -= screenShakeDecay;
                if (screenShakeIntensity < 0) screenShakeIntensity = 0;
            }
        }

        // Damage flash overlay
        function flashDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.4';
                setTimeout(() => overlay.style.opacity = '0', 150);
            }
        }

        // v4.1: Create nebula clouds for galaxy atmosphere
        function createNebulae() {
            const nebulaColors = [0xff3366, 0x3366ff, 0x66ff33, 0xff6633, 0x9933ff, 0x33ffff];
            const nebulaCount = 6;

            for (let i = 0; i < nebulaCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Create procedural nebula with radial gradients
                const color = nebulaColors[i % nebulaColors.length];
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;

                // Multiple overlapping gradients for organic look
                for (let j = 0; j < 3; j++) {
                    const cx = 80 + Math.random() * 96;
                    const cy = 80 + Math.random() * 96;
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100 + Math.random() * 56);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.25)`);
                    gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.1)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                }

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    opacity: 0.6
                });

                const geometry = new THREE.PlaneGeometry(600, 600);
                const nebula = new THREE.Mesh(geometry, material);

                // Position nebulae around the galaxy
                const angle = (i / nebulaCount) * Math.PI * 2;
                const dist = 400 + Math.random() * 600;
                nebula.position.set(
                    Math.cos(angle) * dist,
                    (Math.random() - 0.5) * 300,
                    Math.sin(angle) * dist
                );

                // Random rotation
                nebula.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                scene.add(nebula);
            }
        }

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, water: 0x2244aa, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, water: 0x446688, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, water: 0x88aadd, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, water: 0x8800ff, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, water: 0xff4400, name: 'Magma' }
        };

        // v4.2: Enemy Variety System - Biome-specific enemies
        // v4.5: Added attack telegraphing parameters
        const ENEMY_TYPES = {
            Slime: {
                hp: 10, damage: 5, speed: 4, color: 0x44ff44, emissive: 0x003300,
                drops: ['Slime'], xp: 100, biomes: ['Terra', 'Alien'],
                attackWindup: 800, attackRange: 2.5  // v4.5: Telegraph timing
            },
            Scorpion: {
                hp: 15, damage: 8, speed: 5, color: 0xdd9944, emissive: 0x442200,
                drops: ['Chitin'], xp: 150, biomes: ['Desert'],
                attackWindup: 600, attackRange: 3.0
            },
            IceWisp: {
                hp: 8, damage: 6, speed: 7, color: 0x88ccff, emissive: 0x002244,
                drops: ['Frost Shard'], xp: 120, biomes: ['Ice'],
                attackWindup: 500, attackRange: 4.0  // Fast ranged
            },
            MagmaCore: {
                hp: 20, damage: 10, speed: 3, color: 0xff4400, emissive: 0x440000,
                drops: ['Magma Gem'], xp: 180, biomes: ['Volcanic'],
                attackWindup: 1200, attackRange: 3.5  // Slow heavy
            },
            VoidSpawn: {
                hp: 25, damage: 12, speed: 5, color: 0x8800ff, emissive: 0x220044,
                drops: ['Void Fragment'], xp: 250, biomes: ['Alien'],
                attackWindup: 700, attackRange: 3.0
            },
            // v5.12: Hypnotist - Special enemy that takes control of the player
            Hypnotist: {
                hp: 35, damage: 8, speed: 2, color: 0xff00ff, emissive: 0x660066,
                drops: ['Void Fragment', 'Psychic Shard'], xp: 400, biomes: ['Alien', 'Volcanic'],
                attackWindup: 2000, attackRange: 15.0,  // Long range hypnosis
                isHypnotist: true,
                hypnosisRange: 12,
                hypnosisDuration: 8000,
                hypnosisCooldown: 15000
            }
        };

        // v4.6: Elemental Status Effects System
        const STATUS_EFFECTS = {
            ice: {
                name: 'Frozen',
                duration: 3000,
                color: 0x88ccff,
                icon: 'â„ï¸',
                speedMod: 0.3  // Slows to 30% speed
            },
            fire: {
                name: 'Burning',
                duration: 4000,
                color: 0xff4400,
                icon: 'ðŸ”¥',
                tickRate: 500,
                tickDamage: 2
            },
            void: {
                name: 'Weakened',
                duration: 5000,
                color: 0x8800ff,
                icon: 'ðŸ’œ',
                damageMod: 0.5  // Enemy deals 50% damage
            },
            cosmic: {
                name: 'Annihilated',
                duration: 3000,
                color: 0xffd700,
                icon: 'âœ¨',
                tickRate: 250,
                tickDamage: 5,
                speedMod: 0.5
            }
        };

        // ============================================
        // v5.12: HYPNOTIST SYSTEM
        // Eye animation, trance effects, and break-free mechanics
        // ============================================
        const HYPNOSIS_STATE = {
            active: false,
            hypnotistMob: null,
            startTime: 0,
            duration: 0,
            spiralAngle: 0,
            eyePhase: 0,
            breakAttempts: 0,
            maxBreakAttempts: 3,
            breakDamage: 25,
            tranceOverlay: null,
            spiralRings: [],
            companionEyeOffset: { x: 0, y: 0 }
        };

        // Eye animation patterns for hypnosis
        const HYPNO_EYE_PATTERNS = [
            { name: 'spiral', fn: (t) => ({ x: Math.cos(t * 3) * 0.3, y: Math.sin(t * 3) * 0.15 }) },
            { name: 'figure8', fn: (t) => ({ x: Math.sin(t * 2) * 0.4, y: Math.sin(t * 4) * 0.2 }) },
            { name: 'pendulum', fn: (t) => ({ x: Math.sin(t * 2.5) * 0.5, y: 0 }) },
            { name: 'erratic', fn: (t) => ({ x: Math.sin(t * 7) * 0.3 + Math.cos(t * 11) * 0.2, y: Math.cos(t * 5) * 0.2 }) }
        ];

        let hypnoVisualGroup = null;
        let hypnoEyePattern = 0;

        // Initialize hypnosis visual effects
        function initHypnosisEffects() {
            // Create overlay for trance effect
            const overlay = document.createElement('div');
            overlay.id = 'hypnosis-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                pointer-events: none; z-index: 48;
                background: radial-gradient(ellipse at center,
                    transparent 20%,
                    rgba(138, 43, 226, 0.1) 40%,
                    rgba(255, 0, 255, 0.2) 60%,
                    rgba(138, 43, 226, 0.4) 100%);
                opacity: 0;
                transition: opacity 0.5s;
            `;
            document.body.appendChild(overlay);
            HYPNOSIS_STATE.tranceOverlay = overlay;

            // Create spiral rings container in 3D
            hypnoVisualGroup = new THREE.Group();
        }

        // Start hypnosis effect on player
        function startHypnosis(hypnotistMob, duration = 8000) {
            if (HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.active = true;
            HYPNOSIS_STATE.hypnotistMob = hypnotistMob;
            HYPNOSIS_STATE.startTime = performance.now();
            HYPNOSIS_STATE.duration = duration;
            HYPNOSIS_STATE.spiralAngle = 0;
            HYPNOSIS_STATE.eyePhase = 0;
            HYPNOSIS_STATE.breakAttempts = 0;

            // Random eye pattern
            hypnoEyePattern = Math.floor(Math.random() * HYPNO_EYE_PATTERNS.length);

            // Show overlay
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.opacity = '1';
            }

            // Create 3D spiral rings around player
            createHypnoSpirals();

            // Show UI notification
            showHypnosisUI();

            // Notification
            if (typeof showNotification === 'function') {
                showNotification('ðŸ‘ï¸ You are being hypnotized! Press SPACE rapidly to break free!', 'warning');
            }

            console.log('Hypnosis started - break free with SPACE!');
        }

        // Create swirling spiral rings effect
        function createHypnoSpirals() {
            if (!scene || !worldState.player) return;

            // Clear existing
            HYPNOSIS_STATE.spiralRings.forEach(ring => {
                if (ring.parent) ring.parent.remove(ring);
                ring.geometry?.dispose();
                ring.material?.dispose();
            });
            HYPNOSIS_STATE.spiralRings = [];

            // Create multiple concentric spiral rings
            for (let i = 0; i < 5; i++) {
                const radius = 3 + i * 2;
                const ringGeo = new THREE.TorusGeometry(radius, 0.15, 8, 64);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0xff00ff : 0x8a2be2,
                    transparent: true,
                    opacity: 0.6 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 1 + i * 0.5;
                ring.userData.baseY = ring.position.y;
                ring.userData.index = i;

                scene.add(ring);
                HYPNOSIS_STATE.spiralRings.push(ring);
            }
        }

        // Update hypnosis effects each frame
        function updateHypnosis(dt) {
            if (!HYPNOSIS_STATE.active) return;

            const elapsed = performance.now() - HYPNOSIS_STATE.startTime;
            const progress = elapsed / HYPNOSIS_STATE.duration;

            // Check if hypnosis ended naturally
            if (progress >= 1) {
                endHypnosis(false);
                return;
            }

            // Update spiral angle
            HYPNOSIS_STATE.spiralAngle += dt * 2;
            HYPNOSIS_STATE.eyePhase += dt;

            // Move spiral rings around player
            if (worldState.player) {
                const playerPos = worldState.player.position;

                HYPNOSIS_STATE.spiralRings.forEach((ring, i) => {
                    ring.position.x = playerPos.x;
                    ring.position.z = playerPos.z;
                    ring.position.y = playerPos.y + ring.userData.baseY + Math.sin(HYPNOSIS_STATE.spiralAngle + i) * 0.5;
                    ring.rotation.z = HYPNOSIS_STATE.spiralAngle * (i % 2 === 0 ? 1 : -1) * 0.5;

                    // Pulsing opacity
                    ring.material.opacity = (0.4 + Math.sin(HYPNOSIS_STATE.spiralAngle * 2 + i) * 0.2) * (1 - progress * 0.3);
                });
            }

            // Update companion eye animation
            updateHypnoEyeAnimation();

            // Move player in trance pattern (toward hypnotist slowly)
            if (worldState.player && HYPNOSIS_STATE.hypnotistMob && !autopilotEnabled) {
                const hypnotistPos = HYPNOSIS_STATE.hypnotistMob.position;
                const playerPos = worldState.player.position;

                // Spiral movement toward hypnotist
                const angle = HYPNOSIS_STATE.spiralAngle * 0.3;
                const spiralRadius = 2 + Math.sin(HYPNOSIS_STATE.spiralAngle * 0.5) * 1;

                const targetX = hypnotistPos.x + Math.cos(angle) * spiralRadius;
                const targetZ = hypnotistPos.z + Math.sin(angle) * spiralRadius;

                // Very slow drift toward hypnotist
                playerPos.x += (targetX - playerPos.x) * dt * 0.3;
                playerPos.z += (targetZ - playerPos.z) * dt * 0.3;
            }

            // Overlay pulsing
            if (HYPNOSIS_STATE.tranceOverlay) {
                const pulse = 0.7 + Math.sin(HYPNOSIS_STATE.spiralAngle * 3) * 0.3;
                HYPNOSIS_STATE.tranceOverlay.style.opacity = pulse.toString();
            }
        }

        // Update the "eye" animation on the companion orb
        function updateHypnoEyeAnimation() {
            if (!copilotMesh || !HYPNOSIS_STATE.active) return;

            const pattern = HYPNO_EYE_PATTERNS[hypnoEyePattern];
            const offset = pattern.fn(HYPNOSIS_STATE.eyePhase);

            HYPNOSIS_STATE.companionEyeOffset = offset;

            // Move the companion's inner orb to create "eye looking around" effect
            const orb = copilotMesh.userData?.orb;
            const core = copilotMesh.userData?.core;

            if (orb) {
                orb.position.x = offset.x;
                orb.position.y = offset.y;
            }
            if (core) {
                core.position.x = offset.x * 0.5;
                core.position.y = offset.y * 0.5;
            }

            // Also make the companion face the hypnotist
            if (HYPNOSIS_STATE.hypnotistMob) {
                copilotMesh.lookAt(HYPNOSIS_STATE.hypnotistMob.position);
            }
        }

        // Show hypnosis UI
        function showHypnosisUI() {
            // Create or show the break-free UI
            let hypnoUI = document.getElementById('hypnosis-ui');
            if (!hypnoUI) {
                hypnoUI = document.createElement('div');
                hypnoUI.id = 'hypnosis-ui';
                hypnoUI.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    border: 3px solid #ff00ff;
                    border-radius: 15px;
                    padding: 20px 40px;
                    color: #fff;
                    font-family: Georgia, serif;
                    text-align: center;
                    z-index: 1005;
                    animation: hypnoPulse 1s ease-in-out infinite;
                `;
                hypnoUI.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 10px;">ðŸ‘ï¸</div>
                    <div style="font-size: 18px; color: #ff00ff; margin-bottom: 15px;">HYPNOTIZED</div>
                    <div style="font-size: 14px; color: #aaa;">Press <span style="color: #0ff; font-weight: bold;">SPACE</span> rapidly to break free!</div>
                    <div style="margin-top: 15px;">
                        <div id="hypno-break-bar" style="width: 200px; height: 10px; background: #333; border-radius: 5px; overflow: hidden;">
                            <div id="hypno-break-fill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff00ff, #0ff); transition: width 0.1s;"></div>
                        </div>
                        <div id="hypno-break-text" style="font-size: 12px; color: #888; margin-top: 5px;">0 / ${HYPNOSIS_STATE.maxBreakAttempts}</div>
                    </div>
                `;
                document.body.appendChild(hypnoUI);

                // Add pulse animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes hypnoPulse {
                        0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); transform: translate(-50%, -50%) scale(1); }
                        50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.8); transform: translate(-50%, -50%) scale(1.02); }
                    }
                `;
                document.head.appendChild(style);
            }
            hypnoUI.style.display = 'block';
        }

        // Handle break attempt (called when player presses SPACE during hypnosis)
        function attemptBreakHypnosis() {
            if (!HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.breakAttempts++;

            // Update UI
            const fill = document.getElementById('hypno-break-fill');
            const text = document.getElementById('hypno-break-text');
            if (fill) {
                fill.style.width = (HYPNOSIS_STATE.breakAttempts / HYPNOSIS_STATE.maxBreakAttempts * 100) + '%';
            }
            if (text) {
                text.textContent = `${HYPNOSIS_STATE.breakAttempts} / ${HYPNOSIS_STATE.maxBreakAttempts}`;
            }

            // Screen flash on attempt
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,255,255,0.3) 0%, rgba(138,43,226,0.4) 100%)';
                setTimeout(() => {
                    if (HYPNOSIS_STATE.tranceOverlay) {
                        HYPNOSIS_STATE.tranceOverlay.style.background = 'radial-gradient(ellipse at center, transparent 20%, rgba(138, 43, 226, 0.1) 40%, rgba(255, 0, 255, 0.2) 60%, rgba(138, 43, 226, 0.4) 100%)';
                    }
                }, 100);
            }

            // Check if broken free
            if (HYPNOSIS_STATE.breakAttempts >= HYPNOSIS_STATE.maxBreakAttempts) {
                endHypnosis(true);
            }
        }

        // End hypnosis effect
        function endHypnosis(brokeFreeBySelf) {
            if (!HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.active = false;

            // Hide overlay
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.opacity = '0';
            }

            // Remove spiral rings
            HYPNOSIS_STATE.spiralRings.forEach(ring => {
                if (ring.parent) ring.parent.remove(ring);
                ring.geometry?.dispose();
                ring.material?.dispose();
            });
            HYPNOSIS_STATE.spiralRings = [];

            // Reset companion eye position
            if (copilotMesh) {
                const orb = copilotMesh.userData?.orb;
                const core = copilotMesh.userData?.core;
                if (orb) { orb.position.x = 0; orb.position.y = 0; }
                if (core) { core.position.x = 0; core.position.y = 0; }
            }

            // Hide UI
            const hypnoUI = document.getElementById('hypnosis-ui');
            if (hypnoUI) hypnoUI.style.display = 'none';

            // If broke free, damage the hypnotist!
            if (brokeFreeBySelf && HYPNOSIS_STATE.hypnotistMob) {
                const damage = HYPNOSIS_STATE.breakDamage;
                HYPNOSIS_STATE.hypnotistMob.userData.hp -= damage;

                // Show damage effect
                if (typeof createDamageNumber === 'function') {
                    createDamageNumber(HYPNOSIS_STATE.hypnotistMob.position.clone(), damage, 0x00ffff);
                }

                // Notification
                if (typeof showNotification === 'function') {
                    showNotification(`ðŸ”® You broke free! Dealt ${damage} psychic damage to the Hypnotist!`, 'success');
                }

                // Screen shake
                if (typeof screenShake === 'function') {
                    screenShake(0.5);
                }

                // Check if hypnotist died
                if (HYPNOSIS_STATE.hypnotistMob.userData.hp <= 0) {
                    // Handle death
                    const xpReward = HYPNOSIS_STATE.hypnotistMob.userData.xpReward || 400;
                    if (typeof addXp === 'function') addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;

                    if (typeof showNotification === 'function') {
                        showNotification('ðŸ‘ï¸ Hypnotist defeated by psychic backlash!', 'success');
                    }

                    // Remove from scene
                    if (HYPNOSIS_STATE.hypnotistMob.parent) {
                        scene.remove(HYPNOSIS_STATE.hypnotistMob);
                    }
                    const idx = worldState.mobs.indexOf(HYPNOSIS_STATE.hypnotistMob);
                    if (idx > -1) worldState.mobs.splice(idx, 1);
                }
            } else if (!brokeFreeBySelf) {
                // Hypnosis wore off naturally - player takes some damage
                if (worldState.player) {
                    const damage = 10;
                    gameData.hp = Math.max(1, gameData.hp - damage);
                    if (typeof updateHealthUI === 'function') updateHealthUI();
                    if (typeof showNotification === 'function') {
                        showNotification('ðŸ‘ï¸ Hypnosis wore off. You feel drained...', 'warning');
                    }
                }
            }

            HYPNOSIS_STATE.hypnotistMob = null;
        }

        // v4.7: Elite Enemy System - Affixes that modify enemy behavior
        const ELITE_AFFIXES = {
            swift: {
                name: 'Swift',
                prefix: 'âš¡',
                color: 0x00ffff,
                speedMult: 1.8,
                hpMult: 1.2,
                damageMult: 1.0,
                description: 'Moves much faster'
            },
            armored: {
                name: 'Armored',
                prefix: 'ðŸ›¡ï¸',
                color: 0x888888,
                speedMult: 0.8,
                hpMult: 3.0,
                damageMult: 1.0,
                description: 'Extremely tough'
            },
            vampiric: {
                name: 'Vampiric',
                prefix: 'ðŸ¦‡',
                color: 0x990000,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 1.2,
                lifesteal: 0.3,
                description: 'Heals on hit'
            },
            explosive: {
                name: 'Explosive',
                prefix: 'ðŸ’¥',
                color: 0xff6600,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 0.8,
                explodeOnDeath: true,
                description: 'Explodes on death'
            },
            berserker: {
                name: 'Berserker',
                prefix: 'ðŸ˜¤',
                color: 0xff0000,
                speedMult: 1.2,
                hpMult: 1.0,
                damageMult: 2.0,
                description: 'Deals double damage'
            },
            regenerating: {
                name: 'Regenerating',
                prefix: 'ðŸ’š',
                color: 0x00ff00,
                speedMult: 1.0,
                hpMult: 1.8,
                damageMult: 1.0,
                regenRate: 0.02,
                description: 'Regenerates health'
            },
            teleporter: {
                name: 'Teleporter',
                prefix: 'ðŸŒ€',
                color: 0x9900ff,
                speedMult: 0.9,
                hpMult: 1.3,
                damageMult: 1.3,
                canTeleport: true,
                description: 'Blinks around'
            },
            frozen: {
                name: 'Frozen',
                prefix: 'â„ï¸',
                color: 0x88ddff,
                speedMult: 0.7,
                hpMult: 2.0,
                damageMult: 1.1,
                chillingAura: true,
                description: 'Slows nearby player'
            }
        };

        const ELITE_CONFIG = {
            spawnChance: 0.15,        // 15% chance for elite
            minWorldLevel: 2,         // Only spawn in world level 2+
            essenceDropChance: 0.8,   // 80% chance to drop elite essence
            bonusXpMult: 2.5,         // 2.5x XP from elites
            bonusDropMult: 2          // Double drops from elites
        };

        // v4.7: Session Rewards - Welcome back bonuses
        const SESSION_REWARDS = {
            tiers: [
                { minHours: 1, xpBonus: 50, resources: { 'Slime': 2 }, message: 'Quick break bonus!' },
                { minHours: 4, xpBonus: 150, resources: { 'Ore': 3, 'Log': 3 }, message: 'Gone a while bonus!' },
                { minHours: 12, xpBonus: 400, resources: { 'Ore': 8, 'Log': 8, 'Health Potion': 2 }, message: 'Half-day bonus!' },
                { minHours: 24, xpBonus: 1000, resources: { 'Crystal': 2, 'Mystic Orb': 1, 'Health Potion': 3 }, message: 'Daily login bonus!' },
                { minHours: 72, xpBonus: 3000, resources: { 'Elite Essence': 5, 'Legendary Core': 1, 'Super Potion': 2 }, message: 'We missed you bonus!' }
            ],
            maxOfflineHours: 168 // Cap at 1 week
        };

        // v4.6: Get equipped weapon element
        function getEquippedElement() {
            const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade'];
            for (const weapon of weapons) {
                if (hasItem(weapon)) {
                    return ITEMS[weapon].element || null;
                }
            }
            return null;
        }

        // v4.6: Apply status effect to mob
        function applyStatusEffect(mob, element) {
            const effect = STATUS_EFFECTS[element];
            if (!effect) return;

            const data = mob.userData;
            data.statusEffects = data.statusEffects || {};

            // Only apply if not already affected by this element
            if (data.statusEffects[element]) return;

            data.statusEffects[element] = {
                endTime: performance.now() + effect.duration,
                lastTick: performance.now()
            };

            // Apply immediate effects
            if (effect.speedMod) {
                data.speedMultiplier = (data.speedMultiplier || 1) * effect.speedMod;
            }
            if (effect.damageMod) {
                data.damageMultiplier = (data.damageMultiplier || 1) * effect.damageMod;
            }

            // Visual feedback
            mob.material.emissive.setHex(effect.color);
            spawnFloater(mob.position, effect.icon + ' ' + effect.name, '#' + effect.color.toString(16).padStart(6, '0'));
            AudioSystem.hit();
        }

        // v4.6: Update status effects for mob
        function updateMobStatusEffects(mob, time) {
            const data = mob.userData;
            if (!data.statusEffects) return;

            for (const [element, state] of Object.entries(data.statusEffects)) {
                const effect = STATUS_EFFECTS[element];
                if (!effect) continue;

                // Apply DoT
                if (effect.tickDamage && time - state.lastTick >= effect.tickRate) {
                    data.hp -= effect.tickDamage;
                    state.lastTick = time;
                    spawnFloater(mob.position, `-${effect.tickDamage}`, '#' + effect.color.toString(16).padStart(6, '0'));

                    // Check for death by status effect
                    if (data.hp <= 0) {
                        // Will be handled in main mob loop
                    }
                }

                // Check expiration
                if (time >= state.endTime) {
                    // Clear effects
                    if (effect.speedMod) {
                        data.speedMultiplier = (data.speedMultiplier || 1) / effect.speedMod;
                    }
                    if (effect.damageMod) {
                        data.damageMultiplier = (data.damageMultiplier || 1) / effect.damageMod;
                    }
                    delete data.statusEffects[element];

                    // Restore emissive color if no more effects
                    if (Object.keys(data.statusEffects).length === 0) {
                        const originalEmissive = ENEMY_TYPES[data.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }
            }
        }

        // v4.3: Boss Encounter System
        // v4.5: Added gear check requirements and increased mob kill thresholds
        const BOSS_TYPES = {
            'Terra_Boss': {
                name: 'Ancient Guardian',
                hp: 100, damage: 15, speed: 2, scale: 2.5,
                color: 0x228b22, emissive: 0x114411,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Ancient Artifact', count: 3 }],
                xp: 1000, biome: 'Terra',
                spawnCondition: { mobsKilled: 8, minCombatLevel: 2 },
                attackWindup: 1000, attackRange: 4
            },
            'Desert_Boss': {
                name: 'Sandstorm Titan',
                hp: 120, damage: 18, speed: 3, scale: 2.8,
                color: 0xcc8844, emissive: 0x664422,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Chitin', count: 10 }],
                xp: 1200, biome: 'Desert',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 3, requiredItem: 'Sword' },
                attackWindup: 900, attackRange: 4.5
            },
            'Ice_Boss': {
                name: 'Frost Monarch',
                hp: 90, damage: 20, speed: 4, scale: 2.2,
                color: 0x88ddff, emissive: 0x4488aa,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Frost Shard', count: 10 }],
                xp: 1100, biome: 'Ice',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 4 },
                attackWindup: 700, attackRange: 5
            },
            'Volcanic_Boss': {
                name: 'Magma Colossus',
                hp: 150, damage: 25, speed: 1.5, scale: 3,
                color: 0xff4400, emissive: 0xaa2200,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Magma Gem', count: 10 }],
                xp: 1500, biome: 'Volcanic',
                spawnCondition: { mobsKilled: 12, minCombatLevel: 5, requiredItem: 'Frost Blade' },
                attackWindup: 1500, attackRange: 5
            },
            'Alien_Boss': {
                name: 'Void Leviathan',
                hp: 200, damage: 30, speed: 3, scale: 3.5,
                color: 0x8800ff, emissive: 0x440088,
                drops: [{ item: 'Boss Trophy', count: 2 }, { item: 'Void Fragment', count: 15 }, { item: 'Legendary Core', count: 1 }],
                xp: 2500, biome: 'Alien',
                spawnCondition: { mobsKilled: 15, minCombatLevel: 7, requiredItem: 'Magma Sword' },
                attackWindup: 800, attackRange: 6
            }
        };

        // v4.2: Points of Interest System
        const POI_TYPES = {
            'ancient_ruins': {
                name: 'Ancient Ruins', icon: 'ðŸ›ï¸', rarity: 0.12,
                rewards: [{ item: 'Ancient Artifact', count: 1 }],
                xpBonus: 200, biomes: null
            },
            'crystal_cave': {
                name: 'Crystal Cavern', icon: 'ðŸ’Ž', rarity: 0.10,
                rewards: [{ item: 'Crystal', count: [2, 5] }],
                xpBonus: 150, biomes: ['Ice', 'Alien']
            },
            'oasis': {
                name: 'Hidden Oasis', icon: 'ðŸŒ´', rarity: 0.15,
                rewards: [{ item: 'Healing Spring', count: 1 }],
                xpBonus: 100, biomes: ['Desert']
            },
            'volcano_vent': {
                name: 'Volcanic Vent', icon: 'ðŸŒ‹', rarity: 0.12,
                rewards: [{ item: 'Obsidian', count: [1, 3] }],
                xpBonus: 175, biomes: ['Volcanic']
            },
            'crashed_ship': {
                name: 'Crashed Vessel', icon: 'ðŸ›¸', rarity: 0.06,
                rewards: [{ item: 'Tech Fragment', count: 1 }, { item: 'Power Cell', count: 1 }],
                xpBonus: 300, biomes: null
            },
            'mystic_shrine': {
                name: 'Mystic Shrine', icon: 'â›©ï¸', rarity: 0.08,
                rewards: [{ item: 'Mystic Orb', count: 1 }],
                xpBonus: 250, biomes: ['Terra', 'Alien']
            }
        };

        // v4.2: Player Ranks and Titles
        const PLAYER_RANKS = [
            { points: 0, title: 'Novice Explorer', color: '#888888' },
            { points: 100, title: 'Wanderer', color: '#44ff44' },
            { points: 500, title: 'Pathfinder', color: '#4488ff' },
            { points: 1500, title: 'Star Scout', color: '#ff8844' },
            { points: 5000, title: 'Galaxy Ranger', color: '#ff44ff' },
            { points: 15000, title: 'Cosmic Legend', color: '#ffd700' }
        ];

        const SPECIAL_TITLES = {
            'Slime Bane': { condition: (s, sk) => s.mobsKilled >= 100, color: '#ff4444' },
            'Master Lumberjack': { condition: (s, sk) => sk.wood.level >= 10, color: '#44aa44' },
            'Deep Miner': { condition: (s, sk) => sk.mining.level >= 10, color: '#888888' },
            'Cosmic Wanderer': { condition: (s, sk) => gameData.visitedPlanets.length >= 50, color: '#00ffff' },
            'Combat Master': { condition: (s, sk) => sk.combat.level >= 10, color: '#ff6644' },
            'Master Angler': { condition: (s, sk) => sk.fishing.level >= 10, color: '#4488ff' }
        };

        const ITEMS = {
            // Base resources
            'Log': { icon: 'ðŸªµ', stackable: true, maxStack: 99 },
            'Ore': { icon: 'ðŸª¨', stackable: true, maxStack: 99 },
            'Slime': { icon: 'ðŸŸ¢', stackable: true, maxStack: 99 },
            'Raw Fish': { icon: 'ðŸŸ', stackable: true, maxStack: 99 },
            'Cooked Fish': { icon: 'ðŸ–', stackable: true, maxStack: 99, heal: 20 },
            // v4.2: Biome-specific enemy drops
            'Chitin': { icon: 'ðŸ¦‚', stackable: true, maxStack: 99 },
            'Frost Shard': { icon: 'â„ï¸', stackable: true, maxStack: 99 },
            'Magma Gem': { icon: 'ðŸ”¥', stackable: true, maxStack: 99 },
            'Void Fragment': { icon: 'ðŸŒ€', stackable: true, maxStack: 99 },
            // v4.2: POI rewards
            'Ancient Artifact': { icon: 'ðŸº', stackable: true, maxStack: 20 },
            'Crystal': { icon: 'ðŸ’ ', stackable: true, maxStack: 50 },
            'Healing Spring': { icon: 'ðŸ’§', stackable: true, maxStack: 10, heal: 100 },
            'Obsidian': { icon: 'ðŸ–¤', stackable: true, maxStack: 50 },
            'Tech Fragment': { icon: 'ðŸ”§', stackable: true, maxStack: 20 },
            'Power Cell': { icon: 'ðŸ”‹', stackable: true, maxStack: 10 },
            'Mystic Orb': { icon: 'ðŸ”®', stackable: true, maxStack: 10 },
            // Tools
            'Pickaxe': { icon: 'â›ï¸', stackable: false, miningBonus: 2 },
            'Sword': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 5 },
            'Fishing Rod': { icon: 'ðŸŽ£', stackable: false, fishingBonus: 2 },
            'Health Potion': { icon: 'ðŸ§ª', stackable: true, maxStack: 10, heal: 50 },
            // v4.2: New craftables
            'Frost Blade': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 8, element: 'ice' },
            'Magma Sword': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 10, element: 'fire' },
            'Void Dagger': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 12, element: 'void' },
            'Crystal Pickaxe': { icon: 'â›ï¸', stackable: false, miningBonus: 3 },
            'Super Potion': { icon: 'ðŸ§ª', stackable: true, maxStack: 10, heal: 100 },
            'Chitin Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 5 },
            // v4.3: Boss rewards
            'Boss Trophy': { icon: 'ðŸ†', stackable: true, maxStack: 20 },
            'Legendary Core': { icon: 'ðŸ’Ž', stackable: true, maxStack: 5 },
            // v4.3: Legendary gear (requires boss materials)
            'Legendary Blade': { icon: 'âš”ï¸', stackable: false, combatBonus: 20, element: 'cosmic' },
            'Guardian Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 15 },
            // v4.7: Elite enemy drops
            'Elite Essence': { icon: 'ðŸ’ ', stackable: true, maxStack: 99 },
            'Berserker Badge': { icon: 'ðŸ”´', stackable: false, combatBonus: 15, attackSpeedMult: 1.3 },
            'Vampiric Fang': { icon: 'ðŸ¦·', stackable: false, combatBonus: 10, lifesteal: 0.15 },
            'Frost Heart': { icon: 'ðŸ’™', stackable: false, defenseBonus: 10, element: 'ice' },
            // v5.1: New craftable equipment
            'Iron Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 3 },
            'Steel Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 8 },
            'Lucky Charm': { icon: 'ðŸ€', stackable: false },
            'Swift Boots': { icon: 'ðŸ‘¢', stackable: false },
            'Power Ring': { icon: 'ðŸ’', stackable: false },
            'Master Rod': { icon: 'ðŸŽ£', stackable: false, fishingBonus: 4 },
            // v5.1: Enchantment materials
            'Enchant Shard': { icon: 'âœ¨', stackable: true, maxStack: 50 },
            'Arcane Dust': { icon: 'ðŸ’«', stackable: true, maxStack: 99 },
            // v5.3: Portal realm rewards
            'Shadow Essence': { icon: 'ðŸŒ‘', stackable: true, maxStack: 50 },
            'Dark Crystal': { icon: 'ðŸ”®', stackable: true, maxStack: 30 },
            'Frozen Heart': { icon: 'ðŸ’™', stackable: true, maxStack: 30 },
            'Permafrost Shard': { icon: 'â„ï¸', stackable: true, maxStack: 50 },
            'Infernal Core': { icon: 'ðŸ”¥', stackable: true, maxStack: 30 },
            'Magma Heart': { icon: 'â¤ï¸â€ðŸ”¥', stackable: true, maxStack: 30 },
            'Void Core': { icon: 'ðŸŒ€', stackable: true, maxStack: 20 },
            'Dimension Shard': { icon: 'ðŸ’ ', stackable: true, maxStack: 30 },
            'Celestial Essence': { icon: 'âœ¨', stackable: true, maxStack: 10 },
            'Star Fragment': { icon: 'â­', stackable: true, maxStack: 20 },
            'Mythic Orb': { icon: 'ðŸ”®', stackable: false, combatBonus: 25, element: 'cosmic', defenseBonus: 10 },
            // v5.4: World Event items
            'Meteor Ore': { icon: 'â˜„ï¸', stackable: true, maxStack: 30, description: 'Rare ore from a meteor shower' },
            'Cosmic Dust': { icon: 'ðŸŒŸ', stackable: true, maxStack: 99, description: 'Glittering cosmic particles' },
            'Gold Chest': { icon: 'ðŸ“¦', stackable: true, maxStack: 10, description: 'A treasure chest filled with gold' },
            'Silver Chest': { icon: 'ðŸ“¦', stackable: true, maxStack: 20, description: 'A treasure chest with silver' },
            'Ancient Relic': { icon: 'ðŸ—¿', stackable: true, maxStack: 10, description: 'An ancient relic of power' },
            'Rune Stone': { icon: 'ðŸª¨', stackable: true, maxStack: 20, description: 'Stone inscribed with ancient runes' },
            'Lost Technology': { icon: 'ðŸ”§', stackable: true, maxStack: 10, description: 'Advanced technology from a lost civilization' },
            'Rainbow Crystal': { icon: 'ðŸ’Ž', stackable: true, maxStack: 15, description: 'A crystal that shimmers with all colors' },
            'Pure Crystal': { icon: 'ðŸ’ ', stackable: true, maxStack: 20, description: 'A perfectly pure crystal' },
            'Crystal Shard': { icon: 'ðŸ”¹', stackable: true, maxStack: 50, description: 'A small crystal fragment' }
        };

        const RECIPES = {
            'pickaxe': { result: 'Pickaxe', requires: { 'Ore': 3, 'Log': 2 } },
            'sword': { result: 'Sword', requires: { 'Ore': 5, 'Log': 1 } },
            'rod': { result: 'Fishing Rod', requires: { 'Log': 2 } },
            'cookedFish': { result: 'Cooked Fish', requires: { 'Raw Fish': 1 } },
            'potion': { result: 'Health Potion', requires: { 'Slime': 2 } },
            // v4.2: New recipes using biome materials
            'frostBlade': { result: 'Frost Blade', requires: { 'Ore': 8, 'Frost Shard': 5 }, craftingLevel: 5 },
            'magmaSword': { result: 'Magma Sword', requires: { 'Ore': 10, 'Magma Gem': 5 }, craftingLevel: 7 },
            'voidDagger': { result: 'Void Dagger', requires: { 'Ore': 12, 'Void Fragment': 5 }, craftingLevel: 10 },
            'crystalPickaxe': { result: 'Crystal Pickaxe', requires: { 'Ore': 6, 'Crystal': 3 }, craftingLevel: 6 },
            'superPotion': { result: 'Super Potion', requires: { 'Slime': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'chitinArmor': { result: 'Chitin Armor', requires: { 'Chitin': 10, 'Log': 5 }, craftingLevel: 4 },
            // v4.3: Legendary recipes (requires boss materials)
            'legendaryBlade': { result: 'Legendary Blade', requires: { 'Boss Trophy': 5, 'Legendary Core': 1, 'Ore': 20 }, craftingLevel: 15 },
            'guardianArmor': { result: 'Guardian Armor', requires: { 'Boss Trophy': 3, 'Chitin': 20, 'Crystal': 5 }, craftingLevel: 12 },
            // v4.7: Elite gear recipes
            'berserkerBadge': { result: 'Berserker Badge', requires: { 'Elite Essence': 10, 'Magma Gem': 3 }, craftingLevel: 10 },
            'vampiricFang': { result: 'Vampiric Fang', requires: { 'Elite Essence': 15, 'Void Fragment': 5 }, craftingLevel: 12 },
            'frostHeart': { result: 'Frost Heart', requires: { 'Elite Essence': 12, 'Frost Shard': 8, 'Crystal': 3 }, craftingLevel: 11 },
            // v5.1: New equipment recipes
            'ironArmor': { result: 'Iron Armor', requires: { 'Ore': 8, 'Log': 3 }, craftingLevel: 2 },
            'steelArmor': { result: 'Steel Armor', requires: { 'Ore': 15, 'Crystal': 2 }, craftingLevel: 8 },
            'luckyCharm': { result: 'Lucky Charm', requires: { 'Crystal': 5, 'Mystic Orb': 2 }, craftingLevel: 6 },
            'swiftBoots': { result: 'Swift Boots', requires: { 'Chitin': 8, 'Slime': 5 }, craftingLevel: 5 },
            'powerRing': { result: 'Power Ring', requires: { 'Ore': 10, 'Magma Gem': 3 }, craftingLevel: 7 },
            'masterRod': { result: 'Master Rod', requires: { 'Log': 10, 'Crystal': 3, 'Frost Shard': 2 }, craftingLevel: 9 },
            // v5.1: Enchantment material crafting
            'enchantShard': { result: 'Enchant Shard', requires: { 'Crystal': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'arcaneDust': { result: 'Arcane Dust', requires: { 'Slime': 5, 'Void Fragment': 1 }, craftingLevel: 6 }
        };

        // v5.1: Equipment System
        const EQUIPMENT_SLOTS = {
            weapon: { name: 'Weapon', icon: 'âš”ï¸', statKey: 'combatBonus' },
            armor: { name: 'Armor', icon: 'ðŸ›¡ï¸', statKey: 'defenseBonus' },
            accessory: { name: 'Accessory', icon: 'ðŸ’', statKey: 'special' },
            tool: { name: 'Tool', icon: 'ðŸ”§', statKey: 'toolBonus' }
        };

        // v5.1: Map items to equipment slots
        const EQUIPMENT_MAP = {
            // Weapons
            'Sword': { slot: 'weapon', stats: { damage: 5 } },
            'Frost Blade': { slot: 'weapon', stats: { damage: 8, element: 'ice' } },
            'Magma Sword': { slot: 'weapon', stats: { damage: 10, element: 'fire' } },
            'Void Dagger': { slot: 'weapon', stats: { damage: 12, element: 'void' } },
            'Legendary Blade': { slot: 'weapon', stats: { damage: 20, element: 'cosmic', critChance: 0.15 } },
            // Armor (tiered)
            'Iron Armor': { slot: 'armor', stats: { defense: 3 } },
            'Chitin Armor': { slot: 'armor', stats: { defense: 5 } },
            'Steel Armor': { slot: 'armor', stats: { defense: 8 } },
            'Guardian Armor': { slot: 'armor', stats: { defense: 15, maxHpBonus: 50 } },
            // Accessories
            'Berserker Badge': { slot: 'accessory', stats: { damage: 15, attackSpeed: 1.3 } },
            'Vampiric Fang': { slot: 'accessory', stats: { damage: 10, lifesteal: 0.15 } },
            'Frost Heart': { slot: 'accessory', stats: { defense: 10, element: 'ice' } },
            'Lucky Charm': { slot: 'accessory', stats: { critChance: 0.10, lootBonus: 0.15 } },
            'Swift Boots': { slot: 'accessory', stats: { moveSpeed: 1.15, dodgeBonus: 0.1 } },
            'Power Ring': { slot: 'accessory', stats: { damage: 8, critChance: 0.05 } },
            // Tools
            'Pickaxe': { slot: 'tool', stats: { miningBonus: 2 } },
            'Crystal Pickaxe': { slot: 'tool', stats: { miningBonus: 3 } },
            'Fishing Rod': { slot: 'tool', stats: { fishingBonus: 2 } },
            'Master Rod': { slot: 'tool', stats: { fishingBonus: 4 } }
        };

        // v5.1: Equipment state getter (uses gameData for persistence)
        function getEquippedGear() {
            if (!gameData.equipment) {
                gameData.equipment = { weapon: null, armor: null, accessory: null, tool: null };
            }
            return gameData.equipment;
        }

        // v5.1: Equipment functions
        function isEquippable(itemName) {
            return EQUIPMENT_MAP.hasOwnProperty(itemName);
        }

        function getEquipmentSlot(itemName) {
            return EQUIPMENT_MAP[itemName]?.slot || null;
        }

        function equipItem(itemName) {
            if (!isEquippable(itemName)) {
                showNotification('Cannot equip this item!', 'error');
                return false;
            }

            const slot = getEquipmentSlot(itemName);
            const equipData = EQUIPMENT_MAP[itemName];
            const gear = getEquippedGear();

            // Unequip current item in slot (return to inventory)
            if (gear[slot]) {
                addItem(gear[slot]);
                showNotification(`Unequipped ${gear[slot]}`, 'info');
            }

            // Remove from inventory
            if (!removeItem(itemName, 1)) {
                showNotification('Item not in inventory!', 'error');
                return false;
            }

            // Equip new item
            gear[slot] = itemName;
            showNotification(`Equipped ${itemName}!`, 'success');
            AudioSystem.collect();
            updateEquipmentUI();
            saveGameData();
            return true;
        }

        function unequipItem(slot) {
            const gear = getEquippedGear();
            if (!gear[slot]) return;

            const itemName = gear[slot];
            if (gameData.inventory.length >= 20) {
                showNotification('Inventory full!', 'error');
                return;
            }

            addItem(itemName);
            gear[slot] = null;
            showNotification(`Unequipped ${itemName}`, 'info');
            updateEquipmentUI();
            saveGameData();
        }

        function getEquipmentStats() {
            const stats = {
                damage: 0,
                defense: 0,
                miningBonus: 0,
                fishingBonus: 0,
                attackSpeed: 1.0,
                lifesteal: 0,
                critChance: 0,
                maxHpBonus: 0,
                element: null,
                // v5.1: New stats
                moveSpeed: 1.0,
                lootBonus: 0,
                dodgeBonus: 0
            };

            const gear = getEquippedGear();
            for (const slot of Object.keys(gear)) {
                const itemName = gear[slot];
                if (!itemName) continue;

                const equipData = EQUIPMENT_MAP[itemName];
                if (!equipData) continue;

                for (const [stat, value] of Object.entries(equipData.stats)) {
                    if (stat === 'element') {
                        stats.element = value;
                    } else if (stat === 'attackSpeed' || stat === 'moveSpeed') {
                        // Multiplicative stats
                        stats[stat] *= value;
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }

                // v5.1: Add enchantment bonuses
                const enchantBonuses = getEnchantmentBonuses(itemName);
                for (const [stat, value] of Object.entries(enchantBonuses)) {
                    if (stat === 'moveSpeed') {
                        stats[stat] *= value; // Multiplicative for move speed enchants
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }
            }

            return stats;
        }

        function updateEquipmentUI() {
            const gear = getEquippedGear();
            for (const [slot, slotInfo] of Object.entries(EQUIPMENT_SLOTS)) {
                const slotEl = document.getElementById(`equip-slot-${slot}`);
                if (!slotEl) continue;

                const itemName = gear[slot];
                const iconEl = slotEl.querySelector('.equip-icon');
                const nameEl = slotEl.querySelector('.equip-name');

                if (itemName) {
                    const itemDef = ITEMS[itemName];
                    iconEl.textContent = itemDef?.icon || '?';
                    nameEl.textContent = itemName;
                    slotEl.classList.add('equipped');
                } else {
                    iconEl.textContent = slotInfo.icon;
                    nameEl.textContent = 'Empty';
                    slotEl.classList.remove('equipped');
                }
            }

            // Update stats display
            const stats = getEquipmentStats();
            const statsEl = document.getElementById('equipment-stats');
            if (statsEl) {
                let html = `
                    <div style="color: #f44;">âš”ï¸ +${stats.damage} DMG</div>
                    <div style="color: #4af;">ðŸ›¡ï¸ +${stats.defense} DEF</div>
                `;
                if (stats.critChance > 0) html += `<div style="color: #fa4;">ðŸŽ¯ +${Math.round(stats.critChance * 100)}% Crit</div>`;
                if (stats.lifesteal > 0) html += `<div style="color: #4f4;">ðŸ’š ${Math.round(stats.lifesteal * 100)}% Lifesteal</div>`;
                if (stats.attackSpeed !== 1.0) html += `<div style="color: #ff4;">âš¡ ${Math.round(stats.attackSpeed * 100)}% ATK Spd</div>`;
                if (stats.moveSpeed !== 1.0) html += `<div style="color: #8ff;">ðŸ‘¢ ${Math.round(stats.moveSpeed * 100)}% Move Spd</div>`;
                if (stats.lootBonus > 0) html += `<div style="color: #8f8;">ðŸ€ +${Math.round(stats.lootBonus * 100)}% Loot</div>`;
                if (stats.dodgeBonus > 0) html += `<div style="color: #88f;">ðŸ’¨ +${Math.round(stats.dodgeBonus * 100)}% Dodge</div>`;
                statsEl.innerHTML = html;
            }
        }

        // v5.1: Enchantment System
        const ENCHANTMENTS = {
            sharpness: { name: 'Sharpness', icon: 'ðŸ”ª', stat: 'damage', bonus: 3, slots: ['weapon'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            fortify: { name: 'Fortify', icon: 'ðŸ°', stat: 'defense', bonus: 2, slots: ['armor'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            swiftness: { name: 'Swiftness', icon: 'ðŸ’¨', stat: 'moveSpeed', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 1, 'Arcane Dust': 3 }, multiplicative: true },
            luck: { name: 'Luck', icon: 'ðŸ€', stat: 'lootBonus', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 8 } },
            efficiency: { name: 'Efficiency', icon: 'âš¡', stat: 'miningBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            lure: { name: 'Lure', icon: 'ðŸŽ£', stat: 'fishingBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            critical: { name: 'Critical', icon: 'ðŸŽ¯', stat: 'critChance', bonus: 0.05, slots: ['weapon', 'accessory'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 10 } },
            vampiric: { name: 'Vampiric', icon: 'ðŸ¦‡', stat: 'lifesteal', bonus: 0.05, slots: ['weapon'], cost: { 'Enchant Shard': 5, 'Arcane Dust': 15 } }
        };

        // v5.1: Get enchantments for an item
        function getItemEnchantments(itemName) {
            if (!gameData.enchantments) gameData.enchantments = {};
            return gameData.enchantments[itemName] || [];
        }

        // v5.1: Check if enchantment can be applied
        function canEnchant(itemName, enchantId) {
            const equipData = EQUIPMENT_MAP[itemName];
            if (!equipData) return false;

            const enchant = ENCHANTMENTS[enchantId];
            if (!enchant) return false;

            // Check slot compatibility
            if (!enchant.slots.includes(equipData.slot)) return false;

            // Check if already has this enchantment
            const currentEnchants = getItemEnchantments(itemName);
            if (currentEnchants.includes(enchantId)) return false;

            // Check max enchantments (3 per item)
            if (currentEnchants.length >= 3) return false;

            // Check materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                if (!hasItem(mat, count)) return false;
            }

            return true;
        }

        // v5.1: Apply enchantment to item
        function applyEnchantment(itemName, enchantId) {
            if (!canEnchant(itemName, enchantId)) {
                showNotification('Cannot apply this enchantment!', 'error');
                return false;
            }

            const enchant = ENCHANTMENTS[enchantId];

            // Consume materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                removeItem(mat, count);
            }

            // Apply enchantment
            if (!gameData.enchantments) gameData.enchantments = {};
            if (!gameData.enchantments[itemName]) gameData.enchantments[itemName] = [];
            gameData.enchantments[itemName].push(enchantId);

            showNotification(`Applied ${enchant.icon} ${enchant.name} to ${itemName}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateEnchantModal();
            updateEquipmentUI();
            return true;
        }

        // v5.1: Get total stats including enchantments
        function getEnchantmentBonuses(itemName) {
            const bonuses = {};
            const enchants = getItemEnchantments(itemName);

            for (const enchantId of enchants) {
                const enchant = ENCHANTMENTS[enchantId];
                if (!enchant) continue;

                if (enchant.multiplicative) {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 1) * (1 + enchant.bonus);
                } else {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 0) + enchant.bonus;
                }
            }

            return bonuses;
        }

        // v5.1: Show enchant modal
        function showEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'flex';
            updateEnchantModal();
        }

        function closeEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'none';
        }

        function updateEnchantModal() {
            const gear = getEquippedGear();
            const itemsDiv = document.getElementById('enchant-items');
            const enchantsDiv = document.getElementById('enchant-options');

            // List equipped items
            let itemsHtml = '';
            for (const [slot, itemName] of Object.entries(gear)) {
                if (!itemName) continue;
                const itemDef = ITEMS[itemName];
                const enchants = getItemEnchantments(itemName);
                const enchantIcons = enchants.map(e => ENCHANTMENTS[e]?.icon || '?').join('');
                itemsHtml += `
                    <div class="enchant-item" onclick="selectEnchantItem('${itemName}')" data-item="${itemName}"
                         style="display: flex; justify-content: space-between; padding: 8px; border: 1px solid #444;
                                border-radius: 4px; cursor: pointer; margin-bottom: 5px;">
                        <span>${itemDef?.icon || '?'} ${itemName}</span>
                        <span style="color: #8af;">${enchantIcons || 'No enchants'}</span>
                    </div>
                `;
            }
            itemsDiv.innerHTML = itemsHtml || '<div style="color: #888;">Equip items first!</div>';

            // Default: no item selected
            enchantsDiv.innerHTML = '<div style="color: #888;">Select an item to enchant</div>';
        }

        let selectedEnchantItem = null;

        function selectEnchantItem(itemName) {
            selectedEnchantItem = itemName;
            const equipData = EQUIPMENT_MAP[itemName];
            const enchantsDiv = document.getElementById('enchant-options');

            // Highlight selected item
            document.querySelectorAll('.enchant-item').forEach(el => {
                el.style.background = el.dataset.item === itemName ? 'rgba(68, 136, 255, 0.2)' : '';
                el.style.borderColor = el.dataset.item === itemName ? '#4af' : '#444';
            });

            // Show available enchantments
            let html = '<div style="font-weight: bold; margin-bottom: 10px;">Available Enchantments:</div>';

            for (const [id, enchant] of Object.entries(ENCHANTMENTS)) {
                if (!enchant.slots.includes(equipData.slot)) continue;

                const canApply = canEnchant(itemName, id);
                const hasIt = getItemEnchantments(itemName).includes(id);
                const costStr = Object.entries(enchant.cost).map(([m, c]) => `${c}x ${m}`).join(', ');

                html += `
                    <div style="padding: 8px; border: 1px solid ${hasIt ? '#4a4' : canApply ? '#448' : '#333'};
                                border-radius: 4px; margin-bottom: 5px; background: ${hasIt ? 'rgba(68,170,68,0.15)' : 'rgba(0,0,0,0.3)'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${enchant.icon} ${enchant.name}</span>
                            ${hasIt ? '<span style="color: #4f4;">âœ“ Applied</span>' :
                              canApply ? `<button onclick="applyEnchantment('${itemName}', '${id}')" style="padding: 4px 8px; cursor: pointer;">Apply</button>` :
                              '<span style="color: #666;">Need materials</span>'}
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">+${enchant.bonus}${enchant.multiplicative ? '%' : ''} ${enchant.stat} | Cost: ${costStr}</div>
                    </div>
                `;
            }

            enchantsDiv.innerHTML = html;
        }

        // v5.2: Talent Tree System
        const TALENT_TREES = {
            combat: {
                name: 'Combat Mastery', icon: 'âš”ï¸', color: '#ff4444',
                talents: {
                    brutality: { name: 'Brutality', desc: '+5% damage per rank', maxRank: 5, effect: { damage: 0.05 } },
                    toughness: { name: 'Toughness', desc: '+10 max HP per rank', maxRank: 5, effect: { maxHp: 10 } },
                    precision: { name: 'Precision', desc: '+2% crit chance per rank', maxRank: 5, effect: { critChance: 0.02 }, requires: 'brutality' },
                    bloodlust: { name: 'Bloodlust', desc: '+1% lifesteal per rank', maxRank: 3, effect: { lifesteal: 0.01 }, requires: 'precision' },
                    warlord: { name: 'Warlord', desc: '+10% ability damage', maxRank: 1, effect: { abilityDamage: 0.10 }, requires: 'bloodlust' }
                }
            },
            survival: {
                name: 'Survival Instinct', icon: 'ðŸ›¡ï¸', color: '#44aaff',
                talents: {
                    thick_skin: { name: 'Thick Skin', desc: '+2 defense per rank', maxRank: 5, effect: { defense: 2 } },
                    evasion: { name: 'Evasion', desc: '+3% dodge chance per rank', maxRank: 5, effect: { dodgeChance: 0.03 } },
                    second_wind: { name: 'Second Wind', desc: '+5% HP regen per rank', maxRank: 3, effect: { hpRegen: 0.05 }, requires: 'thick_skin' },
                    fortress: { name: 'Fortress', desc: '+20% shield duration', maxRank: 3, effect: { shieldDuration: 0.20 }, requires: 'evasion' },
                    immortal: { name: 'Immortal', desc: 'Survive fatal blow once/world', maxRank: 1, effect: { deathSave: true }, requires: 'second_wind' }
                }
            },
            fortune: {
                name: 'Fortune Seeker', icon: 'ðŸ€', color: '#44ff44',
                talents: {
                    lucky: { name: 'Lucky', desc: '+3% loot drop per rank', maxRank: 5, effect: { lootBonus: 0.03 } },
                    harvester: { name: 'Harvester', desc: '+10% resource yield per rank', maxRank: 5, effect: { resourceYield: 0.10 } },
                    treasure_sense: { name: 'Treasure Sense', desc: '+5% rare find per rank', maxRank: 3, effect: { rareFind: 0.05 }, requires: 'lucky' },
                    midas_touch: { name: 'Midas Touch', desc: '+15% XP gain per rank', maxRank: 3, effect: { xpBonus: 0.15 }, requires: 'harvester' },
                    jackpot: { name: 'Jackpot', desc: 'Double boss loot chance', maxRank: 1, effect: { doubleBossLoot: true }, requires: 'treasure_sense' }
                }
            }
        };

        // v5.2: Get talent points available
        function getTalentPoints() {
            const totalLevels = Object.values(gameData.skills).reduce((sum, s) => sum + s.level, 0);
            const pointsEarned = Math.floor(totalLevels / 5); // 1 point per 5 total skill levels
            const pointsSpent = getSpentTalentPoints();
            return { earned: pointsEarned, spent: pointsSpent, available: pointsEarned - pointsSpent };
        }

        function getSpentTalentPoints() {
            if (!gameData.talents) gameData.talents = {};
            let spent = 0;
            for (const treeId of Object.keys(TALENT_TREES)) {
                const treeTalents = gameData.talents[treeId] || {};
                for (const [talentId, rank] of Object.entries(treeTalents)) {
                    spent += rank;
                }
            }
            return spent;
        }

        function getTalentRank(treeId, talentId) {
            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            return gameData.talents[treeId][talentId] || 0;
        }

        function canUnlockTalent(treeId, talentId) {
            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            const currentRank = getTalentRank(treeId, talentId);

            // Check max rank
            if (currentRank >= talent.maxRank) return false;

            // Check points available
            if (getTalentPoints().available <= 0) return false;

            // Check prerequisite
            if (talent.requires) {
                const reqRank = getTalentRank(treeId, talent.requires);
                const reqTalent = tree.talents[talent.requires];
                if (reqRank < reqTalent.maxRank) return false;
            }

            return true;
        }

        function unlockTalent(treeId, talentId) {
            if (!canUnlockTalent(treeId, talentId)) {
                showNotification('Cannot unlock this talent!', 'error');
                return false;
            }

            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            gameData.talents[treeId][talentId] = (gameData.talents[treeId][talentId] || 0) + 1;

            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            showNotification(`Unlocked ${talent.name}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateTalentModal();
            return true;
        }

        function getTalentBonuses() {
            const bonuses = {
                damage: 0, maxHp: 0, critChance: 0, lifesteal: 0, abilityDamage: 0,
                defense: 0, dodgeChance: 0, hpRegen: 0, shieldDuration: 0, deathSave: false,
                lootBonus: 0, resourceYield: 0, rareFind: 0, xpBonus: 0, doubleBossLoot: false
            };

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    if (rank > 0) {
                        for (const [stat, value] of Object.entries(talent.effect)) {
                            if (typeof value === 'boolean') {
                                bonuses[stat] = value;
                            } else {
                                bonuses[stat] = (bonuses[stat] || 0) + (value * rank);
                            }
                        }
                    }
                }
            }

            return bonuses;
        }

        // ============================================
        // v5.13: SHIP DEFENSE SYSTEM
        // Visible ship on world map with defensive laser
        // ============================================
        const SHIP_STATE = {
            mesh: null,
            landingPad: null,
            hp: 100,
            maxHp: 100,
            position: new THREE.Vector3(0, 0, 0),
            laser: {
                active: false,
                target: null,
                beam: null,
                cooldown: 0,
                lastFire: 0,
                damage: 15,
                range: 35,
                fireRate: 800,  // ms between shots
                autoDefend: true
            },
            propellers: [],
            thrustLight: null,
            damaged: false,
            repairCost: 50  // gold to repair
        };

        // Create ship mesh for world map
        function createWorldShip(spawnPosition) {
            const shipGroup = new THREE.Group();

            // Main body - sleek fuselage
            const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3a,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            shipGroup.add(body);

            // Cockpit dome
            const cockpitGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x004444,
                emissiveIntensity: 0.5
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.8, 0.5);
            cockpit.scale.set(1, 0.5, 1.2);
            shipGroup.add(cockpit);

            // Wings
            const wingGeometry = new THREE.BoxGeometry(8, 0.2, 2);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a4a,
                metalness: 0.6,
                roughness: 0.4
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.set(0, 0.3, -0.5);
            wings.castShadow = true;
            shipGroup.add(wings);

            // Wing tips with lights
            const tipGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const tipMaterialL = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1
            });
            const tipMaterialR = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 1
            });
            const tipL = new THREE.Mesh(tipGeometry, tipMaterialL);
            const tipR = new THREE.Mesh(tipGeometry, tipMaterialR);
            tipL.position.set(-4, 0.3, -0.5);
            tipR.position.set(4, 0.3, -0.5);
            shipGroup.add(tipL, tipR);

            // Tail fin
            const tailGeometry = new THREE.BoxGeometry(0.3, 2, 1);
            const tail = new THREE.Mesh(tailGeometry, wingMaterial);
            tail.position.set(0, 1, -2);
            tail.castShadow = true;
            shipGroup.add(tail);

            // Engine pods
            const engineGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2, 8);
            const engineMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2a,
                metalness: 0.8,
                roughness: 0.2
            });
            [-2, 2].forEach(x => {
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.rotation.x = Math.PI / 2;
                engine.position.set(x, 0, -2);
                engine.castShadow = true;
                shipGroup.add(engine);

                // Engine glow
                const glowGeometry = new THREE.CircleGeometry(0.4, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.8
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.set(x, 0, -3);
                shipGroup.add(glow);
            });

            // Laser turret on top
            const turretBaseGeo = new THREE.CylinderGeometry(0.5, 0.6, 0.4, 8);
            const turretMaterial = new THREE.MeshStandardMaterial({
                color: 0x444455,
                metalness: 0.8
            });
            const turretBase = new THREE.Mesh(turretBaseGeo, turretMaterial);
            turretBase.position.set(0, 1.1, -0.5);
            shipGroup.add(turretBase);

            const turretBarrelGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
            const turretBarrel = new THREE.Mesh(turretBarrelGeo, turretMaterial);
            turretBarrel.rotation.z = Math.PI / 2;
            turretBarrel.position.set(0, 1.5, -0.5);
            shipGroup.add(turretBarrel);
            shipGroup.userData.turretBarrel = turretBarrel;

            // Laser beam (initially invisible)
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const laserBeam = new THREE.Mesh(laserGeometry, laserMaterial);
            laserBeam.visible = false;
            shipGroup.add(laserBeam);
            SHIP_STATE.laser.beam = laserBeam;

            // Landing gear
            const gearGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const gearMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            [[-1.5, -1, 1], [1.5, -1, 1], [0, -1, -2]].forEach(pos => {
                const gear = new THREE.Mesh(gearGeometry, gearMaterial);
                gear.position.set(...pos);
                gear.castShadow = true;
                shipGroup.add(gear);
            });

            // Position ship at spawn point (landing zone)
            shipGroup.position.copy(spawnPosition);
            shipGroup.position.y = spawnPosition.y + 2;  // Slightly above ground
            shipGroup.rotation.y = Math.random() * Math.PI * 2;

            SHIP_STATE.mesh = shipGroup;
            SHIP_STATE.position.copy(spawnPosition);

            return shipGroup;
        }

        // Create landing pad/zone marker
        function createLandingZone(position) {
            const padGroup = new THREE.Group();

            // Landing pad - circular platform
            const padGeometry = new THREE.CylinderGeometry(10, 10, 0.3, 32);
            const padMaterial = new THREE.MeshStandardMaterial({
                color: 0x333344,
                metalness: 0.5,
                roughness: 0.5
            });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Landing markings - concentric rings
            [8, 6, 4].forEach((r, i) => {
                const ringGeo = new THREE.RingGeometry(r - 0.2, r, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: i === 0 ? 0xffff00 : 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.2;
                padGroup.add(ring);
            });

            // Corner beacons
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const beaconGeo = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
                const beaconMat = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.6
                });
                const beacon = new THREE.Mesh(beaconGeo, beaconMat);
                beacon.position.set(Math.cos(angle) * 9, 1, Math.sin(angle) * 9);
                padGroup.add(beacon);

                // Beacon light
                const lightGeo = new THREE.SphereGeometry(0.35, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.set(Math.cos(angle) * 9, 2.2, Math.sin(angle) * 9);
                light.userData.isBeacon = true;
                light.userData.phase = i * Math.PI / 2;
                padGroup.add(light);
            }

            // HP shield dome (visible when damaged)
            const shieldGeo = new THREE.SphereGeometry(12, 32, 32);
            const shieldMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                wireframe: true
            });
            const shield = new THREE.Mesh(shieldGeo, shieldMat);
            shield.position.y = 5;
            padGroup.add(shield);
            padGroup.userData.shield = shield;

            padGroup.position.copy(position);

            SHIP_STATE.landingPad = padGroup;
            return padGroup;
        }

        // Update ship defense system
        function updateShipDefense(dt, time) {
            if (!SHIP_STATE.mesh || mode !== 'world') return;

            // Animate beacon lights
            if (SHIP_STATE.landingPad) {
                SHIP_STATE.landingPad.children.forEach(child => {
                    if (child.userData.isBeacon) {
                        const pulse = (Math.sin(time * 0.003 + child.userData.phase) + 1) / 2;
                        child.material.opacity = 0.5 + pulse * 0.5;
                    }
                });

                // Shield visibility based on recent damage
                const shield = SHIP_STATE.landingPad.userData.shield;
                if (shield) {
                    if (SHIP_STATE.damaged) {
                        shield.material.opacity = Math.min(0.3, shield.material.opacity + dt * 0.5);
                        shield.rotation.y += dt * 0.5;
                    } else {
                        shield.material.opacity = Math.max(0, shield.material.opacity - dt * 0.2);
                    }
                }
            }

            // Auto-defend: Find and shoot nearby mobs
            if (SHIP_STATE.laser.autoDefend && time - SHIP_STATE.laser.lastFire > SHIP_STATE.laser.fireRate) {
                let nearestMob = null;
                let nearestDist = SHIP_STATE.laser.range;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent || mob.userData.hp <= 0) return;
                    const dist = SHIP_STATE.mesh.position.distanceTo(mob.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    fireShipLaser(nearestMob, time);
                }
            }

            // Update laser beam visual
            updateLaserBeam(dt, time);

            // Mobs attacking ship
            worldState.mobs.forEach(mob => {
                if (!mob.parent || mob.userData.hp <= 0) return;

                const distToShip = mob.position.distanceTo(SHIP_STATE.mesh.position);

                // Mobs occasionally target ship if player is far away
                if (distToShip < 20 && !mob.userData.targetingPlayer) {
                    const distToPlayer = worldState.player ? mob.position.distanceTo(worldState.player.position) : Infinity;
                    if (distToPlayer > 30 && Math.random() < 0.01) {  // Small chance to attack ship
                        mob.userData.targetingShip = true;
                        mob.userData.targetPos.copy(SHIP_STATE.mesh.position);
                    }
                }

                // Damage ship when in melee range
                if (mob.userData.targetingShip && distToShip < 5) {
                    const now = performance.now();
                    if (!mob.userData.lastShipAttack || now - mob.userData.lastShipAttack > 2000) {
                        damageShip(mob.userData.damage || 5);
                        mob.userData.lastShipAttack = now;
                    }
                }
            });

            // Gentle hover animation for ship
            if (SHIP_STATE.mesh) {
                SHIP_STATE.mesh.position.y = SHIP_STATE.position.y + 2 + Math.sin(time * 0.002) * 0.2;
                SHIP_STATE.mesh.rotation.z = Math.sin(time * 0.001) * 0.02;
            }
        }

        // Fire ship's defensive laser
        function fireShipLaser(target, time) {
            if (!SHIP_STATE.mesh || !target) return;

            SHIP_STATE.laser.lastFire = time;
            SHIP_STATE.laser.target = target;
            SHIP_STATE.laser.active = true;

            // Rotate turret toward target
            const turret = SHIP_STATE.mesh.userData.turretBarrel;
            if (turret) {
                const dir = new THREE.Vector3().subVectors(target.position, SHIP_STATE.mesh.position).normalize();
                turret.lookAt(target.position);
            }

            // Deal damage
            target.userData.hp -= SHIP_STATE.laser.damage;

            // Visual feedback
            if (particles) {
                particles.emit(target.position, 10, 0xff0000, { spread: 2, lifetime: 300 });
            }

            spawnFloater(target.position, `-${SHIP_STATE.laser.damage}`, '#ff4444');

            // Sound effect placeholder
            AudioSystem.play('spell');

            // Check if killed
            if (target.userData.hp <= 0) {
                const xpReward = target.userData.xpReward || 50;
                addXp('combat', Math.floor(xpReward * 0.5));  // Half XP for ship kills
                spawnFloater(target.position, `SHIP KILL! +${Math.floor(xpReward * 0.5)}XP`, '#ff8800');
            }
        }

        // Update laser beam visual effect
        function updateLaserBeam(dt, time) {
            const beam = SHIP_STATE.laser.beam;
            if (!beam) return;

            if (SHIP_STATE.laser.active && SHIP_STATE.laser.target) {
                beam.visible = true;

                const start = SHIP_STATE.mesh.position.clone();
                start.y += 1.5;
                const end = SHIP_STATE.laser.target.position.clone();
                end.y += 1;

                const dir = new THREE.Vector3().subVectors(end, start);
                const length = dir.length();

                beam.scale.set(1, length, 1);
                beam.position.copy(start).add(dir.multiplyScalar(0.5));
                beam.lookAt(end);
                beam.rotateX(Math.PI / 2);

                // Flash effect
                beam.material.opacity = 0.9;

                // Deactivate after short duration
                setTimeout(() => {
                    SHIP_STATE.laser.active = false;
                    beam.visible = false;
                }, 100);
            } else {
                beam.visible = false;
            }
        }

        // Damage the ship
        function damageShip(amount) {
            SHIP_STATE.hp = Math.max(0, SHIP_STATE.hp - amount);
            SHIP_STATE.damaged = true;

            // Clear damaged flag after 2 seconds
            setTimeout(() => { SHIP_STATE.damaged = false; }, 2000);

            // Visual feedback
            if (SHIP_STATE.mesh) {
                // Flash red
                SHIP_STATE.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        const originalColor = child.material.emissive.getHex();
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            child.material.emissive.setHex(originalColor);
                        }, 200);
                    }
                });
            }

            // Particles
            if (particles && SHIP_STATE.mesh) {
                particles.emit(SHIP_STATE.mesh.position, 15, 0xff4400, { spread: 3, lifetime: 500 });
            }

            spawnFloater(SHIP_STATE.mesh.position, `-${amount}`, '#ff0000');
            showNotification(`Ship taking damage! (${SHIP_STATE.hp}/${SHIP_STATE.maxHp} HP)`, 'warning');

            // Update UI
            updateShipHPUI();

            // Ship destroyed
            if (SHIP_STATE.hp <= 0) {
                shipDestroyed();
            }
        }

        // Handle ship destruction
        function shipDestroyed() {
            showNotification('SHIP DESTROYED! Repair required to leave planet.', 'error');

            // Disable ship mesh
            if (SHIP_STATE.mesh) {
                SHIP_STATE.mesh.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 0.3;
                        child.material.transparent = true;
                    }
                });
            }

            // Large explosion
            if (particles && SHIP_STATE.mesh) {
                particles.emit(SHIP_STATE.mesh.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                particles.emit(SHIP_STATE.mesh.position, 30, 0xffff00, { spread: 6, lifetime: 1000 });
            }
        }

        // Repair ship (costs gold)
        function repairShip() {
            if (SHIP_STATE.hp >= SHIP_STATE.maxHp) {
                showNotification('Ship is already at full health!', 'info');
                return;
            }

            if (gameData.currency >= SHIP_STATE.repairCost) {
                gameData.currency -= SHIP_STATE.repairCost;
                SHIP_STATE.hp = SHIP_STATE.maxHp;

                // Restore ship visuals
                if (SHIP_STATE.mesh) {
                    SHIP_STATE.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = 1;
                            child.material.transparent = false;
                        }
                    });
                }

                showNotification(`Ship repaired! -${SHIP_STATE.repairCost} Gold`, 'success');
                updateShipHPUI();
                saveGame();
            } else {
                showNotification(`Need ${SHIP_STATE.repairCost} Gold to repair ship!`, 'warning');
            }
        }

        // Update ship HP UI
        function updateShipHPUI() {
            const bar = document.getElementById('ship-hp-fill');
            const text = document.getElementById('ship-hp-text');
            if (bar) {
                const percent = (SHIP_STATE.hp / SHIP_STATE.maxHp) * 100;
                bar.style.width = `${percent}%`;
                bar.style.background = percent > 50 ? '#00ff88' : percent > 25 ? '#ffaa00' : '#ff4444';
            }
            if (text) {
                text.textContent = `${SHIP_STATE.hp}/${SHIP_STATE.maxHp}`;
            }
        }

        // Toggle ship auto-defend
        function toggleShipAutoDefend() {
            SHIP_STATE.laser.autoDefend = !SHIP_STATE.laser.autoDefend;
            showNotification(`Ship Auto-Defense: ${SHIP_STATE.laser.autoDefend ? 'ENABLED' : 'DISABLED'}`, 'info');
            const btn = document.getElementById('ship-defense-btn');
            if (btn) {
                btn.textContent = SHIP_STATE.laser.autoDefend ? 'ðŸ›¡ï¸ Defense: ON' : 'ðŸ›¡ï¸ Defense: OFF';
                btn.style.background = SHIP_STATE.laser.autoDefend ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 68, 68, 0.2)';
            }
        }

        // v5.11: RTS Panel Toggle System
        const rtsPanelState = {
            skills: false,
            crafting: false,
            inventory: false,
            equipment: false
        };

        function toggleRTSPanel(panelName) {
            rtsPanelState[panelName] = !rtsPanelState[panelName];

            const panelIds = {
                skills: 'skills-panel',
                crafting: 'crafting-panel',
                inventory: 'inventory-panel',
                equipment: 'equipment-panel'
            };

            const panel = document.getElementById(panelIds[panelName]);
            const toggleBtn = document.getElementById(`toggle-${panelName}`);

            if (panel) {
                if (rtsPanelState[panelName]) {
                    panel.classList.add('visible');
                } else {
                    panel.classList.remove('visible');
                }
            }

            if (toggleBtn) {
                if (rtsPanelState[panelName]) {
                    toggleBtn.classList.add('active');
                } else {
                    toggleBtn.classList.remove('active');
                }
            }
        }

        // v5.11: Keyboard shortcuts for RTS panels
        function handleRTSPanelHotkeys(e) {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

            switch(e.key.toLowerCase()) {
                case 'k': toggleRTSPanel('skills'); break;
                case 'i': toggleRTSPanel('inventory'); break;
                case 'e': toggleRTSPanel('equipment'); break;
                // 'c' is often used for crafting but may conflict with other controls
            }
        }

        // v5.2: Talent Modal UI
        function showTalentModal() {
            document.getElementById('talent-modal').style.display = 'flex';
            updateTalentModal();
        }

        function closeTalentModal() {
            document.getElementById('talent-modal').style.display = 'none';
        }

        function updateTalentModal() {
            const points = getTalentPoints();
            document.getElementById('talent-points-display').textContent = `Talent Points: ${points.available}/${points.earned}`;

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                const treeDiv = document.getElementById(`talent-tree-${treeId}`);
                if (!treeDiv) continue;

                let html = '';
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    const canUnlock = canUnlockTalent(treeId, talentId);
                    const isMaxed = rank >= talent.maxRank;
                    const isLocked = talent.requires && getTalentRank(treeId, talent.requires) < TALENT_TREES[treeId].talents[talent.requires].maxRank;

                    html += `
                        <div style="padding: 8px; margin-bottom: 5px; border: 1px solid ${isMaxed ? tree.color : isLocked ? '#333' : '#555'};
                                    border-radius: 4px; background: ${isMaxed ? `${tree.color}22` : 'rgba(0,0,0,0.3)'};
                                    opacity: ${isLocked ? 0.5 : 1}; cursor: ${canUnlock ? 'pointer' : 'default'};"
                             onclick="${canUnlock ? `unlockTalent('${treeId}', '${talentId}')` : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: ${isMaxed ? tree.color : '#fff'};">${talent.name}</span>
                                <span style="color: ${isMaxed ? '#4f4' : '#888'};">${rank}/${talent.maxRank}</span>
                            </div>
                            <div style="font-size: 10px; color: #888; margin-top: 3px;">${talent.desc}</div>
                        </div>
                    `;
                }
                treeDiv.innerHTML = html;
            }
        }

        // ============================================
        // v5.3: MASTERY SYSTEM
        // ============================================
        const MASTERY_MILESTONES = {
            mining: {
                name: 'Mining', icon: 'â›ï¸', color: '#888888',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'miningYield', value: 0.1 }, desc: '+10% ore yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'miningYield', value: 0.15 }, desc: '+15% ore yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Miner\'s Blessing' }, desc: 'Unlock Miner\'s Blessing buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'miningYield', value: 0.25 }, desc: '+25% ore yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Miner' }, desc: 'Earn Grandmaster title' }
                ]
            },
            wood: {
                name: 'Woodcutting', icon: 'ðŸª“', color: '#da5500',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'woodYield', value: 0.1 }, desc: '+10% wood yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'woodYield', value: 0.15 }, desc: '+15% wood yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Lumberjack\'s Spirit' }, desc: 'Unlock Lumberjack buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'woodYield', value: 0.25 }, desc: '+25% wood yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Lumberjack' }, desc: 'Earn Grandmaster title' }
                ]
            },
            combat: {
                name: 'Combat', icon: 'âš”ï¸', color: '#ff4444',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'combatDamage', value: 0.05 }, desc: '+5% damage' },
                    { level: 10, reward: { type: 'bonus', stat: 'combatDamage', value: 0.1 }, desc: '+10% damage' },
                    { level: 15, reward: { type: 'unlock', ability: 'Veteran Strike' }, desc: 'Unlock Veteran Strike' },
                    { level: 20, reward: { type: 'bonus', stat: 'combatCrit', value: 0.05 }, desc: '+5% crit chance' },
                    { level: 25, reward: { type: 'title', title: 'Warlord' }, desc: 'Earn Warlord title' }
                ]
            },
            fishing: {
                name: 'Fishing', icon: 'ðŸŽ£', color: '#4488ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'fishChance', value: 0.1 }, desc: '+10% catch rate' },
                    { level: 10, reward: { type: 'bonus', stat: 'rareFind', value: 0.05 }, desc: '+5% rare fish' },
                    { level: 15, reward: { type: 'unlock', item: 'Golden Lure' }, desc: 'Unlock Golden Lure' },
                    { level: 20, reward: { type: 'bonus', stat: 'fishChance', value: 0.2 }, desc: '+20% catch rate' },
                    { level: 25, reward: { type: 'title', title: 'Master Angler' }, desc: 'Earn Master title' }
                ]
            },
            cooking: {
                name: 'Cooking', icon: 'ðŸ³', color: '#ff8800',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'healBonus', value: 0.1 }, desc: '+10% heal amount' },
                    { level: 10, reward: { type: 'bonus', stat: 'healBonus', value: 0.15 }, desc: '+15% heal amount' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Feast' }, desc: 'Unlock Feast recipe' },
                    { level: 20, reward: { type: 'bonus', stat: 'foodDuration', value: 0.3 }, desc: '+30% buff duration' },
                    { level: 25, reward: { type: 'title', title: 'Master Chef' }, desc: 'Earn Master title' }
                ]
            },
            crafting: {
                name: 'Crafting', icon: 'ðŸ”¨', color: '#aa44ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'craftBonus', value: 0.1 }, desc: '+10% craft success' },
                    { level: 10, reward: { type: 'bonus', stat: 'materialSave', value: 0.1 }, desc: '10% material savings' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Masterwork Forge' }, desc: 'Unlock Masterwork crafts' },
                    { level: 20, reward: { type: 'bonus', stat: 'rarityBoost', value: 0.15 }, desc: '+15% rarity chance' },
                    { level: 25, reward: { type: 'title', title: 'Artisan Supreme' }, desc: 'Earn Artisan title' }
                ]
            }
        };

        function getMasteryBonuses() {
            const bonuses = {
                miningYield: 0, woodYield: 0, combatDamage: 0, combatCrit: 0,
                fishChance: 0, rareFind: 0, healBonus: 0, foodDuration: 0,
                craftBonus: 0, materialSave: 0, rarityBoost: 0
            };

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'bonus') {
                        bonuses[milestone.reward.stat] = (bonuses[milestone.reward.stat] || 0) + milestone.reward.value;
                    }
                }
            }

            return bonuses;
        }

        function getUnlockedMasteryTitles() {
            const titles = [];
            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'title') {
                        titles.push(milestone.reward.title);
                    }
                }
            }
            return titles;
        }

        function openMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'flex';
            updateMasteryModal();
        }

        function closeMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'none';
        }

        function updateMasteryModal() {
            const listDiv = document.getElementById('mastery-list');
            let html = '';

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                const maxMilestone = mastery.milestones[mastery.milestones.length - 1].level;
                const progress = Math.min(100, (skillLevel / maxMilestone) * 100);
                const isMastered = skillLevel >= maxMilestone;

                html += `
                    <div class="mastery-card ${isMastered ? 'mastered' : ''}">
                        <div class="mastery-header">
                            <span class="mastery-skill" style="color: ${mastery.color};">${mastery.icon} ${mastery.name}</span>
                            <span class="mastery-level">Lv ${skillLevel}</span>
                        </div>
                        <div class="mastery-progress-bar">
                            <div class="mastery-progress-fill" style="width: ${progress}%;"></div>
                        </div>
                        <div class="mastery-milestones">
                `;

                for (const milestone of mastery.milestones) {
                    const achieved = skillLevel >= milestone.level;
                    const isNext = !achieved && mastery.milestones.find(m => skillLevel < m.level)?.level === milestone.level;
                    html += `
                        <div class="milestone ${achieved ? 'achieved' : ''} ${isNext ? 'next' : ''}" title="${milestone.desc}">
                            Lv${milestone.level}: ${achieved ? 'âœ“' : milestone.desc.substring(0, 15)}...
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        // ============================================
        // v5.3: REALM PORTAL SYSTEM
        // ============================================
        const REALM_PORTALS = {
            shadow_realm: {
                name: 'Shadow Realm',
                icon: 'ðŸŒ‘',
                tier: 1,
                desc: 'A realm of darkness where shadows come alive. Enhanced enemy spawn rates.',
                requirements: { combatLevel: 10, bossesDefeated: 1 },
                modifiers: { enemyDamage: 1.5, enemyHp: 1.3, spawnRate: 2.0 },
                rewards: ['Shadow Essence', 'Dark Crystal'],
                xpMultiplier: 1.5,
                duration: 300 // 5 minutes
            },
            frost_dimension: {
                name: 'Frost Dimension',
                icon: 'â„ï¸',
                tier: 2,
                desc: 'An eternally frozen world. All enemies inflict chill. Ice enemies are empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 1.8, enemyHp: 1.5, allEnemiesChill: true },
                rewards: ['Frozen Heart', 'Permafrost Shard', 'Frost Blade'],
                xpMultiplier: 2.0,
                duration: 300
            },
            inferno_pit: {
                name: 'Inferno Pit',
                icon: 'ðŸ”¥',
                tier: 2,
                desc: 'Volcanic realm of eternal flame. Fire damage over time. Magma enemies empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 2.0, enemyHp: 1.5, environmentalDamage: 2 },
                rewards: ['Infernal Core', 'Magma Heart', 'Magma Sword'],
                xpMultiplier: 2.0,
                duration: 300
            },
            void_nexus: {
                name: 'Void Nexus',
                icon: 'ðŸŒ€',
                tier: 3,
                desc: 'The space between dimensions. Reality warps around you. Elite enemies guaranteed.',
                requirements: { combatLevel: 20, bossesDefeated: 5, elitesKilled: 20 },
                modifiers: { enemyDamage: 2.5, enemyHp: 2.0, allElites: true },
                rewards: ['Void Core', 'Dimension Shard', 'Void Dagger', 'Legendary Core'],
                xpMultiplier: 3.0,
                duration: 300
            },
            celestial_ascent: {
                name: 'Celestial Ascent',
                icon: 'âœ¨',
                tier: 4,
                desc: 'The ultimate challenge. Face the Celestial Guardians in their domain.',
                requirements: { combatLevel: 25, bossesDefeated: 10, portalClears: 5 },
                modifiers: { enemyDamage: 3.0, enemyHp: 3.0, bossOnly: true },
                rewards: ['Celestial Essence', 'Star Fragment', 'Legendary Blade', 'Mythic Orb'],
                xpMultiplier: 5.0,
                duration: 600 // 10 minutes
            }
        };

        function initPortalSystem() {
            if (!gameData.portals) {
                gameData.portals = {
                    clears: {},
                    currentPortal: null,
                    portalStartTime: 0,
                    totalClears: 0
                };
            }
        }

        function canEnterPortal(portalId) {
            const portal = REALM_PORTALS[portalId];
            if (!portal) return false;

            const reqs = portal.requirements;
            const combatLevel = gameData.skills?.combat?.level || 1;
            const bossesDefeated = gameData.statistics?.bossesDefeated || 0;
            const elitesKilled = gameData.statistics?.elitesKilled || 0;
            const portalClears = gameData.portals?.totalClears || 0;

            if (combatLevel < reqs.combatLevel) return false;
            if (bossesDefeated < reqs.bossesDefeated) return false;
            if (reqs.elitesKilled && elitesKilled < reqs.elitesKilled) return false;
            if (reqs.portalClears && portalClears < reqs.portalClears) return false;

            return true;
        }

        function getPortalRequirementText(portalId) {
            const portal = REALM_PORTALS[portalId];
            const reqs = portal.requirements;
            const parts = [];

            parts.push(`Combat Lv ${reqs.combatLevel}`);
            parts.push(`${reqs.bossesDefeated} bosses`);
            if (reqs.elitesKilled) parts.push(`${reqs.elitesKilled} elites`);
            if (reqs.portalClears) parts.push(`${reqs.portalClears} portal clears`);

            return parts.join(' | ');
        }

        function enterPortal(portalId) {
            if (!canEnterPortal(portalId)) {
                showNotification('Requirements not met!', 'error');
                return false;
            }

            if (gameData.portals.currentPortal) {
                showNotification('Already in a portal realm!', 'warning');
                return false;
            }

            if (mode !== 'world') {
                showNotification('Must be on a planet to enter portals!', 'warning');
                return false;
            }

            const portal = REALM_PORTALS[portalId];
            gameData.portals.currentPortal = portalId;
            gameData.portals.portalStartTime = Date.now();
            gameData.portals.killProgress = 0; // v5.3: Reset kill counter

            showNotification(`Entered ${portal.name}! ${portal.duration / 60} minutes to clear.`, 'success');
            AudioSystem.bossSpawn();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 50, parseInt(portal.icon === 'ðŸŒ‘' ? '0x440088' : portal.icon === 'â„ï¸' ? '0x88ddff' : portal.icon === 'ðŸ”¥' ? '0xff4400' : '0x8844ff'), { spread: 8, lifetime: 1500 });
            }

            closePortalModal();
            updatePortalUI();
            saveGameData();
            return true;
        }

        function exitPortal(completed = false) {
            if (!gameData.portals.currentPortal) return;

            const portalId = gameData.portals.currentPortal;
            const portal = REALM_PORTALS[portalId];

            if (completed) {
                // Grant rewards
                gameData.portals.clears[portalId] = (gameData.portals.clears[portalId] || 0) + 1;
                gameData.portals.totalClears++;

                // Give a random reward
                const rewardItem = portal.rewards[Math.floor(Math.random() * portal.rewards.length)];
                addItem(rewardItem);

                showNotification(`Portal cleared! Received ${rewardItem}!`, 'success');
                AudioSystem.levelUp();

                if (particles && worldState.player) {
                    particles.emit(worldState.player.position, 60, 0xffd700, { spread: 10, lifetime: 2000 });
                }
            } else {
                showNotification('Portal expired. Try again!', 'warning');
            }

            gameData.portals.currentPortal = null;
            gameData.portals.portalStartTime = 0;
            updatePortalUI();
            saveGameData();
        }

        function getPortalModifiers() {
            if (!gameData.portals?.currentPortal) return null;
            return REALM_PORTALS[gameData.portals.currentPortal]?.modifiers || null;
        }

        function getPortalXpMultiplier() {
            if (!gameData.portals?.currentPortal) return 1;
            return REALM_PORTALS[gameData.portals.currentPortal]?.xpMultiplier || 1;
        }

        function checkPortalTimeout() {
            if (!gameData.portals?.currentPortal) return;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;

            if (elapsed >= portal.duration) {
                exitPortal(false);
            }
        }

        function getPortalTimeRemaining() {
            if (!gameData.portals?.currentPortal) return 0;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;
            return Math.max(0, portal.duration - elapsed);
        }

        function openPortalModal() {
            initPortalSystem();
            document.getElementById('portal-modal').style.display = 'flex';
            updatePortalModal();
        }

        function closePortalModal() {
            document.getElementById('portal-modal').style.display = 'none';
        }

        function updatePortalModal() {
            const currentPortal = gameData.portals?.currentPortal;
            document.getElementById('current-realm').textContent = currentPortal ? REALM_PORTALS[currentPortal].name : 'None';

            const listDiv = document.getElementById('portal-list');
            let html = '';

            for (const [portalId, portal] of Object.entries(REALM_PORTALS)) {
                const canEnter = canEnterPortal(portalId);
                const isActive = currentPortal === portalId;
                const clears = gameData.portals?.clears?.[portalId] || 0;

                html += `
                    <div class="portal-card ${!canEnter ? 'locked' : ''} ${isActive ? 'active' : ''}"
                         onclick="${canEnter && !currentPortal ? `enterPortal('${portalId}')` : ''}">
                        <div class="portal-header">
                            <span class="portal-name">${portal.icon} ${portal.name}</span>
                            <span class="portal-tier">Tier ${portal.tier}</span>
                        </div>
                        <div class="portal-desc">${portal.desc}</div>
                        <div class="portal-rewards">
                            ${portal.rewards.map(r => `<span class="portal-reward">${ITEMS[r]?.icon || 'ðŸ“¦'} ${r}</span>`).join('')}
                        </div>
                        <div class="portal-requirement">
                            ${canEnter ? `âœ“ Unlocked | Cleared: ${clears}x | ${portal.xpMultiplier}x XP` : `ðŸ”’ ${getPortalRequirementText(portalId)}`}
                        </div>
                        ${isActive ? `<div style="color: #ff8844; margin-top: 8px; text-align: center;">â±ï¸ Active - ${Math.floor(getPortalTimeRemaining())}s remaining</div>` : ''}
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        function updatePortalUI() {
            // This would update any in-game portal indicators
            if (document.getElementById('portal-modal').style.display === 'flex') {
                updatePortalModal();
            }
        }

        // ============================================
        // v5.3: LOOT RARITY SYSTEM
        // ============================================
        const LOOT_RARITIES = {
            common: { name: 'Common', color: '#aaaaaa', chance: 0.60, statMult: 1.0 },
            uncommon: { name: 'Uncommon', color: '#44ff44', chance: 0.25, statMult: 1.15 },
            rare: { name: 'Rare', color: '#4488ff', chance: 0.10, statMult: 1.35 },
            epic: { name: 'Epic', color: '#aa44ff', chance: 0.04, statMult: 1.6 },
            legendary: { name: 'Legendary', color: '#ff8800', chance: 0.0095, statMult: 2.0 },
            mythic: { name: 'Mythic', color: '#ff4488', chance: 0.0005, statMult: 3.0 }
        };

        const ITEM_MODIFIERS = {
            // Offensive modifiers
            sharp: { name: 'Sharp', stat: 'damage', value: 3, desc: '+3 Damage' },
            keen: { name: 'Keen', stat: 'critChance', value: 0.05, desc: '+5% Crit' },
            brutal: { name: 'Brutal', stat: 'damage', value: 5, desc: '+5 Damage' },
            deadly: { name: 'Deadly', stat: 'critDamage', value: 0.25, desc: '+25% Crit Damage' },
            vampiric: { name: 'Vampiric', stat: 'lifesteal', value: 0.05, desc: '+5% Lifesteal' },

            // Defensive modifiers
            sturdy: { name: 'Sturdy', stat: 'defense', value: 2, desc: '+2 Defense' },
            fortified: { name: 'Fortified', stat: 'defense', value: 4, desc: '+4 Defense' },
            vital: { name: 'Vital', stat: 'maxHp', value: 15, desc: '+15 Max HP' },
            resilient: { name: 'Resilient', stat: 'damageReduction', value: 0.05, desc: '+5% DR' },

            // Utility modifiers
            swift: { name: 'Swift', stat: 'moveSpeed', value: 0.1, desc: '+10% Speed' },
            lucky: { name: 'Lucky', stat: 'lootBonus', value: 0.1, desc: '+10% Loot' },
            wise: { name: 'Wise', stat: 'xpBonus', value: 0.1, desc: '+10% XP' },
            efficient: { name: 'Efficient', stat: 'resourceYield', value: 0.15, desc: '+15% Yield' }
        };

        function rollItemRarity(baseLuckBonus = 0) {
            const masteryBonuses = getMasteryBonuses();
            const talentBonuses = getTalentBonuses();
            const totalLuck = baseLuckBonus + (masteryBonuses.rarityBoost || 0) + (talentBonuses.rareFind || 0);

            let roll = Math.random();
            // Luck improves rare+ chances
            roll = roll * (1 - totalLuck);

            let cumulative = 0;
            for (const [rarityId, rarity] of Object.entries(LOOT_RARITIES)) {
                cumulative += rarity.chance;
                if (roll < cumulative) {
                    return rarityId;
                }
            }
            return 'common';
        }

        function rollItemModifiers(rarity) {
            const numModifiers = {
                common: 0,
                uncommon: 1,
                rare: 1,
                epic: 2,
                legendary: 2,
                mythic: 3
            };

            const count = numModifiers[rarity] || 0;
            if (count === 0) return [];

            const modifierKeys = Object.keys(ITEM_MODIFIERS);
            const selected = [];

            for (let i = 0; i < count; i++) {
                const availableModifiers = modifierKeys.filter(m => !selected.includes(m));
                if (availableModifiers.length === 0) break;

                const modId = availableModifiers[Math.floor(Math.random() * availableModifiers.length)];
                selected.push(modId);
            }

            return selected;
        }

        function createRarityItem(baseItemName, forcedRarity = null) {
            const rarity = forcedRarity || rollItemRarity();
            const modifiers = rollItemModifiers(rarity);
            const rarityData = LOOT_RARITIES[rarity];

            return {
                baseName: baseItemName,
                rarity: rarity,
                modifiers: modifiers,
                statMultiplier: rarityData.statMult
            };
        }

        function getRarityItemName(rarityItem) {
            if (!rarityItem || !rarityItem.rarity || rarityItem.rarity === 'common') {
                return rarityItem?.baseName || rarityItem;
            }

            const modNames = rarityItem.modifiers?.map(m => ITEM_MODIFIERS[m]?.name).filter(Boolean) || [];
            const prefix = modNames.length > 0 ? modNames.join(' ') + ' ' : '';
            const rarityData = LOOT_RARITIES[rarityItem.rarity];

            return `${prefix}${rarityItem.baseName}`;
        }

        function getRarityItemStats(rarityItem) {
            if (!rarityItem || typeof rarityItem === 'string') return {};

            const stats = {};
            const mult = rarityItem.statMultiplier || 1;

            // Apply modifier stats
            for (const modId of (rarityItem.modifiers || [])) {
                const mod = ITEM_MODIFIERS[modId];
                if (mod) {
                    stats[mod.stat] = (stats[mod.stat] || 0) + mod.value;
                }
            }

            return stats;
        }

        function showRarityDropPopup(rarityItem) {
            if (!rarityItem || rarityItem.rarity === 'common') return;

            const rarityData = LOOT_RARITIES[rarityItem.rarity];
            const itemData = ITEMS[rarityItem.baseName] || {};
            const displayName = getRarityItemName(rarityItem);
            const modifierStats = getRarityItemStats(rarityItem);

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'loot-drop-popup';
            popup.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">${itemData.icon || 'ðŸ“¦'}</div>
                <div class="rarity-${rarityItem.rarity}" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    ${rarityData.name} Drop!
                </div>
                <div style="color: ${rarityData.color}; font-size: 14px; margin-bottom: 10px;">
                    ${displayName}
                </div>
                ${Object.keys(modifierStats).length > 0 ? `
                    <div class="item-modifiers">
                        ${rarityItem.modifiers.map(m => ITEM_MODIFIERS[m]?.desc).join(' | ')}
                    </div>
                ` : ''}
                <button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 20px; cursor: pointer;
                    background: linear-gradient(135deg, ${rarityData.color}, #333); border: none; border-radius: 4px; color: #fff;">
                    Collect
                </button>
            `;

            document.body.appendChild(popup);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (popup.parentElement) {
                    popup.remove();
                }
            }, 5000);

            // Play appropriate sound
            if (rarityItem.rarity === 'legendary' || rarityItem.rarity === 'mythic') {
                AudioSystem.levelUp();
            } else {
                AudioSystem.collect();
            }
        }

        // Enhanced item drop function that uses rarity system
        function dropRarityItem(baseItemName, luckBonus = 0) {
            const rarityItem = createRarityItem(baseItemName, null);

            // Store rarity items in a special format
            if (!gameData.rarityItems) gameData.rarityItems = [];

            if (rarityItem.rarity !== 'common') {
                gameData.rarityItems.push(rarityItem);
                showRarityDropPopup(rarityItem);
            }

            // Add the base item to inventory (rarity tracked separately)
            addItem(baseItemName);

            return rarityItem;
        }

        // Get total bonus stats from all rarity items
        function getRarityBonuses() {
            const bonuses = {};

            for (const item of (gameData.rarityItems || [])) {
                // Only count equipped items (check if base item is in equipment)
                const gear = getEquippedGear();
                const isEquipped = Object.values(gear).some(g => g === item.baseName);

                if (isEquipped) {
                    const stats = getRarityItemStats(item);
                    for (const [stat, value] of Object.entries(stats)) {
                        bonuses[stat] = (bonuses[stat] || 0) + value;
                    }
                }
            }

            return bonuses;
        }

        // v5.5: 3D Ship Landing Mini-Game System (Drone-style)
        let landingGame = {
            active: false,
            targetCiv: null,
            scene: null,
            camera: null,
            renderer: null,
            ship: null,
            landingPad: null,
            animFrame: null,
            lastTime: 0,
            isManual: false,
            fuel: 100,
            velocity: null,
            targetPosition: null,
            propellers: [],
            thrustLight: null,
            environmentObjects: []
        };

        const LANDING_CONFIG = {
            startAltitude: 60,
            maxSpeed: 8,
            safeSpeed: 2.5,
            gravity: 0.02,          // Much slower gravity
            thrustPower: 0.06,      // Gentler thrust
            manualControl: 0.25,    // Slower manual movement
            fuelConsumption: 0.02,  // Slower fuel drain
            landingPadSize: 18,     // Bigger landing pad
            bounds: 100,
            biomeColors: {
                Terra: { sky: 0x87CEEB, ground: 0x3a8c3a, fog: 0x87CEEB },
                Desert: { sky: 0xffcc99, ground: 0xc2a060, fog: 0xffcc99 },
                Ice: { sky: 0xddeeff, ground: 0xe8f4f8, fog: 0xddeeff },
                Volcanic: { sky: 0x330000, ground: 0x2a1a1a, fog: 0x330000 },
                Alien: { sky: 0x220044, ground: 0x440066, fog: 0x220044 }
            }
        };

        function startLandingGame(civ) {
            // Cleanup any existing landing game
            if (landingGame.animFrame) {
                cancelAnimationFrame(landingGame.animFrame);
            }
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
            }

            landingGame.active = true;
            landingGame.targetCiv = civ;
            landingGame.isManual = false;
            landingGame.fuel = 100;
            landingGame.velocity = new THREE.Vector3(0, -0.1, 0);  // Very slow initial descent
            landingGame.targetPosition = new THREE.Vector3(0, 20, 0);
            landingGame.lastTime = 0;
            mode = 'landing';

            // Show landing UI
            const overlay = document.getElementById('landing-overlay');
            overlay.style.display = 'block';
            document.getElementById('landing-planet-name').textContent = `Landing on ${civ.name} (${civ.biomeName})`;
            document.getElementById('landing-mode').textContent = 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = 'Switch to Manual';

            // Get biome colors
            const biomeColors = LANDING_CONFIG.biomeColors[civ.biome] || LANDING_CONFIG.biomeColors.Terra;

            // Create separate Three.js scene for landing
            landingGame.scene = new THREE.Scene();
            landingGame.scene.fog = new THREE.Fog(biomeColors.fog, 100, 500);

            // Isometric camera
            const container = document.getElementById('landing-scene-container');
            const aspect = container.clientWidth / container.clientHeight;
            const d = 50;
            landingGame.camera = new THREE.OrthographicCamera(
                -d * aspect, d * aspect, d, -d, 1, 1000
            );
            landingGame.camera.position.set(100, 100, 100);
            landingGame.camera.lookAt(0, 0, 0);

            // Renderer
            landingGame.renderer = new THREE.WebGLRenderer({ antialias: true });
            landingGame.renderer.setSize(container.clientWidth, container.clientHeight);
            landingGame.renderer.shadowMap.enabled = true;
            landingGame.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            landingGame.renderer.setClearColor(biomeColors.sky);
            container.innerHTML = '';
            container.appendChild(landingGame.renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            landingGame.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            landingGame.scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: biomeColors.ground });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            landingGame.scene.add(ground);

            // Create landing pad
            createLandingPad();

            // Create environment based on biome
            createLandingEnvironment(civ.biome);

            // Create ship
            createLandingShip();

            // Start animation loop
            landingGameLoop(0);

            // Simple short blip sound instead of ringing tone
            AudioSystem.click();
            showNotification(`Approaching ${civ.name}... Land on the green pad!`, 'info');
        }

        function createLandingPad() {
            const padGroup = new THREE.Group();

            // Main pad
            const padGeometry = new THREE.CylinderGeometry(LANDING_CONFIG.landingPadSize, LANDING_CONFIG.landingPadSize, 1, 32);
            const padMaterial = new THREE.MeshLambertMaterial({ color: 0x44ff44 });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.position.y = 0.5;
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Center marker
            const markerGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.y = 1.2;
            padGroup.add(marker);

            // Beacon light
            const beaconGeometry = new THREE.CylinderGeometry(1, 1, 5, 8);
            const beaconMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.set(LANDING_CONFIG.landingPadSize - 2, 3, 0);
            beacon.castShadow = true;
            padGroup.add(beacon);

            // Beacon light
            const lightGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            landingGame.beaconLight = new THREE.Mesh(lightGeometry, lightMaterial);
            landingGame.beaconLight.position.set(LANDING_CONFIG.landingPadSize - 2, 6, 0);
            padGroup.add(landingGame.beaconLight);

            landingGame.landingPad = padGroup;
            landingGame.scene.add(padGroup);
        }

        function createLandingEnvironment(biome) {
            landingGame.environmentObjects = [];

            // Add trees/structures based on biome
            if (biome === 'Terra' || biome === 'Alien') {
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 250;
                    const z = (Math.random() - 0.5) * 250;
                    if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                        const tree = createLandingTree(biome);
                        tree.position.set(x, 0, z);
                        landingGame.scene.add(tree);
                        landingGame.environmentObjects.push(tree);
                    }
                }
            }

            // Add rocks/obstacles for all biomes
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                if (Math.abs(x) > 25 || Math.abs(z) > 25) {
                    const rock = createLandingRock(biome);
                    rock.position.set(x, 0, z);
                    landingGame.scene.add(rock);
                    landingGame.environmentObjects.push(rock);
                }
            }
        }

        function createLandingTree(biome) {
            const group = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15);
            const trunkColor = biome === 'Alien' ? 0x8800ff : 0x8B4513;
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: trunkColor });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(8, 8, 6);
            const foliageColor = biome === 'Alien' ? 0xff00ff : 0x228B22;
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: foliageColor });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 18;
            foliage.castShadow = true;
            group.add(foliage);

            return group;
        }

        function createLandingRock(biome) {
            const rockColors = {
                Terra: 0x888888,
                Desert: 0xaa5522,
                Ice: 0xaaccff,
                Volcanic: 0x333333,
                Alien: 0x00ffcc
            };
            const height = 5 + Math.random() * 15;
            const geometry = new THREE.DodecahedronGeometry(3 + Math.random() * 5, 0);
            const material = new THREE.MeshLambertMaterial({ color: rockColors[biome] || 0x888888 });
            const rock = new THREE.Mesh(geometry, material);
            rock.position.y = height / 2;
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.scale.y = height / 10;
            rock.castShadow = true;
            rock.receiveShadow = true;
            return rock;
        }

        function createLandingShip() {
            const shipGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(6, 2, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shipGroup.add(body);

            // Cockpit
            const cockpitGeometry = new THREE.SphereGeometry(2, 16, 16);
            const cockpitMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.y = 1.5;
            cockpit.scale.y = 0.6;
            shipGroup.add(cockpit);

            // Propeller arms and propellers
            landingGame.propellers = [];
            const propPositions = [
                [-4, 0.5, -4], [4, 0.5, -4],
                [-4, 0.5, 4], [4, 0.5, 4]
            ];

            propPositions.forEach(pos => {
                // Arm
                const armGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos[0] * 0.6, pos[1], pos[2] * 0.6);
                shipGroup.add(arm);

                // Propeller
                const propGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4);
                const propMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                const propeller = new THREE.Mesh(propGeometry, propMaterial);
                propeller.rotation.z = Math.PI / 2;
                propeller.position.set(...pos);
                propeller.castShadow = true;
                landingGame.propellers.push(propeller);
                shipGroup.add(propeller);
            });

            // Engine light
            landingGame.thrustLight = new THREE.PointLight(0x00ff00, 1, 15);
            landingGame.thrustLight.position.y = -1;
            shipGroup.add(landingGame.thrustLight);

            // Position ship at start
            shipGroup.position.set(
                (Math.random() - 0.5) * 40,
                LANDING_CONFIG.startAltitude,
                (Math.random() - 0.5) * 40
            );

            landingGame.ship = shipGroup;
            landingGame.scene.add(shipGroup);
        }

        function landingGameLoop(currentTime) {
            if (!landingGame.active) return;

            const deltaTime = (currentTime - landingGame.lastTime) / 1000;
            landingGame.lastTime = currentTime;

            if (deltaTime > 0 && deltaTime < 0.1) {
                updateLandingShip(deltaTime);
                checkLandingConditions();
                updateLandingUI();
            }

            // Rotate propellers
            landingGame.propellers.forEach(prop => {
                prop.rotation.y += deltaTime * 50;
            });

            // Blink beacon
            const blinkOn = Math.floor(currentTime / 500) % 2 === 0;
            if (landingGame.beaconLight) {
                landingGame.beaconLight.material.color.setHex(blinkOn ? 0xff0000 : 0x440000);
            }

            // Camera follow
            const cameraTarget = new THREE.Vector3(
                landingGame.ship.position.x * 0.3,
                0,
                landingGame.ship.position.z * 0.3
            );
            landingGame.camera.position.x = 100 + cameraTarget.x;
            landingGame.camera.position.z = 100 + cameraTarget.z;
            landingGame.camera.lookAt(cameraTarget);

            landingGame.renderer.render(landingGame.scene, landingGame.camera);
            landingGame.animFrame = requestAnimationFrame(landingGameLoop);
        }

        function updateLandingShip(deltaTime) {
            const ship = landingGame.ship;

            // Slow fuel drain
            landingGame.fuel = Math.max(0, landingGame.fuel - deltaTime * LANDING_CONFIG.fuelConsumption * 3);

            if (!landingGame.isManual && landingGame.fuel > 0) {
                // Autonomous flight - navigate to landing pad
                runLandingAutopilot(deltaTime);
            } else if (landingGame.isManual && landingGame.fuel > 0) {
                // Manual controls via keyboard
                applyManualLandingControls(deltaTime);
            }

            // Apply gentle gravity
            landingGame.velocity.y -= LANDING_CONFIG.gravity * deltaTime * 20;

            // Apply velocity (slower multiplier)
            ship.position.add(landingGame.velocity.clone().multiplyScalar(deltaTime * 25));

            // Tilt based on velocity
            ship.rotation.z = landingGame.velocity.x * 0.05;
            ship.rotation.x = -landingGame.velocity.z * 0.05;

            // Strong damping for smoother movement
            landingGame.velocity.multiplyScalar(0.96);

            // Keep within bounds
            ship.position.clamp(
                new THREE.Vector3(-LANDING_CONFIG.bounds, 2, -LANDING_CONFIG.bounds),
                new THREE.Vector3(LANDING_CONFIG.bounds, 100, LANDING_CONFIG.bounds)
            );

            // Update thrust light color based on mode
            if (landingGame.thrustLight) {
                landingGame.thrustLight.color.setHex(landingGame.isManual ? 0xff8800 : 0x00ff88);
                landingGame.thrustLight.intensity = 1 + Math.sin(Date.now() * 0.005) * 0.3;
            }
        }

        function runLandingAutopilot(deltaTime) {
            const ship = landingGame.ship;
            const padPos = new THREE.Vector3(0, 4, 0); // Target slightly above pad

            // Calculate direction to landing pad
            const direction = new THREE.Vector3().subVectors(padPos, ship.position);
            const horizontalDist = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
            const verticalDist = ship.position.y;

            // Desired velocity based on position - MUCH slower and gentler
            const desiredVelocity = new THREE.Vector3();

            // Horizontal movement - very gentle drift toward pad
            if (horizontalDist > 3) {
                desiredVelocity.x = direction.x * 0.015;  // Very slow horizontal
                desiredVelocity.z = direction.z * 0.015;
            }

            // Vertical movement - very controlled slow descent
            const slowDescent = -0.15;  // Very slow descent speed
            if (verticalDist > 25) {
                // High altitude - still slow descent
                desiredVelocity.y = slowDescent * 1.5;
            } else if (horizontalDist > 8) {
                // Not over pad yet - hover and drift
                desiredVelocity.y = -0.05;
            } else {
                // Over pad - very slow final descent
                desiredVelocity.y = slowDescent * 0.5;
            }

            // Very gentle lerp toward desired velocity
            landingGame.velocity.lerp(desiredVelocity, deltaTime * 0.8);

            // Counter gravity gently when needed
            if (landingGame.velocity.y < desiredVelocity.y - 0.05) {
                landingGame.velocity.y += LANDING_CONFIG.thrustPower * deltaTime * 30;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 0.5;
            }
        }

        function applyManualLandingControls(deltaTime) {
            const controlForce = LANDING_CONFIG.manualControl * deltaTime * 60;

            if (landingKeys['ArrowUp'] || landingKeys['w']) {
                landingGame.velocity.z -= controlForce;
            }
            if (landingKeys['ArrowDown'] || landingKeys['s']) {
                landingGame.velocity.z += controlForce;
            }
            if (landingKeys['ArrowLeft'] || landingKeys['a']) {
                landingGame.velocity.x -= controlForce;
            }
            if (landingKeys['ArrowRight'] || landingKeys['d']) {
                landingGame.velocity.x += controlForce;
            }
            if (landingKeys[' ']) {
                landingGame.velocity.y += controlForce * 1.5;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 2;
            }
            if (landingKeys['Shift']) {
                landingGame.velocity.y -= controlForce * 0.5;
            }
        }

        const landingKeys = {};

        function handleLandingKeyDown(e) {
            if (!landingGame.active) return;
            landingKeys[e.key] = true;

            if (e.key === 'Escape') {
                abortLanding();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleLandingMode();
            }

            // Auto-switch to manual if keys pressed
            if (!landingGame.isManual && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                landingGame.isManual = true;
                updateLandingModeUI();
                showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
            }

            e.preventDefault();
        }

        function handleLandingKeyUp(e) {
            landingKeys[e.key] = false;
        }

        function toggleLandingMode() {
            landingGame.isManual = !landingGame.isManual;
            updateLandingModeUI();
            showNotification(landingGame.isManual ? 'MANUAL CONTROL' : 'AUTOPILOT ENGAGED', 'info');
        }

        function updateLandingModeUI() {
            document.getElementById('landing-mode').textContent = landingGame.isManual ? 'Manual' : 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = landingGame.isManual ? 'Switch to Autonomous' : 'Switch to Manual';
        }

        function updateLandingUI() {
            const ship = landingGame.ship;
            const altitude = Math.max(0, ship.position.y - 1).toFixed(1);
            const speed = landingGame.velocity.length().toFixed(1);
            const padPos = new THREE.Vector3(0, 0, 0);
            const distance = Math.sqrt(
                Math.pow(ship.position.x - padPos.x, 2) +
                Math.pow(ship.position.z - padPos.z, 2)
            ).toFixed(1);

            document.getElementById('landing-altitude').textContent = altitude;
            document.getElementById('landing-speed').textContent = speed;
            document.getElementById('landing-fuel').textContent = Math.floor(landingGame.fuel);
            document.getElementById('landing-distance').textContent = distance;
        }

        function checkLandingConditions() {
            const ship = landingGame.ship;
            const altitude = ship.position.y;
            const speed = landingGame.velocity.length();
            const horizontalDist = Math.sqrt(ship.position.x * ship.position.x + ship.position.z * ship.position.z);

            // Check if landed
            if (altitude <= 3) {
                const onPad = horizontalDist < LANDING_CONFIG.landingPadSize;
                const slowEnough = speed < LANDING_CONFIG.safeSpeed;

                if (onPad && slowEnough) {
                    landingSuccess();
                } else if (!slowEnough) {
                    landingCrash('Too fast! Reduce speed before landing.');
                } else {
                    landingCrash('Missed the landing pad!');
                }
            }

            // Out of fuel
            if (landingGame.fuel <= 0 && altitude > 10) {
                landingCrash('Out of fuel!');
            }
        }

        function landingSuccess() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            const civ = landingGame.targetCiv;
            const bonusXp = Math.floor(landingGame.fuel * 2);

            cleanupLandingGame();

            showNotification(`Perfect landing on ${civ.name}! +${bonusXp} XP bonus!`, 'success');
            AudioSystem.levelUp();

            // Grant landing bonus XP
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(bonusXp / 6));
            });

            // Track successful landings
            gameData.statistics.successfulLandings = (gameData.statistics.successfulLandings || 0) + 1;

            // Now actually enter the world
            initWorld(civ);
        }

        function landingCrash(reason) {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            cleanupLandingGame();

            showNotification(`Crash landing! ${reason}`, 'error');
            AudioSystem.error();

            // Take damage
            gameData.player.hp = Math.max(1, gameData.player.hp - 20);
            updateHealthUI();

            // Track crashes
            gameData.statistics.crashLandings = (gameData.statistics.crashLandings || 0) + 1;

            mode = 'galaxy';
        }

        function abortLanding() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);
            cleanupLandingGame();
            mode = 'galaxy';
            showNotification('Landing aborted. Returning to orbit.', 'info');
        }

        function cleanupLandingGame() {
            document.getElementById('landing-overlay').style.display = 'none';
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
                const container = document.getElementById('landing-scene-container');
                if (container) container.innerHTML = '';
            }
            // Reset keys
            Object.keys(landingKeys).forEach(k => landingKeys[k] = false);
        }

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isTouchDevice = 'ontouchstart' in window;

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;
        let cycle = 0;

        // Floater pool for performance
        const floaterPool = [];
        const MAX_FLOATERS = 20;

        // RPG State
        let worldState = {
            player: null,
            terrain: [],
            interactables: [],
            fishingSpots: [],
            mobs: [],
            pois: [], // v4.2: Points of Interest
            sun: null,
            ambient: null,
            timeOfDay: 0,
            target: null,
            interactTarget: null,
            lastActionTime: 0, // v4.0: Cooldown-based interactions
            lastPlayerPos: null // v4.2: For distance tracking
        };

        // v5.5: Autonomous Exploration System
        let autoExplore = {
            enabled: true,  // Start in auto mode
            currentTarget: null,
            lastTargetTime: 0,
            targetCooldown: 3000,  // Time between target switches
            idleTime: 0,
            state: 'exploring',  // exploring, gathering, combat, idle
            combatTarget: null
        };

        function toggleAutoExplore() {
            autoExplore.enabled = !autoExplore.enabled;
            autoExplore.currentTarget = null;
            updateAutoExploreUI();
            showNotification(autoExplore.enabled ? 'AUTOPILOT: Exploring automatically' : 'MANUAL: You have control', 'info');
        }

        function updateAutoExploreUI() {
            const btn = document.getElementById('auto-explore-btn');
            const indicator = document.getElementById('auto-explore-indicator');
            if (btn) {
                btn.textContent = autoExplore.enabled ? 'Take Manual Control' : 'Enable Autopilot';
                btn.style.background = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
            if (indicator) {
                indicator.textContent = autoExplore.enabled ? 'ðŸ¤– AUTOPILOT' : 'ðŸŽ® MANUAL';
                indicator.style.color = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
        }

        function runAutoExplore(dt) {
            if (!autoExplore.enabled || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            // Priority 1: Combat - attack nearby enemies
            if (worldState.mobs.length > 0) {
                let nearestMob = null;
                let nearestDist = Infinity;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent) return;
                    const dist = player.position.distanceTo(mob.position);
                    if (dist < 25 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    autoExplore.state = 'combat';
                    autoExplore.combatTarget = nearestMob;

                    // Move toward mob if not in range
                    if (nearestDist > CONFIG.INTERACTION_RANGE) {
                        worldState.target = nearestMob.position.clone();
                        worldState.interactTarget = nearestMob;
                    } else {
                        // Attack!
                        worldState.target = null;
                        if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                            performAction(nearestMob);
                            worldState.lastActionTime = now;
                        }
                    }
                    return true;
                }
            }

            // Priority 2: Gather resources - only target actual harvestable resources
            let bestResource = null;
            let bestResourceDist = Infinity;

            // Check interactables for actual resources (trees, rocks, ores)
            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const name = obj.userData.name || '';
                // Only target actual resources, not decorations
                const isResource = name.includes('Tree') || name.includes('Rock') ||
                                   name.includes('Ore') || name.includes('Crystal') ||
                                   name.includes('Bush') || name.includes('Plant') ||
                                   name.includes('Mushroom') || name.includes('Herb');
                if (!isResource) return;

                const dist = player.position.distanceTo(obj.position);
                if (dist < 50 && dist < bestResourceDist) {
                    bestResourceDist = dist;
                    bestResource = obj;
                }
            });

            // Also check fishing spots
            if (!bestResource && worldState.fishingSpots) {
                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = player.position.distanceTo(spot.position);
                    if (dist < 50 && dist < bestResourceDist) {
                        bestResourceDist = dist;
                        bestResource = spot;
                    }
                });
            }

            if (bestResource) {
                autoExplore.state = 'gathering';
                autoExplore.currentTarget = null; // Clear random exploration target

                if (bestResourceDist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = bestResource.position.clone();
                    worldState.interactTarget = bestResource;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(bestResource);
                        worldState.lastActionTime = now;
                    }
                }
                return true;
            }

            // Priority 3: Explore - find new resources
            autoExplore.state = 'exploring';

            // Pick a new random target periodically or if stuck
            const stuckCheck = autoExplore.currentTarget &&
                player.position.distanceTo(autoExplore.currentTarget) === autoExplore.lastDistToTarget;

            if (stuckCheck) {
                autoExplore.stuckCounter = (autoExplore.stuckCounter || 0) + 1;
            } else {
                autoExplore.stuckCounter = 0;
            }
            autoExplore.lastDistToTarget = autoExplore.currentTarget ?
                player.position.distanceTo(autoExplore.currentTarget) : 0;

            // Pick new target if: no target, timeout, or stuck
            if (!autoExplore.currentTarget ||
                now - autoExplore.lastTargetTime > autoExplore.targetCooldown ||
                autoExplore.stuckCounter > 60) {

                // Try to find an unexplored area with resources
                let foundTarget = false;

                // Search for any resource in a wider area
                let anyResource = null;
                let anyResourceDist = Infinity;

                worldState.interactables.forEach(obj => {
                    if (!obj.parent) return;
                    const dist = player.position.distanceTo(obj.position);
                    if (dist > 10 && dist < anyResourceDist) { // Not too close, not too far
                        anyResourceDist = dist;
                        anyResource = obj;
                    }
                });

                if (anyResource && anyResourceDist < 100) {
                    autoExplore.currentTarget = anyResource.position.clone();
                    foundTarget = true;
                }

                // If no resources found, pick a random direction
                if (!foundTarget) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 20 + Math.random() * 20;
                    autoExplore.currentTarget = new THREE.Vector3(
                        player.position.x + Math.cos(angle) * distance,
                        0,
                        player.position.z + Math.sin(angle) * distance
                    );
                }

                // Clamp to world bounds
                autoExplore.currentTarget.x = Math.max(-45, Math.min(45, autoExplore.currentTarget.x));
                autoExplore.currentTarget.z = Math.max(-45, Math.min(45, autoExplore.currentTarget.z));
                autoExplore.lastTargetTime = now;
                autoExplore.stuckCounter = 0;
            }

            worldState.target = autoExplore.currentTarget;

            // Check if reached target
            if (autoExplore.currentTarget && player.position.distanceTo(autoExplore.currentTarget) < 3) {
                autoExplore.currentTarget = null;
            }

            return true;
        }

        // WASD Keyboard controls
        const keys = { w: false, a: false, s: false, d: false };

        // Persistent Game Data (saved to localStorage)
        let gameData = {
            version: VERSION,
            playtime: 0,
            lastPlayed: null,
            hasSeenTutorial: false, // v4.0: Tutorial tracking
            inventory: [],
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 },
                fishing: { level: 1, xp: 0 },
                cooking: { level: 1, xp: 0 },
                crafting: { level: 1, xp: 0 }
            },
            player: {
                hp: CONFIG.PLAYER_MAX_HP,
                maxHp: CONFIG.PLAYER_MAX_HP
            },
            visitedPlanets: [],
            statistics: {
                treesChopped: 0,
                oresMined: 0,
                mobsKilled: 0,
                fishCaught: 0,
                itemsCrafted: 0,
                fishCooked: 0,
                // v4.2: New stats
                poisDiscovered: 0,
                totalDamageDealt: 0,
                bossesDefeated: 0,
                distanceTraveled: 0
            },
            // v4.2: Player rank tracking
            playerRank: { points: 0, lastTitle: 'Novice Explorer' },
            // v4.2: Discovered POIs by planet
            discoveredPOIs: {},
            // v4.1: Achievement System
            achievements: {},
            // v4.1: Daily Challenge System
            dailyChallenge: {
                lastGenerated: null,
                completed: false,
                current: null,
                streak: 0,
                bestStreak: 0
            },
            // v4.4: Prestige System
            prestige: {
                level: 0,
                totalLifetimePoints: 0,
                bonuses: {
                    xpMultiplier: 1.0,
                    startingSkillBonus: 0
                }
            },
            // v4.4: Fog of War exploration tracking per planet
            exploredTiles: {},
            // v4.6: Settings
            settings: {
                masterVolume: 30,
                sfxEnabled: true,
                ambientEnabled: true,
                particleQuality: 'high',
                shadowsEnabled: true,
                screenShakeEnabled: true,
                hintsEnabled: true
            },
            // v5.1: Equipment slots
            equipment: {
                weapon: null,
                armor: null,
                accessory: null,
                tool: null
            },
            // v5.1: Item enchantments
            enchantments: {},
            // v5.2: Talent tree points
            talents: {}
        };

        // v4.4: Simulated Leaderboard Players for local comparison
        const SIMULATED_PLAYERS = [
            { name: 'StarSeeker_X', points: 500, rank: 'Pathfinder' },
            { name: 'CosmicNova', points: 2500, rank: 'Star Scout' },
            { name: 'VoidWalker99', points: 8000, rank: 'Galaxy Ranger' },
            { name: 'AstroLegend', points: 12000, rank: 'Void Hunter' },
            { name: 'NebulaKing', points: 18000, rank: 'Cosmic Legend' },
            { name: 'Explorer42', points: 150, rank: 'Wanderer' },
            { name: 'SpaceCadet', points: 350, rank: 'Wanderer' },
            { name: 'Starlight', points: 1200, rank: 'Pathfinder' }
        ];

        // v4.4: Prestige requirements and rewards
        const PRESTIGE_LEVELS = {
            1: { required: 15000, xpBonus: 0.10, skillBonus: 0 },
            2: { required: 20000, xpBonus: 0.10, skillBonus: 1 },
            3: { required: 30000, xpBonus: 0.15, skillBonus: 1 },
            4: { required: 50000, xpBonus: 0.20, skillBonus: 2 },
            5: { required: 100000, xpBonus: 0.25, skillBonus: 3 }
        };

        function canPrestige() {
            const currentLevel = gameData.prestige?.level || 0;
            const nextLevel = PRESTIGE_LEVELS[currentLevel + 1];
            if (!nextLevel) return false;
            return calculatePlayerPoints() >= nextLevel.required;
        }

        function performPrestige() {
            if (!canPrestige()) return false;

            const currentLevel = gameData.prestige?.level || 0;
            const newLevel = currentLevel + 1;
            const reward = PRESTIGE_LEVELS[newLevel];

            // Store lifetime stats
            const lifetimePoints = (gameData.prestige?.totalLifetimePoints || 0) + calculatePlayerPoints();

            // Calculate cumulative bonuses
            const newXpMultiplier = 1.0 + Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.xpBonus, 0);
            const newSkillBonus = Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.skillBonus, 0);

            // Keep achievements and daily challenge
            const keepData = {
                achievements: { ...gameData.achievements },
                dailyChallenge: { ...gameData.dailyChallenge },
                hasSeenTutorial: true,
                prestige: {
                    level: newLevel,
                    totalLifetimePoints: lifetimePoints,
                    bonuses: {
                        xpMultiplier: newXpMultiplier,
                        startingSkillBonus: newSkillBonus
                    }
                }
            };

            // Reset everything else
            gameData.version = VERSION;
            gameData.playtime = 0;
            gameData.inventory = [];
            gameData.visitedPlanets = [];
            gameData.discoveredPOIs = {};
            gameData.exploredTiles = {};
            gameData.playerRank = { points: 0, lastTitle: 'Novice Explorer' };

            // Reset skills with prestige bonus
            for (const skill of Object.keys(gameData.skills)) {
                gameData.skills[skill] = { level: 1 + newSkillBonus, xp: 0 };
            }

            // Reset statistics
            for (const stat of Object.keys(gameData.statistics)) {
                gameData.statistics[stat] = 0;
            }

            gameData.player = { hp: CONFIG.PLAYER_MAX_HP, maxHp: CONFIG.PLAYER_MAX_HP };

            // Restore kept data
            Object.assign(gameData, keepData);

            saveGameData();
            showNotification(`PRESTIGE ${newLevel}! XP +${Math.round((newXpMultiplier - 1) * 100)}%`, 'success');
            AudioSystem.levelUp();
            return true;
        }

        function getLeaderboardPosition() {
            const myPoints = calculatePlayerPoints();
            const allPlayers = [...SIMULATED_PLAYERS, { name: 'YOU', points: myPoints, rank: getPlayerRank().title }]
                .sort((a, b) => b.points - a.points);
            const myIndex = allPlayers.findIndex(p => p.name === 'YOU');
            return {
                position: myIndex + 1,
                total: allPlayers.length,
                nearby: allPlayers.slice(Math.max(0, myIndex - 2), myIndex + 3)
            };
        }

        // --- ACHIEVEMENT DEFINITIONS ---
        const ACHIEVEMENTS = {
            'first_landing': { name: 'First Contact', desc: 'Land on your first planet', icon: 'ðŸŒ' },
            'explorer_10': { name: 'Star Hopper', desc: 'Visit 10 different planets', icon: 'âœ¨' },
            'explorer_30': { name: 'Galaxy Wanderer', desc: 'Visit 30 planets', icon: 'ðŸš€' },
            'lumberjack_25': { name: 'Woodcutter', desc: 'Chop 25 trees', icon: 'ðŸª“' },
            'lumberjack_100': { name: 'Lumberjack', desc: 'Chop 100 trees', icon: 'ðŸŒ²' },
            'miner_25': { name: 'Prospector', desc: 'Mine 25 ore veins', icon: 'â›ï¸' },
            'miner_100': { name: 'Master Miner', desc: 'Mine 100 ore veins', icon: 'ðŸ’Ž' },
            'angler_10': { name: 'Fisherman', desc: 'Catch 10 fish', icon: 'ðŸŸ' },
            'angler_50': { name: 'Master Angler', desc: 'Catch 50 fish', icon: 'ðŸŽ£' },
            'slayer_10': { name: 'Slime Slayer', desc: 'Defeat 10 slimes', icon: 'âš”ï¸' },
            'slayer_50': { name: 'Exterminator', desc: 'Defeat 50 slimes', icon: 'ðŸ’€' },
            'crafter_10': { name: 'Apprentice', desc: 'Craft 10 items', icon: 'ðŸ”¨' },
            'crafter_50': { name: 'Master Craftsman', desc: 'Craft 50 items', icon: 'ðŸ†' },
            'max_skill': { name: 'Specialist', desc: 'Reach level 10 in any skill', icon: 'ðŸ“ˆ' },
            'playtime_1h': { name: 'Dedicated', desc: 'Play for 1 hour', icon: 'â°' },
            'survivor': { name: 'Survivor', desc: 'Heal 500 HP total', icon: 'â¤ï¸' },
            'daily_3': { name: 'Consistent', desc: 'Complete 3 daily challenges', icon: 'ðŸ“…' },
            'daily_7': { name: 'Weekly Warrior', desc: 'Complete 7 daily challenges', icon: 'ðŸ”¥' }
        };

        // --- DAILY CHALLENGE DEFINITIONS ---
        const DAILY_CHALLENGES = [
            { type: 'gather_logs', amount: 15, desc: 'Gather 15 logs', reward: { skill: 'wood', xp: 150 } },
            { type: 'gather_ore', amount: 12, desc: 'Mine 12 ore', reward: { skill: 'mining', xp: 150 } },
            { type: 'kill_mobs', amount: 5, desc: 'Defeat 5 slimes', reward: { skill: 'combat', xp: 200 } },
            { type: 'catch_fish', amount: 8, desc: 'Catch 8 fish', reward: { skill: 'fishing', xp: 150 } },
            { type: 'craft_items', amount: 3, desc: 'Craft 3 items', reward: { skill: 'crafting', xp: 100 } },
            { type: 'visit_planets', amount: 2, desc: 'Explore 2 new planets', reward: { skill: 'combat', xp: 200 } },
            { type: 'cook_fish', amount: 3, desc: 'Cook 3 fish', reward: { skill: 'cooking', xp: 120 } }
        ];

        // Tutorial functions
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            gameData.hasSeenTutorial = true;
            saveGameData();
            AudioSystem.click();
        }

        // --- ACHIEVEMENT SYSTEM ---
        function checkAchievements() {
            const s = gameData.statistics;
            const sk = gameData.skills;

            const checks = {
                'first_landing': () => gameData.visitedPlanets.length >= 1,
                'explorer_10': () => gameData.visitedPlanets.length >= 10,
                'explorer_30': () => gameData.visitedPlanets.length >= 30,
                'lumberjack_25': () => s.treesChopped >= 25,
                'lumberjack_100': () => s.treesChopped >= 100,
                'miner_25': () => s.oresMined >= 25,
                'miner_100': () => s.oresMined >= 100,
                'angler_10': () => s.fishCaught >= 10,
                'angler_50': () => s.fishCaught >= 50,
                'slayer_10': () => s.mobsKilled >= 10,
                'slayer_50': () => s.mobsKilled >= 50,
                'crafter_10': () => s.itemsCrafted >= 10,
                'crafter_50': () => s.itemsCrafted >= 50,
                'max_skill': () => Object.values(sk).some(skill => skill.level >= 10),
                'playtime_1h': () => gameData.playtime >= 3600,
                'survivor': () => (s.totalHealed || 0) >= 500,
                'daily_3': () => (gameData.dailyChallenge.completedCount || 0) >= 3,
                'daily_7': () => (gameData.dailyChallenge.completedCount || 0) >= 7
            };

            for (const [id, check] of Object.entries(checks)) {
                if (!gameData.achievements[id] && check()) {
                    unlockAchievement(id);
                }
            }
        }

        function unlockAchievement(id) {
            if (gameData.achievements[id]) return;

            const ach = ACHIEVEMENTS[id];
            if (!ach) return;

            gameData.achievements[id] = { unlockedAt: new Date().toISOString() };

            // Show achievement popup
            showAchievementPopup(ach.icon, ach.name, ach.desc);
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 25, 0xffd700, { spread: 6, lifetime: 1500 });
            }

            saveGameData();
        }

        function showAchievementPopup(icon, name, desc) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div class="ach-icon">${icon}</div>
                <div class="ach-text">
                    <div class="ach-title">Achievement Unlocked!</div>
                    <div class="ach-name">${name}</div>
                    <div class="ach-desc">${desc}</div>
                </div>
            `;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 4000);
        }

        // --- DAILY CHALLENGE SYSTEM ---
        function generateDailyChallenge() {
            const today = new Date().toDateString();

            if (gameData.dailyChallenge.lastGenerated === today && gameData.dailyChallenge.current) {
                return gameData.dailyChallenge.current;
            }

            // Reset streak if missed a day
            if (gameData.dailyChallenge.lastGenerated) {
                const lastDate = new Date(gameData.dailyChallenge.lastGenerated);
                const now = new Date();
                const diffDays = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
                if (diffDays > 1) {
                    gameData.dailyChallenge.streak = 0;
                }
            }

            // Use date as seed for consistent daily challenge
            const seed = new SeededRNG(today);
            const template = seed.pick(DAILY_CHALLENGES);
            const challenge = {
                ...template,
                progress: 0,
                startStats: { ...gameData.statistics },
                startPlanets: gameData.visitedPlanets.length
            };

            gameData.dailyChallenge.lastGenerated = today;
            gameData.dailyChallenge.current = challenge;
            gameData.dailyChallenge.completed = false;
            saveGameData();

            return challenge;
        }

        function updateDailyChallengeProgress() {
            if (!gameData.dailyChallenge.current || gameData.dailyChallenge.completed) return;

            const c = gameData.dailyChallenge.current;
            const start = c.startStats || {};
            const now = gameData.statistics;

            switch (c.type) {
                case 'gather_logs': c.progress = (now.treesChopped || 0) - (start.treesChopped || 0); break;
                case 'gather_ore': c.progress = (now.oresMined || 0) - (start.oresMined || 0); break;
                case 'kill_mobs': c.progress = (now.mobsKilled || 0) - (start.mobsKilled || 0); break;
                case 'catch_fish': c.progress = (now.fishCaught || 0) - (start.fishCaught || 0); break;
                case 'craft_items': c.progress = (now.itemsCrafted || 0) - (start.itemsCrafted || 0); break;
                case 'cook_fish': c.progress = (now.fishCooked || 0) - (start.fishCooked || 0); break;
                case 'visit_planets': c.progress = gameData.visitedPlanets.length - (c.startPlanets || 0); break;
            }

            if (c.progress >= c.amount && !gameData.dailyChallenge.completed) {
                completeDailyChallenge();
            }

            updateDailyChallengeUI();
        }

        function completeDailyChallenge() {
            gameData.dailyChallenge.completed = true;
            gameData.dailyChallenge.streak++;
            gameData.dailyChallenge.completedCount = (gameData.dailyChallenge.completedCount || 0) + 1;
            gameData.dailyChallenge.bestStreak = Math.max(gameData.dailyChallenge.bestStreak || 0, gameData.dailyChallenge.streak);

            // Apply reward with streak bonus
            const reward = gameData.dailyChallenge.current.reward;
            const streakMultiplier = 1 + (gameData.dailyChallenge.streak * 0.1);
            const xpReward = Math.floor(reward.xp * streakMultiplier);

            addXp(reward.skill, xpReward);

            showNotification(`Daily Challenge Complete! +${xpReward} ${reward.skill} XP (Streak: ${gameData.dailyChallenge.streak})`);
            AudioSystem.levelUp();

            checkAchievements();
            saveGameData();
        }

        function updateDailyChallengeUI() {
            const el = document.getElementById('daily-challenge');
            if (!el) return;

            const c = gameData.dailyChallenge.current;
            if (!c) {
                el.style.display = 'none';
                return;
            }

            el.style.display = 'block';
            document.getElementById('daily-desc').textContent = c.desc;
            document.getElementById('daily-progress-text').textContent = `${Math.min(c.progress || 0, c.amount)}/${c.amount}`;
            document.getElementById('daily-progress-fill').style.width = `${Math.min(100, ((c.progress || 0) / c.amount) * 100)}%`;
            document.getElementById('daily-streak').textContent = `Streak: ${gameData.dailyChallenge.streak} days`;

            if (gameData.dailyChallenge.completed) {
                el.classList.add('completed');
            } else {
                el.classList.remove('completed');
            }
        }

        // --- v4.2: PLAYER RANK SYSTEM ---
        function calculatePlayerPoints() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            return (
                gameData.visitedPlanets.length * 50 +
                s.treesChopped * 2 +
                s.oresMined * 2 +
                s.mobsKilled * 10 +
                s.fishCaught * 3 +
                s.itemsCrafted * 5 +
                (s.poisDiscovered || 0) * 100 +
                Object.values(sk).reduce((sum, skill) => sum + skill.level * 20, 0) +
                Math.floor(gameData.playtime / 60)
            );
        }

        function getPlayerRank() {
            const points = calculatePlayerPoints();
            let rank = PLAYER_RANKS[0];
            for (const r of PLAYER_RANKS) {
                if (points >= r.points) rank = r;
            }
            return { ...rank, points };
        }

        function getSpecialTitles() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            const titles = [];
            for (const [name, data] of Object.entries(SPECIAL_TITLES)) {
                if (data.condition(s, sk)) {
                    titles.push({ name, color: data.color });
                }
            }
            return titles;
        }

        function updatePlayerRank() {
            const rank = getPlayerRank();
            const oldTitle = gameData.playerRank?.lastTitle || 'Novice Explorer';

            gameData.playerRank = {
                points: rank.points,
                lastTitle: rank.title
            };

            // Show rank up notification
            if (rank.title !== oldTitle) {
                showNotification(`RANK UP! You are now: ${rank.title}`, 'success');
                AudioSystem.levelUp();
            }

            saveGameData();
        }

        // --- STATISTICS PANEL ---
        function showStatsPanel() {
            updateStatsDisplay();
            document.getElementById('stats-modal').style.display = 'flex';
        }

        function closeStatsModal() {
            document.getElementById('stats-modal').style.display = 'none';
        }

        // v4.9: Collection Codex System
        const CODEX_DATA = {
            creatures: [
                { id: 'wolf', name: 'Wolf', icon: 'ðŸº', biome: 'forest', description: 'A fierce forest predator' },
                { id: 'bear', name: 'Bear', icon: 'ðŸ»', biome: 'forest', description: 'Massive and dangerous' },
                { id: 'snake', name: 'Snake', icon: 'ðŸ', biome: 'desert', description: 'Venomous desert dweller' },
                { id: 'scorpion', name: 'Scorpion', icon: 'ðŸ¦‚', biome: 'desert', description: 'Deadly desert creature' },
                { id: 'yeti', name: 'Yeti', icon: 'ðŸ¦', biome: 'arctic', description: 'Legendary snow beast' },
                { id: 'penguin', name: 'Penguin', icon: 'ðŸ§', biome: 'arctic', description: 'Hardy arctic bird' },
                { id: 'shark', name: 'Shark', icon: 'ðŸ¦ˆ', biome: 'ocean', description: 'Apex ocean predator' },
                { id: 'octopus', name: 'Octopus', icon: 'ðŸ™', biome: 'ocean', description: 'Intelligent sea creature' },
                { id: 'dragon', name: 'Dragon', icon: 'ðŸ‰', biome: 'volcanic', description: 'Ancient fire-breathing beast' },
                { id: 'phoenix', name: 'Phoenix', icon: 'ðŸ”¥', biome: 'volcanic', description: 'Immortal flame bird' },
                { id: 'alien', name: 'Alien', icon: 'ðŸ‘½', biome: 'alien', description: 'Extraterrestrial lifeform' },
                { id: 'robot', name: 'Robot', icon: 'ðŸ¤–', biome: 'crystal', description: 'Mechanical guardian' },
                { id: 'elite', name: 'Elite Monster', icon: 'ðŸ‘¹', biome: 'any', description: 'Powerful elite creature' },
                { id: 'boss', name: 'World Boss', icon: 'ðŸ’€', biome: 'any', description: 'Legendary boss creature' }
            ],
            biomes: [
                { id: 'forest', name: 'Forest World', icon: 'ðŸŒ²', color: '#228B22' },
                { id: 'desert', name: 'Desert World', icon: 'ðŸœï¸', color: '#DEB887' },
                { id: 'arctic', name: 'Arctic World', icon: 'â„ï¸', color: '#87CEEB' },
                { id: 'ocean', name: 'Ocean World', icon: 'ðŸŒŠ', color: '#1E90FF' },
                { id: 'volcanic', name: 'Volcanic World', icon: 'ðŸŒ‹', color: '#FF4500' },
                { id: 'alien', name: 'Alien World', icon: 'ðŸ›¸', color: '#9400D3' },
                { id: 'crystal', name: 'Crystal World', icon: 'ðŸ’Ž', color: '#00CED1' },
                { id: 'mushroom', name: 'Mushroom World', icon: 'ðŸ„', color: '#FF69B4' }
            ]
        };

        function initCodexTracking() {
            if (!gameData.codex) {
                gameData.codex = {
                    creatures: {},
                    items: {},
                    biomes: {}
                };
            }
        }

        function trackCreatureKill(creatureType) {
            initCodexTracking();
            if (!gameData.codex.creatures[creatureType]) {
                gameData.codex.creatures[creatureType] = { count: 0, firstKill: Date.now() };
                showNotification(`New Codex Entry: ${creatureType}!`, 'success');
            }
            gameData.codex.creatures[creatureType].count++;
        }

        function trackItemDiscovery(itemName) {
            initCodexTracking();
            if (!gameData.codex.items[itemName]) {
                gameData.codex.items[itemName] = { count: 0, firstFound: Date.now() };
            }
            gameData.codex.items[itemName].count++;
        }

        function trackBiomeVisit(biomeType) {
            initCodexTracking();
            if (!gameData.codex.biomes[biomeType]) {
                gameData.codex.biomes[biomeType] = { visited: true, firstVisit: Date.now() };
                showNotification(`New Biome Discovered: ${biomeType}!`, 'success');
            }
        }

        function openCodexModal() {
            initCodexTracking();
            updateCodexDisplay();
            document.getElementById('codex-modal').style.display = 'flex';
        }

        function closeCodexModal() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        function switchCodexTab(tab) {
            document.querySelectorAll('.codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.codex-content').forEach(c => c.style.display = 'none');
            document.querySelector(`.codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`codex-${tab}`).style.display = 'block';
        }

        function updateCodexDisplay() {
            // Creatures
            const creaturesGrid = document.getElementById('codex-creatures-grid');
            let creaturesHtml = '';
            let discoveredCreatures = 0;
            CODEX_DATA.creatures.forEach(c => {
                const discovered = gameData.codex?.creatures?.[c.id];
                if (discovered) discoveredCreatures++;
                creaturesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? c.description : '???'}">
                        <span class="entry-icon">${c.icon}</span>
                        <span class="entry-name">${discovered ? c.name : '???'}</span>
                        ${discovered ? `<span class="entry-count">Defeated: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            creaturesGrid.innerHTML = creaturesHtml;
            document.getElementById('codex-creatures-count').textContent = discoveredCreatures;
            document.getElementById('codex-creatures-total').textContent = CODEX_DATA.creatures.length;

            // Items
            const itemsGrid = document.getElementById('codex-items-grid');
            let itemsHtml = '';
            let discoveredItems = 0;
            const allItems = Object.keys(ITEMS);
            allItems.forEach(itemName => {
                const item = ITEMS[itemName];
                const discovered = gameData.codex?.items?.[itemName];
                if (discovered) discoveredItems++;
                itemsHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? (item.description || itemName) : '???'}">
                        <span class="entry-icon">${item.icon || 'ðŸ“¦'}</span>
                        <span class="entry-name">${discovered ? itemName : '???'}</span>
                        ${discovered ? `<span class="entry-count">Found: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            itemsGrid.innerHTML = itemsHtml;
            document.getElementById('codex-items-count').textContent = discoveredItems;
            document.getElementById('codex-items-total').textContent = allItems.length;

            // Biomes
            const biomesGrid = document.getElementById('codex-biomes-grid');
            let biomesHtml = '';
            let discoveredBiomes = 0;
            CODEX_DATA.biomes.forEach(b => {
                const discovered = gameData.codex?.biomes?.[b.id];
                if (discovered) discoveredBiomes++;
                biomesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" style="${discovered ? `border-color: ${b.color}` : ''}">
                        <span class="entry-icon">${b.icon}</span>
                        <span class="entry-name">${discovered ? b.name : '???'}</span>
                    </div>
                `;
            });
            biomesGrid.innerHTML = biomesHtml;
            document.getElementById('codex-biomes-count').textContent = discoveredBiomes;
            document.getElementById('codex-biomes-total').textContent = CODEX_DATA.biomes.length;

            // Abilities
            const abilitiesGrid = document.getElementById('codex-abilities-grid');
            let abilitiesHtml = '';
            let unlockedAbilities = 0;
            const combatLevel = gameData.skills?.combat?.level || 1;
            Object.entries(COMBAT_ABILITIES).forEach(([key, ability]) => {
                const unlocked = combatLevel >= ability.unlockLevel;
                if (unlocked) unlockedAbilities++;
                abilitiesHtml += `
                    <div class="codex-entry ${unlocked ? 'discovered' : 'undiscovered'}" title="${unlocked ? ability.description : `Unlocks at Combat Lv ${ability.unlockLevel}`}">
                        <span class="entry-icon">${ability.icon}</span>
                        <span class="entry-name">${unlocked ? ability.name : '???'}</span>
                        <span class="entry-count">${unlocked ? `[${ability.key}]` : `Lv ${ability.unlockLevel}`}</span>
                    </div>
                `;
            });
            abilitiesGrid.innerHTML = abilitiesHtml;
            document.getElementById('codex-abilities-count').textContent = unlockedAbilities;
            document.getElementById('codex-abilities-total').textContent = Object.keys(COMBAT_ABILITIES).length;

            // v5.0: Pets
            initPetSystem();
            const petsGrid = document.getElementById('codex-pets-grid');
            let petsHtml = '';
            let collectedPets = 0;
            const ownedPets = gameData.pets?.owned || [];
            const activePet = gameData.pets?.active;

            Object.entries(PET_TYPES).forEach(([petId, pet]) => {
                const owned = ownedPets.includes(petId);
                const isActive = activePet === petId;
                if (owned) collectedPets++;

                petsHtml += `
                    <div class="codex-entry ${owned ? 'discovered' : 'undiscovered'} ${isActive ? 'active-pet' : ''}"
                         style="${owned ? `border-color: ${RARITY_COLORS[pet.rarity]}` : ''}; ${isActive ? 'box-shadow: 0 0 10px ' + RARITY_COLORS[pet.rarity] : ''}"
                         title="${owned ? pet.abilityDesc : '???'}"
                         onclick="${owned ? `setActivePet('${isActive ? '' : petId}')` : ''}">
                        <span class="entry-icon" style="font-size: 32px;">${pet.icon}</span>
                        <span class="entry-name" style="color: ${owned ? RARITY_COLORS[pet.rarity] : '#666'}">${owned ? pet.name : '???'}</span>
                        ${owned ? `<span class="entry-count" style="color: ${RARITY_COLORS[pet.rarity]}">${pet.rarity.toUpperCase()}</span>` : ''}
                        ${owned ? `<span style="font-size: 10px; color: #aaa;">${pet.abilityDesc}</span>` : ''}
                        ${isActive ? '<span style="color: #ff8c00; font-size: 10px;">ACTIVE</span>' : ''}
                    </div>
                `;
            });
            petsGrid.innerHTML = petsHtml;
            document.getElementById('codex-pets-count').textContent = collectedPets;
            document.getElementById('codex-pets-total').textContent = Object.keys(PET_TYPES).length;
            document.getElementById('active-pet-name').textContent = activePet ? PET_TYPES[activePet].name : 'None';
        }

        // v5.0: Quest System
        const QUEST_TEMPLATES = {
            daily: [
                { id: 'kill_mobs', name: 'Monster Hunter', desc: 'Defeat enemies', icon: 'âš”ï¸', target: 10, reward: { xp: 500, item: 'Health Potion' }, stat: 'mobsKilled' },
                { id: 'gather_wood', name: 'Lumberjack', desc: 'Chop down trees', icon: 'ðŸª“', target: 15, reward: { xp: 300 }, stat: 'treesChopped' },
                { id: 'mine_ore', name: 'Prospector', desc: 'Mine ore deposits', icon: 'â›ï¸', target: 10, reward: { xp: 400, item: 'Iron Ore' }, stat: 'oresMined' },
                { id: 'catch_fish', name: 'Angler', desc: 'Catch fish', icon: 'ðŸŽ£', target: 8, reward: { xp: 350 }, stat: 'fishCaught' },
                { id: 'visit_planets', name: 'Explorer', desc: 'Visit different planets', icon: 'ðŸŒ', target: 3, reward: { xp: 600 }, stat: 'planetsVisited' },
                { id: 'craft_items', name: 'Artisan', desc: 'Craft items', icon: 'ðŸ”¨', target: 5, reward: { xp: 400, item: 'Super Potion' }, stat: 'itemsCrafted' },
                { id: 'use_abilities', name: 'Ability Master', desc: 'Use combat abilities', icon: 'âœ¨', target: 20, reward: { xp: 450 }, stat: 'abilitiesUsed' },
                { id: 'kill_elites', name: 'Elite Slayer', desc: 'Defeat elite enemies', icon: 'ðŸ‘¹', target: 2, reward: { xp: 800, item: 'Void Fragment' }, stat: 'elitesKilled' }
            ],
            weekly: [
                { id: 'w_kill_mobs', name: 'Monster Massacre', desc: 'Defeat many enemies', icon: 'ðŸ’€', target: 100, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'mobsKilled' },
                { id: 'w_bosses', name: 'Boss Hunter', desc: 'Defeat world bosses', icon: 'ðŸ‰', target: 5, reward: { xp: 8000 }, stat: 'bossesDefeated' },
                { id: 'w_explore', name: 'Galactic Explorer', desc: 'Visit many planets', icon: 'ðŸš€', target: 15, reward: { xp: 6000 }, stat: 'planetsVisited' },
                { id: 'w_gather', name: 'Resource Mogul', desc: 'Gather total resources', icon: 'ðŸ“¦', target: 200, reward: { xp: 4000, item: 'Super Potion' }, stat: 'totalGathered' },
                { id: 'w_combat', name: 'Combat Veteran', desc: 'Deal damage with abilities', icon: 'âš¡', target: 50, reward: { xp: 5500 }, stat: 'abilitiesUsed' }
            ],
            story: [
                { id: 's_first_kill', name: 'First Blood', desc: 'Defeat your first enemy', icon: 'ðŸ©¸', target: 1, reward: { xp: 100 }, stat: 'mobsKilled', oneTime: true },
                { id: 's_first_planet', name: 'First Steps', desc: 'Visit your first planet', icon: 'ðŸ‘£', target: 1, reward: { xp: 200 }, stat: 'planetsVisited', oneTime: true },
                { id: 's_craft_weapon', name: 'Armed and Ready', desc: 'Craft a weapon', icon: 'ðŸ—¡ï¸', target: 1, reward: { xp: 300, item: 'Health Potion' }, stat: 'weaponsCrafted', oneTime: true },
                { id: 's_level_combat', name: 'Warrior\'s Path', desc: 'Reach Combat Level 5', icon: 'âš”ï¸', target: 5, reward: { xp: 500 }, stat: 'combatLevel', oneTime: true },
                { id: 's_first_boss', name: 'Giant Slayer', desc: 'Defeat a world boss', icon: 'ðŸ†', target: 1, reward: { xp: 1000, item: 'Magma Sword' }, stat: 'bossesDefeated', oneTime: true },
                { id: 's_master_combat', name: 'Combat Master', desc: 'Reach Combat Level 15', icon: 'ðŸŽ–ï¸', target: 15, reward: { xp: 2000 }, stat: 'combatLevel', oneTime: true },
                { id: 's_explore_all', name: 'Galaxy Conqueror', desc: 'Visit 30 planets', icon: 'ðŸŒŒ', target: 30, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'planetsVisited', oneTime: true },
                { id: 's_ultimate', name: 'Legendary Hero', desc: 'Reach Combat Level 20', icon: 'ðŸ‘‘', target: 20, reward: { xp: 10000 }, stat: 'combatLevel', oneTime: true }
            ]
        };

        function initQuestSystem() {
            if (!gameData.quests) {
                gameData.quests = {
                    daily: { quests: [], lastReset: 0, sessionStart: {} },
                    weekly: { quests: [], lastReset: 0, sessionStart: {} },
                    story: { completed: [], claimed: [] }
                };
            }
            checkQuestResets();
        }

        function checkQuestResets() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            // Daily reset (every 24 hours from first play)
            if (now - gameData.quests.daily.lastReset > dayMs) {
                generateDailyQuests();
            }

            // Weekly reset (every 7 days)
            if (now - gameData.quests.weekly.lastReset > weekMs) {
                generateWeeklyQuests();
            }
        }

        function generateDailyQuests() {
            const shuffled = [...QUEST_TEMPLATES.daily].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 3);

            gameData.quests.daily = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function generateWeeklyQuests() {
            const shuffled = [...QUEST_TEMPLATES.weekly].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 2);

            gameData.quests.weekly = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function captureQuestStats() {
            const s = gameData.statistics;
            return {
                mobsKilled: s.mobsKilled || 0,
                treesChopped: s.treesChopped || 0,
                oresMined: s.oresMined || 0,
                fishCaught: s.fishCaught || 0,
                planetsVisited: gameData.visitedPlanets.length,
                itemsCrafted: s.itemsCrafted || 0,
                bossesDefeated: s.bossesDefeated || 0,
                elitesKilled: s.elitesKilled || 0,
                abilitiesUsed: s.abilitiesUsed || 0,
                totalGathered: (s.treesChopped || 0) + (s.oresMined || 0) + (s.fishCaught || 0),
                combatLevel: gameData.skills?.combat?.level || 1,
                weaponsCrafted: s.weaponsCrafted || 0
            };
        }

        function getQuestProgress(quest, type) {
            const current = captureQuestStats();
            const start = gameData.quests[type]?.sessionStart || {};

            if (quest.oneTime) {
                return current[quest.stat] || 0;
            }

            const startVal = start[quest.stat] || 0;
            const currentVal = current[quest.stat] || 0;
            return Math.max(0, currentVal - startVal);
        }

        function openQuestModal() {
            initQuestSystem();
            updateQuestDisplay();
            document.getElementById('quest-modal').style.display = 'flex';
            startQuestTimers();
        }

        function closeQuestModal() {
            document.getElementById('quest-modal').style.display = 'none';
        }

        function switchQuestTab(tab) {
            document.querySelectorAll('#quest-modal .codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.quest-content').forEach(c => c.style.display = 'none');
            document.querySelector(`#quest-modal .codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`quest-${tab}`).style.display = 'block';
        }

        let questTimerInterval = null;
        function startQuestTimers() {
            if (questTimerInterval) clearInterval(questTimerInterval);
            questTimerInterval = setInterval(updateQuestTimers, 1000);
            updateQuestTimers();
        }

        function updateQuestTimers() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            const dailyReset = (gameData.quests?.daily?.lastReset || now) + dayMs;
            const weeklyReset = (gameData.quests?.weekly?.lastReset || now) + weekMs;

            document.getElementById('daily-reset-timer').textContent = formatTimeRemaining(dailyReset - now);
            document.getElementById('weekly-reset-timer').textContent = formatTimeRemaining(weeklyReset - now);
        }

        function formatTimeRemaining(ms) {
            if (ms <= 0) return 'Resetting...';
            const hours = Math.floor(ms / (60 * 60 * 1000));
            const mins = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
            const secs = Math.floor((ms % (60 * 1000)) / 1000);
            return `${hours}h ${mins}m ${secs}s`;
        }

        function updateQuestDisplay() {
            // Daily quests
            const dailyList = document.getElementById('daily-quests-list');
            dailyList.innerHTML = renderQuestList(gameData.quests.daily.quests, 'daily');

            // Weekly quests
            const weeklyList = document.getElementById('weekly-quests-list');
            weeklyList.innerHTML = renderQuestList(gameData.quests.weekly.quests, 'weekly');

            // Story quests
            const storyList = document.getElementById('story-quests-list');
            storyList.innerHTML = renderStoryQuests();
        }

        function renderQuestList(quests, type) {
            return quests.map((quest, idx) => {
                const progress = getQuestProgress(quest, type);
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = quest.claimed;

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimQuest('${type}', ${idx})">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;">âœ“ Claimed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function renderStoryQuests() {
            return QUEST_TEMPLATES.story.map((quest, idx) => {
                const progress = captureQuestStats()[quest.stat] || 0;
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = gameData.quests.story.claimed.includes(quest.id);

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimStoryQuest('${quest.id}')">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;">âœ“ Completed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function claimQuest(type, idx) {
            const quest = gameData.quests[type].quests[idx];
            if (!quest || quest.claimed) return;

            quest.claimed = true;

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Quest Complete: ${quest.name}! +${quest.reward.xp} XP`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 30, 0xffd700, { spread: 5, lifetime: 1000 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        function claimStoryQuest(questId) {
            if (gameData.quests.story.claimed.includes(questId)) return;

            const quest = QUEST_TEMPLATES.story.find(q => q.id === questId);
            if (!quest) return;

            gameData.quests.story.claimed.push(questId);

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Story Quest Complete: ${quest.name}!`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 40, 0xffd700, { spread: 6, lifetime: 1200 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        // Track ability usage for quests
        function trackAbilityUsage() {
            if (!gameData.statistics.abilitiesUsed) gameData.statistics.abilitiesUsed = 0;
            gameData.statistics.abilitiesUsed++;
        }

        // v5.0: Pet Companion System
        const PET_TYPES = {
            slime: {
                name: 'Slime Buddy',
                icon: 'ðŸŸ¢',
                color: 0x44ff44,
                rarity: 'common',
                dropChance: 0.05,
                ability: 'regen',
                abilityDesc: '+1 HP/5s',
                speed: 3
            },
            firefly: {
                name: 'Firefly',
                icon: 'âœ¨',
                color: 0xffff00,
                rarity: 'common',
                dropChance: 0.04,
                ability: 'light',
                abilityDesc: 'Reveals hidden items',
                speed: 5
            },
            crystal: {
                name: 'Crystal Sprite',
                icon: 'ðŸ’Ž',
                color: 0x00ffff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'luck',
                abilityDesc: '+10% drop rate',
                speed: 4
            },
            shadow: {
                name: 'Shadow Wisp',
                icon: 'ðŸ‘»',
                color: 0x8800ff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'dodge',
                abilityDesc: '+5% dodge chance',
                speed: 6
            },
            phoenix: {
                name: 'Mini Phoenix',
                icon: 'ðŸ”¥',
                color: 0xff4400,
                rarity: 'rare',
                dropChance: 0.008,
                ability: 'damage',
                abilityDesc: '+15% damage',
                speed: 5
            },
            dragon: {
                name: 'Baby Dragon',
                icon: 'ðŸ²',
                color: 0xff0088,
                rarity: 'rare',
                dropChance: 0.005,
                ability: 'attack',
                abilityDesc: 'Attacks nearby enemies',
                speed: 4
            },
            void: {
                name: 'Void Entity',
                icon: 'ðŸŒ€',
                color: 0x4400ff,
                rarity: 'legendary',
                dropChance: 0.002,
                ability: 'absorb',
                abilityDesc: '+25% XP gain',
                speed: 3
            },
            celestial: {
                name: 'Celestial Star',
                icon: 'â­',
                color: 0xffd700,
                rarity: 'legendary',
                dropChance: 0.001,
                ability: 'allStats',
                abilityDesc: '+10% all stats',
                speed: 7
            }
        };

        const RARITY_COLORS = {
            common: '#aaaaaa',
            uncommon: '#00ff00',
            rare: '#0088ff',
            legendary: '#ff8800'
        };

        let activePetMesh = null;
        let petAnimTime = 0;

        function initPetSystem() {
            if (!gameData.pets) {
                gameData.pets = {
                    owned: [],
                    active: null
                };
            }
        }

        function tryDropPet(mobType) {
            initPetSystem();
            // Each mob kill has a chance to drop a random pet
            for (const [petId, pet] of Object.entries(PET_TYPES)) {
                if (Math.random() < pet.dropChance) {
                    if (!gameData.pets.owned.includes(petId)) {
                        gameData.pets.owned.push(petId);
                        showNotification(`NEW PET: ${pet.icon} ${pet.name}!`, 'success');
                        AudioSystem.levelUp();
                        if (worldState.player && particles) {
                            particles.emit(worldState.player.position, 40, pet.color, { spread: 6, lifetime: 1500 });
                        }
                        saveGameData();
                        return true;
                    }
                }
            }
            return false;
        }

        function setActivePet(petId) {
            initPetSystem();
            if (petId && !gameData.pets.owned.includes(petId)) return;

            gameData.pets.active = petId;
            updatePetMesh();
            saveGameData();

            if (petId) {
                const pet = PET_TYPES[petId];
                showNotification(`${pet.icon} ${pet.name} is now your companion!`);
            } else {
                showNotification('Pet dismissed');
            }
        }

        function updatePetMesh() {
            // Remove existing pet
            if (activePetMesh) {
                scene.remove(activePetMesh);
                activePetMesh = null;
            }

            if (!gameData.pets?.active || mode !== 'world') return;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return;

            // Create pet mesh
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: pet.color,
                emissive: pet.color,
                emissiveIntensity: 0.5
            });
            activePetMesh = new THREE.Mesh(geometry, material);
            activePetMesh.castShadow = true;

            // Add glow
            const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: pet.color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            activePetMesh.add(glow);

            scene.add(activePetMesh);
        }

        function updatePet(dt, time) {
            if (!activePetMesh || !worldState.player) return;

            const pet = PET_TYPES[gameData.pets?.active];
            if (!pet) return;

            petAnimTime += dt;

            // Follow player with offset
            const targetX = worldState.player.position.x + Math.sin(petAnimTime * 2) * 1.5;
            const targetZ = worldState.player.position.z + Math.cos(petAnimTime * 2) * 1.5;
            const targetY = worldState.player.position.y + 2 + Math.sin(petAnimTime * 3) * 0.3;

            // Smooth follow
            activePetMesh.position.x += (targetX - activePetMesh.position.x) * dt * pet.speed;
            activePetMesh.position.z += (targetZ - activePetMesh.position.z) * dt * pet.speed;
            activePetMesh.position.y += (targetY - activePetMesh.position.y) * dt * pet.speed;

            // Rotate
            activePetMesh.rotation.y += dt * 2;

            // Dragon attack ability
            if (pet.ability === 'attack' && Math.random() < 0.01) {
                const nearestMob = findNearestMob(activePetMesh.position, 8);
                if (nearestMob) {
                    const damage = Math.max(1, Math.floor(getPlayerDamage() * 0.3));
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `ðŸ² -${damage}`, '#ff0088');
                    if (particles) particles.emit(nearestMob.position, 5, 0xff0088);
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                }
            }
        }

        function findNearestMob(position, range) {
            let nearest = null;
            let minDist = range;
            worldState.mobs.forEach(mob => {
                const dist = mob.position.distanceTo(position);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = mob;
                }
            });
            return nearest;
        }

        function getPetBonuses() {
            const bonuses = {
                regen: 0,
                luck: 0,
                dodge: 0,
                damage: 0,
                xp: 0,
                allStats: 0
            };

            if (!gameData.pets?.active) return bonuses;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return bonuses;

            switch (pet.ability) {
                case 'regen': bonuses.regen = 1; break;
                case 'luck': bonuses.luck = 0.1; break;
                case 'dodge': bonuses.dodge = 0.05; break;
                case 'damage': bonuses.damage = 0.15; break;
                case 'absorb': bonuses.xp = 0.25; break;
                case 'allStats': bonuses.allStats = 0.1; break;
            }

            return bonuses;
        }

        // Pet regen tick
        let lastPetRegenTick = 0;
        function updatePetRegen(time) {
            const bonuses = getPetBonuses();
            if (bonuses.regen > 0 && time - lastPetRegenTick > 5000) {
                lastPetRegenTick = time;
                if (gameData.player.hp < gameData.player.maxHp) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + bonuses.regen);
                    updateHealthUI();
                    if (worldState.player) {
                        spawnFloater(worldState.player.position, `+${bonuses.regen}`, '#88ff88');
                    }
                }
            }
        }

        // ============================================
        // v5.6: COPILOT COMPANION SYSTEM
        // Follows the player with advice and assistance
        // ============================================
        let copilotMesh = null;
        let copilotAnimTime = 0;
        let copilotChatOpen = false;
        let copilotConversationHistory = [];
        let copilotVoiceRecognition = null;
        let copilotIsListening = false;
        let copilotSynthesis = window.speechSynthesis;
        let speechRecognizer = null; // v5.9: Azure Speech SDK recognizer

        // v5.10: Star Wars 3D Text Crawl System
        let copilotTextFont = null;
        let copilotTextGroup = null;        // Group for scrolling text
        let copilotTextMeshes = [];         // Individual text line meshes
        let copilotActiveTextAnimation = null;
        let copilotPersistentTextGroup = null; // Stays after scroll completes

        const COPILOT_CONFIG = {
            followDistance: 3,      // Distance behind player
            floatHeight: 2.5,       // Height above ground
            floatAmplitude: 0.4,    // Bobbing amount
            floatSpeed: 2,          // Bobbing speed
            orbitSpeed: 0.5,        // Circling speed
            followSmoothing: 4,     // How quickly it catches up
            color: 0x8a2be2,        // Primary color (purple)
            glowColor: 0x06ffa5,    // Glow color (cyan/green)
            particleCount: 30
        };

        // ============================================
        // v5.9: COPILOT TASK SYSTEM
        // Allows Copilot to perform autonomous tasks
        // ============================================
        const COPILOT_TASK_TYPES = {
            gather: {
                name: 'Gathering Resources',
                icon: 'ðŸªµ',
                duration: 12000,
                statusMessages: ['Searching for resources...', 'Found something!', 'Collecting materials...'],
                progressClass: ''
            },
            hunt: {
                name: 'Hunting Enemies',
                icon: 'âš”ï¸',
                duration: 15000,
                statusMessages: ['Scanning for targets...', 'Engaging enemy!', 'Combat in progress...'],
                progressClass: 'hunting'
            },
            scout: {
                name: 'Scouting Area',
                icon: 'ðŸ”',
                duration: 10000,
                statusMessages: ['Flying ahead...', 'Surveying the area...', 'Analyzing terrain...'],
                progressClass: 'scouting'
            },
            protect: {
                name: 'Protection Mode',
                icon: 'ðŸ›¡ï¸',
                duration: 0, // Continuous
                continuous: true,
                statusMessages: ['Guarding you...', 'Watching for threats...', 'Standing ready...'],
                progressClass: 'protecting'
            },
            heal: {
                name: 'Healing Support',
                icon: 'ðŸ’š',
                duration: 8000,
                statusMessages: ['Channeling healing energy...', 'Restoring your health...'],
                progressClass: ''
            },
            fish: {
                name: 'Fishing',
                icon: 'ðŸŽ£',
                duration: 15000,
                statusMessages: ['Finding a good spot...', 'Casting line...', 'Waiting for a bite...', 'Got one!'],
                progressClass: ''
            },
            mine: {
                name: 'Mining Ore',
                icon: 'â›ï¸',
                duration: 14000,
                statusMessages: ['Looking for ore veins...', 'Mining deposit...', 'Extracting minerals...'],
                progressClass: ''
            }
        };

        // Task state
        let copilotTask = {
            active: null,
            type: null,
            startTime: 0,
            progress: 0,
            results: [],
            targetPosition: null,
            continuous: false
        };

        // Assign a task to the Copilot
        function assignCopilotTask(taskType, params = {}) {
            const taskConfig = COPILOT_TASK_TYPES[taskType];
            if (!taskConfig) {
                addCopilotMessage(`I don't know how to do that task.`, 'ai');
                return false;
            }

            // Check if already on a task
            if (copilotTask.active) {
                addCopilotMessage(`I'm currently busy with ${COPILOT_TASK_TYPES[copilotTask.type].name}. Say "recall" or "come back" to cancel it first.`, 'ai');
                return false;
            }

            // Start the task
            copilotTask = {
                active: true,
                type: taskType,
                startTime: performance.now(),
                progress: 0,
                results: [],
                params: params,
                continuous: taskConfig.continuous || false
            };

            // Show task panel
            showTaskPanel(taskType);

            // Update copilot button indicator
            document.getElementById('copilot-button').classList.add('has-task');

            // Announce task start
            const startMessages = [
                `On it! I'll start ${taskConfig.name.toLowerCase()} now.`,
                `Understood! Beginning ${taskConfig.name.toLowerCase()}.`,
                `Leave it to me! ${taskConfig.name} in progress.`
            ];
            addCopilotMessage(startMessages[Math.floor(Math.random() * startMessages.length)], 'ai');

            // Speak if Azure TTS available
            if (rappidSettings.azureTTSKey) {
                speakWithAzureTTS(`Starting ${taskConfig.name.toLowerCase()}.`);
            }

            return true;
        }

        // Show the task panel UI
        function showTaskPanel(taskType) {
            const taskConfig = COPILOT_TASK_TYPES[taskType];
            const panel = document.getElementById('copilot-task-panel');

            document.getElementById('task-icon').textContent = taskConfig.icon;
            document.getElementById('task-name').textContent = taskConfig.name;
            document.getElementById('task-status').textContent = taskConfig.statusMessages[0];
            document.getElementById('task-progress-bar').style.width = '0%';
            document.getElementById('task-progress-bar').className = 'copilot-task-progress-bar ' + taskConfig.progressClass;
            document.getElementById('task-results').style.display = 'none';
            document.getElementById('task-results').innerHTML = '';

            panel.classList.add('active');
        }

        // Hide task panel
        function hideTaskPanel() {
            document.getElementById('copilot-task-panel').classList.remove('active');
        }

        // Recall the Copilot (cancel current task)
        function recallCopilot() {
            if (!copilotTask.active) return;

            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];

            // Partial results if any progress was made
            if (copilotTask.progress > 0.3 && copilotTask.results.length > 0) {
                completeTask(true); // Partial completion
            } else {
                addCopilotMessage(`Returning to you! Task cancelled.`, 'ai');
                if (rappidSettings.azureTTSKey) {
                    speakWithAzureTTS(`Coming back!`);
                }
            }

            // Reset task state
            copilotTask = {
                active: false,
                type: null,
                startTime: 0,
                progress: 0,
                results: [],
                continuous: false
            };

            hideTaskPanel();
            document.getElementById('copilot-button').classList.remove('has-task');
        }

        // Update task progress (called in game loop)
        function updateCopilotTask(deltaTime) {
            if (!copilotTask.active) return;

            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];
            const elapsed = performance.now() - copilotTask.startTime;

            // Continuous tasks (like protect) don't have progress
            if (copilotTask.continuous) {
                // Update status message periodically
                const msgIndex = Math.floor((elapsed / 3000) % taskConfig.statusMessages.length);
                document.getElementById('task-status').textContent = taskConfig.statusMessages[msgIndex];
                document.getElementById('task-progress-bar').style.width = '100%';

                // Continuous task effects
                handleContinuousTaskEffect(copilotTask.type, deltaTime);
                return;
            }

            // Calculate progress
            copilotTask.progress = Math.min(1, elapsed / taskConfig.duration);
            document.getElementById('task-progress-bar').style.width = (copilotTask.progress * 100) + '%';

            // Update status message based on progress
            const msgIndex = Math.floor(copilotTask.progress * taskConfig.statusMessages.length);
            const clampedIndex = Math.min(msgIndex, taskConfig.statusMessages.length - 1);
            document.getElementById('task-status').textContent = taskConfig.statusMessages[clampedIndex];

            // Generate results during task
            generateTaskResults(copilotTask.type, copilotTask.progress);

            // Check if task is complete
            if (copilotTask.progress >= 1) {
                completeTask(false);
            }
        }

        // Generate results based on task type and progress
        function generateTaskResults(taskType, progress) {
            // Only generate at certain thresholds
            const thresholds = [0.3, 0.6, 0.9];
            const currentThreshold = thresholds.find(t => progress >= t && !copilotTask.results.some(r => r.threshold === t));

            if (!currentThreshold) return;

            let result = { threshold: currentThreshold };

            switch (taskType) {
                case 'gather':
                    const gatherItems = ['Logs', 'Fiber', 'Stone', 'Herbs'];
                    result.item = gatherItems[Math.floor(Math.random() * gatherItems.length)];
                    result.amount = Math.floor(Math.random() * 3) + 1;
                    break;

                case 'hunt':
                    result.xp = Math.floor(Math.random() * 30) + 20;
                    result.gold = Math.floor(Math.random() * 15) + 5;
                    if (Math.random() < 0.3) {
                        result.loot = ['Raw Meat', 'Monster Fang', 'Beast Hide'][Math.floor(Math.random() * 3)];
                    }
                    break;

                case 'scout':
                    const discoveries = [
                        'Found a resource node nearby!',
                        'Spotted enemy patrol to the east.',
                        'Discovered a safe area ahead.',
                        'Located a point of interest.',
                        'Mapped the surrounding terrain.'
                    ];
                    result.discovery = discoveries[Math.floor(Math.random() * discoveries.length)];
                    break;

                case 'heal':
                    result.healAmount = Math.floor(Math.random() * 15) + 10;
                    break;

                case 'fish':
                    if (Math.random() < 0.7) {
                        result.item = 'Raw Fish';
                        result.amount = Math.floor(Math.random() * 2) + 1;
                    }
                    break;

                case 'mine':
                    const oreTypes = ['Iron Ore', 'Copper Ore', 'Stone'];
                    result.item = oreTypes[Math.floor(Math.random() * oreTypes.length)];
                    result.amount = Math.floor(Math.random() * 2) + 1;
                    break;
            }

            copilotTask.results.push(result);
            updateTaskResultsUI();
        }

        // Handle continuous task effects
        function handleContinuousTaskEffect(taskType, deltaTime) {
            switch (taskType) {
                case 'protect':
                    // Protect mode: automatically attack nearby enemies
                    // (visual effect - enemies near player take slight damage)
                    if (worldState.mobs) {
                        worldState.mobs.forEach(mob => {
                            if (mob.mesh && worldState.player) {
                                const dist = mob.mesh.position.distanceTo(worldState.player.position);
                                if (dist < 8 && Math.random() < 0.02) {
                                    // Copilot attacks enemy
                                    mob.hp -= 5;
                                    spawnFloater(mob.mesh.position, '-5', '#ff88ff');
                                    if (mob.hp <= 0) {
                                        addCopilotMessage(`I took care of that enemy for you!`, 'ai');
                                    }
                                }
                            }
                        });
                    }
                    break;
            }
        }

        // Update the results UI
        function updateTaskResultsUI() {
            const resultsDiv = document.getElementById('task-results');
            if (copilotTask.results.length === 0) {
                resultsDiv.style.display = 'none';
                return;
            }

            resultsDiv.style.display = 'block';
            let html = '';

            copilotTask.results.forEach(result => {
                if (result.item) {
                    html += `<div class="result-item positive">+${result.amount} ${result.item}</div>`;
                }
                if (result.xp) {
                    html += `<div class="result-item positive">+${result.xp} XP</div>`;
                }
                if (result.gold) {
                    html += `<div class="result-item positive">+${result.gold} Gold</div>`;
                }
                if (result.loot) {
                    html += `<div class="result-item positive">+1 ${result.loot}</div>`;
                }
                if (result.discovery) {
                    html += `<div class="result-item">${result.discovery}</div>`;
                }
                if (result.healAmount) {
                    html += `<div class="result-item positive">+${result.healAmount} HP</div>`;
                }
            });

            resultsDiv.innerHTML = html;
        }

        // Complete the task and apply rewards
        function completeTask(partial = false) {
            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];

            // Apply all results to game state
            copilotTask.results.forEach(result => {
                if (result.item && result.amount) {
                    // Add items to inventory
                    addToInventory(result.item, result.amount);
                }
                if (result.xp) {
                    gainSkillXP('combat', result.xp);
                }
                if (result.gold) {
                    gameData.gold = (gameData.gold || 0) + result.gold;
                }
                if (result.loot) {
                    addToInventory(result.loot, 1);
                }
                if (result.healAmount) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + result.healAmount);
                    updateHealthUI();
                }
            });

            // Completion message
            const completeMessages = partial ? [
                `I'm back! I managed to get some things done before returning.`,
                `Returning with partial results. Here's what I gathered.`
            ] : [
                `Task complete! Here's what I found.`,
                `All done! The ${taskConfig.name.toLowerCase()} was successful.`,
                `Mission accomplished! I've returned with the results.`
            ];

            addCopilotMessage(completeMessages[Math.floor(Math.random() * completeMessages.length)], 'ai');

            if (rappidSettings.azureTTSKey) {
                speakWithAzureTTS(partial ? `I'm back with some results.` : `Task complete!`);
            }

            // Show final results
            document.getElementById('task-status').textContent = partial ? 'Recalled - Partial results' : 'Complete!';
            document.getElementById('task-progress-bar').style.width = '100%';

            // Keep panel visible briefly to show results
            setTimeout(() => {
                hideTaskPanel();
                document.getElementById('copilot-button').classList.remove('has-task');

                // Reset task state
                copilotTask = {
                    active: false,
                    type: null,
                    startTime: 0,
                    progress: 0,
                    results: [],
                    continuous: false
                };
            }, 3000);

            saveGameData();
        }

        // Helper: Add item to inventory
        function addToInventory(itemName, amount) {
            if (!gameData.inventory) gameData.inventory = [];

            // Find existing stack or empty slot
            let existingIdx = gameData.inventory.findIndex(item => item && item.name === itemName);
            if (existingIdx >= 0) {
                gameData.inventory[existingIdx].amount = (gameData.inventory[existingIdx].amount || 1) + amount;
            } else {
                // Find empty slot
                let emptyIdx = gameData.inventory.findIndex(item => !item);
                if (emptyIdx < 0) {
                    emptyIdx = gameData.inventory.length;
                }
                gameData.inventory[emptyIdx] = { name: itemName, amount: amount };
            }

            updateInventoryUI();
        }

        // Parse natural language for task commands
        function parseCopilotTaskCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Recall commands
            if (lowerMsg.includes('recall') || lowerMsg.includes('come back') || lowerMsg.includes('return') ||
                lowerMsg.includes('stop task') || lowerMsg.includes('cancel task') || lowerMsg.includes('abort')) {
                if (copilotTask.active) {
                    recallCopilot();
                    return true;
                }
                return false;
            }

            // Gather/collect resources
            if (lowerMsg.includes('gather') || lowerMsg.includes('collect') ||
                (lowerMsg.includes('get') && (lowerMsg.includes('wood') || lowerMsg.includes('logs') || lowerMsg.includes('materials') || lowerMsg.includes('resources')))) {
                return assignCopilotTask('gather');
            }

            // Hunt/kill enemies
            if (lowerMsg.includes('hunt') || lowerMsg.includes('kill') ||
                lowerMsg.includes('fight') || lowerMsg.includes('attack enemies')) {
                return assignCopilotTask('hunt');
            }

            // Scout/explore
            if (lowerMsg.includes('scout') || lowerMsg.includes('explore') ||
                lowerMsg.includes('look around') || lowerMsg.includes('survey') ||
                lowerMsg.includes('check the area') || lowerMsg.includes('what\'s nearby')) {
                return assignCopilotTask('scout');
            }

            // Protect/guard
            if (lowerMsg.includes('protect') || lowerMsg.includes('guard') ||
                lowerMsg.includes('defend') || lowerMsg.includes('watch my back')) {
                return assignCopilotTask('protect');
            }

            // Heal
            if (lowerMsg.includes('heal me') || lowerMsg.includes('restore health') ||
                lowerMsg.includes('patch me up') || lowerMsg.includes('healing')) {
                return assignCopilotTask('heal');
            }

            // Fish
            if (lowerMsg.includes('fish') || lowerMsg.includes('catch fish') ||
                lowerMsg.includes('go fishing')) {
                return assignCopilotTask('fish');
            }

            // Mine
            if (lowerMsg.includes('mine') || lowerMsg.includes('get ore') ||
                lowerMsg.includes('dig') || lowerMsg.includes('excavate')) {
                return assignCopilotTask('mine');
            }

            // Task status
            if (lowerMsg.includes('what are you doing') || lowerMsg.includes('task status') ||
                lowerMsg.includes('current task')) {
                if (copilotTask.active) {
                    const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];
                    addCopilotMessage(`I'm currently ${taskConfig.name.toLowerCase()}. Progress: ${Math.floor(copilotTask.progress * 100)}%`, 'ai');
                    return true;
                } else {
                    addCopilotMessage(`I'm not working on any task right now. Ask me to gather, hunt, scout, fish, mine, or protect you!`, 'ai');
                    return true;
                }
            }

            return false; // Not a task command
        }

        // ============================================
        // v5.10: MULTI-AGENT FLEET SYSTEM
        // Spawn up to 10 AI-driven autonomous agents
        // Each driven by RAPPID API with canned transcripts
        // ============================================
        const MAX_AGENTS = 10;
        const AGENT_NAMES = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa'];

        // v5.12.1: Endpoint configuration registry - allows different AI providers per agent
        const ENDPOINT_REGISTRY = {
            default: {
                name: 'RAPPID (Default)',
                urlKey: 'rappid-agent-url',  // localStorage key for URL
                apiKeyKey: 'rappid-api-key', // localStorage key for API key
                headerStyle: 'x-functions-key',
                bodyFormat: 'rappid' // rappid | openai | anthropic | custom
            },
            openai: {
                name: 'OpenAI',
                urlKey: 'openai-agent-url',
                apiKeyKey: 'openai-api-key',
                headerStyle: 'Authorization',
                headerPrefix: 'Bearer ',
                bodyFormat: 'openai'
            },
            anthropic: {
                name: 'Anthropic',
                urlKey: 'anthropic-agent-url',
                apiKeyKey: 'anthropic-api-key',
                headerStyle: 'x-api-key',
                bodyFormat: 'anthropic'
            },
            azure: {
                name: 'Azure OpenAI',
                urlKey: 'azure-agent-url',
                apiKeyKey: 'azure-api-key',
                headerStyle: 'api-key',
                bodyFormat: 'openai'
            },
            local: {
                name: 'Local LLM',
                urlKey: 'local-agent-url',
                apiKeyKey: 'local-api-key',
                headerStyle: 'Authorization',
                headerPrefix: 'Bearer ',
                bodyFormat: 'openai' // Most local servers use OpenAI-compatible format
            },
            custom: {
                name: 'Custom Endpoint',
                urlKey: 'custom-agent-url',
                apiKeyKey: 'custom-api-key',
                headerStyle: 'Authorization',
                bodyFormat: 'custom'
            }
        };

        // Get endpoint configuration for an agent
        function getAgentEndpoint(agent) {
            // Check if agent has custom endpoint from transcript
            if (agent.endpointConfig) {
                const config = agent.endpointConfig;
                return {
                    url: config.url || localStorage.getItem(config.urlKey) || '',
                    key: config.apiKey || localStorage.getItem(config.apiKeyKey) || '',
                    headerStyle: config.headerStyle || 'x-functions-key',
                    headerPrefix: config.headerPrefix || '',
                    bodyFormat: config.bodyFormat || 'rappid',
                    name: config.name || 'Custom'
                };
            }

            // Check if agent type has default endpoint
            const typeConfig = AGENT_TYPES[agent.type];
            if (typeConfig?.endpoint) {
                const registryEntry = ENDPOINT_REGISTRY[typeConfig.endpoint] || ENDPOINT_REGISTRY.default;
                return {
                    url: localStorage.getItem(registryEntry.urlKey) || '',
                    key: localStorage.getItem(registryEntry.apiKeyKey) || '',
                    headerStyle: registryEntry.headerStyle,
                    headerPrefix: registryEntry.headerPrefix || '',
                    bodyFormat: registryEntry.bodyFormat,
                    name: registryEntry.name
                };
            }

            // Fall back to global RAPPID endpoint
            const globalEndpoint = getActiveEndpoint();
            return {
                url: globalEndpoint?.url || '',
                key: globalEndpoint?.key || '',
                headerStyle: 'x-functions-key',
                headerPrefix: '',
                bodyFormat: 'rappid',
                name: 'RAPPID'
            };
        }

        // Format request body based on endpoint type
        function formatAgentRequestBody(endpoint, contextMessage, conversationHistory, agent) {
            switch (endpoint.bodyFormat) {
                case 'openai':
                    return JSON.stringify({
                        model: agent.endpointConfig?.model || 'gpt-4o-mini',
                        messages: conversationHistory,
                        max_tokens: 500,
                        temperature: 0.7
                    });

                case 'anthropic':
                    // Anthropic uses 'human' and 'assistant' roles
                    const anthropicMessages = conversationHistory.slice(1).map(m => ({
                        role: m.role === 'user' ? 'human' : m.role,
                        content: m.content
                    }));
                    return JSON.stringify({
                        model: agent.endpointConfig?.model || 'claude-3-haiku-20240307',
                        messages: anthropicMessages,
                        system: conversationHistory[0]?.content || '',
                        max_tokens: 500
                    });

                case 'custom':
                    // Allow custom body format from transcript config
                    if (agent.endpointConfig?.customBody) {
                        const body = { ...agent.endpointConfig.customBody };
                        body.messages = conversationHistory;
                        body.input = contextMessage.content;
                        return JSON.stringify(body);
                    }
                    // Fall through to default

                case 'rappid':
                default:
                    return JSON.stringify({
                        user_input: contextMessage.content,
                        conversation_history: conversationHistory,
                        user_guid: `agent-${agent.id}`
                    });
            }
        }

        // Parse response based on endpoint type
        function parseAgentResponse(endpoint, data) {
            switch (endpoint.bodyFormat) {
                case 'openai':
                    return data.choices?.[0]?.message?.content || data.response || '';

                case 'anthropic':
                    return data.content?.[0]?.text || data.completion || '';

                case 'rappid':
                default:
                    return data.assistant_response || data.response || '';
            }
        }

        // Agent type definitions with canned transcript templates
        const AGENT_TYPES = {
            gatherer: {
                icon: 'ðŸªµ',
                name: 'Gatherer',
                color: 0x44ff88,
                colorClass: 'agent-color-gatherer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous resource-gathering AI agent in the game LEVIATHAN. Your sole purpose is to efficiently gather resources (logs, fiber, stone, herbs) for the player. You operate independently and report back with what you find. Keep responses brief (1-2 sentences). Always analyze the situation and decide: continue gathering, return with resources, or adjust strategy. Output JSON with: {"action": "gather|return|move", "target": "resource type", "message": "brief status", "results": [{"item": "name", "amount": num}]}` },
                ],
                decisionInterval: 4000, // ms between API calls
                taskType: 'gather'
            },
            hunter: {
                icon: 'âš”ï¸',
                name: 'Hunter',
                color: 0xff4444,
                colorClass: 'agent-color-hunter',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous combat AI agent in LEVIATHAN. Your mission is to hunt and defeat enemies to earn XP and loot for the player. You fight strategically and retreat if overwhelmed. Keep responses brief. Analyze: enemy count, difficulty, your health. Output JSON: {"action": "attack|retreat|patrol", "target": "enemy type or direction", "message": "brief status", "results": [{"xp": num, "gold": num, "loot": "item name"}]}` },
                ],
                decisionInterval: 3000,
                taskType: 'hunt'
            },
            scout: {
                icon: 'ðŸ”',
                name: 'Scout',
                color: 0x44aaff,
                colorClass: 'agent-color-scout',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous reconnaissance AI agent in LEVIATHAN. Your role is to explore, map terrain, and report discoveries (resources, enemies, points of interest). Stay mobile and avoid combat. Output JSON: {"action": "explore|report|mark", "direction": "N/S/E/W or area name", "message": "brief discovery", "discoveries": [{"type": "resource|enemy|poi", "description": "what you found"}]}` },
                ],
                decisionInterval: 5000,
                taskType: 'scout'
            },
            protector: {
                icon: 'ðŸ›¡ï¸',
                name: 'Protector',
                color: 0xffcc00,
                colorClass: 'agent-color-protector',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous defense AI agent in LEVIATHAN. Your duty is to guard the player, intercept threats, and maintain a protective perimeter. You stay close to the player and engage any enemy that approaches. Output JSON: {"action": "guard|intercept|alert", "threat_level": "low|medium|high", "message": "security status", "enemies_engaged": num}` },
                ],
                decisionInterval: 2000,
                taskType: 'protect'
            },
            healer: {
                icon: 'ðŸ’š',
                name: 'Healer',
                color: 0xff88ff,
                colorClass: 'agent-color-healer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous healing AI agent in LEVIATHAN. Monitor the player's health and provide healing support. Prioritize keeping the player alive. You channel healing energy periodically. Output JSON: {"action": "heal|monitor|recover", "target": "player or self", "heal_amount": num, "message": "healing status", "player_health_pct": num}` },
                ],
                decisionInterval: 3500,
                taskType: 'heal'
            },
            fisher: {
                icon: 'ðŸŽ£',
                name: 'Fisher',
                color: 0x44ffff,
                colorClass: 'agent-color-fisher',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous fishing AI agent in LEVIATHAN. Find water sources and catch fish for food. You're patient and methodical. Report catches and move to better fishing spots when needed. Output JSON: {"action": "fish|move|return", "location": "current spot description", "message": "fishing status", "catch": [{"item": "fish type", "amount": num}]}` },
                ],
                decisionInterval: 6000,
                taskType: 'fish'
            },
            miner: {
                icon: 'â›ï¸',
                name: 'Miner',
                color: 0xffaa44,
                colorClass: 'agent-color-miner',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous mining AI agent in LEVIATHAN. Locate ore veins, extract minerals, and report finds. You're thorough and efficient. Move to new deposits when current one is depleted. Output JSON: {"action": "mine|prospect|return", "deposit": "ore type", "message": "mining status", "ore": [{"item": "ore type", "amount": num}]}` },
                ],
                decisionInterval: 5000,
                taskType: 'mine'
            },
            explorer: {
                icon: 'ðŸ§­',
                name: 'Explorer',
                color: 0xaa88ff,
                colorClass: 'agent-color-explorer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous exploration AI agent in LEVIATHAN. Push into uncharted territory, discover new areas, and expand the known map. You're brave and curious. Report unusual phenomena and mark important locations. Output JSON: {"action": "venture|document|beacon", "area": "location name", "message": "exploration log", "findings": [{"type": "biome|landmark|secret", "description": "discovery"}]}` },
                ],
                decisionInterval: 7000,
                taskType: 'scout'
            }
        };

        // Fleet state
        let agentFleet = [];
        let agentFleetPanelOpen = false;
        let agentUpdateTimers = {};

        // Toggle fleet panel
        function toggleAgentFleetPanel() {
            agentFleetPanelOpen = !agentFleetPanelOpen;
            const panel = document.getElementById('agent-fleet-panel');
            panel.classList.toggle('active', agentFleetPanelOpen);
        }

        // v5.12.1: Spawn a new agent with optional custom transcript and endpoint config
        // customConfig: { transcript: [...], endpoint: {...}, name: 'Custom Name' }
        function spawnAgent(agentType, customConfig = null) {
            if (agentFleet.length >= MAX_AGENTS) {
                addCopilotMessage(`Fleet capacity reached (${MAX_AGENTS} agents). Recall an agent first.`, 'ai');
                return null;
            }

            const typeConfig = AGENT_TYPES[agentType];
            if (!typeConfig) return null;

            // Find next available name
            const usedNames = agentFleet.map(a => a.name);
            const availableName = customConfig?.name ||
                                  AGENT_NAMES.find(n => !usedNames.includes(n)) ||
                                  `Agent-${agentFleet.length + 1}`;

            // Merge custom transcript with base if provided
            let transcript = [...typeConfig.baseTranscript];
            if (customConfig?.transcript) {
                transcript = customConfig.transcript;
            }

            // Extract endpoint config from transcript if present
            let endpointConfig = customConfig?.endpoint || null;
            if (!endpointConfig && transcript.length > 0) {
                // Check if first message contains endpoint config
                const systemMsg = transcript[0];
                if (systemMsg.endpoint) {
                    endpointConfig = systemMsg.endpoint;
                }
            }

            const agent = {
                id: Date.now().toString(36) + Math.random().toString(36).substr(2, 9),
                name: availableName,
                type: agentType,
                typeConfig: typeConfig,
                status: 'initializing',
                statusMessage: 'Preparing to deploy...',
                progress: 0,
                conversationHistory: transcript,
                results: [],
                lastDecisionTime: 0,
                mesh: null,
                position: worldState.player ? worldState.player.position.clone() : new THREE.Vector3(0, 0, 0),
                targetPosition: null,
                totalEarnings: { xp: 0, gold: 0, items: [] },
                spawnTime: performance.now(),
                // v5.12.1: Endpoint configuration
                endpointConfig: endpointConfig,
                activeEndpoint: null
            };

            // Create 3D mesh for the agent
            createAgentMesh(agent);

            // Add to fleet
            agentFleet.push(agent);

            // Update UI
            updateFleetUI();
            updateFleetButton();

            // Start autonomous loop for this agent
            startAgentLoop(agent);

            // Announce
            addCopilotMessage(`${typeConfig.icon} ${availableName} (${typeConfig.name}) deployed! They'll work autonomously and report back.`, 'ai');

            return agent;
        }

        // Create 3D mesh for an agent
        function createAgentMesh(agent) {
            if (!worldState.scene) return;

            const color = agent.typeConfig.color;

            // Create a smaller companion orb for each agent
            const geometry = new THREE.IcosahedronGeometry(0.4, 1);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });

            agent.mesh = new THREE.Mesh(geometry, material);

            // Position near player but offset
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 8,
                2 + Math.random() * 2,
                (Math.random() - 0.5) * 8
            );

            if (worldState.player) {
                agent.mesh.position.copy(worldState.player.position).add(offset);
            }

            agent.position = agent.mesh.position.clone();

            // Add glow effect
            const glowGeometry = new THREE.IcosahedronGeometry(0.55, 1);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.15
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            agent.mesh.add(glow);
            agent.glow = glow;

            worldState.scene.add(agent.mesh);
        }

        // Start autonomous decision loop for an agent
        function startAgentLoop(agent) {
            const loop = async () => {
                if (!agent || !agentFleet.includes(agent)) return;

                const now = performance.now();
                if (now - agent.lastDecisionTime >= agent.typeConfig.decisionInterval) {
                    agent.lastDecisionTime = now;
                    await makeAgentDecision(agent);
                }

                // Continue loop
                agentUpdateTimers[agent.id] = setTimeout(loop, 500);
            };

            // Initial delay before first decision
            setTimeout(() => {
                agent.status = 'working';
                agent.statusMessage = 'Starting task...';
                updateAgentCardUI(agent);
                loop();
            }, 1500);
        }

        // v5.12.1: Make an autonomous decision for an agent via configurable API endpoint
        async function makeAgentDecision(agent) {
            // Get agent-specific endpoint (may differ from global)
            const endpoint = getAgentEndpoint(agent);

            // Build real-time context
            const gameContext = buildGameContextForAgent(agent);

            // Inject context into a user message
            const contextMessage = {
                role: 'user',
                content: `Current situation: ${JSON.stringify(gameContext)}. What's your next action?`
            };

            // Build conversation for API
            const conversationForApi = [...agent.conversationHistory, contextMessage];

            // If no endpoint configured, use simulated local decisions
            if (!endpoint || !endpoint.url || !endpoint.key) {
                simulateAgentDecision(agent, gameContext);
                return;
            }

            try {
                agent.status = 'thinking';
                agent.activeEndpoint = endpoint.name; // Track which endpoint is being used
                updateAgentCardUI(agent);

                // Build headers based on endpoint configuration
                const headers = {
                    'Content-Type': 'application/json'
                };

                // Add auth header based on endpoint style
                if (endpoint.headerPrefix) {
                    headers[endpoint.headerStyle] = endpoint.headerPrefix + endpoint.key;
                } else {
                    headers[endpoint.headerStyle] = endpoint.key;
                }

                // Format body based on endpoint type
                const requestBody = formatAgentRequestBody(endpoint, contextMessage, conversationForApi, agent);

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (response.ok) {
                    const data = await response.json();

                    // Parse response based on endpoint type
                    const textResponse = parseAgentResponse(endpoint, data);

                    // Add to conversation history (keep last 20 messages to avoid token overflow)
                    agent.conversationHistory.push(contextMessage);
                    agent.conversationHistory.push({ role: 'assistant', content: textResponse });
                    if (agent.conversationHistory.length > 22) {
                        // Keep system message + last 20
                        agent.conversationHistory = [
                            agent.conversationHistory[0],
                            ...agent.conversationHistory.slice(-20)
                        ];
                    }

                    // Parse and execute the decision
                    parseAndExecuteAgentDecision(agent, textResponse);
                } else {
                    console.warn(`Agent ${agent.name} API error (${endpoint.name}):`, response.status);
                    simulateAgentDecision(agent, gameContext);
                }
            } catch (error) {
                console.error(`Agent ${agent.name} decision error (${endpoint.name}):`, error);
                simulateAgentDecision(agent, gameContext);
            }

            agent.status = 'working';
            updateAgentCardUI(agent);
        }

        // Build game context for agent decision
        function buildGameContextForAgent(agent) {
            const elapsed = (performance.now() - agent.spawnTime) / 1000;

            return {
                agent_name: agent.name,
                agent_type: agent.type,
                mission_time_seconds: Math.floor(elapsed),
                player_hp: gameData.player?.hp || 100,
                player_max_hp: gameData.player?.maxHp || 100,
                player_position: worldState.player ? {
                    x: Math.floor(worldState.player.position.x),
                    z: Math.floor(worldState.player.position.z)
                } : { x: 0, z: 0 },
                current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                nearby_enemies: countNearbyEnemies(agent),
                items_gathered: agent.totalEarnings.items.length,
                xp_earned: agent.totalEarnings.xp,
                gold_earned: agent.totalEarnings.gold
            };
        }

        // Count enemies near an agent
        function countNearbyEnemies(agent) {
            if (!worldState.mobs || !agent.position) return 0;
            return worldState.mobs.filter(mob => {
                if (!mob.mesh) return false;
                return mob.mesh.position.distanceTo(agent.position) < 15;
            }).length;
        }

        // Parse API response and execute agent action
        function parseAndExecuteAgentDecision(agent, response) {
            try {
                // Try to extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const decision = JSON.parse(jsonMatch[0]);
                    executeAgentAction(agent, decision);
                } else {
                    // No JSON, use response as status message
                    agent.statusMessage = response.substring(0, 100);
                }
            } catch (e) {
                // Parse failed, treat as status update
                agent.statusMessage = response.substring(0, 100);
            }
            updateAgentCardUI(agent);
        }

        // Execute an agent action based on decision
        function executeAgentAction(agent, decision) {
            agent.statusMessage = decision.message || 'Working...';

            // Process results
            if (decision.results) {
                decision.results.forEach(result => {
                    if (result.item && result.amount) {
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push({ item: result.item, amount: result.amount });
                        agent.results.push({ item: result.item, amount: result.amount });
                    }
                    if (result.xp) {
                        gainSkillXP('combat', result.xp);
                        agent.totalEarnings.xp += result.xp;
                    }
                    if (result.gold) {
                        gameData.gold = (gameData.gold || 0) + result.gold;
                        agent.totalEarnings.gold += result.gold;
                    }
                    if (result.loot) {
                        addToInventory(result.loot, 1);
                        agent.totalEarnings.items.push({ item: result.loot, amount: 1 });
                    }
                });
            }

            // Process discoveries (for scouts/explorers)
            if (decision.discoveries) {
                decision.discoveries.forEach(d => {
                    agent.results.push({ discovery: d.description });
                });
            }

            // Process healing
            if (decision.heal_amount) {
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + decision.heal_amount);
                updateHealthUI();
                agent.results.push({ heal: decision.heal_amount });
            }

            // Process catch (fishing)
            if (decision.catch) {
                decision.catch.forEach(c => {
                    if (c.item && c.amount) {
                        addToInventory(c.item, c.amount);
                        agent.totalEarnings.items.push({ item: c.item, amount: c.amount });
                        agent.results.push({ item: c.item, amount: c.amount });
                    }
                });
            }

            // Process ore (mining)
            if (decision.ore) {
                decision.ore.forEach(o => {
                    if (o.item && o.amount) {
                        addToInventory(o.item, o.amount);
                        agent.totalEarnings.items.push({ item: o.item, amount: o.amount });
                        agent.results.push({ item: o.item, amount: o.amount });
                    }
                });
            }

            // Update progress based on time
            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100); // 100% at 1 minute

            saveGameData();
        }

        // Simulate agent decision (fallback when no API)
        function simulateAgentDecision(agent, context) {
            const taskType = agent.typeConfig.taskType;

            // Random results based on task type
            const rand = Math.random();
            let result = {};

            switch (taskType) {
                case 'gather':
                    if (rand < 0.4) {
                        const items = ['Logs', 'Fiber', 'Stone', 'Herbs'];
                        result = { item: items[Math.floor(Math.random() * items.length)], amount: Math.floor(Math.random() * 2) + 1 };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                    }
                    agent.statusMessage = rand < 0.4 ? `Found ${result.amount} ${result.item}!` : 'Searching for resources...';
                    break;

                case 'hunt':
                    if (rand < 0.3) {
                        result.xp = Math.floor(Math.random() * 20) + 10;
                        result.gold = Math.floor(Math.random() * 10) + 3;
                        gainSkillXP('combat', result.xp);
                        gameData.gold = (gameData.gold || 0) + result.gold;
                        agent.totalEarnings.xp += result.xp;
                        agent.totalEarnings.gold += result.gold;
                        agent.results.push(result);
                    }
                    agent.statusMessage = rand < 0.3 ? `Defeated enemy! +${result.xp} XP` : 'Hunting enemies...';
                    break;

                case 'scout':
                    if (rand < 0.25) {
                        const discoveries = ['Found a resource deposit', 'Spotted enemy camp', 'Discovered safe path', 'Located point of interest'];
                        const disc = discoveries[Math.floor(Math.random() * discoveries.length)];
                        agent.results.push({ discovery: disc });
                        agent.statusMessage = disc;
                    } else {
                        agent.statusMessage = 'Surveying the area...';
                    }
                    break;

                case 'protect':
                    const nearbyEnemies = countNearbyEnemies(agent);
                    if (nearbyEnemies > 0 && rand < 0.5) {
                        agent.statusMessage = `Engaging ${nearbyEnemies} threat(s)!`;
                        // Attack a nearby enemy
                        if (worldState.mobs) {
                            const nearMob = worldState.mobs.find(m => m.mesh && m.mesh.position.distanceTo(agent.position) < 15);
                            if (nearMob) {
                                nearMob.hp -= 8;
                                if (agent.mesh) spawnFloater(agent.mesh.position, '-8', agent.typeConfig.color.toString(16));
                            }
                        }
                    } else {
                        agent.statusMessage = nearbyEnemies > 0 ? 'Alert! Enemies nearby.' : 'Area secure.';
                    }
                    break;

                case 'heal':
                    if (gameData.player.hp < gameData.player.maxHp && rand < 0.5) {
                        const healAmt = Math.floor(Math.random() * 8) + 5;
                        gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                        updateHealthUI();
                        agent.results.push({ heal: healAmt });
                        agent.statusMessage = `Healed player for ${healAmt} HP!`;
                    } else {
                        agent.statusMessage = gameData.player.hp < gameData.player.maxHp ? 'Channeling healing energy...' : 'Player at full health.';
                    }
                    break;

                case 'fish':
                    if (rand < 0.3) {
                        result = { item: 'Raw Fish', amount: 1 };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        agent.statusMessage = 'Caught a fish!';
                    } else {
                        agent.statusMessage = rand < 0.5 ? 'Waiting for a bite...' : 'Casting line...';
                    }
                    break;

                case 'mine':
                    if (rand < 0.35) {
                        const ores = ['Iron Ore', 'Copper Ore', 'Stone'];
                        result = { item: ores[Math.floor(Math.random() * ores.length)], amount: Math.floor(Math.random() * 2) + 1 };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        agent.statusMessage = `Mined ${result.amount} ${result.item}!`;
                    } else {
                        agent.statusMessage = 'Mining deposit...';
                    }
                    break;
            }

            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100);

            saveGameData();
            updateAgentCardUI(agent);
        }

        // Recall an agent
        function recallAgent(agentId) {
            const agentIndex = agentFleet.findIndex(a => a.id === agentId);
            if (agentIndex === -1) return;

            const agent = agentFleet[agentIndex];

            // Stop the update loop
            if (agentUpdateTimers[agent.id]) {
                clearTimeout(agentUpdateTimers[agent.id]);
                delete agentUpdateTimers[agent.id];
            }

            // Remove mesh from scene
            if (agent.mesh && worldState.scene) {
                worldState.scene.remove(agent.mesh);
            }

            // Generate summary
            const summary = [];
            if (agent.totalEarnings.xp > 0) summary.push(`+${agent.totalEarnings.xp} XP`);
            if (agent.totalEarnings.gold > 0) summary.push(`+${agent.totalEarnings.gold} Gold`);
            if (agent.totalEarnings.items.length > 0) {
                const itemCounts = {};
                agent.totalEarnings.items.forEach(i => {
                    itemCounts[i.item] = (itemCounts[i.item] || 0) + (i.amount || 1);
                });
                Object.entries(itemCounts).forEach(([item, count]) => {
                    summary.push(`+${count} ${item}`);
                });
            }

            // Remove from fleet
            agentFleet.splice(agentIndex, 1);

            // Announce
            const summaryStr = summary.length > 0 ? ` Earnings: ${summary.join(', ')}` : '';
            addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} recalled!${summaryStr}`, 'ai');

            updateFleetUI();
            updateFleetButton();
        }

        // Update the fleet button indicator
        function updateFleetButton() {
            const btn = document.getElementById('fleet-button');
            if (agentFleet.length > 0) {
                btn.classList.add('has-agents');
                btn.setAttribute('data-count', agentFleet.length);
            } else {
                btn.classList.remove('has-agents');
            }
        }

        // Update the fleet panel UI
        function updateFleetUI() {
            document.getElementById('fleet-count').textContent = `${agentFleet.length}/${MAX_AGENTS}`;

            // Update spawn buttons disabled state
            const spawnBtns = document.querySelectorAll('.agent-spawn-btn');
            spawnBtns.forEach(btn => {
                btn.disabled = agentFleet.length >= MAX_AGENTS;
            });

            // Update agent list
            const listContainer = document.getElementById('agent-fleet-list');

            if (agentFleet.length === 0) {
                listContainer.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                        No agents deployed yet.<br>Click an agent type above to spawn.
                    </div>
                `;
                return;
            }

            listContainer.innerHTML = agentFleet.map(agent => {
                const colorHex = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');
                const statusDotClass = agent.status === 'thinking' ? 'thinking' : (agent.status === 'idle' ? 'idle' : '');

                const recentResults = agent.results.slice(-3).map(r => {
                    if (r.item) return `+${r.amount} ${r.item}`;
                    if (r.xp) return `+${r.xp} XP`;
                    if (r.gold) return `+${r.gold} Gold`;
                    if (r.heal) return `+${r.heal} HP`;
                    if (r.discovery) return r.discovery.substring(0, 20);
                    return '';
                }).filter(Boolean);

                return `
                    <div class="agent-card" data-agent-id="${agent.id}">
                        <div class="agent-card-header">
                            <div class="agent-identity">
                                <div class="agent-avatar ${agent.typeConfig.colorClass}" style="background: ${colorHex}22;">
                                    ${agent.typeConfig.icon}
                                </div>
                                <div class="agent-info">
                                    <div class="agent-name">${agent.name}</div>
                                    <div class="agent-role">${agent.typeConfig.name}</div>
                                </div>
                            </div>
                            <div class="agent-actions">
                                <button class="agent-action-btn export" onclick="exportAgentTranscript('${agent.id}')" title="Export transcript">ðŸ“‹</button>
                                <button class="agent-action-btn recall" onclick="recallAgent('${agent.id}')" title="Recall agent">âœ•</button>
                            </div>
                        </div>
                        <div class="agent-card-status">
                            <div class="agent-status-dot ${statusDotClass}"></div>
                            <span class="status-text">${agent.statusMessage}</span>
                        </div>
                        <div class="agent-card-progress">
                            <div class="agent-progress-bar" style="width: ${agent.progress}%; background: ${colorHex};"></div>
                        </div>
                        ${recentResults.length > 0 ? `
                            <div class="agent-results-mini">
                                ${recentResults.map(r => `<span class="agent-result-tag">${r}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Update a single agent card UI
        function updateAgentCardUI(agent) {
            const card = document.querySelector(`.agent-card[data-agent-id="${agent.id}"]`);
            if (!card) return;

            const statusDot = card.querySelector('.agent-status-dot');
            const statusText = card.querySelector('.status-text');
            const progressBar = card.querySelector('.agent-progress-bar');

            if (statusDot) {
                statusDot.className = 'agent-status-dot';
                if (agent.status === 'thinking') statusDot.classList.add('thinking');
                if (agent.status === 'idle') statusDot.classList.add('idle');
            }

            if (statusText) statusText.textContent = agent.statusMessage;
            if (progressBar) progressBar.style.width = `${agent.progress}%`;

            // Update results
            const recentResults = agent.results.slice(-3).map(r => {
                if (r.item) return `+${r.amount} ${r.item}`;
                if (r.xp) return `+${r.xp} XP`;
                if (r.gold) return `+${r.gold} Gold`;
                if (r.heal) return `+${r.heal} HP`;
                if (r.discovery) return r.discovery.substring(0, 20);
                return '';
            }).filter(Boolean);

            let resultsDiv = card.querySelector('.agent-results-mini');
            if (recentResults.length > 0) {
                if (!resultsDiv) {
                    resultsDiv = document.createElement('div');
                    resultsDiv.className = 'agent-results-mini';
                    card.appendChild(resultsDiv);
                }
                resultsDiv.innerHTML = recentResults.map(r => `<span class="agent-result-tag">${r}</span>`).join('');
            }
        }

        // Update all agent meshes (called in game loop)
        function updateAgentFleetMeshes(deltaTime) {
            agentFleet.forEach(agent => {
                if (!agent.mesh) return;

                // Bobbing animation
                const time = performance.now() / 1000;
                const bobOffset = Math.sin(time * 2 + agent.id.charCodeAt(0)) * 0.2;
                agent.mesh.position.y = agent.position.y + bobOffset;

                // Slow rotation
                agent.mesh.rotation.y += deltaTime * 0.5;

                // Glow pulse
                if (agent.glow) {
                    agent.glow.material.opacity = 0.1 + Math.sin(time * 3) * 0.05;
                    agent.glow.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
                }

                // Move towards random target or player vicinity
                if (!agent.targetPosition || agent.mesh.position.distanceTo(agent.targetPosition) < 1) {
                    // Pick a new target near player
                    if (worldState.player) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            2 + Math.random() * 3,
                            (Math.random() - 0.5) * 20
                        );
                        agent.targetPosition = worldState.player.position.clone().add(offset);
                    }
                }

                // Move towards target
                if (agent.targetPosition) {
                    const direction = new THREE.Vector3().subVectors(agent.targetPosition, agent.mesh.position);
                    direction.y = 0; // Keep horizontal movement
                    if (direction.length() > 0.5) {
                        direction.normalize();
                        agent.mesh.position.x += direction.x * deltaTime * 3;
                        agent.mesh.position.z += direction.z * deltaTime * 3;
                        agent.position.copy(agent.mesh.position);
                    }
                }
            });
        }

        // Parse natural language commands for agent fleet
        function parseAgentFleetCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Spawn commands
            const spawnPatterns = [
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?gatherer/i, type: 'gatherer' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?hunter/i, type: 'hunter' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?scout/i, type: 'scout' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?protector/i, type: 'protector' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?healer/i, type: 'healer' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?fisher/i, type: 'fisher' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?miner/i, type: 'miner' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?explorer/i, type: 'explorer' },
                { pattern: /send\s+(a\s+)?(\d+\s+)?agent/i, type: null },
                { pattern: /deploy\s+(a\s+)?(\d+\s+)?agent/i, type: null },
            ];

            for (const { pattern, type } of spawnPatterns) {
                const match = lowerMsg.match(pattern);
                if (match) {
                    if (type) {
                        const count = parseInt(match[2]) || 1;
                        for (let i = 0; i < Math.min(count, MAX_AGENTS - agentFleet.length); i++) {
                            spawnAgent(type);
                        }
                        return true;
                    } else {
                        // Generic spawn - suggest opening the fleet panel
                        toggleAgentFleetPanel();
                        addCopilotMessage(`Fleet panel opened! Select an agent type to spawn.`, 'ai');
                        return true;
                    }
                }
            }

            // Alternative spawn phrases
            if (lowerMsg.includes('send agent') || lowerMsg.includes('send out') || lowerMsg.includes('deploy agent')) {
                toggleAgentFleetPanel();
                addCopilotMessage(`Fleet panel opened! Choose an agent type to deploy.`, 'ai');
                return true;
            }

            // Recall all agents
            if (lowerMsg.includes('recall all') || lowerMsg.includes('bring back all') || lowerMsg.includes('return all agents')) {
                if (agentFleet.length > 0) {
                    const count = agentFleet.length;
                    [...agentFleet].forEach(agent => recallAgent(agent.id));
                    addCopilotMessage(`Recalled all ${count} agents!`, 'ai');
                    return true;
                } else {
                    addCopilotMessage(`No agents are currently deployed.`, 'ai');
                    return true;
                }
            }

            // Fleet status
            if (lowerMsg.includes('fleet status') || lowerMsg.includes('agent status') || lowerMsg.includes('how many agents')) {
                if (agentFleet.length === 0) {
                    addCopilotMessage(`No agents deployed. Open the fleet panel (ðŸ¤– button) to spawn agents!`, 'ai');
                } else {
                    const summary = agentFleet.map(a => `${a.typeConfig.icon} ${a.name} (${a.typeConfig.name})`).join(', ');
                    addCopilotMessage(`${agentFleet.length}/${MAX_AGENTS} agents deployed: ${summary}`, 'ai');
                }
                return true;
            }

            // Open fleet panel
            if (lowerMsg.includes('open fleet') || lowerMsg.includes('show agents') || lowerMsg.includes('agent panel')) {
                toggleAgentFleetPanel();
                return true;
            }

            return false;
        }

        // ============================================
        // v5.10: TRANSCRIPT EXPORT SYSTEM
        // Export agent transcripts for debugging
        // ============================================
        let currentTranscriptAgentId = null;

        // v5.12.1: Build a standard transcript JSON for an agent (includes endpoint config)
        function buildAgentTranscript(agent) {
            const elapsed = (performance.now() - agent.spawnTime) / 1000;
            const agentEndpoint = getAgentEndpoint(agent);

            return {
                transcript_version: "1.1",
                export_timestamp: new Date().toISOString(),
                application: "LEVIATHAN: OMNIVERSE",
                application_version: VERSION,
                agent: {
                    id: agent.id,
                    name: agent.name,
                    type: agent.type,
                    type_config: {
                        icon: agent.typeConfig.icon,
                        name: agent.typeConfig.name,
                        decision_interval_ms: agent.typeConfig.decisionInterval,
                        task_type: agent.typeConfig.taskType
                    },
                    status: agent.status,
                    status_message: agent.statusMessage,
                    progress_percent: Math.round(agent.progress),
                    spawn_time: new Date(Date.now() - elapsed * 1000).toISOString(),
                    runtime_seconds: Math.floor(elapsed)
                },
                // v5.12.1: Endpoint configuration for spawning agents with different AI providers
                endpoint_config: {
                    name: agentEndpoint.name,
                    url: agent.endpointConfig?.url || '${URL_PLACEHOLDER}',
                    apiKey: agent.endpointConfig?.apiKey ? '${API_KEY_PLACEHOLDER}' : null,
                    urlKey: agent.endpointConfig?.urlKey || null,
                    apiKeyKey: agent.endpointConfig?.apiKeyKey || null,
                    headerStyle: agentEndpoint.headerStyle,
                    headerPrefix: agentEndpoint.headerPrefix || '',
                    bodyFormat: agentEndpoint.bodyFormat,
                    model: agent.endpointConfig?.model || null,
                    active_endpoint: agent.activeEndpoint || 'default'
                },
                game_context: {
                    player_hp: gameData.player?.hp || 100,
                    player_max_hp: gameData.player?.maxHp || 100,
                    current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planet_name: worldState?.currentCiv?.name || 'Unknown',
                    player_position: worldState.player ? {
                        x: Math.floor(worldState.player.position.x),
                        z: Math.floor(worldState.player.position.z)
                    } : null
                },
                earnings: {
                    total_xp: agent.totalEarnings.xp,
                    total_gold: agent.totalEarnings.gold,
                    items_collected: agent.totalEarnings.items
                },
                results_log: agent.results,
                conversation_history: agent.conversationHistory.map((msg, idx) => ({
                    index: idx,
                    role: msg.role,
                    content: msg.content,
                    // Include endpoint in first message for transcript re-import
                    endpoint: idx === 0 && agent.endpointConfig ? {
                        url: agent.endpointConfig.url || '${URL_PLACEHOLDER}',
                        apiKey: '${API_KEY_PLACEHOLDER}',
                        headerStyle: agent.endpointConfig.headerStyle,
                        bodyFormat: agent.endpointConfig.bodyFormat,
                        model: agent.endpointConfig.model
                    } : undefined,
                    timestamp: null
                })),
                system_prompt: agent.conversationHistory.length > 0 ? agent.conversationHistory[0].content : null,
                total_messages: agent.conversationHistory.length,
                api_endpoint: agentEndpoint.url || 'local-simulation'
            };
        }

        // Build transcript for all agents
        function buildAllAgentTranscripts() {
            return {
                transcript_version: "1.0",
                export_timestamp: new Date().toISOString(),
                application: "LEVIATHAN: OMNIVERSE",
                application_version: "5.10",
                fleet_summary: {
                    total_agents: agentFleet.length,
                    max_agents: MAX_AGENTS,
                    agent_types: agentFleet.reduce((acc, a) => {
                        acc[a.type] = (acc[a.type] || 0) + 1;
                        return acc;
                    }, {}),
                    total_xp_earned: agentFleet.reduce((sum, a) => sum + a.totalEarnings.xp, 0),
                    total_gold_earned: agentFleet.reduce((sum, a) => sum + a.totalEarnings.gold, 0),
                    total_items_collected: agentFleet.reduce((sum, a) => sum + a.totalEarnings.items.length, 0)
                },
                game_context: {
                    player_hp: gameData.player?.hp || 100,
                    player_max_hp: gameData.player?.maxHp || 100,
                    current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planet_name: worldState?.currentCiv?.name || 'Unknown'
                },
                agents: agentFleet.map(agent => buildAgentTranscript(agent)),
                copilot_conversation_history: copilotConversationHistory
            };
        }

        // Open transcript viewer modal
        function openTranscriptViewer() {
            const modal = document.getElementById('transcript-modal');
            modal.classList.add('active');

            // Build tabs
            const tabsContainer = document.getElementById('transcript-tabs');
            let tabsHtml = `<button class="transcript-tab active" onclick="selectTranscriptTab('all')">ðŸ“¦ All Agents</button>`;

            agentFleet.forEach(agent => {
                tabsHtml += `<button class="transcript-tab" onclick="selectTranscriptTab('${agent.id}')">${agent.typeConfig.icon} ${agent.name}</button>`;
            });

            // Add copilot main chat
            tabsHtml += `<button class="transcript-tab" onclick="selectTranscriptTab('copilot')">â­ Main Copilot</button>`;

            tabsContainer.innerHTML = tabsHtml;

            // Show all agents by default
            selectTranscriptTab('all');
        }

        // Close transcript viewer
        function closeTranscriptViewer() {
            document.getElementById('transcript-modal').classList.remove('active');
        }

        // Select a transcript tab
        function selectTranscriptTab(agentId) {
            currentTranscriptAgentId = agentId;

            // Update tab active state
            document.querySelectorAll('.transcript-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            const infoContainer = document.getElementById('transcript-agent-info');
            const jsonView = document.getElementById('transcript-json-view');

            if (agentId === 'all') {
                // Show all agents summary
                const transcript = buildAllAgentTranscripts();
                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total Agents</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_agents}/${MAX_AGENTS}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total XP</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_xp_earned}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total Gold</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_gold_earned}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Items Collected</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_items_collected}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            } else if (agentId === 'copilot') {
                // Show main copilot conversation
                const transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory.map((msg, idx) => ({
                        index: idx,
                        role: msg.role,
                        content: msg.content
                    })),
                    total_messages: copilotConversationHistory.length,
                    rappid_settings: {
                        enabled: rappidSettings.rappid,
                        endpoint: getActiveEndpoint()?.name || 'none',
                        tts_enabled: !!rappidSettings.azureTTSKey
                    }
                };
                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Type</div>
                        <div class="transcript-info-value">Main Copilot</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Messages</div>
                        <div class="transcript-info-value">${copilotConversationHistory.length}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">RAPPID</div>
                        <div class="transcript-info-value">${rappidSettings.rappid ? 'Enabled' : 'Disabled'}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            } else {
                // Show specific agent
                const agent = agentFleet.find(a => a.id === agentId);
                if (!agent) {
                    jsonView.innerHTML = '<span style="color: #ff4444;">Agent not found</span>';
                    return;
                }

                const transcript = buildAgentTranscript(agent);
                const elapsed = Math.floor((performance.now() - agent.spawnTime) / 1000);

                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Agent</div>
                        <div class="transcript-info-value">${agent.typeConfig.icon} ${agent.name}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Type</div>
                        <div class="transcript-info-value">${agent.typeConfig.name}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Status</div>
                        <div class="transcript-info-value">${agent.status}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Runtime</div>
                        <div class="transcript-info-value">${elapsed}s</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Messages</div>
                        <div class="transcript-info-value">${agent.conversationHistory.length}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">XP Earned</div>
                        <div class="transcript-info-value">${agent.totalEarnings.xp}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            }
        }

        // Syntax highlight JSON for display
        function syntaxHighlightJSON(json) {
            return json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
                    let cls = 'number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = 'key';
                        } else {
                            cls = 'string';
                        }
                    } else if (/true|false/.test(match)) {
                        cls = 'boolean';
                    } else if (/null/.test(match)) {
                        cls = 'null';
                    }
                    return `<span class="${cls}">${match}</span>`;
                });
        }

        // Copy current transcript to clipboard
        function copyTranscriptToClipboard() {
            let transcript;
            if (currentTranscriptAgentId === 'all') {
                transcript = buildAllAgentTranscripts();
            } else if (currentTranscriptAgentId === 'copilot') {
                transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory
                };
            } else {
                const agent = agentFleet.find(a => a.id === currentTranscriptAgentId);
                if (!agent) return;
                transcript = buildAgentTranscript(agent);
            }

            navigator.clipboard.writeText(JSON.stringify(transcript, null, 2)).then(() => {
                showNotification('Transcript copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Copy failed:', err);
                showNotification('Failed to copy transcript', 'error');
            });
        }

        // Download current transcript as JSON file
        function downloadCurrentTranscript() {
            let transcript;
            let filename;

            if (currentTranscriptAgentId === 'all') {
                transcript = buildAllAgentTranscripts();
                filename = `leviathan-fleet-transcript-${new Date().toISOString().split('T')[0]}.json`;
            } else if (currentTranscriptAgentId === 'copilot') {
                transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory
                };
                filename = `leviathan-copilot-transcript-${new Date().toISOString().split('T')[0]}.json`;
            } else {
                const agent = agentFleet.find(a => a.id === currentTranscriptAgentId);
                if (!agent) return;
                transcript = buildAgentTranscript(agent);
                filename = `leviathan-agent-${agent.name.toLowerCase()}-transcript-${new Date().toISOString().split('T')[0]}.json`;
            }

            downloadJSON(transcript, filename);
        }

        // Download all transcripts as a single JSON file
        function downloadAllTranscripts() {
            const transcript = buildAllAgentTranscripts();
            const filename = `leviathan-full-fleet-export-${new Date().toISOString().split('T')[0]}.json`;
            downloadJSON(transcript, filename);
        }

        // Helper to download JSON
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
            showNotification(`Downloaded: ${filename}`, 'success');
        }

        // Export single agent transcript (for agent card button)
        function exportAgentTranscript(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            const transcript = buildAgentTranscript(agent);
            const filename = `leviathan-agent-${agent.name.toLowerCase()}-transcript-${new Date().toISOString().split('T')[0]}.json`;
            downloadJSON(transcript, filename);
        }

        // Import transcript file (for replaying/debugging)
        function importTranscriptFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const transcript = JSON.parse(e.target.result);
                    console.log('Imported transcript:', transcript);

                    // Validate transcript structure
                    if (!transcript.transcript_version) {
                        showNotification('Invalid transcript format', 'error');
                        return;
                    }

                    // Show in console for debugging
                    console.log('=== IMPORTED TRANSCRIPT ===');
                    console.log('Version:', transcript.transcript_version);
                    console.log('Application:', transcript.application);

                    if (transcript.agents) {
                        console.log('Fleet with', transcript.agents.length, 'agents');
                        transcript.agents.forEach(agent => {
                            console.log(`  - ${agent.agent.name} (${agent.agent.type}): ${agent.total_messages} messages`);
                        });
                    } else if (transcript.agent) {
                        console.log('Single agent:', transcript.agent.name);
                        console.log('Messages:', transcript.total_messages);
                    } else if (transcript.type === 'main_copilot') {
                        console.log('Main copilot conversation');
                        console.log('Messages:', transcript.conversation_history?.length);
                    }

                    showNotification('Transcript imported - check console for details', 'success');

                    // Open transcript viewer with imported data
                    // (Could add more functionality here to replay transcripts)

                } catch (error) {
                    console.error('Import failed:', error);
                    showNotification('Failed to parse transcript file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Context-aware responses based on game state
        const COPILOT_RESPONSES = {
            greeting: [
                "Hello, Explorer! Ready for adventure?",
                "Greetings! I'm here to help you on your journey.",
                "Welcome back! What shall we explore today?"
            ],
            lowHealth: [
                "Careful! Your health is low. Consider using a health potion or retreating.",
                "You're wounded! Look for healing items or rest at a safe spot.",
                "Warning: Low HP! Maybe craft some health potions?"
            ],
            nearEnemy: [
                "Enemy spotted nearby! Prepare for combat.",
                "Be cautious, there's a hostile creature close by.",
                "I sense danger ahead. Ready your weapon!"
            ],
            afterKill: [
                "Well done! That was impressive combat.",
                "Excellent work, Explorer!",
                "Another victory! Your skills are improving."
            ],
            exploration: [
                "This area looks interesting. Let's explore!",
                "I wonder what secrets this place holds...",
                "Keep your eyes open for resources and treasures."
            ],
            tips: [
                "Tip: Use WASD to move and click to attack enemies.",
                "Tip: Collect resources to craft better equipment.",
                "Tip: Your combat skill increases as you defeat enemies.",
                "Tip: Look for points of interest marked on the minimap.",
                "Tip: Different biomes have different resources and enemies.",
                "Tip: Pets can help you in combat and provide bonuses."
            ],
            whatNext: [
                "Try exploring new areas to find resources and level up.",
                "You could hunt some enemies to gain XP and loot.",
                "Check your inventory - maybe craft some new equipment.",
                "Have you discovered all the points of interest on this planet?"
            ],
            getStronger: [
                "Fight enemies to gain combat XP and level up your skills.",
                "Craft better weapons and armor from the resources you gather.",
                "Find and bond with a pet companion for stat bonuses.",
                "Complete daily challenges for bonus rewards.",
                "Unlock talents in the talent tree as you level up."
            ],
            enemies: [
                "Enemies respawn periodically throughout the world.",
                "Look for the red markers on your minimap.",
                "Elite enemies (marked with special effects) drop better loot.",
                "Different biomes have different enemy types."
            ]
        };

        function initCopilotCompanion() {
            // Initialize speech recognition if available (browser fallback)
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                copilotVoiceRecognition = new SpeechRecognition();
                copilotVoiceRecognition.continuous = false;
                copilotVoiceRecognition.interimResults = true; // v5.9: Enable interim results
                copilotVoiceRecognition.lang = 'en-US';

                copilotVoiceRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    // Update overlay with real-time transcription
                    if (finalTranscript) {
                        updateSTTTranscript(finalTranscript, true);
                    } else if (interimTranscript) {
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                copilotVoiceRecognition.onend = () => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotVoiceRecognition.onerror = (event) => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                    showSTTOverlay(false);
                    console.error('Browser STT error:', event.error);
                };
            }
        }

        function createCopilotMesh() {
            if (copilotMesh) {
                scene.remove(copilotMesh);
                copilotMesh = null;
            }

            if (mode !== 'world' || !worldState.player) return;

            const companionGroup = new THREE.Group();

            // Main orb
            const orbGeometry = new THREE.SphereGeometry(0.5, 24, 24);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: COPILOT_CONFIG.color,
                emissive: COPILOT_CONFIG.color,
                emissiveIntensity: 0.6,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            companionGroup.add(orb);

            // Inner glow core
            const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            companionGroup.add(core);

            // Outer glow
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            companionGroup.add(glow);

            // Point light for illumination
            const light = new THREE.PointLight(COPILOT_CONFIG.glowColor, 1.5, 8);
            companionGroup.add(light);

            // Particle ring
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = COPILOT_CONFIG.particleCount;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                const angle = (i / 3) * (Math.PI * 2 / particleCount);
                const radius = 0.8 + Math.random() * 0.3;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = (Math.random() - 0.5) * 0.4;
                positions[i + 2] = Math.sin(angle) * radius;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: COPILOT_CONFIG.glowColor,
                size: 0.08,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            companionGroup.add(particles);

            // Store references for animation
            companionGroup.userData = {
                orb: orb,
                core: core,
                glow: glow,
                light: light,
                particles: particles,
                isClickable: true,
                isCopilot: true
            };

            // v5.11: Create text groups for Star Wars crawl - optimized for cinematic camera
            copilotTextGroup = new THREE.Group();
            copilotTextGroup.position.set(0, 8, 6); // Higher and forward toward camera
            copilotTextGroup.rotation.x = THREE.MathUtils.degToRad(-55); // Steeper tilt to face down-looking camera
            companionGroup.add(copilotTextGroup);

            copilotPersistentTextGroup = new THREE.Group();
            copilotPersistentTextGroup.position.set(0, 12, 4); // Much higher, toward camera
            copilotPersistentTextGroup.rotation.x = THREE.MathUtils.degToRad(-45); // Tilt to face camera
            companionGroup.add(copilotPersistentTextGroup);

            // Load font for 3D text
            loadCopilotTextFont();

            // Position initially near player
            if (worldState.player) {
                companionGroup.position.copy(worldState.player.position);
                companionGroup.position.y += COPILOT_CONFIG.floatHeight;
                companionGroup.position.z += COPILOT_CONFIG.followDistance;
            }

            scene.add(companionGroup);
            copilotMesh = companionGroup;
        }

        // v5.10: Load font for 3D text rendering
        function loadCopilotTextFont() {
            if (copilotTextFont) return; // Already loaded

            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                copilotTextFont = font;
                console.log('Copilot 3D text font loaded');
            }, undefined, (err) => {
                console.warn('Failed to load 3D text font:', err);
            });
        }

        // v5.10: Animate voice response as Star Wars text crawl
        function animateCopilotTextCrawl(text) {
            if (!copilotTextFont || !copilotTextGroup || !copilotMesh) {
                console.log('Text crawl not ready - font or groups not initialized');
                return;
            }

            // Cancel any existing animation
            if (copilotActiveTextAnimation) {
                cancelAnimationFrame(copilotActiveTextAnimation);
                copilotActiveTextAnimation = null;
            }

            // Clear existing text meshes
            copilotTextMeshes.forEach(mesh => {
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
                copilotTextGroup.remove(mesh);
            });
            copilotTextMeshes = [];
            copilotTextGroup.position.y = 8; // v5.11: Reset to cinematic position

            // v5.11: Word wrap text into lines - larger text for visibility
            const maxCharsPerLine = 20; // Shorter lines for larger text
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine) {
                    if (currentLine) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                }
                currentLine += word + ' ';
            });
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            // v5.11: Create 3D text for each line - MUCH LARGER for camera distance visibility
            const lineHeight = 2.2; // Increased from 0.6 for larger text
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x06ffa5,
                emissiveIntensity: 0.8, // Brighter glow
                metalness: 0.4,
                roughness: 0.3,
                transparent: true,
                opacity: 1
            });

            lines.forEach((line, index) => {
                try {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: copilotTextFont,
                        size: 1.2, // v5.11: Increased from 0.25 - much larger for visibility
                        height: 0.1, // Increased depth
                        curveSegments: 8,
                        bevelEnabled: true,
                        bevelThickness: 0.02,
                        bevelSize: 0.015,
                        bevelSegments: 4
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, textMaterial.clone());
                    textMesh.position.y = -index * lineHeight;

                    copilotTextGroup.add(textMesh);
                    copilotTextMeshes.push(textMesh);
                } catch (e) {
                    console.warn('Failed to create text geometry for line:', line, e);
                }
            });

            const totalHeight = lines.length * lineHeight;
            animateStarWarsScroll(totalHeight, text);
        }

        // v5.11: Animate the scrolling like Star Wars - adjusted for larger text
        function animateStarWarsScroll(totalHeight, fullText) {
            const scrollSpeed = 0.04; // Faster scroll for larger text
            const startY = 0;
            const endY = totalHeight + 15; // More distance for larger text
            let currentY = startY;

            const animate = () => {
                if (!copilotTextGroup || copilotTextMeshes.length === 0) return;

                currentY += scrollSpeed;
                copilotTextGroup.position.y = 8 + currentY; // v5.11: Match cinematic starting position

                // Fade based on Y position for depth effect
                copilotTextMeshes.forEach((mesh, index) => {
                    const meshWorldY = currentY - index * 2.2; // Match new lineHeight

                    // Fade in from bottom
                    if (meshWorldY < 0) {
                        mesh.material.opacity = Math.max(0, 1 + meshWorldY * 0.3);
                    }
                    // Fade out at top
                    else if (meshWorldY > totalHeight - 5) {
                        mesh.material.opacity = Math.max(0, 1 - (meshWorldY - (totalHeight - 5)) / 5);
                    }
                    else {
                        mesh.material.opacity = 1;
                    }
                });

                // Check if scroll is complete
                if (currentY > endY) {
                    createPersistentCopilotText(fullText);
                    fadeOutCopilotText();
                    return;
                }

                copilotActiveTextAnimation = requestAnimationFrame(animate);
            };

            animate();
        }

        // v5.11: Create persistent abbreviated text after scroll completes - larger for visibility
        function createPersistentCopilotText(text) {
            // Clear existing persistent text
            if (copilotPersistentTextGroup) {
                copilotPersistentTextGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                copilotPersistentTextGroup.clear();
            }

            if (!copilotTextFont || !copilotPersistentTextGroup) return;

            // Truncate text for persistent display
            const maxLength = 50;
            const displayText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;

            // Word wrap - shorter lines for larger text
            const lines = [];
            const maxCharsPerLine = 18;
            const words = displayText.split(' ');
            let currentLine = '';

            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine) {
                    if (currentLine) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                }
                currentLine += word + ' ';
            });
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            const displayLines = lines.slice(0, 2); // Only first 2 lines

            const lineHeight = 1.4; // v5.11: Increased for larger text
            const persistentMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x8a2be2,
                emissiveIntensity: 0.5, // Brighter
                metalness: 0.3,
                roughness: 0.5,
                transparent: true,
                opacity: 0.85
            });

            displayLines.forEach((line, index) => {
                try {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: copilotTextFont,
                        size: 0.7, // v5.11: Much larger for visibility
                        height: 0.06,
                        curveSegments: 6,
                        bevelEnabled: true,
                        bevelThickness: 0.012,
                        bevelSize: 0.008,
                        bevelSegments: 3
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, persistentMaterial.clone());
                    textMesh.position.y = -index * lineHeight;

                    copilotPersistentTextGroup.add(textMesh);
                } catch (e) {
                    console.warn('Failed to create persistent text:', e);
                }
            });
        }

        // v5.10: Fade out scrolling text after animation completes
        function fadeOutCopilotText() {
            let opacity = 1;
            const fadeSpeed = 0.03;

            const fade = () => {
                opacity -= fadeSpeed;

                if (opacity <= 0) {
                    copilotTextMeshes.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                        copilotTextGroup.remove(mesh);
                    });
                    copilotTextMeshes = [];
                    copilotTextGroup.position.y = 8; // v5.11: Cinematic reset position
                    return;
                }

                copilotTextMeshes.forEach(mesh => {
                    mesh.material.opacity = opacity;
                });

                requestAnimationFrame(fade);
            };

            fade();
        }

        function updateCopilotCompanion(dt, time) {
            if (!copilotMesh || !worldState.player || mode !== 'world') return;

            copilotAnimTime += dt;

            // Calculate target position (behind and above player)
            const playerPos = worldState.player.position;
            const playerRotY = worldState.player.rotation.y;

            // Orbit slightly around the player
            const orbitAngle = copilotAnimTime * COPILOT_CONFIG.orbitSpeed;
            const offsetX = Math.sin(playerRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;
            const offsetZ = Math.cos(playerRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;

            const targetX = playerPos.x + offsetX;
            const targetZ = playerPos.z + offsetZ;
            const targetY = playerPos.y + COPILOT_CONFIG.floatHeight +
                           Math.sin(copilotAnimTime * COPILOT_CONFIG.floatSpeed) * COPILOT_CONFIG.floatAmplitude;

            // Smooth follow
            const smoothing = COPILOT_CONFIG.followSmoothing * dt;
            copilotMesh.position.x += (targetX - copilotMesh.position.x) * smoothing;
            copilotMesh.position.z += (targetZ - copilotMesh.position.z) * smoothing;
            copilotMesh.position.y += (targetY - copilotMesh.position.y) * smoothing;

            // Rotate particles
            if (copilotMesh.userData.particles) {
                copilotMesh.userData.particles.rotation.y += dt * 1.5;
            }

            // Pulse glow effect
            const pulse = 0.5 + Math.sin(time * 0.003) * 0.3;
            if (copilotMesh.userData.glow) {
                copilotMesh.userData.glow.material.opacity = 0.15 + pulse * 0.1;
            }
            if (copilotMesh.userData.light) {
                copilotMesh.userData.light.intensity = 1 + pulse;
            }
            if (copilotMesh.userData.orb) {
                copilotMesh.userData.orb.material.emissiveIntensity = 0.4 + pulse * 0.4;
            }

            // Make copilot face camera
            copilotMesh.lookAt(camera.position);
        }

        function toggleCopilotChat() {
            copilotChatOpen = !copilotChatOpen;
            const chatInterface = document.getElementById('copilot-chat-interface');
            const button = document.getElementById('copilot-button');

            if (copilotChatOpen) {
                chatInterface.classList.add('active');
                button.classList.add('active');
                document.getElementById('copilot-chat-input').focus();
            } else {
                chatInterface.classList.remove('active');
                button.classList.remove('active');
            }
        }

        async function sendCopilotMessage() {
            const input = document.getElementById('copilot-chat-input');
            const message = input.value.trim();
            if (!message) return;

            // Add user message to chat
            addCopilotMessage(message, 'user');
            input.value = '';

            // v5.9: Check for task commands first (gather, hunt, scout, etc.)
            if (parseCopilotTaskCommand(message)) {
                // Task command handled - skip normal response flow
                return;
            }

            // v5.10: Check for agent fleet commands
            if (parseAgentFleetCommand(message)) {
                // Fleet command handled
                return;
            }

            // Add to history
            copilotConversationHistory.push({ role: 'user', content: message });

            // Show typing indicator
            showCopilotTyping();

            // Check if RAPPID is configured for AI-powered responses
            const hasRappid = rappidSettings.rappid && getActiveEndpoint();

            if (hasRappid) {
                // Use RAPPID API for response
                try {
                    // v5.9: Response now contains { text, voice } - text for display, voice for TTS
                    const response = await generateCopilotResponseWithRappid(message);
                    hideCopilotTyping();
                    // Display the full text response in chat
                    addCopilotMessage(response.text, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response.text });
                    animateCopilotResponse();

                    // v5.9: Use voice_response for TTS (concise, no formatting)
                    // v5.10: Also trigger Star Wars 3D text crawl
                    animateCopilotTextCrawl(response.voice);

                    if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                        speakWithAzureTTS(response.voice);
                    } else {
                        speakCopilotResponse(response.voice);
                    }
                } catch (error) {
                    console.error('RAPPID response error:', error);
                    hideCopilotTyping();
                    const fallbackResponse = generateCopilotResponse(message);
                    addCopilotMessage(fallbackResponse, 'ai');
                    speakCopilotResponse(fallbackResponse);
                    animateCopilotTextCrawl(fallbackResponse); // v5.10: Text crawl for fallback
                }
            } else {
                // Use local responses
                setTimeout(() => {
                    hideCopilotTyping();
                    const response = generateCopilotResponse(message);
                    addCopilotMessage(response, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response });

                    // Animate copilot when responding
                    animateCopilotResponse();

                    // v5.10: Star Wars 3D text crawl
                    animateCopilotTextCrawl(response);

                    // Optionally speak the response
                    speakCopilotResponse(response);
                }, 800 + Math.random() * 700);
            }
        }

        function sendCopilotQuickMessage(message) {
            document.getElementById('copilot-chat-input').value = message;
            sendCopilotMessage();
        }

        function generateCopilotResponse(message) {
            const lowerMessage = message.toLowerCase();

            // Context-aware responses
            if (lowerMessage.includes('health') || lowerMessage.includes('hp') || lowerMessage.includes('hurt')) {
                if (gameData.player.hp < gameData.player.maxHp * 0.3) {
                    return getRandomResponse(COPILOT_RESPONSES.lowHealth);
                }
                return `Your health is ${gameData.player.hp}/${gameData.player.maxHp}. ${gameData.player.hp < gameData.player.maxHp * 0.5 ? 'Consider healing up!' : 'You\'re in good shape!'}`;
            }

            if (lowerMessage.includes('tip') || lowerMessage.includes('help') || lowerMessage.includes('advice')) {
                return getRandomResponse(COPILOT_RESPONSES.tips);
            }

            if (lowerMessage.includes('what') && (lowerMessage.includes('next') || lowerMessage.includes('do'))) {
                return getRandomResponse(COPILOT_RESPONSES.whatNext);
            }

            if (lowerMessage.includes('strong') || lowerMessage.includes('level') || lowerMessage.includes('power')) {
                return getRandomResponse(COPILOT_RESPONSES.getStronger);
            }

            if (lowerMessage.includes('enemy') || lowerMessage.includes('enemies') || lowerMessage.includes('monster')) {
                return getRandomResponse(COPILOT_RESPONSES.enemies);
            }

            if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                return getRandomResponse(COPILOT_RESPONSES.greeting);
            }

            if (lowerMessage.includes('explore') || lowerMessage.includes('where')) {
                return getRandomResponse(COPILOT_RESPONSES.exploration);
            }

            if (lowerMessage.includes('stats') || lowerMessage.includes('status')) {
                return `Stats: Combat Lvl ${gameData.skills.combat.level}, HP: ${gameData.player.hp}/${gameData.player.maxHp}, XP: ${gameData.skills.combat.xp}/${gameData.skills.combat.xpNeeded}`;
            }

            if (lowerMessage.includes('pet') || lowerMessage.includes('companion')) {
                const activePet = gameData.pets?.active;
                if (activePet) {
                    const pet = PET_TYPES[activePet];
                    return `You have ${pet.name} (${pet.icon}) as your pet companion. ${pet.abilityDesc}. You can find more pets by defeating enemies!`;
                }
                return "You don't have an active pet. Defeat enemies to find pet companions that can help you!";
            }

            // Default response
            const defaults = [
                "I'm here to help! Try asking about tips, enemies, or how to get stronger.",
                "Interesting question! I can help with game tips, enemy locations, and advice.",
                "Let me think... Try asking 'What should I do next?' or 'Give me a tip' for guidance.",
                "I'm your Copilot! Ask me about your health, enemies, or exploration tips."
            ];
            return getRandomResponse(defaults);
        }

        function getRandomResponse(responses) {
            return responses[Math.floor(Math.random() * responses.length)];
        }

        // v5.9: Simple markdown parser for chat messages
        function parseMarkdown(text) {
            if (!text) return '';

            // First, protect markdown links from URL matching
            const linkPlaceholders = [];
            let processedText = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
                const placeholder = `__LINK_${linkPlaceholders.length}__`;
                linkPlaceholders.push({ text: linkText, url: url });
                return placeholder;
            });

            // Convert plain URLs to markdown links (before escaping)
            processedText = processedText.replace(/(^|[\s(])(https?:\/\/[^\s)<]+)/g, (match, prefix, url) => {
                // Shorten URL for display
                let displayUrl = url;
                try {
                    const urlObj = new URL(url);
                    displayUrl = urlObj.hostname + (urlObj.pathname.length > 20 ? urlObj.pathname.substring(0, 20) + '...' : urlObj.pathname);
                } catch (e) {
                    displayUrl = url.length > 40 ? url.substring(0, 40) + '...' : url;
                }
                const placeholder = `__LINK_${linkPlaceholders.length}__`;
                linkPlaceholders.push({ text: displayUrl, url: url });
                return prefix + placeholder;
            });

            let html = processedText
                // Escape HTML first
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')

                // Code blocks (``` ... ```)
                .replace(/```(\w*)\n?([\s\S]*?)```/g, '<pre><code>$2</code></pre>')

                // Inline code (`code`)
                .replace(/`([^`]+)`/g, '<code>$1</code>')

                // Headers (### ## #)
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')

                // Bold (**text** or __text__) - but not our placeholders
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')

                // Italic (*text* or _text_) - but not underscores in placeholders
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')

                // Horizontal rule (---)
                .replace(/^---$/gm, '<hr>')

                // Blockquotes (> text)
                .replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>')

                // Unordered lists (- item)
                .replace(/^- (.+)$/gm, '<li>$1</li>')

                // Numbered lists (1. item)
                .replace(/^\d+\. (.+)$/gm, '<li>$1</li>')

                // Line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');

            // Restore link placeholders
            linkPlaceholders.forEach((link, index) => {
                const placeholder = `__LINK_${index}__`;
                html = html.replace(placeholder, `<a href="${link.url}" target="_blank" rel="noopener noreferrer">${link.text}</a>`);
            });

            // Wrap consecutive <li> elements in <ul>
            html = html.replace(/(<li>.*?<\/li>)(\s*<br>)?/g, '$1');
            html = html.replace(/(<li>[\s\S]*?<\/li>)+/g, '<ul>$&</ul>');

            // Wrap in paragraph if not already wrapped
            if (!html.startsWith('<h') && !html.startsWith('<ul') && !html.startsWith('<pre') && !html.startsWith('<blockquote')) {
                html = '<p>' + html + '</p>';
            }

            // Clean up empty paragraphs
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p><br><\/p>/g, '');

            return html;
        }

        function addCopilotMessage(text, sender) {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `copilot-message ${sender}`;

            if (sender === 'ai') {
                // Parse markdown for AI responses
                messageDiv.innerHTML = parseMarkdown(text);

                // Make sure all links open in new tab
                messageDiv.querySelectorAll('a').forEach(link => {
                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
            } else {
                // Plain text for user messages
                messageDiv.textContent = text;
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showCopilotTyping() {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'copilot-typing';
            typingDiv.className = 'copilot-typing';
            typingDiv.innerHTML = '<div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div>';
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideCopilotTyping() {
            const typing = document.getElementById('copilot-typing');
            if (typing) typing.remove();
        }

        function animateCopilotResponse() {
            if (!copilotMesh || !copilotMesh.userData.orb) return;

            const orb = copilotMesh.userData.orb;
            const originalScale = 1;
            let progress = 0;

            const animate = () => {
                progress += 0.08;
                if (progress > 1) return;

                const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                orb.scale.setScalar(scale);

                if (copilotMesh.userData.light) {
                    copilotMesh.userData.light.intensity = 2 + Math.sin(progress * Math.PI * 2) * 1.5;
                }

                requestAnimationFrame(animate);
            };
            animate();
        }

        function speakCopilotResponse(text) {
            if (!copilotSynthesis) return;

            // Cancel any ongoing speech
            copilotSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.1;
            utterance.volume = 0.8;

            // Try to use a female voice
            const voices = copilotSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.name.includes('Female') || v.name.includes('Samantha') || v.name.includes('Google'));
            if (preferredVoice) utterance.voice = preferredVoice;

            utterance.onstart = () => {
                document.getElementById('copilot-voice-indicator').classList.add('active');
            };

            utterance.onend = () => {
                document.getElementById('copilot-voice-indicator').classList.remove('active');
            };

            copilotSynthesis.speak(utterance);
        }

        // v5.9: Toggle voice input - click to start/stop
        let sttFinalTranscript = '';
        let sttAutoSend = localStorage.getItem('leviathan-stt-autosend') === 'true';

        // Initialize auto-send toggle state on load
        function initAutoSendToggle() {
            const toggle = document.getElementById('stt-auto-send-toggle');
            if (toggle) {
                toggle.checked = sttAutoSend;
            }
        }

        // Toggle auto-send setting
        function toggleAutoSend(enabled) {
            sttAutoSend = enabled;
            localStorage.setItem('leviathan-stt-autosend', enabled ? 'true' : 'false');
            console.log('Auto-send ' + (enabled ? 'enabled' : 'disabled'));
        }

        async function toggleCopilotVoice() {
            if (copilotIsListening) {
                stopCopilotVoice();
                return;
            }

            // Check if Azure Speech SDK should be used
            if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                await startAzureSTT();
            } else if (copilotVoiceRecognition) {
                // Fall back to browser speech recognition
                startBrowserSTT();
            } else {
                console.warn('No speech recognition available');
                alert('Speech recognition not available. Please configure Azure Speech key in RAPPID settings.');
            }
        }

        // Show/hide transcription overlay
        function showSTTOverlay(show) {
            const overlay = document.getElementById('stt-transcription-overlay');
            if (show) {
                overlay.classList.add('active');
                document.getElementById('stt-transcript-text').textContent = 'Speak now...';
                document.getElementById('stt-transcript-text').className = 'stt-transcript-text interim';
                document.getElementById('stt-status').textContent = 'Listening...';
                document.getElementById('stt-waveform').style.display = 'flex';
                document.getElementById('stt-actions').style.display = 'none';
                // Sync auto-send toggle state
                initAutoSendToggle();
            } else {
                overlay.classList.remove('active');
            }
        }

        // Update transcription display
        function updateSTTTranscript(text, isFinal) {
            const textEl = document.getElementById('stt-transcript-text');
            textEl.textContent = text || 'Speak now...';
            textEl.className = 'stt-transcript-text ' + (isFinal ? 'final' : 'interim');

            if (isFinal && text) {
                sttFinalTranscript = text;

                // Check if auto-send is enabled
                if (sttAutoSend) {
                    // Auto-send: show brief confirmation then send
                    document.getElementById('stt-status').textContent = 'Sending...';
                    document.getElementById('stt-waveform').style.display = 'none';
                    // Brief delay so user sees what was transcribed
                    setTimeout(() => {
                        sendSTTMessage();
                    }, 500);
                } else {
                    // Manual confirm: show action buttons
                    document.getElementById('stt-status').textContent = 'Ready to send';
                    document.getElementById('stt-waveform').style.display = 'none';
                    document.getElementById('stt-actions').style.display = 'flex';
                }
            }
        }

        // Send the transcribed message
        function sendSTTMessage() {
            if (sttFinalTranscript) {
                document.getElementById('copilot-chat-input').value = sttFinalTranscript;
                sendCopilotMessage();
            }
            showSTTOverlay(false);
            sttFinalTranscript = '';
        }

        // Cancel STT message
        function cancelSTTMessage() {
            showSTTOverlay(false);
            sttFinalTranscript = '';
            cleanupSTT();
        }

        // Retry STT
        function retrySTT() {
            sttFinalTranscript = '';
            showSTTOverlay(false);
            cleanupSTT();
            setTimeout(() => toggleCopilotVoice(), 200);
        }

        // Browser-based STT fallback
        function startBrowserSTT() {
            if (!copilotVoiceRecognition || copilotIsListening) return;

            try {
                copilotIsListening = true;
                document.getElementById('copilot-voice-btn').classList.add('recording');
                showSTTOverlay(true);
                copilotVoiceRecognition.start();
            } catch (e) {
                console.error('Browser STT error:', e);
                copilotIsListening = false;
                document.getElementById('copilot-voice-btn').classList.remove('recording');
                showSTTOverlay(false);
            }
        }

        // v5.9: Azure Speech-to-Text using Speech SDK with real-time transcription
        let sttInitializing = false;
        async function startAzureSTT() {
            // Prevent multiple simultaneous initializations
            if (sttInitializing || copilotIsListening) {
                console.log('STT already initializing or listening');
                return;
            }

            sttInitializing = true;
            sttFinalTranscript = '';

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser STT');
                    sttInitializing = false;
                    startBrowserSTT();
                    return;
                }

                // Clean up any existing recognizer first
                if (speechRecognizer) {
                    try {
                        speechRecognizer.close();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                    speechRecognizer = null;
                    // Small delay to ensure cleanup
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Request microphone permission first
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // Stop the test stream immediately
                    stream.getTracks().forEach(track => track.stop());
                } catch (permError) {
                    console.error('Microphone permission denied:', permError);
                    alert('Microphone access denied. Please allow microphone access to use voice input.');
                    sttInitializing = false;
                    return;
                }

                // Show the overlay
                showSTTOverlay(true);

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechRecognitionLanguage = 'en-US';

                // Use default microphone
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();

                // Create recognizer
                speechRecognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

                // Set up event handlers for real-time transcription
                let interimTranscript = '';

                // Recognizing event - fires with interim results
                speechRecognizer.recognizing = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
                        interimTranscript = e.result.text;
                        console.log('Azure STT interim:', interimTranscript);
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                // Recognized event - fires with final result
                speechRecognizer.recognized = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
                        const finalText = e.result.text;
                        console.log('Azure STT final:', finalText);
                        if (finalText && finalText.trim()) {
                            updateSTTTranscript(finalText, true);
                            // Stop continuous recognition after getting result
                            speechRecognizer.stopContinuousRecognitionAsync();
                        }
                    } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
                        console.log('Azure STT: No speech recognized');
                        updateSTTTranscript('No speech detected. Try again.', false);
                    }
                };

                // Canceled event
                speechRecognizer.canceled = (s, e) => {
                    console.warn('Azure STT canceled:', e.reason);
                    if (e.errorDetails) {
                        console.warn('Error details:', e.errorDetails);
                    }
                    cleanupSTT();
                    showSTTOverlay(false);
                };

                // Session stopped event
                speechRecognizer.sessionStopped = (s, e) => {
                    console.log('Azure STT session stopped');
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotIsListening = true;
                sttInitializing = false;
                document.getElementById('copilot-voice-btn').classList.add('recording');

                console.log('Azure STT: Starting continuous recognition...');

                // Start continuous recognition for real-time transcription
                speechRecognizer.startContinuousRecognitionAsync(
                    () => {
                        console.log('Azure STT: Continuous recognition started');
                    },
                    (error) => {
                        console.error('Azure STT start error:', error);
                        cleanupSTT();
                        showSTTOverlay(false);
                    }
                );
            } catch (error) {
                console.error('Azure STT initialization error:', error);
                sttInitializing = false;
                cleanupSTT();
                showSTTOverlay(false);

                // Fall back to browser STT
                startBrowserSTT();
            }
        }

        // Clean up STT resources
        function cleanupSTT() {
            copilotIsListening = false;
            sttInitializing = false;
            document.getElementById('copilot-voice-btn').classList.remove('recording');

            if (speechRecognizer) {
                try {
                    speechRecognizer.stopContinuousRecognitionAsync(
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        },
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        }
                    );
                } catch (e) {
                    try { speechRecognizer.close(); } catch(e2) {}
                    speechRecognizer = null;
                }
            }
        }

        function stopCopilotVoice() {
            // Stop Azure STT if active
            cleanupSTT();
            showSTTOverlay(false);

            // Stop browser STT if active
            if (copilotVoiceRecognition) {
                try {
                    copilotVoiceRecognition.stop();
                } catch (e) {
                    // Ignore
                }
            }
        }

        // Check for 3D copilot click
        function checkCopilotClick(event) {
            if (!copilotMesh || mode !== 'world') return false;

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(copilotMesh, true);
            if (intersects.length > 0) {
                toggleCopilotChat();
                return true;
            }
            return false;
        }

        // Contextual notifications from copilot
        let lastCopilotNotification = 0;
        function triggerCopilotContextualHelp(context) {
            const now = performance.now();
            if (now - lastCopilotNotification < 30000) return; // 30 second cooldown

            let message = '';
            switch (context) {
                case 'lowHealth':
                    message = getRandomResponse(COPILOT_RESPONSES.lowHealth);
                    break;
                case 'nearEnemy':
                    if (Math.random() < 0.3) message = getRandomResponse(COPILOT_RESPONSES.nearEnemy);
                    break;
                case 'afterKill':
                    if (Math.random() < 0.2) message = getRandomResponse(COPILOT_RESPONSES.afterKill);
                    break;
            }

            if (message) {
                lastCopilotNotification = now;
                addCopilotMessage(message, 'ai');
                if (copilotChatOpen) {
                    speakCopilotResponse(message);
                }
            }
        }

        // ============================================
        // v5.7: RAPPID INTEGRATION SYSTEM
        // AI-powered responses via external endpoints
        // ============================================
        const RAPPID_STORAGE_KEY = 'leviathan-rappid-settings';
        let rappidSettings = {
            rappid: false,
            endpoints: {},
            azureTTSKey: '',
            azureRegion: '',
            ttsVoiceName: 'en-US-JennyNeural',
            version: '1.0'
        };

        function loadRappidSettings() {
            try {
                const saved = localStorage.getItem(RAPPID_STORAGE_KEY);
                if (saved) {
                    rappidSettings = JSON.parse(saved);
                    console.log('RAPPID settings loaded');
                    updateRappidUI();
                }
            } catch (e) {
                console.error('Failed to load RAPPID settings:', e);
            }
        }

        function saveRappidSettings() {
            try {
                localStorage.setItem(RAPPID_STORAGE_KEY, JSON.stringify(rappidSettings));
                console.log('RAPPID settings saved');
            } catch (e) {
                console.error('Failed to save RAPPID settings:', e);
            }
        }

        // v5.7: AI Settings Modal Functions
        function openRappidModal() {
            document.getElementById('ai-settings-modal').classList.add('active');
            updateAISettingsUI();
        }

        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').classList.remove('active');
        }

        // Alias for backwards compatibility
        function closeRappidModal() {
            closeAISettingsModal();
        }

        function switchAITab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.ai-settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.ai-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('ai-tab-' + tabName).classList.add('active');
        }

        function updateAISettingsUI() {
            // Update General tab - API fields
            const activeEndpoint = getActiveEndpoint();
            if (activeEndpoint) {
                document.getElementById('ai-api-key').value = activeEndpoint.key || '';
                document.getElementById('ai-api-endpoint').value = activeEndpoint.url || '';
            }

            // Update endpoints list in General tab
            const endpointsList = document.getElementById('ai-endpoints-list');
            if (endpointsList && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsList.innerHTML = '<label style="display:block; margin: 15px 0 10px; font-size: 12px; color: #aaa;">Available Endpoints</label>';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsList.appendChild(div);
                });
            } else if (endpointsList) {
                endpointsList.innerHTML = '';
            }

            // Update Voice tab - TTS settings
            if (rappidSettings.azureTTSKey) {
                document.getElementById('ai-tts-key').value = rappidSettings.azureTTSKey;
            }
            if (rappidSettings.azureRegion) {
                document.getElementById('ai-tts-region').value = rappidSettings.azureRegion;
            }
            if (rappidSettings.ttsVoiceName) {
                document.getElementById('ai-tts-voice').value = rappidSettings.ttsVoiceName;
            }

            // Update Import/Export tab - endpoints preview
            const endpointsPreview = document.getElementById('ai-endpoints-preview');
            if (endpointsPreview && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsPreview.innerHTML = '';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsPreview.appendChild(div);
                });
            } else if (endpointsPreview) {
                endpointsPreview.innerHTML = '<div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center; color: #888;">No endpoints configured yet</div>';
            }

            // Update connection status
            const statusDiv = document.getElementById('ai-connection-status');
            if (statusDiv) {
                if (activeEndpoint) {
                    statusDiv.innerHTML = `
                        <div style="color: #06ffa5; margin-bottom: 5px;">Connected to: ${activeEndpoint.name}</div>
                        <div style="font-size: 11px; color: #666;">${activeEndpoint.url}</div>
                    `;
                } else {
                    statusDiv.innerHTML = '<span style="color: #888;">No endpoint configured</span>';
                }
            }
        }

        function saveAISettings() {
            // Save API settings from General tab
            const apiKey = document.getElementById('ai-api-key').value;
            const apiEndpoint = document.getElementById('ai-api-endpoint').value;

            // If user entered new endpoint details, create/update a custom endpoint
            if (apiKey && apiEndpoint) {
                const customId = 'custom-' + Date.now();
                rappidSettings.endpoints = rappidSettings.endpoints || {};

                // Check if updating existing or adding new
                const activeEndpoint = getActiveEndpoint();
                if (activeEndpoint) {
                    activeEndpoint.key = apiKey;
                    activeEndpoint.url = apiEndpoint;
                } else {
                    rappidSettings.endpoints[customId] = {
                        id: customId,
                        name: 'Custom Endpoint',
                        url: apiEndpoint,
                        key: apiKey,
                        guid: 'custom-guid',
                        active: true
                    };
                }
                rappidSettings.rappid = true;
            }

            // Save Voice settings
            rappidSettings.azureTTSKey = document.getElementById('ai-tts-key').value;
            rappidSettings.azureRegion = document.getElementById('ai-tts-region').value;
            rappidSettings.ttsVoiceName = document.getElementById('ai-tts-voice').value;

            // Save companion settings
            rappidSettings.companionName = document.getElementById('ai-companion-name').value;
            rappidSettings.companionPersonality = document.getElementById('ai-companion-personality').value;
            rappidSettings.voiceEnabled = document.getElementById('ai-voice-enabled').checked;
            rappidSettings.autoSpeak = document.getElementById('ai-auto-speak').checked;
            rappidSettings.voiceInputEnabled = document.getElementById('ai-voice-input-enabled').checked;
            rappidSettings.continuousMode = document.getElementById('ai-continuous-mode').checked;
            rappidSettings.pttKey = document.getElementById('ai-ptt-key').value;

            // Save 3D view settings
            rappidSettings.primaryColor = document.getElementById('ai-primary-color').value;
            rappidSettings.glowColor = document.getElementById('ai-glow-color').value;
            rappidSettings.companionSize = document.getElementById('ai-companion-size').value;
            rappidSettings.showParticles = document.getElementById('ai-show-particles').checked;
            rappidSettings.enableGlow = document.getElementById('ai-enable-glow').checked;
            rappidSettings.followDistance = parseFloat(document.getElementById('ai-follow-distance').value);
            rappidSettings.floatHeight = parseFloat(document.getElementById('ai-float-height').value);

            saveRappidSettings();
            showAIStatusMessage('Settings saved successfully!', 'success');
            showNotification('AI Companion settings saved!');

            // Apply 3D settings immediately if companion exists
            applyCompanionSettings();
        }

        function applyCompanionSettings() {
            // Update COPILOT_CONFIG with new settings
            if (rappidSettings.followDistance) COPILOT_CONFIG.followDistance = rappidSettings.followDistance;
            if (rappidSettings.floatHeight) COPILOT_CONFIG.floatHeight = rappidSettings.floatHeight;
            if (rappidSettings.primaryColor) COPILOT_CONFIG.color = parseInt(rappidSettings.primaryColor.replace('#', '0x'));
            if (rappidSettings.glowColor) COPILOT_CONFIG.glowColor = parseInt(rappidSettings.glowColor.replace('#', '0x'));

            // Recreate mesh with new settings
            if (copilotMesh && mode === 'world') {
                createCopilotMesh();
            }
        }

        function showAIStatusMessage(message, type) {
            const statusEl = document.getElementById('ai-status-message');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = 'ai-status-msg ' + type;
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.className = 'ai-status-msg';
                }, 3000);
            }
        }

        // Alias for backwards compatibility
        function showRappidStatus(message, type) {
            showAIStatusMessage(message, type);
        }

        // Keep old updateRappidUI for backwards compatibility
        function updateRappidUI() {
            updateAISettingsUI();
        }

        // Color picker sync
        document.addEventListener('DOMContentLoaded', function() {
            // Primary color sync
            const primaryColor = document.getElementById('ai-primary-color');
            const primaryHex = document.getElementById('ai-primary-color-hex');
            if (primaryColor && primaryHex) {
                primaryColor.addEventListener('input', () => primaryHex.value = primaryColor.value);
                primaryHex.addEventListener('input', () => primaryColor.value = primaryHex.value);
            }

            // Glow color sync
            const glowColor = document.getElementById('ai-glow-color');
            const glowHex = document.getElementById('ai-glow-color-hex');
            if (glowColor && glowHex) {
                glowColor.addEventListener('input', () => glowHex.value = glowColor.value);
                glowHex.addEventListener('input', () => glowColor.value = glowHex.value);
            }
        });

        function setActiveEndpoint(endpointId) {
            Object.values(rappidSettings.endpoints).forEach(ep => {
                ep.active = ep.id === endpointId;
            });
            saveRappidSettings();
            updateRappidUI();
            showRappidStatus('Endpoint activated: ' + rappidSettings.endpoints[endpointId]?.name, 'success');
        }

        function getActiveEndpoint() {
            return Object.values(rappidSettings.endpoints).find(ep => ep.active);
        }

        function importRappidSettings(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Validate it's a RAPPID settings file
                    if (imported.rappid === true && imported.backupType === 'RAPPID Settings Backup') {
                        rappidSettings = {
                            rappid: true,
                            backupType: imported.backupType,
                            endpoints: imported.endpoints || {},
                            azureTTSKey: imported.azureTTSKey || '',
                            azureRegion: imported.azureRegion || '',
                            ttsVoiceName: imported.ttsVoiceName || 'en-US-JennyNeural',
                            exportDate: imported.exportDate,
                            version: imported.version || '1.0'
                        };
                        saveRappidSettings();
                        updateRappidUI();
                        showRappidStatus('RAPPID settings imported successfully!', 'success');
                        showNotification('RAPPID settings imported! Copilot is now AI-powered.');
                    } else {
                        showRappidStatus('Invalid RAPPID settings file', 'error');
                    }
                } catch (error) {
                    console.error('RAPPID import error:', error);
                    showRappidStatus('Failed to import: Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportRappidSettings() {
            if (!rappidSettings.rappid) {
                showRappidStatus('No RAPPID settings to export', 'error');
                return;
            }

            const exportData = {
                rappid: true,
                backupType: 'RAPPID Settings Backup',
                endpoints: rappidSettings.endpoints,
                azureTTSKey: rappidSettings.azureTTSKey,
                azureRegion: rappidSettings.azureRegion,
                ttsVoiceName: rappidSettings.ttsVoiceName,
                exportDate: new Date().toISOString(),
                version: rappidSettings.version
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `leviathan-rappid-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showRappidStatus('RAPPID settings exported!', 'success');
        }

        async function testRappidConnection() {
            const endpoint = getActiveEndpoint();
            if (!endpoint) {
                showRappidStatus('No active endpoint selected', 'error');
                return;
            }

            showRappidStatus('Testing connection...', '');

            try {
                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        message: 'Hello, this is a connection test from LEVIATHAN game.',
                        guid: endpoint.guid
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    showRappidStatus('Connection successful! Endpoint is responding.', 'success');
                    showNotification('RAPPID connection test passed!');
                } else {
                    showRappidStatus(`Connection failed: HTTP ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('RAPPID connection test error:', error);
                showRappidStatus('Connection failed: Network error', 'error');
            }
        }

        function clearRappidSettings() {
            if (confirm('Are you sure you want to clear all RAPPID settings?')) {
                rappidSettings = {
                    rappid: false,
                    endpoints: {},
                    azureTTSKey: '',
                    azureRegion: '',
                    ttsVoiceName: 'en-US-JennyNeural',
                    version: '1.0'
                };
                localStorage.removeItem(RAPPID_STORAGE_KEY);
                updateRappidUI();
                showRappidStatus('RAPPID settings cleared', 'success');
            }
        }

        function showRappidStatus(message, type) {
            const statusEl = document.getElementById('rappid-status-message');
            statusEl.textContent = message;
            statusEl.className = 'rappid-status ' + type;
        }

        // v5.9: Enhanced generateCopilotResponse with RAPPID API integration
        // Uses correct API format: user_input, conversation_history, user_guid
        // Returns object with { text, voice } - text for display, voice for TTS
        async function generateCopilotResponseWithRappid(message) {
            const endpoint = getActiveEndpoint();

            // If no active RAPPID endpoint, fall back to local responses
            if (!endpoint || !endpoint.url || !endpoint.key) {
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }

            try {
                // Build context from game state
                const gameContext = {
                    playerHP: gameData.player?.hp || 100,
                    playerMaxHP: gameData.player?.maxHp || 100,
                    combatLevel: gameData.skills?.combat?.level || 1,
                    currentBiome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planetName: worldState?.currentCiv?.name || 'Unknown',
                    activePet: gameData.pets?.active || null,
                    inventoryItems: Object.keys(gameData.inventory || {}).length
                };

                // Build conversation history with system context
                const systemMessage = {
                    role: 'system',
                    content: `You are a helpful AI companion in the game LEVIATHAN: OMNIVERSE. The player is exploring alien worlds. Current status: HP ${gameContext.playerHP}/${gameContext.playerMaxHP}, Combat Level ${gameContext.combatLevel}, currently on planet "${gameContext.planetName}" (${gameContext.currentBiome} biome). ${gameContext.activePet ? `They have a ${gameContext.activePet} pet companion.` : 'They have no pet.'} Keep responses brief and helpful (1-3 sentences).`
                };

                // Build conversation history for API
                const conversationForApi = [systemMessage, ...copilotConversationHistory];

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        user_input: message,
                        conversation_history: conversationForApi,
                        user_guid: endpoint.guid || 'leviathan-game-user'
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // v5.9: Extract both assistant_response (for display) and voice_response (for TTS)
                    const textResponse = data.assistant_response || data.response || data.message || data.reply || generateCopilotResponse(message);
                    // Use voice_response for TTS if available, otherwise fall back to text response
                    const voiceResponse = data.voice_response || textResponse;
                    return { text: textResponse, voice: voiceResponse };
                } else {
                    console.warn('RAPPID API error (status ' + response.status + '), falling back to local response');
                    const localResponse = generateCopilotResponse(message);
                    return { text: localResponse, voice: localResponse };
                }
            } catch (error) {
                console.error('RAPPID request failed:', error);
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }
        }

        // Azure TTS integration using Microsoft Speech SDK
        let speechSdkLoaded = false;
        let speechSynthesizer = null;

        function loadSpeechSdk() {
            return new Promise((resolve, reject) => {
                if (speechSdkLoaded && window.SpeechSDK) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://aka.ms/csspeech/jsbrowserpackageraw';
                script.onload = () => {
                    speechSdkLoaded = true;
                    console.log('Microsoft Speech SDK loaded');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Failed to load Speech SDK');
                    reject(new Error('Speech SDK failed to load'));
                };
                document.head.appendChild(script);
            });
        }

        async function speakWithAzureTTS(text) {
            if (!rappidSettings.azureTTSKey || !rappidSettings.azureRegion) {
                // Fall back to browser TTS
                speakCopilotResponse(text);
                return;
            }

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser TTS');
                    speakCopilotResponse(text);
                    return;
                }

                // Cancel any existing speech
                if (speechSynthesizer) {
                    speechSynthesizer.close();
                    speechSynthesizer = null;
                }

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechSynthesisVoiceName = rappidSettings.ttsVoiceName || 'en-US-JennyNeural';

                // Use default speaker output
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();

                // Create synthesizer
                speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(speechConfig, audioConfig);

                // Truncate text if too long (SDK has limits)
                const maxLength = 5000;
                const truncatedText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;

                // Show voice indicator
                const voiceIndicator = document.getElementById('copilot-voice-indicator');
                if (voiceIndicator) voiceIndicator.classList.add('active');

                // Speak the text
                speechSynthesizer.speakTextAsync(
                    truncatedText,
                    (result) => {
                        // Hide voice indicator on completion
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                            console.log('Azure TTS completed successfully');
                        } else {
                            console.warn('Azure TTS synthesis ended with reason:', result.reason);
                        }

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }
                    },
                    (error) => {
                        console.error('Azure TTS error:', error);
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }

                        // Fall back to browser TTS
                        speakCopilotResponse(text);
                    }
                );
            } catch (error) {
                console.error('Azure TTS error:', error);
                speakCopilotResponse(text);
            }
        }

        // Function to stop Azure TTS
        function stopAzureTTS() {
            if (speechSynthesizer) {
                speechSynthesizer.close();
                speechSynthesizer = null;
            }
            const voiceIndicator = document.getElementById('copilot-voice-indicator');
            if (voiceIndicator) voiceIndicator.classList.remove('active');
        }

        // Override sendCopilotMessage to use RAPPID when available
        const originalSendCopilotMessage = typeof sendCopilotMessage === 'function' ? sendCopilotMessage : null;

        // ============================================
        // v5.4: COMPANION EVOLUTION SYSTEM
        // ============================================
        const PET_EVOLUTIONS = {
            slime: {
                stages: [
                    { name: 'Slime Hatchling', icon: 'ðŸŸ¢', bondRequired: 0, abilities: ['regen'], statMult: 1.0 },
                    { name: 'Gel Guardian', icon: 'ðŸ§ª', bondRequired: 50, abilities: ['regen', 'shield'], statMult: 1.5 },
                    { name: 'Slime Sovereign', icon: 'ðŸ‘‘', bondRequired: 150, abilities: ['regen', 'shield', 'absorb'], statMult: 2.5 }
                ]
            },
            wisp: {
                stages: [
                    { name: 'Tiny Wisp', icon: 'âœ¨', bondRequired: 0, abilities: ['luck'], statMult: 1.0 },
                    { name: 'Bright Spirit', icon: 'ðŸ’«', bondRequired: 60, abilities: ['luck', 'illuminate'], statMult: 1.6 },
                    { name: 'Radiant Beacon', icon: 'ðŸŒŸ', bondRequired: 180, abilities: ['luck', 'illuminate', 'fortune'], statMult: 2.8 }
                ]
            },
            bat: {
                stages: [
                    { name: 'Cave Bat', icon: 'ðŸ¦‡', bondRequired: 0, abilities: ['dodge'], statMult: 1.0 },
                    { name: 'Shadow Wing', icon: 'ðŸ–¤', bondRequired: 55, abilities: ['dodge', 'swoop'], statMult: 1.4 },
                    { name: 'Vampire Lord', icon: 'ðŸ§›', bondRequired: 165, abilities: ['dodge', 'swoop', 'lifesteal'], statMult: 2.4 }
                ]
            },
            phoenix: {
                stages: [
                    { name: 'Mini Phoenix', icon: 'ðŸ”¥', bondRequired: 0, abilities: ['damage'], statMult: 1.0 },
                    { name: 'Flame Herald', icon: 'ðŸŒ‹', bondRequired: 70, abilities: ['damage', 'burn'], statMult: 1.7 },
                    { name: 'Inferno Avatar', icon: 'â˜€ï¸', bondRequired: 200, abilities: ['damage', 'burn', 'rebirth'], statMult: 3.0 }
                ]
            },
            dragon: {
                stages: [
                    { name: 'Baby Dragon', icon: 'ðŸ²', bondRequired: 0, abilities: ['attack'], statMult: 1.0 },
                    { name: 'Drake Champion', icon: 'ðŸ‰', bondRequired: 80, abilities: ['attack', 'firebreath'], statMult: 1.8 },
                    { name: 'Elder Wyrm', icon: 'ðŸ”±', bondRequired: 250, abilities: ['attack', 'firebreath', 'devastation'], statMult: 3.5 }
                ]
            },
            void: {
                stages: [
                    { name: 'Void Entity', icon: 'ðŸŒ€', bondRequired: 0, abilities: ['absorb'], statMult: 1.0 },
                    { name: 'Void Walker', icon: 'ðŸ•³ï¸', bondRequired: 100, abilities: ['absorb', 'phase'], statMult: 2.0 },
                    { name: 'Void Sovereign', icon: 'âš«', bondRequired: 300, abilities: ['absorb', 'phase', 'annihilate'], statMult: 4.0 }
                ]
            },
            celestial: {
                stages: [
                    { name: 'Celestial Star', icon: 'â­', bondRequired: 0, abilities: ['allStats'], statMult: 1.0 },
                    { name: 'Constellation Spirit', icon: 'ðŸŒŒ', bondRequired: 120, abilities: ['allStats', 'blessing'], statMult: 2.2 },
                    { name: 'Cosmic Deity', icon: 'ðŸ’Ž', bondRequired: 400, abilities: ['allStats', 'blessing', 'transcendence'], statMult: 5.0 }
                ]
            }
        };

        const EVOLUTION_ABILITIES = {
            regen: { name: 'Regeneration', desc: '+1 HP/5s', icon: 'ðŸ’š' },
            shield: { name: 'Shield Aura', desc: '+5% damage reduction', icon: 'ðŸ›¡ï¸' },
            absorb: { name: 'Soul Absorb', desc: '+25% XP gain', icon: 'ðŸ‘»' },
            luck: { name: 'Lucky Charm', desc: '+10% loot bonus', icon: 'ðŸ€' },
            illuminate: { name: 'Illuminate', desc: 'Reveals hidden items', icon: 'ðŸ’¡' },
            fortune: { name: 'Fortune', desc: '+20% rare item chance', icon: 'ðŸ’°' },
            dodge: { name: 'Evasion', desc: '+5% dodge chance', icon: 'ðŸ’¨' },
            swoop: { name: 'Swoop Attack', desc: 'Pet deals bonus damage', icon: 'ðŸŽ¯' },
            lifesteal: { name: 'Lifesteal', desc: '+8% life on hit', icon: 'ðŸ©¸' },
            damage: { name: 'Power Boost', desc: '+15% damage', icon: 'âš”ï¸' },
            burn: { name: 'Burning Aura', desc: 'Enemies take fire damage', icon: 'ðŸ”¥' },
            rebirth: { name: 'Rebirth', desc: 'Revive once per fight', icon: 'ðŸŒ…' },
            attack: { name: 'Pet Attack', desc: 'Pet attacks enemies', icon: 'ðŸ‘Š' },
            firebreath: { name: 'Fire Breath', desc: 'AoE fire damage', icon: 'ðŸ²' },
            devastation: { name: 'Devastation', desc: '+50% boss damage', icon: 'ðŸ’€' },
            phase: { name: 'Phase Shift', desc: 'Ignore 10% damage', icon: 'ðŸŒ€' },
            annihilate: { name: 'Annihilate', desc: 'Execute low HP enemies', icon: 'âš«' },
            allStats: { name: 'All Stats', desc: '+10% all stats', icon: 'âœ¨' },
            blessing: { name: 'Blessing', desc: '+15% all bonuses', icon: 'ðŸ™' },
            transcendence: { name: 'Transcendence', desc: 'Ultimate power', icon: 'ðŸŒˆ' }
        };

        function initPetEvolutionSystem() {
            if (!gameData.petEvolution) {
                gameData.petEvolution = {};
            }
            // Initialize bond for each owned pet
            if (gameData.pets?.owned) {
                for (const petId of gameData.pets.owned) {
                    if (!gameData.petEvolution[petId]) {
                        gameData.petEvolution[petId] = {
                            bond: 0,
                            stage: 0
                        };
                    }
                }
            }
        }

        function getPetEvolutionStage(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.stage || 0;
        }

        function getPetBond(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.bond || 0;
        }

        function addPetBond(petId, amount) {
            initPetEvolutionSystem();
            if (!gameData.petEvolution[petId]) {
                gameData.petEvolution[petId] = { bond: 0, stage: 0 };
            }
            gameData.petEvolution[petId].bond += amount;
            saveGameData();
        }

        function canEvolvePet(petId) {
            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return false;

            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];
            if (!nextStage) return false;

            const currentBond = getPetBond(petId);
            return currentBond >= nextStage.bondRequired;
        }

        function evolvePet(petId) {
            if (!canEvolvePet(petId)) return false;

            const evolution = PET_EVOLUTIONS[petId];
            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];

            gameData.petEvolution[petId].stage = currentStage + 1;
            saveGameData();

            // Show evolution popup
            showNotification(`${nextStage.icon} ${nextStage.name} EVOLVED!`, 'success');
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 60, 0xaa44ff, { spread: 8, lifetime: 2000 });
            }

            updateEvolutionDisplay();
            return true;
        }

        function getCurrentPetData(petId) {
            const basePet = PET_TYPES[petId];
            if (!basePet) return null;

            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return basePet;

            const stage = getPetEvolutionStage(petId);
            const stageData = evolution.stages[stage];

            return {
                ...basePet,
                name: stageData.name,
                icon: stageData.icon,
                abilities: stageData.abilities,
                statMult: stageData.statMult
            };
        }

        function getEvolutionBonuses() {
            const bonuses = {
                damageReduction: 0,
                xpBonus: 0,
                lootBonus: 0,
                rareChance: 0,
                dodgeBonus: 0,
                lifesteal: 0,
                damageBonus: 0,
                burnDamage: false,
                canRevive: false,
                bossDamage: 0,
                phaseShift: 0,
                executeThreshold: 0,
                allStatsBonus: 0,
                blessingMult: 1.0
            };

            if (!gameData.pets?.active) return bonuses;

            const petData = getCurrentPetData(gameData.pets.active);
            if (!petData?.abilities) return bonuses;

            for (const ability of petData.abilities) {
                switch (ability) {
                    case 'shield': bonuses.damageReduction += 0.05; break;
                    case 'absorb': bonuses.xpBonus += 0.25; break;
                    case 'luck': bonuses.lootBonus += 0.1; break;
                    case 'fortune': bonuses.rareChance += 0.2; break;
                    case 'dodge': bonuses.dodgeBonus += 0.05; break;
                    case 'lifesteal': bonuses.lifesteal += 0.08; break;
                    case 'damage': bonuses.damageBonus += 0.15; break;
                    case 'burn': bonuses.burnDamage = true; break;
                    case 'rebirth': bonuses.canRevive = true; break;
                    case 'devastation': bonuses.bossDamage += 0.5; break;
                    case 'phase': bonuses.phaseShift += 0.1; break;
                    case 'annihilate': bonuses.executeThreshold = 0.15; break;
                    case 'allStats': bonuses.allStatsBonus += 0.1; break;
                    case 'blessing': bonuses.blessingMult = 1.15; break;
                    case 'transcendence':
                        bonuses.allStatsBonus += 0.2;
                        bonuses.blessingMult = 1.3;
                        break;
                }
            }

            // Apply blessing multiplier
            bonuses.damageBonus *= bonuses.blessingMult;
            bonuses.xpBonus *= bonuses.blessingMult;
            bonuses.lootBonus *= bonuses.blessingMult;

            return bonuses;
        }

        function openEvolutionModal() {
            initPetEvolutionSystem();
            updateEvolutionDisplay();
            document.getElementById('evolution-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeEvolutionModal() {
            document.getElementById('evolution-modal').style.display = 'none';
        }

        function updateEvolutionDisplay() {
            const container = document.getElementById('evolution-list');
            if (!container) return;

            initPetEvolutionSystem();
            const ownedPets = gameData.pets?.owned || [];

            if (ownedPets.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No companions yet. Defeat enemies to find pets!</div>';
                return;
            }

            let html = '';
            for (const petId of ownedPets) {
                const evolution = PET_EVOLUTIONS[petId];
                if (!evolution) continue;

                const currentStage = getPetEvolutionStage(petId);
                const stageData = evolution.stages[currentStage];
                const nextStage = evolution.stages[currentStage + 1];
                const bond = getPetBond(petId);
                const canEvolve = canEvolvePet(petId);
                const isActive = gameData.pets?.active === petId;

                const bondForNext = nextStage ? nextStage.bondRequired : bond;
                const bondProgress = nextStage ? Math.min(100, (bond / bondForNext) * 100) : 100;

                html += `
                    <div class="evolution-card ${canEvolve ? 'can-evolve' : ''}" style="${isActive ? 'border-color: #ff8800;' : ''}">
                        <div class="evolution-header">
                            <div class="evolution-icon">${stageData.icon}</div>
                            <div class="evolution-info">
                                <div class="evolution-name">${stageData.name}</div>
                                <div class="evolution-stage">Stage ${currentStage + 1}/${evolution.stages.length} ${isActive ? '(ACTIVE)' : ''}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffd700; font-size: 14px;">${bond} Bond</div>
                                <div style="color: #888; font-size: 11px;">x${stageData.statMult.toFixed(1)} Stats</div>
                            </div>
                        </div>
                        <div class="evolution-bond">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 4px;">
                                <span>Bond Progress</span>
                                <span>${bond}/${bondForNext}</span>
                            </div>
                            <div class="bond-bar">
                                <div class="bond-fill" style="width: ${bondProgress}%;"></div>
                            </div>
                        </div>
                        <div class="evolution-abilities">
                            ${stageData.abilities.map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability" title="${abilityData?.desc || ''}">${abilityData?.icon || ''} ${abilityData?.name || ab}</div>`;
                            }).join('')}
                            ${nextStage ? nextStage.abilities.filter(ab => !stageData.abilities.includes(ab)).map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability locked" title="Unlock at next evolution">${abilityData?.icon || ''} ???</div>`;
                            }).join('') : ''}
                        </div>
                        ${nextStage ? `
                            <button class="evolve-btn" onclick="evolvePet('${petId}')" ${canEvolve ? '' : 'disabled'}>
                                ${canEvolve ? `EVOLVE to ${nextStage.name}` : `Need ${bondForNext - bond} more bond`}
                            </button>
                        ` : '<div style="text-align: center; color: #ffd700; margin-top: 10px; font-size: 12px;">MAX EVOLUTION</div>'}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Gain bond from various activities
        function gainPetBond(amount) {
            if (!gameData.pets?.active) return;
            addPetBond(gameData.pets.active, amount);
        }

        // ============================================
        // v5.4: WORLD EVENTS SYSTEM
        // ============================================
        const WORLD_EVENTS = {
            meteorShower: {
                name: 'Meteor Shower',
                icon: 'â˜„ï¸',
                desc: 'Meteors rain from the sky! Collect rare ores.',
                duration: 120000, // 2 minutes
                minLevel: 3,
                spawnItems: ['Meteor Ore', 'Star Fragment', 'Cosmic Dust'],
                rewards: { xp: 500, lootBonus: 0.5 },
                color: 0xff4400
            },
            treasureHunt: {
                name: 'Treasure Hunt',
                icon: 'ðŸ—ºï¸',
                desc: 'Hidden treasure chests have appeared!',
                duration: 180000, // 3 minutes
                minLevel: 2,
                spawnItems: ['Gold Chest', 'Silver Chest', 'Ancient Relic'],
                rewards: { xp: 400, goldBonus: 2.0 },
                color: 0xffd700
            },
            invasionWave: {
                name: 'Monster Invasion',
                icon: 'ðŸ‘¹',
                desc: 'Powerful monsters are invading! Defend the area!',
                duration: 150000, // 2.5 minutes
                minLevel: 5,
                spawnMobs: true,
                mobMultiplier: 2.0,
                rewards: { xp: 800, combatXp: 300 },
                color: 0xff0044
            },
            harvestMoon: {
                name: 'Harvest Moon',
                icon: 'ðŸŒ•',
                desc: 'Resources yield double during the Harvest Moon!',
                duration: 240000, // 4 minutes
                minLevel: 1,
                resourceMultiplier: 2.0,
                rewards: { xp: 300 },
                color: 0xffcc00
            },
            ancientRuins: {
                name: 'Ancient Ruins Emerge',
                icon: 'ðŸ›ï¸',
                desc: 'Ancient ruins have surfaced! Explore for rare artifacts.',
                duration: 200000, // 3.33 minutes
                minLevel: 7,
                spawnItems: ['Ancient Artifact', 'Rune Stone', 'Lost Technology'],
                rewards: { xp: 1000, rareChance: 0.3 },
                color: 0x8844aa
            },
            crystalBloom: {
                name: 'Crystal Bloom',
                icon: 'ðŸ’Ž',
                desc: 'Rare crystals are blooming across the land!',
                duration: 160000, // 2.66 minutes
                minLevel: 4,
                spawnItems: ['Rainbow Crystal', 'Pure Crystal', 'Crystal Shard'],
                rewards: { xp: 600, craftBonus: 0.5 },
                color: 0x44ffff
            },
            bossRush: {
                name: 'Boss Rush',
                icon: 'ðŸ’€',
                desc: 'Multiple bosses have spawned! Great rewards await!',
                duration: 300000, // 5 minutes
                minLevel: 10,
                spawnBosses: true,
                rewards: { xp: 2000, rareLoot: true },
                color: 0xff00ff
            },
            peacefulDay: {
                name: 'Peaceful Day',
                icon: 'ðŸŒ¸',
                desc: 'A peaceful day with bonus XP and healing!',
                duration: 180000, // 3 minutes
                minLevel: 1,
                xpMultiplier: 1.5,
                healingBonus: 2.0,
                rewards: { xp: 200 },
                color: 0xff88aa
            }
        };

        let activeWorldEvent = null;
        let worldEventEndTime = 0;
        let worldEventProgress = { collected: 0, killed: 0, explored: 0 };
        let lastWorldEventCheck = 0;
        let worldEventSpawns = [];

        function initWorldEventSystem() {
            if (!gameData.worldEvents) {
                gameData.worldEvents = {
                    completed: {},
                    totalEventsCompleted: 0,
                    lastEventTime: 0
                };
            }
        }

        function canSpawnWorldEvent() {
            if (activeWorldEvent) return false;
            if (mode !== 'world') return false;

            const timeSinceLastEvent = performance.now() - (gameData.worldEvents?.lastEventTime || 0);
            return timeSinceLastEvent > 180000; // 3 minute cooldown between events
        }

        function trySpawnWorldEvent() {
            if (!canSpawnWorldEvent()) return false;

            // 2% chance per check (checked every ~5 seconds in game loop)
            if (Math.random() > 0.02) return false;

            const playerLevel = Math.max(...Object.values(gameData.skills).map(s => s.level));
            const eligibleEvents = Object.entries(WORLD_EVENTS).filter(([id, event]) => {
                return playerLevel >= event.minLevel;
            });

            if (eligibleEvents.length === 0) return false;

            const [eventId, eventData] = eligibleEvents[Math.floor(Math.random() * eligibleEvents.length)];
            startWorldEvent(eventId);
            return true;
        }

        function startWorldEvent(eventId) {
            const eventData = WORLD_EVENTS[eventId];
            if (!eventData) return;

            activeWorldEvent = { id: eventId, ...eventData };
            worldEventEndTime = performance.now() + eventData.duration;
            worldEventProgress = { collected: 0, killed: 0, explored: 0 };
            worldEventSpawns = [];

            // Show event notification
            showWorldEventNotification(eventData);

            // Spawn event-specific content
            if (eventData.spawnItems) {
                spawnEventItems(eventData);
            }
            if (eventData.spawnMobs) {
                spawnEventMobs(eventData);
            }
            if (eventData.spawnBosses) {
                spawnEventBosses();
            }

            // Update UI
            updateEventIndicator();

            gameData.worldEvents.lastEventTime = performance.now();
            saveGameData();
        }

        function showWorldEventNotification(eventData) {
            const notification = document.createElement('div');
            notification.className = 'event-notification';
            notification.innerHTML = `
                <div class="event-title">${eventData.icon} ${eventData.name}!</div>
                <div class="event-desc">${eventData.desc}</div>
                <div class="event-timer">Duration: ${Math.floor(eventData.duration / 1000)}s</div>
            `;
            document.body.appendChild(notification);

            AudioSystem.levelUp();
            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 40, eventData.color, { spread: 10, lifetime: 2000 });
            }

            setTimeout(() => notification.remove(), 5000);
        }

        function spawnEventItems(eventData) {
            if (!worldState.player) return;

            const itemCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < itemCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 40;
                const x = worldState.player.position.x + Math.cos(angle) * dist;
                const z = worldState.player.position.z + Math.sin(angle) * dist;

                const itemType = eventData.spawnItems[Math.floor(Math.random() * eventData.spawnItems.length)];

                // Create visual marker
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: eventData.color,
                    emissive: eventData.color,
                    emissiveIntensity: 0.5
                });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(x, 1, z);
                marker.userData = { type: 'eventItem', itemType, eventId: activeWorldEvent.id, hp: 1, maxHp: 1 };
                scene.add(marker);
                worldEventSpawns.push(marker);
                // Add to interactables so player can target them
                worldState.interactables.push(marker);
            }
        }

        function spawnEventMobs(eventData) {
            // Spawn extra mobs during invasion
            const extraMobs = Math.floor(10 * (eventData.mobMultiplier || 1));
            for (let i = 0; i < extraMobs; i++) {
                if (typeof spawnMob === 'function') {
                    spawnMob(true); // Force spawn stronger mobs
                }
            }
        }

        function spawnEventBosses() {
            // Spawn multiple bosses during boss rush
            for (let i = 0; i < 3; i++) {
                if (typeof spawnBoss === 'function') {
                    setTimeout(() => spawnBoss(), i * 30000);
                }
            }
        }

        function updateWorldEvent(dt, time) {
            if (!activeWorldEvent) {
                // Check for new event every 5 seconds
                if (time - lastWorldEventCheck > 5000) {
                    lastWorldEventCheck = time;
                    trySpawnWorldEvent();
                }
                return;
            }

            // Check if event ended
            if (performance.now() >= worldEventEndTime) {
                endWorldEvent();
                return;
            }

            // Update event indicator
            updateEventIndicator();

            // Apply event bonuses
            applyEventBonuses();

            // Animate event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.position) {
                    spawn.position.y = 1 + Math.sin(time * 0.003) * 0.3;
                    spawn.rotation.y += dt * 2;
                }
            });
        }

        function applyEventBonuses() {
            // Bonuses are applied in relevant game functions
            // This function tracks active bonuses
        }

        function getWorldEventBonuses() {
            if (!activeWorldEvent) return {};

            return {
                resourceMultiplier: activeWorldEvent.resourceMultiplier || 1,
                xpMultiplier: activeWorldEvent.xpMultiplier || 1,
                lootBonus: activeWorldEvent.rewards?.lootBonus || 0,
                healingBonus: activeWorldEvent.healingBonus || 1
            };
        }

        function collectEventItem(marker) {
            if (!marker.userData.itemType) return;

            const itemType = marker.userData.itemType;
            worldEventProgress.collected++;

            // Add item to inventory
            addItem(itemType);
            showNotification(`Collected: ${itemType}`, 'success');
            AudioSystem.collect();

            if (particles) {
                particles.emit(marker.position, 15, activeWorldEvent?.color || 0xffd700);
            }

            // Remove marker
            scene.remove(marker);
            worldEventSpawns = worldEventSpawns.filter(s => s !== marker);
            worldState.interactables = worldState.interactables.filter(i => i !== marker);

            // Gain pet bond
            gainPetBond(2);
        }

        function endWorldEvent() {
            if (!activeWorldEvent) return;

            initWorldEventSystem();

            // Apply completion rewards
            const rewards = activeWorldEvent.rewards;
            if (rewards.xp) {
                addXp('combat', rewards.xp);
            }
            if (rewards.combatXp) {
                addXp('combat', rewards.combatXp);
            }

            // Track completion
            if (!gameData.worldEvents.completed[activeWorldEvent.id]) {
                gameData.worldEvents.completed[activeWorldEvent.id] = 0;
            }
            gameData.worldEvents.completed[activeWorldEvent.id]++;
            gameData.worldEvents.totalEventsCompleted++;

            showNotification(`${activeWorldEvent.icon} Event Complete! +${rewards.xp || 0} XP`, 'success');

            // Clean up event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.parent) scene.remove(spawn);
                // Remove from interactables
                worldState.interactables = worldState.interactables.filter(i => i !== spawn);
            });
            worldEventSpawns = [];

            // Gain pet bond for completion
            gainPetBond(10);

            activeWorldEvent = null;
            updateEventIndicator();
            saveGameData();
        }

        function updateEventIndicator() {
            const indicator = document.getElementById('event-indicator');
            if (!indicator) return;

            if (!activeWorldEvent) {
                indicator.classList.remove('active');
                return;
            }

            indicator.classList.add('active');

            const timeLeft = Math.max(0, worldEventEndTime - performance.now());
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            const progress = (timeLeft / activeWorldEvent.duration) * 100;

            document.getElementById('event-ind-icon').textContent = activeWorldEvent.icon;
            document.getElementById('event-ind-name').textContent = activeWorldEvent.name;
            document.getElementById('event-ind-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('event-ind-fill').style.width = `${progress}%`;
        }

        // ============================================
        // v5.4: ACHIEVEMENT SHOWCASE SYSTEM
        // ============================================
        const ACHIEVEMENT_POINTS = {
            // Basic achievements
            'first_landing': { points: 10, tier: 'common' },
            'explorer_10': { points: 25, tier: 'common' },
            'explorer_30': { points: 50, tier: 'rare' },
            'lumberjack_25': { points: 15, tier: 'common' },
            'lumberjack_100': { points: 40, tier: 'rare' },
            'miner_25': { points: 15, tier: 'common' },
            'miner_100': { points: 40, tier: 'rare' },
            'angler_10': { points: 15, tier: 'common' },
            'angler_50': { points: 35, tier: 'rare' },
            'slayer_10': { points: 20, tier: 'common' },
            'slayer_50': { points: 50, tier: 'rare' },
            'crafter_10': { points: 15, tier: 'common' },
            'crafter_50': { points: 45, tier: 'rare' },
            'max_skill': { points: 75, tier: 'legendary' },
            'playtime_1h': { points: 30, tier: 'common' },
            'survivor': { points: 35, tier: 'rare' },
            'daily_3': { points: 25, tier: 'common' },
            'daily_7': { points: 60, tier: 'rare' }
        };

        const AP_MILESTONES = [
            { points: 50, name: 'Novice Achiever', reward: { type: 'cosmetic', id: 'sparkle' } },
            { points: 100, name: 'Rising Star', reward: { type: 'xpBonus', value: 0.05 } },
            { points: 200, name: 'Accomplished', reward: { type: 'cosmetic', id: 'aura_blue' } },
            { points: 350, name: 'Elite Achiever', reward: { type: 'lootBonus', value: 0.1 } },
            { points: 500, name: 'Master Achiever', reward: { type: 'cosmetic', id: 'aura_gold' } },
            { points: 750, name: 'Legendary Status', reward: { type: 'allBonus', value: 0.1 } },
            { points: 1000, name: 'Achievement God', reward: { type: 'cosmetic', id: 'aura_rainbow' } }
        ];

        const COSMETIC_EFFECTS = {
            sparkle: { name: 'Sparkle Trail', desc: 'Leave sparkles as you move', icon: 'âœ¨' },
            aura_blue: { name: 'Blue Aura', desc: 'Mystical blue glow around player', icon: 'ðŸ’™' },
            aura_gold: { name: 'Golden Aura', desc: 'Prestigious golden glow', icon: 'ðŸ’›' },
            aura_rainbow: { name: 'Rainbow Aura', desc: 'Ultimate rainbow effect', icon: 'ðŸŒˆ' }
        };

        function initAchievementShowcase() {
            if (!gameData.achievementShowcase) {
                gameData.achievementShowcase = {
                    activeCosmetic: null,
                    unlockedCosmetics: [],
                    bonuses: {
                        xpBonus: 0,
                        lootBonus: 0,
                        allBonus: 0
                    }
                };
            }
        }

        function calculateTotalAP() {
            let total = 0;
            for (const [achId, achPoints] of Object.entries(ACHIEVEMENT_POINTS)) {
                if (gameData.achievements[achId]) {
                    total += achPoints.points;
                }
            }
            return total;
        }

        function getCurrentMilestone() {
            const totalAP = calculateTotalAP();
            let current = null;
            let next = AP_MILESTONES[0];

            for (let i = 0; i < AP_MILESTONES.length; i++) {
                if (totalAP >= AP_MILESTONES[i].points) {
                    current = AP_MILESTONES[i];
                    next = AP_MILESTONES[i + 1] || null;
                } else {
                    break;
                }
            }

            return { current, next };
        }

        function checkMilestoneRewards() {
            initAchievementShowcase();
            const totalAP = calculateTotalAP();

            for (const milestone of AP_MILESTONES) {
                if (totalAP >= milestone.points) {
                    const reward = milestone.reward;

                    if (reward.type === 'cosmetic') {
                        if (!gameData.achievementShowcase.unlockedCosmetics.includes(reward.id)) {
                            gameData.achievementShowcase.unlockedCosmetics.push(reward.id);
                            showNotification(`Cosmetic Unlocked: ${COSMETIC_EFFECTS[reward.id]?.name}!`, 'success');
                        }
                    } else if (reward.type === 'xpBonus') {
                        gameData.achievementShowcase.bonuses.xpBonus = Math.max(
                            gameData.achievementShowcase.bonuses.xpBonus,
                            reward.value
                        );
                    } else if (reward.type === 'lootBonus') {
                        gameData.achievementShowcase.bonuses.lootBonus = Math.max(
                            gameData.achievementShowcase.bonuses.lootBonus,
                            reward.value
                        );
                    } else if (reward.type === 'allBonus') {
                        gameData.achievementShowcase.bonuses.allBonus = Math.max(
                            gameData.achievementShowcase.bonuses.allBonus,
                            reward.value
                        );
                    }
                }
            }

            saveGameData();
        }

        function getShowcaseBonuses() {
            initAchievementShowcase();
            return {
                xpBonus: gameData.achievementShowcase.bonuses?.xpBonus || 0,
                lootBonus: gameData.achievementShowcase.bonuses?.lootBonus || 0,
                allBonus: gameData.achievementShowcase.bonuses?.allBonus || 0
            };
        }

        function setActiveCosmetic(cosmeticId) {
            initAchievementShowcase();
            if (cosmeticId && !gameData.achievementShowcase.unlockedCosmetics.includes(cosmeticId)) {
                return false;
            }

            gameData.achievementShowcase.activeCosmetic = cosmeticId;
            saveGameData();
            updateShowcaseDisplay();

            if (cosmeticId) {
                const cosmetic = COSMETIC_EFFECTS[cosmeticId];
                showNotification(`Cosmetic equipped: ${cosmetic?.name}`, 'info');
            } else {
                showNotification('Cosmetic removed', 'info');
            }

            return true;
        }

        function openShowcaseModal() {
            initAchievementShowcase();
            checkMilestoneRewards();
            updateShowcaseDisplay();
            document.getElementById('showcase-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeShowcaseModal() {
            document.getElementById('showcase-modal').style.display = 'none';
        }

        function updateShowcaseDisplay() {
            const totalAP = calculateTotalAP();
            const milestones = getCurrentMilestone();

            document.getElementById('total-ap').textContent = totalAP;

            if (milestones.next) {
                document.getElementById('next-milestone-name').textContent =
                    `${milestones.next.name} (${milestones.next.points} AP)`;
                const progress = ((totalAP - (milestones.current?.points || 0)) /
                    (milestones.next.points - (milestones.current?.points || 0))) * 100;
                document.getElementById('milestone-progress').style.width = `${Math.min(100, progress)}%`;
            } else {
                document.getElementById('next-milestone-name').textContent = 'All milestones complete!';
                document.getElementById('milestone-progress').style.width = '100%';
            }

            // Active cosmetic
            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            document.getElementById('active-cosmetic').textContent =
                activeCosmetic ? COSMETIC_EFFECTS[activeCosmetic]?.name : 'None';

            // Render badges
            const container = document.getElementById('showcase-badges');
            let html = '';

            // Cosmetics section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #aa44ff; margin: 10px 0;">Cosmetics</div>';
            for (const [cosId, cosmetic] of Object.entries(COSMETIC_EFFECTS)) {
                const unlocked = gameData.achievementShowcase?.unlockedCosmetics?.includes(cosId);
                const isActive = activeCosmetic === cosId;
                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${isActive ? 'legendary' : ''}"
                         onclick="${unlocked ? `setActiveCosmetic('${isActive ? '' : cosId}')` : ''}"
                         title="${unlocked ? cosmetic.desc : 'Locked - earn more AP!'}">
                        <div class="showcase-badge-icon">${cosmetic.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? cosmetic.name : '???'}</div>
                    </div>
                `;
            }

            // Achievements section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #ffd700; margin: 10px 0;">Achievements</div>';
            for (const [achId, achData] of Object.entries(ACHIEVEMENT_POINTS)) {
                const achievement = ACHIEVEMENTS[achId];
                if (!achievement) continue;

                const unlocked = gameData.achievements[achId];
                const tierClass = achData.tier === 'legendary' ? 'legendary' :
                                 achData.tier === 'rare' ? 'rare' : '';

                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${unlocked && tierClass}"
                         title="${achievement.desc} (${achData.points} AP)">
                        <div class="showcase-badge-icon">${achievement.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? achievement.name : '???'}</div>
                        ${unlocked ? `<div style="font-size: 9px; color: #ffd700;">+${achData.points} AP</div>` : ''}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Apply cosmetic effect visuals
        let lastCosmeticUpdate = 0;
        function updateCosmeticEffects(time) {
            if (!worldState.player) return;

            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            if (!activeCosmetic) return;

            if (time - lastCosmeticUpdate < 100) return;
            lastCosmeticUpdate = time;

            if (activeCosmetic === 'sparkle' && particles) {
                particles.emit(worldState.player.position, 2, 0xffffff, { spread: 1, lifetime: 500 });
            } else if (activeCosmetic.startsWith('aura_') && particles) {
                const colors = {
                    aura_blue: 0x4488ff,
                    aura_gold: 0xffd700,
                    aura_rainbow: Math.random() > 0.5 ? 0xff4488 : (Math.random() > 0.5 ? 0x44ff88 : 0x4488ff)
                };
                particles.emit(worldState.player.position, 1, colors[activeCosmetic] || 0xffffff, { spread: 2, lifetime: 800 });
            }
        }

        // v5.0: Dynamic Weather System
        const WEATHER_TYPES = {
            clear: {
                name: 'Clear',
                icon: 'â˜€ï¸',
                fogDensity: 1.0,
                lightIntensity: 1.0,
                moveSpeedMod: 1.0,
                particleType: null
            },
            rain: {
                name: 'Rain',
                icon: 'ðŸŒ§ï¸',
                fogDensity: 0.7,
                lightIntensity: 0.6,
                moveSpeedMod: 0.9,
                particleType: 'rain',
                particleColor: 0x6688aa
            },
            storm: {
                name: 'Storm',
                icon: 'â›ˆï¸',
                fogDensity: 0.5,
                lightIntensity: 0.4,
                moveSpeedMod: 0.8,
                particleType: 'rain',
                particleColor: 0x445566,
                lightning: true
            },
            fog: {
                name: 'Fog',
                icon: 'ðŸŒ«ï¸',
                fogDensity: 0.3,
                lightIntensity: 0.7,
                moveSpeedMod: 0.95,
                particleType: null
            },
            snow: {
                name: 'Snow',
                icon: 'â„ï¸',
                fogDensity: 0.6,
                lightIntensity: 0.8,
                moveSpeedMod: 0.85,
                particleType: 'snow',
                particleColor: 0xffffff
            },
            sandstorm: {
                name: 'Sandstorm',
                icon: 'ðŸœï¸',
                fogDensity: 0.4,
                lightIntensity: 0.5,
                moveSpeedMod: 0.75,
                particleType: 'sand',
                particleColor: 0xddbb88
            }
        };

        const BIOME_WEATHER = {
            Terra: ['clear', 'rain', 'fog'],
            Forest: ['clear', 'rain', 'fog'],
            Desert: ['clear', 'sandstorm'],
            Ice: ['clear', 'snow', 'storm'],
            Volcanic: ['clear', 'fog'],
            Ocean: ['clear', 'rain', 'storm'],
            Alien: ['clear', 'fog', 'storm'],
            Crystal: ['clear', 'fog']
        };

        let currentWeather = 'clear';
        let weatherTransition = 0;
        let weatherParticles = [];
        let lastLightningTime = 0;
        let weatherChangeTime = 0;

        function initWeatherSystem() {
            currentWeather = 'clear';
            weatherParticles = [];
            weatherChangeTime = performance.now() + 60000 + Math.random() * 120000; // 1-3 min initial
        }

        function updateWeather(dt, time) {
            if (!activeCiv || mode !== 'world') return;

            // Check for weather change
            if (time > weatherChangeTime) {
                changeWeather();
                weatherChangeTime = time + 60000 + Math.random() * 180000; // 1-4 min between changes
            }

            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            // Update fog based on weather
            if (scene.fog) {
                const targetNear = 20 * weather.fogDensity;
                const targetFar = 120 * weather.fogDensity;
                scene.fog.near += (targetNear - scene.fog.near) * dt * 0.5;
                scene.fog.far += (targetFar - scene.fog.far) * dt * 0.5;
            }

            // Update light intensity
            if (worldState.sun) {
                const baseIntensity = Math.max(0.1, Math.sin(worldState.timeOfDay * Math.PI * 2)) * 1.2;
                worldState.sun.intensity = baseIntensity * weather.lightIntensity;
            }

            // Spawn weather particles
            if (weather.particleType && worldState.player) {
                spawnWeatherParticles(weather, dt);
            }

            // Update weather particles
            updateWeatherParticles(dt);

            // Lightning effect
            if (weather.lightning && time - lastLightningTime > 3000 + Math.random() * 7000) {
                if (Math.random() < 0.3) {
                    triggerLightning();
                    lastLightningTime = time;
                }
            }
        }

        function changeWeather() {
            if (!activeCiv) return;

            const biomeWeathers = BIOME_WEATHER[activeCiv.biome] || ['clear'];
            const newWeather = biomeWeathers[Math.floor(Math.random() * biomeWeathers.length)];

            if (newWeather !== currentWeather) {
                currentWeather = newWeather;
                const weather = WEATHER_TYPES[newWeather];
                showNotification(`Weather: ${weather.icon} ${weather.name}`, 'info');
                updateWeatherUI();
            }
        }

        function updateWeatherUI() {
            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            const iconEl = document.getElementById('weather-icon');
            const nameEl = document.getElementById('weather-name');
            const effectEl = document.getElementById('weather-effect');

            if (iconEl) iconEl.textContent = weather.icon;
            if (nameEl) nameEl.textContent = weather.name;

            // Show speed effect if not 100%
            if (effectEl) {
                const speedPct = Math.round(weather.moveSpeedMod * 100);
                effectEl.textContent = speedPct < 100 ? `Speed: ${speedPct}%` : '';
            }
        }

        function spawnWeatherParticles(weather, dt) {
            const spawnRate = weather.particleType === 'rain' ? 50 : 20;
            const spawnCount = Math.floor(spawnRate * dt);

            for (let i = 0; i < spawnCount; i++) {
                const x = worldState.player.position.x + (Math.random() - 0.5) * 40;
                const z = worldState.player.position.z + (Math.random() - 0.5) * 40;
                const y = worldState.player.position.y + 20 + Math.random() * 10;

                weatherParticles.push({
                    x, y, z,
                    vx: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    vy: weather.particleType === 'snow' ? -3 - Math.random() * 2 : -15 - Math.random() * 10,
                    vz: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    life: 3,
                    color: weather.particleColor,
                    type: weather.particleType
                });
            }

            // Limit particle count
            if (weatherParticles.length > 500) {
                weatherParticles = weatherParticles.slice(-400);
            }
        }

        function updateWeatherParticles(dt) {
            weatherParticles = weatherParticles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.z += p.vz * dt;
                p.life -= dt;

                // Draw particle (simple point)
                if (p.life > 0 && particles && worldState.player) {
                    const dist = Math.sqrt(
                        Math.pow(p.x - worldState.player.position.x, 2) +
                        Math.pow(p.z - worldState.player.position.z, 2)
                    );
                    if (dist < 30 && Math.random() < 0.1) {
                        particles.emit(
                            { x: p.x, y: p.y, z: p.z },
                            1,
                            p.color,
                            { spread: 0.1, lifetime: 100, size: p.type === 'snow' ? 0.15 : 0.05 }
                        );
                    }
                }

                return p.life > 0 && p.y > -10;
            });
        }

        function triggerLightning() {
            // Flash screen white briefly
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: white; opacity: 0.8; pointer-events: none; z-index: 100;
            `;
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.style.opacity = '0.3';
                setTimeout(() => {
                    overlay.remove();
                }, 100);
            }, 50);

            // Thunder sound
            if (AudioSystem.enabled && AudioSystem.ctx) {
                const osc = AudioSystem.ctx.createOscillator();
                const gain = AudioSystem.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, AudioSystem.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, AudioSystem.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, AudioSystem.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AudioSystem.ctx.currentTime + 0.8);
                osc.connect(gain);
                gain.connect(AudioSystem.ctx.destination);
                osc.start();
                osc.stop(AudioSystem.ctx.currentTime + 0.8);
            }

            screenShake(0.8);
        }

        function getWeatherSpeedMod() {
            const weather = WEATHER_TYPES[currentWeather];
            return weather ? weather.moveSpeedMod : 1.0;
        }

        function updateStatsDisplay() {
            const s = gameData.statistics;

            document.getElementById('stat-planets').textContent = `${gameData.visitedPlanets.length} / ${CONFIG.NUM_CIVS}`;

            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('stat-playtime').textContent = `${hours}h ${mins}m`;

            document.getElementById('stat-trees').textContent = s.treesChopped || 0;
            document.getElementById('stat-ore').textContent = s.oresMined || 0;
            document.getElementById('stat-fish').textContent = s.fishCaught || 0;
            document.getElementById('stat-mobs').textContent = s.mobsKilled || 0;
            document.getElementById('stat-crafted').textContent = s.itemsCrafted || 0;

            // v4.2: Display POIs discovered and player rank
            const poisEl = document.getElementById('stat-pois');
            if (poisEl) poisEl.textContent = s.poisDiscovered || 0;

            const rankEl = document.getElementById('stat-rank');
            if (rankEl) {
                const rank = getPlayerRank();
                rankEl.textContent = rank.title;
                rankEl.style.color = rank.color;
            }

            const pointsEl = document.getElementById('stat-points');
            if (pointsEl) pointsEl.textContent = calculatePlayerPoints();

            // v4.2: Display special titles
            const titlesEl = document.getElementById('special-titles');
            if (titlesEl) {
                const titles = getSpecialTitles();
                if (titles.length > 0) {
                    titlesEl.innerHTML = titles.map(t =>
                        `<span style="color:${t.color}">${t.name}</span>`
                    ).join(' | ');
                } else {
                    titlesEl.innerHTML = '<span style="color:#666">None yet</span>';
                }
            }

            // Render achievements
            const achList = document.getElementById('achievements-list');
            if (achList) {
                achList.innerHTML = '';
                for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
                    const unlocked = gameData.achievements[id];
                    const div = document.createElement('div');
                    div.className = `ach-item ${unlocked ? 'unlocked' : 'locked'}`;
                    div.innerHTML = `<span class="ach-badge">${ach.icon}</span><span>${ach.name}</span>`;
                    div.title = ach.desc;
                    achList.appendChild(div);
                }
            }

            // v4.4: Render leaderboard
            const lbList = document.getElementById('leaderboard-list');
            if (lbList) {
                const lb = getLeaderboardPosition();
                lbList.innerHTML = lb.nearby.map((p, i) => {
                    const isYou = p.name === 'YOU';
                    const bgColor = isYou ? 'rgba(255,215,0,0.2)' : 'transparent';
                    const textColor = isYou ? '#ffd700' : '#aaa';
                    const rank = lb.position - (lb.nearby.indexOf(lb.nearby.find(x => x.name === 'YOU'))) + i;
                    return `<div style="display: flex; justify-content: space-between; padding: 4px 8px; margin: 2px 0; background: ${bgColor}; border-radius: 4px;">
                        <span style="color: ${textColor};">#${rank} ${p.name}</span>
                        <span style="color: #888;">${p.points.toLocaleString()} pts</span>
                    </div>`;
                }).join('');
            }

            // v4.4: Render prestige info
            const prestigeLevel = gameData.prestige?.level || 0;
            const xpMult = gameData.prestige?.bonuses?.xpMultiplier || 1.0;
            const lifetimePoints = gameData.prestige?.totalLifetimePoints || 0;

            document.getElementById('prestige-level').textContent = prestigeLevel;
            document.getElementById('prestige-xp').textContent = `x${xpMult.toFixed(1)}`;
            document.getElementById('prestige-lifetime').textContent = lifetimePoints.toLocaleString();

            const progressEl = document.getElementById('prestige-progress');
            const prestigeBtn = document.getElementById('prestige-btn');
            const nextLevel = PRESTIGE_LEVELS[prestigeLevel + 1];

            if (nextLevel) {
                const currentPts = calculatePlayerPoints();
                const progress = Math.min(100, (currentPts / nextLevel.required) * 100);
                progressEl.innerHTML = `Next prestige: ${currentPts.toLocaleString()} / ${nextLevel.required.toLocaleString()} pts (${progress.toFixed(1)}%)`;

                if (canPrestige()) {
                    prestigeBtn.style.display = 'block';
                } else {
                    prestigeBtn.style.display = 'none';
                }
            } else {
                progressEl.innerHTML = `<span style="color: #aa44ff;">MAX PRESTIGE REACHED!</span>`;
                prestigeBtn.style.display = 'none';
            }
        }

        // --- DATA PERSISTENCE ---
        function loadGameData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle version updates
                    gameData = { ...gameData, ...parsed };
                    // Ensure nested objects exist
                    gameData.skills = { ...gameData.skills, ...parsed.skills };
                    gameData.player = { ...gameData.player, ...parsed.player };
                    gameData.statistics = { ...gameData.statistics, ...parsed.statistics };
                    console.log('Game data loaded successfully');
                }
            } catch (e) {
                console.error('Failed to load game data:', e);
            }
        }

        function saveGameData() {
            try {
                gameData.lastPlayed = new Date().toISOString();
                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                console.log('Game saved');
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.version) {
                        gameData = { ...gameData, ...imported };
                        saveGameData();
                        showNotification('Save imported! Refreshing...');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        alert('Invalid save file format');
                    }
                } catch (error) {
                    alert('Failed to import: Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // v4.6: Quick save function
        function quickSave() {
            saveGameData();
            document.getElementById('last-save-time').textContent = new Date().toLocaleString();
            showNotification('Game saved!');
        }

        // v4.7: Session Rewards System
        let pendingSessionReward = null;

        function checkSessionRewards() {
            if (!gameData.lastPlayed) return null;

            const lastPlayed = new Date(gameData.lastPlayed);
            const now = new Date();
            const hoursAway = Math.min(
                (now - lastPlayed) / (1000 * 60 * 60),
                SESSION_REWARDS.maxOfflineHours
            );

            // Find the best applicable tier
            let bestTier = null;
            for (const tier of SESSION_REWARDS.tiers) {
                if (hoursAway >= tier.minHours) {
                    bestTier = tier;
                }
            }

            if (bestTier) {
                return {
                    tier: bestTier,
                    hoursAway: Math.floor(hoursAway),
                    minutesAway: Math.floor((hoursAway % 1) * 60)
                };
            }
            return null;
        }

        function showWelcomeBackModal(reward) {
            pendingSessionReward = reward;

            document.getElementById('welcome-back-message').textContent = reward.tier.message;

            const timeText = reward.hoursAway > 0
                ? `You were away for ${reward.hoursAway}h ${reward.minutesAway}m`
                : `You were away for ${reward.minutesAway}m`;
            document.getElementById('welcome-back-time').textContent = timeText;

            // Build rewards list
            const rewardsList = document.getElementById('welcome-back-rewards-list');
            let html = '';
            html += `<div style="color: #ffd700; margin-bottom: 8px;">+${reward.tier.xpBonus} XP (all skills)</div>`;
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                const icon = ITEMS[item]?.icon || 'ðŸ“¦';
                html += `<div style="color: #aaf; margin-bottom: 4px;">${icon} ${count}x ${item}</div>`;
            }
            rewardsList.innerHTML = html;

            document.getElementById('welcome-back-modal').style.display = 'flex';
            AudioSystem.levelUp();
        }

        function claimWelcomeBackRewards() {
            if (!pendingSessionReward) return;

            const reward = pendingSessionReward;

            // Grant XP to all skills
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(reward.tier.xpBonus / Object.keys(gameData.skills).length));
            });

            // Grant resources
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                for (let i = 0; i < count; i++) {
                    addItem(item);
                }
            }

            // Track the claim
            gameData.statistics.sessionRewardsClaimed = (gameData.statistics.sessionRewardsClaimed || 0) + 1;

            document.getElementById('welcome-back-modal').style.display = 'none';
            showNotification('Rewards claimed! Welcome back!', 'success');
            AudioSystem.collect();

            pendingSessionReward = null;
            saveGameData();
        }

        // v5.7: Secondary menu toggle
        function toggleSecondaryMenu() {
            const menu = document.getElementById('menu-secondary');
            menu.classList.toggle('show');
        }

        // Close secondary menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('menu-secondary');
            const toggle = document.querySelector('.menu-toggle');
            if (menu && toggle && !menu.contains(e.target) && !toggle.contains(e.target)) {
                menu.classList.remove('show');
            }
        });

        // v4.6: Settings Modal Functions
        function showSettingsModal() {
            // Sync UI with current settings
            const s = gameData.settings || {};
            document.getElementById('volume-slider').value = s.masterVolume || 30;
            document.getElementById('volume-display').textContent = (s.masterVolume || 30) + '%';
            updateToggleBtn('sfx-toggle', s.sfxEnabled !== false);
            updateToggleBtn('ambient-toggle', s.ambientEnabled !== false);
            updateToggleBtn('shadow-toggle', s.shadowsEnabled !== false);
            updateToggleBtn('shake-toggle', s.screenShakeEnabled !== false);
            updateToggleBtn('hints-toggle', s.hintsEnabled !== false);
            document.getElementById('particle-quality').value = s.particleQuality || 'high';
            document.getElementById('last-save-time').textContent = gameData.lastPlayed ? new Date(gameData.lastPlayed).toLocaleString() : 'Never';
            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveGameData();
        }

        function updateToggleBtn(id, isOn) {
            const btn = document.getElementById(id);
            if (isOn) {
                btn.textContent = 'ON';
                btn.classList.remove('off');
            } else {
                btn.textContent = 'OFF';
                btn.classList.add('off');
            }
        }

        function setMasterVolume(val) {
            gameData.settings = gameData.settings || {};
            gameData.settings.masterVolume = parseInt(val);
            AudioSystem.masterVolume = val / 100;
            document.getElementById('volume-display').textContent = val + '%';
        }

        function toggleSFX() {
            gameData.settings = gameData.settings || {};
            gameData.settings.sfxEnabled = !gameData.settings.sfxEnabled;
            AudioSystem.enabled = gameData.settings.sfxEnabled;
            updateToggleBtn('sfx-toggle', gameData.settings.sfxEnabled);
        }

        function toggleAmbient() {
            gameData.settings = gameData.settings || {};
            gameData.settings.ambientEnabled = !gameData.settings.ambientEnabled;
            if (gameData.settings.ambientEnabled) {
                if (mode === 'world' && activeCiv) AudioSystem.startAmbient(activeCiv.biome);
            } else {
                AudioSystem.stopAmbient();
            }
            updateToggleBtn('ambient-toggle', gameData.settings.ambientEnabled);
        }

        function setParticleQuality(quality) {
            gameData.settings = gameData.settings || {};
            gameData.settings.particleQuality = quality;
            // Adjust particle limits
            if (particles) {
                particles.maxParticles = quality === 'high' ? 100 : quality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = quality === 'high' ? 60 : quality === 'medium' ? 30 : 15;
            }
        }

        function toggleShadows() {
            gameData.settings = gameData.settings || {};
            gameData.settings.shadowsEnabled = !gameData.settings.shadowsEnabled;
            renderer.shadowMap.enabled = gameData.settings.shadowsEnabled;
            updateToggleBtn('shadow-toggle', gameData.settings.shadowsEnabled);
        }

        function toggleScreenShake() {
            gameData.settings = gameData.settings || {};
            gameData.settings.screenShakeEnabled = !gameData.settings.screenShakeEnabled;
            updateToggleBtn('shake-toggle', gameData.settings.screenShakeEnabled);
        }

        function toggleHints() {
            gameData.settings = gameData.settings || {};
            gameData.settings.hintsEnabled = !gameData.settings.hintsEnabled;
            updateToggleBtn('hints-toggle', gameData.settings.hintsEnabled);
        }

        // v4.6: Apply settings on load
        function applySettings() {
            const s = gameData.settings || {};
            AudioSystem.masterVolume = (s.masterVolume || 30) / 100;
            AudioSystem.enabled = s.sfxEnabled !== false;
            if (particles) {
                particles.maxParticles = s.particleQuality === 'high' ? 100 : s.particleQuality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = s.particleQuality === 'high' ? 60 : s.particleQuality === 'medium' ? 30 : 15;
            }
        }

        function closeModal() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        // v4.3: Notification queue to prevent stacking
        const notificationQueue = [];
        let notificationActive = false;
        const MAX_VISIBLE_NOTIFICATIONS = 3;
        let visibleNotifications = [];

        function showNotification(message, type = 'success') {
            // Add to queue
            notificationQueue.push({ message, type });
            processNotificationQueue();
        }

        function processNotificationQueue() {
            // Remove expired notifications
            visibleNotifications = visibleNotifications.filter(n => n.element.parentNode);

            // Process queue while under limit
            while (notificationQueue.length > 0 && visibleNotifications.length < MAX_VISIBLE_NOTIFICATIONS) {
                const { message, type } = notificationQueue.shift();
                displayNotification(message, type);
            }
        }

        function displayNotification(message, type) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;

            // Position based on how many are currently visible
            const offset = visibleNotifications.length * 50;
            notif.style.top = (100 + offset) + 'px';

            if (type === 'error') {
                notif.style.background = 'rgba(100, 0, 0, 0.9)';
                notif.style.borderColor = '#f00';
                notif.style.color = '#f00';
            } else if (type === 'warning') {
                notif.style.background = 'rgba(100, 80, 0, 0.9)';
                notif.style.borderColor = '#fa0';
                notif.style.color = '#fa0';
            }

            document.body.appendChild(notif);
            const notifObj = { element: notif, expires: Date.now() + 2500 };
            visibleNotifications.push(notifObj);

            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    notif.remove();
                    processNotificationQueue();
                }, 300);
            }, 2500);
        }

        // --- INITIALIZATION ---
        function init() {
            loadGameData();

            // v5.7: Load RAPPID settings for AI-powered Copilot
            loadRappidSettings();

            // v5.3: Initialize portal system
            initPortalSystem();

            // v4.7: Check for welcome back rewards
            const sessionReward = checkSessionRewards();
            if (sessionReward) {
                // Delay modal to let game initialize
                setTimeout(() => showWelcomeBackModal(sessionReward), 1500);
            }

            // v4.0: Initialize audio and particle systems
            AudioSystem.init();
            particles = new ParticleSystem();
            envParticles = new EnvironmentParticles(); // v4.4

            // v4.6: Apply saved settings
            applySettings();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize floater pool
            for (let i = 0; i < MAX_FLOATERS; i++) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.display = 'none';
                document.body.appendChild(el);
                floaterPool.push({ el, active: false });
            }

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            // Touch events
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'flex';
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.getElementById('touch-action').addEventListener('touchstart', onTouchAction);

                // v4.3: Virtual Joystick setup
                const joystick = document.getElementById('virtual-joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                const actionBtn = document.getElementById('touch-action-btn');

                joystick.style.display = 'block';
                actionBtn.style.display = 'flex';

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    joystickActive = true;
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (joystickActive) {
                        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickInput = { x: 0, y: 0 };
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });

                actionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world' && worldState.interactTarget) {
                        performAction(worldState.interactTarget);
                    }
                }, { passive: false });

                // v4.5: Dodge button setup
                const dodgeBtn = document.getElementById('touch-dodge-btn');
                dodgeBtn.style.display = 'flex';
                dodgeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world') {
                        startDodge();
                    }
                }, { passive: false });

                function updateJoystick(touchX, touchY) {
                    let dx = touchX - joystickCenter.x;
                    let dy = touchY - joystickCenter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > joystickMaxDist) {
                        dx = (dx / dist) * joystickMaxDist;
                        dy = (dy / dist) * joystickMaxDist;
                    }

                    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    joystickInput = { x: dx / joystickMaxDist, y: dy / joystickMaxDist };
                }
            }

            // Keyboard events (including WASD)
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            // v5.11: RTS Panel hotkeys
            window.addEventListener('keydown', handleRTSPanelHotkeys);

            initGalaxy();
            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();

            // v4.1: Initialize daily challenge system
            generateDailyChallenge();
            updateDailyChallengeUI();

            document.getElementById('loading').style.display = 'none';

            // v4.0: Show tutorial for first-time players
            if (!gameData.hasSeenTutorial) {
                setTimeout(showTutorial, 500);
            }

            // v4.1: Check achievements on load
            checkAchievements();

            // Autosave
            setInterval(() => {
                if (mode === 'world') {
                    saveGameData();
                    checkAchievements();
                    updateDailyChallengeProgress();
                    // v5.3: Check portal timeout
                    checkPortalTimeout();
                }
            }, CONFIG.AUTOSAVE_INTERVAL);

            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            mode = 'galaxy';

            // v4.3: Stop ambient audio when leaving planet
            AudioSystem.stopAmbient();

            // v4.4: Stop environmental particles
            if (envParticles) envParticles.stop();

            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield (optimized with BufferGeometry)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<8000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                const c = new THREE.Color().setHSL(Math.random() * 0.2 + 0.55, 0.2, 0.8 + Math.random() * 0.2);
                starColors.push(c.r, c.g, c.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 2, vertexColors: true })));

            // v4.1: Nebula clouds for atmosphere
            createNebulae();

            // Civilizations
            const rng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();

            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(200, 1200);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = rng.range(-100, 100);

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));
                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i)
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);

                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(8, 16, 16),
                    new THREE.MeshBasicMaterial({color: color})
                );
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.2})
                );
                sysGroup.add(glow);

                // Mark visited planets
                if (civ.visited) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(18, 20, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2;
                    sysGroup.add(ring);
                }

                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('weather-indicator').style.display = 'none';
            document.getElementById('civ-count').innerText = CONFIG.NUM_CIVS;

            updatePlaytimeDisplay();
        }

        // --- WORLD MODE ---
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';

            // Mark as visited
            if (!gameData.visitedPlanets.includes(civ.id)) {
                gameData.visitedPlanets.push(civ.id);
                showNotification(`First visit to ${civ.name}!`);
                // v4.1: Check achievements after planet discovery
                checkAchievements();
                updateDailyChallengeProgress();
            }

            // v4.9: Track biome in codex
            trackBiomeVisit(civ.biome.toLowerCase());

            while(scene.children.length > 0) scene.remove(scene.children[0]);

            // v4.3: Reset boss spawn tracking for new world
            worldMobKillCount = 0;
            bossSpawned = false;

            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 1024;
            worldState.sun.shadow.mapSize.height = 1024;
            scene.add(worldState.sun);

            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.interactables = [];
            worldState.fishingSpots = [];
            worldState.mobs = [];

            // Merged geometry for better performance
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            const groundMat = new THREE.MeshLambertMaterial({ color: biome.ground });
            const waterMat = new THREE.MeshLambertMaterial({ color: biome.water, transparent: true, opacity: 0.8 });

            const worldGroup = new THREE.Group();

            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    const hVal = noise(x + civ.id, z + civ.id);
                    const height = Math.floor((hVal + 1) * 3);
                    const realY = height * CONFIG.TILE_SIZE/2;

                    const isWater = height < 1;

                    const mesh = new THREE.Mesh(groundGeo, isWater ? waterMat : groundMat);
                    mesh.position.set(
                        (x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE,
                        realY,
                        (z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE
                    );
                    mesh.receiveShadow = true;
                    worldGroup.add(mesh);

                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    // Fishing spots in water
                    if(isWater && rng.next() > 0.95) {
                        createFishingSpot(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                    }

                    // Trees/Rocks
                    if(!isWater && rng.next() > 0.85) {
                        const type = rng.next() > 0.5 ? 'tree' : 'rock';
                        createProp(type, mesh.position.x, mesh.position.y + CONFIG.TILE_SIZE/2, mesh.position.z, biome);
                    }
                }
            }
            scene.add(worldGroup);

            // Player - Using CylinderGeometry since CapsuleGeometry isn't in Three.js r128
            const playerGroup = new THREE.Group();

            // Body (cylinder)
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.6, 8);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.3, roughness: 0.7 });
            const body = new THREE.Mesh(bodyGeo, playerMat);
            body.position.y = 0.8;
            body.castShadow = true;
            playerGroup.add(body);

            // Head (sphere on top)
            const headGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeo, playerMat);
            head.position.y = 1.8;
            head.castShadow = true;
            playerGroup.add(head);

            worldState.player = playerGroup;
            worldState.player.position.set(0, 10, 0);

            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0;
            worldState.player.add(ring);

            scene.add(worldState.player);

            // Mobs
            const mobCount = 5 + Math.floor(rng.next() * 5);
            for(let i=0; i<mobCount; i++) {
                createMob(rng, biome);
            }

            // v4.2: Generate POIs based on biome
            worldState.pois = [];
            const biomeKey = civ.biome;
            for (const [poiType, poiData] of Object.entries(POI_TYPES)) {
                // Check if POI can spawn in this biome
                if (poiData.biomes && !poiData.biomes.includes(biomeKey)) continue;

                // Check rarity
                if (rng.next() < poiData.rarity) {
                    // Check if already discovered on this planet
                    const alreadyDiscovered = gameData.discoveredPOIs[civ.id]?.includes(poiType);
                    createPOI(rng, biome, poiType, poiData);
                    // Mark pre-discovered POIs
                    if (alreadyDiscovered && worldState.pois.length > 0) {
                        const poi = worldState.pois[worldState.pois.length - 1];
                        poi.userData.discovered = true;
                        if (poi.userData.beacon) poi.userData.beacon.material.emissiveIntensity = 0.1;
                        if (poi.userData.iconMesh) poi.userData.iconMesh.material.opacity = 0.3;
                    }
                }
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('world-name').textContent = civ.biomeName;
            document.getElementById('rpg-ui').style.display = 'flex';
            document.getElementById('player-health-bar').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('ability-bar').style.display = 'block';
            document.getElementById('weather-indicator').style.display = 'block';
            updateAbilityUI();
            updateWeatherUI();

            // v4.3: Start biome ambient audio
            AudioSystem.startAmbient(civ.biome);

            // v5.0: Spawn pet companion
            initPetSystem();
            updatePetMesh();

            // v5.6: Initialize and spawn Copilot Companion
            initCopilotCompanion();
            createCopilotMesh();

            // v5.12: Initialize hypnosis effects
            initHypnosisEffects();

            // v5.13: Create ship and landing zone
            const landingSpot = new THREE.Vector3(
                (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE,
                10,
                (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE
            );
            // Find ground height at landing spot
            const lx = Math.floor(CONFIG.WORLD_SIZE / 4);
            const lz = Math.floor(CONFIG.WORLD_SIZE / 4);
            if (worldState.terrain[lx] && worldState.terrain[lx][lz] !== undefined) {
                landingSpot.y = worldState.terrain[lx][lz] > 0 ? worldState.terrain[lx][lz] : 5;
            }
            const landingPad = createLandingZone(landingSpot);
            scene.add(landingPad);
            const ship = createWorldShip(landingSpot);
            scene.add(ship);
            SHIP_STATE.hp = SHIP_STATE.maxHp;  // Reset ship HP for new world
            updateShipHPUI();
            document.getElementById('ship-status').style.display = 'block';

            // v5.0: Initialize weather system
            initWeatherSystem();

            // v5.4: Initialize new systems
            initPetEvolutionSystem();
            initWorldEventSystem();
            initAchievementShowcase();

            // v4.4: Start environmental particles
            if (envParticles) envParticles.startBiome(civ.biome);

            worldState.target = null;
            worldState.interactTarget = null;

            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();
            updateCraftingUI();
            initMinimap();
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                    new THREE.MeshLambertMaterial({ color: 0x553311 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: biome.tree })
                );
                leaves.position.y = 2.8;
                leaves.castShadow = true;
                group.add(leaves);
                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: 'Ancient Tree' };
            } else {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1),
                    new THREE.MeshLambertMaterial({ color: biome.rock })
                );
                rock.position.y = 0.5;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createFishingSpot(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Ripple effect
            const ripple = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ripple.rotation.x = -Math.PI / 2;
            group.add(ripple);

            group.userData = { type: 'fishing', name: 'Fishing Spot', ripple };
            scene.add(group);
            worldState.fishingSpots.push(group);
            worldState.interactables.push(group);
        }

        function createMob(rng, biome) {
            // v4.2: Select enemy type based on biome
            const biomeKey = biome.name === 'Terra' ? 'Terra' :
                            biome.name === 'Desert' ? 'Desert' :
                            biome.name === 'Tundra' ? 'Ice' :
                            biome.name === 'Xeno' ? 'Alien' :
                            biome.name === 'Magma' ? 'Volcanic' : 'Terra';

            const validEnemies = Object.entries(ENEMY_TYPES)
                .filter(([name, data]) => data.biomes.includes(biomeKey));

            const [enemyName, enemyData] = validEnemies.length > 0
                ? validEnemies[rng.int(0, validEnemies.length - 1)]
                : ['Slime', ENEMY_TYPES.Slime];

            // v4.7: Elite enemy roll
            const prestigeLevel = gameData.prestige?.level || 0;
            const isElite = prestigeLevel >= ELITE_CONFIG.minWorldLevel &&
                           rng.next() < ELITE_CONFIG.spawnChance;

            let eliteAffix = null;
            let eliteData = null;
            if (isElite) {
                const affixKeys = Object.keys(ELITE_AFFIXES);
                const affixKey = affixKeys[rng.int(0, affixKeys.length - 1)];
                eliteAffix = affixKey;
                eliteData = ELITE_AFFIXES[affixKey];
            }

            // Calculate stats with elite multipliers
            const baseHp = enemyData.hp * (eliteData ? eliteData.hpMult : 1);
            const baseDamage = enemyData.damage * (eliteData ? eliteData.damageMult : 1);
            const baseSpeed = enemyData.speed * (eliteData ? eliteData.speedMult : 1);

            const mobGeo = new THREE.SphereGeometry(isElite ? 1.0 : 0.8, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({
                color: eliteData ? eliteData.color : enemyData.color,
                roughness: 0.3,
                emissive: eliteData ? eliteData.color : enemyData.emissive,
                emissiveIntensity: isElite ? 0.5 : 0.2
            });
            const mob = new THREE.Mesh(mobGeo, mobMat);

            const rx = (rng.next() - 0.5) * 60;
            const rz = (rng.next() - 0.5) * 60;
            mob.position.set(rx, 10, rz);
            mob.castShadow = true;

            // v4.7: Add glowing aura ring for elite enemies
            if (isElite) {
                const auraGeo = new THREE.RingGeometry(1.2, 1.5, 32);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: eliteData.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                mob.add(aura);
                mob.userData.auraRing = aura;
            }

            // v5.12: Hypnotist special eye appearance
            if (enemyData.isHypnotist) {
                // Create eye-like structure with iris and pupil
                const irisGeo = new THREE.CircleGeometry(0.5, 32);
                const irisMat = new THREE.MeshBasicMaterial({
                    color: 0x8800ff,
                    side: THREE.DoubleSide
                });
                const iris = new THREE.Mesh(irisGeo, irisMat);
                iris.position.z = 0.75;
                mob.add(iris);

                // Pupil (inner dark circle that moves)
                const pupilGeo = new THREE.CircleGeometry(0.25, 32);
                const pupilMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                pupil.position.z = 0.76;
                mob.add(pupil);
                mob.userData.pupil = pupil;
                mob.userData.iris = iris;

                // Glowing concentric rings around the eye
                for (let i = 0; i < 3; i++) {
                    const ringGeo = new THREE.RingGeometry(0.9 + i * 0.3, 1.0 + i * 0.3, 32);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0xff00ff : 0x8800ff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.z = 0.74 - i * 0.02;
                    mob.add(ring);
                }

                // Give it a floating, creepy movement
                mob.userData.isHypnotist = true;
            }

            // Health bar above mob (larger for elites)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.0 : 1.5, 0.15),
                new THREE.MeshBasicMaterial({ color: isElite ? 0xffaa00 : 0x00ff00, side: THREE.DoubleSide })
            );
            hpBar.position.y = isElite ? 1.8 : 1.5;
            mob.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.1 : 1.6, 0.2),
                new THREE.MeshBasicMaterial({ color: isElite ? 0x553300 : 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = isElite ? 1.8 : 1.5;
            hpBg.position.z = -0.01;
            mob.add(hpBg);

            // v5.3: Apply portal modifiers to mob stats
            const portalMods = getPortalModifiers();
            let finalHp = baseHp;
            let finalDamage = baseDamage;
            if (portalMods) {
                finalHp = Math.floor(baseHp * (portalMods.enemyHp || 1));
                finalDamage = Math.floor(baseDamage * (portalMods.enemyDamage || 1));
            }

            mob.userData = {
                type: 'mob',
                hp: finalHp,
                maxHp: finalHp,
                name: enemyName,
                damage: finalDamage,
                speed: baseSpeed,
                drops: enemyData.drops,
                xpReward: enemyData.xp * (isElite ? ELITE_CONFIG.bonusXpMult : 1),
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                // v4.5: Attack telegraph properties
                attackWindup: enemyData.attackWindup || 600,
                attackRange: enemyData.attackRange || 2.5,
                telegraphing: false,
                // v4.7: Elite properties
                isElite: isElite,
                eliteAffix: eliteAffix,
                eliteData: eliteData,
                displayName: isElite ? `${eliteData.prefix} ${eliteData.name} ${enemyName}` : enemyName,
                // v5.3: Portal-modified flag
                portalBuffed: portalMods !== null
            };

            scene.add(mob);
            worldState.mobs.push(mob);

            // v4.7: Announce elite spawn
            if (isElite) {
                showNotification(`${eliteData.prefix} ELITE ${eliteData.name} ${enemyName} appeared!`, 'warning');
            }
        }

        // v4.2: Create Point of Interest
        function createPOI(rng, biome, poiType, poiData) {
            const group = new THREE.Group();

            // Create visual marker based on POI type
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.5, 8);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x886644,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            group.add(base);

            // Add glowing beacon
            const beaconGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 8);
            const beaconMat = new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 2.5;
            group.add(beacon);

            // Floating icon sphere
            const iconGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const iconMat = new THREE.MeshStandardMaterial({
                color: 0x44ffff,
                emissive: 0x22aaaa,
                transparent: true,
                opacity: 0.8
            });
            const icon = new THREE.Mesh(iconGeo, iconMat);
            icon.position.y = 5;
            group.add(icon);

            const rx = (rng.next() - 0.5) * 50;
            const rz = (rng.next() - 0.5) * 50;
            group.position.set(rx, 0, rz);

            group.userData = {
                type: 'poi',
                poiType: poiType,
                name: poiData.name,
                icon: poiData.icon,
                rewards: poiData.rewards,
                xpBonus: poiData.xpBonus,
                discovered: false,
                beacon: beacon,
                iconMesh: icon
            };

            scene.add(group);
            worldState.pois.push(group);
            worldState.interactables.push(group);
        }

        // v4.3: Create Boss
        function createBoss(biomeKey) {
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];
            if (!bossData) return;

            // Create larger, more intimidating boss mesh
            const bossGeo = new THREE.SphereGeometry(0.8 * bossData.scale, 24, 24);
            const bossMat = new THREE.MeshStandardMaterial({
                color: bossData.color,
                roughness: 0.2,
                emissive: bossData.emissive,
                emissiveIntensity: 0.5
            });
            const boss = new THREE.Mesh(bossGeo, bossMat);

            // Position boss away from spawn
            boss.position.set(
                (Math.random() - 0.5) * 40,
                15,
                (Math.random() - 0.5) * 40
            );
            boss.castShadow = true;

            // Boss health bar (larger)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            hpBar.position.y = 3;
            boss.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(3.2, 0.4),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = 3;
            hpBg.position.z = -0.01;
            boss.add(hpBg);

            // Crown/indicator for boss
            const crownGeo = new THREE.ConeGeometry(0.5, 0.8, 4);
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800 });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.y = bossData.scale * 0.8 + 0.5;
            crown.rotation.y = Math.PI / 4;
            boss.add(crown);

            boss.userData = {
                type: 'boss',
                bossId: bossId,
                hp: bossData.hp,
                maxHp: bossData.hp,
                name: bossData.name,
                damage: bossData.damage,
                speed: bossData.speed,
                scale: bossData.scale,
                drops: bossData.drops,
                xpReward: bossData.xp,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                isBoss: true
            };

            scene.add(boss);
            worldState.mobs.push(boss);

            // Announce boss spawn
            showNotification(`BOSS APPEARED: ${bossData.name}!`, 'error');
            AudioSystem.bossSpawn();

            return boss;
        }

        // v4.3: Track world mob kills for boss spawning
        let worldMobKillCount = 0;
        let bossSpawned = false;

        function checkBossSpawn() {
            if (bossSpawned || !activeCiv) return;

            // Find the appropriate boss for this biome
            const biomeKey = activeCiv.biome;
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];

            if (!bossData) return;

            const condition = bossData.spawnCondition;

            // v4.5: Check mob kill requirement
            if (worldMobKillCount < condition.mobsKilled) return;

            // v4.5: Check combat level requirement
            if (condition.minCombatLevel && gameData.skills.combat.level < condition.minCombatLevel) {
                // Show hint if close to spawning
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires Combat Level ${condition.minCombatLevel}!`, 'warning');
                }
                return;
            }

            // v4.5: Check required item
            if (condition.requiredItem && !hasItem(condition.requiredItem)) {
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires ${condition.requiredItem} equipped!`, 'warning');
                }
                return;
            }

            createBoss(biomeKey);
            bossSpawned = true;
        }

        // --- GAME LOOP ---
        // v4.7: Tab visibility handling
        let tabVisible = true;
        let lastFpsTime = 0;
        let frameCount = 0;
        let currentFps = 60;

        document.addEventListener('visibilitychange', () => {
            tabVisible = !document.hidden;
            if (tabVisible) {
                // Reset timing when tab becomes visible to prevent huge dt
                lastTime = performance.now();
                AudioSystem.resume();
            } else {
                // Pause audio when tab is hidden
                if (AudioSystem.ctx && AudioSystem.ctx.state === 'running') {
                    AudioSystem.ctx.suspend();
                }
            }
        });

        function loop(time) {
            requestAnimationFrame(loop);

            // v4.7: Skip updates when tab is not visible (save resources)
            if (!tabVisible) {
                return;
            }

            // v4.7: Track FPS for adaptive performance
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = time;

                // Adaptive performance: reduce particles if FPS drops
                if (currentFps < 30 && particles && particles.maxParticles > 25) {
                    particles.maxParticles = Math.max(25, particles.maxParticles - 10);
                    console.log('Performance: Reduced particles to', particles.maxParticles);
                } else if (currentFps > 55 && particles && particles.maxParticles < 100) {
                    particles.maxParticles = Math.min(100, particles.maxParticles + 5);
                }
            }

            // v4.4: Hit-stop effect - skip game logic during freeze, still render
            if (performance.now() < hitStopUntil) {
                renderer.render(scene, camera);
                return;
            }

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            gameData.playtime += dt;

            if(mode === 'galaxy') {
                galaxyGroup.rotation.y += 0.0005;
                cycle = Math.floor(time / 1000);
                document.getElementById('cycle-count').innerText = cycle;

                if(activeCiv) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);
                }

                if (cycle % 10 === 0) updatePlaytimeDisplay();
            }
            else if(mode === 'world') {
                updateWorld(dt, time);
            }

            renderer.render(scene, camera);
        }

        function updateWorld(dt, time) {
            // Day/Night Cycle
            worldState.timeOfDay = (time * 0.00005) % 1;
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;

            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0.1, Math.sin(angle)) * 1.2;

            const biome = BIOMES[activeCiv.biome];
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x050510);
            scene.background.lerpColors(nightColor, dayColor, Math.max(0.1, Math.sin(angle)));
            scene.fog.color.copy(scene.background);

            // Player Movement
            const p = worldState.player;

            // v4.7: Check and clear chilled status
            if (playerState.chilled && time > playerState.chilledEnd) {
                playerState.chilled = false;
                playerState.moveSpeedMult = 1.0;
            }
            // v5.0: Apply weather speed modifier, v5.1: Apply equipment move speed
            const equipStats = getEquipmentStats();
            const speed = 12 * playerState.moveSpeedMult * getWeatherSpeedMod() * equipStats.moveSpeed;

            // v4.0: WASD keyboard movement + v4.3: Virtual joystick
            const hasKeyInput = keys.w || keys.a || keys.s || keys.d;
            const hasJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);

            // v5.5: Disable autopilot if player takes manual control
            if (hasKeyInput || hasJoystickInput) {
                if (autoExplore.enabled) {
                    autoExplore.enabled = false;
                    autoExplore.currentTarget = null;
                    updateAutoExploreUI();
                    showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
                }
            }

            // v5.5: Run autonomous exploration if enabled
            if (autoExplore.enabled) {
                runAutoExplore(dt);
            }

            if (hasKeyInput || hasJoystickInput) {
                _tempVec3A.set(0, 0, 0);
                if (hasKeyInput) {
                    if (keys.w) _tempVec3A.z -= 1;
                    if (keys.s) _tempVec3A.z += 1;
                    if (keys.a) _tempVec3A.x -= 1;
                    if (keys.d) _tempVec3A.x += 1;
                } else if (hasJoystickInput) {
                    // v4.3: Joystick input (x is left/right, y is up/down on screen = forward/back in 3D)
                    _tempVec3A.x = joystickInput.x;
                    _tempVec3A.z = joystickInput.y;
                }
                _tempVec3A.normalize().multiplyScalar(speed * dt);
                p.position.add(_tempVec3A);
                worldState.target = null;
                worldState.interactTarget = null;
                // Face movement direction
                if (_tempVec3A.length() > 0.01) {
                    p.rotation.y = Math.atan2(_tempVec3A.x, _tempVec3A.z);
                }
            }

            // Click-to-move (using pre-allocated vector)
            if(worldState.target) {
                _tempVec3A.subVectors(worldState.target, p.position);
                _tempVec3A.y = 0;
                const dist = _tempVec3A.length();

                if(dist > CONFIG.MOVEMENT_THRESHOLD) {
                    _tempVec3A.normalize();
                    p.position.add(_tempVec3A.multiplyScalar(speed * dt));
                    p.lookAt(worldState.target.x, p.position.y, worldState.target.z);
                } else {
                    worldState.target = null;
                }
            }

            snapToGround(p);

            // v4.0: Cooldown-based interaction (replaces random chance)
            if(worldState.interactTarget) {
                const t = worldState.interactTarget;
                const dist = p.position.distanceTo(t.position);

                if(dist < CONFIG.INTERACTION_RANGE) {
                    worldState.target = null;

                    const now = performance.now();
                    if(now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(t);
                        worldState.lastActionTime = now;
                    }
                } else if (!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // v5.11: Cinematic Camera Follow - player higher in frame
            camera.position.lerp(p.position.clone().add(_camOffset), 0.08);
            camera.lookAt(p.position.clone().add(_camLookOffset)); // Look below/ahead for cinematic view

            // v4.0: Screen shake effect
            updateScreenShake();

            // v4.0: Update particles
            if (particles) particles.update(dt);

            // v4.4: Update environmental particles
            if (envParticles && worldState.player) {
                envParticles.update(dt, worldState.player.position);
            }

            // v4.5: Update dodge movement
            updateDodge(dt);

            // Mob AI with aggro (using CONFIG constants)
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;

                // v4.6: Update status effects
                updateMobStatusEffects(mob, time);

                // Check if mob died from status effect DoT
                if (mob.userData.hp <= 0) {
                    // Handle death - same as combat death but simplified
                    const xpReward = mob.userData.xpReward || 100;
                    addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;
                    worldMobKillCount++;
                    checkBossSpawn();
                    // v4.9: Track creature in codex
                    trackCreatureKill(mob.userData.name?.toLowerCase() || 'unknown');
                    spawnFloater(mob.position, `KILLED! +${xpReward}XP`, '#f00');
                    if (particles) particles.emit(mob.position, 20, ENEMY_TYPES[mob.userData.name]?.color || 0x44ff44);
                    scene.remove(mob);
                    worldState.mobs = worldState.mobs.filter(x => x !== mob);
                    return;
                }

                // v4.6: Handle stun state from parry
                if (mob.userData.stunned) {
                    if (time < mob.userData.stunEnd) {
                        // Still stunned - skip AI behavior, keep yellow glow
                        mob.userData.telegraphing = false;
                        // Update HP bar to face camera
                        if (mob.userData.hpBar) mob.userData.hpBar.lookAt(camera.position);
                        return;
                    } else {
                        // Stun ended
                        mob.userData.stunned = false;
                        // Restore original emissive
                        const originalEmissive = ENEMY_TYPES[mob.userData.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }

                const distToPlayer = mob.position.distanceTo(p.position);

                // Aggro range
                if (distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > CONFIG.MOB_ATTACK_RANGE) {
                    mob.userData.targetPos.copy(p.position);
                    mob.userData.nextMove = time + 500;
                } else if(time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob (using temp vector) - v4.2: Use enemy-specific speed
                // v4.6: Apply status effect speed modifier
                _tempVec3B.subVectors(mob.userData.targetPos, mob.position);
                _tempVec3B.y = 0;
                if(_tempVec3B.length() > 0.1) {
                    _tempVec3B.normalize();
                    const mobSpeed = (mob.userData.speed || 4) * (mob.userData.speedMultiplier || 1);
                    mob.position.add(_tempVec3B.multiplyScalar(mobSpeed * dt));
                }
                snapToGround(mob);

                // v4.5: Attack telegraph system with windup
                const attackRange = mob.userData.attackRange || CONFIG.MOB_ATTACK_RANGE;
                const attackWindup = mob.userData.attackWindup || 600;

                // Start telegraph when in range and ready to attack
                if (distToPlayer < attackRange && time > mob.userData.nextAttack && !mob.userData.telegraphing) {
                    mob.userData.telegraphing = true;
                    mob.userData.telegraphStart = time;
                    mob.userData.telegraphEnd = time + attackWindup;
                    // Show telegraph visual - mob glows red
                    if (mob.material) {
                        mob.userData.originalEmissive = mob.material.emissive.getHex();
                        mob.material.emissive.setHex(0xff0000);
                    }
                    AudioSystem.telegraph();
                }

                // Update telegraph progress
                if (mob.userData.telegraphing) {
                    const telegraphProgress = (time - mob.userData.telegraphStart) / attackWindup;
                    // Pulse effect during windup
                    const pulseScale = 1 + Math.sin(telegraphProgress * Math.PI * 4) * 0.15;
                    mob.scale.setScalar(pulseScale);

                    // Execute attack when windup completes
                    if (time >= mob.userData.telegraphEnd) {
                        mob.userData.telegraphing = false;
                        mob.scale.setScalar(1);
                        // Restore original emissive
                        if (mob.material && mob.userData.originalEmissive !== undefined) {
                            mob.material.emissive.setHex(mob.userData.originalEmissive);
                        }
                        // Only deal damage if still in range
                        if (distToPlayer < attackRange * 1.2) {
                            // v4.6: Apply damage multiplier from status effects
                            const actualDamage = Math.floor(mob.userData.damage * (mob.userData.damageMultiplier || 1));
                            damagePlayer(actualDamage);
                            spawnFloater(p.position, `-${actualDamage} HP`, '#ff4444');

                            // v4.7: Vampiric elite heals on hit
                            if (mob.userData.isElite && mob.userData.eliteData?.lifesteal) {
                                const healAmount = Math.floor(actualDamage * mob.userData.eliteData.lifesteal);
                                mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + healAmount);
                                spawnFloater(mob.position, `ðŸ¦‡ +${healAmount}`, '#ff00ff');
                                // Update health bar
                                if (mob.userData.hpBar) {
                                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                                    mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                                }
                            }
                        }
                        mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                    }
                }

                // v4.7: Elite affix behaviors
                if (mob.userData.isElite && mob.userData.eliteData) {
                    const eliteData = mob.userData.eliteData;

                    // Regenerating: heal over time
                    if (eliteData.regenRate && mob.userData.hp < mob.userData.maxHp) {
                        const regenAmount = mob.userData.maxHp * eliteData.regenRate * dt;
                        mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + regenAmount);
                        // Update health bar
                        if (mob.userData.hpBar) {
                            const hpPercent = mob.userData.hp / mob.userData.maxHp;
                            mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                        }
                    }

                    // Teleporter: blink towards player when in aggro range
                    if (eliteData.canTeleport && distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > 5) {
                        if (!mob.userData.lastTeleport || time - mob.userData.lastTeleport > 4000) {
                            // Teleport towards player
                            const teleportDist = Math.min(10, distToPlayer - 3);
                            const dir = _tempVec3B.subVectors(p.position, mob.position).normalize();
                            mob.position.add(dir.multiplyScalar(teleportDist));
                            mob.userData.lastTeleport = time;
                            spawnFloater(mob.position, 'ðŸŒ€', '#9900ff');
                            if (particles) particles.emit(mob.position, 15, 0x9900ff, { spread: 3, lifetime: 500 });
                        }
                    }

                    // Chilling Aura: slow player when nearby
                    if (eliteData.chillingAura && distToPlayer < 6) {
                        if (!playerState.chilled || time > playerState.chilledEnd) {
                            playerState.chilled = true;
                            playerState.chilledEnd = time + 500;
                            playerState.moveSpeedMult = 0.5;
                        }
                    }

                    // Animate elite aura ring
                    if (mob.userData.auraRing) {
                        mob.userData.auraRing.rotation.z += dt * 2;
                        const auraScale = 1 + Math.sin(time * 0.005) * 0.2;
                        mob.userData.auraRing.scale.set(auraScale, auraScale, 1);
                    }
                }

                // v5.12: Hypnotist special behavior - hypnotize player when in range
                const enemyType = ENEMY_TYPES[mob.userData.name];
                if (enemyType?.isHypnotist && !HYPNOSIS_STATE.active) {
                    const hypnosisRange = enemyType.hypnosisRange || 12;
                    const hypnosisCooldown = enemyType.hypnosisCooldown || 15000;

                    if (distToPlayer < hypnosisRange && distToPlayer > 3) {
                        // Check cooldown
                        if (!mob.userData.lastHypnosis || time - mob.userData.lastHypnosis > hypnosisCooldown) {
                            mob.userData.lastHypnosis = time;

                            // Start hypnosis!
                            const duration = enemyType.hypnosisDuration || 8000;
                            startHypnosis(mob, duration);

                            // Visual effect on hypnotist
                            spawnFloater(mob.position, 'ðŸ‘ï¸ HYPNOSIS', '#ff00ff');
                            if (particles) particles.emit(mob.position, 30, 0xff00ff, { spread: 5, lifetime: 1000 });

                            // Pulsing eye effect on the mob itself
                            mob.material.emissive.setHex(0xff00ff);
                            mob.userData.hypnotizing = true;
                        }
                    }
                }

                // Animate hypnotist while hypnotizing
                if (mob.userData.hypnotizing && HYPNOSIS_STATE.active && HYPNOSIS_STATE.hypnotistMob === mob) {
                    // Pulsing glow
                    const pulse = 0.3 + Math.sin(time * 0.01) * 0.2;
                    mob.material.emissiveIntensity = pulse;

                    // Slowly rotate
                    mob.rotation.y += dt * 0.5;
                } else if (mob.userData.hypnotizing && !HYPNOSIS_STATE.active) {
                    mob.userData.hypnotizing = false;
                    mob.material.emissive.setHex(enemyType?.emissive || 0x660066);
                    mob.material.emissiveIntensity = 0.2;
                }

                // v5.12: Animate hypnotist eye - pupil tracks player
                if (mob.userData.isHypnotist && mob.userData.pupil) {
                    // Make the eye look toward the player
                    const lookDir = _tempVec3A.subVectors(p.position, mob.position).normalize();

                    // Calculate pupil offset based on look direction (limited movement)
                    const maxOffset = 0.2;
                    mob.userData.pupil.position.x = lookDir.x * maxOffset;
                    mob.userData.pupil.position.y = Math.max(-maxOffset, lookDir.y * maxOffset + 0.1);

                    // Make the whole mob face the player
                    mob.lookAt(p.position.x, mob.position.y, p.position.z);

                    // Subtle creepy floating animation
                    mob.position.y += Math.sin(time * 0.003 + mob.id) * 0.002;
                }

                // Update HP bar rotation to face camera
                if (mob.userData.hpBar) {
                    mob.userData.hpBar.lookAt(camera.position);
                }
            });

            // Animate fishing spots
            worldState.fishingSpots.forEach(spot => {
                if (spot.userData.ripple) {
                    const scale = 1 + Math.sin(time * 0.003) * 0.2;
                    spot.userData.ripple.scale.set(scale, scale, 1);
                }
            });

            // Update minimap
            updateMinimap();

            // v4.8: Update ability cooldowns
            updateAbilityUI();

            // v5.0: Update pet companion
            updatePet(dt, time);
            updatePetRegen(time);

            // v5.6: Update Copilot Companion
            updateCopilotCompanion(dt, time);

            // v5.12: Update hypnosis effects
            updateHypnosis(dt);

            // v5.13: Update ship defense system
            updateShipDefense(dt, time);

            // v5.9: Update Copilot task progress
            updateCopilotTask(dt);

            // v5.10: Update Agent Fleet meshes
            updateAgentFleetMeshes(dt);

            // v5.0: Update weather system
            updateWeather(dt, time);

            // v5.4: Update world events
            updateWorldEvent(dt, time);

            // v5.4: Update cosmetic effects
            updateCosmeticEffects(time);
        }

        function snapToGround(obj) {
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;

            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx][gz];
                if(y > -50) {
                    const targetY = y + (obj === worldState.player ? 1.2 : 0.8);
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.15);
                }
            }
        }

        // v4.2: Calculate player damage with weapon bonus and skill levels
        function getPlayerDamage() {
            let baseDamage = 1;

            // v5.1: Get damage from equipped gear
            const equipStats = getEquipmentStats();
            let weaponBonus = equipStats.damage;

            // Fallback: Check inventory for weapons if nothing equipped
            if (weaponBonus === 0) {
                const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade', 'Sword'];
                for (const weapon of weapons) {
                    if (hasItem(weapon)) {
                        weaponBonus = Math.max(weaponBonus, ITEMS[weapon].combatBonus || 0);
                        break;
                    }
                }
            }

            // Skill bonus: +1 damage every 3 combat levels
            const skillBonus = Math.floor(gameData.skills.combat.level / 3);

            let totalDamage = baseDamage + weaponBonus + skillBonus;

            // v5.1: Apply equipment crit chance
            if (equipStats.critChance > 0 && Math.random() < equipStats.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'âš¡ CRIT!', '#ffaa00');
                }
            }

            // v4.6: Apply crit multiplier if in parry crit window
            if (isInCritWindow()) {
                totalDamage = Math.floor(totalDamage * PARRY_CONFIG.CRIT_MULTIPLIER);
            }

            // v4.8: Apply combo multiplier
            const comboMult = getComboMultiplier();
            if (comboMult > 1) {
                totalDamage = Math.floor(totalDamage * comboMult);
            }

            // v4.8: Apply War Cry damage boost
            if (isWarcryActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.warcry.damageBoost);
            }

            // v4.9: Apply Berserker Rage damage boost
            if (isBerserkActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.berserk.damageBoost);
            }

            // v5.0: Apply pet damage bonus
            const petBonuses = getPetBonuses();
            if (petBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.damage));
            }
            if (petBonuses.allStats > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.allStats));
            }

            // v5.2: Apply talent bonuses
            const talentBonuses = getTalentBonuses();
            if (talentBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + talentBonuses.damage));
            }
            // v5.2: Apply talent crit chance
            if (talentBonuses.critChance > 0 && Math.random() < talentBonuses.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸŒŸ TALENT CRIT!', '#ffd700');
                }
            }

            // v5.3: Apply mastery combat bonuses
            const masteryBonuses = getMasteryBonuses();
            if (masteryBonuses.combatDamage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + masteryBonuses.combatDamage));
            }
            if (masteryBonuses.combatCrit > 0 && Math.random() < masteryBonuses.combatCrit) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'âœ¨ MASTERY CRIT!', '#ff44ff');
                }
            }

            // v5.3: Apply rarity item bonuses
            const rarityBonuses = getRarityBonuses();
            if (rarityBonuses.damage > 0) {
                totalDamage += rarityBonuses.damage;
            }
            if (rarityBonuses.critChance > 0 && Math.random() < rarityBonuses.critChance) {
                const critMult = 2 + (rarityBonuses.critDamage || 0);
                totalDamage = Math.floor(totalDamage * critMult);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸ’Ž RARITY CRIT!', '#4488ff');
                }
            }

            // v5.4: Apply evolution damage bonus
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageBonus > 0) {
                totalDamage = Math.floor(totalDamage * (1 + evolutionBonuses.damageBonus));
            }
            // v5.8: Boss damage bonus is now applied in performAction where isBoss is known

            return totalDamage;
        }

        // v4.2: Calculate skill bonus for gathering (multiplier)
        function getSkillBonus(skillName) {
            const level = gameData.skills[skillName]?.level || 1;
            return 1 + Math.floor(level / 5) * 0.25; // +25% every 5 levels
        }

        // v4.2: Calculate player defense from armor
        function getPlayerDefense() {
            let defense = 0;

            // v5.1: Get defense from equipped gear
            const equipStats = getEquipmentStats();
            defense += equipStats.defense;

            // Fallback: Check inventory for armor if nothing equipped
            if (equipStats.defense === 0 && hasItem('Chitin Armor')) {
                defense += ITEMS['Chitin Armor'].defenseBonus;
            }
            if (equipStats.defense === 0 && hasItem('Guardian Armor')) {
                defense += ITEMS['Guardian Armor'].defenseBonus;
            }

            defense += Math.floor(gameData.skills.combat.level / 5); // +1 defense every 5 combat levels

            // v5.2: Apply talent defense bonus
            const talentBonuses = getTalentBonuses();
            defense += talentBonuses.defense || 0;

            // v5.3: Apply rarity item defense bonus
            const rarityBonuses = getRarityBonuses();
            defense += rarityBonuses.defense || 0;

            return defense;
        }

        function performAction(target) {
            const data = target.userData;

            // v5.4: Handle event item collection
            if (data.type === 'eventItem') {
                collectEventItem(target);
                return;
            }

            // v4.2: Handle POI interactions differently
            if (data.type === 'poi') {
                if (!data.discovered) {
                    data.discovered = true;
                    gameData.statistics.poisDiscovered++;

                    // Mark as discovered for this planet
                    if (!gameData.discoveredPOIs[activeCiv.id]) {
                        gameData.discoveredPOIs[activeCiv.id] = [];
                    }
                    gameData.discoveredPOIs[activeCiv.id].push(data.poiType);

                    // Grant rewards
                    data.rewards.forEach(reward => {
                        const count = Array.isArray(reward.count)
                            ? Math.floor(Math.random() * (reward.count[1] - reward.count[0] + 1)) + reward.count[0]
                            : reward.count;
                        for (let i = 0; i < count; i++) {
                            addItem(reward.item);
                        }
                        spawnFloater(target.position, `+${count} ${reward.item}`, '#ffdd00');
                    });

                    // Grant XP bonus
                    addXp('combat', data.xpBonus);

                    spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.icon} ${data.name} DISCOVERED!`, '#ffdd00');
                    AudioSystem.levelUp();
                    if (particles) particles.emit(target.position, 30, 0xffdd00, { spread: 6, lifetime: 1500, size: 0.3 });

                    // Change POI appearance to show it's been discovered
                    if (data.beacon) data.beacon.material.emissiveIntensity = 0.1;
                    if (data.iconMesh) data.iconMesh.material.opacity = 0.3;

                    checkAchievements();
                    updateDailyChallengeProgress();
                    updatePlayerRank();
                } else {
                    spawnFloater(target.position, "Already discovered", '#888888');
                }
                return;
            }

            // v4.2: Calculate damage based on type
            let damage = 1;
            if (data.type === 'mob' || data.type === 'boss') {
                damage = getPlayerDamage();
                // v5.8: Apply evolution boss damage bonus here where isBoss is known
                const isBoss = data.type === 'boss' || data.isBoss;
                if (isBoss) {
                    const evolutionBonuses = getEvolutionBonuses();
                    if (evolutionBonuses.bossDamage > 0) {
                        damage = Math.floor(damage * (1 + evolutionBonuses.bossDamage));
                    }
                }
            }

            // v4.8: Update combo state on combat hit
            const isCombatHit = data.type === 'mob' || data.type === 'boss';
            let comboHit = 0;
            if (isCombatHit) {
                comboHit = updateCombo(performance.now());
            }

            // v4.6: Show crit feedback if in crit window, v4.8: combo feedback
            const isCrit = isInCritWindow() && isCombatHit;
            const isFinisher = comboHit >= COMBO_CONFIG.MAX_HITS - 1;

            let hitText, hitColor;
            if (isFinisher) {
                hitText = `ðŸ’¥ FINISHER x${comboHit + 1}! -${damage}`;
                hitColor = '#ff00ff';
            } else if (isCrit) {
                hitText = `âš”ï¸ CRIT! -${damage}`;
                hitColor = '#ffd700';
            } else if (comboHit > 0) {
                hitText = `x${comboHit + 1} COMBO! -${damage}`;
                hitColor = '#00ffff';
            } else {
                hitText = damage > 1 ? `HIT! -${damage}` : "HIT!";
                hitColor = undefined;
            }

            spawnFloater(target.position, hitText, hitColor);
            AudioSystem.hit();

            data.hp -= damage;
            gameData.statistics.totalDamageDealt += damage;

            // v5.1: Apply lifesteal from equipment
            const equipStats = getEquipmentStats();
            if (equipStats.lifesteal > 0) {
                const healAmount = Math.floor(damage * equipStats.lifesteal);
                if (healAmount > 0) {
                    gameData.player.hp = Math.min(CONFIG.PLAYER_MAX_HP + equipStats.maxHpBonus, gameData.player.hp + healAmount);
                    spawnFloater(worldState.player.position, `ðŸ’š +${healAmount}`, '#44ff44');
                    updateHealthUI();
                }
            }

            // v4.4: Hit-stop and flash for satisfying combat
            const isBossTarget = data.type === 'boss' || data.isBoss;
            const isMobTarget = data.type === 'mob';
            if (isBossTarget) {
                triggerHitStop(HIT_STOP_BOSS);
                flashTargetHit(target, 0xff4400);
            } else if (isMobTarget) {
                triggerHitStop(HIT_STOP_LIGHT);
                flashTargetHit(target, 0xff0000);
            }

            // v4.6: Apply elemental status effect on hit
            if (isMobTarget || isBossTarget) {
                const element = getEquippedElement();
                if (element) {
                    applyStatusEffect(target, element);
                }
            }

            // Visual feedback
            target.scale.setScalar(0.85);
            setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

            // v4.0: Hit particles based on type
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 :
                                     data.type === 'rock' ? 0x888888 :
                                     data.type === 'mob' ? (ENEMY_TYPES[data.name]?.color || 0x44ff44) : 0x4488ff;
                particles.emit(target.position, 5, particleColor, { spread: 2, lifetime: 600, size: 0.15 });
            }

            // Update mob health bar
            if (data.type === 'mob' && data.hpBar) {
                const hpPercent = data.hp / data.maxHp;
                data.hpBar.scale.x = Math.max(0.01, hpPercent);
                data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
            }

            if(data.hp <= 0) {
                if(data.type === 'tree') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('wood');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Log');
                    addXp('wood', 50);
                    gameData.statistics.treesChopped++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} LOG`, '#da5');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 12, 0xdd9955, { spread: 4, lifetime: 1000 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'rock') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('mining');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Ore');
                    addXp('mining', 50);
                    gameData.statistics.oresMined++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} ORE`, '#888');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 15, 0x888888, { spread: 3, lifetime: 800 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob' || data.type === 'boss') {
                    // v4.3: Handle both regular mobs and bosses
                    const isBoss = data.type === 'boss' || data.isBoss;

                    // v4.2/4.3: Drop items from enemy data
                    const drops = data.drops || ['Slime'];
                    // v4.7: Elite enemies drop more items
                    const dropMultiplier = data.isElite ? ELITE_CONFIG.bonusDropMult : 1;

                    drops.forEach(drop => {
                        // Handle boss drop format { item, count }
                        if (typeof drop === 'object') {
                            const count = drop.count * dropMultiplier;
                            for (let i = 0; i < count; i++) addItem(drop.item);
                            spawnFloater(target.position.clone().add(new THREE.Vector3(Math.random(), 1, Math.random())), `+${count} ${drop.item}`, '#ffd700');
                        } else {
                            for (let i = 0; i < dropMultiplier; i++) addItem(drop);
                        }
                    });

                    // v4.7: Elite essence drop
                    if (data.isElite && Math.random() < ELITE_CONFIG.essenceDropChance) {
                        const essenceCount = 1 + Math.floor(Math.random() * 3); // 1-3 essence
                        for (let i = 0; i < essenceCount; i++) addItem('Elite Essence');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1.5, 0)), `+${essenceCount} Elite Essence`, '#aa00ff');
                    }

                    const xpReward = data.xpReward || 100;
                    addXp('combat', xpReward);

                    // v4.7: Handle explosive affix death
                    if (data.isElite && data.eliteData?.explodeOnDeath) {
                        const explosionDamage = Math.floor(data.damage * 2);
                        const explosionRange = 5;
                        const distToPlayer = target.position.distanceTo(p.position);
                        if (distToPlayer < explosionRange) {
                            damagePlayer(explosionDamage, 'explosion');
                            spawnFloater(p.position, `ðŸ’¥ EXPLOSION! -${explosionDamage}`, '#ff6600');
                        }
                        if (particles) particles.emit(target.position, 40, 0xff6600, { spread: 8, lifetime: 1000, size: 0.4 });
                        screenShake(1.2);
                        AudioSystem.explosion && AudioSystem.explosion();
                    }

                    if (isBoss) {
                        gameData.statistics.bossesDefeated++;
                        // v4.9: Track boss in codex
                        trackCreatureKill('boss');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `BOSS DEFEATED! +${xpReward}XP`, '#ffd700');
                        showNotification(`${data.name} has been defeated!`, 'success');
                        // v4.4: Extra long hit-stop for boss kill
                        triggerHitStop(HIT_STOP_BOSS * 2);
                        screenShake(1.5);
                        // Extra celebration
                        if (particles) particles.emit(target.position, 50, 0xffd700, { spread: 8, lifetime: 2000, size: 0.4 });

                        // v5.3: Check portal clear on boss kill (portal realms require boss kills)
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            if (portalMods?.bossOnly) {
                                exitPortal(true);
                            }
                        }

                        // v5.3: Chance for rarity loot on boss kills
                        if (Math.random() < 0.4) {
                            const rareDrop = drops[0]?.item || drops[0] || 'Boss Trophy';
                            const rarityItem = createRarityItem(rareDrop);
                            if (rarityItem.rarity !== 'common') {
                                if (!gameData.rarityItems) gameData.rarityItems = [];
                                gameData.rarityItems.push(rarityItem);
                                showRarityDropPopup(rarityItem);
                            }
                        }
                    } else {
                        gameData.statistics.mobsKilled++;
                        // v4.9: Track creature in codex
                        if (data.isElite) {
                            trackCreatureKill('elite');
                        } else {
                            trackCreatureKill(data.name?.toLowerCase() || 'unknown');
                        }
                        // v5.0: Try to drop a pet
                        tryDropPet(data.name);
                        // v5.4: Gain pet bond from kills
                        gainPetBond(data.isElite ? 3 : 1);
                        // v4.7: Track elite kills
                        if (data.isElite) {
                            gameData.statistics.elitesKilled = (gameData.statistics.elitesKilled || 0) + 1;
                            spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.eliteData.prefix} ELITE SLAIN! +${xpReward}XP`, '#ffaa00');
                            showNotification(`Elite ${data.name} defeated!`, 'success');
                            triggerHitStop(HIT_STOP_BOSS);

                            // v5.3: Chance for rarity loot on elite kills
                            if (Math.random() < 0.2) {
                                const rareDrop = drops[0] || 'Elite Essence';
                                const rarityItem = createRarityItem(rareDrop);
                                if (rarityItem.rarity !== 'common') {
                                    if (!gameData.rarityItems) gameData.rarityItems = [];
                                    gameData.rarityItems.push(rarityItem);
                                    showRarityDropPopup(rarityItem);
                                }
                            }
                        } else {
                            spawnFloater(target.position, `KILLED! +${xpReward}XP`, '#f00');
                            triggerHitStop(HIT_STOP_HEAVY);
                        }
                        worldMobKillCount++; // v4.3: Track for boss spawning
                        checkBossSpawn(); // v4.3: Check if boss should spawn

                        // v5.3: Track portal kills - elites count more
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            // Portals without bossOnly can be cleared by killing enough enemies
                            if (!portalMods?.bossOnly && data.isElite) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 5; // Elite = 5 kills
                                if (gameData.portals.killProgress >= 25) { // Need 25 points (5 elites or 25 mobs)
                                    exitPortal(true);
                                }
                            } else if (!portalMods?.bossOnly) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 1;
                                if (gameData.portals.killProgress >= 25) {
                                    exitPortal(true);
                                }
                            }
                        }
                    }

                    AudioSystem.kill();
                    const mobColor = data.isElite ? (data.eliteData?.color || 0xffaa00) :
                                    isBoss ? (BOSS_TYPES[data.bossId]?.color || 0xffd700) :
                                    (ENEMY_TYPES[data.name]?.color || 0x44ff44);
                    if (particles && !isBoss) particles.emit(target.position, data.isElite ? 30 : 20, mobColor, { spread: data.isElite ? 7 : 5, lifetime: 1200, size: data.isElite ? 0.35 : 0.25 });
                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                else if(data.type === 'fishing') {
                    if (hasItem('Fishing Rod')) {
                        // v4.2: Skill bonus for fishing
                        const skillMultiplier = getSkillBonus('fishing');
                        const fishCount = Math.floor(1 * skillMultiplier);
                        for (let i = 0; i < fishCount; i++) addItem('Raw Fish');
                        addXp('fishing', 40);
                        gameData.statistics.fishCaught += fishCount;
                        gainPetBond(1); // v5.4: Pet bond from fishing
                        spawnFloater(target.position, `+${fishCount} FISH`, '#44f');
                        AudioSystem.collect();
                        if (particles) particles.emit(target.position, 8, 0x4488ff, { spread: 2, lifetime: 800, gravity: 5 });
                    } else {
                        spawnFloater(target.position, "Need Rod!", '#f44');
                        AudioSystem.error();
                    }
                    data.hp = data.maxHp = 1;
                    return;
                }
                worldState.interactTarget = null;

                checkAchievements();
                updateDailyChallengeProgress();
                updatePlayerRank();
            }
        }

        function damagePlayer(amount) {
            // v4.5: Check for dodge i-frames
            if (isInvincible()) {
                spawnFloater(worldState.player.position, 'DODGE!', '#88ffff');
                return;
            }

            // v4.8: Break combo on taking damage
            if (COMBO_CONFIG.BREAK_ON_DAMAGE && comboState.active) {
                breakCombo();
            }

            // v4.9: Apply Shield Wall damage reduction
            let reducedAmount = amount;
            if (isShieldWallActive()) {
                reducedAmount = Math.floor(amount * (1 - COMBAT_ABILITIES.shieldWall.damageReduction));
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `ðŸ›¡ï¸ BLOCKED!`, '#4488ff');
                }
            }

            // v5.4: Apply evolution damage reduction and phase shift
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageReduction > 0) {
                reducedAmount = Math.floor(reducedAmount * (1 - evolutionBonuses.damageReduction));
            }
            if (evolutionBonuses.phaseShift > 0 && Math.random() < evolutionBonuses.phaseShift) {
                reducedAmount = Math.floor(reducedAmount * 0.5);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸŒ€ PHASED!', '#4400ff');
                }
            }

            // v4.2: Apply defense reduction
            const defense = getPlayerDefense();
            const actualDamage = Math.max(1, reducedAmount - defense);
            gameData.player.hp = Math.max(0, gameData.player.hp - actualDamage);
            updateHealthUI();

            // v4.0: Enhanced damage feedback
            AudioSystem.damage();
            screenShake(amount * 0.1);
            flashDamageOverlay();

            if (gameData.player.hp <= 0) {
                playerDeath();
            }
        }

        function healPlayer(amount) {
            gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
            updateHealthUI();
            spawnFloater(worldState.player.position, `+${amount} HP`, '#44ff44');
            AudioSystem.heal(); // v4.0
        }

        function playerDeath() {
            showNotification('You died! Respawning...', 'error');
            gameData.player.hp = gameData.player.maxHp;
            worldState.player.position.set(0, 10, 0);
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();
        }

        function spawnFloater(pos, text, color='#fff') {
            // Use pool
            let floater = floaterPool.find(f => !f.active);
            if (!floater) {
                floater = floaterPool[0]; // Reuse oldest
            }

            floater.active = true;
            floater.el.textContent = text;
            floater.el.style.color = color;
            floater.el.style.display = 'block';
            floater.el.style.animation = 'none';
            floater.el.offsetHeight; // Trigger reflow
            floater.el.style.animation = 'floatUp 1.5s forwards';

            const v = pos.clone();
            v.y += 2;
            v.project(camera);

            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;

            floater.el.style.left = x + 'px';
            floater.el.style.top = y + 'px';

            setTimeout(() => {
                floater.el.style.display = 'none';
                floater.active = false;
            }, 1400);
        }

        // --- INPUT HANDLERS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong>${civ.name}</strong><br>Biome: ${civ.biomeName}<br>Pop: ${civ.pop}M${civ.visited ? '<br><span style="color:#0f0">Visited</span>' : ''}<br><span style="color:#888">ðŸš€ Click to Begin Landing Sequence</span>`;
                        document.body.style.cursor = 'pointer';

                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
            } else if (mode === 'world') {
                // v5.6: Check for Copilot Companion hover
                if (copilotMesh) {
                    const copilotHits = raycaster.intersectObject(copilotMesh, true);
                    if (copilotHits.length > 0) {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) {
                            copilotTooltip.style.display = 'block';
                            copilotTooltip.style.left = e.clientX + 15 + 'px';
                            copilotTooltip.style.top = e.clientY - 30 + 'px';
                        }
                        document.body.style.cursor = 'pointer';
                        return;
                    } else {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) copilotTooltip.style.display = 'none';
                    }
                }

                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        const hpText = obj.userData.hp !== undefined ? `<br>HP: ${obj.userData.hp}/${obj.userData.maxHp}` : '';
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong>${hpText}<br><span style="color:#888">Click to Interact</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy') selectionRing.visible = false;
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            // v5.6: Check for Copilot Companion click first
            if (checkCopilotClick(e)) {
                return; // Copilot was clicked, don't process other clicks
            }

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        // v5.5: Landing mini-game before entering world
                        startLandingGame(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    spawnFloater(obj.position, "Targeting...", '#0ff');
                    return;
                }

                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null;

                    const m = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                    );
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(() => scene.remove(m), 400);
                }
            }
        }

        // Touch handlers
        let touchStartPos = null;

        // v4.3: Virtual Joystick state
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        const joystickMaxDist = 40;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            if (touchStartPos) {
                raycaster.setFromCamera(mouse, camera);
                onMouseDown({ clientX: touchStartPos.x, clientY: touchStartPos.y });
                touchStartPos = null;
            }
        }

        function onTouchAction() {
            // Quick action button - interact with nearest target
            if (mode === 'world' && worldState.interactTarget) {
                performAction(worldState.interactTarget);
            }
        }

        function onKeyDown(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v5.9: Voice hotkeys
            // V key: Open Copilot chat and start voice listening
            if (e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                if (!copilotChatOpen) {
                    toggleCopilotChat();
                }
                // Small delay to ensure chat is open before starting voice
                setTimeout(() => {
                    if (!copilotIsListening) {
                        toggleCopilotVoice();
                    }
                }, 100);
                return;
            }

            // Spacebar: If Copilot chat is open, trigger voice instead of dodge
            if (e.key === ' ') {
                if (copilotChatOpen) {
                    e.preventDefault();
                    if (!copilotIsListening) {
                        toggleCopilotVoice();
                    } else {
                        // If already listening, stop (toggle behavior)
                        stopCopilotVoice();
                    }
                    return;
                }
            }

            // Escape: Close Copilot chat if open
            if (e.key === 'Escape' && copilotChatOpen) {
                toggleCopilotChat();
                e.preventDefault();
                return;
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyDown(e);
                return;
            }

            // WASD movement
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                e.preventDefault();
            }

            // Number keys 1-9 to use inventory items
            if (mode === 'world' && e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                useInventoryItem(idx);
            }
            // E to eat food
            if (e.key === 'e' || e.key === 'E') {
                const foodIdx = gameData.inventory.findIndex(item =>
                    item && (item.name === 'Cooked Fish' || item.name === 'Health Potion')
                );
                if (foodIdx >= 0) useInventoryItem(foodIdx);
            }
            // H for help/tutorial
            if (e.key === 'h' || e.key === 'H') {
                showTutorial();
            }
            // v5.5: M to toggle autopilot exploration
            if ((e.key === 'm' || e.key === 'M') && mode === 'world') {
                toggleAutoExplore();
            }
            // v4.5: Space or Shift to dodge (space only if chat not open)
            // v5.12: Space also breaks hypnosis
            if (e.key === ' ' || e.key === 'Shift') {
                if (mode === 'world' && !copilotChatOpen) {
                    // Check if hypnotized - SPACE breaks hypnosis
                    if (HYPNOSIS_STATE.active && e.key === ' ') {
                        attemptBreakHypnosis();
                        e.preventDefault();
                        return;
                    }
                    startDodge();
                    e.preventDefault();
                }
            }
            // v4.8: Combat abilities Q/E/R (v4.9: Extended with Tier 2 T/F/Z/X/C)
            if (mode === 'world') {
                if (e.key === 'q' || e.key === 'Q') {
                    useAbility('powerStrike');
                    e.preventDefault();
                }
                if (e.key === 'e' || e.key === 'E') {
                    // E is now abilities, but keep food eating as fallback if no ability ready
                    if (!useAbility('whirlwind')) {
                        const foodIdx = gameData.inventory.findIndex(item =>
                            item && (item.name === 'Cooked Fish' || item.name === 'Health Potion' || item.name === 'Super Potion')
                        );
                        if (foodIdx >= 0) useInventoryItem(foodIdx);
                    }
                    e.preventDefault();
                }
                if (e.key === 'r' || e.key === 'R') {
                    useAbility('warcry');
                    e.preventDefault();
                }
                // v4.9: Tier 2 Abilities
                if (e.key === 't' || e.key === 'T') {
                    useAbility('heal');
                    e.preventDefault();
                }
                if (e.key === 'f' || e.key === 'F') {
                    useAbility('dash');
                    e.preventDefault();
                }
                if (e.key === 'z' || e.key === 'Z') {
                    useAbility('shieldWall');
                    e.preventDefault();
                }
                if (e.key === 'x' || e.key === 'X') {
                    useAbility('execute');
                    e.preventDefault();
                }
                if (e.key === 'c' || e.key === 'C') {
                    useAbility('berserk');
                    e.preventDefault();
                }
            }
        }

        function onKeyUp(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyUp(e);
                return;
            }

            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            saveGameData();
            initGalaxy();
            activeCiv = null;
        }

        // --- INVENTORY & RPG ---
        function addItem(name) {
            const itemDef = ITEMS[name];
            if (!itemDef) return false;

            // v4.9: Track item in codex
            trackItemDiscovery(name);

            // Find existing stack
            if (itemDef.stackable) {
                const existing = gameData.inventory.find(item =>
                    item && item.name === name && item.count < (itemDef.maxStack || 99)
                );
                if (existing) {
                    existing.count++;
                    updateInventoryUI();
                    return true;
                }
            }

            // Add new slot
            if (gameData.inventory.length < 20) {
                gameData.inventory.push({ name, count: 1 });
                updateInventoryUI();
                return true;
            }

            spawnFloater(worldState.player.position, "Inventory full!", '#f44');
            return false;
        }

        function removeItem(name, count = 1) {
            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (item && item.name === name) {
                    item.count -= count;
                    if (item.count <= 0) {
                        gameData.inventory.splice(i, 1);
                    }
                    updateInventoryUI();
                    return true;
                }
            }
            return false;
        }

        function hasItem(name, count = 1) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item && item.count >= count;
        }

        function countItem(name) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item ? item.count : 0;
        }

        function useInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const def = ITEMS[item.name];

            // v5.1: Check if item is equippable
            if (isEquippable(item.name)) {
                equipItem(item.name);
                updateInventoryUI();
                return;
            }

            // Use consumables
            if (def && def.heal) {
                if (gameData.player.hp < gameData.player.maxHp) {
                    healPlayer(def.heal);
                    removeItem(item.name, 1);
                } else {
                    showNotification('Health is already full!');
                }
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            gameData.inventory.forEach((item, idx) => {
                if (!item) return;
                const def = ITEMS[item.name] || { icon: '?' };
                const slot = document.createElement('div');
                slot.className = 'inv-slot';

                // v4.8: Build detailed tooltip
                const tooltip = buildItemTooltip(item.name, def, item.count);
                slot.title = tooltip;

                slot.innerHTML = `${def.icon}<div class="inv-count">${item.count}</div>`;
                slot.onclick = () => useInventoryItem(idx);
                grid.appendChild(slot);
            });

            // Fill empty slots
            for (let i = gameData.inventory.length; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }

            document.getElementById('inv-count').textContent = gameData.inventory.length;
        }

        // v4.8: Build detailed item tooltip
        function buildItemTooltip(name, def, count) {
            let lines = [name];

            // Add quantity for stackable items
            if (def.stackable && count > 1) {
                lines[0] += ` (x${count})`;
            }

            // Healing items
            if (def.heal) {
                lines.push(`Heals ${def.heal} HP`);
                lines.push('Click or press E to use');
            }

            // Combat bonuses
            if (def.combatBonus) {
                lines.push(`Combat: +${def.combatBonus} damage`);
            }

            // Defense
            if (def.defenseBonus) {
                lines.push(`Defense: +${def.defenseBonus}`);
            }

            // Mining/Tool bonuses
            if (def.miningBonus) {
                lines.push(`Mining: x${def.miningBonus} yield`);
            }
            if (def.fishingBonus) {
                lines.push(`Fishing: x${def.fishingBonus} yield`);
            }

            // Elemental
            if (def.element) {
                const elementNames = { ice: 'Ice (Slow)', fire: 'Fire (Burn)', void: 'Void (Weaken)', cosmic: 'Cosmic (All)' };
                lines.push(`Element: ${elementNames[def.element] || def.element}`);
            }

            // Lifesteal
            if (def.lifesteal) {
                lines.push(`Lifesteal: ${Math.floor(def.lifesteal * 100)}%`);
            }

            // Attack speed
            if (def.attackSpeedMult) {
                lines.push(`Attack Speed: +${Math.floor((def.attackSpeedMult - 1) * 100)}%`);
            }

            // Max stack info for materials
            if (def.stackable && def.maxStack) {
                lines.push(`Max Stack: ${def.maxStack}`);
            }

            return lines.join('\\n');
        }

        function addXp(skill, amt) {
            if (!gameData.skills[skill]) return;

            // v4.4: Apply prestige XP multiplier
            let multiplier = gameData.prestige?.bonuses?.xpMultiplier || 1.0;

            // v5.3: Apply portal XP multiplier
            multiplier *= getPortalXpMultiplier();

            // v5.3: Apply mastery XP bonus
            const masteryBonuses = getMasteryBonuses();
            // v5.3: Apply talent XP bonus
            const talentBonuses = getTalentBonuses();
            multiplier *= (1 + (talentBonuses.xpBonus || 0));

            // v5.3: Apply rarity item XP bonus
            const rarityBonuses = getRarityBonuses();
            multiplier *= (1 + (rarityBonuses.xpBonus || 0));

            // v5.4: Apply showcase milestone XP bonus
            const showcaseBonuses = getShowcaseBonuses();
            multiplier *= (1 + (showcaseBonuses.xpBonus || 0) + (showcaseBonuses.allBonus || 0));

            // v5.4: Apply world event XP bonus
            const eventBonuses = getWorldEventBonuses();
            multiplier *= (eventBonuses.xpMultiplier || 1);

            // v5.4: Apply evolution XP bonus
            const evolutionBonuses = getEvolutionBonuses();
            multiplier *= (1 + (evolutionBonuses.xpBonus || 0));

            const adjustedAmt = Math.round(amt * multiplier);

            const oldLevel = gameData.skills[skill].level;
            gameData.skills[skill].xp += adjustedAmt;

            // Check level up
            const newLevel = Math.floor(Math.sqrt(gameData.skills[skill].xp / 100)) + 1;
            gameData.skills[skill].level = newLevel;

            if (newLevel > oldLevel) {
                showNotification(`${skill.charAt(0).toUpperCase() + skill.slice(1)} leveled up to ${newLevel}!`);
                AudioSystem.levelUp(); // v4.0
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `LEVEL UP!`, '#ffff00');
                    // v4.0: Level up particle burst
                    if (particles) particles.emit(worldState.player.position, 25, 0xffff00, { spread: 6, lifetime: 1500, gravity: 3 });
                }
            }

            updateSkillsUI();
        }

        function updateSkillsUI() {
            const skills = ['mining', 'wood', 'combat', 'fishing', 'cooking', 'crafting'];

            skills.forEach(skill => {
                const data = gameData.skills[skill];
                if (!data) return;

                const level = data.level;
                const xp = data.xp;
                const nextLevelXp = Math.pow(level, 2) * 100;
                const prevLevelXp = Math.pow(level - 1, 2) * 100;
                const progress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

                const lvlEl = document.getElementById(`lvl-${skill}`);
                const barEl = document.getElementById(`bar-${skill}`);

                if (lvlEl) lvlEl.textContent = level;
                if (barEl) barEl.style.width = Math.min(100, progress) + '%';
            });

            // v5.2: Update talent points button
            const talentBtn = document.getElementById('talent-points-btn');
            if (talentBtn) {
                const points = getTalentPoints();
                talentBtn.textContent = points.available;
                talentBtn.parentElement.style.borderColor = points.available > 0 ? '#ff0' : '#ffd700';
                talentBtn.parentElement.style.animation = points.available > 0 ? 'ability-ready-pulse 2s infinite' : 'none';
            }
        }

        function updateHealthUI() {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const percent = (hp / maxHp) * 100;

            document.getElementById('player-health-fill').style.width = percent + '%';
            document.getElementById('health-text').textContent = `${Math.round(hp)} / ${maxHp}`;
        }

        // v4.8: Update ability UI cooldowns and states (v4.9: Extended with Tier 2)
        function updateAbilityUI() {
            const abilities = [
                // Tier 1
                { key: 'q', id: 'powerStrike', slot: 'ability-q', cooldown: 'cooldown-q' },
                { key: 'e', id: 'whirlwind', slot: 'ability-e', cooldown: 'cooldown-e' },
                { key: 'r', id: 'warcry', slot: 'ability-r', cooldown: 'cooldown-r' },
                // v4.9: Tier 2
                { key: 't', id: 'heal', slot: 'ability-t', cooldown: 'cooldown-t' },
                { key: 'f', id: 'dash', slot: 'ability-f', cooldown: 'cooldown-f' },
                { key: 'z', id: 'shieldWall', slot: 'ability-z', cooldown: 'cooldown-z' },
                { key: 'x', id: 'execute', slot: 'ability-x', cooldown: 'cooldown-x' },
                { key: 'c', id: 'berserk', slot: 'ability-c', cooldown: 'cooldown-c' }
            ];

            abilities.forEach(({ key, id, slot, cooldown }) => {
                const slotEl = document.getElementById(slot);
                const cdEl = document.getElementById(cooldown);
                const ability = COMBAT_ABILITIES[id];

                if (!slotEl || !cdEl) return;

                // Check if unlocked
                const unlocked = isAbilityUnlocked(id);
                slotEl.classList.toggle('locked', !unlocked);

                // Check cooldown
                const cdRemaining = getAbilityCooldownRemaining(id);
                const onCooldown = cdRemaining > 0;
                slotEl.classList.toggle('on-cooldown', onCooldown);

                // Show cooldown overlay
                if (onCooldown) {
                    const cdPercent = (cdRemaining / ability.cooldown) * 100;
                    cdEl.style.height = cdPercent + '%';
                } else {
                    cdEl.style.height = '0%';
                }

                // Special: Buff active states
                if (id === 'warcry' && isWarcryActive()) {
                    slotEl.classList.add('active-buff');
                } else if (id === 'warcry') {
                    slotEl.classList.remove('active-buff');
                }
                // v4.9: Shield Wall active state
                if (id === 'shieldWall' && isShieldWallActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#4488ff';
                    slotEl.style.boxShadow = '0 0 10px #4488ff';
                } else if (id === 'shieldWall') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
                // v4.9: Berserk active state
                if (id === 'berserk' && isBerserkActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#ff4400';
                    slotEl.style.boxShadow = '0 0 15px #ff4400';
                } else if (id === 'berserk') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
            });

            // v4.9: Update buff overlays
            const berserkOverlay = document.getElementById('berserk-overlay');
            const shieldOverlay = document.getElementById('shield-overlay');
            if (berserkOverlay) {
                berserkOverlay.style.opacity = isBerserkActive() ? '1' : '0';
            }
            if (shieldOverlay) {
                shieldOverlay.style.opacity = isShieldWallActive() ? '1' : '0';
            }
        }

        function updatePlaytimeDisplay() {
            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('total-playtime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
        }

        // --- CRAFTING ---
        function craft(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            // v4.2: Check crafting level requirement
            if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                showNotification(`Requires Crafting level ${recipe.craftingLevel}!`, 'error');
                AudioSystem.error();
                return;
            }

            // Check requirements
            for (const [item, count] of Object.entries(recipe.requires)) {
                if (!hasItem(item, count)) {
                    showNotification(`Need ${count}x ${item}!`, 'error');
                    AudioSystem.error(); // v4.0
                    return;
                }
            }

            // Consume materials
            for (const [item, count] of Object.entries(recipe.requires)) {
                removeItem(item, count);
            }

            // Add result
            addItem(recipe.result);
            addXp('crafting', 30);
            if (recipeId === 'cookedFish') {
                addXp('cooking', 25);
                gameData.statistics.fishCooked = (gameData.statistics.fishCooked || 0) + 1;
            }
            gameData.statistics.itemsCrafted++;

            // v4.1: Check achievements and daily progress
            checkAchievements();
            updateDailyChallengeProgress();

            showNotification(`Crafted ${recipe.result}!`);
            AudioSystem.craft(); // v4.0
            updateCraftingUI();
        }

        // v4.2: Enhanced crafting UI with level requirements and new recipes
        function updateCraftingUI() {
            const recipeDisplayNames = {
                'pickaxe': 'Pickaxe',
                'sword': 'Sword',
                'rod': 'Fishing Rod',
                'cookedFish': 'Cooked Fish',
                'potion': 'Health Potion',
                'frostBlade': 'Frost Blade',
                'magmaSword': 'Magma Sword',
                'voidDagger': 'Void Dagger',
                'crystalPickaxe': 'Crystal Pickaxe',
                'superPotion': 'Super Potion',
                'chitinArmor': 'Chitin Armor'
            };

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const btn = document.getElementById(`craft-${id}`);
                if (!btn) continue;

                let canCraft = true;
                let reqParts = [];

                // v4.2: Check level requirement
                if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                    canCraft = false;
                    reqParts.push(`Lvl ${recipe.craftingLevel} req`);
                }

                for (const [item, count] of Object.entries(recipe.requires)) {
                    const have = countItem(item);
                    if (have < count) canCraft = false;
                    reqParts.push(`${have}/${count} ${item}`);
                }
                btn.disabled = !canCraft;
                btn.innerHTML = `${recipeDisplayNames[id] || recipe.result}<br><small style="opacity:0.7">${reqParts.join(', ')}</small>`;
            }
        }

        // --- MINIMAP ---
        let minimapCtx;

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 100;
            canvas.height = 100;
            minimapCtx = canvas.getContext('2d');
        }

        // v4.4: Update fog of war exploration
        function updateExploration() {
            if (!worldState.player || !activeCiv) return;

            const planetId = activeCiv.id;
            if (!gameData.exploredTiles[planetId]) {
                gameData.exploredTiles[planetId] = {};
            }

            // Mark tiles within vision radius as explored
            const px = Math.floor(worldState.player.position.x / 10);
            const pz = Math.floor(worldState.player.position.z / 10);
            const visionRadius = 3;

            for (let dx = -visionRadius; dx <= visionRadius; dx++) {
                for (let dz = -visionRadius; dz <= visionRadius; dz++) {
                    if (dx * dx + dz * dz <= visionRadius * visionRadius) {
                        const key = `${px + dx},${pz + dz}`;
                        gameData.exploredTiles[planetId][key] = 1;
                    }
                }
            }
        }

        function isTileExplored(planetId, worldX, worldZ) {
            const tx = Math.floor(worldX / 10);
            const tz = Math.floor(worldZ / 10);
            const key = `${tx},${tz}`;
            return gameData.exploredTiles[planetId]?.[key] === 1;
        }

        function updateMinimap() {
            if (!minimapCtx || !worldState.player) return;

            // v4.4: Update exploration tracking
            updateExploration();

            const ctx = minimapCtx;
            const size = 100;
            const scale = size / (CONFIG.WORLD_SIZE * 2);
            const planetId = activeCiv?.id;

            // Clear with fog of war (darker)
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, size, size);

            // v4.4: Draw explored areas lighter
            if (planetId && gameData.exploredTiles[planetId]) {
                ctx.fillStyle = '#181818';
                for (const key in gameData.exploredTiles[planetId]) {
                    const [tx, tz] = key.split(',').map(Number);
                    const x = (tx * 10 + CONFIG.WORLD_SIZE) * scale;
                    const y = (tz * 10 + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 5 * scale, y - 5 * scale, 10 * scale, 10 * scale);
                }
            }

            // Draw terrain bounds
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0, 0, size, size);

            // Draw interactables (only in explored areas)
            ctx.fillStyle = '#0a0';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'tree') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            ctx.fillStyle = '#888';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'rock') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            // Draw mobs
            ctx.fillStyle = '#f00';
            worldState.mobs.forEach(mob => {
                const x = (mob.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (mob.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // v4.2: Draw POIs
            worldState.pois.forEach(poi => {
                const x = (poi.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (poi.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.fillStyle = poi.userData.discovered ? '#666' : '#ffd700';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                if (!poi.userData.discovered) {
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // v5.13: Draw ship and landing zone
            if (SHIP_STATE.mesh) {
                const shipX = (SHIP_STATE.mesh.position.x + CONFIG.WORLD_SIZE) * scale;
                const shipY = (SHIP_STATE.mesh.position.z + CONFIG.WORLD_SIZE) * scale;

                // Landing zone circle
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(shipX, shipY, 6, 0, Math.PI * 2);
                ctx.stroke();

                // Ship icon
                ctx.fillStyle = SHIP_STATE.hp > 0 ? '#00ffff' : '#444';
                ctx.beginPath();
                ctx.moveTo(shipX, shipY - 4);
                ctx.lineTo(shipX + 3, shipY + 3);
                ctx.lineTo(shipX - 3, shipY + 3);
                ctx.closePath();
                ctx.fill();

                // Defense range indicator (subtle)
                if (SHIP_STATE.laser.autoDefend) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(shipX, shipY, SHIP_STATE.laser.range * scale, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw player
            ctx.fillStyle = '#ff0';
            const px = (worldState.player.position.x + CONFIG.WORLD_SIZE) * scale;
            const py = (worldState.player.position.z + CONFIG.WORLD_SIZE) * scale;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start
        init();
    </script>
</body>
</html>
