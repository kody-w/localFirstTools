<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LEVIATHAN">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        /* System fonts - local-first compliant, no external dependencies */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        /* ============================================
         * v7.0: UNIFIED DESIGN TOKEN SYSTEM
         * 10-point UI polish overhaul
         * ============================================ */
        :root {
            /* === iOS Safe Areas === */
            --app-height: 100vh;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);

            /* === Z-INDEX LAYERING SYSTEM ===
             * Named constants prevent overlap bugs forever
             * Layer tiers: base(1-9) < ui(100-900) < panels(1000-1999) < overlays(2000-8999) < modals(9000-9999) < critical(10000+)
             */
            --z-base: 1;
            --z-base-elevated: 5;
            --z-base-top: 10;

            --z-ui-back: 100;
            --z-ui-mid: 150;
            --z-ui-front: 200;
            --z-ui-controls: 250;
            --z-ui-floating: 300;
            --z-ui-dropdown: 400;
            --z-ui-sticky: 500;

            --z-panel-base: 1000;
            --z-panel-rts: 1003;
            --z-panel-overlay: 1500;

            --z-overlay-dim: 2000;
            --z-overlay-content: 2500;

            --z-toast: 5000;

            --z-modal-backdrop: 9000;
            --z-modal-content: 9500;
            --z-modal-close: 9600;

            --z-critical: 10000;
            --z-cinematic: 10001;
            --z-galaxy-modal: 25000;
            --z-qr-overlay: 26000;

            /* === SPACING SYSTEM (4px grid) === */
            --space-0: 0;
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;
            --space-12: 48px;

            /* === TYPOGRAPHY SCALE === */
            --font-xs: 10px;
            --font-sm: 12px;
            --font-base: 14px;
            --font-md: 16px;
            --font-lg: 18px;
            --font-xl: 24px;
            --font-2xl: 32px;
            --font-3xl: 48px;

            /* === COLOR PALETTE === */
            --color-bg-dark: rgba(10, 15, 20, 0.95);
            --color-bg-panel: rgba(15, 20, 30, 0.95);
            --color-bg-hover: rgba(30, 35, 40, 0.95);
            --color-bg-active: rgba(0, 60, 80, 0.5);

            --color-border-dim: #334;
            --color-border-default: #445;
            --color-border-hover: #fb0;
            --color-border-active: #0ff;
            --color-border-focus: #4af;

            --color-text-primary: #fff;
            --color-text-secondary: #aaa;
            --color-text-muted: #666;
            --color-text-accent: #fb0;

            --color-accent-gold: #fb0;
            --color-accent-cyan: #0ff;
            --color-accent-purple: #bf00ff;
            --color-accent-blue: #4488ff;
            --color-accent-green: #00ff88;
            --color-accent-red: #ff4444;
            --color-accent-orange: #ff8800;

            /* === TOUCH TARGET SIZES === */
            --touch-min: 44px;
            --touch-comfortable: 48px;
            --touch-spacious: 56px;

            /* === BORDER RADIUS === */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 10px;
            --radius-xl: 15px;
            --radius-full: 9999px;

            /* === TRANSITIONS === */
            --transition-fast: 0.1s ease;
            --transition-base: 0.15s ease;
            --transition-smooth: 0.25s ease;
            --transition-slow: 0.4s ease;
            --transition-panel: 0.3s cubic-bezier(0.4, 0, 0.2, 1);

            /* === SHADOWS === */
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            --shadow-lg: 0 10px 40px rgba(0,0,0,0.5);
            --shadow-glow-cyan: 0 0 10px rgba(0,255,255,0.3);
            --shadow-glow-gold: 0 0 10px rgba(255,187,0,0.3);
        }

        /* === UNIFIED BUTTON SYSTEM === */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: var(--touch-min);
            min-height: var(--touch-min);
            padding: var(--space-2) var(--space-4);
            background: var(--color-bg-dark);
            border: 2px solid var(--color-border-default);
            border-radius: var(--radius-md);
            color: var(--color-text-accent);
            font-size: var(--font-base);
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-base);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .btn:hover {
            border-color: var(--color-border-hover);
            background: var(--color-bg-hover);
            transform: translateY(-1px);
        }
        .btn:active {
            transform: scale(0.95) translateY(0);
            background: var(--color-bg-active);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .btn:focus-visible {
            outline: 2px solid var(--color-border-focus);
            outline-offset: 2px;
        }
        .btn.active {
            border-color: var(--color-border-active);
            background: var(--color-bg-active);
            box-shadow: var(--shadow-glow-cyan);
        }

        /* Button variants */
        .btn--sm {
            min-width: 36px;
            min-height: 36px;
            padding: var(--space-1) var(--space-2);
            font-size: var(--font-sm);
        }
        .btn--lg {
            min-width: var(--touch-comfortable);
            min-height: var(--touch-comfortable);
            padding: var(--space-3) var(--space-6);
            font-size: var(--font-md);
        }
        .btn--icon {
            width: var(--touch-min);
            height: var(--touch-min);
            padding: 0;
            font-size: var(--font-md);
        }
        .btn--ghost {
            background: transparent;
            border-color: transparent;
        }
        .btn--ghost:hover {
            background: var(--color-bg-hover);
            border-color: var(--color-border-dim);
        }
        .btn--primary {
            background: linear-gradient(135deg, var(--color-accent-cyan), var(--color-accent-blue));
            border-color: var(--color-accent-cyan);
            color: #000;
        }
        .btn--danger {
            border-color: var(--color-accent-red);
            color: var(--color-accent-red);
        }
        .btn--danger:hover {
            background: rgba(255, 68, 68, 0.2);
            border-color: #ff6666;
        }

        /* === KEYBOARD SHORTCUT BADGES === */
        .kbd-hint {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: var(--font-xs);
            color: var(--color-text-muted);
            background: rgba(0,0,0,0.5);
            padding: 1px 3px;
            border-radius: 2px;
            font-family: monospace;
            pointer-events: none;
        }

        /* === PANEL TRANSITIONS === */
        .panel-animate {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity var(--transition-panel), transform var(--transition-panel);
        }
        .panel-animate.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .panel-animate.slide-left {
            transform: translateX(-20px);
        }
        .panel-animate.slide-left.visible {
            transform: translateX(0);
        }
        .panel-animate.slide-right {
            transform: translateX(20px);
        }
        .panel-animate.slide-right.visible {
            transform: translateX(0);
        }
        .panel-animate.scale {
            transform: scale(0.95);
        }
        .panel-animate.scale.visible {
            transform: scale(1);
        }

        /* === FOCUS INDICATORS (Accessibility) === */
        *:focus-visible {
            outline: 2px solid var(--color-border-focus);
            outline-offset: 2px;
        }
        button:focus:not(:focus-visible),
        [role="button"]:focus:not(:focus-visible) {
            outline: none;
        }

        /* === MICRO-ANIMATIONS === */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* === LOADING SKELETON === */
        .skeleton {
            background: linear-gradient(90deg,
                var(--color-bg-panel) 25%,
                rgba(255,255,255,0.1) 50%,
                var(--color-bg-panel) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: var(--radius-sm);
        }

        @supports (height: 100dvh) {
            :root { --app-height: 100dvh; }
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }

        /* iOS Zoom Prevention - 16px minimum for all text inputs (8-strategy consensus) */
        input[type="text"],
        input[type="password"],
        input[type="email"],
        input[type="number"],
        input[type="search"],
        input[type="tel"],
        input[type="url"],
        textarea,
        select {
            font-size: 16px !important;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY - v7.0: Using design tokens */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: var(--z-ui-front);
        }

        /* GALAXY HUD - v7.0: Using design tokens */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: var(--space-4) var(--space-5);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: var(--space-3);
            z-index: var(--z-ui-controls);
        }

        .game-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vw, 32px);
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
            font-weight: bold;
            transition: opacity 0.5s ease; /* v6.19: Smooth transition for 3D title swap */
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2vw, 12px);
            transition: opacity 0.5s ease; /* v6.19: Smooth transition for 3D title swap */
        }

        .stats-box {
            display: flex;
            gap: 15px;
            text-align: right;
            flex-wrap: wrap;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: clamp(14px, 3vw, 20px); color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: clamp(8px, 1.5vw, 10px); color: #666; text-transform: uppercase; }

        /* v6.86: New Galaxy Discovery Button */
        .discover-galaxy-btn {
            display: none;
            background: linear-gradient(135deg, #9400d3, #4b0082, #0000cd);
            border: 2px solid #bf00ff;
            color: #fff;
            padding: 8px 14px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 20px;
            font-family: inherit;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: galaxyPulse 2s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5);
        }
        .discover-galaxy-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(191, 0, 255, 0.8);
        }
        .discover-galaxy-btn.visible { display: inline-flex; align-items: center; gap: 6px; }
        @keyframes galaxyPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(191, 0, 255, 0.5); }
            50% { box-shadow: 0 0 35px rgba(191, 0, 255, 0.9); }
        }

        /* v6.86: New Galaxy Discovery Modal */
        .galaxy-discovery-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(ellipse at center, rgba(20,0,50,0.98) 0%, rgba(0,0,0,0.99) 100%);
            z-index: 20000;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .galaxy-discovery-modal.active { display: flex; }
        .galaxy-warp-effect {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 30%, rgba(100,0,200,0.1) 50%, rgba(0,0,100,0.2) 100%);
            animation: warpTunnel 3s ease-in-out;
        }
        @keyframes warpTunnel {
            0% { transform: scale(0.1); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0.5; }
        }
        .galaxy-discovery-content {
            position: relative;
            text-align: center;
            z-index: 1;
            max-width: 500px;
            padding: 40px;
        }
        .galaxy-discovery-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(135deg, #bf00ff, #00d4ff, #bf00ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            animation: titleShimmer 3s ease-in-out infinite;
        }
        @keyframes titleShimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        .galaxy-discovery-subtitle {
            font-size: 18px;
            color: #888;
            margin-bottom: 30px;
        }
        .galaxy-stats-preview {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
        }
        .galaxy-stat-item {
            text-align: center;
        }
        .galaxy-stat-value {
            font-size: 36px;
            color: #bf00ff;
            font-weight: bold;
        }
        .galaxy-stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        .galaxy-discovery-btn {
            background: linear-gradient(135deg, #9400d3, #4b0082);
            border: 2px solid #bf00ff;
            color: #fff;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 20px;
        }
        .galaxy-discovery-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(191, 0, 255, 0.8);
        }
        /* v6.95: Ignite pulse animation for burning universe into existence */
        @keyframes ignite-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 100, 0, 0.6), 0 0 40px rgba(255, 50, 0, 0.3); transform: scale(1); }
            50% { box-shadow: 0 0 35px rgba(255, 150, 0, 0.8), 0 0 60px rgba(255, 100, 0, 0.5), 0 0 80px rgba(255, 50, 0, 0.3); transform: scale(1.02); }
        }
        .galaxy-journey-info {
            margin-top: 25px;
            padding: 15px;
            background: rgba(100,0,200,0.2);
            border: 1px solid rgba(191,0,255,0.3);
            border-radius: 10px;
            font-size: 14px;
            color: #aaa;
        }
        .galaxy-number {
            color: #bf00ff;
            font-weight: bold;
        }

        /* v6.86: Galaxy Manager Styles */
        .galaxy-manager-btn { background: linear-gradient(135deg, #1a0033, #330066); border: 1px solid #bf00ff; color: #bf00ff; padding: 5px 12px; font-size: 11px; cursor: pointer; border-radius: 15px; transition: all 0.3s; }
        .galaxy-manager-btn:hover { background: linear-gradient(135deg, #330066, #4400aa); box-shadow: 0 0 15px rgba(191,0,255,0.5); }
        .galaxy-manager-modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 25000; overflow-y: auto; pointer-events: auto; }
        .galaxy-manager-modal.active { display: block; }
        .galaxy-manager-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .galaxy-manager-header { display: flex; justify-content: space-between; align-items: center; padding: 20px 0; border-bottom: 1px solid rgba(191,0,255,0.3); margin-bottom: 20px; flex-wrap: wrap; gap: 15px; }
        .galaxy-manager-title { font-size: 28px; font-weight: bold; background: linear-gradient(135deg, #bf00ff, #00d4ff); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; }
        .galaxy-manager-stats { display: flex; gap: 20px; flex-wrap: wrap; }
        .gm-stat { text-align: center; padding: 8px 15px; background: rgba(191,0,255,0.1); border: 1px solid rgba(191,0,255,0.3); border-radius: 10px; }
        .gm-stat-value { font-size: 24px; font-weight: bold; color: #bf00ff; }
        .gm-stat-label { font-size: 10px; color: #888; text-transform: uppercase; }
        .galaxy-manager-close { position: fixed; top: 20px; right: 25px; background: none; border: none; font-size: 36px; color: #888; cursor: pointer; z-index: 25001; }
        .galaxy-manager-close:hover { color: #fff; }
        .galaxy-manager-controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .gm-control-btn { background: rgba(100,0,200,0.2); border: 1px solid rgba(191,0,255,0.4); color: #bf00ff; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s; }
        .gm-control-btn:hover { background: rgba(150,0,255,0.3); }
        .gm-control-btn.primary { background: linear-gradient(135deg, #9400d3, #4b0082); color: #fff; }
        .gm-search-box { flex: 1; min-width: 200px; background: rgba(0,0,0,0.5); border: 1px solid rgba(191,0,255,0.3); border-radius: 20px; padding: 10px 20px; color: #fff; font-size: 14px; outline: none; }
        .gm-search-box::placeholder { color: #666; }
        .galaxy-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; padding-bottom: 40px; }
        .galaxy-card { background: linear-gradient(145deg, rgba(20,0,40,0.9), rgba(10,0,30,0.95)); border: 1px solid rgba(191,0,255,0.3); border-radius: 15px; overflow: hidden; transition: all 0.3s; position: relative; }
        .galaxy-card:hover { transform: translateY(-5px); box-shadow: 0 10px 40px rgba(191,0,255,0.3); }
        .galaxy-card.current { border: 2px solid #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.3); }
        .galaxy-card.current::before { content: 'CURRENT'; position: absolute; top: 10px; right: 10px; background: #00ff88; color: #000; padding: 3px 8px; border-radius: 8px; font-size: 9px; font-weight: bold; z-index: 2; }
        .galaxy-card-header { background: linear-gradient(135deg, rgba(191,0,255,0.2), rgba(0,100,200,0.1)); padding: 15px; text-align: center; }
        .galaxy-card-visual { width: 60px; height: 60px; margin: 0 auto 10px; border-radius: 50%; background: radial-gradient(ellipse at center, #1a0033 0%, #000 100%); border: 2px solid rgba(191,0,255,0.5); position: relative; overflow: hidden; }
        .galaxy-card-visual::before { content: ''; position: absolute; top: 50%; left: 50%; width: 45px; height: 45px; transform: translate(-50%,-50%); background: conic-gradient(from 0deg, transparent, rgba(191,0,255,0.3), transparent); border-radius: 50%; animation: galaxySpin 8s linear infinite; }
        .galaxy-card-visual::after { content: ''; position: absolute; top: 50%; left: 50%; width: 5px; height: 5px; transform: translate(-50%,-50%); background: #fff; border-radius: 50%; box-shadow: 0 0 8px #fff; }
        @keyframes galaxySpin { from { transform: translate(-50%,-50%) rotate(0deg); } to { transform: translate(-50%,-50%) rotate(360deg); } }
        .galaxy-card-name { font-size: 15px; font-weight: bold; color: #fff; }
        .galaxy-card-name input { background: transparent; border: none; border-bottom: 1px dashed rgba(255,255,255,0.3); color: #fff; font-size: 15px; font-weight: bold; text-align: center; width: 100%; outline: none; }
        .galaxy-card-seed { font-size: 8px; color: #666; font-family: monospace; margin-top: 5px; }
        .galaxy-card-body { padding: 12px; }
        .galaxy-card-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 10px; }
        .gc-stat { background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; text-align: center; }
        .gc-stat-value { font-size: 16px; font-weight: bold; }
        .gc-stat-value.active { color: #00ff88; }
        .gc-stat-value.visited { color: #00d4ff; }
        .gc-stat-value.destroyed { color: #ff4444; }
        .gc-stat-value.escaped { color: #ffaa00; }
        .gc-stat-label { font-size: 7px; color: #888; text-transform: uppercase; }
        .galaxy-card-progress { height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; margin-bottom: 10px; }
        .galaxy-card-progress-bar { height: 100%; background: linear-gradient(90deg, #bf00ff, #00d4ff); transition: width 0.5s; }
        .galaxy-card-meta { font-size: 9px; color: #666; margin-bottom: 10px; }
        .galaxy-card-actions { display: flex; gap: 5px; }
        .gc-action-btn { flex: 1; padding: 7px; border: none; border-radius: 5px; cursor: pointer; font-size: 10px; font-weight: bold; transition: all 0.3s; }
        .gc-action-btn.warp { background: linear-gradient(135deg, #9400d3, #4b0082); color: #fff; }
        .gc-action-btn.warp:hover { box-shadow: 0 0 10px rgba(191,0,255,0.5); }
        .gc-action-btn.qr { background: rgba(0,200,255,0.2); color: #00d4ff; }
        .gc-action-btn.share { background: rgba(0,255,136,0.2); color: #00ff88; }
        .galaxy-qr-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 26000; align-items: center; justify-content: center; }
        .galaxy-qr-overlay.active { display: flex; }
        .galaxy-qr-content { background: linear-gradient(145deg, rgba(30,0,60,0.95), rgba(15,0,40,0.98)); border: 2px solid #bf00ff; border-radius: 20px; padding: 25px; text-align: center; max-width: 380px; }
        .galaxy-qr-title { font-size: 20px; color: #bf00ff; margin-bottom: 5px; }
        .galaxy-qr-subtitle { font-size: 10px; color: #888; margin-bottom: 12px; }
        .galaxy-qr-code { background: #fff; padding: 12px; border-radius: 10px; display: inline-block; margin-bottom: 12px; }
        .galaxy-qr-url { background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; font-size: 9px; color: #888; word-break: break-all; font-family: monospace; margin-bottom: 12px; }
        .galaxy-qr-actions { display: flex; gap: 10px; justify-content: center; }
        .galaxy-empty-state { text-align: center; padding: 60px 20px; color: #666; }
        .galaxy-empty-icon { font-size: 48px; margin-bottom: 15px; opacity: 0.5; }

        /* Data Controls - Import/Export */
        .data-controls {
            position: fixed;
            top: 8px;
            left: 220px;
            right: 180px;
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            pointer-events: auto;
            justify-content: center;
            align-items: flex-start;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        /* v6.1: ACCESSIBILITY IMPROVEMENTS - Focus states and keyboard navigation */
        *:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
        }

        button:focus-visible,
        .interactive:focus-visible,
        [role="button"]:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Skip to main content link */
        .skip-link {
            position: absolute;
            top: -100%;
            left: 50%;
            transform: translateX(-50%);
            background: #00ffff;
            color: #000;
            padding: 10px 20px;
            z-index: 10000;
            font-weight: bold;
            text-decoration: none;
            border-radius: 4px;
        }

        .skip-link:focus {
            top: 10px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .subtitle, .stat-lbl { color: #aaa; }
            button { border-width: 2px; }
            .hud-top { background: rgba(0, 0, 0, 0.95); }
        }

        /* Reduced motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Improved touch targets (min 44x44px) */
        @media (pointer: coarse) {
            button, .interactive, [role="button"] {
                min-height: 44px;
                min-width: 44px;
            }
        }

        /* v5.7: Menu toggle for dropdown */
        .data-controls .menu-toggle {
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid #fff !important;
            color: #fff !important;
        }

        .data-controls .menu-toggle:hover {
            background: rgba(255, 255, 255, 0.3) !important;
        }

        .data-controls .menu-secondary {
            display: none;
            position: fixed;
            top: 40px;
            right: 180px;
            background: rgba(10, 10, 30, 0.98);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 8px;
            flex-direction: column;
            gap: 5px;
            min-width: 130px;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3);
            z-index: 1001;
        }

        .data-controls .menu-secondary.show {
            display: flex;
        }

        .data-controls .menu-secondary button {
            width: 100%;
            text-align: left;
            padding: 8px 12px;
        }

        /* v5.7: AI Companion Settings Modal - Tabbed Interface */
        .ai-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .ai-settings-modal.active { display: flex; }
        .ai-settings-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid #7b2cbf;
            border-radius: 20px;
            width: 94%;
            max-width: 580px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(123, 44, 191, 0.5), inset 0 0 100px rgba(123, 44, 191, 0.1);
            position: relative;
        }
        .ai-settings-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(123, 44, 191, 0.1) 0%, transparent 50%);
            animation: ai-glow-rotate 20s linear infinite;
            pointer-events: none;
        }
        @keyframes ai-glow-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .ai-settings-header {
            padding: 25px 25px 20px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        .ai-settings-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            font-style: italic;
            background: linear-gradient(135deg, #06ffa5, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .ai-settings-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 2;
        }
        .ai-settings-close:hover { opacity: 1; transform: scale(1.1); }

        /* Tabs */
        .ai-settings-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 20px 20px;
            position: relative;
            z-index: 1;
        }
        .ai-settings-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-settings-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-settings-tab.active {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            border-color: #06ffa5;
            color: #000;
            font-weight: bold;
        }

        /* Tab Content */
        .ai-settings-body {
            padding: 0 25px 20px;
            max-height: calc(90vh - 250px);
            overflow-y: auto;
            position: relative;
            z-index: 1;
        }
        .ai-tab-content {
            display: none;
        }
        .ai-tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Sections */
        .ai-section {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(123, 44, 191, 0.2);
        }
        .ai-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: bold;
            color: #06ffa5;
        }

        /* Form Elements */
        .ai-form-group {
            margin-bottom: 15px;
        }
        .ai-form-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }
        .ai-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .ai-input:focus {
            outline: none;
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }
        .ai-input::placeholder {
            color: #555;
        }
        .ai-select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
        }
        .ai-select:focus {
            outline: none;
            border-color: #06ffa5;
        }

        /* Toggle Switch */
        .ai-toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        .ai-toggle-label {
            font-size: 14px;
            color: #ddd;
        }
        .ai-toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        .ai-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .ai-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 26px;
            transition: 0.3s;
        }
        .ai-toggle-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }
        .ai-toggle input:checked + .ai-toggle-slider {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }
        .ai-toggle input:checked + .ai-toggle-slider::before {
            transform: translateX(24px);
        }

        /* Endpoint Cards */
        .ai-endpoint-card {
            padding: 15px;
            background: rgba(6, 255, 165, 0.05);
            border: 1px solid rgba(6, 255, 165, 0.2);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-endpoint-card:hover {
            background: rgba(6, 255, 165, 0.1);
            border-color: rgba(6, 255, 165, 0.4);
        }
        .ai-endpoint-card.active {
            background: rgba(6, 255, 165, 0.15);
            border-color: #06ffa5;
            box-shadow: 0 0 20px rgba(6, 255, 165, 0.2);
        }
        .ai-endpoint-name {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .ai-endpoint-url {
            font-size: 11px;
            color: #666;
            word-break: break-all;
        }
        .ai-endpoint-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 10px;
            margin-top: 8px;
            font-weight: bold;
        }
        .ai-endpoint-badge.active {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
        }
        .ai-endpoint-badge.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        /* Color Picker Row */
        .ai-color-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .ai-color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .ai-color-input {
            flex: 1;
        }

        /* Actions Footer */
        .ai-settings-footer {
            display: flex;
            gap: 15px;
            padding: 20px 25px;
            border-top: 1px solid rgba(123, 44, 191, 0.3);
            position: relative;
            z-index: 1;
        }
        .ai-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            font-family: inherit;
        }
        .ai-btn-save {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }
        .ai-btn-save:hover {
            box-shadow: 0 0 25px rgba(6, 255, 165, 0.5);
            transform: translateY(-2px);
        }
        .ai-btn-cancel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
        }
        .ai-btn-cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-btn-import {
            background: linear-gradient(135deg, #7b2cbf, #3a0ca3);
            color: #fff;
        }
        .ai-btn-import:hover {
            box-shadow: 0 0 20px rgba(123, 44, 191, 0.5);
        }

        /* Status Message */
        .ai-status-msg {
            text-align: center;
            padding: 10px;
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
        .ai-status-msg.success { color: #06ffa5; }
        .ai-status-msg.error { color: #f44; }

        /* Player Health Bar - v5.15.2: Updated for PROBE INTEGRITY design */
        /* v5.16.3: Moved below button row to fix UI overlap */
        .player-health-bar {
            position: fixed;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(200px, 35vw, 320px);
            background: rgba(10, 20, 30, 0.9);
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 8px 12px;
            display: none;
            pointer-events: none;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            z-index: 99;
        }

        .player-health-bar.critical {
            border-color: #f44;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            animation: critical-pulse 0.5s infinite;
        }

        @keyframes critical-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.4); }
            50% { box-shadow: 0 0 30px rgba(255, 68, 68, 0.7); }
        }

        .player-health-fill {
            height: 8px;
            background: linear-gradient(to right, #0ff, #06ffa5);
            width: 100%;
            transition: width 0.3s, background 0.3s;
            border-radius: 4px;
        }

        .player-health-fill.low {
            background: linear-gradient(to right, #ff8800, #ffaa00);
        }

        .player-health-fill.critical {
            background: linear-gradient(to right, #f44, #ff6666);
        }

        .player-health-text {
            text-align: right;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        /* v5.11: RTS-Style RPG INTERFACE - Edge Docked Panels */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            display: none;
            padding: 0;
            pointer-events: none;
        }

        /* RTS Panel Toggle Buttons - Bottom Left Corner - v7.0: Design tokens + touch targets */
        .rts-panel-toggles {
            position: fixed;
            bottom: var(--space-3);
            left: var(--space-3);
            display: flex;
            gap: var(--space-1);
            z-index: var(--z-panel-rts);
            pointer-events: auto;
        }
        .rts-toggle-btn {
            position: relative;
            width: var(--touch-min);
            height: var(--touch-min);
            background: var(--color-bg-dark);
            border: 2px solid var(--color-border-default);
            border-radius: var(--radius-md);
            color: var(--color-text-accent);
            font-size: var(--font-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-base);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .rts-toggle-btn:hover {
            border-color: var(--color-border-hover);
            background: var(--color-bg-hover);
            transform: translateY(-2px);
        }
        .rts-toggle-btn:active {
            transform: scale(0.92);
            background: var(--color-bg-active);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .rts-toggle-btn:focus-visible {
            outline: 2px solid var(--color-border-focus);
            outline-offset: 2px;
        }
        .rts-toggle-btn.active {
            border-color: var(--color-border-active);
            background: var(--color-bg-active);
            box-shadow: var(--shadow-glow-cyan);
        }

        /* v6.99: Navigation buttons - consistent with RTS toggles but distinct color */
        .rts-toggle-btn.nav-btn { border-color: var(--color-accent-purple); }
        .rts-toggle-btn.nav-btn:hover { border-color: #9370db; background: rgba(106, 90, 205, 0.3); }
        .rts-toggle-btn.nav-btn.galaxy { border-color: var(--color-accent-purple); }
        .rts-toggle-btn.nav-btn.galaxy:hover { border-color: #df40ff; background: rgba(191, 0, 255, 0.3); }
        .rts-toggle-btn.nav-btn.surfaces { border-color: var(--color-accent-blue); }
        .rts-toggle-btn.nav-btn.surfaces:hover { border-color: #66aaff; background: rgba(68, 136, 255, 0.3); }

        /* v6.99: Visual divider between panel toggles and navigation */
        .rts-divider {
            width: 2px;
            height: 28px;
            background: linear-gradient(180deg, transparent, var(--color-border-default), transparent);
            margin: var(--space-2) var(--space-1);
            align-self: center;
        }

        /* v7.0: Keyboard hint badges on RTS buttons */
        .rts-toggle-btn .kbd-hint {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: var(--font-xs);
            color: var(--color-text-muted);
            background: rgba(0,0,0,0.6);
            padding: 0 2px;
            border-radius: 2px;
            font-family: monospace;
            line-height: 1.2;
        }

        /* Skills Panel - Left Edge Dock - v7.0: Design tokens + smooth transitions */
        .player-stats {
            position: fixed;
            bottom: 60px;
            left: 0;
            pointer-events: auto;
            background: var(--color-bg-dark);
            border: 2px solid var(--color-border-default);
            border-left: none;
            border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
            padding: var(--space-2) var(--space-3);
            width: 160px;
            max-height: 240px;
            overflow-y: auto;
            z-index: var(--z-panel-base);
            transform: translateX(-100%);
            opacity: 0;
            transition: transform var(--transition-panel), opacity var(--transition-panel);
        }
        .player-stats.visible {
            transform: translateX(0);
            opacity: 1;
        }

        /* Crafting Panel - Left Edge Dock - v7.0: Design tokens */
        .crafting-panel {
            position: fixed;
            bottom: 60px;
            left: 170px;
            background: var(--color-bg-dark);
            border: 2px solid var(--color-border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-2);
            pointer-events: auto;
            width: 150px;
            max-height: 280px;
            overflow-y: auto;
            z-index: var(--z-panel-base);
            transform: translateX(-300px);
            opacity: 0;
            transition: transform var(--transition-panel), opacity var(--transition-panel);
        }
        .crafting-panel.visible { transform: translateX(0); opacity: 1; }

        /* Inventory Panel - Bottom Center Dock - v7.0: Design tokens */
        .inventory-panel {
            position: fixed;
            bottom: var(--space-3);
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: var(--color-bg-dark);
            border: 2px solid var(--color-border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-2);
            pointer-events: auto;
            width: 200px;
            z-index: var(--z-panel-base);
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transition: transform var(--transition-panel), opacity var(--transition-panel);
        }
        .inventory-panel.visible { transform: translateX(-50%) translateY(0); opacity: 1; }

        /* Equipment Panel - Right of Inventory - v7.0: Design tokens */
        .equipment-panel {
            position: fixed;
            bottom: var(--space-3);
            right: 80px;
            background: var(--color-bg-dark);
            border: 2px solid var(--color-border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-2);
            pointer-events: auto;
            width: 160px;
            z-index: var(--z-panel-base);
            box-shadow: var(--shadow-lg);
            transform: translateY(100%);
            opacity: 0;
            transition: transform var(--transition-panel), opacity var(--transition-panel);
        }
        .equipment-panel.visible { transform: translateY(0); opacity: 1; }

        /* v7.0: Unified panel title styling */
        .panel-title {
            color: var(--color-text-accent);
            font-family: Georgia, serif;
            border-bottom: 1px solid var(--color-border-default);
            margin-bottom: var(--space-2);
            padding-bottom: var(--space-1);
            font-size: var(--font-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-title .close-panel {
            cursor: pointer;
            color: var(--color-text-muted);
            font-size: var(--font-base);
            line-height: 1;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }
        .panel-title .close-panel:hover {
            color: var(--color-accent-red);
            background: rgba(255, 68, 68, 0.2);
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 32px;
            min-height: 32px;
            border-radius: 3px;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 1px; right: 2px;
            font-size: 9px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        /* v5.1: Equipment Slots - Compact */
        .equip-slot {
            background: #1a1a2a;
            border: 1px solid #334;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .equip-slot:hover { border-color: #fb0; background: #2a2a3a; }
        .equip-slot.equipped { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .equip-icon { font-size: 16px; margin-bottom: 2px; }
        .equip-name { font-size: 8px; color: #aaa; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60px; }
        .equip-slot.equipped .equip-name { color: #4f4; }

        .xp-bar-container {
            margin-bottom: 4px;
        }
        .xp-label { font-size: 9px; color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 4px; background: #222; border-radius: 2px; overflow: hidden; margin-top: 2px; }
        .xp-bar-fill { height: 100%; width: 0%; transition: width 0.3s; }

        .craft-btn {
            display: block;
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px 6px;
            margin-bottom: 3px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 9px;
            transition: all 0.2s;
        }

        .craft-btn:hover:not(:disabled) { background: #555; border-color: #fb0; }
        /* v6.6: Active press feedback (Agent 3 UX consensus) */
        .craft-btn:active:not(:disabled) {
            transform: scale(0.95);
            background: #666;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Action Buttons */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: Georgia, serif;
            pointer-events: auto;
            font-size: clamp(11px, 2vw, 14px);
            transition: all 0.1s;
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }
        /* v6.6: Active press feedback (Agent 3 UX consensus) */
        .action-btn:active {
            transform: scale(0.95);
            background: #e0a000;
            box-shadow: 0 0 8px #fb0, inset 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Floating Text - v6.43: Enhanced pop animation */
        /* v6.32: Enhanced floater visibility with stronger shadows and outline */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow:
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 8px #000,
                0 2px 10px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: clamp(14px, 2.5vw, 18px);
            z-index: 1000;
            letter-spacing: 0.5px;
        }

        .floater.crit {
            font-size: clamp(20px, 3.5vw, 28px);
            animation: floatUpCrit 1.8s forwards;
            text-shadow:
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000,
                0 0 12px #000,
                0 0 20px currentColor;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1.5); opacity: 1; }
            10% { transform: translateY(-5px) scale(1); opacity: 1; }
            70% { opacity: 1; }
            100% { transform: translateY(-70px) scale(0.85); opacity: 0; }
        }

        @keyframes floatUpCrit {
            0% { transform: translateY(0) scale(2.2) rotate(-5deg); opacity: 1; }
            15% { transform: translateY(-12px) scale(1.3) rotate(3deg); opacity: 1; }
            30% { transform: translateY(-25px) scale(1.15) rotate(-2deg); opacity: 1; }
            70% { opacity: 1; }
            100% { transform: translateY(-90px) scale(0.75) rotate(0deg); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.95);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: clamp(10px, 1.5vw, 12px);
            pointer-events: none;
            display: none;
            z-index: 150;
            border-radius: 4px;
            max-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
        }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
            font-family: Georgia, serif;
        }

        .loading-text {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }

        .loading-bar {
            width: clamp(200px, 50vw, 300px);
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #0f0;
            animation: loadPulse 1s ease-in-out infinite;
        }

        @keyframes loadPulse {
            0%, 100% { width: 20%; margin-left: 0; }
            50% { width: 40%; margin-left: 60%; }
        }

        /* v6.74: Minimap - Repositioned to bottom-right corner */
        .minimap {
            position: fixed;
            bottom: 80px;
            right: 10px;
            width: clamp(100px, 15vw, 130px);
            height: clamp(100px, 15vw, 130px);
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(0,255,255,0.3);
            border-radius: 10px;
            display: none;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* v6.98: CINEMATIC MODE - RDR2-style theatrical view */
        .cinematic-active .ui-layer,
        .cinematic-active #ai-behavior-panel,
        .cinematic-active #skills-panel,
        .cinematic-active #crafting-panel,
        .cinematic-active .minimap,
        .cinematic-active #minimap-container,
        .cinematic-active #ship-status,
        .cinematic-active #pet-panel,
        .cinematic-active #weather-widget,
        .cinematic-active #gear-panel,
        .cinematic-active #hotbar,
        .cinematic-active #ability-bar,
        .cinematic-active #hp-mp-bars,
        .cinematic-active #daily-challenge-panel,
        .cinematic-active #chronicle-panel,
        .cinematic-active #perf-metrics,
        .cinematic-active #autosave-indicator,
        .cinematic-active #combo-display,
        .cinematic-active #quest-tracker,
        .cinematic-active .draggable-panel,
        .cinematic-active #environment-widget,
        .cinematic-active #spectator-btn,
        .cinematic-active #copilot-chat,
        .cinematic-active #inventory-panel,
        .cinematic-active #nav-galaxy,
        .cinematic-active #nav-surfaces,
        .cinematic-active .rts-divider {
            opacity: 0 !important;
            pointer-events: none !important;
            transition: opacity 0.8s ease-out !important;
        }

        .cinematic-letterbox {
            position: fixed;
            left: 0;
            right: 0;
            height: 0;
            background: #000;
            z-index: 9999;
            transition: height 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }
        .cinematic-letterbox-top { top: 0; }
        .cinematic-letterbox-bottom { bottom: 0; }
        .cinematic-active .cinematic-letterbox { height: 12%; }

        .cinematic-vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0;
            transition: opacity 0.8s ease-out;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
        }
        .cinematic-active .cinematic-vignette { opacity: 1; }

        .cinematic-grain {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 9997;
            opacity: 0;
            transition: opacity 0.8s ease-out;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
        }
        .cinematic-active .cinematic-grain { opacity: 0.03; }

        .cinematic-toggle-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.3);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        .cinematic-toggle-btn:hover {
            background: rgba(0,0,0,0.8);
            border-color: rgba(255,255,255,0.6);
            transform: scale(1.1);
        }
        .cinematic-active .cinematic-toggle-btn {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .cinematic-active .cinematic-toggle-btn:hover,
        .cinematic-active:hover .cinematic-toggle-btn {
            opacity: 0.5;
        }

        .cinematic-hint {
            position: fixed;
            bottom: 14%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.8);
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.5s ease;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        .cinematic-hint.visible { opacity: 1; }
        .cinematic-hint.fade-out { opacity: 0; transition: opacity 1.5s ease; }

        /* Hide cursor after inactivity in cinematic mode */
        .cinematic-active.cursor-hidden { cursor: none !important; }
        .cinematic-active.cursor-hidden * { cursor: none !important; }

        /* v6.50: Ant Farm Ecosystem View */
        .ant-farm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 500;
            display: none;
            pointer-events: none;
        }
        .ant-farm-overlay.active { display: flex; flex-direction: column; }
        .ant-farm-overlay * { pointer-events: auto; }
        .ant-farm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(20, 20, 40, 0.9);
            border-bottom: 1px solid #0ff;
        }
        .ant-farm-title {
            color: #0ff;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .ant-farm-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .ant-farm-controls span { color: #888; font-size: 12px; }
        .ant-farm-controls kbd {
            background: #333;
            padding: 2px 8px;
            border-radius: 3px;
            color: #0ff;
        }
        .ant-farm-stats {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(10, 10, 20, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #0ff;
            color: #aaa;
            font-size: 12px;
        }
        .ant-farm-stats div { margin: 4px 0; }
        .ant-farm-stats span { color: #0ff; font-weight: bold; }
        .ant-farm-zoom-info {
            position: fixed;
            bottom: 20px;
            left: 10px;
            background: rgba(10, 10, 20, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #0ff;
            color: #0ff;
            font-size: 12px;
        }

        /* v4.8: Combat Abilities (v4.9: Enhanced styling) */
        @keyframes ability-ready-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); }
        }
        @keyframes berserk-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.9); }
        }
        /* v6.42: Chrono-Echo ghost pulse animation */
        @keyframes chrono-echo-pulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(136, 68, 255, 0.3);
                border-color: #00ffff;
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.9), 0 0 40px rgba(136, 68, 255, 0.6);
                border-color: #8844ff;
            }
        }
        .chrono-echo-slot.active-buff {
            animation: chrono-echo-pulse 0.8s infinite !important;
        }
        /* v6.70: Enhanced ability slot styling */
        .ability-slot {
            width: 52px;
            height: 52px;
            background: linear-gradient(180deg, rgba(35,40,55,0.95) 0%, rgba(25,30,45,0.98) 100%);
            border: 2px solid rgba(100,110,130,0.5);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.15s ease-out;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .ability-slot:hover:not(.locked):not(.on-cooldown) {
            border-color: #0ff;
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0,255,255,0.25), inset 0 1px 0 rgba(255,255,255,0.1);
        }
        /* v6.6: Active press feedback (Agent 3 UX consensus) */
        .ability-slot:active:not(.locked):not(.on-cooldown) {
            transform: translateY(0) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.6);
        }
        .ability-slot.locked {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(0.9) brightness(0.7);
        }
        .ability-slot.locked::after {
            content: '';
            position: absolute;
            font-size: 11px;
            top: 3px;
            right: 3px;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.8));
        }
        .ability-slot.on-cooldown {
            border-color: rgba(60,60,80,0.6);
            opacity: 0.6;
            background: linear-gradient(180deg, rgba(25,28,40,0.95) 0%, rgba(18,22,35,0.98) 100%);
        }
        .ability-slot:not(.locked):not(.on-cooldown) {
            animation: ability-ready-pulse 2.5s ease-in-out infinite;
            border-color: rgba(0,200,200,0.6);
        }
        .ability-slot.active-buff {
            border-color: #ff8800;
            box-shadow: 0 0 15px rgba(255,136,0,0.5), inset 0 0 10px rgba(255,136,0,0.2);
            animation: none;
            background: linear-gradient(180deg, rgba(60,45,30,0.95) 0%, rgba(45,35,25,0.98) 100%);
        }
        .ability-slot.active-buff[id="ability-c"] {
            animation: berserk-pulse 0.5s infinite;
        }
        .ability-icon {
            font-size: 20px;
        }
        .ability-key {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
            border-radius: 0 0 6px 6px;
        }
        /* v6.8: Numeric cooldown timer (Agent consensus - UI/UX) */
        .ability-cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 4px #000, 0 0 2px #000;
            z-index: 5;
            pointer-events: none;
        }

        /* Touch Controls */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
            pointer-events: auto;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* v4.3: Virtual Joystick */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .touch-action-btn {
            position: fixed;
            bottom: 50px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: rgba(255, 100, 0, 0.4);
            border: 3px solid rgba(255, 150, 0, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-action-btn:active {
            background: rgba(255, 150, 0, 0.7);
        }

        /* v4.5: Mobile Dodge Button */
        .touch-dodge-btn {
            position: fixed;
            bottom: 140px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(100, 200, 255, 0.4);
            border: 3px solid rgba(150, 220, 255, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-dodge-btn:active {
            background: rgba(150, 220, 255, 0.7);
        }

        /* v6.87: Touch Ability Bar - Mobile Combat (8-strategy consensus) */
        .touch-ability-bar {
            display: none;
            position: fixed;
            right: calc(20px + var(--safe-right, 0px));
            bottom: calc(220px + var(--safe-bottom, 0px));
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            pointer-events: auto;
        }

        .touch-ability-btn {
            width: 52px;
            height: 52px;
            background: rgba(30, 40, 60, 0.85);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease-out;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            -webkit-tap-highlight-color: transparent;
        }

        .touch-ability-btn:active:not(.locked):not(.on-cooldown) {
            transform: scale(0.9);
            background: rgba(100, 200, 255, 0.6);
        }

        .touch-ability-btn.locked {
            display: none;
        }

        .touch-ability-btn.on-cooldown {
            opacity: 0.5;
            border-color: rgba(60, 60, 80, 0.6);
        }

        .touch-ability-btn:not(.locked):not(.on-cooldown) {
            border-color: rgba(0, 255, 255, 0.7);
        }

        .touch-ability-icon {
            font-size: 22px;
            z-index: 1;
        }

        .touch-ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 0 0 50% 50%;
            transition: height 0.1s linear;
        }

        .touch-ability-cd-text {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 2;
        }

        @media (pointer: coarse) {
            .touch-ability-bar {
                display: flex;
            }
        }

        /* Notification Toast - v6.34: Moved below HUD to prevent overlap */
        .notification {
            position: fixed;
            top: 180px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px 20px;
            border-radius: 4px;
            color: #0f0;
            font-size: 14px;
            z-index: 500;
            animation: notifySlide 3s forwards;
            pointer-events: none;
            transition: top 0.3s ease-out;
            max-width: 400px;
            text-align: center;
        }

        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* v6.32: Low HP Warning Vignette */
        #low-hp-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(180, 0, 0, 0.4) 100%);
        }

        #low-hp-vignette.active {
            opacity: 1;
            animation: lowHpPulse 1.2s ease-in-out infinite;
        }

        #low-hp-vignette.critical {
            background: radial-gradient(ellipse at center, transparent 30%, rgba(200, 0, 0, 0.6) 100%);
            animation: lowHpPulseCritical 0.8s ease-in-out infinite;
        }

        @keyframes lowHpPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        @keyframes lowHpPulseCritical {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* v6.80: CRITICAL HP DESATURATION MODE - 8-Agent Consensus Enhancement */
        #critical-hp-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #critical-hp-overlay.active {
            opacity: 1;
            animation: criticalHeartbeat 0.8s ease-in-out infinite;
        }
        @keyframes criticalHeartbeat {
            0%, 100% {
                backdrop-filter: saturate(0.3) brightness(0.9);
                box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.3);
            }
            50% {
                backdrop-filter: saturate(0.5) brightness(1);
                box-shadow: inset 0 0 150px rgba(255, 0, 0, 0.5);
            }
        }

        /* v6.80: IMPACT BORDER PULSE - Damage Feedback */
        #impact-border {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.1s ease;
        }
        #impact-border.damage-taken {
            opacity: 1;
            box-shadow: inset 0 0 80px 20px rgba(255, 50, 50, 0.8);
            animation: impactFade 0.4s ease-out forwards;
        }
        #impact-border.damage-dealt {
            opacity: 1;
            box-shadow: inset 0 0 60px 15px rgba(255, 200, 50, 0.6);
            animation: impactFade 0.3s ease-out forwards;
        }
        #impact-border.critical-hit {
            opacity: 1;
            box-shadow: inset 0 0 100px 30px rgba(255, 100, 0, 1);
            animation: criticalImpact 0.5s ease-out forwards;
        }
        #impact-border.heal {
            opacity: 1;
            box-shadow: inset 0 0 60px 15px rgba(50, 255, 100, 0.6);
            animation: impactFade 0.4s ease-out forwards;
        }
        @keyframes impactFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        @keyframes criticalImpact {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
            100% { opacity: 0; transform: scale(1); }
        }

        /* v6.80: ABILITY ACTIVATION FLASH */
        #ability-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 4;
            opacity: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.4) 0%, transparent 70%);
        }
        #ability-flash.fire { background: radial-gradient(circle at center, rgba(255,100,0,0.5) 0%, transparent 70%); }
        #ability-flash.ice { background: radial-gradient(circle at center, rgba(100,200,255,0.5) 0%, transparent 70%); }
        #ability-flash.lightning { background: radial-gradient(circle at center, rgba(255,255,100,0.5) 0%, transparent 70%); }
        #ability-flash.dark { background: radial-gradient(circle at center, rgba(150,50,200,0.5) 0%, transparent 70%); }
        #ability-flash.holy { background: radial-gradient(circle at center, rgba(255,255,200,0.6) 0%, transparent 70%); }
        #ability-flash.active {
            animation: abilityFlash 0.3s ease-out forwards;
        }
        @keyframes abilityFlash {
            0% { opacity: 1; transform: scale(0.8); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        /* v6.80: BOSS INTRODUCTION CINEMATIC */
        #boss-intro-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        #boss-intro-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        .boss-intro-title {
            font-size: clamp(40px, 8vw, 80px);
            color: #ff3333;
            text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
            font-family: Georgia, serif;
            letter-spacing: 8px;
            animation: bossNameReveal 1.5s ease-out forwards;
            opacity: 0;
        }
        .boss-intro-subtitle {
            font-size: clamp(16px, 3vw, 24px);
            color: #ff6666;
            text-transform: uppercase;
            letter-spacing: 12px;
            margin-top: 20px;
            opacity: 0;
            animation: bossSubtitleReveal 1s ease-out 0.8s forwards;
        }
        @keyframes bossNameReveal {
            0% { opacity: 0; transform: scale(3) translateY(-50px); filter: blur(20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); filter: blur(0); }
        }
        @keyframes bossSubtitleReveal {
            0% { opacity: 0; letter-spacing: 30px; }
            100% { opacity: 1; letter-spacing: 12px; }
        }

        /* v6.80: MOMENTUM METER - Flow State Tracking */
        #momentum-meter {
            position: fixed;
            bottom: 200px;
            left: 20px;
            width: 8px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #momentum-meter.active { opacity: 1; }
        #momentum-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff6600, #ff0000);
            transition: height 0.2s ease;
            box-shadow: 0 0 10px currentColor;
        }
        #momentum-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #888;
            white-space: nowrap;
        }
        #momentum-meter.on-fire #momentum-fill {
            animation: momentumFire 0.3s ease infinite;
        }
        @keyframes momentumFire {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        /* v6.80: VICTORY CONFETTI CONTAINER */
        #confetti-container {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 450;
            overflow: hidden;
        }
        .confetti-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 1;
        }

        /* v6.80: UI PANEL TRANSITIONS */
        .panel-transition {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .panel-transition.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        /* v6.73: Auto-save Indicator - Repositioned to avoid UI overlap */
        #autosave-indicator {
            position: fixed;
            bottom: 100px;
            left: 20px;
            background: linear-gradient(180deg, rgba(12,16,24,0.95) 0%, rgba(6,10,18,0.98) 100%);
            color: #4ade80;
            padding: 10px 16px;
            border-radius: 12px;
            border: 1px solid rgba(74, 222, 128, 0.3);
            font-size: 12px;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }

        #autosave-indicator.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #autosave-indicator .save-icon {
            animation: saveRotate 1s linear infinite;
        }

        @keyframes saveRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(50, 40, 80, 0.95));
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 600;
            animation: achievementSlide 4s forwards;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .achievement-popup .ach-icon { font-size: 36px; }
        .achievement-popup .ach-title { color: #ffd700; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; }
        .achievement-popup .ach-name { color: #fff; font-size: 16px; font-weight: bold; margin: 3px 0; }
        .achievement-popup .ach-desc { color: #aaa; font-size: 12px; }

        @keyframes achievementSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }

        /* Daily Challenge Box */
        /* v6.81: Repositioned below AI Behavior panel */
        .daily-challenge-box {
            position: fixed;
            top: 240px;
            right: 10px;
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid #ffd700;
            border-radius: 10px;
            padding: 12px 15px;
            width: 180px;
            z-index: 100;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .daily-challenge-box.completed {
            border-color: #44ff44;
            background: rgba(20, 40, 20, 0.9);
        }

        .daily-title { color: #ffd700; font-size: 11px; text-transform: uppercase; margin-bottom: 8px; }
        .daily-desc { color: #fff; font-size: 12px; margin-bottom: 8px; }
        .daily-progress-bar { background: #333; border-radius: 4px; height: 8px; overflow: hidden; }
        .daily-progress-fill { background: linear-gradient(90deg, #ffd700, #ffaa00); height: 100%; transition: width 0.3s; }
        .daily-progress-text { color: #aaa; font-size: 10px; margin-top: 5px; }
        .daily-streak { color: #ff8800; font-size: 10px; margin-top: 3px; }

        .daily-toggle-btn {
            float: right;
            margin: -4px -6px 0 8px;
            width: 20px;
            height: 20px;
            background: rgba(40, 40, 60, 0.9);
            border: 1px solid #ffd700;
            border-radius: 4px;
            color: #ffd700;
            font-size: 14px;
            line-height: 16px;
            cursor: pointer;
            padding: 0;
            transition: all 0.2s;
        }
        .daily-toggle-btn:hover { background: rgba(60, 60, 80, 0.9); }
        .daily-challenge-box.collapsed { width: auto; padding: 8px 12px; }
        .daily-challenge-box.collapsed #daily-challenge-content { display: none; }
        .daily-challenge-box.collapsed .daily-title { margin-bottom: 0; display: inline; }

        /* Stats Modal */
        .stats-section { margin-bottom: 20px; }
        .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 13px; }
        .stat-row span:last-child { color: #0ff; font-weight: bold; }

        .achievements-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .ach-item {
            display: flex; align-items: center; gap: 6px;
            background: rgba(40,40,60,0.8);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
        }
        .ach-item.unlocked { color: #fff; background: rgba(50, 50, 80, 0.9); border: 1px solid #ffd700; }
        .ach-item.locked .ach-badge { filter: grayscale(1); opacity: 0.4; }
        .ach-badge { font-size: 16px; }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .modal-content {
            background: #1a1a2e;
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            margin: auto;
            position: relative;
        }

        .modal-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 20px;
            font-family: Georgia, serif;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* v4.9: Collection Codex Styles */
        .codex-tab {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #444;
            color: #aaa;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .codex-tab:hover { border-color: #0ff; color: #fff; }
        .codex-tab.active {
            background: linear-gradient(135deg, #0aa, #088);
            border-color: #0ff;
            color: #fff;
        }
        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .codex-entry {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .codex-entry:hover { border-color: #0ff; transform: translateY(-2px); }
        .codex-entry.discovered { border-color: #4a4; }
        .codex-entry.undiscovered {
            filter: grayscale(1);
            opacity: 0.5;
        }
        .codex-entry .entry-icon {
            font-size: 28px;
            margin-bottom: 5px;
            display: block;
        }
        .codex-entry .entry-name {
            font-size: 11px;
            color: #ccc;
            display: block;
        }
        .codex-entry.undiscovered .entry-name { color: #666; }
        .codex-entry .entry-count {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        /* v5.0: Quest System Styles */
        .quest-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quest-item {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
        }
        .quest-item:hover { border-color: #ff8c00; }
        .quest-item.completed {
            border-color: #4a4;
            background: rgba(40, 80, 40, 0.3);
        }
        .quest-item.claimed {
            opacity: 0.5;
            border-color: #333;
        }
        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .quest-title {
            font-size: 14px;
            color: #fff;
            font-weight: bold;
        }
        .quest-reward {
            font-size: 12px;
            color: #ffd700;
        }
        .quest-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        .quest-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8c00, #ffd700);
            transition: width 0.3s;
        }
        .quest-progress-text {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            text-align: right;
        }
        .quest-claim-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #4a4, #2a2);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        .quest-claim-btn:hover { background: linear-gradient(135deg, #5b5, #3b3); }
        .quest-claim-btn:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* v4.6: Settings Panel Styles */
        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-section:last-child { border-bottom: none; }
        .settings-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }
        .setting-row input[type="range"] {
            width: 100px;
            margin: 0 10px;
            accent-color: #0ff;
        }
        .setting-row select {
            background: #222;
            border: 1px solid #445;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .toggle-btn {
            background: rgba(0,100,0,0.5);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            min-width: 50px;
        }
        .toggle-btn.off {
            background: rgba(100,0,0,0.5);
            border-color: #f44;
            color: #f44;
        }

        /* v5.3: Mastery System Styles */
        .mastery-card {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .mastery-card:hover { border-color: #ffd700; }
        .mastery-card.mastered { border-color: #ffd700; background: rgba(50, 45, 30, 0.9); }
        .mastery-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .mastery-skill { font-size: 16px; font-weight: bold; }
        .mastery-level { color: #ffd700; font-size: 14px; }
        .mastery-progress-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
        .mastery-progress-fill { height: 100%; background: linear-gradient(90deg, #8844ff, #ff44ff); transition: width 0.3s; }
        .mastery-milestones { display: flex; gap: 8px; flex-wrap: wrap; }
        .milestone { padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(0,0,0,0.3); border: 1px solid #333; }
        .milestone.achieved { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; color: #ffd700; }
        .milestone.next { background: rgba(136, 68, 255, 0.2); border-color: #8844ff; color: #aaf; }

        /* v5.3: Realm Portal Styles */
        .portal-card {
            background: linear-gradient(135deg, rgba(40, 20, 60, 0.95), rgba(20, 40, 60, 0.95));
            border: 2px solid #8844ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .portal-card:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(136, 68, 255, 0.4); }
        .portal-card.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.5); }
        .portal-card.active { border-color: #ff4400; animation: portal-pulse 1.5s infinite; }
        @keyframes portal-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.6); }
        }
        .portal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .portal-name { font-size: 18px; font-weight: bold; color: #fff; }
        .portal-tier { padding: 4px 10px; border-radius: 12px; font-size: 11px; background: linear-gradient(135deg, #8844ff, #4488ff); }
        .portal-desc { color: #aaa; font-size: 12px; margin-bottom: 10px; }
        .portal-rewards { display: flex; gap: 10px; flex-wrap: wrap; }
        .portal-reward { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .portal-requirement { color: #888; font-size: 11px; margin-top: 8px; }

        /* v5.3: Loot Rarity Styles */
        .rarity-common { color: #aaaaaa; }
        .rarity-uncommon { color: #44ff44; }
        .rarity-rare { color: #4488ff; }
        .rarity-epic { color: #aa44ff; }
        .rarity-legendary { color: #ff8800; text-shadow: 0 0 5px rgba(255, 136, 0, 0.5); }
        .rarity-mythic { color: #ff4488; text-shadow: 0 0 8px rgba(255, 68, 136, 0.6); animation: mythic-glow 2s infinite; }
        @keyframes mythic-glow {
            0%, 100% { text-shadow: 0 0 5px rgba(255, 68, 136, 0.4); }
            50% { text-shadow: 0 0 15px rgba(255, 68, 136, 0.8); }
        }
        .item-modifiers { font-size: 10px; color: #88ff88; margin-top: 4px; }
        .loot-drop-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            min-width: 250px;
            text-align: center;
            animation: loot-appear 0.3s ease-out;
        }
        @keyframes loot-appear {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* v5.4: Companion Evolution Styles */
        .evolution-card {
            background: linear-gradient(135deg, rgba(40, 30, 60, 0.95), rgba(60, 40, 80, 0.95));
            border: 2px solid #aa44ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        .evolution-card:hover { box-shadow: 0 0 20px rgba(170, 68, 255, 0.4); }
        .evolution-card.can-evolve { border-color: #ffd700; animation: evolve-pulse 1.5s infinite; }
        @keyframes evolve-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); }
        }
        .evolution-header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
        .evolution-icon { font-size: 40px; }
        .evolution-info { flex: 1; }
        .evolution-name { font-size: 16px; font-weight: bold; color: #fff; }
        .evolution-stage { font-size: 12px; color: #aa88ff; }
        .evolution-bond { margin: 10px 0; }
        .bond-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .bond-fill { height: 100%; background: linear-gradient(90deg, #ff44aa, #aa44ff); transition: width 0.3s; }
        .evolution-abilities { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
        .evolution-ability { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .evolution-ability.locked { opacity: 0.4; }
        .evolve-btn {
            display: block; width: 100%; margin-top: 10px; padding: 10px;
            background: linear-gradient(135deg, #ffd700, #ff8800);
            border: none; border-radius: 6px; color: #000; font-weight: bold;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .evolve-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .evolve-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

        /* v5.4: World Events Styles */
        /* v6.33: Improved stacking and positioning */
        .event-notification {
            position: fixed; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.95), rgba(200, 50, 0, 0.95));
            border: 2px solid #ffd700; border-radius: 12px; padding: 12px 20px;
            z-index: 1500; text-align: center; animation: event-slide 0.4s ease-out;
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.5);
            transition: top 0.3s ease-out, opacity 0.3s ease-out;
        }
        .event-notification.dismissing {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }
        @keyframes event-slide {
            0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .event-title { font-size: 16px; font-weight: bold; color: #fff; margin-bottom: 4px; }
        .event-desc { font-size: 11px; color: #ffd700; }
        .event-timer { font-size: 12px; color: #fff; margin-top: 6px; }
        .world-event-marker {
            position: absolute; pointer-events: none;
            animation: event-marker-pulse 1s infinite;
        }
        @keyframes event-marker-pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        .event-indicator {
            position: fixed; top: 130px; right: 10px;
            background: rgba(0,0,0,0.8); border: 2px solid #ff8800;
            border-radius: 8px; padding: 10px; z-index: 100;
            display: none; min-width: 150px;
        }
        .event-indicator.active { display: block; animation: event-pulse 2s infinite; }
        @keyframes event-pulse {
            0%, 100% { border-color: #ff8800; }
            50% { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 136, 0, 0.5); }
        }
        .event-indicator-icon { font-size: 24px; text-align: center; margin-bottom: 5px; }
        .event-indicator-name { font-size: 12px; color: #ffd700; text-align: center; }
        .event-indicator-time { font-size: 11px; color: #fff; text-align: center; margin-top: 4px; }
        .event-indicator-progress { height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 6px; overflow: hidden; }
        .event-indicator-fill { height: 100%; background: #ff8800; transition: width 0.5s; }

        /* v5.4: Achievement Showcase Styles */
        .showcase-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 15px; }
        .showcase-badge {
            background: rgba(30, 30, 50, 0.9); border: 2px solid #333;
            border-radius: 8px; padding: 10px; text-align: center;
            cursor: pointer; transition: all 0.2s;
        }
        .showcase-badge:hover { border-color: #ffd700; transform: translateY(-2px); }
        .showcase-badge.earned { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .showcase-badge.rare { border-color: #4488ff; background: rgba(68, 136, 255, 0.15); }
        .showcase-badge.legendary { border-color: #ff8800; background: rgba(255, 136, 0, 0.15); animation: legendary-badge 2s infinite; }
        @keyframes legendary-badge {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 136, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 136, 0, 0.6); }
        }
        .showcase-badge-icon { font-size: 28px; margin-bottom: 5px; }
        .showcase-badge-name { font-size: 10px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .showcase-badge.earned .showcase-badge-name { color: #4f4; }
        .achievement-points-display {
            text-align: center; padding: 15px; margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 136, 0, 0.1));
            border: 1px solid #ffd700; border-radius: 8px;
        }
        .ap-value { font-size: 32px; font-weight: bold; color: #ffd700; }
        .ap-label { font-size: 12px; color: #aaa; }
        .ap-milestone { margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; }
        .ap-milestone-progress { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-top: 5px; }
        .ap-milestone-fill { height: 100%; background: linear-gradient(90deg, #ffd700, #ff8800); }
        .cosmetic-effect { position: absolute; pointer-events: none; z-index: 5; }
        .cosmetic-aura { animation: aura-rotate 3s linear infinite; }
        @keyframes aura-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
            }

            .rpg-ui {
                flex-direction: column;
                align-items: center;
                max-height: 50vh;
                overflow-y: auto;
            }

            .inventory-panel, .player-stats, .crafting-panel {
                width: 95%;
                max-width: none;
            }

            .touch-controls {
                display: flex;
            }

            .data-controls {
                position: fixed;
                top: auto;
                bottom: 155px;  /* v6.33: Above touch controls and RTS buttons */
                right: 10px;
                left: 10px;
                justify-content: flex-start;
                overflow-x: auto;
                overflow-y: hidden;
                flex-wrap: nowrap;
                padding: 8px 5px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 8px;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }

            .data-controls::-webkit-scrollbar {
                display: none;
            }

            .data-controls button {
                padding: 8px 12px;
                font-size: 11px;
                flex-shrink: 0;
                min-height: 38px;
            }

            .data-controls .menu-secondary {
                position: fixed;
                top: auto;
                bottom: 200px;
                right: 10px;
                left: 10px;
                transform: none;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .minimap {
                bottom: auto;
                top: 60px;
                right: 5px;
                width: 80px !important;
                height: 80px !important;
            }

            /* v6.33: Move ship status panel to not overlap */
            #ship-status {
                top: auto !important;
                bottom: 220px !important;
                left: 10px !important;
                right: auto !important;
                max-width: 180px !important;
                font-size: 10px !important;
            }

            /* v6.33: Adjust daily challenge position */
            #daily-challenge-panel {
                top: 145px !important;
                right: 5px !important;
                max-width: 150px !important;
                font-size: 10px !important;
            }

            /* v6.33: Weather indicator repositioned */
            #weather-indicator {
                bottom: 210px !important;
                right: 5px !important;
            }

            /* v6.33: Dodge button above joystick area */
            .touch-dodge-btn {
                bottom: 80px !important;
                right: 20px !important;
            }

            .touch-action-btn {
                bottom: 20px !important;
                right: 20px !important;
            }

            /* v7.0: RTS panel toggles - proper touch targets for mobile */
            .rts-panel-toggles {
                bottom: 75px !important;
                left: var(--space-2) !important;
                gap: var(--space-2) !important;
            }

            .rts-toggle-btn {
                width: var(--touch-min) !important;
                height: var(--touch-min) !important;
                font-size: var(--font-md) !important;
            }

            .rts-toggle-btn .kbd-hint {
                display: none; /* Hide keyboard hints on touch devices */
            }

            /* v6.33: Virtual joystick repositioned */
            .virtual-joystick, #virtual-joystick {
                bottom: 20px !important;
                left: 10px !important;
                width: 100px !important;
                height: 100px !important;
            }

            /* v6.33: RTS command bar repositioned */
            .rts-command-bar {
                bottom: 75px !important;
                right: 10px !important;
            }

            /* v6.81: Companion and environment widgets repositioned for mobile */
            .companion-health-container {
                bottom: auto !important;
                top: 150px !important;
                right: 5px !important;
                width: 160px !important;
            }

            #environment-widget {
                bottom: auto !important;
                top: 230px !important;
                right: 5px !important;
                width: 150px !important;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 16px;
                letter-spacing: 1px;
            }

            .inv-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .rpg-ui {
                padding: 5px;
            }

            .data-controls {
                bottom: 140px;
            }

            .data-controls button {
                padding: 6px 10px;
                font-size: 10px;
                min-height: 36px;
            }

            /* v6.33: Smaller panels on very small screens */
            #ship-status {
                max-width: 160px !important;
                padding: 6px !important;
                bottom: 200px !important;
            }

            #daily-challenge-panel {
                max-width: 130px !important;
            }
        }

        /* ==========================================
           iOS MOBILE OPTIMIZATIONS
           Consensus fixes from 8 strategy analyses
           ========================================== */

        /* iOS Safe Area Support (5/8 consensus) */
        @supports (padding: env(safe-area-inset-top)) {
            .hud-top {
                padding-top: calc(10px + var(--safe-top));
                padding-left: calc(10px + var(--safe-left));
                padding-right: calc(10px + var(--safe-right));
            }

            .virtual-joystick, #virtual-joystick {
                bottom: calc(20px + var(--safe-bottom)) !important;
                left: calc(10px + var(--safe-left)) !important;
            }

            .touch-action-btn {
                bottom: calc(20px + var(--safe-bottom)) !important;
                right: calc(20px + var(--safe-right)) !important;
            }

            .touch-dodge-btn {
                bottom: calc(90px + var(--safe-bottom)) !important;
                right: calc(20px + var(--safe-right)) !important;
            }

            .data-controls {
                bottom: calc(155px + var(--safe-bottom)) !important;
                left: calc(10px + var(--safe-left)) !important;
                right: calc(10px + var(--safe-right)) !important;
            }

            #ability-bar {
                bottom: calc(10px + var(--safe-bottom)) !important;
            }

            .galaxy-manager-modal,
            .modal-overlay {
                padding-top: var(--safe-top);
                padding-bottom: var(--safe-bottom);
            }
        }

        /* 44px Touch Targets (4/8 consensus) */
        @media (pointer: coarse) {
            button, .interactive, [role="button"],
            .action-btn, .craft-btn, .gc-action-btn,
            .rts-toggle-btn, .gm-control-btn,
            .modal-close, .galaxy-manager-close {
                min-height: 44px;
                min-width: 44px;
            }

            .inv-slot, .equip-slot {
                min-width: 44px;
                min-height: 44px;
            }

            .data-controls button {
                min-height: 44px;
                padding: 10px 14px;
            }

            .rts-toggle-btn {
                width: 44px !important;
                height: 44px !important;
            }

            .modal-close, .galaxy-manager-close {
                width: 44px;
                height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 28px;
            }
        }

        /* Hover State Isolation for Touch (1/8 but critical) */
        @media (hover: hover) and (pointer: fine) {
            .discover-galaxy-btn:hover { transform: scale(1.05); }
            .galaxy-card:hover { transform: translateY(-5px); box-shadow: 0 10px 40px rgba(191,0,255,0.3); }
            .data-controls button:hover { background: rgba(0,255,255,0.3); box-shadow: 0 0 10px rgba(0,255,255,0.5); }
            .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
            .equip-slot:hover { border-color: #fb0; background: #2a2a3a; }
            .ability-slot:hover:not(.locked):not(.on-cooldown) { border-color: #0ff; transform: translateY(-3px) scale(1.05); }
            .craft-btn:hover { background: rgba(0,255,0,0.3); }
            .action-btn:hover { box-shadow: 0 0 15px rgba(0,200,255,0.5); }
            .codex-entry:hover { border-color: #0ff; }
        }

        /* Remove hover effects on touch devices */
        @media (hover: none) {
            .discover-galaxy-btn:hover,
            .galaxy-card:hover,
            .data-controls button:hover,
            .inv-slot:hover,
            .equip-slot:hover,
            .ability-slot:hover,
            .craft-btn:hover,
            .action-btn:hover,
            .codex-entry:hover {
                transform: none !important;
                box-shadow: inherit !important;
            }
        }

        /* Full-screen Modals on Mobile (2/8 consensus) */
        @media (max-width: 768px) {
            .modal-content {
                width: 100% !important;
                max-width: 100% !important;
                max-height: var(--app-height);
                height: 100%;
                border-radius: 0;
                margin: 0;
            }

            .galaxy-manager-container {
                padding: 15px;
                padding-top: calc(15px + var(--safe-top));
                padding-bottom: calc(60px + var(--safe-bottom));
            }

            .galaxy-grid {
                grid-template-columns: 1fr;
            }

            /* Typography fixes (1/8 but important) */
            .stat-lbl { font-size: 11px !important; color: #999 !important; }
            .gc-stat-label { font-size: 10px !important; color: #aaa !important; }
            .galaxy-card-seed { font-size: 10px !important; color: #999 !important; }
            .galaxy-card-meta { font-size: 11px !important; color: #999 !important; }
        }

        /* iOS Momentum Scrolling */
        .galaxy-manager-modal,
        .modal-content,
        .codex-grid,
        .quest-list,
        .rpg-ui {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        /* v6.89: Mobile UI - All panels draggable (drag off-screen to hide) */
        @media (max-width: 768px), (pointer: coarse) {
            /* Hide keyboard ability bar on mobile - we have touch ability buttons */
            #ability-bar {
                display: none !important;
            }

            /* Make draggable panels compact on mobile */
            .draggable-panel {
                transform: scale(0.85) !important;
                transform-origin: top left;
            }

            /* Smaller drag handles on mobile */
            .draggable-panel .drag-handle {
                height: 22px;
            }

            /* Larger touch target for minimize button on mobile */
            .draggable-panel > .minimize-btn {
                width: 32px;
                height: 32px;
                font-size: 20px;
                right: 2px;
                top: -5px;
            }

            /* Minimized panels on mobile - even more compact */
            .draggable-panel.minimized {
                transform: scale(1) !important;
                min-height: 22px !important;
                height: 22px !important;
            }

            /* Compact AI Behavior panel */
            #ai-behavior-panel {
                max-width: 140px !important;
                font-size: 9px !important;
            }

            /* Compact Daily Challenge panel */
            .daily-challenge-box,
            #daily-challenge {
                max-width: 130px !important;
                font-size: 9px !important;
            }

            /* Compact Ship Status */
            #ship-status {
                max-width: 140px !important;
                font-size: 9px !important;
            }

            /* Move data controls higher to not overlap with touch controls */
            .data-controls {
                bottom: calc(180px + var(--safe-bottom, 0px)) !important;
                left: 5px !important;
                right: 5px !important;
                padding: 5px !important;
                gap: 4px !important;
            }

            .data-controls button {
                padding: 6px 10px !important;
                font-size: 10px !important;
                min-height: 36px !important;
            }

            /* Smaller minimap on mobile */
            .minimap,
            #minimap-container {
                width: 60px !important;
                height: 60px !important;
            }

            /* Compact HP/MP bars */
            #player-dota-bars-ui {
                transform: scale(0.8) !important;
                transform-origin: center bottom;
            }

            /* Compact companion health */
            .companion-health-container {
                max-width: 130px !important;
                font-size: 10px !important;
            }

            /* Compact environment widget */
            #environment-widget {
                max-width: 130px !important;
                font-size: 9px !important;
            }

            /* Hide weather indicator on mobile (less critical) */
            #weather-indicator {
                display: none !important;
            }

            /* RTS toggles - hide on mobile */
            .rts-panel-toggles {
                display: none !important;
            }

            /* Smaller HUD top */
            .hud-top {
                padding: 5px 8px !important;
                gap: 5px !important;
            }

            .game-title {
                font-size: 14px !important;
            }

            .subtitle {
                display: none !important;
            }

            /* Hide stat entries in galaxy controls on mobile */
            #galaxy-controls .stat-entry:not(:first-child) {
                display: none !important;
            }

            /* Smaller buttons in HUD */
            .discover-galaxy-btn,
            .galaxy-manager-btn {
                padding: 4px 8px !important;
                font-size: 10px !important;
            }

            /* Compact restore tabs on mobile */
            .panel-restore-tab {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }

            /* Reset button styling for mobile */
            .reset-panels-btn {
                font-size: 10px;
                padding: 4px 8px;
            }
        }

        /* Extra small screens (iPhone SE, etc) */
        @media (max-width: 375px) {
            .data-controls {
                bottom: calc(160px + var(--safe-bottom, 0px)) !important;
            }

            .data-controls button {
                padding: 4px 6px !important;
                font-size: 9px !important;
            }

            .touch-ability-bar {
                right: 10px !important;
                bottom: calc(180px + var(--safe-bottom, 0px)) !important;
            }

            .touch-ability-btn {
                width: 44px !important;
                height: 44px !important;
            }

            .touch-ability-icon {
                font-size: 18px !important;
            }

            .virtual-joystick, #virtual-joystick {
                width: 80px !important;
                height: 80px !important;
            }

            .touch-action-btn {
                width: 55px !important;
                height: 55px !important;
            }

            .touch-dodge-btn {
                width: 50px !important;
                height: 50px !important;
            }
        }

        /* v6.89: Universal Draggable Panel System - Drag panels off-screen to maximize game area */
        .draggable-panel {
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: height 0.25s ease, min-height 0.25s ease, padding 0.25s ease;
        }

        .draggable-panel.dragging {
            cursor: grabbing;
            opacity: 0.85;
            z-index: 10000 !important;
        }

        .draggable-panel .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: linear-gradient(180deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.03) 100%);
            border-radius: 8px 8px 0 0;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .draggable-panel .drag-handle .drag-grip {
            width: 30px;
            height: 4px;
            background: rgba(255,255,255,0.35);
            border-radius: 2px;
        }

        .draggable-panel .drag-handle .panel-title {
            font-size: 9px;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80px;
        }

        .draggable-panel > .minimize-btn {
            position: absolute;
            right: 4px;
            top: 2px;
            width: 20px;
            height: 20px;
            background: rgba(100, 180, 255, 0.35);
            border: 1px solid rgba(100, 180, 255, 0.6);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #aaddff;
            transition: all 0.15s ease;
            padding: 0;
            line-height: 1;
            z-index: 10001;
            pointer-events: auto !important;
            -webkit-tap-highlight-color: rgba(100, 180, 255, 0.5);
            touch-action: manipulation;
        }

        .draggable-panel > .minimize-btn:hover {
            background: rgba(100, 180, 255, 0.5);
            border-color: rgba(100, 180, 255, 0.9);
            color: #fff;
            transform: scale(1.15);
        }

        .draggable-panel > .minimize-btn:active {
            transform: scale(0.9);
            background: rgba(100, 180, 255, 0.7);
        }

        /* Keep button visible when minimized */
        .draggable-panel.minimized > .minimize-btn {
            display: flex !important;
        }

        /* Minimized panel state */
        .draggable-panel.minimized {
            min-height: 24px !important;
            height: 24px !important;
            overflow: visible !important;
            padding-bottom: 0 !important;
        }

        .draggable-panel.minimized .drag-handle {
            border-radius: 8px;
        }

        .draggable-panel.minimized .panel-content-wrapper {
            display: none !important;
        }

        /* Hide all children except drag-handle and minimize-btn when minimized */
        .draggable-panel.minimized > *:not(.drag-handle):not(.minimize-btn) {
            display: none !important;
        }

        .draggable-panel.dragging .drag-handle {
            cursor: grabbing;
        }

        /* Visual indicator when panel is near edge (about to hide) */
        .draggable-panel.near-edge {
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.5) !important;
        }

        /* Collapsed panel indicator - shows as small tab on edge */
        .panel-restore-tab {
            position: fixed;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, rgba(30,40,60,0.95), rgba(20,30,45,0.95));
            border: 2px solid rgba(100, 180, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4);
        }

        .panel-restore-tab:hover {
            transform: scale(1.1);
            border-color: rgba(100, 180, 255, 0.8);
            box-shadow: 0 4px 15px rgba(100, 180, 255, 0.3);
        }

        .panel-restore-tab:active {
            transform: scale(0.95);
        }

        /* Reset all panels button */
        .reset-panels-btn {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 12px;
            background: rgba(30,40,60,0.9);
            border: 1px solid rgba(100, 180, 255, 0.4);
            border-radius: 6px;
            color: #88bbff;
            font-size: 11px;
            cursor: pointer;
            z-index: 10001;
            display: none;
            transition: all 0.2s ease;
        }

        .reset-panels-btn:hover {
            background: rgba(50,70,100,0.95);
            border-color: rgba(100, 180, 255, 0.7);
        }

        .reset-panels-btn.visible {
            display: block;
        }

        /* v6.32: Smooth transitions for UI panels */
        #ship-status,
        #daily-challenge-panel,
        #weather-indicator,
        .rts-command-bar,
        .copilot-button,
        #copilot-chat {
            transition: opacity 0.3s ease-out, transform 0.3s ease-out, top 0.3s ease-out, bottom 0.3s ease-out, left 0.3s ease-out, right 0.3s ease-out !important;
        }

        /* v6.73: Companion Health Display - Fixed name truncation */
        /* v6.81: Fixed positioning to prevent overlap with environment widget */
        .companion-health-container {
            position: fixed;
            bottom: 355px;
            right: 10px;
            width: 195px;  /* Wide enough for "ECHO (Gen 1)" + "Bond: 5%" */
            background: linear-gradient(180deg, rgba(12,16,24,0.95) 0%, rgba(6,10,18,0.98) 100%);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 14px;
            padding: 12px 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.55), 0 0 12px rgba(138, 43, 226, 0.15), inset 0 1px 0 rgba(255,255,255,0.05);
        }

        .companion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.2);
        }

        .companion-name {
            font-size: 13px;
            font-weight: 700;
            color: #a855f7;
            white-space: nowrap;
            text-shadow: 0 0 8px rgba(168, 85, 247, 0.5);
            /* Removed overflow/ellipsis to show full name */
        }

        .companion-bond {
            font-size: 12px;
            color: #22d3ee;
            font-weight: 600;
            white-space: nowrap;
            text-shadow: 0 0 6px rgba(34, 211, 238, 0.4);
        }

        .companion-hp-container {
            position: relative;
            height: 16px;  /* Slightly increased for better readability */
            background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(138, 43, 226, 0.35);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .companion-hp-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(180deg, #c084fc 0%, #a855f7 50%, #7c3aed 100%);
            border-radius: 3px;
            transition: width 0.3s ease, background-color 0.3s ease;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
        }

        .companion-hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;  /* Increased from 10px */
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px #000, -1px -1px 2px #000, 0 0 4px #000;
            letter-spacing: 0.3px;
        }

        .companion-memorial-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid #555;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        }

        .companion-memorial-btn:hover {
            background: rgba(255, 68, 68, 0.5);
            transform: scale(1.1);
        }

        /* v6.65: Hide companion health in galaxy/approach modes */
        .companion-health-container.hidden {
            display: none !important;
        }

        /* v5.10: RTS-Style Command Bar - Compact Bottom-Right Toolbar */
        .rts-command-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1002;
            pointer-events: auto;
        }

        /* v5.6: Copilot Companion System Styles - RTS Compact */
        .copilot-button {
            width: 44px;
            height: 44px;
            background: rgba(138, 43, 226, 0.4);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(138, 43, 226, 0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(138, 43, 226, 0.3);
        }

        .copilot-button:hover {
            background: rgba(138, 43, 226, 0.6);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.5);
        }

        .copilot-button.active {
            background: rgba(6, 255, 165, 0.5);
            border-color: rgba(6, 255, 165, 0.9);
            box-shadow: 0 2px 15px rgba(6, 255, 165, 0.4);
        }

        .copilot-button svg {
            width: 22px;
            height: 22px;
            color: white;
        }

        .copilot-chat-interface {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 320px;
            height: 380px;
            background: rgba(8, 12, 20, 0.96);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            pointer-events: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .copilot-chat-interface.active {
            display: flex;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-chat-header {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.1));
            border-radius: 14px 14px 0 0;
        }

        .copilot-chat-title {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .copilot-chat-title::before {
            content: '';
        }

        .copilot-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 0 5px;
        }

        .copilot-close-btn:hover {
            opacity: 1;
            color: #ff6a88;
            transform: rotate(90deg);
        }

        .copilot-chat-messages {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .copilot-message {
            margin: 8px 0;
            padding: 10px 12px;
            border-radius: 12px;
            max-width: 90%;
            word-wrap: break-word;
            font-size: 13px;
            line-height: 1.5;
            animation: message-slide 0.3s ease;
        }

        @keyframes message-slide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-message.user {
            background: rgba(138, 43, 226, 0.3);
            margin-left: auto;
            text-align: right;
            border: 1px solid rgba(138, 43, 226, 0.4);
        }

        .copilot-message.ai {
            background: rgba(6, 255, 165, 0.15);
            margin-right: auto;
            border: 1px solid rgba(6, 255, 165, 0.3);
            text-align: left;
        }

        /* v5.9: Markdown formatting in chat messages */
        .copilot-message.ai a {
            color: #06ffa5;
            text-decoration: underline;
            cursor: pointer;
            word-break: break-word;
        }

        .copilot-message.ai a:hover {
            color: #4fffbc;
            text-decoration: none;
        }

        .copilot-message.ai strong, .copilot-message.ai b {
            color: #fff;
            font-weight: 600;
        }

        .copilot-message.ai em, .copilot-message.ai i {
            font-style: italic;
            color: #ccc;
        }

        .copilot-message.ai code {
            background: rgba(0, 0, 0, 0.4);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: #ff9500;
        }

        .copilot-message.ai pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 6px 0;
            font-size: 11px;
        }

        .copilot-message.ai pre code {
            background: none;
            padding: 0;
        }

        .copilot-message.ai ul, .copilot-message.ai ol {
            margin: 6px 0;
            padding-left: 18px;
        }

        .copilot-message.ai li {
            margin: 3px 0;
        }

        .copilot-message.ai h1, .copilot-message.ai h2, .copilot-message.ai h3 {
            margin: 8px 0 4px 0;
            color: #06ffa5;
            font-size: 14px;
        }

        .copilot-message.ai h1 { font-size: 15px; }
        .copilot-message.ai h2 { font-size: 14px; }
        .copilot-message.ai h3 { font-size: 13px; }

        .copilot-message.ai hr {
            border: none;
            border-top: 1px solid rgba(6, 255, 165, 0.3);
            margin: 8px 0;
        }

        .copilot-message.ai blockquote {
            border-left: 3px solid #06ffa5;
            padding-left: 10px;
            margin: 6px 0;
            color: #aaa;
            font-style: italic;
        }

        .copilot-message.ai p {
            margin: 4px 0;
        }

        .copilot-message.ai p:first-child {
            margin-top: 0;
        }

        .copilot-message.ai p:last-child {
            margin-bottom: 0;
        }

        .copilot-typing {
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(6, 255, 165, 0.15);
            display: flex;
            align-items: center;
            gap: 5px;
            width: fit-content;
            margin: 10px 0;
        }

        .copilot-typing-dot {
            width: 7px;
            height: 7px;
            background: rgba(6, 255, 165, 0.7);
            border-radius: 50%;
            animation: typing-pulse 1.4s infinite ease-in-out;
        }

        .copilot-typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .copilot-typing-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing-pulse {
            0%, 80%, 100% { transform: scale(0.7); opacity: 0.4; }
            40% { transform: scale(1); opacity: 1; }
        }

        .copilot-chat-input-container {
            padding: 12px;
            border-top: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .copilot-chat-input {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 20px;
            color: white;
            font-size: 13px;
            outline: none;
            transition: all 0.2s;
        }

        .copilot-chat-input:focus {
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }

        .copilot-chat-send {
            background: linear-gradient(135deg, #8a2be2, #06ffa5);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s;
        }

        .copilot-chat-send:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(6, 255, 165, 0.4);
        }

        /* v5.9: Hotkey hint */
        .copilot-hotkey-hint {
            font-size: 10px;
            color: #666;
            text-align: center;
            padding: 6px 12px 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .copilot-hotkey-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 10px;
            color: #06ffa5;
        }

        /* v5.9: Copilot Task System UI - RTS Compact Style */
        .copilot-task-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(138, 43, 226, 0.6);
            border-radius: 8px;
            padding: 10px 14px;
            min-width: 180px;
            max-width: 220px;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.4);
        }

        .copilot-task-panel.active {
            display: block;
            animation: task-slide-in 0.2s ease;
        }

        @keyframes task-slide-in {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .copilot-task-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .copilot-task-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #06ffa5;
            font-weight: 600;
        }

        .copilot-task-title .task-icon {
            font-size: 18px;
        }

        .copilot-task-recall {
            background: rgba(255, 68, 68, 0.3);
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-task-recall:hover {
            background: rgba(255, 68, 68, 0.5);
            color: #fff;
        }

        .copilot-task-status {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .copilot-task-progress {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .copilot-task-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #06ffa5);
            border-radius: 3px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.5);
        }

        .copilot-task-progress-bar.hunting {
            background: linear-gradient(90deg, #ff4444, #ff8800);
        }

        .copilot-task-progress-bar.scouting {
            background: linear-gradient(90deg, #4488ff, #44ffff);
        }

        .copilot-task-progress-bar.protecting {
            background: linear-gradient(90deg, #ffcc00, #ff8800);
            animation: protect-pulse 1.5s infinite;
        }

        @keyframes protect-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .copilot-task-results {
            font-size: 11px;
            color: #888;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
            margin-top: 4px;
        }

        .copilot-task-results .result-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 3px 0;
        }

        .copilot-task-results .result-item.positive {
            color: #06ffa5;
        }

        /* Task indicator on copilot button */
        .copilot-button.has-task::after {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            background: #06ffa5;
            border-radius: 50%;
            animation: task-indicator-pulse 1s infinite;
        }

        @keyframes task-indicator-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* Copilot visual state when on task */
        .copilot-on-task {
            filter: hue-rotate(60deg);
        }

        /* v5.10: Multi-Agent Fleet System - RTS Style */
        .agent-fleet-panel {
            position: fixed;
            top: 60px;
            right: 0;
            background: rgba(5, 8, 15, 0.95);
            border-left: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 0;
            width: 280px;
            max-height: calc(100vh - 120px);
            z-index: 1001;
            display: none;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .agent-fleet-panel.active {
            display: flex;
            flex-direction: column;
            animation: fleet-slide-in 0.25s ease;
        }

        @keyframes fleet-slide-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }

        .agent-fleet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.05));
            border-bottom: 1px solid rgba(138, 43, 226, 0.4);
        }

        .agent-fleet-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
        }

        .agent-fleet-title span.icon {
            font-size: 16px;
        }

        .agent-fleet-count {
            font-size: 10px;
            color: #06ffa5;
            background: rgba(6, 255, 165, 0.12);
            padding: 2px 6px;
            border-radius: 8px;
        }

        .agent-fleet-close {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 2px;
        }

        .agent-fleet-close:hover {
            color: #ff4444;
        }

        .agent-fleet-spawn {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .agent-spawn-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .agent-spawn-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 2px;
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .agent-spawn-btn:hover:not(:disabled) {
            background: rgba(138, 43, 226, 0.35);
            border-color: #06ffa5;
        }

        .agent-spawn-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .agent-spawn-btn .icon {
            font-size: 18px;
        }

        .agent-spawn-btn .label {
            font-size: 8px;
            color: #888;
            text-align: center;
        }

        .agent-fleet-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
        }

        .agent-card {
            background: rgba(15, 18, 25, 0.9);
            border: 1px solid rgba(138, 43, 226, 0.25);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .agent-card:hover {
            border-color: rgba(6, 255, 165, 0.5);
        }

        .agent-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .agent-identity {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .agent-avatar {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
        }

        .agent-info {
            display: flex;
            flex-direction: column;
        }

        .agent-name {
            font-size: 11px;
            font-weight: 600;
            color: #fff;
        }

        .agent-role {
            font-size: 9px;
            color: #666;
        }

        .agent-actions {
            display: flex;
            gap: 4px;
        }

        .agent-action-btn {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
            color: #666;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .agent-action-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #aaa;
        }

        .agent-action-btn.recall {
            border-color: rgba(255, 68, 68, 0.3);
        }

        .agent-action-btn.recall:hover {
            background: rgba(255, 68, 68, 0.25);
            border-color: #ff4444;
            color: #ff4444;
        }

        .agent-card-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 10px;
            color: #888;
        }

        .agent-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #06ffa5;
            animation: pulse 1.5s infinite;
        }

        .agent-status-dot.thinking {
            background: #ffaa00;
        }

        .agent-status-dot.idle {
            background: #666;
            animation: none;
        }

        .agent-card-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .agent-progress-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .agent-last-msg {
            font-size: 11px;
            color: #666;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-results-mini {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .agent-result-tag {
            font-size: 10px;
            background: rgba(6, 255, 165, 0.15);
            color: #06ffa5;
            padding: 2px 6px;
            border-radius: 8px;
        }

        /* v5.15: Real-time Agent Transcript Viewer */
        .agent-transcript-toggle {
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: #668;
            font-size: 10px;
            transition: color 0.2s;
        }

        .agent-transcript-toggle:hover {
            color: #0af;
        }

        .agent-transcript-toggle .expand-icon {
            transition: transform 0.2s;
        }

        .agent-transcript-toggle.expanded .expand-icon {
            transform: rotate(90deg);
        }

        .agent-transcript-viewer {
            display: none;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(0, 170, 255, 0.2);
            max-height: 300px;
            overflow-y: auto;
        }

        .agent-transcript-viewer.expanded {
            display: block;
        }

        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(0, 170, 255, 0.1);
            border-bottom: 1px solid rgba(0, 170, 255, 0.2);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .transcript-header-title {
            font-size: 10px;
            color: #0af;
            font-weight: bold;
        }

        .transcript-message-count {
            font-size: 9px;
            color: #666;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        .transcript-messages {
            padding: 6px;
        }

        .transcript-msg {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .transcript-msg.system {
            background: rgba(128, 128, 128, 0.2);
            border-left: 2px solid #888;
            color: #999;
        }

        .transcript-msg.user {
            background: rgba(0, 170, 255, 0.15);
            border-left: 2px solid #0af;
            color: #8cf;
        }

        .transcript-msg.assistant {
            background: rgba(6, 255, 165, 0.15);
            border-left: 2px solid #06ffa5;
            color: #8fc;
        }

        .transcript-msg-role {
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 2px;
            opacity: 0.7;
        }

        .transcript-msg-content {
            white-space: pre-wrap;
            max-height: 100px;
            overflow-y: auto;
        }

        .transcript-msg-content.truncated {
            max-height: 60px;
        }

        .transcript-empty {
            text-align: center;
            color: #555;
            padding: 20px;
            font-style: italic;
        }

        .transcript-live-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            margin-left: 4px;
            animation: pulse 1s infinite;
        }

        /* v5.15.2: Try Again Replay System */
        .try-again-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
            border-radius: 4px;
            color: #ffaa00;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .try-again-btn:hover {
            background: rgba(255, 170, 0, 0.35);
            box-shadow: 0 0 8px rgba(255, 170, 0, 0.3);
        }

        .try-again-btn.replaying {
            background: rgba(0, 170, 255, 0.2);
            border-color: #0af;
            color: #0af;
            animation: pulse 1s infinite;
        }

        .replay-comparison {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }

        .replay-comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .replay-comparison-title {
            font-size: 10px;
            color: #ffaa00;
            font-weight: bold;
        }

        .replay-branch-indicator {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(255, 68, 68, 0.2);
            color: #f88;
        }

        .replay-branch-indicator.same {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
        }

        .replay-side-by-side {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .replay-column {
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .replay-column-label {
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .replay-column.original .replay-column-label {
            color: #888;
        }

        .replay-column.retry .replay-column-label {
            color: #0af;
        }

        .replay-content {
            font-size: 9px;
            color: #aaa;
            max-height: 80px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .replay-diff {
            background: rgba(255, 255, 0, 0.1);
            border-left: 2px solid #ff0;
        }

        .replay-actions {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        .replay-action-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 9px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-action-btn.use-original {
            background: rgba(128, 128, 128, 0.2);
            border: 1px solid #888;
            color: #888;
        }

        .replay-action-btn.use-retry {
            background: rgba(0, 170, 255, 0.2);
            border: 1px solid #0af;
            color: #0af;
        }

        .replay-action-btn:hover {
            filter: brightness(1.2);
        }

        /* v5.16.1: Agent Body Cam Preview */
        /* v5.16.2: Agent Takeover / Remote Control System */
        .agent-bodycam-container {
            margin: 8px 0;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(0, 170, 255, 0.3);
            background: #000;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .agent-bodycam-container:hover {
            border-color: #0af;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.3);
        }

        .agent-bodycam-container.expanded-view {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            max-width: 900px;
            height: 60vh;
            max-height: 600px;
            z-index: 2000;
            border: 3px solid #0af;
            box-shadow: 0 0 50px rgba(0, 170, 255, 0.5);
            margin: 0;
        }

        .agent-bodycam-canvas {
            width: 100%;
            height: 150px;
            display: block;
            object-fit: cover;
        }

        .agent-bodycam-container.expanded-view .agent-bodycam-canvas {
            height: 100%;
        }

        .agent-bodycam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 6px 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .agent-bodycam-label {
            font-size: 10px;
            color: #0af;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .agent-bodycam-label .rec-dot {
            width: 8px;
            height: 8px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1s infinite;
            box-shadow: 0 0 8px #f00;
        }

        .agent-bodycam-status {
            font-size: 9px;
            color: #888;
            background: rgba(0,0,0,0.5);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* v5.16.2: Agent HUD overlay */
        .agent-pov-hud {
            position: absolute;
            top: 30px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .agent-pov-stats {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(0, 170, 255, 0.3);
        }

        .agent-pov-hp-bar {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .agent-pov-hp-fill {
            height: 100%;
            background: linear-gradient(to right, #0f0, #8f0);
            transition: width 0.3s;
        }

        .agent-pov-hp-fill.low { background: linear-gradient(to right, #ff0, #f80); }
        .agent-pov-hp-fill.critical { background: linear-gradient(to right, #f44, #f00); }

        .agent-pov-hp-text {
            font-size: 8px;
            color: #aaa;
            text-align: center;
        }

        .agent-pov-target {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 9px;
            color: #f88;
        }

        .agent-pov-target.resource {
            background: rgba(255, 200, 0, 0.2);
            border-color: rgba(255, 200, 0, 0.5);
            color: #fc8;
        }

        /* Crosshair */
        .agent-pov-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .agent-pov-crosshair::before,
        .agent-pov-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.5);
        }

        .agent-pov-crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .agent-pov-crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .agent-bodycam-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 6px 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .agent-bodycam-coords {
            font-size: 10px;
            color: #0f0;
            font-family: monospace;
        }

        .agent-bodycam-action {
            font-size: 10px;
            color: #ff0;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .agent-bodycam-controls {
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .agent-bodycam-container:hover .agent-bodycam-controls {
            opacity: 1;
        }

        .agent-pov-btn {
            padding: 6px 12px;
            font-size: 10px;
            border-radius: 4px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 0, 0, 0.7);
        }

        .agent-pov-btn.locate {
            border-color: #0af;
            color: #0af;
        }

        .agent-pov-btn.takeover {
            border-color: #f80;
            color: #f80;
        }

        .agent-pov-btn.close {
            border-color: #888;
            color: #888;
        }

        /* v5.17.1: Pop-out button style */
        .agent-pov-btn.popout {
            border-color: #a855f7;
            color: #a855f7;
        }

        .agent-pov-btn:hover {
            filter: brightness(1.3);
            transform: scale(1.05);
        }

        .agent-bodycam-click-hint {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            font-size: 10px;
            color: #fff;
            background: rgba(0, 170, 255, 0.8);
            padding: 4px 10px;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .agent-bodycam-container:hover:not(.expanded-view) .agent-bodycam-click-hint {
            opacity: 1;
        }

        /* Fullscreen backdrop */
        .agent-pov-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1999;
        }

        /* v5.16.2: Agent Takeover Flyout Window */
        .agent-takeover-flyout {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 400px;
            height: calc(100vh - 100px);
            max-height: 600px;
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.98), rgba(5, 15, 30, 0.98));
            border: 2px solid #f80;
            border-radius: 12px;
            z-index: 2500;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 40px rgba(255, 136, 0, 0.4), inset 0 0 60px rgba(255, 136, 0, 0.05);
            overflow: hidden;
            animation: flyoutSlideIn 0.3s ease-out;
        }

        @keyframes flyoutSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .takeover-header {
            background: linear-gradient(to bottom, rgba(255, 136, 0, 0.2), rgba(255, 136, 0, 0.05));
            border-bottom: 1px solid rgba(255, 136, 0, 0.3);
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .takeover-title {
            font-size: 14px;
            font-weight: bold;
            color: #f80;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .takeover-title .agent-icon {
            font-size: 18px;
        }

        .takeover-close-btn {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            color: #f88;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .takeover-close-btn:hover {
            background: rgba(255, 68, 68, 0.4);
            border-color: #f44;
        }

        .takeover-viewport {
            flex: 1;
            position: relative;
            background: #000;
            min-height: 200px;
        }

        .takeover-viewport canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Takeover HUD Overlay */
        .takeover-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .takeover-hud-top {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .takeover-agent-stats {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 136, 0, 0.3);
        }

        .takeover-hp-bar {
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .takeover-hp-fill {
            height: 100%;
            background: linear-gradient(to right, #0f0, #8f0);
            transition: width 0.3s;
        }

        .takeover-hp-fill.low { background: linear-gradient(to right, #ff0, #f80); }
        .takeover-hp-fill.critical { background: linear-gradient(to right, #f44, #f00); animation: pulse 0.5s infinite; }

        .takeover-hp-text {
            font-size: 10px;
            color: #0f0;
            text-align: center;
            margin-top: 2px;
        }

        .takeover-agent-info {
            font-size: 10px;
            color: #aaa;
            margin-top: 4px;
        }

        .takeover-target-info {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.4);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 10px;
            color: #f88;
        }

        .takeover-target-info.resource {
            background: rgba(0, 255, 0, 0.1);
            border-color: rgba(0, 255, 0, 0.3);
            color: #8f8;
        }

        .takeover-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
        }

        .takeover-crosshair::before,
        .takeover-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 136, 0, 0.6);
        }

        .takeover-crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .takeover-crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .takeover-status-badge {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 136, 0, 0.9);
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        /* Takeover Controls Panel */
        .takeover-controls {
            background: rgba(0, 0, 0, 0.6);
            border-top: 1px solid rgba(255, 136, 0, 0.3);
            padding: 10px;
        }

        .takeover-controls-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .takeover-controls-row:last-child {
            margin-bottom: 0;
        }

        .takeover-control-btn {
            flex: 1;
            padding: 8px 10px;
            font-size: 10px;
            border-radius: 4px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .takeover-control-btn.primary {
            border-color: #f80;
            color: #f80;
        }

        .takeover-control-btn.primary:hover {
            background: rgba(255, 136, 0, 0.2);
        }

        .takeover-control-btn.secondary {
            border-color: #0af;
            color: #0af;
        }

        .takeover-control-btn.secondary:hover {
            background: rgba(0, 170, 255, 0.2);
        }

        .takeover-control-btn.danger {
            border-color: #f44;
            color: #f44;
        }

        .takeover-control-btn.danger:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        .takeover-control-btn.action {
            border-color: #0f0;
            color: #0f0;
        }

        .takeover-control-btn.action:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .takeover-control-btn:active {
            transform: scale(0.95);
        }

        .takeover-keybind {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 9px;
            margin-left: 4px;
        }

        /* WASD Indicator */
        .takeover-wasd {
            display: flex;
            justify-content: center;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 90px;
            margin: 0 auto;
        }

        .takeover-wasd-key {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #888;
            transition: all 0.1s;
        }

        .takeover-wasd-key.active {
            background: rgba(255, 136, 0, 0.5);
            border-color: #f80;
            color: #fff;
            box-shadow: 0 0 10px rgba(255, 136, 0, 0.3);
        }

        .takeover-wasd-spacer {
            width: 24px;
            height: 24px;
        }

        /* Active control indicator */
        .takeover-active-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 136, 0, 0.9);
            color: #000;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 2600;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 20px rgba(255, 136, 0, 0.5);
        }

        .takeover-active-indicator .pulse {
            width: 8px;
            height: 8px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        /* Fleet button - RTS Compact Style */
        .fleet-button {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(68, 170, 255, 0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            box-shadow: 0 2px 10px rgba(68, 170, 255, 0.2);
            position: relative;
        }

        .fleet-button:hover {
            transform: scale(1.05);
            border-color: #06ffa5;
            background: rgba(30, 45, 70, 0.9);
        }

        .fleet-button.has-agents {
            border-color: #06ffa5;
            box-shadow: 0 2px 15px rgba(6, 255, 165, 0.3);
        }

        .fleet-button.has-agents::after {
            content: attr(data-count);
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 16px;
            height: 16px;
            background: #06ffa5;
            color: #000;
            font-size: 10px;
            font-weight: 700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Agent colors */
        .agent-color-gatherer { color: #44ff88; }
        .agent-color-hunter { color: #ff4444; }
        .agent-color-scout { color: #44aaff; }
        .agent-color-protector { color: #ffcc00; }
        .agent-color-healer { color: #ff88ff; }
        .agent-color-fisher { color: #44ffff; }
        .agent-color-miner { color: #ffaa44; }
        .agent-color-explorer { color: #aa88ff; }
        /* v5.18: Construction agents */
        .agent-color-terraformer { color: #cd853f; }  /* v6.82: Brightened for better contrast */
        .agent-color-builder { color: #00bfff; }
        /* v6.85: MEMENTO MORI - The Archivist */
        .agent-color-archivist { color: #8b0000; }

        /* v6.85: Archivist Death Greeting Overlay */
        .archivist-greeting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10003;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        .archivist-greeting-overlay.active {
            display: flex;
            animation: archivistFadeIn 1s ease;
        }
        @keyframes archivistFadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .archivist-greeting-content {
            background: linear-gradient(135deg, #0a0505 0%, #1a0a0a 50%, #0a0a0a 100%);
            border: 2px solid #8b0000;
            border-radius: 20px;
            width: 94%;
            max-width: 600px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow:
                0 0 60px rgba(139, 0, 0, 0.4),
                0 0 100px rgba(139, 0, 0, 0.2),
                inset 0 0 60px rgba(139, 0, 0, 0.1);
            position: relative;
        }
        .archivist-greeting-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(139, 0, 0, 0.08) 0%, transparent 50%);
            animation: ai-glow-rotate 20s linear infinite;
            pointer-events: none;
        }
        .archivist-header {
            padding: 30px 25px 20px;
            text-align: center;
            position: relative;
            z-index: 1;
            border-bottom: 1px solid rgba(139, 0, 0, 0.3);
        }
        .archivist-icon {
            font-size: 48px;
            margin-bottom: 15px;
            filter: drop-shadow(0 0 20px rgba(139, 0, 0, 0.8));
        }
        .archivist-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
            font-family: Georgia, serif;
            letter-spacing: 3px;
        }
        .archivist-subtitle {
            color: #666;
            font-size: 12px;
            margin-top: 8px;
            font-style: italic;
        }
        .archivist-body {
            padding: 25px;
            position: relative;
            z-index: 1;
        }
        .archivist-message {
            color: #cc8888;
            font-size: 16px;
            line-height: 1.8;
            text-align: center;
            margin-bottom: 20px;
            font-style: italic;
        }
        .archivist-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .archivist-stat {
            background: rgba(139, 0, 0, 0.15);
            border: 1px solid rgba(139, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px 10px;
            text-align: center;
        }
        .archivist-stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }
        .archivist-stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }
        .archivist-observation {
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid #8b0000;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .archivist-observation-header {
            font-size: 11px;
            color: #8b0000;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        .archivist-observation-text {
            color: #ffaaaa;
            font-size: 14px;
            line-height: 1.6;
        }
        .archivist-footer {
            padding: 20px 25px;
            border-top: 1px solid rgba(139, 0, 0, 0.2);
            text-align: center;
            position: relative;
            z-index: 1;
        }
        .archivist-continue-btn {
            background: linear-gradient(135deg, #8b0000, #660000);
            border: none;
            color: #fff;
            padding: 12px 40px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .archivist-continue-btn:hover {
            background: linear-gradient(135deg, #aa0000, #880000);
            box-shadow: 0 0 30px rgba(139, 0, 0, 0.5);
            transform: scale(1.05);
        }
        .archivist-killer-info {
            color: #ff6666;
            font-size: 13px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 68, 68, 0.1);
            border-radius: 8px;
        }
        .archivist-killer-info strong {
            color: #ff4444;
        }

        /* Agent transcript export */
        .agent-action-btn.export {
            border-color: rgba(68, 170, 255, 0.4);
        }

        .agent-action-btn.export:hover {
            background: rgba(68, 170, 255, 0.3);
            border-color: #44aaff;
            color: #44aaff;
        }

        .fleet-export-btn {
            background: rgba(68, 170, 255, 0.2);
            border: 1px solid rgba(68, 170, 255, 0.4);
            color: #44aaff;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 8px;
        }

        .fleet-export-btn:hover {
            background: rgba(68, 170, 255, 0.4);
            color: #fff;
        }

        .fleet-import-btn {
            background: rgba(106, 255, 165, 0.2);
            border: 1px solid rgba(106, 255, 165, 0.4);
            color: #06ffa5;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .fleet-import-btn:hover {
            background: rgba(106, 255, 165, 0.4);
            color: #fff;
        }

        /* Transcript viewer modal - RTS Style */
        .transcript-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .transcript-modal.active {
            display: flex;
            animation: fade-in 0.15s ease;
        }

        .transcript-modal-content {
            background: rgba(10, 12, 20, 0.98);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6);
        }

        .transcript-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(68, 170, 255, 0.1));
            border-bottom: 1px solid rgba(138, 43, 226, 0.5);
        }

        .transcript-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .transcript-modal-actions {
            display: flex;
            gap: 8px;
        }

        .transcript-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .transcript-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .transcript-action-btn.primary {
            background: rgba(68, 170, 255, 0.3);
            border-color: #44aaff;
            color: #44aaff;
        }

        .transcript-action-btn.primary:hover {
            background: rgba(68, 170, 255, 0.5);
            color: #fff;
        }

        .transcript-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-json {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.5;
            background: #0d0d1a;
            border-radius: 8px;
            padding: 16px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 60vh;
            overflow-y: auto;
        }

        .transcript-json .key { color: #ff88ff; }
        .transcript-json .string { color: #06ffa5; }
        .transcript-json .number { color: #44aaff; }
        .transcript-json .boolean { color: #ffcc00; }
        .transcript-json .null { color: #888; }

        .transcript-tabs {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
        }

        .transcript-tab {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #888;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .transcript-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
        }

        .transcript-tab.active {
            background: rgba(138, 43, 226, 0.3);
            border-color: #8a2be2;
            color: #fff;
        }

        .transcript-agent-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .transcript-info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .transcript-info-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
        }

        .transcript-info-value {
            font-size: 13px;
            color: #fff;
        }

        .copilot-quick-actions {
            display: flex;
            gap: 6px;
            padding: 0 12px 10px;
            flex-wrap: wrap;
        }

        .copilot-quick-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 14px;
            padding: 5px 10px;
            font-size: 11px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-quick-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: rgba(138, 43, 226, 0.5);
            color: #fff;
        }

        /* v6.51: Mind-Blowing Prompts - Special button styling */
        .copilot-mind-blowing-btn {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.3), rgba(138, 43, 226, 0.3));
            border: 1px solid rgba(255, 0, 110, 0.5);
            color: #ff6eb4;
            animation: mind-blowing-glow 2s ease-in-out infinite;
        }
        .copilot-mind-blowing-btn:hover {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.5), rgba(138, 43, 226, 0.5));
            border-color: #ff006e;
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 0, 110, 0.4);
        }
        @keyframes mind-blowing-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 0, 110, 0.2); }
            50% { box-shadow: 0 0 15px rgba(255, 0, 110, 0.4); }
        }

        /* v6.51: Mind-Blowing Prompts Modal */
        .mind-blowing-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10002;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }
        .mind-blowing-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        .mind-blowing-content {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            border: 2px solid;
            border-image: linear-gradient(135deg, #ff006e, #8a2be2, #06ffa5) 1;
            border-radius: 20px;
            width: 94%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow:
                0 0 60px rgba(255, 0, 110, 0.3),
                0 0 100px rgba(138, 43, 226, 0.2),
                inset 0 0 60px rgba(138, 43, 226, 0.1);
            position: relative;
        }
        .mind-blowing-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 0, 110, 0.05) 0%, transparent 50%);
            animation: ai-glow-rotate 15s linear infinite;
            pointer-events: none;
        }
        .mind-blowing-header {
            padding: 25px 25px 15px;
            text-align: center;
            position: relative;
            z-index: 1;
            border-bottom: 1px solid rgba(255, 0, 110, 0.2);
        }
        .mind-blowing-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff006e, #ff6eb4, #8a2be2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }
        .mind-blowing-subtitle {
            color: #888;
            font-size: 12px;
            margin-top: 5px;
        }
        .mind-blowing-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 2;
        }
        .mind-blowing-close:hover { opacity: 1; transform: scale(1.1); color: #ff006e; }
        /* v6.52: Category filter buttons */
        .mind-blowing-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 0 20px 15px;
            justify-content: center;
            position: relative;
            z-index: 1;
        }
        .filter-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: #888;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .filter-btn:hover {
            background: rgba(255, 0, 110, 0.15);
            border-color: rgba(255, 0, 110, 0.3);
            color: #fff;
        }
        .filter-btn.active {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.3), rgba(138, 43, 226, 0.3));
            border-color: #ff006e;
            color: #fff;
        }
        /* Category badges on prompts */
        .prompt-category {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 9px;
            text-transform: uppercase;
            font-weight: bold;
            margin-right: 8px;
        }
        .prompt-category.narrative { background: rgba(0, 150, 255, 0.2); color: #4da6ff; }
        .prompt-category.philosophical { background: rgba(138, 43, 226, 0.2); color: #b366ff; }
        .prompt-category.transcendence { background: rgba(255, 215, 0, 0.2); color: #ffd700; }
        .prompt-category.comedy { background: rgba(255, 165, 0, 0.2); color: #ffa500; }
        .prompt-category.scientific { background: rgba(0, 255, 127, 0.2); color: #00ff7f; }
        .prompt-category.horror { background: rgba(139, 0, 0, 0.3); color: #ff4444; }
        .prompt-category.competitive { background: rgba(255, 0, 110, 0.2); color: #ff6eb4; }
        .prompt-category.social { background: rgba(0, 191, 255, 0.2); color: #00bfff; }
        .prompt-category.poetic { background: rgba(255, 182, 193, 0.2); color: #ffb6c1; }
        .prompt-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .mind-blowing-body {
            padding: 15px 20px;
            max-height: calc(85vh - 160px);
            overflow-y: auto;
            position: relative;
            z-index: 1;
        }
        .mind-blowing-prompt {
            display: flex;
            gap: 15px;
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 0, 110, 0.15);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mind-blowing-prompt:hover {
            background: rgba(255, 0, 110, 0.1);
            border-color: rgba(255, 0, 110, 0.4);
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.15);
        }
        .prompt-number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #ff006e, #8a2be2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            flex-shrink: 0;
        }
        .prompt-content {
            flex: 1;
            min-width: 0;
        }
        .prompt-title {
            font-weight: bold;
            color: #ff6eb4;
            font-size: 14px;
            margin-bottom: 6px;
        }
        .prompt-desc {
            color: #aaa;
            font-size: 12px;
            line-height: 1.5;
        }
        .prompt-consensus {
            display: inline-block;
            margin-top: 8px;
            padding: 3px 10px;
            background: rgba(6, 255, 165, 0.15);
            border: 1px solid rgba(6, 255, 165, 0.3);
            border-radius: 12px;
            font-size: 10px;
            color: #06ffa5;
            font-weight: bold;
        }
        .mind-blowing-footer {
            padding: 15px 25px;
            border-top: 1px solid rgba(255, 0, 110, 0.2);
            text-align: center;
            position: relative;
            z-index: 1;
        }
        .mind-blowing-hint {
            color: #666;
            font-size: 11px;
        }
        /* Scrollbar styling for the modal */
        .mind-blowing-body::-webkit-scrollbar {
            width: 6px;
        }
        .mind-blowing-body::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        .mind-blowing-body::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ff006e, #8a2be2);
            border-radius: 3px;
        }

        .copilot-voice-btn {
            background: linear-gradient(135deg, #ff006e, #ff4488);
            border: none;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .copilot-voice-btn:hover {
            transform: scale(1.1);
        }

        .copilot-voice-btn.recording {
            background: linear-gradient(135deg, #ff0000, #ff4444);
            animation: voice-record-pulse 1.5s infinite;
        }

        @keyframes voice-record-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.6); }
            70% { box-shadow: 0 0 0 12px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .copilot-voice-btn svg {
            width: 18px;
            height: 18px;
            color: white;
        }

        /* v5.9: Real-time transcription overlay */
        .stt-transcription-overlay {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff006e;
            border-radius: 16px;
            padding: 16px 24px;
            min-width: 300px;
            max-width: 500px;
            z-index: 10001;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(255, 0, 110, 0.3);
        }

        .stt-transcription-overlay.active {
            display: flex;
        }

        .stt-header {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ff006e;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stt-header .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            animation: stt-pulse 1s infinite;
        }

        @keyframes stt-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .stt-waveform {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 30px;
        }

        .stt-waveform .bar {
            width: 4px;
            background: linear-gradient(to top, #ff006e, #ff4488);
            border-radius: 2px;
            animation: stt-wave 0.5s ease-in-out infinite;
        }

        .stt-waveform .bar:nth-child(1) { animation-delay: 0s; }
        .stt-waveform .bar:nth-child(2) { animation-delay: 0.1s; }
        .stt-waveform .bar:nth-child(3) { animation-delay: 0.2s; }
        .stt-waveform .bar:nth-child(4) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(5) { animation-delay: 0.4s; }
        .stt-waveform .bar:nth-child(6) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(7) { animation-delay: 0.2s; }

        @keyframes stt-wave {
            0%, 100% { height: 8px; }
            50% { height: 25px; }
        }

        .stt-transcript-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.5;
            min-height: 24px;
            text-align: center;
        }

        .stt-transcript-text.interim {
            color: #aaa;
            font-style: italic;
        }

        .stt-transcript-text.final {
            color: #06ffa5;
        }

        .stt-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .stt-actions button {
            padding: 8px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .stt-actions .stt-send {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }

        .stt-actions .stt-send:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.4);
        }

        .stt-actions .stt-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stt-actions .stt-cancel:hover {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff4444;
        }

        .stt-actions .stt-retry {
            background: rgba(255, 0, 110, 0.3);
            color: #ff006e;
            border: 1px solid #ff006e;
        }

        .stt-actions .stt-retry:hover {
            background: rgba(255, 0, 110, 0.5);
        }

        /* v5.9: Auto-send toggle */
        .stt-auto-send {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 4px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stt-auto-send label {
            font-size: 12px;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stt-auto-send input[type="checkbox"] {
            display: none;
        }

        .stt-toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
        }

        .stt-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .stt-auto-send input[type="checkbox"]:checked + .stt-toggle {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }

        .stt-auto-send input[type="checkbox"]:checked + .stt-toggle::after {
            left: 18px;
        }

        .stt-auto-send .auto-label {
            color: #aaa;
            transition: color 0.3s;
        }

        .stt-auto-send input[type="checkbox"]:checked ~ .auto-label {
            color: #06ffa5;
        }

        /* Copilot Companion 3D Indicator */
        .copilot-3d-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: #06ffa5;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            z-index: 1010;
            border: 1px solid rgba(6, 255, 165, 0.4);
        }

        .copilot-3d-tooltip.visible {
            opacity: 1;
        }

        /* Voice Status Indicator */
        .copilot-voice-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1004;
            font-size: 12px;
            animation: fade-in 0.3s ease;
        }

        .copilot-voice-indicator.active {
            display: flex;
        }

        .copilot-voice-indicator svg {
            width: 16px;
            height: 16px;
            animation: voice-wave 1s infinite;
        }

        @keyframes voice-wave {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .copilot-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                height: 350px;
                bottom: 170px;
            }

            .copilot-button {
                width: 55px;
                height: 55px;
                bottom: 95px;
            }

            /* v6.65: Mobile companion health - positioned above left UI */
            .companion-health-container {
                bottom: auto;
                top: 160px;
                right: auto;
                left: 10px;
                width: 100px;
                padding: 4px 6px;
                border-radius: 5px;
            }

            .companion-header {
                margin-bottom: 2px;
            }

            .companion-name {
                font-size: 8px;
                max-width: 55px;
            }

            .companion-bond {
                font-size: 7px;
            }

            .companion-hp-container {
                height: 10px;
            }

            .companion-hp-text {
                font-size: 7px;
            }

            .companion-memorial-btn {
                width: 14px;
                height: 14px;
                font-size: 8px;
                top: -4px;
                right: -4px;
            }
        }

        /* v6.29: PHYSICS TUTORIAL PANEL - Interactive orbital controls */
        /* v6.35: Hidden by default for cinematic view, toggle with button */
        .physics-tutorial {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 340px;
            background: linear-gradient(135deg, rgba(0,20,40,0.95), rgba(0,10,30,0.98));
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            z-index: 500;
            opacity: 0;
            transform: translateX(-380px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            pointer-events: none;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1), inset 0 0 20px rgba(0, 255, 255, 0.03);
        }

        .physics-tutorial.visible {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        /* v6.35: Settings toggle button */
        .settings-toggle-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, rgba(0,40,60,0.9), rgba(0,20,40,0.95));
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 12px;
            z-index: 501;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        .settings-toggle-btn:hover {
            background: linear-gradient(135deg, rgba(0,60,80,0.95), rgba(0,40,60,0.98));
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .settings-toggle-btn.active {
            left: 380px;
            background: linear-gradient(135deg, rgba(0,80,100,0.95), rgba(0,60,80,0.98));
            border-color: #00ffff;
        }

        .physics-tutorial-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .physics-tutorial-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .physics-tutorial-title {
            color: #00ffff;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .physics-tutorial-subtitle {
            color: #668899;
            font-size: 11px;
            margin-top: 2px;
        }

        .physics-control {
            margin-bottom: 16px;
        }

        .physics-control:last-child {
            margin-bottom: 0;
        }

        .physics-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .physics-control-label {
            color: #aaccdd;
            font-size: 12px;
            font-weight: 500;
        }

        .physics-control-value {
            color: #00ffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .physics-control-desc {
            color: #556677;
            font-size: 10px;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .physics-slider-container {
            position: relative;
            width: 100%;
            padding-top: 25px;
        }

        .physics-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, rgba(0, 255, 255, 0.3), rgba(0, 136, 255, 0.3));
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            position: relative;
        }

        .physics-slider::-webkit-slider-runnable-track {
            height: 8px;
            border-radius: 4px;
        }

        .physics-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s, box-shadow 0.15s;
            margin-top: -7px;
        }

        .physics-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.8), 0 2px 10px rgba(0, 0, 0, 0.4);
        }

        .physics-slider::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.2);
        }

        .physics-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            border-radius: 50%;
            cursor: grab;
            border: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .physics-slider::-moz-range-track {
            height: 8px;
            background: linear-gradient(to right, rgba(0, 255, 255, 0.3), rgba(0, 136, 255, 0.3));
            border-radius: 4px;
        }

        /* Popup bubble that follows the slider thumb */
        .slider-bubble {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #00ffff, #0088ff);
            color: #000;
            font-size: 11px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.4);
        }

        .slider-bubble::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #0088ff;
        }

        .physics-slider-container:hover .slider-bubble,
        .physics-slider:active + .slider-bubble {
            opacity: 1;
        }

        .physics-slider:focus + .slider-bubble {
            opacity: 1;
        }

        .physics-formula {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 6px;
            padding: 10px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #88aacc;
            text-align: center;
        }

        .physics-formula .formula-main {
            color: #00ffff;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .physics-hint {
            color: #445566;
            font-size: 10px;
            text-align: center;
            margin-top: 12px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .physics-tutorial {
                width: calc(100% - 40px);
                left: 20px;
                right: 20px;
                bottom: 100px;
            }
        }

        /* ================================================
           v6.40: 4D TESSERACT WALK-THROUGH MODE
           Enter the black hole to experience impossible geometry
           ================================================ */

        /* Tesseract HUD */
        .tesseract-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(20, 0, 40, 0.95), transparent);
            display: none;
            z-index: 100;
            pointer-events: auto;
        }

        .tesseract-hud.active {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tesseract-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .tesseract-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(18px, 3vw, 28px);
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.4);
            letter-spacing: 3px;
        }

        .tesseract-subtitle {
            font-size: 11px;
            color: #aa88cc;  /* v6.82: Improved contrast for accessibility */
            letter-spacing: 2px;
        }

        .tesseract-exit-btn {
            background: rgba(255, 0, 100, 0.3);
            border: 1px solid #ff0066;
            color: #ff66aa;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s;
        }

        .tesseract-exit-btn:hover {
            background: rgba(255, 0, 100, 0.5);
            box-shadow: 0 0 20px rgba(255, 0, 100, 0.5);
            transform: scale(1.05);
        }

        /* 4D Rotation Controls */
        .tesseract-controls {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            pointer-events: auto;
        }

        .tesseract-controls.active {
            display: flex;
        }

        .rotation-plane {
            background: rgba(30, 0, 60, 0.9);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 120px;
        }

        .rotation-plane-label {
            font-size: 11px;
            color: #cc88ff;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rotation-plane-value {
            color: #ff00ff;
            font-weight: bold;
        }

        .rotation-plane input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #330066, #ff00ff);
            border-radius: 3px;
            cursor: pointer;
        }

        .rotation-plane input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
            cursor: grab;
        }

        .rotation-plane input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.2);
        }

        /* Room Indicator */
        .tesseract-room-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 0, 80, 0.9);
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 15px;
            padding: 15px 30px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 100;
            pointer-events: none;
        }

        .tesseract-room-indicator.active {
            display: flex;
        }

        .room-name {
            font-size: 16px;
            color: #ff88ff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .room-desc {
            font-size: 11px;
            color: #aa88cc;
            text-align: center;
            max-width: 300px;
        }

        /* Portal Door Effect */
        .portal-prompt {
            position: fixed;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 12px 25px;
            color: #0ff;
            font-size: 14px;
            display: none;
            animation: portal-pulse 1.5s ease-in-out infinite;
            z-index: 100;
            pointer-events: none;
        }

        .portal-prompt.active {
            display: block;
        }

        @keyframes portal-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); transform: translateX(-50%) scale(1); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 255, 0.6); transform: translateX(-50%) scale(1.05); }
        }

        /* Dimension Shift Effect */
        .dimension-shift-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 255, 0.8), rgba(0, 0, 0, 0.9));
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .dimension-shift-overlay.active {
            display: flex;
            animation: dimension-shift 2s ease-in-out forwards;
        }

        @keyframes dimension-shift {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        .dimension-shift-text {
            font-size: clamp(24px, 5vw, 48px);
            color: #fff;
            text-shadow: 0 0 30px #ff00ff, 0 0 60px #ff00ff;
            letter-spacing: 10px;
            animation: text-glitch 0.3s infinite;
        }

        @keyframes text-glitch {
            0%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
            25% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
        }

        /* Movement Instructions */
        .tesseract-movement-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 0, 40, 0.8);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            padding: 10px 20px;
            display: none;
            gap: 15px;
            font-size: 11px;
            color: #aa88cc;
            z-index: 100;
            pointer-events: none;
        }

        .tesseract-movement-hint.active {
            display: flex;
        }

        .tesseract-movement-hint kbd {
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid rgba(255, 0, 255, 0.4);
            border-radius: 4px;
            padding: 2px 6px;
            color: #ff88ff;
            font-family: inherit;
        }

        /* ================================================
           v6.60: THROUGH THE TESSERACT - 4D Higher Dimensional Guide
           Interactive educational system for understanding 4D space
           ================================================ */

        /* ================================================
           IMMERSIVE TUTORIAL SYSTEM - The world teaches you
           ================================================ */

        /* Narrator - Cinematic subtitle-style text */
        .tesseract-narrator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 700px;
            text-align: center;
            z-index: 300;
            pointer-events: none;
            display: none;
        }

        .tesseract-narrator.active {
            display: block;
        }

        .narrator-text {
            font-size: clamp(16px, 2.5vw, 22px);
            color: #e8d0ff;
            line-height: 1.6;
            text-shadow:
                0 0 20px rgba(150, 50, 255, 0.8),
                0 0 40px rgba(100, 0, 200, 0.6),
                0 2px 4px rgba(0, 0, 0, 0.9);
            font-style: italic;
            letter-spacing: 0.5px;
            padding: 20px 30px;
            background: linear-gradient(180deg, transparent, rgba(20, 0, 40, 0.7), rgba(20, 0, 40, 0.8));
            border-radius: 10px;
        }

        .narrator-text .highlight {
            color: #ff88ff;
            font-weight: bold;
            font-style: normal;
        }

        .narrator-text .dim {
            color: #9977aa;
        }

        /* Tutorial Stage Indicator */
        .tutorial-stage {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 0, 200, 0.3);
            border: 1px solid rgba(200, 100, 255, 0.4);
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 11px;
            color: #cc99ff;
            letter-spacing: 3px;
            text-transform: uppercase;
            z-index: 300;
            display: none;
        }

        .tutorial-stage.active {
            display: block;
            animation: stage-appear 0.5s ease-out;
        }

        @keyframes stage-appear {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Tutorial Prompt - For interactive moments */
        .tutorial-prompt {
            position: fixed;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 200, 150, 0.2), rgba(0, 150, 200, 0.2));
            border: 2px solid rgba(0, 255, 200, 0.5);
            border-radius: 12px;
            padding: 15px 30px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 300;
            animation: prompt-pulse 2s ease-in-out infinite;
        }

        .tutorial-prompt.active {
            display: flex;
        }

        @keyframes prompt-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 200, 0.3); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 200, 0.6); }
        }

        .tutorial-prompt-text {
            font-size: 14px;
            color: #88ffdd;
            font-weight: bold;
        }

        .tutorial-prompt-hint {
            font-size: 11px;
            color: #66ccaa;
        }

        .tutorial-prompt kbd {
            background: rgba(0, 255, 200, 0.2);
            border: 1px solid rgba(0, 255, 200, 0.4);
            border-radius: 4px;
            padding: 3px 8px;
            color: #aaffee;
            font-family: inherit;
            margin: 0 3px;
        }

        /* Tutorial Success Feedback */
        .tutorial-success {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #00ffaa;
            text-shadow: 0 0 30px rgba(0, 255, 170, 0.8);
            z-index: 400;
            display: none;
            animation: success-pop 0.6s ease-out;
        }

        .tutorial-success.active {
            display: block;
        }

        @keyframes success-pop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* W-Axis Visualization Arrow (3D overlay hint) */
        .w-axis-hint {
            position: fixed;
            top: 50%;
            right: 180px;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 150;
            pointer-events: none;
        }

        .w-axis-hint.active {
            display: flex;
            animation: w-axis-appear 1s ease-out;
        }

        @keyframes w-axis-appear {
            from { opacity: 0; transform: translateY(-50%) translateX(20px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .w-axis-arrow {
            font-size: 40px;
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            animation: w-pulse 1.5s ease-in-out infinite;
        }

        @keyframes w-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .w-axis-label {
            font-size: 12px;
            color: #cc88ff;
            letter-spacing: 2px;
        }

        .w-axis-label-ana {
            color: #ff88ff;
        }

        .w-axis-label-kata {
            color: #8888ff;
        }

        /* Tutorial Skip Button */
        .tutorial-skip {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(100, 100, 100, 0.3);
            border: 1px solid rgba(150, 150, 150, 0.4);
            color: #999;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            z-index: 350;
            display: none;
            transition: all 0.2s;
        }

        .tutorial-skip.active {
            display: block;
        }

        .tutorial-skip:hover {
            background: rgba(150, 100, 100, 0.4);
            color: #ccc;
        }

        /* Vertex Trail Effect (for teaching rotations) */
        .vertex-trail-hint {
            position: fixed;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #aa88cc;
            text-align: center;
            z-index: 150;
            display: none;
            pointer-events: none;
        }

        .vertex-trail-hint.active {
            display: block;
        }

        /* Cell Highlight Overlay */
        .cell-highlight-text {
            position: fixed;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #ffaa00;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.6);
            z-index: 150;
            display: none;
            pointer-events: none;
            text-align: center;
        }

        .cell-highlight-text.active {
            display: block;
        }

        /* 4D Guide Toggle Button */
        .tesseract-guide-toggle {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(100, 0, 200, 0.8), rgba(50, 0, 100, 0.9));
            border: 2px solid rgba(200, 100, 255, 0.6);
            border-radius: 12px;
            padding: 12px 16px;
            color: #e0b0ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            z-index: 101;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(150, 50, 255, 0.3);
        }

        .tesseract-guide-toggle.active {
            display: flex;
        }

        .tesseract-guide-toggle:hover {
            background: linear-gradient(135deg, rgba(130, 0, 255, 0.9), rgba(70, 0, 140, 0.95));
            box-shadow: 0 0 30px rgba(180, 80, 255, 0.5);
            transform: translateY(-50%) scale(1.05);
        }

        .tesseract-guide-toggle .guide-icon {
            font-size: 24px;
        }

        .tesseract-guide-toggle .guide-label {
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        /* 4D Guide Panel */
        .tesseract-guide-panel {
            position: fixed;
            left: 20px;
            top: 100px;
            bottom: 100px;
            width: 320px;
            background: linear-gradient(180deg, rgba(30, 0, 60, 0.96), rgba(15, 0, 30, 0.98));
            border: 2px solid rgba(200, 100, 255, 0.4);
            border-radius: 16px;
            display: none;
            flex-direction: column;
            z-index: 200;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(150, 50, 255, 0.3), inset 0 0 60px rgba(100, 0, 200, 0.1);
            pointer-events: auto;
        }

        .tesseract-guide-panel.active {
            display: flex;
            animation: guide-slide-in 0.4s ease-out;
        }

        @keyframes guide-slide-in {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .guide-header {
            padding: 20px;
            background: linear-gradient(180deg, rgba(100, 0, 200, 0.3), transparent);
            border-bottom: 1px solid rgba(200, 100, 255, 0.2);
        }

        .guide-header-title {
            font-size: 16px;
            font-weight: bold;
            color: #e0b0ff;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(200, 100, 255, 0.5);
            margin-bottom: 5px;
        }

        .guide-header-subtitle {
            font-size: 11px;
            color: #9966cc;
        }

        .guide-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 50, 150, 0.2);
            border: 1px solid rgba(255, 50, 150, 0.4);
            color: #ff88bb;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .guide-close-btn:hover {
            background: rgba(255, 50, 150, 0.4);
            transform: scale(1.1);
        }

        /* Guide Tabs */
        .guide-tabs {
            display: flex;
            padding: 0 15px;
            gap: 5px;
            background: rgba(0, 0, 0, 0.2);
        }

        .guide-tab {
            flex: 1;
            padding: 10px 8px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: #aa88cc;  /* v6.82: Improved contrast for accessibility */
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .guide-tab:hover {
            color: #cc99ff;
        }

        .guide-tab.active {
            color: #e0b0ff;
            border-bottom-color: #cc66ff;
            background: rgba(150, 50, 255, 0.1);
        }

        /* Guide Content */
        .guide-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .guide-content::-webkit-scrollbar {
            width: 6px;
        }

        .guide-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .guide-content::-webkit-scrollbar-thumb {
            background: rgba(200, 100, 255, 0.3);
            border-radius: 3px;
        }

        .guide-tab-content {
            display: none;
        }

        .guide-tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        /* Guide Sections */
        .guide-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(100, 50, 180, 0.1);
            border: 1px solid rgba(200, 100, 255, 0.15);
            border-radius: 10px;
        }

        .guide-section-title {
            font-size: 13px;
            font-weight: bold;
            color: #cc88ff;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .guide-section-title .section-icon {
            font-size: 16px;
        }

        .guide-section p {
            font-size: 12px;
            color: #aa88cc;
            line-height: 1.6;
            margin: 0 0 10px 0;
        }

        .guide-section p:last-child {
            margin-bottom: 0;
        }

        /* Concept Cards */
        .concept-card {
            background: rgba(80, 0, 160, 0.2);
            border: 1px solid rgba(200, 100, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .concept-card-title {
            font-size: 12px;
            font-weight: bold;
            color: #e0b0ff;
            margin-bottom: 6px;
        }

        .concept-card-desc {
            font-size: 11px;
            color: #9977bb;
            line-height: 1.5;
        }

        /* Rotation Plane Explainer */
        .rotation-explainer {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .rotation-card {
            background: rgba(60, 0, 120, 0.3);
            border: 1px solid rgba(255, 0, 255, 0.2);
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rotation-card:hover {
            background: rgba(100, 0, 200, 0.4);
            border-color: rgba(255, 0, 255, 0.4);
            transform: scale(1.02);
        }

        .rotation-card.dimensional {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(100, 0, 200, 0.3));
            border-color: rgba(255, 100, 255, 0.4);
        }

        .rotation-card-label {
            font-size: 14px;
            font-weight: bold;
            color: #ff88ff;
            margin-bottom: 4px;
        }

        .rotation-card-desc {
            font-size: 10px;
            color: #aa88cc;
            line-height: 1.4;
        }

        .rotation-card-type {
            font-size: 9px;
            color: #8866aa;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* W-Coordinate Indicator */
        .w-coordinate-indicator {
            position: fixed;
            left: 20px;
            bottom: 100px;
            background: linear-gradient(180deg, rgba(50, 0, 100, 0.9), rgba(30, 0, 60, 0.95));
            border: 2px solid rgba(255, 0, 255, 0.4);
            border-radius: 12px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
            min-width: 180px;
        }

        .w-coordinate-indicator.active {
            display: flex;
        }

        .w-indicator-title {
            font-size: 11px;
            color: #cc88ff;
            letter-spacing: 1px;
            text-align: center;
        }

        .w-indicator-visual {
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .w-indicator-bar {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            background: linear-gradient(180deg, #ff00ff, #8800ff, #0044ff);
            border-radius: 4px;
            top: 10px;
            bottom: 10px;
        }

        .w-indicator-marker {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #fff, #ff88ff);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
            transition: top 0.3s ease;
        }

        .w-indicator-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #8866aa;
        }

        .w-indicator-value {
            text-align: center;
            font-size: 16px;
            color: #ff88ff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .w-indicator-label {
            font-size: 10px;
            color: #aa88cc;
            text-align: center;
        }

        /* Guided Tour Overlay */
        .tesseract-tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 500;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .tesseract-tour-overlay.active {
            display: flex;
        }

        .tour-card {
            background: linear-gradient(135deg, rgba(60, 0, 120, 0.95), rgba(30, 0, 60, 0.98));
            border: 2px solid rgba(200, 100, 255, 0.5);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 60px rgba(150, 50, 255, 0.4);
            animation: tour-card-appear 0.5s ease-out;
        }

        @keyframes tour-card-appear {
            from { opacity: 0; transform: scale(0.9) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .tour-step-indicator {
            font-size: 11px;
            color: #8866aa;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .tour-title {
            font-size: 22px;
            color: #e0b0ff;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(200, 100, 255, 0.5);
        }

        .tour-content {
            font-size: 14px;
            color: #bb99dd;
            line-height: 1.7;
            margin-bottom: 25px;
        }

        .tour-visual {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 0, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 80px;
        }

        .tour-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .tour-btn {
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            transition: all 0.2s;
        }

        .tour-btn.primary {
            background: linear-gradient(135deg, #cc66ff, #9933ff);
            border: none;
            color: #fff;
        }

        .tour-btn.primary:hover {
            background: linear-gradient(135deg, #dd88ff, #aa44ff);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(200, 100, 255, 0.5);
        }

        .tour-btn.secondary {
            background: transparent;
            border: 1px solid rgba(200, 100, 255, 0.4);
            color: #cc99ff;
        }

        .tour-btn.secondary:hover {
            background: rgba(200, 100, 255, 0.1);
        }

        /* Glossary Modal */
        .tesseract-glossary {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 600;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .tesseract-glossary.active {
            display: flex;
        }

        .glossary-content {
            background: linear-gradient(135deg, rgba(40, 0, 80, 0.98), rgba(20, 0, 40, 0.99));
            border: 2px solid rgba(200, 100, 255, 0.4);
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .glossary-header {
            padding: 20px;
            background: rgba(100, 0, 200, 0.2);
            border-bottom: 1px solid rgba(200, 100, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .glossary-title {
            font-size: 18px;
            color: #e0b0ff;
            font-weight: bold;
        }

        .glossary-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .glossary-term {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(100, 50, 180, 0.15);
            border-radius: 10px;
            border-left: 3px solid #cc66ff;
        }

        .glossary-term-name {
            font-size: 14px;
            font-weight: bold;
            color: #cc88ff;
            margin-bottom: 5px;
        }

        .glossary-term-def {
            font-size: 12px;
            color: #aa88cc;
            line-height: 1.5;
        }

        /* Rotation Plane Tooltips */
        .rotation-plane-tooltip {
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(40, 0, 80, 0.95);
            border: 1px solid rgba(200, 100, 255, 0.4);
            border-radius: 8px;
            padding: 10px 12px;
            margin-right: 10px;
            width: 200px;
            display: none;
            z-index: 150;
            pointer-events: none;
        }

        .rotation-plane:hover .rotation-plane-tooltip {
            display: block;
            animation: tooltip-appear 0.2s ease;
        }

        @keyframes tooltip-appear {
            from { opacity: 0; transform: translateY(-50%) translateX(10px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .rotation-plane-tooltip-title {
            font-size: 12px;
            font-weight: bold;
            color: #e0b0ff;
            margin-bottom: 5px;
        }

        .rotation-plane-tooltip-desc {
            font-size: 10px;
            color: #aa88cc;
            line-height: 1.4;
        }

        .rotation-plane-tooltip-tag {
            display: inline-block;
            font-size: 9px;
            padding: 2px 6px;
            background: rgba(255, 0, 255, 0.2);
            border-radius: 4px;
            color: #ff88ff;
            margin-top: 6px;
        }


        /* ================================================
           v6.82: 4D INTUITION ENGINE - Teaching 4D through eureka moments
           ================================================ */

        /* Eureka Flash Effect */
        #eureka-flash {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center, rgba(255, 215, 0, 0.6) 0%, rgba(255, 200, 50, 0.3) 40%, transparent 70%);
            pointer-events: none; z-index: 600; display: none;
        }
        #eureka-flash.active { display: block; animation: eurekaFlash 1.5s ease-out forwards; }
        @keyframes eurekaFlash {
            0% { opacity: 1; transform: scale(0.8); }
            20% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        /* Eureka Popup */
        .eureka-popup {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            background: linear-gradient(135deg, rgba(40, 20, 60, 0.98), rgba(20, 10, 40, 0.98));
            border: 3px solid #ffd700; border-radius: 20px; padding: 40px 60px;
            text-align: center; z-index: 700; display: none; pointer-events: none;
            box-shadow: 0 0 80px rgba(255, 215, 0, 0.5), inset 0 0 40px rgba(255, 215, 0, 0.1);
        }
        .eureka-popup.active { display: block; opacity: 1; pointer-events: auto; animation: eurekaPop 0.5s ease-out forwards; }
        @keyframes eurekaPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            60% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .eureka-icon { font-size: 60px; margin-bottom: 15px; animation: eurekaPulse 1s ease-in-out infinite; }
        @keyframes eurekaPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .eureka-title { font-size: 28px; font-family: Georgia, serif; color: #ffd700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8); margin-bottom: 10px; letter-spacing: 4px; }
        .eureka-message { font-size: 16px; color: #e8d0ff; font-style: italic; margin-bottom: 20px; max-width: 400px; }
        .eureka-achievement { display: inline-block; background: rgba(255, 215, 0, 0.2); border: 1px solid #ffd700; border-radius: 20px; padding: 8px 20px; font-size: 12px; color: #ffd700; letter-spacing: 2px; }

        /* Flatland Overlay */
        #flatland-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #1a0a2e; z-index: 550; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #flatland-overlay.active { display: flex; }
        #flatland-canvas { width: 80vw; max-width: 600px; height: 80vw; max-height: 600px; background: #0d0520; border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 10px; }
        .flatland-narrator { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); font-size: 18px; color: #e8d0ff; text-align: center; max-width: 600px; font-style: italic; }
        .flatland-narrator .highlight { color: #00ffff; font-weight: bold; }
        .flatland-header { position: fixed; top: 30px; left: 50%; transform: translateX(-50%); text-align: center; }
        .flatland-title { font-size: 24px; color: #00ffff; letter-spacing: 8px; text-shadow: 0 0 15px rgba(0, 255, 255, 0.6); margin-bottom: 5px; }
        .flatland-subtitle { font-size: 12px; color: #888; letter-spacing: 4px; }

        /* Dimensional Ladder */
        #dimensional-ladder { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 5, 20, 0.98); z-index: 560; display: none; flex-direction: column; align-items: center; justify-content: center; gap: 30px; }
        #dimensional-ladder.active { display: flex; }
        .ladder-header { text-align: center; }
        .ladder-title { font-size: 28px; color: #00ffff; letter-spacing: 6px; margin-bottom: 10px; }
        .ladder-subtitle { font-size: 14px; color: #888; }
        .ladder-display { display: flex; gap: 40px; align-items: flex-end; }
        .ladder-step { display: flex; flex-direction: column; align-items: center; gap: 10px; opacity: 0.3; transition: opacity 0.5s, transform 0.5s; }
        .ladder-step.active { opacity: 1; transform: scale(1.1); }
        .ladder-step.completed { opacity: 0.7; }
        .ladder-shape-container { width: 100px; height: 100px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 10px; background: rgba(0, 50, 80, 0.2); }
        .ladder-step.active .ladder-shape-container { border-color: #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
        .ladder-label { font-size: 12px; color: #888; letter-spacing: 2px; }
        .ladder-step.active .ladder-label { color: #00ffff; }
        .ladder-stats { font-size: 10px; color: #666; text-align: center; }
        .ladder-stats span { color: #ffd700; }
        .ladder-prediction { margin-top: 30px; text-align: center; display: none; }
        .ladder-question { font-size: 18px; color: #e8d0ff; margin-bottom: 20px; }
        .ladder-input-group { display: flex; gap: 30px; justify-content: center; }
        .ladder-input-item { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .ladder-input-item label { font-size: 12px; color: #888; }
        .ladder-input-item input { width: 80px; padding: 10px; font-size: 18px; text-align: center; background: rgba(0, 50, 80, 0.3); border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 8px; color: #00ffff; outline: none; }
        .ladder-input-item input:focus { border-color: #00ffff; box-shadow: 0 0 15px rgba(0, 255, 255, 0.3); }
        .ladder-submit { margin-top: 20px; padding: 12px 40px; font-size: 16px; background: linear-gradient(135deg, #00ffff, #0088ff); border: none; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer; }
        .ladder-submit:hover { transform: translateY(-2px); box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }

        /* Ana/Kata Legend for W-coordinate colors */
        .ana-kata-legend { position: fixed; top: 120px; right: 20px; background: rgba(10, 10, 30, 0.9); border: 1px solid rgba(100, 100, 150, 0.3); border-radius: 10px; padding: 12px 16px; z-index: 150; display: none; pointer-events: none; }
        .ana-kata-legend.active { display: block; }
        .ana-kata-legend-title { font-size: 10px; color: #888; letter-spacing: 2px; margin-bottom: 10px; text-align: center; }
        .ana-kata-legend-item { display: flex; align-items: center; gap: 10px; margin: 6px 0; font-size: 12px; }
        .ana-kata-dot { width: 14px; height: 14px; border-radius: 50%; }
        .ana-kata-dot.ana { background: radial-gradient(circle, #00ffff, #0088ff); box-shadow: 0 0 10px rgba(0, 255, 255, 0.6); }
        .ana-kata-dot.kata { background: radial-gradient(circle, #ff00ff, #ff0088); box-shadow: 0 0 10px rgba(255, 0, 255, 0.6); }
        .ana-kata-dot.neutral { background: radial-gradient(circle, #ffffff, #aaaaaa); box-shadow: 0 0 10px rgba(255, 255, 255, 0.4); }
        .ana-kata-label { color: #aaa; }
        .ana-kata-label.ana { color: #00ffff; }
        .ana-kata-label.kata { color: #ff00ff; }

        /* Inside-Out Indicator */
        #inside-out-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; color: #ff8800; text-shadow: 0 0 20px rgba(255, 136, 0, 0.8); letter-spacing: 6px; z-index: 200; display: none; pointer-events: none; }
        #inside-out-indicator.active { display: block; animation: insideOutPulse 0.8s ease-out forwards; }
        @keyframes insideOutPulse { 0% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } 30% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 70% { opacity: 1; } 100% { opacity: 0; } }

        /* Black Hole Entry Prompt */
        .black-hole-entry {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(60, 0, 100, 0.95), rgba(20, 0, 40, 0.95));
            border: 2px solid rgba(255, 0, 255, 0.6);
            border-radius: 20px;
            padding: 30px 40px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 1000;
            text-align: center;
            animation: black-hole-appear 0.5s ease-out;
            box-shadow: 0 0 100px rgba(255, 0, 255, 0.4), inset 0 0 50px rgba(255, 0, 255, 0.1);
        }

        .black-hole-entry.active {
            display: flex;
        }

        @keyframes black-hole-appear {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .black-hole-entry h2 {
            font-size: 24px;
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            margin: 0;
            letter-spacing: 3px;
        }

        .black-hole-entry p {
            color: #cc99ff;
            font-size: 14px;
            max-width: 350px;
            line-height: 1.6;
            margin: 0;
        }

        .black-hole-entry-buttons {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .black-hole-entry-btn {
            padding: 12px 30px;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }

        .black-hole-entry-btn.enter {
            background: linear-gradient(135deg, #ff00ff, #8800ff);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .black-hole-entry-btn.enter:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .black-hole-entry-btn.cancel {
            background: rgba(100, 100, 100, 0.3);
            color: #999;
            border: 1px solid #666;
        }

        .black-hole-entry-btn.cancel:hover {
            background: rgba(100, 100, 100, 0.5);
            color: #fff;
        }

        /* ============================================
           v6.54: STEAM DECK OPTIMIZATION (1280x800)
           8-Agent Consensus Implementation
           ============================================ */
        @media (width: 1280px) and (height: 800px),
               (max-width: 1300px) and (min-width: 1250px) and (max-height: 850px) and (min-height: 750px) {

            /* Font scaling for 7" screen at arm's length */
            .stat-val { font-size: 18px !important; }
            .stat-lbl { font-size: 12px !important; }
            .ability-key { font-size: 14px !important; }
            .ability-cooldown-text { font-size: 18px !important; font-weight: bold !important; }
            .floater { font-size: 20px !important; }
            .floater.crit { font-size: 26px !important; }
            .context-tooltip { font-size: 14px !important; max-width: 250px !important; }
            .data-controls button { font-size: 13px !important; min-height: 44px; padding: 8px 14px !important; }

            /* Larger touch targets for abilities */
            .ability-slot {
                width: 56px !important;
                height: 56px !important;
            }
            .ability-icon { font-size: 26px !important; }

            /* Touch controls scaling */
            .touch-btn {
                width: 60px !important;
                height: 60px !important;
                font-size: 26px !important;
            }

            /* Inventory slot scaling */
            .inv-slot, .equip-slot {
                min-width: 44px !important;
                min-height: 44px !important;
            }

            /* Safe zone repositioning - avoid thumb rest areas */
            .minimap {
                bottom: 130px !important;
                right: 25px !important;
                width: 130px !important;
                height: 130px !important;
            }

            /* Health bar wider for visibility */
            .player-health-bar {
                width: clamp(280px, 42vw, 420px) !important;
            }

            /* Notification positioning */
            .notification {
                top: 70px !important;
                font-size: 16px !important;
            }

            /* HUD breathing room */
            .hud-top {
                padding: 12px 25px !important;
            }

            /* Settings panel scaling */
            .modal-content {
                max-width: 420px !important;
            }
            .setting-row {
                min-height: 44px;
            }
        }

        /* Steam Deck Gamepad UI Elements */
        .gamepad-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 20px;
            padding: 5px 12px;
            font-size: 12px;
            color: #00ff88;
            z-index: 1100;
            display: none;
            align-items: center;
            gap: 6px;
        }
        .gamepad-indicator.connected { display: flex; }
        .gamepad-indicator.disconnected {
            display: flex;
            background: rgba(255, 100, 100, 0.2);
            border-color: #ff6464;
            color: #ff6464;
        }

        /* Button prompt icons */
        .btn-prompt {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            margin: 0 3px;
        }
        .btn-prompt.a { background: #44bb44; color: #fff; }
        .btn-prompt.b { background: #bb4444; color: #fff; }
        .btn-prompt.x { background: #4488dd; color: #fff; }
        .btn-prompt.y { background: #ddbb44; color: #000; }
        .btn-prompt.lb, .btn-prompt.rb { background: #666; color: #fff; border-radius: 4px; }
        .btn-prompt.lt, .btn-prompt.rt { background: #888; color: #fff; border-radius: 4px; width: 28px; }

        /* Radial ability menu */
        .radial-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #0ff;
            border-radius: 50%;
            display: none;
            z-index: 2000;
        }
        .radial-menu.active { display: block; }
        .radial-segment {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.15s;
        }
        .radial-segment.selected {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(1.15);
            box-shadow: 0 0 20px #0ff;
        }
        .radial-segment-label {
            font-size: 9px;
            color: #0ff;
            margin-top: 2px;
        }

        /* ================================================
           v6.56: CIVILIZATION GENESIS ENGINE
           8-Agent Consensus Implementation
           Drop a seed, watch civilizations emerge from 4 rules
           ================================================ */

        .genesis-button {
            width: 44px;
            height: 44px;
            background: rgba(255, 165, 0, 0.4);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(255, 165, 0, 0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(255, 165, 0, 0.3);
            font-size: 20px;
        }
        .genesis-button:hover {
            background: rgba(255, 165, 0, 0.6);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 165, 0, 0.5);
        }
        .genesis-button.active {
            background: rgba(255, 215, 0, 0.5);
            border-color: rgba(255, 215, 0, 0.9);
            box-shadow: 0 2px 15px rgba(255, 215, 0, 0.4);
            animation: genesis-pulse 2s ease-in-out infinite;
        }
        @keyframes genesis-pulse {
            0%, 100% { box-shadow: 0 2px 15px rgba(255, 215, 0, 0.4); }
            50% { box-shadow: 0 4px 25px rgba(255, 215, 0, 0.7); }
        }

        /* Genesis HUD */
        .genesis-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            background: linear-gradient(to bottom, rgba(30, 15, 0, 0.95), transparent);
            display: none;
            z-index: 100;
            pointer-events: auto;
            border-bottom: 1px solid rgba(255, 165, 0, 0.2);
        }
        .genesis-hud.active { display: flex; flex-wrap: wrap; gap: 15px; justify-content: space-between; align-items: flex-start; }

        .genesis-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(18px, 3vw, 28px);
            color: #ffa500;
            text-shadow: 0 0 15px rgba(255, 165, 0, 0.6);
            letter-spacing: 3px;
        }
        .genesis-subtitle {
            font-size: 10px;
            color: #886644;
            letter-spacing: 2px;
        }

        .genesis-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .genesis-stat {
            text-align: center;
        }
        .genesis-stat-val {
            font-size: clamp(16px, 3vw, 24px);
            color: #ffd700;
            font-weight: bold;
        }
        .genesis-stat-lbl {
            font-size: 9px;
            color: #886644;
            text-transform: uppercase;
        }

        .genesis-exit-btn {
            background: rgba(255, 100, 50, 0.3);
            border: 1px solid #ff6622;
            color: #ffaa66;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
        }
        .genesis-exit-btn:hover {
            background: rgba(255, 100, 50, 0.5);
            box-shadow: 0 0 15px rgba(255, 100, 50, 0.4);
        }

        /* Genesis Controls Panel */
        .genesis-controls-panel {
            position: fixed;
            top: 80px;
            right: 10px;
            background: rgba(20, 10, 0, 0.95);
            border: 1px solid rgba(255, 165, 0, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            display: none;
            z-index: 99;
            backdrop-filter: blur(8px);
        }
        .genesis-controls-panel.active { display: block; }

        .genesis-panel-title {
            color: #ffa500;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .genesis-speed-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        .genesis-speed-btn {
            flex: 1;
            padding: 8px 4px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #444;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .genesis-speed-btn:hover { border-color: #ffa500; color: #ffa500; }
        .genesis-speed-btn.active {
            background: rgba(255, 165, 0, 0.3);
            border-color: #ffa500;
            color: #ffa500;
        }

        .genesis-interventions {
            border-top: 1px solid rgba(255, 165, 0, 0.2);
            padding-top: 12px;
            margin-top: 8px;
        }
        .genesis-interventions-title {
            font-size: 10px;
            color: #664422;
            margin-bottom: 8px;
        }
        .genesis-intervention-btns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .genesis-intervention-btn {
            padding: 8px;
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #ffd700;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .genesis-intervention-btn:hover {
            background: rgba(255, 215, 0, 0.3);
            transform: scale(1.02);
        }
        .genesis-intervention-btn.disaster {
            background: rgba(255, 50, 0, 0.15);
            border-color: rgba(255, 50, 0, 0.3);
            color: #ff6644;
        }
        .genesis-intervention-btn.disaster:hover {
            background: rgba(255, 50, 0, 0.3);
        }

        /* Genesis Placement Cursor */
        .genesis-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }
        .genesis-cursor.active { display: block; }
        .genesis-cursor-ring {
            width: 50px;
            height: 50px;
            border: 2px dashed #ffa500;
            border-radius: 50%;
            animation: genesis-cursor-pulse 1.2s ease-in-out infinite;
        }
        .genesis-cursor-label {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 11px;
            color: #ffa500;
            text-shadow: 0 0 5px #000, 0 0 10px #000;
        }
        @keyframes genesis-cursor-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.15); opacity: 0.7; }
        }

        /* Genesis Faction Colors */
        .genesis-faction-0 { color: #66aaff; }
        .genesis-faction-1 { color: #66ff88; }
        .genesis-faction-2 { color: #ff8866; }
        .genesis-faction-3 { color: #aa66ff; }
        .genesis-faction-4 { color: #ffff66; }
        .genesis-faction-5 { color: #ff66aa; }

        /* Genesis Event Log */
        .genesis-event-log {
            position: fixed;
            bottom: 100px;
            left: 10px;
            background: rgba(20, 10, 0, 0.85);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-width: 280px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            z-index: 98;
            font-size: 10px;
        }
        .genesis-event-log.active { display: block; }
        .genesis-event {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 165, 0, 0.1);
            color: #aa8866;
        }
        .genesis-event:last-child { border-bottom: none; }
        .genesis-event-time { color: #664422; margin-right: 6px; }
    </style>
</head>
<body>
    <!-- v6.6: ARIA live region for screen reader notifications (Agent 6 accessibility) -->
    <div id="sr-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>

    <!-- v6.54: Steam Deck Gamepad Indicator -->
    <div id="gamepad-indicator" class="gamepad-indicator">
        <span></span>
        <span id="gamepad-status">Controller Connected</span>
    </div>

    <!-- v6.54: Radial Ability Menu for Controller -->
    <div id="radial-menu" class="radial-menu">
        <div class="radial-segment" data-ability="powerStrike" style="top: 15px; left: 50%; transform: translateX(-50%);"><span class="radial-segment-label">Q</span></div>
        <div class="radial-segment" data-ability="execute" style="top: 50px; right: 30px;"><span class="radial-segment-label">X</span></div>
        <div class="radial-segment" data-ability="whirlwind" style="top: 50%; right: 15px; transform: translateY(-50%);"><span class="radial-segment-label">E</span></div>
        <div class="radial-segment" data-ability="berserk" style="bottom: 50px; right: 30px;"><span class="radial-segment-label">C</span></div>
        <div class="radial-segment" data-ability="warcry" style="bottom: 15px; left: 50%; transform: translateX(-50%);"><span class="radial-segment-label">R</span></div>
        <div class="radial-segment" data-ability="dash" style="bottom: 50px; left: 30px;"><span class="radial-segment-label">F</span></div>
        <div class="radial-segment" data-ability="shield" style="top: 50%; left: 15px; transform: translateY(-50%);"><span class="radial-segment-label">Z</span></div>
        <div class="radial-segment" data-ability="heal" style="top: 50px; left: 30px;"><span class="radial-segment-label">T</span></div>
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #0ff; font-size: 11px; text-align: center;">
            <div></div>
            <div>Right Stick</div>
        </div>
    </div>

    <!-- v6.84: Added ARIA attributes for loading screen accessibility -->
    <div id="loading" class="loading" role="status" aria-live="polite" aria-label="Game loading screen">
        <div class="loading-text" id="loading-phase" aria-live="polite">INITIALIZING OMNIVERSE ENGINE...</div>
        <div class="loading-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="loading-progress" id="loading-progress-bar"></div></div>
        <!-- v6.43: Loading phase indicator -->
        <div id="loading-phases" style="margin-top: 15px; display: flex; gap: 8px; font-size: 10px;">
            <span id="phase-1" style="color: #0f0;"> Audio</span>
            <span id="phase-2" style="color: #333;"> Renderer</span>
            <span id="phase-3" style="color: #333;"> World</span>
            <span id="phase-4" style="color: #333;"> Assets</span>
        </div>
        <!-- v6.1: Loading screen tips -->
        <div id="loading-tip" style="margin-top: 20px; color: #888; font-size: 14px; max-width: 400px; text-align: center; line-height: 1.5;">
            <span style="color: #0ff;">TIP:</span> <span id="tip-text">Press F1 anytime to view keyboard shortcuts</span>
        </div>
    </div>

    <div id="container"></div>

    <!-- v6.32: Low HP Warning Vignette Overlay -->
    <div id="low-hp-vignette"></div>

    <!-- v6.80: Critical HP Desaturation Overlay -->
    <div id="critical-hp-overlay"></div>

    <!-- v6.80: Impact Border Pulse -->
    <div id="impact-border"></div>

    <!-- v6.80: Ability Activation Flash -->
    <div id="ability-flash"></div>

    <!-- v6.80: Boss Introduction Overlay -->
    <div id="boss-intro-overlay">
        <div class="boss-intro-title" id="boss-intro-name"></div>
        <div class="boss-intro-subtitle" id="boss-intro-title"></div>
    </div>

    <!-- v6.80: Momentum Meter -->
    <div id="momentum-meter">
        <div id="momentum-fill"></div>
        <div id="momentum-label">MOMENTUM</div>
    </div>

    <!-- v6.80: Victory Confetti Container -->
    <div id="confetti-container"></div>

    <!-- v6.32: Auto-save Indicator -->
    <div id="autosave-indicator">
        <span class="save-icon"></span>
        <span>Saving...</span>
    </div>

    <!-- v6.40: 4D TESSERACT WALK-THROUGH UI -->
    <!-- Tesseract HUD -->
    <div id="tesseract-hud" class="tesseract-hud">
        <div class="tesseract-header">
            <div>
                <div class="tesseract-title">4D TESSERACT</div>
                <div class="tesseract-subtitle">IMPOSSIBLE GEOMETRY WALK-THROUGH</div>
            </div>
            <button class="tesseract-exit-btn" onclick="exitTesseract()" aria-label="Exit Tesseract and return to Galaxy view"> EXIT TO GALAXY</button>
        </div>
    </div>

    <!-- 4D Rotation Controls -->
    <!-- v6.60: Enhanced rotation controls with educational tooltips -->
    <div id="tesseract-controls" class="tesseract-controls">
        <div class="rotation-plane">
            <div class="rotation-plane-label">XY <span class="rotation-plane-value" id="rot-xy-val">0</span></div>
            <input type="range" id="rot-xy" min="0" max="360" value="0" oninput="updateTesseractRotation()">
            <div class="rotation-plane-tooltip">
                <div class="rotation-plane-tooltip-title">XY Plane Rotation</div>
                <div class="rotation-plane-tooltip-desc">Rotation around the Z-axis. This is like spinning a top or turning a steering wheel.</div>
                <span class="rotation-plane-tooltip-tag">3D Rotation</span>
            </div>
        </div>
        <div class="rotation-plane">
            <div class="rotation-plane-label">XZ <span class="rotation-plane-value" id="rot-xz-val">0</span></div>
            <input type="range" id="rot-xz" min="0" max="360" value="0" oninput="updateTesseractRotation()">
            <div class="rotation-plane-tooltip">
                <div class="rotation-plane-tooltip-title">XZ Plane Rotation</div>
                <div class="rotation-plane-tooltip-desc">Rotation around the Y-axis. Like a compass needle or spinning in place.</div>
                <span class="rotation-plane-tooltip-tag">3D Rotation</span>
            </div>
        </div>
        <div class="rotation-plane">
            <div class="rotation-plane-label">XW <span class="rotation-plane-value" id="rot-xw-val">0</span></div>
            <input type="range" id="rot-xw" min="0" max="360" value="0" oninput="updateTesseractRotation()">
            <div class="rotation-plane-tooltip">
                <div class="rotation-plane-tooltip-title">XW Plane Rotation</div>
                <div class="rotation-plane-tooltip-desc">The X-axis rotates INTO the 4th dimension. Vertices "flip through" hyperspace - impossible in 3D!</div>
                <span class="rotation-plane-tooltip-tag">&#x2728; 4D Only</span>
            </div>
        </div>
        <div class="rotation-plane">
            <div class="rotation-plane-label">YZ <span class="rotation-plane-value" id="rot-yz-val">0</span></div>
            <input type="range" id="rot-yz" min="0" max="360" value="0" oninput="updateTesseractRotation()">
            <div class="rotation-plane-tooltip">
                <div class="rotation-plane-tooltip-title">YZ Plane Rotation</div>
                <div class="rotation-plane-tooltip-desc">Rotation around the X-axis. Like a wheel rolling forward or nodding your head.</div>
                <span class="rotation-plane-tooltip-tag">3D Rotation</span>
            </div>
        </div>
        <div class="rotation-plane">
            <div class="rotation-plane-label">YW <span class="rotation-plane-value" id="rot-yw-val">0</span></div>
            <input type="range" id="rot-yw" min="0" max="360" value="0" oninput="updateTesseractRotation()">
            <div class="rotation-plane-tooltip">
                <div class="rotation-plane-tooltip-title">YW Plane Rotation</div>
                <div class="rotation-plane-tooltip-desc">The Y-axis (vertical) rotates into W. "Up" and "Ana" exchange places - hyper-vertical motion!</div>
                <span class="rotation-plane-tooltip-tag">&#x2728; 4D Only</span>
            </div>
        </div>
        <div class="rotation-plane">
            <div class="rotation-plane-label">ZW <span class="rotation-plane-value" id="rot-zw-val">0</span></div>
            <input type="range" id="rot-zw" min="0" max="360" value="0" oninput="updateTesseractRotation()">
            <div class="rotation-plane-tooltip">
                <div class="rotation-plane-tooltip-title">ZW Plane Rotation</div>
                <div class="rotation-plane-tooltip-desc">The Z-axis (depth) rotates into W. Forward becomes hyperforward - the deepest 4D rotation.</div>
                <span class="rotation-plane-tooltip-tag">&#x2728; 4D Only</span>
            </div>
        </div>
    </div>

    <!-- Room Indicator -->
    <div id="tesseract-room" class="tesseract-room-indicator">
        <div class="room-name" id="room-name">The Outer Cube</div>
        <div class="room-desc" id="room-desc">You are in ordinary 3D space. Walk toward a wall to enter...</div>
    </div>

    <!-- Portal Prompt -->
    <div id="portal-prompt" class="portal-prompt">Press SPACE to enter portal</div>

    <!-- Dimension Shift Overlay -->
    <div id="dimension-shift" class="dimension-shift-overlay">
        <div class="dimension-shift-text">SHIFTING DIMENSIONS...</div>
    </div>

    <!-- Movement Hint -->
    <div id="tesseract-hint" class="tesseract-movement-hint">
        <span><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move</span>
        <span><kbd>Mouse</kbd> Look</span>
        <span><kbd>SPACE</kbd> Enter Portal</span>
        <span><kbd>ESC</kbd> Exit</span>
    </div>

    <!-- v6.60: THROUGH THE TESSERACT - 4D Higher Dimensional Guide -->

    <!-- IMMERSIVE TUTORIAL SYSTEM -->
    <!-- Narrator - The voice of the tesseract -->
    <div id="tesseract-narrator" class="tesseract-narrator">
        <div id="narrator-text" class="narrator-text"></div>
    </div>

    <!-- Tutorial Stage Indicator -->
    <div id="tutorial-stage" class="tutorial-stage"></div>

    <!-- Interactive Prompt -->
    <div id="tutorial-prompt" class="tutorial-prompt">
        <div id="tutorial-prompt-text" class="tutorial-prompt-text"></div>
        <div id="tutorial-prompt-hint" class="tutorial-prompt-hint"></div>
    </div>

    <!-- Success Feedback -->
    <div id="tutorial-success" class="tutorial-success">&#x2713;</div>

    <!-- W-Axis Visualization -->
    <div id="w-axis-hint" class="w-axis-hint">
        <div class="w-axis-label w-axis-label-ana">+W (ANA)</div>
        <div class="w-axis-arrow">&#x2B06;</div>
        <div class="w-axis-label">THE FOURTH DIRECTION</div>
        <div class="w-axis-arrow" style="transform: rotate(180deg);">&#x2B06;</div>
        <div class="w-axis-label w-axis-label-kata">-W (KATA)</div>
    </div>

    <!-- Skip Tutorial Button -->
    <!-- v6.84: Added ARIA label for accessibility -->
    <button id="tutorial-skip" class="tutorial-skip" onclick="skipImmersiveTutorial()" aria-label="Skip the tutorial and go directly to gameplay">Skip Tutorial</button>

    <!-- Vertex Trail Hint -->
    <div id="vertex-trail-hint" class="vertex-trail-hint">
        Watch the glowing vertices - they're not disappearing, they're rotating <em>through</em> you
    </div>

    <!-- Cell Highlight Text -->

    <!-- v6.82: 4D INTUITION ENGINE - New Elements -->
    
    <!-- Eureka Flash Effect -->
    <div id="eureka-flash"></div>
    
    <!-- Eureka Popup -->
    <div id="eureka-popup" class="eureka-popup">
        <div class="eureka-icon"></div>
        <div class="eureka-title" id="eureka-title">EUREKA</div>
        <div class="eureka-message" id="eureka-message">You understood something profound.</div>
        <div class="eureka-achievement" id="eureka-achievement">DIMENSIONAL THINKER</div>
    </div>
    
    <!-- Ana/Kata Legend -->
    <div id="ana-kata-legend" class="ana-kata-legend">
        <div class="ana-kata-legend-title">W-COORDINATE</div>
        <div class="ana-kata-legend-item">
            <div class="ana-kata-dot ana"></div>
            <span class="ana-kata-label ana"><strong>+W (Ana)</strong> - Hyperward</span>
        </div>
        <div class="ana-kata-legend-item">
            <div class="ana-kata-dot neutral"></div>
            <span class="ana-kata-label neutral"><strong>W=0</strong> - Our 3D slice</span>
        </div>
        <div class="ana-kata-legend-item">
            <div class="ana-kata-dot kata"></div>
            <span class="ana-kata-label kata"><strong>-W (Kata)</strong> - Anti-hyperward</span>
        </div>
    </div>
    
    <!-- Inside-Out Indicator -->
    <div id="inside-out-indicator"> HYPERCUBE INVERTING </div>
    
    <!-- Flatland Overlay -->
    <div id="flatland-overlay">
        <div class="flatland-header">
            <div class="flatland-title">FLATLAND</div>
            <div class="flatland-subtitle">A ROMANCE OF MANY DIMENSIONS</div>
        </div>
        <canvas id="flatland-canvas"></canvas>
        <div class="flatland-narrator" id="flatland-narrator"></div>
    </div>
    
    <!-- Dimensional Ladder -->
    <div id="dimensional-ladder">
        <div class="ladder-header">
            <div class="ladder-title">THE PATTERN</div>
            <div class="ladder-subtitle">How dimensions are built</div>
        </div>
        <div class="ladder-display" id="ladder-display">
            <div class="ladder-step" data-dim="0">
                <div class="ladder-shape-container" id="shape-0d"></div>
                <div class="ladder-label">0D POINT</div>
                <div class="ladder-stats"><span>1</span> vertex</div>
            </div>
            <div class="ladder-step" data-dim="1">
                <div class="ladder-shape-container" id="shape-1d"></div>
                <div class="ladder-label">1D LINE</div>
                <div class="ladder-stats"><span>2</span> vertices, <span>1</span> edge</div>
            </div>
            <div class="ladder-step" data-dim="2">
                <div class="ladder-shape-container" id="shape-2d"></div>
                <div class="ladder-label">2D SQUARE</div>
                <div class="ladder-stats"><span>4</span> vertices, <span>4</span> edges</div>
            </div>
            <div class="ladder-step" data-dim="3">
                <div class="ladder-shape-container" id="shape-3d"></div>
                <div class="ladder-label">3D CUBE</div>
                <div class="ladder-stats"><span>8</span> vertices, <span>12</span> edges</div>
            </div>
            <div class="ladder-step" data-dim="4">
                <div class="ladder-shape-container" id="shape-4d">?</div>
                <div class="ladder-label">4D TESSERACT</div>
                <div class="ladder-stats" id="ladder-4d-stats">? vertices, ? edges</div>
            </div>
        </div>
        <div class="ladder-prediction" id="ladder-prediction">
            <div class="ladder-question">Based on the pattern, how many vertices does a tesseract have?</div>
            <div class="ladder-input-group">
                <div class="ladder-input-item">
                    <label>Vertices</label>
                    <input type="number" id="predict-vertices" placeholder="?" min="0" max="100">
                </div>
                <div class="ladder-input-item">
                    <label>Edges</label>
                    <input type="number" id="predict-edges" placeholder="?" min="0" max="100">
                </div>
            </div>
            <button class="ladder-submit" onclick="checkDimensionalPrediction()">SUBMIT PREDICTION</button>
        </div>
    </div>

    <div id="cell-highlight-text" class="cell-highlight-text"></div>

    <!-- Guide Toggle Button -->
    <!-- v6.84: Added ARIA attributes for accessibility -->
    <button id="tesseract-guide-toggle" class="tesseract-guide-toggle" onclick="toggleTesseractGuide()" aria-label="Open 4D Tesseract guide panel" aria-expanded="false">
        <span class="guide-icon" aria-hidden="true">&#x1F4D6;</span>
        <span class="guide-label">4D GUIDE</span>
    </button>

    <!-- 4D Guide Panel -->
    <div id="tesseract-guide-panel" class="tesseract-guide-panel">
        <div class="guide-header">
            <div class="guide-header-title">THROUGH THE TESSERACT</div>
            <div class="guide-header-subtitle">Higher Dimensional Guide</div>
            <button class="guide-close-btn" onclick="toggleTesseractGuide()">&times;</button>
        </div>

        <div class="guide-tabs">
            <button class="guide-tab active" onclick="switchGuideTab('basics')">Basics</button>
            <button class="guide-tab" onclick="switchGuideTab('rotations')">Rotations</button>
            <button class="guide-tab" onclick="switchGuideTab('rooms')">Rooms</button>
            <button class="guide-tab" onclick="switchGuideTab('philosophy')">Mind</button>
        </div>

        <div class="guide-content">
            <!-- BASICS TAB -->
            <div id="guide-basics" class="guide-tab-content active">
                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F300;</span>
                        What is 4D Space?
                    </div>
                    <p>You exist in 3D space: you can move left/right, forward/backward, and up/down. But mathematically, there's no reason space has to stop at three dimensions.</p>
                    <p>The <strong>fourth spatial dimension</strong> (W) is a direction perpendicular to all three directions you know. It's impossible to point toward it in our universe, but mathematics lets us explore it.</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x2B1C;</span>
                        What is a Tesseract?
                    </div>
                    <p>A tesseract (or hypercube) is to a cube what a cube is to a square:</p>
                    <div class="concept-card">
                        <div class="concept-card-title">Dimensional Progression</div>
                        <div class="concept-card-desc">
                            <strong>0D:</strong> Point (no dimensions)<br>
                            <strong>1D:</strong> Line (1 direction)<br>
                            <strong>2D:</strong> Square (2 directions)<br>
                            <strong>3D:</strong> Cube (3 directions)<br>
                            <strong>4D:</strong> Tesseract (4 directions)
                        </div>
                    </div>
                    <p>A tesseract has 16 vertices, 32 edges, 24 square faces, and 8 cubic cells. You're walking through one of those cells right now.</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F441;</span>
                        Why Does It Look Strange?
                    </div>
                    <p>What you see is a <strong>3D shadow</strong> of a 4D object. Just as a 3D cube casts a 2D shadow on a wall, a 4D tesseract casts a 3D "shadow" that we can see.</p>
                    <p>The distortions you see are because the W-axis is being projected away - parts of the tesseract that extend into the 4th dimension appear squished or enlarged.</p>
                </div>

                <button class="tour-btn primary" style="width: 100%; margin-top: 10px;" onclick="startGuidedTour()">
                    &#x1F680; Start Guided Tour
                </button>
            </div>

            <!-- ROTATIONS TAB -->
            <div id="guide-rotations" class="guide-tab-content">
                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F504;</span>
                        Understanding 4D Rotation
                    </div>
                    <p>In 3D, we rotate around axes (X, Y, Z). In 4D, we rotate in <strong>planes</strong>. With 4 dimensions, there are 6 possible rotation planes.</p>
                    <p>Three are familiar (3D rotations). Three are impossible in our world (4D rotations).</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F310;</span>
                        3D Rotations (Familiar)
                    </div>
                    <div class="rotation-explainer">
                        <div class="rotation-card" onclick="focusRotation('xy')">
                            <div class="rotation-card-label">XY Plane</div>
                            <div class="rotation-card-desc">Rotation around Z-axis. Like spinning a top.</div>
                            <div class="rotation-card-type">&#x2705; EXISTS IN 3D</div>
                        </div>
                        <div class="rotation-card" onclick="focusRotation('xz')">
                            <div class="rotation-card-label">XZ Plane</div>
                            <div class="rotation-card-desc">Rotation around Y-axis. Like a compass needle.</div>
                            <div class="rotation-card-type">&#x2705; EXISTS IN 3D</div>
                        </div>
                        <div class="rotation-card" onclick="focusRotation('yz')">
                            <div class="rotation-card-label">YZ Plane</div>
                            <div class="rotation-card-desc">Rotation around X-axis. Like a wheel rolling.</div>
                            <div class="rotation-card-type">&#x2705; EXISTS IN 3D</div>
                        </div>
                    </div>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x2728;</span>
                        4D Rotations (Impossible)
                    </div>
                    <p>These rotations involve the W-axis. They're mathematically valid but physically impossible in our universe.</p>
                    <div class="rotation-explainer">
                        <div class="rotation-card dimensional" onclick="focusRotation('xw')">
                            <div class="rotation-card-label">XW Plane</div>
                            <div class="rotation-card-desc">X rotates into W. Points "flip" through the 4th dimension.</div>
                            <div class="rotation-card-type">&#x1F31F; 4D ONLY</div>
                        </div>
                        <div class="rotation-card dimensional" onclick="focusRotation('yw')">
                            <div class="rotation-card-label">YW Plane</div>
                            <div class="rotation-card-desc">Y rotates into W. Vertical becomes hypervertical.</div>
                            <div class="rotation-card-type">&#x1F31F; 4D ONLY</div>
                        </div>
                        <div class="rotation-card dimensional" onclick="focusRotation('zw')">
                            <div class="rotation-card-label">ZW Plane</div>
                            <div class="rotation-card-desc">Z rotates into W. Depth becomes hyperdepth.</div>
                            <div class="rotation-card-type">&#x1F31F; 4D ONLY</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ROOMS TAB -->
            <div id="guide-rooms" class="guide-tab-content">
                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F3DB;</span>
                        The 8 Cubic Cells
                    </div>
                    <p>A tesseract contains 8 cubic cells - 3D "rooms" that share faces with each other in impossible ways. Each room you visit is one of these cells.</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F6AA;</span>
                        Why Rooms Feel Bigger Inside
                    </div>
                    <p>In 4D, a room can have more interior volume than its 3D exterior suggests. The "extra" space extends into the W dimension.</p>
                    <p>Think of it like this: a flat shadow of a box looks like a square - you can't tell how deep it is. Similarly, a 3D "shadow" of a 4D room hides its W-depth.</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F52E;</span>
                        Portals Between Cells
                    </div>
                    <p>The portals connect cubic cells through their shared faces. When you step through a portal, you're moving in the W direction - even though it feels like you're walking forward.</p>
                    <p>This is why each room can lead to multiple others without overlapping. They're not stacked in 3D; they're arranged in 4D.</p>
                </div>
            </div>

            <!-- PHILOSOPHY TAB -->
            <div id="guide-philosophy" class="guide-tab-content">
                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x1F9E0;</span>
                        What You Look Like from 4D
                    </div>
                    <p>A 4D being looking at you would see your entire 3D body at once - your skin, your organs, your skeleton - all simultaneously visible, like how you can see the entire 2D cross-section of an orange slice.</p>
                    <p>Your timeline would appear as a 4D "worm" - every moment of your existence laid out like a sculpture through time.</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x231B;</span>
                        Time as a Fourth Dimension
                    </div>
                    <p>Einstein showed that time is dimension-like. But the W-axis here is a <strong>fourth spatial dimension</strong> - not time. It's a direction you could theoretically walk in, if physics allowed it.</p>
                    <p>In this tesseract, you're exploring what it might feel like if that extra direction actually existed.</p>
                </div>

                <div class="guide-section">
                    <div class="guide-section-title">
                        <span class="section-icon">&#x267E;</span>
                        The Limits of Perception
                    </div>
                    <p>Your brain evolved in 3D. It has no hardware for processing 4D space directly. What you're seeing is your visual cortex's best attempt at interpreting something it was never designed to understand.</p>
                    <p>The confusion, the wrongness, the sense that something is off - that's your 3D brain brushing against a higher reality it cannot fully grasp.</p>
                </div>

                <button class="tour-btn secondary" style="width: 100%; margin-top: 10px;" onclick="openTesseractGlossary()">
                    &#x1F4D6; Open 4D Glossary
                </button>
            </div>
        </div>
    </div>

    <!-- W-Coordinate Indicator -->
    <div id="w-coordinate-indicator" class="w-coordinate-indicator">
        <div class="w-indicator-title">W-AXIS POSITION</div>
        <div class="w-indicator-visual">
            <div class="w-indicator-bar"></div>
            <div id="w-indicator-marker" class="w-indicator-marker" style="top: 50%;"></div>
        </div>
        <div class="w-indicator-labels">
            <span>-W (ANA)</span>
            <span>+W (KATA)</span>
        </div>
        <div id="w-indicator-value" class="w-indicator-value">0.00</div>
        <div class="w-indicator-label">Fourth Dimensional Depth</div>
    </div>

    <!-- Guided Tour Overlay -->
    <div id="tesseract-tour-overlay" class="tesseract-tour-overlay">
        <div class="tour-card">
            <div id="tour-step-indicator" class="tour-step-indicator">STEP 1 OF 7</div>
            <div id="tour-visual" class="tour-visual">&#x1F300;</div>
            <div id="tour-title" class="tour-title">Welcome to 4D Space</div>
            <div id="tour-content" class="tour-content">
                You have crossed the event horizon and entered a tesseract - a four-dimensional hypercube. Everything you thought you knew about space is about to change.
            </div>
            <div class="tour-buttons">
                <button class="tour-btn secondary" onclick="skipTour()">Skip Tour</button>
                <button class="tour-btn primary" onclick="nextTourStep()">Continue &#x2192;</button>
            </div>
        </div>
    </div>

    <!-- 4D Glossary Modal -->
    <div id="tesseract-glossary" class="tesseract-glossary">
        <div class="glossary-content">
            <div class="glossary-header">
                <div class="glossary-title">&#x1F4D6; 4D Glossary</div>
                <button class="guide-close-btn" onclick="closeTesseractGlossary()">&times;</button>
            </div>
            <div class="glossary-body">
                <div class="glossary-term">
                    <div class="glossary-term-name">Tesseract (Hypercube)</div>
                    <div class="glossary-term-def">The 4D analog of a cube. It has 16 vertices, 32 edges, 24 square faces, and 8 cubic cells. Also called an 8-cell or octachoron.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">W-Axis</div>
                    <div class="glossary-term-def">The fourth spatial dimension, perpendicular to X, Y, and Z. Movement along W is impossible in our universe but mathematically valid.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Ana / Kata</div>
                    <div class="glossary-term-def">Coined by Charles Hinton in 1888. "Ana" means movement in the +W direction, "Kata" means movement in the -W direction. Like up/down for the fourth dimension.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Stereographic Projection</div>
                    <div class="glossary-term-def">A method of projecting higher-dimensional objects into lower dimensions. The tesseract you see is a 3D stereographic projection of a 4D object.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Rotation Plane</div>
                    <div class="glossary-term-def">In 4D, rotation happens in a plane, not around an axis. Six rotation planes exist: XY, XZ, XW, YZ, YW, ZW. Three involve W and are impossible in 3D.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Cell (4D)</div>
                    <div class="glossary-term-def">The 3D boundary element of a 4D shape. A tesseract has 8 cubic cells, just as a cube has 6 square faces.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Hyperplane</div>
                    <div class="glossary-term-def">A 3D "slice" of 4D space. The room you're standing in is a hyperplane - a 3D cross-section of the tesseract.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Klein Bottle</div>
                    <div class="glossary-term-def">A non-orientable surface that can only exist without self-intersection in 4D. It has no inside or outside - like a M&ouml;bius strip with no edges.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">Flatland</div>
                    <div class="glossary-term-def">An 1884 novella by Edwin Abbott exploring how 2D beings would perceive 3D. A useful analogy for understanding how 3D beings (us) perceive 4D.</div>
                </div>
                <div class="glossary-term">
                    <div class="glossary-term-name">4D Intuition</div>
                    <div class="glossary-term-def">With practice, some mathematicians develop a "feel" for 4D space. Your brain can build new pathways for processing higher dimensions, though true 4D vision remains impossible.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Black Hole Entry Modal -->
    <div id="black-hole-entry" class="black-hole-entry">
        <h2> EVENT HORIZON</h2>
        <p>You have approached the supermassive black hole at the galaxy's center. Beyond lies a gateway to the 4th dimension - a tesseract of impossible geometry where space folds upon itself.</p>
        <p style="color: #ff88ff; font-weight: bold;">Do you dare to enter?</p>
        <div class="black-hole-entry-buttons">
            <button class="black-hole-entry-btn enter" onclick="enterTesseract()">ENTER THE TESSERACT</button>
            <button class="black-hole-entry-btn cancel" onclick="cancelBlackHoleEntry()">Stay in Galaxy</button>
        </div>
    </div>

    <!-- v6.35: Settings toggle button for cinematic view -->
    <!-- v6.84: Added ARIA attributes for accessibility -->
    <button id="settings-toggle-btn" class="settings-toggle-btn" onclick="toggleSettingsPanel()" title="Toggle Settings (S)" aria-label="Toggle settings panel" aria-expanded="false">
        <span aria-hidden="true"></span>
    </button>

    <!-- v6.29: PHYSICS TUTORIAL PANEL - Interactive orbital mechanics controls -->
    <div id="physics-tutorial" class="physics-tutorial">
        <div class="physics-tutorial-header">
            <div class="physics-tutorial-icon"></div>
            <div>
                <div class="physics-tutorial-title">ORBITAL PHYSICS</div>
                <div class="physics-tutorial-subtitle">Real-time Keplerian mechanics</div>
            </div>
        </div>

        <!-- Gravitational Constant -->
        <div class="physics-control">
            <div class="physics-control-header">
                <span class="physics-control-label">Gravitational Constant (G)</span>
                <span class="physics-control-value" id="physics-g-value">50,000</span>
            </div>
            <div class="physics-control-desc">Controls the strength of gravity. Higher = faster orbits.</div>
            <div class="physics-slider-container">
                <input type="range" class="physics-slider" id="physics-g" min="10000" max="150000" value="50000" step="1000">
                <div class="slider-bubble" id="physics-g-bubble">50,000</div>
            </div>
        </div>

        <!-- Black Hole Mass -->
        <div class="physics-control">
            <div class="physics-control-header">
                <span class="physics-control-label">Black Hole Mass (M)</span>
                <span class="physics-control-value" id="physics-mass-value">1,000</span>
            </div>
            <div class="physics-control-desc">Mass of central body. Heavier = stronger pull.</div>
            <div class="physics-slider-container">
                <input type="range" class="physics-slider" id="physics-mass" min="100" max="5000" value="1000" step="100">
                <div class="slider-bubble" id="physics-mass-bubble">1,000</div>
            </div>
        </div>

        <!-- Time Scale -->
        <div class="physics-control">
            <div class="physics-control-header">
                <span class="physics-control-label">Time Scale</span>
                <span class="physics-control-value" id="physics-time-value">0.50x</span>
            </div>
            <div class="physics-control-desc">Speed of simulation. Slow down to observe, speed up to see patterns.</div>
            <div class="physics-slider-container">
                <input type="range" class="physics-slider" id="physics-time" min="0.05" max="3" value="0.5" step="0.05">
                <div class="slider-bubble" id="physics-time-bubble">0.50x</div>
            </div>
        </div>

        <!-- Eccentricity -->
        <div class="physics-control">
            <div class="physics-control-header">
                <span class="physics-control-label">Orbit Eccentricity</span>
                <span class="physics-control-value" id="physics-ecc-value">0.30</span>
            </div>
            <div class="physics-control-desc">How elliptical orbits are. 0 = circular, 1 = parabolic.</div>
            <div class="physics-slider-container">
                <input type="range" class="physics-slider" id="physics-ecc" min="0" max="0.8" value="0.3" step="0.05">
                <div class="slider-bubble" id="physics-ecc-bubble">0.30</div>
            </div>
        </div>

        <!-- v6.31: Preset Scenarios -->
        <div style="background: rgba(0,0,0,0.3); border: 1px solid rgba(0,255,255,0.15); border-radius: 6px; padding: 10px; margin-bottom: 12px;">
            <div style="font-size: 10px; color: #668899; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Quick Scenarios:</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                <button onclick="applyPhysicsPreset('stable')" style="background: rgba(0,136,255,0.2); border: 1px solid rgba(0,136,255,0.4); color: #00ccff; padding: 6px; font-size: 10px; border-radius: 4px; cursor: pointer;"> Stable</button>
                <button onclick="applyPhysicsPreset('fast')" style="background: rgba(0,136,255,0.2); border: 1px solid rgba(0,136,255,0.4); color: #00ccff; padding: 6px; font-size: 10px; border-radius: 4px; cursor: pointer;"> Fast Orbits</button>
                <button onclick="applyPhysicsPreset('elliptical')" style="background: rgba(0,136,255,0.2); border: 1px solid rgba(0,136,255,0.4); color: #00ccff; padding: 6px; font-size: 10px; border-radius: 4px; cursor: pointer;"> Elliptical</button>
                <button onclick="applyPhysicsPreset('chaos')" style="background: rgba(255,100,0,0.2); border: 1px solid rgba(255,100,0,0.4); color: #ff8844; padding: 6px; font-size: 10px; border-radius: 4px; cursor: pointer;"> Chaos!</button>
            </div>
        </div>

        <div class="physics-formula">
            <div class="formula-main"> = (GM / r)</div>
            Kepler's Third Law: Angular velocity from gravity
        </div>

        <!-- v6.31: Escape velocity warning -->
        <div id="escape-warning" style="display: none; margin-top: 10px; padding: 8px; background: rgba(255,170,0,0.15); border: 1px solid rgba(255,170,0,0.4); border-radius: 6px; font-size: 11px; text-align: center; animation: pulse 0.8s ease-in-out infinite;"></div>

        <!-- Escaped planets counter -->
        <div id="escape-counter" style="margin-top: 10px; padding: 8px; background: rgba(255, 100, 0, 0.15); border: 1px solid rgba(255, 100, 0, 0.3); border-radius: 6px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #ff6600; font-size: 12px;"> Escaped Planets</span>
                <span id="escape-count" style="color: #ffaa00; font-weight: bold; font-size: 14px; transition: transform 0.2s;">0</span>
            </div>
            <div style="color: #886644; font-size: 9px; margin-top: 4px;">Drop G or M quickly to launch more!</div>
        </div>

        <div class="physics-hint">Move mouse to show  Try the presets!</div>

        <!-- v6.32: Advanced Features from 8 Strategy Agents Consensus -->
        <div style="background: rgba(128,0,255,0.1); border: 1px solid rgba(128,0,255,0.3); border-radius: 8px; padding: 12px; margin-top: 15px;">
            <div style="font-size: 11px; color: #bb88ff; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; font-weight: bold;"> v6.32 MIND-BLOWING FEATURES</div>

            <!-- Planet Rider Camera -->
            <div style="margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="color: #aaccff; font-size: 11px;"> Planet Rider Cam</span>
                    <button id="rider-cam-btn" onclick="togglePlanetRiderCam()" style="background: rgba(0,100,255,0.3); border: 1px solid #0088ff; color: #00ccff; padding: 4px 10px; font-size: 10px; border-radius: 4px; cursor: pointer;">OFF</button>
                </div>
                <div style="color: #667788; font-size: 9px;">Ride along on a planet's orbital journey</div>
            </div>

            <!-- Gravitational Lensing -->
            <div style="margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="color: #aaccff; font-size: 11px;"> Gravitational Lensing</span>
                    <button id="lensing-btn" onclick="toggleGravitationalLensing()" style="background: rgba(128,0,255,0.3); border: 1px solid #8800ff; color: #bb88ff; padding: 4px 10px; font-size: 10px; border-radius: 4px; cursor: pointer;">ON</button>
                </div>
                <div style="color: #667788; font-size: 9px;">Light bending around the supermassive black hole</div>
            </div>

            <!-- Planet Collisions -->
            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="color: #aaccff; font-size: 11px;"> Planet Collisions</span>
                    <button id="collisions-btn" onclick="togglePlanetCollisions()" style="background: rgba(255,100,0,0.3); border: 1px solid #ff6600; color: #ffaa44; padding: 4px 10px; font-size: 10px; border-radius: 4px; cursor: pointer;">ON</button>
                </div>
                <div style="color: #667788; font-size: 9px;">Planets can collide and create supernovae</div>
            </div>

            <!-- Collision Counter -->
            <div id="collision-counter" style="display: none; padding: 6px; background: rgba(255,60,60,0.15); border: 1px solid rgba(255,60,60,0.3); border-radius: 4px; text-align: center;">
                <span style="color: #ff6666; font-size: 10px;"> Collisions: </span>
                <span id="collision-count" style="color: #ffaa66; font-weight: bold;">0</span>
            </div>

            <!-- v6.33: Auto-hide settings toggle -->
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(128,0,255,0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: #8899aa; font-size: 10px;"> Auto-hide Panel</span>
                    <button id="autohide-btn" onclick="toggleAutoHideSettings()" style="background: rgba(100,100,100,0.3); border: 1px solid #666; color: #aaa; padding: 4px 10px; font-size: 10px; border-radius: 4px; cursor: pointer;">ON</button>
                </div>
            </div>
        </div>

        <!-- v6.95: Universe Ignition Tip -->
        <div style="background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,50,0,0.05)); border: 1px solid rgba(255,100,0,0.3); border-radius: 8px; padding: 10px; margin-top: 12px;">
            <div style="font-size: 10px; color: #ff9944; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; font-weight: bold;"> Universe Ignition</div>
            <div style="color: #888; font-size: 9px; line-height: 1.5;">
                Destroyed & escaped planets are <strong style="color:#ffaa66;">permanent</strong>.
                When all planets are gone, discover new galaxies to ignite.
                Share via <strong style="color:#ffaa66;">QR code</strong> to let others visit your universe!
            </div>
            <button onclick="openGalaxyManager()" style="width: 100%; margin-top: 8px; background: rgba(255,100,0,0.2); border: 1px solid rgba(255,100,0,0.4); color: #ff9944; padding: 6px; font-size: 10px; border-radius: 4px; cursor: pointer;"> Galaxy Manager</button>
        </div>
    </div>

    <!-- v6.33: Planet Approach Cinematic Overlay -->
    <div id="planet-approach-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 500; pointer-events: none;">
        <!-- Cinematic letterbox bars -->
        <div id="letterbox-top" style="position: absolute; top: 0; left: 0; width: 100%; height: 0; background: #000; transition: height 0.8s ease;"></div>
        <div id="letterbox-bottom" style="position: absolute; bottom: 0; left: 0; width: 100%; height: 0; background: #000; transition: height 0.8s ease;"></div>

        <!-- Planet info HUD -->
        <div id="approach-hud" style="position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); text-align: center; opacity: 0; transition: opacity 1s ease;">
            <div style="font-size: 12px; color: #668899; text-transform: uppercase; letter-spacing: 3px; margin-bottom: 8px;">APPROACHING</div>
            <div id="approach-planet-name" style="font-size: 36px; font-weight: bold; color: #00ffff; text-shadow: 0 0 20px rgba(0,255,255,0.5); letter-spacing: 4px;"></div>
            <div id="approach-planet-biome" style="font-size: 14px; color: #aaccff; margin-top: 8px;"></div>
            <div style="margin-top: 20px; display: flex; gap: 30px; justify-content: center;">
                <div style="text-align: center;">
                    <div id="approach-distance" style="font-size: 24px; color: #ffaa00; font-weight: bold;">0</div>
                    <div style="font-size: 10px; color: #666;">DISTANCE (km)</div>
                </div>
                <div style="text-align: center;">
                    <div id="approach-velocity" style="font-size: 24px; color: #00ff88; font-weight: bold;">0</div>
                    <div style="font-size: 10px; color: #666;">VELOCITY (km/s)</div>
                </div>
                <div style="text-align: center;">
                    <div id="approach-eta" style="font-size: 24px; color: #ff6688; font-weight: bold;">0</div>
                    <div style="font-size: 10px; color: #666;">ETA (sec)</div>
                </div>
            </div>
        </div>

        <!-- Landing prompt -->
        <div id="approach-land-prompt" style="position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.5s ease; pointer-events: auto;">
            <button onclick="completePlanetApproach()" style="background: linear-gradient(135deg, #00aaff, #0066cc); border: 2px solid #00ccff; color: #fff; padding: 15px 40px; font-size: 16px; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 0 30px rgba(0,170,255,0.5); animation: pulse-glow 1.5s ease-in-out infinite;">
                 INITIATE LANDING
            </button>
        </div>

        <!-- Skip button -->
        <div id="approach-skip" style="position: absolute; top: 20px; right: 20px; opacity: 0; transition: opacity 0.5s ease; pointer-events: auto;">
            <button onclick="skipPlanetApproach()" style="background: rgba(0,0,0,0.5); border: 1px solid #444; color: #888; padding: 8px 16px; font-size: 11px; border-radius: 4px; cursor: pointer;">SKIP [ESC]</button>
        </div>
    </div>

    <div class="ui-layer">
        <!-- Data Controls - Two rows for better organization -->
        <div class="data-controls">
            <!-- Row 1: Game Features -->
            <button onclick="showStatsPanel()">Stats</button>
            <button onclick="openCodexModal()" style="background: linear-gradient(135deg, #ffd700, #ff8c00);">Codex</button>
            <button onclick="openQuestModal()" style="background: linear-gradient(135deg, #ff8c00, #ff4400);">Quests</button>
            <button onclick="openMasteryModal()" style="background: linear-gradient(135deg, #ff44ff, #8844ff);">Mastery</button>
            <button onclick="openPortalModal()" style="background: linear-gradient(135deg, #8844ff, #4488ff);">Portals</button>
            <button onclick="openEvolutionModal()" style="background: linear-gradient(135deg, #aa44ff, #ff44aa);">Evolve</button>
            <button onclick="showSettingsModal()">Settings</button>
            <!-- RAPPID prominently visible -->
            <button onclick="openRappidModal()" style="background: linear-gradient(135deg, #7b2cbf, #3a0ca3); border-color: #7b2cbf; color: #fff;">RAPPID</button>
            <!-- More menu for less used features -->
            <button class="menu-toggle" onclick="toggleSecondaryMenu()" style="background: rgba(255,255,255,0.1); border-color: #fff; color: #fff;">More </button>
            <!-- Secondary dropdown menu -->
            <div class="menu-secondary" id="menu-secondary">
                <button onclick="openShowcaseModal()" style="background: linear-gradient(135deg, #ffd700, #ffaa00);">Showcase</button>
                <button onclick="showRewindModal()" style="background: linear-gradient(135deg, #ff4488, #aa44ff);"> Rewind</button>
                <button onclick="quickSave()">Save</button>
                <button onclick="exportData()">Export Game</button>
                <button onclick="document.getElementById('importFile').click()">Import Game</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            <input type="file" id="rappidImportFile" accept=".json" style="display: none;" onchange="importRappidSettings(event)">
        </div>

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">GALAXY SIMULATION v6.73</div>
            </div>

            <div id="galaxy-controls" class="stats-box" style="align-items: center;">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <!-- v6.86: Discover New Galaxy button - appears when civilizations reach 0 -->
                <button id="discover-galaxy-btn" class="discover-galaxy-btn" onclick="openGalaxyDiscoveryModal()">
                     New Galaxy
                </button>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="total-playtime">0:00</span>
                    <span class="stat-lbl">Playtime</span>
                </div>
                <!-- v6.86: Galaxy Manager button -->
                <button class="galaxy-manager-btn" onclick="openGalaxyManager()"> <span id="galaxy-btn-count-main">Galaxies</span></button>
            </div>

            <!-- v6.81: Reorganized world controls - Planet info left, buttons center -->
            <div id="world-controls" class="stats-box" style="display:none; gap: 10px; align-items: center;">
                <div class="stat-entry">
                    <span class="stat-val" id="world-name">Terra</span>
                    <span class="stat-lbl">Planet</span>
                </div>
                <div style="display: flex; gap: 6px; align-items: center;">
                    <button class="action-btn" onclick="returnToGalaxy()" style="padding: 5px 10px; font-size: 11px;">LEAVE</button>
                    <button class="action-btn" onclick="openMarketUI()" style="background: linear-gradient(135deg, #ffd700, #ff8c00); color: #000; font-weight: bold; padding: 5px 10px; font-size: 11px;"></button>
                </div>
            </div>
        </div>

        <!-- v6.99: Quick access buttons moved to bottom-left RTS panel toggles -->

        <!-- v6.81: AI Behavior Panel - Moved to fixed position for better layout -->
        <!-- v6.98: Lowered z-index to 50 so top bar buttons remain clickable -->
        <div id="ai-behavior-panel" style="display: none; position: fixed; top: 70px; right: 10px; z-index: 50;
            background: linear-gradient(180deg, rgba(15,20,35,0.95) 0%, rgba(10,15,25,0.98) 100%);
            border: 1px solid rgba(68, 136, 255, 0.4); border-radius: 10px; padding: 12px; width: 180px;
            backdrop-filter: blur(8px); box-shadow: 0 4px 20px rgba(0,0,0,0.5); pointer-events: auto;">
            <div style="font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <span></span> AI BEHAVIOR
            </div>
            <select id="ai-behavior-select" onchange="setAIBehavior(this.value)" style="width: 100%; padding: 8px; background: linear-gradient(135deg, #1a1a3a, #2a2a4a); color: #fff; border: 2px solid #4488ff; border-radius: 6px; font-size: 11px; cursor: pointer; font-weight: bold;">
                <option value="manual"> Manual Control</option>
                <option value="explorer" selected> Explorer</option>
                <option value="pusher"> Lane Pusher</option>
                <option value="miner"> Miner</option>
                <option value="defender"> Defender</option>
                <option value="terraformer"> Terraformer</option>
                <option value="builder"> Builder</option>
                <option value="hunter"> Hunter</option>
                <option value="trader"> Trader</option>
            </select>
            <div id="ai-behavior-status" style="text-align: center; margin-top: 8px; font-size: 11px; color: #00ff88; background: rgba(0,255,136,0.1); border-radius: 4px; padding: 5px;">
                 EXPLORING
            </div>
            <div id="ai-behavior-details" style="font-size: 9px; color: #aaa; margin-top: 6px; text-align: center; line-height: 1.3;">
                Auto-gathering resources and fighting mobs
            </div>
        </div>

        <!-- v5.14: Explorer Robot Integrity Bar (v5.15.2: Improved styling) -->
        <div id="player-health-bar" class="player-health-bar">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;"></span>
                    <span style="font-size: 11px; color: #0ff; letter-spacing: 1px; font-weight: bold;">PROBE INTEGRITY</span>
                </div>
                <span id="health-text" class="player-health-text">100 / 100</span>
            </div>
            <div style="height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;">
                <div id="player-health-fill" class="player-health-fill"></div>
            </div>
            <!-- v5.18: Robot Energy Bar -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 8px; margin-bottom: 4px;">
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 12px;"></span>
                    <span style="font-size: 10px; color: #ffaa00; letter-spacing: 1px; font-weight: bold;">ENERGY</span>
                </div>
                <span id="robot-energy-text" style="font-size: 11px; color: #aaa;">100/100</span>
            </div>
            <div style="height: 6px; background: rgba(0,0,0,0.5); border-radius: 3px; overflow: hidden;">
                <div id="robot-energy-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #0088ff, #00aaff); transition: width 0.3s, background 0.3s;"></div>
            </div>
            <!-- v6.1: Active Potion Buffs Display -->
            <div id="active-buffs-container" style="margin-top: 8px; display: none;">
                <div style="font-size: 9px; color: #ff88ff; letter-spacing: 1px; margin-bottom: 4px;">ACTIVE BUFFS</div>
                <div id="active-buffs-list" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
            </div>
        </div>

        <!-- v6.9: Style Meter (Agent consensus - Combat Depth) -->
        <div id="style-meter" style="display: none; position: fixed; top: 200px; right: 20px; z-index: 100;
            width: 40px; height: 200px; background: rgba(10, 10, 20, 0.85); border-radius: 20px;
            border: 2px solid #444; overflow: hidden; backdrop-filter: blur(5px);">
            <div id="style-meter-fill" style="position: absolute; bottom: 0; left: 0; right: 0; height: 0%;
                background: linear-gradient(to top, #888, #888888); transition: height 0.2s, background 0.2s;"></div>
            <div id="style-meter-grade" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                font-size: 24px; font-weight: bold; color: #888; text-shadow: 0 0 10px #888;
                z-index: 2;">D</div>
            <div style="position: absolute; top: 5px; left: 50%; transform: translateX(-50%);
                font-size: 8px; color: #666; letter-spacing: 1px;">STYLE</div>
        </div>

        <!-- v6.43: Combo Counter Display -->
        <div id="combo-counter" style="display: none; position: fixed; top: 150px; right: 70px; z-index: 100;
            text-align: center; pointer-events: none;">
            <div id="combo-count" style="font-size: 48px; font-weight: bold; color: #ff8800;
                text-shadow: 0 0 20px rgba(255, 136, 0, 0.8), 0 2px 4px rgba(0,0,0,0.5);
                font-family: Georgia, serif; transition: transform 0.1s, color 0.2s;">0</div>
            <div style="font-size: 12px; color: #ff8800; letter-spacing: 2px; text-shadow: 0 0 10px rgba(255,136,0,0.5);">COMBO</div>
            <div id="combo-multiplier" style="font-size: 14px; color: #ffcc00; margin-top: 4px;">1.0</div>
        </div>

        <!-- v5.13: Ship Status Panel (v5.15: Defense Log Added, v6.70: Enhanced styling) -->
        <div id="ship-status" style="display: none; position: fixed; top: 80px; left: 10px; z-index: 100;
            background: linear-gradient(180deg, rgba(12,18,28,0.95) 0%, rgba(8,14,24,0.98) 100%);
            padding: 14px; border-radius: 12px;
            border: 1px solid rgba(0,255,255,0.2);
            min-width: 200px; max-width: 260px;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 18px; filter: drop-shadow(0 0 4px rgba(0,255,255,0.5));"></span>
                    <span style="color: #22d3ee; font-weight: 700; font-size: 12px; letter-spacing: 1px; text-shadow: 0 0 8px rgba(34,211,238,0.4);">SHIP STATUS</span>
                </div>
                <button onclick="toggleDefenseLog()" style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: #888; cursor: pointer; font-size: 11px; padding: 4px 8px; border-radius: 6px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'" title="Toggle Defense Log"></button>
            </div>
            <div style="margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255,255,255,0.5); margin-bottom: 4px;">
                    <span>Hull Integrity</span>
                    <span id="ship-hp-text" style="color: #4ade80; font-weight: 600;">100/100</span>
                </div>
                <div style="height: 10px; background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%); border-radius: 5px; overflow: hidden; border: 1px solid rgba(74,222,128,0.3); box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);">
                    <div id="ship-hp-fill" style="width: 100%; height: 100%; background: linear-gradient(180deg, #6ee7b7 0%, #4ade80 50%, #22c55e 100%); transition: width 0.3s ease-out; box-shadow: 0 0 8px rgba(74,222,128,0.4);"></div>
                </div>
            </div>
            <div style="display: flex; gap: 6px;">
                <button id="ship-defense-btn" onclick="toggleShipAutoDefend()" style="flex: 1; padding: 7px 10px;
                    background: linear-gradient(180deg, rgba(34,197,94,0.2) 0%, rgba(22,163,74,0.15) 100%);
                    border: 1px solid rgba(74,222,128,0.4); color: #4ade80; border-radius: 8px; cursor: pointer; font-size: 10px; font-weight: 600;
                    transition: all 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"
                    onmouseover="this.style.background='linear-gradient(180deg, rgba(34,197,94,0.3) 0%, rgba(22,163,74,0.25) 100%)'"
                    onmouseout="this.style.background='linear-gradient(180deg, rgba(34,197,94,0.2) 0%, rgba(22,163,74,0.15) 100%)'"> Defense: ON</button>
                <button onclick="repairShip()" style="padding: 7px 10px;
                    background: linear-gradient(180deg, rgba(251,191,36,0.2) 0%, rgba(245,158,11,0.15) 100%);
                    border: 1px solid rgba(251,191,36,0.4); color: #fbbf24; border-radius: 8px; cursor: pointer; font-size: 10px; font-weight: 600;
                    transition: all 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"
                    onmouseover="this.style.background='linear-gradient(180deg, rgba(251,191,36,0.3) 0%, rgba(245,158,11,0.25) 100%)'"
                    onmouseout="this.style.background='linear-gradient(180deg, rgba(251,191,36,0.2) 0%, rgba(245,158,11,0.15) 100%)'"> Repair</button>
            </div>
            <div style="margin-top: 8px; font-size: 9px; color: rgba(255,255,255,0.35); text-align: center; letter-spacing: 0.5px;">
                Laser Range: 35m | DMG: 15
            </div>
            <!-- v5.15: Defense Statistics (collapsible) -->
            <div id="defense-stats" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,255,255,0.2);">
                <div style="font-size: 11px; color: #0ff; margin-bottom: 6px;"> Defense Statistics</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 10px;">
                    <div style="color: #888;">Engagements:</div><div id="stat-engagements" style="color: #fff; text-align: right;">0</div>
                    <div style="color: #888;">Defeats:</div><div id="stat-kills" style="color: #ff4444; text-align: right;">0</div>
                    <div style="color: #888;">Damage Dealt:</div><div id="stat-damage-dealt" style="color: #ffaa00; text-align: right;">0</div>
                    <div style="color: #888;">Deterred:</div><div id="stat-deterred" style="color: #88ff88; text-align: right;">0</div>
                    <div style="color: #888;">Times Attacked:</div><div id="stat-attacked" style="color: #ff8888; text-align: right;">0</div>
                    <div style="color: #888;">Damage Taken:</div><div id="stat-damage-taken" style="color: #ff6666; text-align: right;">0</div>
                    <div style="color: #888;">Defeat Rate:</div><div id="stat-kill-rate" style="color: #88ffff; text-align: right;">0%</div>
                    <div style="color: #888;">Repairs:</div><div id="stat-repairs" style="color: #ffff88; text-align: right;">0</div>
                </div>
                <!-- v5.15: Recent Events Log -->
                <div style="margin-top: 8px;">
                    <div style="font-size: 11px; color: #0ff; margin-bottom: 4px;"> Recent Events</div>
                    <div id="defense-events-log" style="max-height: 120px; overflow-y: auto; font-size: 9px; background: rgba(0,0,0,0.3); border-radius: 4px; padding: 4px;">
                        <div style="color: #666; text-align: center; padding: 10px;">No events yet</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <!-- Minimap with Show Mode button -->
        <div id="minimap-container" class="minimap" style="cursor: pointer;">
            <canvas id="minimap-canvas" class="minimap-canvas"></canvas>
            <!-- v5.19: Show Mode button overlay -->
            <div style="position: absolute; top: 4px; right: 4px; z-index: 10;">
                <button onclick="openShowModeModal()" style="background: rgba(0,255,255,0.2); border: 1px solid #0ff; color: #0ff; padding: 3px 6px; border-radius: 4px; font-size: 8px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(0,255,255,0.4)'" onmouseout="this.style.background='rgba(0,255,255,0.2)'"></button>
            </div>
            <!-- P2P Status -->
            <div style="position: absolute; bottom: 2px; left: 0; right: 0; text-align: center; display: flex; justify-content: center; gap: 6px; align-items: center;">
                <span id="p2p-status" style="font-size: 9px; color: #888; text-shadow: 0 0 3px #000;"> PRIVATE</span>
                <span id="spectator-count" style="font-size: 9px; color: #00ff88; text-shadow: 0 0 3px #000;"></span>
            </div>
        </div>

        <!-- v6.50: Ant Farm 3D Ecosystem View -->
        <div id="ant-farm-overlay" class="ant-farm-overlay">
            <div class="ant-farm-header">
                <div class="ant-farm-title"> 3D Ant Farm</div>
                <div class="ant-farm-controls">
                    <span><kbd>Drag</kbd> Orbit</span>
                    <span><kbd>Q</kbd><kbd>E</kbd> Rotate</span>
                    <span><kbd>R</kbd><kbd>F</kbd> Tilt</span>
                    <span><kbd>Scroll</kbd> Zoom</span>
                    <span><kbd>A</kbd> Auto</span>
                    <span><kbd>T</kbd> Top</span>
                    <span><kbd>1-4</kbd> Views</span>
                    <span><kbd>N</kbd> Close</span>
                </div>
            </div>
            <div id="ant-farm-stats" class="ant-farm-stats">
                <div>Mobs: <span id="af-mob-count">0</span></div>
                <div>Trees: <span id="af-tree-count">0</span></div>
                <div>Rocks: <span id="af-rock-count">0</span></div>
                <div>Agents: <span id="af-agent-count">0</span></div>
                <div>Fish Spots: <span id="af-fish-count">0</span></div>
            </div>
            <div id="ant-farm-zoom" class="ant-farm-zoom-info">Zoom: 43%</div>
        </div>

        <!-- v6.86: Galaxy Discovery Modal - When all planets are exhausted -->
        <!-- v6.95: Enhanced with "Burning into Existence" concept -->
        <div id="galaxy-discovery-modal" class="galaxy-discovery-modal">
            <div class="galaxy-warp-effect"></div>
            <div class="galaxy-discovery-content">
                <div class="galaxy-discovery-title"> IGNITE NEW UNIVERSE</div>
                <div class="galaxy-discovery-subtitle">You will be the FIRST OBSERVER to burn this reality into existence</div>

                <div class="galaxy-stats-preview">
                    <div class="galaxy-stat-item">
                        <div class="galaxy-stat-value">60</div>
                        <div class="galaxy-stat-label">Planets Awaiting Birth</div>
                    </div>
                    <div class="galaxy-stat-item">
                        <div class="galaxy-stat-value" id="galaxy-number-display">2</div>
                        <div class="galaxy-stat-label">Universe #</div>
                    </div>
                    <div class="galaxy-stat-item">
                        <div class="galaxy-stat-value"></div>
                        <div class="galaxy-stat-label">Possibilities</div>
                    </div>
                </div>

                <!-- v6.95: Show player identity as the first observer -->
                <div id="ignition-identity" style="margin: 15px 0; padding: 12px; background: linear-gradient(135deg, rgba(255,100,0,0.2), rgba(255,50,0,0.1)); border: 1px solid rgba(255,150,0,0.4); border-radius: 10px;">
                    <div style="font-size: 11px; color: #ff9944; text-transform: uppercase; letter-spacing: 2px;">First Observer</div>
                    <div id="ignition-player-name" style="font-size: 18px; color: #ffcc66; font-weight: bold; margin-top: 4px;">Pioneer 0000</div>
                    <div style="font-size: 10px; color: #888; margin-top: 4px;">Your observation will collapse infinite potential into defined reality</div>
                </div>

                <button class="galaxy-discovery-btn" onclick="discoverNewGalaxy()" style="background: linear-gradient(135deg, #ff6600, #ff3300); animation: ignite-pulse 1.5s infinite;">
                     IGNITE UNIVERSE
                </button>

                <div class="galaxy-journey-info">
                    <div>Galaxy <span class="galaxy-number" id="current-galaxy-num">1</span> has been fully explored. A new universe awaits your observation.</div>
                    <div style="margin-top: 8px; font-size: 12px; color: #666;">All skills, inventory, and progress will be preserved across realities.</div>
                </div>

                <button onclick="closeGalaxyDiscoveryModal()" style="margin-top: 15px; background: transparent; border: 1px solid #666; color: #888; padding: 8px 20px; border-radius: 15px; cursor: pointer; font-size: 12px;">
                    Stay in Current Reality
                </button>
            </div>
        </div>

        <!-- v6.86: Galaxy Manager Modal - Multiverse Navigation System -->
        <div id="galaxy-manager-modal" class="galaxy-manager-modal">
            <button class="galaxy-manager-close" onclick="closeGalaxyManager()">&times;</button>
            <div class="galaxy-manager-container">
                <div class="galaxy-manager-header">
                    <div class="galaxy-manager-title"> GALAXY MANAGER</div>
                    <div class="galaxy-manager-stats">
                        <div class="gm-stat">
                            <div class="gm-stat-value" id="gm-total-galaxies">1</div>
                            <div class="gm-stat-label">Galaxies</div>
                        </div>
                        <div class="gm-stat">
                            <div class="gm-stat-value" id="gm-total-planets">60</div>
                            <div class="gm-stat-label">Total Planets</div>
                        </div>
                        <div class="gm-stat">
                            <div class="gm-stat-value" id="gm-total-visited">0</div>
                            <div class="gm-stat-label">Visited</div>
                        </div>
                    </div>
                </div>

                <div class="galaxy-manager-controls">
                    <button class="gm-control-btn primary" onclick="openGalaxyDiscoveryModal(); closeGalaxyManager();"> Discover New Galaxy</button>
                    <button class="gm-control-btn" onclick="importGalaxyFromUrl()"> Import Galaxy URL</button>
                    <input type="text" class="gm-search-box" id="galaxy-search" placeholder="Search galaxies..." oninput="filterGalaxies(this.value)">
                </div>

                <div class="galaxy-grid" id="galaxy-grid">
                    <!-- Galaxy cards will be dynamically inserted here -->
                </div>
            </div>
        </div>

        <!-- v6.86: Galaxy QR Code Overlay -->
        <!-- v6.95: Enhanced with ignition info and state -->
        <div id="galaxy-qr-overlay" class="galaxy-qr-overlay">
            <div class="galaxy-qr-content">
                <div class="galaxy-qr-title" id="qr-galaxy-name">Galaxy #1</div>
                <div class="galaxy-qr-subtitle">Scan to drop into this universe</div>

                <!-- v6.95: Ignition and state info -->
                <div id="qr-ignition-info" style="margin: 10px 0; padding: 10px; background: linear-gradient(135deg, rgba(255,100,0,0.15), rgba(255,50,0,0.1)); border: 1px solid rgba(255,150,0,0.3); border-radius: 8px; font-size: 12px;">
                    <div style="color: #ff9944;"> Ignited by: <span id="qr-ignited-by">Unknown</span></div>
                    <div style="color: #888; margin-top: 5px;" id="qr-galaxy-state">60 planets active</div>
                </div>

                <div class="galaxy-qr-code" id="galaxy-qr-container">
                    <!-- QR code will be inserted here -->
                </div>
                <div class="galaxy-qr-url" id="galaxy-qr-url-display"></div>
                <div style="font-size: 11px; color: #666; margin: 8px 0;">Visitors will see exact state: destroyed/escaped planets</div>
                <div class="galaxy-qr-actions">
                    <button class="gm-control-btn" onclick="copyGalaxyUrl()"> Copy URL</button>
                    <button class="gm-control-btn" onclick="closeGalaxyQROverlay()">Close</button>
                </div>
            </div>
        </div>

        <!-- v5.19: Show Mode Modal - Enhanced with Multiplayer Join -->
        <div id="show-mode-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10001; align-items: center; justify-content: center; backdrop-filter: blur(5px); pointer-events: auto;">
            <div style="background: rgba(20,20,40,0.95); border: 2px solid rgba(0,255,255,0.3); border-radius: 20px; padding: 30px; max-width: 400px; width: 90%; text-align: center; position: relative; box-shadow: 0 0 50px rgba(0,255,255,0.3); pointer-events: auto;">
                <button id="close-show-mode-btn" style="position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 30px; cursor: pointer; color: #fff; transition: all 0.3s; pointer-events: auto; z-index: 10002;">&times;</button>
                <h3 style="margin: 0 0 15px 0; font-size: 24px; background: linear-gradient(45deg, #00ffff, #0088ff, #06ffa5); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">Share World</h3>

                <!-- Mode Toggle Tabs -->
                <div id="share-mode-tabs" style="display: flex; gap: 6px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap;">
                    <button id="tab-spectate" onclick="setShareMode('spectate')" style="flex: 1; min-width: 70px; padding: 8px 6px; border: 2px solid rgba(0,255,255,0.5); background: rgba(0,255,255,0.2); color: #0ff; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; font-size: 0.8em;">
                         Spectate
                    </button>
                    <button id="tab-antfarm" onclick="setShareMode('antfarm')" style="flex: 1; min-width: 70px; padding: 8px 6px; border: 2px solid rgba(0,255,136,0.3); background: transparent; color: #0f8; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; font-size: 0.8em;">
                         Ant Farm
                    </button>
                    <button id="tab-multiplayer" onclick="setShareMode('multiplayer')" style="flex: 1; min-width: 70px; padding: 8px 6px; border: 2px solid rgba(255,100,0,0.3); background: transparent; color: #f80; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; font-size: 0.8em;">
                         Co-op
                    </button>
                    <button id="tab-versus" onclick="setShareMode('versus')" style="flex: 1; min-width: 70px; padding: 8px 6px; border: 2px solid rgba(255,0,100,0.3); background: transparent; color: #f08; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.3s; font-size: 0.8em;">
                         Versus
                    </button>
                </div>

                <p id="share-mode-desc" style="color: rgba(255,255,255,0.7); margin-bottom: 15px; font-size: 0.9em;">Others can watch your exploration in real-time</p>
                <div id="show-mode-info" style="background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); border-radius: 10px; padding: 10px; margin: 10px 0; font-size: 0.85em; color: #06ffa5;"> Spectate Mode - Viewers see what you see!</div>
                <div id="qr-code-container" style="margin: 15px auto; display: flex; justify-content: center; align-items: center; padding: 15px; background: white; border-radius: 15px; min-height: 200px; min-width: 200px;">
                    <!-- QR code canvas/img generated dynamically -->
                </div>
                <p id="qr-url" style="font-size: 11px; color: rgba(255,255,255,0.7); word-break: break-all; margin: 15px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 8px; font-family: monospace;"></p>
                <button id="copy-url-btn" style="background: linear-gradient(45deg, #00ffff, #0088ff); color: white; border: none; padding: 12px 24px; border-radius: 25px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; pointer-events: auto;">COPY URL</button>
                <p id="planet-info" style="margin-top: 12px; font-size: 0.8em; color: rgba(255,255,255,0.5); display: none;"></p>
            </div>
        </div>

        <!-- v5.19: Enhanced Spectator Mode Overlay -->
        <div id="spectator-mode" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(0,10,30,0.98) 0%, rgba(0,5,15,0.99) 100%); z-index: 9999; overflow-y: auto;">

            <!-- Animated Background Grid -->
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image:
                linear-gradient(rgba(0,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,255,0.03) 1px, transparent 1px);
                background-size: 50px 50px; pointer-events: none;"></div>

            <!-- Header Bar -->
            <div style="position: sticky; top: 0; background: linear-gradient(180deg, rgba(0,20,40,0.95) 0%, rgba(0,10,20,0.9) 100%);
                border-bottom: 1px solid rgba(0,255,255,0.2); padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; z-index: 10;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="width: 12px; height: 12px; background: #f44; border-radius: 50%; animation: pulse-red 1.5s infinite;"></div>
                    <span style="color: #f44; font-size: 12px; font-weight: bold; letter-spacing: 2px;"> LIVE</span>
                    <span style="color: #0ff; font-size: 14px; font-weight: bold;">SPECTATOR MODE</span>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div style="text-align: right;">
                        <div style="color: #888; font-size: 10px;">WATCHING</div>
                        <div id="spectator-civ" style="color: #fff; font-size: 14px; font-weight: bold;">Unknown</div>
                    </div>
                    <button id="exit-spectator-btn" style="padding: 8px 16px; background: linear-gradient(135deg, #f44, #c00);
                        border: none; color: #fff; font-weight: bold; border-radius: 20px; cursor: pointer; font-size: 12px;
                        transition: all 0.3s; box-shadow: 0 2px 10px rgba(255,68,68,0.3);">EXIT</button>
                </div>
            </div>

            <!-- Main Content Grid -->
            <div style="display: grid; grid-template-columns: 1fr 320px; gap: 20px; padding: 20px; max-width: 1200px; margin: 0 auto;">

                <!-- Left Column: Main View -->
                <div style="display: flex; flex-direction: column; gap: 15px;">

                    <!-- Large Minimap Display -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 20px; position: relative;">
                        <div style="position: absolute; top: 15px; left: 20px; display: flex; align-items: center; gap: 8px;">
                            <span style="color: #0ff; font-size: 12px; font-weight: bold;"> LIVE MAP</span>
                            <span id="spectator-biome" style="background: rgba(0,255,255,0.2); color: #0ff; padding: 2px 8px; border-radius: 10px; font-size: 10px;">Terra</span>
                        </div>
                        <div style="display: flex; justify-content: center; padding-top: 30px;">
                            <div style="position: relative;">
                                <img id="spectator-minimap" style="width: 280px; height: 280px; border: 2px solid rgba(0,255,255,0.3);
                                    border-radius: 10px; box-shadow: 0 0 30px rgba(0,255,255,0.2);"
                                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Minimap">
                                <!-- Coordinate Overlay -->
                                <div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
                                    background: rgba(0,0,0,0.8); padding: 5px 15px; border-radius: 15px; border: 1px solid #0ff;">
                                    <span id="spectator-coords" style="font-size: 14px; color: #0ff; font-family: monospace; font-weight: bold;">X: 0 Z: 0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Activity Feed -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px; flex: 1;">
                        <div style="color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 10px;"> ACTIVITY FEED</div>
                        <div id="spectator-activity" style="font-size: 11px; color: #aaa; max-height: 150px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px;">
                            <div style="color: #666; font-style: italic;">Waiting for activity...</div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Stats Panel -->
                <div style="display: flex; flex-direction: column; gap: 15px;">

                    <!-- Connection Status -->
                    <div style="background: linear-gradient(135deg, rgba(0,40,60,0.8), rgba(0,20,40,0.8)); border: 1px solid rgba(0,255,255,0.3);
                        border-radius: 15px; padding: 15px; text-align: center;">
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <div id="connection-indicator" style="width: 10px; height: 10px; background: #4f4; border-radius: 50%;
                                box-shadow: 0 0 10px #4f4; animation: pulse-green 2s infinite;"></div>
                            <span style="color: #4f4; font-size: 12px; font-weight: bold;">CONNECTED</span>
                        </div>
                        <div style="color: #666; font-size: 10px;">Stream latency: <span id="spectator-latency" style="color: #0ff;">--</span>ms</div>
                        <div style="color: #666; font-size: 10px; margin-top: 2px;">Version: <span id="spectator-version" style="color: #888;">-</span></div>
                    </div>

                    <!-- Probe Status -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px;">
                        <div style="color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 12px;"> PROBE STATUS</div>

                        <!-- HP -->
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: #888; font-size: 10px;">INTEGRITY</span>
                                <span id="spectator-hp-text" style="color: #fff; font-size: 12px; font-weight: bold;">100/100</span>
                            </div>
                            <div style="background: rgba(0,0,0,0.5); border-radius: 6px; overflow: hidden; height: 8px;">
                                <div id="spectator-hp-fill" style="width: 100%; height: 100%; background: linear-gradient(90deg, #f44, #ff8800, #4f4);
                                    transition: width 0.3s ease; box-shadow: 0 0 10px rgba(0,255,0,0.3);"></div>
                            </div>
                        </div>

                        <!-- Energy -->
                        <div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: #888; font-size: 10px;"> ENERGY</span>
                                <span id="spectator-energy-text" style="color: #0af; font-size: 12px; font-weight: bold;">100/100</span>
                            </div>
                            <div style="background: rgba(0,0,0,0.5); border-radius: 6px; overflow: hidden; height: 8px;">
                                <div id="spectator-energy-fill" style="width: 100%; height: 100%; background: linear-gradient(90deg, #0066cc, #00aaff);
                                    transition: width 0.3s ease; box-shadow: 0 0 10px rgba(0,170,255,0.3);"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Agent Fleet -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px; flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #0ff; font-size: 12px; font-weight: bold;"> AGENT FLEET</span>
                            <span id="spectator-agent-count" style="background: rgba(0,255,255,0.2); color: #0ff; padding: 2px 8px; border-radius: 10px; font-size: 10px;">0</span>
                        </div>
                        <div id="spectator-agents" style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto;">
                            <div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 20px 0;">No agents deployed</div>
                        </div>
                    </div>

                    <!-- Structures -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #0ff; font-size: 12px; font-weight: bold;"> STRUCTURES</span>
                            <span id="spectator-structures" style="color: #fff; font-size: 14px; font-weight: bold;">0</span>
                        </div>
                        <div id="spectator-structure-types" style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                            <!-- Structure type badges will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pulse animation keyframes in style -->
            <style>
                @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
                @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 10px #4f4; } 50% { box-shadow: 0 0 20px #4f4; } }
                @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 30px rgba(0,170,255,0.5); transform: scale(1); } 50% { box-shadow: 0 0 50px rgba(0,170,255,0.8), 0 0 80px rgba(0,170,255,0.4); transform: scale(1.02); } }
                #spectator-agents::-webkit-scrollbar { width: 4px; }
                #spectator-agents::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 2px; }
                #spectator-agents::-webkit-scrollbar-thumb { background: #0ff; border-radius: 2px; }
                #spectator-activity::-webkit-scrollbar { width: 4px; }
                #spectator-activity::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 2px; }
                #spectator-activity::-webkit-scrollbar-thumb { background: #0ff; border-radius: 2px; }
                .spectator-agent-card { background: rgba(0,40,60,0.5); border: 1px solid rgba(0,255,255,0.2); border-radius: 8px; padding: 8px 10px; display: flex; align-items: center; gap: 10px; transition: all 0.2s; }
                .spectator-agent-card:hover { background: rgba(0,60,80,0.5); border-color: rgba(0,255,255,0.4); }
                .activity-item { background: rgba(0,0,0,0.3); border-left: 2px solid #0ff; padding: 6px 10px; border-radius: 0 4px 4px 0; }
                .activity-item.warning { border-left-color: #fa0; }
                .activity-item.danger { border-left-color: #f44; }
                .activity-item.success { border-left-color: #4f4; }
                /* Mobile responsive */
                @media (max-width: 900px) {
                    #spectator-mode > div:nth-child(3) { grid-template-columns: 1fr !important; }
                    #spectator-minimap { width: 200px !important; height: 200px !important; }
                }
            </style>
        </div>

        <!-- v6.74: Environment Widget - Positioned above minimap -->
        <!-- v6.81: Adjusted positioning for cleaner vertical stacking -->
        <div id="environment-widget" style="position: fixed; bottom: 230px; right: 10px; display: none; z-index: 100;
            background: linear-gradient(180deg, rgba(12,16,24,0.95) 0%, rgba(6,10,18,0.98) 100%);
            padding: 12px 14px; border-radius: 14px;
            border: 1px solid rgba(0,255,255,0.35);
            box-shadow: 0 4px 20px rgba(0,0,0,0.55), 0 0 10px rgba(0,255,255,0.12), inset 0 1px 0 rgba(255,255,255,0.05);
            width: 175px; backdrop-filter: blur(10px);">

            <!-- Time Section -->
            <div id="time-indicator" style="display: flex; align-items: center; gap: 10px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.08);">
                <div id="time-icon" style="font-size: 26px; filter: drop-shadow(0 0 6px rgba(255,200,100,0.5)); line-height: 1;"></div>
                <div style="flex: 1; min-width: 0;">
                    <div style="display: flex; align-items: baseline; gap: 8px;">
                        <span id="time-name" style="color: #fbbf24; font-size: 13px; font-weight: 700; text-shadow: 0 0 8px rgba(251,191,36,0.5);">Day</span>
                        <span id="time-clock" style="color: rgba(255,255,255,0.7); font-size: 12px; font-family: 'SF Mono', Monaco, monospace; font-weight: 500;">12:00</span>
                    </div>
                    <div id="time-effect" style="color: rgba(255,255,255,0.5); font-size: 10px; margin-top: 2px; letter-spacing: 0.3px;"></div>
                </div>
            </div>

            <!-- Weather Section -->
            <div id="weather-indicator" style="display: flex; align-items: center; gap: 10px; padding-top: 10px;">
                <div id="weather-icon" style="font-size: 22px; filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); line-height: 1;"></div>
                <div style="flex: 1; min-width: 0;">
                    <div id="weather-name" style="color: rgba(255,255,255,0.85); font-size: 13px; font-weight: 600; letter-spacing: 0.3px;">Clear</div>
                    <div id="weather-effect" style="color: rgba(255,255,255,0.45); font-size: 10px; margin-top: 3px;"></div>
                </div>
            </div>
        </div>

        <!-- v6.13: Wave system is implicit - no UI display, discoverable through exploration -->

        <!-- v6.70: Enhanced Dota 2 Style HP/Mana Bar - Unified HUD -->
        <div id="player-dota-bars-ui" style="position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%); display: none; z-index: 100;">
            <div style="display: flex; flex-direction: column; align-items: center; gap: 3px;
                background: linear-gradient(180deg, rgba(15,20,30,0.95) 0%, rgba(8,12,20,0.98) 100%);
                padding: 10px 20px 8px; border-radius: 12px;
                border: 1px solid rgba(0,255,255,0.2);
                box-shadow: 0 4px 20px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
                min-width: 340px; backdrop-filter: blur(8px);">

                <!-- HP Bar - Enhanced -->
                <div style="width: 100%; display: flex; align-items: center; gap: 10px;">
                    <span style="color: #4ade80; font-size: 10px; font-weight: 700; min-width: 22px; text-shadow: 0 0 6px rgba(74,222,128,0.5);">HP</span>
                    <div style="flex: 1; height: 20px; background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%); border-radius: 4px; border: 1px solid rgba(74,222,128,0.4); overflow: hidden; position: relative; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);">
                        <div id="dota-hp-fill" style="height: 100%; width: 100%; background: linear-gradient(180deg, #6ee7b7 0%, #4ade80 30%, #22c55e 70%, #16a34a 100%); transition: width 0.25s ease-out; box-shadow: 0 0 10px rgba(74,222,128,0.3);"></div>
                        <!-- HP Segments -->
                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; pointer-events: none;">
                            <div style="flex: 1; border-right: 1px solid rgba(0,0,0,0.3);"></div>
                            <div style="flex: 1; border-right: 1px solid rgba(0,0,0,0.3);"></div>
                            <div style="flex: 1; border-right: 1px solid rgba(0,0,0,0.3);"></div>
                            <div style="flex: 1; border-right: 1px solid rgba(0,0,0,0.3);"></div>
                            <div style="flex: 1;"></div>
                        </div>
                        <div id="dota-hp-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 11px; font-weight: 700; text-shadow: 1px 1px 2px #000, -1px -1px 2px #000, 0 0 4px #000; letter-spacing: 0.5px;">100 / 100</div>
                    </div>
                </div>

                <!-- Mana/Energy Bar - Enhanced -->
                <div style="width: 100%; display: flex; align-items: center; gap: 10px;">
                    <span style="color: #60a5fa; font-size: 10px; font-weight: 700; min-width: 22px; text-shadow: 0 0 6px rgba(96,165,250,0.5);">MP</span>
                    <div style="flex: 1; height: 14px; background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%); border-radius: 3px; border: 1px solid rgba(96,165,250,0.4); overflow: hidden; position: relative; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);">
                        <div id="dota-mana-fill" style="height: 100%; width: 100%; background: linear-gradient(180deg, #93c5fd 0%, #60a5fa 30%, #3b82f6 70%, #2563eb 100%); transition: width 0.25s ease-out; box-shadow: 0 0 8px rgba(96,165,250,0.3);"></div>
                        <div id="dota-mana-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 10px; font-weight: 600; text-shadow: 1px 1px 2px #000, -1px -1px 2px #000;">100 / 100</div>
                    </div>
                </div>

                <!-- Level Badge + Class - Enhanced -->
                <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
                    <div id="dota-level-badge" style="width: 26px; height: 26px;
                        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
                        border-radius: 50%; display: flex; align-items: center; justify-content: center;
                        font-size: 12px; font-weight: 800; color: #000;
                        border: 2px solid #fcd34d;
                        box-shadow: 0 0 12px rgba(251,191,36,0.5), inset 0 -2px 4px rgba(0,0,0,0.2);">1</div>
                    <span id="dota-player-name" style="color: #22d3ee; font-size: 13px; font-weight: 700; letter-spacing: 1.5px; text-shadow: 0 0 10px rgba(34,211,238,0.5), 0 1px 2px rgba(0,0,0,0.5); text-transform: uppercase;">EXPLORER</span>
                </div>
            </div>
        </div>

        <!-- v4.8: Combat Abilities Bar (v4.9: Extended with Tier 2, v6.70: Enhanced styling) -->
        <div id="ability-bar" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 100;">
            <div style="display: flex; gap: 6px;
                background: linear-gradient(180deg, rgba(20,25,35,0.95) 0%, rgba(10,15,25,0.98) 100%);
                padding: 10px 14px; border-radius: 10px;
                border: 1px solid rgba(0,255,255,0.15);
                box-shadow: 0 4px 24px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.03);
                backdrop-filter: blur(8px);">
                <!-- Tier 1 Abilities -->
                <!-- v6.8: Added cooldown-text spans for numeric display (Agent consensus) -->
                <div id="ability-q" class="ability-slot" onclick="useAbility('powerStrike')" title="Power Strike (Q) - 3x damage">
                    <span class="ability-icon"></span>
                    <span class="ability-key">Q</span>
                    <div class="ability-cooldown" id="cooldown-q"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-q"></span>
                </div>
                <div id="ability-e" class="ability-slot" onclick="useAbility('whirlwind')" title="Whirlwind (E) - AoE damage">
                    <span class="ability-icon"></span>
                    <span class="ability-key">E</span>
                    <div class="ability-cooldown" id="cooldown-e"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-e"></span>
                </div>
                <div id="ability-r" class="ability-slot" onclick="useAbility('warcry')" title="War Cry (R) - +50% damage">
                    <span class="ability-icon"></span>
                    <span class="ability-key">R</span>
                    <div class="ability-cooldown" id="cooldown-r"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-r"></span>
                </div>
                <!-- v4.9: Tier 2 Abilities -->
                <div style="width: 1px; background: #444; margin: 0 4px;"></div>
                <div id="ability-t" class="ability-slot" onclick="useAbility('heal')" title="Battle Heal (T) - Restore 30% HP">
                    <span class="ability-icon"></span>
                    <span class="ability-key">T</span>
                    <div class="ability-cooldown" id="cooldown-t"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-t"></span>
                </div>
                <div id="ability-f" class="ability-slot" onclick="useAbility('dash')" title="Dash (F) - Surge forward, destroying obstacles and knocking back enemies">
                    <span class="ability-icon"></span>
                    <span class="ability-key">F</span>
                    <div class="ability-cooldown" id="cooldown-f"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-f"></span>
                </div>
                <div id="ability-z" class="ability-slot" onclick="useAbility('shieldWall')" title="Shield Wall (Z) - 70% damage reduction">
                    <span class="ability-icon"></span>
                    <span class="ability-key">Z</span>
                    <div class="ability-cooldown" id="cooldown-z"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-z"></span>
                </div>
                <div id="ability-x" class="ability-slot" onclick="useAbility('execute')" title="Execute (X) - 5x damage to low HP">
                    <span class="ability-icon"></span>
                    <span class="ability-key">X</span>
                    <div class="ability-cooldown" id="cooldown-x"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-x"></span>
                </div>
                <div id="ability-c" class="ability-slot" onclick="useAbility('berserk')" title="Berserker Rage (C) - ULTIMATE">
                    <span class="ability-icon"></span>
                    <span class="ability-key">C</span>
                    <div class="ability-cooldown" id="cooldown-c"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-c"></span>
                </div>
                <!-- v6.42: Chrono-Echo -->
                <div style="width: 1px; background: #555; margin: 0 4px;"></div>
                <div id="ability-b" class="ability-slot chrono-echo-slot" onclick="useAbility('chronoEcho')" title="Chrono-Echo (B) - Summon time-echoes">
                    <span class="ability-icon"></span>
                    <span class="ability-key">B</span>
                    <div class="ability-cooldown" id="cooldown-b"></div>
                    <span class="ability-cooldown-text" id="cooldown-text-b"></span>
                </div>
            </div>
        </div>

        <!-- v5.11: RTS-Style Panel System -->
        <div id="rpg-ui" class="rpg-ui">
            <!-- RTS Toggle Buttons - Bottom Left (v6.99: Added navigation buttons) -->
            <!-- v7.0: RTS Panel Toggles with keyboard hint badges -->
            <div class="rts-panel-toggles" id="rts-panel-toggles">
                <div class="rts-toggle-btn" id="toggle-skills" onclick="toggleRTSPanel('skills')" title="Skills (K)" tabindex="0" role="button" aria-label="Skills panel"><span class="kbd-hint">K</span></div>
                <div class="rts-toggle-btn" id="toggle-crafting" onclick="toggleRTSPanel('crafting')" title="Crafting (P)" tabindex="0" role="button" aria-label="Crafting panel"><span class="kbd-hint">P</span></div>
                <div class="rts-toggle-btn" id="toggle-inventory" onclick="toggleRTSPanel('inventory')" title="Backpack (I)" tabindex="0" role="button" aria-label="Inventory panel"><span class="kbd-hint">I</span></div>
                <div class="rts-toggle-btn" id="toggle-equipment" onclick="toggleRTSPanel('equipment')" title="Equipment (G)" tabindex="0" role="button" aria-label="Equipment panel"><span class="kbd-hint">G</span></div>
                <!-- v6.99: Navigation buttons with visual divider -->
                <div class="rts-divider" id="nav-divider" style="display: none;"></div>
                <div class="rts-toggle-btn nav-btn galaxy" id="nav-galaxy" onclick="openGalaxyManager()" title="Galaxy Manager (M)" tabindex="0" role="button" aria-label="Galaxy manager" style="display: none;"><span class="kbd-hint">M</span></div>
                <div class="rts-toggle-btn nav-btn surfaces" id="nav-surfaces" onclick="showPlanetSurfaceManager()" title="Planet Surfaces" tabindex="0" role="button" aria-label="Planet surfaces" style="display: none;"></div>
            </div>

            <!-- Skills Panel - Left Edge Dock -->
            <div id="skills-panel" class="player-stats">
                <div class="panel-title"><span>Skills</span><span class="close-panel" onclick="toggleRTSPanel('skills')"></span></div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Fishing</span> <span id="lvl-fishing">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-fishing" class="xp-bar-fill" style="background:#44f"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Cooking</span> <span id="lvl-cooking">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-cooking" class="xp-bar-fill" style="background:#f80"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Crafting</span> <span id="lvl-crafting">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-crafting" class="xp-bar-fill" style="background:#a0f"></div></div>
                </div>
                <button onclick="showTalentModal()" style="width: 100%; margin-top: 6px; padding: 5px; cursor: pointer;
                    background: linear-gradient(135deg, #664, #442); border: 1px solid #ffd700; border-radius: 3px; color: #ffd700; font-size: 9px;">
                     Talents (<span id="talent-points-btn">0</span>)
                </button>
            </div>

            <!-- Crafting Panel - Left Edge Dock -->
            <!-- v6.7: Shift+Click = Craft Max (Agent consensus - QoL) -->
            <div id="crafting-panel" class="crafting-panel">
                <div class="panel-title"><span>Crafting</span><span class="close-panel" onclick="toggleRTSPanel('crafting')"></span></div>
                <div style="font-size: 8px; color: #666; margin-bottom: 4px; text-align: center;">Shift+Click = Craft All</div>
                <button class="craft-btn" id="craft-pickaxe" onclick="event.shiftKey ? craftMax('pickaxe') : craft('pickaxe')"> Pickaxe</button>
                <button class="craft-btn" id="craft-sword" onclick="event.shiftKey ? craftMax('sword') : craft('sword')"> Sword</button>
                <button class="craft-btn" id="craft-rod" onclick="event.shiftKey ? craftMax('rod') : craft('rod')"> Rod</button>
                <button class="craft-btn" id="craft-cookedFish" onclick="event.shiftKey ? craftMax('cookedFish') : craft('cookedFish')"> Cook Fish</button>
                <button class="craft-btn" id="craft-potion" onclick="event.shiftKey ? craftMax('potion') : craft('potion')"> Potion</button>
                <div style="border-top: 1px solid #333; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #888; font-size: 8px;">Advanced</small>
                </div>
                <button class="craft-btn" id="craft-chitinArmor" onclick="event.shiftKey ? craftMax('chitinArmor') : craft('chitinArmor')">Chitin Armor</button>
                <button class="craft-btn" id="craft-frostBlade" onclick="event.shiftKey ? craftMax('frostBlade') : craft('frostBlade')">Frost Blade</button>
                <button class="craft-btn" id="craft-crystalPickaxe" onclick="event.shiftKey ? craftMax('crystalPickaxe') : craft('crystalPickaxe')">Crystal Pick</button>
                <button class="craft-btn" id="craft-magmaSword" onclick="event.shiftKey ? craftMax('magmaSword') : craft('magmaSword')">Magma Sword</button>
                <button class="craft-btn" id="craft-superPotion" onclick="event.shiftKey ? craftMax('superPotion') : craft('superPotion')">Super Potion</button>
                <button class="craft-btn" id="craft-voidDagger" onclick="event.shiftKey ? craftMax('voidDagger') : craft('voidDagger')">Void Dagger</button>
                <div style="border-top: 1px solid #664400; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #ffd700; font-size: 8px;"> Legendary</small>
                </div>
                <button class="craft-btn" id="craft-guardianArmor" onclick="event.shiftKey ? craftMax('guardianArmor') : craft('guardianArmor')" style="border-color: #664400;">Guardian Armor</button>
                <button class="craft-btn" id="craft-legendaryBlade" onclick="event.shiftKey ? craftMax('legendaryBlade') : craft('legendaryBlade')" style="border-color: #ffd700;">Legendary Blade</button>
                <div style="border-top: 1px solid #448844; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #88ff88; font-size: 8px;"> Equipment</small>
                </div>
                <button class="craft-btn" id="craft-ironArmor" onclick="event.shiftKey ? craftMax('ironArmor') : craft('ironArmor')" style="border-color: #448844;">Iron Armor</button>
                <button class="craft-btn" id="craft-swiftBoots" onclick="event.shiftKey ? craftMax('swiftBoots') : craft('swiftBoots')" style="border-color: #448844;">Swift Boots</button>
                <button class="craft-btn" id="craft-luckyCharm" onclick="event.shiftKey ? craftMax('luckyCharm') : craft('luckyCharm')" style="border-color: #448844;">Lucky Charm</button>
                <button class="craft-btn" id="craft-powerRing" onclick="event.shiftKey ? craftMax('powerRing') : craft('powerRing')" style="border-color: #448844;">Power Ring</button>
                <button class="craft-btn" id="craft-steelArmor" onclick="event.shiftKey ? craftMax('steelArmor') : craft('steelArmor')" style="border-color: #448844;">Steel Armor</button>
                <button class="craft-btn" id="craft-masterRod" onclick="event.shiftKey ? craftMax('masterRod') : craft('masterRod')" style="border-color: #448844;">Master Rod</button>
            </div>

            <!-- Inventory Panel - Bottom Center -->
            <div id="inventory-panel" class="inventory-panel">
                <div class="panel-title"><span> (<span id="inv-count">0</span>/20)</span><span class="close-panel" onclick="toggleRTSPanel('inventory')"></span></div>
                <div class="inv-grid" id="inventory-grid"></div>
                <!-- v6.13: Clear low priority items button -->
                <button onclick="clearLowPriorityItems()" style="width: 100%; margin-top: 6px; padding: 6px; cursor: pointer;
                    background: linear-gradient(135deg, #664422, #442211); border: 1px solid #885533; border-radius: 4px;
                    color: #ffaa66; font-size: 10px; font-weight: bold;">
                     Clear Low Priority Items
                </button>
                <div style="font-size: 8px; color: #666; text-align: center; margin-top: 4px;">
                    Right-click items to drop  Auto-drops lowest priority when full
                </div>
            </div>

            <!-- Equipment Panel - Bottom Right -->
            <div id="equipment-panel" class="equipment-panel">
                <div class="panel-title"><span> Gear</span><span class="close-panel" onclick="toggleRTSPanel('equipment')"></span></div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                    <div id="equip-slot-weapon" class="equip-slot" onclick="unequipItem('weapon')" title="Weapon">
                        <span class="equip-icon"></span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-armor" class="equip-slot" onclick="unequipItem('armor')" title="Armor">
                        <span class="equip-icon"></span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-accessory" class="equip-slot" onclick="unequipItem('accessory')" title="Accessory">
                        <span class="equip-icon"></span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-tool" class="equip-slot" onclick="unequipItem('tool')" title="Tool">
                        <span class="equip-icon"></span>
                        <span class="equip-name">Empty</span>
                    </div>
                </div>
                <div id="equipment-stats" style="font-size: 9px; padding: 4px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                    <div style="color: #f44;"> +0</div>
                    <div style="color: #4af;"> +0</div>
                </div>
                <button onclick="showEnchantModal()" style="width: 100%; margin-top: 4px; padding: 4px; cursor: pointer;
                    background: linear-gradient(135deg, #448, #226); border: 1px solid #66a; border-radius: 3px; color: #adf; font-size: 8px;">
                     Enchant
                </button>
            </div>
        </div>

        <!-- Touch Controls -->
        <div id="touch-controls" class="touch-controls">
            <div class="touch-btn" id="touch-action">A</div>
        </div>

        <!-- v4.3: Virtual Joystick for Mobile -->
        <div id="virtual-joystick" class="virtual-joystick">
            <div id="joystick-knob" class="joystick-knob"></div>
        </div>
        <div id="touch-action-btn" class="touch-action-btn">ACT</div>
        <div id="touch-dodge-btn" class="touch-dodge-btn">DODGE</div>

        <!-- v6.87: Touch Ability Bar - Mobile Combat (8-strategy consensus) -->
        <div id="touch-ability-bar" class="touch-ability-bar">
            <div class="touch-ability-btn" id="touch-ability-q" data-ability="powerStrike">
                <span class="touch-ability-icon"></span>
                <div class="touch-ability-cooldown"></div>
                <span class="touch-ability-cd-text"></span>
            </div>
            <div class="touch-ability-btn" id="touch-ability-e" data-ability="whirlwind">
                <span class="touch-ability-icon"></span>
                <div class="touch-ability-cooldown"></div>
                <span class="touch-ability-cd-text"></span>
            </div>
            <div class="touch-ability-btn" id="touch-ability-t" data-ability="heal">
                <span class="touch-ability-icon"></span>
                <div class="touch-ability-cooldown"></div>
                <span class="touch-ability-cd-text"></span>
            </div>
            <div class="touch-ability-btn" id="touch-ability-z" data-ability="shieldWall">
                <span class="touch-ability-icon"></span>
                <div class="touch-ability-cooldown"></div>
                <span class="touch-ability-cd-text"></span>
            </div>
        </div>

    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 50;
        background: radial-gradient(transparent 30%, rgba(255,0,0,0.6));
        opacity: 0; transition: opacity 0.1s;
    "></div>

    <!-- v6.7: Directional Damage Indicator (Agent consensus - Combat Juice) -->
    <div id="directional-damage" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 51;
        opacity: 0; transition: opacity 0.15s;
    "></div>

    <!-- v6.12: Victory Celebration Flash (renamed from kill-flash for family-friendly) -->
    <div id="victory-flash" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 52;
        background: radial-gradient(ellipse at center, rgba(255,215,0,0.4) 0%, transparent 70%);
        opacity: 0; transition: opacity 0.05s;
    "></div>
    <!-- Backwards compatibility alias -->
    <div id="kill-flash" style="display: none;"></div>

    <!-- v4.9: Berserk Rage Overlay -->
    <div id="berserk-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 40%, rgba(255,68,0,0.25));
        border: 4px solid rgba(255,68,0,0.5);
        box-shadow: inset 0 0 50px rgba(255,68,0,0.3);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- v4.9: Shield Wall Overlay -->
    <div id="shield-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 50%, rgba(68,136,255,0.2));
        border: 4px solid rgba(68,136,255,0.6);
        box-shadow: inset 0 0 40px rgba(68,136,255,0.2);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- v6.68: Versus Match Overlay - Victory/Defeat Screen -->
    <div id="versus-match-overlay" style="
        display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.95); z-index: 10000;
        justify-content: center; align-items: center; flex-direction: column;
    ">
        <div id="versus-match-result" style="
            font-size: 72px; font-weight: bold; text-transform: uppercase;
            text-shadow: 0 0 30px currentColor, 0 0 60px currentColor;
            animation: versusResultPulse 1.5s ease-in-out infinite;
            margin-bottom: 20px;
        ">VICTORY</div>
        <div id="versus-match-subtitle" style="
            font-size: 24px; color: rgba(255,255,255,0.8);
            margin-bottom: 40px;
        ">The enemy throne has fallen!</div>
        <div style="display: flex; gap: 20px;">
            <button onclick="closeVersusMatchOverlay()" style="
                padding: 15px 40px; font-size: 18px; font-weight: bold;
                background: linear-gradient(45deg, #0ff, #08f);
                border: none; border-radius: 30px; color: white;
                cursor: pointer; text-transform: uppercase;
                box-shadow: 0 0 20px rgba(0,255,255,0.5);
            ">Continue Playing</button>
            <button onclick="startNewVersusMatch()" style="
                padding: 15px 40px; font-size: 18px; font-weight: bold;
                background: linear-gradient(45deg, #f08, #f80);
                border: none; border-radius: 30px; color: white;
                cursor: pointer; text-transform: uppercase;
                box-shadow: 0 0 20px rgba(255,0,136,0.5);
            ">Rematch</button>
        </div>
    </div>

    <!-- v6.68: Versus Match Start Countdown -->
    <div id="versus-countdown" style="
        display: none; position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-size: 120px; font-weight: bold; color: #f08;
        text-shadow: 0 0 40px #f08, 0 0 80px #f08;
        z-index: 10001; pointer-events: none;
    "></div>

    <!-- v6.68: Versus Match HUD -->
    <div id="versus-hud" style="
        display: none; position: fixed; top: 10px; left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8); border: 2px solid #f08;
        border-radius: 15px; padding: 10px 30px; z-index: 200;
        display: none; flex-direction: row; align-items: center; gap: 30px;
    ">
        <div style="text-align: center;">
            <div style="color: #0ff; font-size: 12px; text-transform: uppercase;">Your Throne</div>
            <div id="versus-friendly-throne-hp" style="color: #0ff; font-size: 24px; font-weight: bold;">100%</div>
        </div>
        <div style="color: #f08; font-size: 28px; font-weight: bold;"> VS </div>
        <div style="text-align: center;">
            <div style="color: #f44; font-size: 12px; text-transform: uppercase;">Enemy Throne</div>
            <div id="versus-enemy-throne-hp" style="color: #f44; font-size: 24px; font-weight: bold;">100%</div>
        </div>
    </div>

    <style>
        @keyframes versusResultPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>

    <!-- v6.32: Hyperspace Jump Tunnel Effect (8-agent consensus) -->
    <canvas id="hyperspace-tunnel" style="
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 9999;
        opacity: 0; transition: opacity 0.3s;
    "></canvas>

    <!-- Tutorial Overlay -->
    <!-- v6.95: Enhanced with Universe Ignition documentation -->
    <div id="tutorial-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-title">Welcome to LEVIATHAN</div>
            <div style="color: #aaa; line-height: 1.7; margin-bottom: 20px; font-size: 13px;">

                <p style="margin-bottom: 12px;"><strong style="color: #0ff;"> Galaxy Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Click on star systems to explore planets</li>
                    <li>Visited planets show a green ring</li>
                    <li>Watch orbital mechanics - planets orbit the central black hole</li>
                    <li>Planets can collide or escape into deep space!</li>
                </ul>

                <p style="margin-bottom: 12px;"><strong style="color: #fb0;"> Planet Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Click</strong> to move or interact with objects</li>
                    <li><strong>WASD</strong> keys for movement</li>
                    <li><strong>E</strong> to eat food and heal</li>
                    <li><strong>1-9</strong> to use inventory items</li>
                </ul>

                <!-- v6.95: Universe Ignition Documentation -->
                <p style="margin-bottom: 12px;"><strong style="color: #ff6600;"> Universe Ignition:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>When all planets are exhausted, discover <strong>new galaxies</strong></li>
                    <li>You become the <strong>First Observer</strong> who "burns" the universe into existence</li>
                    <li>Each galaxy gets a unique <strong>ignition signature</strong> tied to you</li>
                    <li>Your actions (planet destruction, escapes) are permanently recorded</li>
                </ul>

                <p style="margin-bottom: 12px;"><strong style="color: #bf00ff;"> Sharing & Drop-In:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Generate <strong>QR codes</strong> to share your universe with others</li>
                    <li>Visitors "drop in" and see your galaxy's <strong>exact state</strong></li>
                    <li>Destroyed planets stay destroyed, escaped planets stay escaped</li>
                    <li>Use <strong>More  Galaxy Manager</strong> to view all discovered galaxies</li>
                </ul>

                <p style="margin-bottom: 12px;"><strong style="color: #0f0;"> Tips:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Gather logs and ore to craft tools</li>
                    <li>Tools increase resource yield</li>
                    <li>Green slimes are aggressive!</li>
                    <li>Fish for food, cook it to heal more</li>
                    <li>Press <strong>F1</strong> anytime for keyboard shortcuts</li>
                </ul>
            </div>
            <button class="action-btn" onclick="closeTutorial()" style="width: 100%;">START EXPLORING</button>
        </div>
    </div>

    <!-- v6.1: Keyboard Shortcuts Overlay (Press F1) -->
    <div id="shortcuts-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-title" style="display: flex; justify-content: space-between; align-items: center;">
                <span> Keyboard Shortcuts</span>
                <button onclick="toggleShortcutsOverlay()" style="background: none; border: none; color: #888; font-size: 24px; cursor: pointer;">&times;</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                <!-- Movement -->
                <div>
                    <div style="color: #0ff; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #0ff; padding-bottom: 5px;"> Movement</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">W A S D</kbd><span style="color: #aaa;">Move character</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Click</kbd><span style="color: #aaa;">Move to location</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Shift</kbd><span style="color: #aaa;">Run (hold)</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Space</kbd><span style="color: #aaa;">Dodge roll</span>
                    </div>
                </div>
                <!-- Combat -->
                <div>
                    <div style="color: #f44; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #f44; padding-bottom: 5px;"> Combat</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">1-9</kbd><span style="color: #aaa;">Use abilities</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Q</kbd><span style="color: #aaa;">Quick heal</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">E</kbd><span style="color: #aaa;">Eat food</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Tab</kbd><span style="color: #aaa;">Target nearest enemy</span>
                    </div>
                </div>
                <!-- UI Panels -->
                <div>
                    <div style="color: #0f0; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #0f0; padding-bottom: 5px;"> Panels</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">I</kbd><span style="color: #aaa;">Inventory</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">K</kbd><span style="color: #aaa;">Skills</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">C</kbd><span style="color: #aaa;">Crafting</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">U</kbd><span style="color: #aaa;">Equipment</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">J</kbd><span style="color: #aaa;">Quests</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">M</kbd><span style="color: #aaa;">Minimap toggle</span>
                    </div>
                </div>
                <!-- AI & System -->
                <div>
                    <div style="color: #ff88ff; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #ff88ff; padding-bottom: 5px;"> AI & System</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">V</kbd><span style="color: #aaa;">Toggle copilot</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">T</kbd><span style="color: #aaa;">Talk to copilot</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">P</kbd><span style="color: #aaa;">Toggle autopilot</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Esc</kbd><span style="color: #aaa;">Settings/Close</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">F1 / ?</kbd><span style="color: #aaa;">This help menu</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">F3</kbd><span style="color: #aaa;">Performance stats</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">F11</kbd><span style="color: #aaa;">Fullscreen</span>
                    </div>
                </div>
                <!-- v6.32: Galaxy Mode shortcuts -->
                <div>
                    <div style="color: #88f; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #88f; padding-bottom: 5px;"> Galaxy Mode</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">S</kbd><span style="color: #aaa;">Settings panel</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Click</kbd><span style="color: #aaa;">Select planet</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Scroll</kbd><span style="color: #aaa;">Zoom in/out</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Drag</kbd><span style="color: #aaa;">Rotate view</span>
                    </div>
                </div>
                <!-- v6.32: Special Actions -->
                <div>
                    <div style="color: #fa0; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #fa0; padding-bottom: 5px;"> Special Actions</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">R</kbd><span style="color: #aaa;">Use repair kit</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">F</kbd><span style="color: #aaa;">Follow mode (MP)</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">H</kbd><span style="color: #aaa;">Toggle HUD</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">Z/X/C</kbd><span style="color: #aaa;">Abilities</span>
                    </div>
                </div>
                <!-- v6.95: Multiverse & Ignition -->
                <div>
                    <div style="color: #ff6600; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #ff6600; padding-bottom: 5px;"> Multiverse</div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px; font-size: 13px;">
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">M</kbd><span style="color: #aaa;">Galaxy Manager</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;"> btn</kbd><span style="color: #aaa;">Ignite new universe</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;">QR</kbd><span style="color: #aaa;">Share galaxy link</span>
                        <kbd style="background: #333; padding: 2px 8px; border-radius: 3px;"></kbd><span style="color: #aaa;">Copy galaxy URL</span>
                    </div>
                </div>
            </div>
            <!-- v6.95: Universe Ignition Quick Reference -->
            <div style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,50,0,0.05)); border: 1px solid rgba(255,100,0,0.3); border-radius: 8px;">
                <div style="color: #ff9944; font-weight: bold; font-size: 12px; margin-bottom: 8px;"> Universe Ignition System</div>
                <div style="color: #888; font-size: 11px; line-height: 1.6;">
                    When you discover a new galaxy, you become the <strong style="color: #ffcc66;">First Observer</strong> who burns that reality into existence.
                    Your player name and a unique <strong style="color: #ffcc66;">ignition signature</strong> are permanently recorded.
                    Share your universe via QR code - visitors will see your galaxy's exact state (destroyed/escaped planets).
                </div>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333; color: #666; font-size: 11px; text-align: center;">
                Press <kbd style="background: #333; padding: 2px 6px; border-radius: 3px;">F1</kbd> or <kbd style="background: #333; padding: 2px 6px; border-radius: 3px;">?</kbd> anytime to show/hide this menu
            </div>
        </div>
    </div>

    <!-- v6.1: Performance Metrics Display (Toggle with F3) -->
    <div id="perf-metrics" style="display: none; position: fixed; top: 10px; right: 10px; z-index: 9999;
        background: rgba(0, 0, 0, 0.85); padding: 10px 15px; border-radius: 8px; border: 1px solid #0ff;
        font-family: monospace; font-size: 12px; pointer-events: none; min-width: 150px;">
        <div style="color: #0ff; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #333; padding-bottom: 5px;"> Performance</div>
        <div style="display: grid; grid-template-columns: 1fr auto; gap: 3px 10px;">
            <span style="color: #888;">FPS:</span><span id="perf-fps" style="color: #0f0;">60</span>
            <span style="color: #888;">Entities:</span><span id="perf-entities" style="color: #ff0;">0</span>
            <span style="color: #888;">Mobs:</span><span id="perf-mobs" style="color: #f88;">0</span>
            <span style="color: #888;">Draw calls:</span><span id="perf-draws" style="color: #8f8;">0</span>
            <span style="color: #888;">Triangles:</span><span id="perf-tris" style="color: #88f;">0</span>
        </div>
    </div>

    <!-- v6.65: Companion Health Display -->
    <div id="companion-health-container" class="companion-health-container hidden">
        <div class="companion-header">
            <span class="companion-name">ECHO (Gen 1)</span>
            <span class="companion-bond">Bond: 0%</span>
        </div>
        <div class="companion-hp-container">
            <div class="companion-hp-bar"></div>
            <span class="companion-hp-text">100/100</span>
        </div>
        <button class="companion-memorial-btn" onclick="showCompanionMemorial()" title="View fallen companions"></button>
    </div>

    <!-- v5.10: RTS-Style Command Bar (Bottom-Right) -->
    <div class="rts-command-bar">
        <!-- v5.6: Copilot Button -->
        <div id="copilot-button" class="copilot-button" onclick="toggleCopilotChat()" title="AI Companion (V)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
            </svg>
        </div>
        <!-- v5.10: Agent Fleet Button -->
        <div id="fleet-button" class="fleet-button" onclick="toggleAgentFleetPanel()" title="Agent Fleet"></div>
        <!-- v6.56: Genesis Engine Button -->
        <div id="genesis-button" class="genesis-button" onclick="toggleGenesisMode()" title="Civilization Genesis (G)"></div>
    </div>

    <!-- v6.56: CIVILIZATION GENESIS ENGINE UI -->
    <!-- Genesis HUD -->
    <div id="genesis-hud" class="genesis-hud">
        <div>
            <div class="genesis-title">GENESIS ENGINE</div>
            <div class="genesis-subtitle">EMERGENT CIVILIZATION SIMULATOR</div>
        </div>
        <div class="genesis-stats">
            <div class="genesis-stat">
                <div class="genesis-stat-val" id="genesis-population">0</div>
                <div class="genesis-stat-lbl">Population</div>
            </div>
            <div class="genesis-stat">
                <div class="genesis-stat-val" id="genesis-factions">0</div>
                <div class="genesis-stat-lbl">Factions</div>
            </div>
            <div class="genesis-stat">
                <div class="genesis-stat-val" id="genesis-age">0</div>
                <div class="genesis-stat-lbl">Age</div>
            </div>
            <div class="genesis-stat">
                <div class="genesis-stat-val" id="genesis-wars">0</div>
                <div class="genesis-stat-lbl">Wars</div>
            </div>
        </div>
        <button class="genesis-exit-btn" onclick="exitGenesisMode()">EXIT GENESIS</button>
    </div>

    <!-- Genesis Controls Panel -->
    <div id="genesis-controls-panel" class="genesis-controls-panel">
        <div class="genesis-panel-title"> GENESIS CONTROLS</div>
        <div class="genesis-speed-controls">
            <button class="genesis-speed-btn" onclick="setGenesisSpeed(0)" data-speed="0" title="Pause"></button>
            <button class="genesis-speed-btn active" onclick="setGenesisSpeed(1)" data-speed="1" title="1x"></button>
            <button class="genesis-speed-btn" onclick="setGenesisSpeed(2)" data-speed="2" title="2x"></button>
            <button class="genesis-speed-btn" onclick="setGenesisSpeed(5)" data-speed="5" title="5x"></button>
        </div>
        <div style="font-size: 10px; color: #664422; margin-bottom: 8px;">
            Click anywhere to drop a seed particle
        </div>
        <div class="genesis-interventions">
            <div class="genesis-interventions-title">Divine Interventions</div>
            <div class="genesis-intervention-btns">
                <button class="genesis-intervention-btn" onclick="triggerGenesisBless()"> Bless</button>
                <button class="genesis-intervention-btn disaster" onclick="triggerGenesisDisaster()"> Disaster</button>
            </div>
        </div>
    </div>

    <!-- Genesis Placement Cursor -->
    <div id="genesis-cursor" class="genesis-cursor">
        <div class="genesis-cursor-ring"></div>
        <div class="genesis-cursor-label">Click to plant seed</div>
    </div>

    <!-- Genesis Event Log -->
    <div id="genesis-event-log" class="genesis-event-log"></div>

    <!-- Copilot Voice Indicator -->
    <div id="copilot-voice-indicator" class="copilot-voice-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        </svg>
        <span>Speaking...</span>
    </div>

    <!-- v5.9: Real-time STT Transcription Overlay -->
    <div id="stt-transcription-overlay" class="stt-transcription-overlay">
        <div class="stt-header">
            <div class="recording-dot"></div>
            <span id="stt-status">Listening...</span>
        </div>
        <div class="stt-waveform" id="stt-waveform">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div id="stt-transcript-text" class="stt-transcript-text interim">Speak now...</div>
        <div class="stt-actions" id="stt-actions" style="display: none;">
            <button class="stt-cancel" onclick="cancelSTTMessage()">Cancel</button>
            <button class="stt-retry" onclick="retrySTT()"> Retry</button>
            <button class="stt-send" onclick="sendSTTMessage()">Send </button>
        </div>
        <div class="stt-auto-send">
            <label>
                <input type="checkbox" id="stt-auto-send-toggle" onchange="toggleAutoSend(this.checked)">
                <span class="stt-toggle"></span>
                <span class="auto-label">Auto-send messages</span>
            </label>
        </div>
    </div>

    <!-- Copilot 3D Tooltip -->
    <div id="copilot-3d-tooltip" class="copilot-3d-tooltip">Click to chat</div>

    <!-- Copilot Chat Interface -->
    <div id="copilot-chat-interface" class="copilot-chat-interface">
        <div class="copilot-chat-header">
            <div class="copilot-chat-title">Copilot Companion</div>
            <button class="copilot-close-btn" onclick="toggleCopilotChat()"></button>
        </div>
        <div class="copilot-quick-actions">
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('What should I do next?')">What next?</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Give me a tip')">Tips</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Where are the enemies?')">Enemies</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('How do I get stronger?')">Get Stronger</button>
            <button class="copilot-quick-btn copilot-mind-blowing-btn" onclick="openMindBlowingPrompts()">Mind-Blowing</button>
        </div>
        <div id="copilot-chat-messages" class="copilot-chat-messages">
            <div class="copilot-message ai">Hello, Explorer! I'm your Copilot Companion. I'll follow you on your journey and help with advice. What would you like to know?</div>
        </div>
        <div class="copilot-chat-input-container">
            <input type="text" id="copilot-chat-input" class="copilot-chat-input" placeholder="Ask your Copilot... (Press V for voice)" onkeypress="if(event.key==='Enter') sendCopilotMessage()">
            <button id="copilot-voice-btn" class="copilot-voice-btn" onclick="toggleCopilotVoice()" title="Voice input (Spacebar)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                </svg>
            </button>
            <button class="copilot-chat-send" onclick="sendCopilotMessage()">Send</button>
        </div>
        <div class="copilot-hotkey-hint">Press <kbd>V</kbd> to voice chat  <kbd>Space</kbd> while open to speak  <kbd>Esc</kbd> to close</div>
    </div>

    <!-- v6.51: Mind-Blowing Prompts Modal - Consensus of 16 Strategy Agents (2 Rounds) -->
    <!-- v6.52: Expanded to 20 prompts with category filtering -->
    <div id="mind-blowing-modal" class="mind-blowing-modal">
        <div class="mind-blowing-content">
            <div class="mind-blowing-header">
                <h2>Mind-Blowing Prompts</h2>
                <div class="mind-blowing-subtitle">21 consensus prompts from 16 AI strategists</div>
                <button class="mind-blowing-close" onclick="closeMindBlowingPrompts()">&times;</button>
            </div>
            <div class="mind-blowing-filters">
                <button class="filter-btn active" onclick="filterPrompts('all')">All (21)</button>
                <button class="filter-btn" onclick="filterPrompts('narrative')">Narrative</button>
                <button class="filter-btn" onclick="filterPrompts('philosophical')">Philosophy</button>
                <button class="filter-btn" onclick="filterPrompts('transcendence')">Transcendence</button>
                <button class="filter-btn" onclick="filterPrompts('comedy')">Comedy</button>
                <button class="filter-btn" onclick="filterPrompts('scientific')">Science</button>
                <button class="filter-btn" onclick="filterPrompts('horror')">Horror</button>
                <button class="filter-btn" onclick="filterPrompts('competitive')">Competitive</button>
            </div>
            <div class="mind-blowing-body" id="mind-blowing-prompts-container">
                <!-- Prompts rendered dynamically by JavaScript -->
            </div>
            <div class="mind-blowing-footer">
                <div class="mind-blowing-hint">Click any prompt to send it to your Copilot</div>
            </div>
        </div>
    </div>

    <!-- v6.85: MEMENTO MORI - Archivist Greeting Overlay -->
    <div id="archivist-greeting" class="archivist-greeting-overlay">
        <div class="archivist-greeting-content">
            <div class="archivist-header">
                <div class="archivist-icon"></div>
                <h2>THE ARCHIVIST SPEAKS</h2>
                <div class="archivist-subtitle">Memento Mori Protocol Active</div>
            </div>
            <div class="archivist-body">
                <div class="archivist-message" id="archivist-message">
                    Welcome back. I have been... waiting.
                </div>
                <div class="archivist-stats">
                    <div class="archivist-stat">
                        <div class="archivist-stat-value" id="archivist-death-count">0</div>
                        <div class="archivist-stat-label">Total Deaths</div>
                    </div>
                    <div class="archivist-stat">
                        <div class="archivist-stat-value" id="archivist-survival-time">0:00</div>
                        <div class="archivist-stat-label">Last Survival</div>
                    </div>
                    <div class="archivist-stat">
                        <div class="archivist-stat-value" id="archivist-session-deaths">0</div>
                        <div class="archivist-stat-label">This Session</div>
                    </div>
                </div>
                <div class="archivist-observation" id="archivist-observation-container" style="display: none;">
                    <div class="archivist-observation-header">Pattern Detected</div>
                    <div class="archivist-observation-text" id="archivist-observation"></div>
                </div>
                <div class="archivist-killer-info" id="archivist-killer-info" style="display: none;">
                    <strong id="archivist-killer-name">Unknown Entity</strong> has killed you <strong id="archivist-killer-count">0</strong> times. It remembers you.
                </div>
            </div>
            <div class="archivist-footer">
                <button class="archivist-continue-btn" onclick="closeArchivistGreeting()">Continue Into The Void</button>
            </div>
        </div>
    </div>

    <!-- v5.9: Copilot Task Panel -->
    <div id="copilot-task-panel" class="copilot-task-panel">
        <div class="copilot-task-header">
            <div class="copilot-task-title">
                <span class="task-icon" id="task-icon"></span>
                <span id="task-name">Working...</span>
            </div>
            <button class="copilot-task-recall" onclick="recallCopilot()">Recall</button>
        </div>
        <div class="copilot-task-status" id="task-status">Preparing...</div>
        <div class="copilot-task-progress">
            <div class="copilot-task-progress-bar" id="task-progress-bar" style="width: 0%"></div>
        </div>
        <div class="copilot-task-results" id="task-results" style="display: none;"></div>
    </div>

    <!-- v5.10: Agent Fleet Management Panel -->
    <div id="agent-fleet-panel" class="agent-fleet-panel">
        <div class="agent-fleet-header">
            <div class="agent-fleet-title">
                <span class="icon"></span>
                Agent Fleet
                <span class="agent-fleet-count" id="fleet-count">0/10</span>
            </div>
            <div style="display: flex; align-items: center;">
                <button class="fleet-export-btn" onclick="openTranscriptViewer()" title="View/Export Transcripts"> Transcripts</button>
                <button class="agent-fleet-close" onclick="toggleAgentFleetPanel()"></button>
            </div>
        </div>
        <div class="agent-fleet-spawn">
            <!-- v5.14: Profile selector for spawning agents -->
            <div style="display: flex; gap: 8px; margin-bottom: 10px; align-items: center;">
                <span style="font-size: 11px; color: #888;">Endpoint:</span>
                <select id="agent-spawn-profile" class="ai-select" style="flex: 1; padding: 6px 10px; font-size: 11px; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: #fff;">
                    <option value="">Default</option>
                    <!-- Options populated dynamically -->
                </select>
            </div>
            <div class="agent-spawn-grid">
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('gatherer')" title="Gather resources">
                    <span class="icon"></span>
                    <span class="label">Gatherer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('hunter')" title="Hunt enemies">
                    <span class="icon"></span>
                    <span class="label">Hunter</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('scout')" title="Scout area">
                    <span class="icon"></span>
                    <span class="label">Scout</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('protector')" title="Protect player">
                    <span class="icon"></span>
                    <span class="label">Protector</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('healer')" title="Heal support">
                    <span class="icon"></span>
                    <span class="label">Healer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('fisher')" title="Fish for food">
                    <span class="icon"></span>
                    <span class="label">Fisher</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('miner')" title="Mine ore">
                    <span class="icon"></span>
                    <span class="label">Miner</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('explorer')" title="Explore unknown areas">
                    <span class="icon"></span>
                    <span class="label">Explorer</span>
                </button>
                <!-- v6.10: Intelligent Construction Agents -->
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('terraformer')" title="INTELLIGENT: Seeks clear areas, smooths rough terrain for building">
                    <span class="icon"></span>
                    <span class="label">Terraformer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('builder')" title="INTELLIGENT: Seeks construction beacons, builds 100% efficiency structures">
                    <span class="icon"></span>
                    <span class="label">Builder</span>
                </button>
            </div>
        </div>
        <div class="agent-fleet-list" id="agent-fleet-list">
            <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                No agents deployed yet.<br>Click an agent type above to spawn.
            </div>
        </div>
    </div>

    <!-- v5.10: Agent Transcript Viewer Modal -->
    <div id="transcript-modal" class="transcript-modal">
        <div class="transcript-modal-content">
            <div class="transcript-modal-header">
                <div class="transcript-modal-title">
                    <span></span>
                    Agent Transcripts
                </div>
                <div class="transcript-modal-actions">
                    <button class="transcript-action-btn" onclick="copyTranscriptToClipboard()"> Copy</button>
                    <button class="transcript-action-btn primary" onclick="downloadCurrentTranscript()"> Download</button>
                    <button class="transcript-action-btn" onclick="downloadAllTranscripts()"> Export All</button>
                    <button class="transcript-action-btn" onclick="closeTranscriptViewer()"></button>
                </div>
            </div>
            <div class="transcript-tabs" id="transcript-tabs">
                <!-- Tabs populated dynamically -->
            </div>
            <div class="transcript-modal-body">
                <div class="transcript-agent-info" id="transcript-agent-info">
                    <!-- Agent info populated dynamically -->
                </div>
                <div class="transcript-json" id="transcript-json-view">
                    <!-- JSON content -->
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for import -->
    <input type="file" id="transcript-import-input" accept=".json" style="display: none;" onchange="importTranscriptFile(event)">

    <!-- v5.7: AI Companion Settings Modal - Tabbed Interface -->
    <div id="ai-settings-modal" class="ai-settings-modal">
        <div class="ai-settings-content">
            <div class="ai-settings-header">
                <h2>AI Companion Settings</h2>
                <button class="ai-settings-close" onclick="closeAISettingsModal()">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="ai-settings-tabs">
                <button class="ai-settings-tab active" onclick="switchAITab('general')">General</button>
                <button class="ai-settings-tab" onclick="switchAITab('endpoints')">Endpoints</button>
                <button class="ai-settings-tab" onclick="switchAITab('voice')">Voice</button>
                <button class="ai-settings-tab" onclick="switchAITab('3dview')">3D View</button>
                <button class="ai-settings-tab" onclick="switchAITab('import')">Import/Export</button>
            </div>

            <div class="ai-settings-body">
                <!-- General Tab -->
                <div id="ai-tab-general" class="ai-tab-content active">
                    <div class="ai-section">
                        <h3>API Configuration</h3>
                        <div class="ai-form-group">
                            <label>API Key</label>
                            <input type="password" id="ai-api-key" class="ai-input" placeholder="Enter your API key">
                        </div>
                        <div class="ai-form-group">
                            <label>API Endpoint</label>
                            <input type="text" id="ai-api-endpoint" class="ai-input" placeholder="http://localhost:7071/api/businessinsightbot_function">
                        </div>
                        <div id="ai-endpoints-list"></div>
                    </div>
                    <div class="ai-section">
                        <h3>World Settings</h3>
                        <div class="ai-form-group">
                            <label>Companion Name</label>
                            <input type="text" id="ai-companion-name" class="ai-input" value="Copilot" placeholder="AI Companion">
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Personality</label>
                            <select id="ai-companion-personality" class="ai-select">
                                <option value="helpful">Helpful & Friendly</option>
                                <option value="adventurous">Adventurous Explorer</option>
                                <option value="wise">Wise Sage</option>
                                <option value="playful">Playful Companion</option>
                                <option value="epic-narrator">Epic Space Opera Narrator</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- v5.14: Endpoints Tab - Configure API endpoint profiles for agents -->
                <div id="ai-tab-endpoints" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Endpoint Profiles</h3>
                        <p style="color: #888; font-size: 12px; margin-bottom: 15px;">
                            Create different endpoint profiles to assign to your agent fleet. Each agent can use a different AI provider.
                        </p>
                        <div id="endpoint-profiles-list" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;">
                            <!-- Profiles populated dynamically -->
                        </div>
                        <button class="ai-btn ai-btn-save" onclick="showAddProfileForm()" style="width: 100%;">
                            + Add New Endpoint Profile
                        </button>
                    </div>

                    <!-- Add/Edit Profile Form -->
                    <div id="endpoint-profile-form" class="ai-section" style="display: none;">
                        <h3 id="profile-form-title">Add Endpoint Profile</h3>
                        <input type="hidden" id="profile-edit-id">
                        <div class="ai-form-group">
                            <label>Profile Name</label>
                            <input type="text" id="profile-name" class="ai-input" placeholder="e.g., My GPT-4 Endpoint">
                        </div>
                        <div class="ai-form-group">
                            <label>Provider Type</label>
                            <select id="profile-type" class="ai-select" onchange="updateProfileFormFields()">
                                <option value="rappid">RAPPID</option>
                                <option value="openai">OpenAI</option>
                                <option value="anthropic">Anthropic</option>
                                <option value="azure">Azure OpenAI</option>
                                <option value="local">Local LLM (Ollama/LM Studio)</option>
                                <option value="custom">Custom Endpoint</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label>API Endpoint URL</label>
                            <input type="text" id="profile-url" class="ai-input" placeholder="https://api.openai.com/v1/chat/completions">
                        </div>
                        <div class="ai-form-group">
                            <label>API Key</label>
                            <input type="password" id="profile-api-key" class="ai-input" placeholder="sk-...">
                        </div>
                        <div class="ai-form-group" id="profile-model-group">
                            <label>Model</label>
                            <input type="text" id="profile-model" class="ai-input" placeholder="gpt-4o-mini">
                        </div>
                        <div class="ai-form-group" id="profile-header-group" style="display: none;">
                            <label>Custom Header Name</label>
                            <input type="text" id="profile-header-name" class="ai-input" placeholder="Authorization">
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="ai-btn ai-btn-save" onclick="saveEndpointProfile()" style="flex: 1;">Save Profile</button>
                            <button class="ai-btn ai-btn-cancel" onclick="hideProfileForm()" style="flex: 1;">Cancel</button>
                        </div>
                    </div>

                    <div class="ai-section">
                        <h3>Default Agent Endpoint</h3>
                        <p style="color: #888; font-size: 12px; margin-bottom: 10px;">
                            Select which profile to use for new agents by default.
                        </p>
                        <select id="default-agent-profile" class="ai-select" onchange="setDefaultAgentProfile(this.value)">
                            <option value="">Use Global RAPPID Settings</option>
                            <!-- Options populated dynamically -->
                        </select>
                    </div>

                    <div class="ai-section">
                        <h3>Quick Test</h3>
                        <div style="display: flex; gap: 10px;">
                            <select id="test-profile-select" class="ai-select" style="flex: 1;">
                                <option value="">Select a profile to test...</option>
                            </select>
                            <button class="ai-btn ai-btn-cancel" onclick="testEndpointProfile()" style="width: 80px;">Test</button>
                        </div>
                        <div id="profile-test-result" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; font-size: 12px; display: none;"></div>
                    </div>
                </div>

                <!-- Voice Tab -->
                <div id="ai-tab-voice" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Voice Output</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Response</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Auto-speak Responses</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-auto-speak">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Azure TTS API Key</label>
                            <input type="password" id="ai-tts-key" class="ai-input" placeholder="Enter Azure TTS key for premium voices">
                        </div>
                        <div class="ai-form-group">
                            <label>Azure Region</label>
                            <input type="text" id="ai-tts-region" class="ai-input" placeholder="eastus2">
                        </div>
                        <div class="ai-form-group">
                            <label>TTS Voice</label>
                            <select id="ai-tts-voice" class="ai-select">
                                <option value="en-US-JennyNeural">Jenny (Female)</option>
                                <option value="en-US-GuyNeural">Guy (Male)</option>
                                <option value="en-US-AriaNeural">Aria (Female)</option>
                                <option value="en-US-DavisNeural">Davis (Male)</option>
                                <option value="en-US-AmberNeural">Amber (Female)</option>
                                <option value="en-US-AnaNeural">Ana (Female - Child)</option>
                                <option value="en-US-BrandonNeural">Brandon (Male)</option>
                                <option value="en-US-ChristopherNeural">Christopher (Male)</option>
                                <option value="en-US-CoraNeural">Cora (Female)</option>
                                <option value="en-US-ElizabethNeural">Elizabeth (Female)</option>
                            </select>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Voice Input</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Input</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-input-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Continuous Conversation Mode</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-continuous-mode">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Push-to-Talk Key</label>
                            <select id="ai-ptt-key" class="ai-select">
                                <option value="Space">Space</option>
                                <option value="KeyV">V</option>
                                <option value="KeyT">T</option>
                                <option value="KeyC">C</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- 3D View Tab -->
                <div id="ai-tab-3dview" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Companion Appearance</h3>
                        <div class="ai-form-group">
                            <label>Primary Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-primary-color" class="ai-color-preview" value="#8a2be2">
                                <input type="text" id="ai-primary-color-hex" class="ai-input ai-color-input" value="#8a2be2">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Glow Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-glow-color" class="ai-color-preview" value="#06ffa5">
                                <input type="text" id="ai-glow-color-hex" class="ai-input ai-color-input" value="#06ffa5">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Size</label>
                            <select id="ai-companion-size" class="ai-select">
                                <option value="small">Small</option>
                                <option value="medium" selected>Medium</option>
                                <option value="large">Large</option>
                            </select>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Show Particles</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-show-particles" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Glow Effect</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-enable-glow" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Behavior</h3>
                        <div class="ai-form-group">
                            <label>Follow Distance</label>
                            <select id="ai-follow-distance" class="ai-select">
                                <option value="2">Close (2m)</option>
                                <option value="3" selected>Normal (3m)</option>
                                <option value="5">Far (5m)</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label>Float Height</label>
                            <select id="ai-float-height" class="ai-select">
                                <option value="1.5">Low (1.5m)</option>
                                <option value="2.5" selected>Normal (2.5m)</option>
                                <option value="3.5">High (3.5m)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Import/Export Tab -->
                <div id="ai-tab-import" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>RAPPID Settings</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
                            Import your RAPPID configuration file to automatically configure API endpoints and Azure TTS settings.
                        </p>
                        <div id="ai-endpoints-preview"></div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="ai-btn ai-btn-import" onclick="document.getElementById('rappidImportFile').click()" style="flex: 1;">
                                Import RAPPID Config
                            </button>
                            <button class="ai-btn ai-btn-cancel" onclick="exportRappidSettings()" style="flex: 1;">
                                Export Settings
                            </button>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="ai-btn" onclick="showBackupOptionsModal()" style="flex: 1; background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,140,0,0.2)); border: 1px solid #ffd700; color: #ffd700;">
                                 Backup Center
                            </button>
                            <button class="ai-btn" onclick="showRappidDataHub()" style="flex: 1; background: linear-gradient(135deg, rgba(68,136,255,0.2), rgba(136,68,255,0.2)); border: 1px solid #4488ff; color: #4488ff;">
                                 Data Hub
                            </button>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Connection Status</h3>
                        <div id="ai-connection-status" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center;">
                            <span style="color: #888;">No endpoint configured</span>
                        </div>
                        <button class="ai-btn ai-btn-cancel" onclick="testRappidConnection()" style="width: 100%; margin-top: 15px;">
                            Test Connection
                        </button>
                    </div>
                    <div class="ai-section">
                        <h3>Reset</h3>
                        <button class="ai-btn" onclick="clearRappidSettings()" style="width: 100%; background: rgba(255,68,68,0.1); border: 1px solid #f44; color: #f44;">
                            Clear All Settings
                        </button>
                    </div>
                    <div id="ai-status-message" class="ai-status-msg"></div>
                </div>
            </div>

            <div class="ai-settings-footer">
                <button class="ai-btn ai-btn-save" onclick="saveAISettings()">Save Changes</button>
                <button class="ai-btn ai-btn-cancel" onclick="closeAISettingsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Box -->
    <div id="daily-challenge" class="daily-challenge-box" style="display: none;">
        <button id="daily-challenge-toggle" class="daily-toggle-btn" onclick="toggleDailyChallenge()" title="Hide/Show"></button>
        <div class="daily-title">Daily Challenge</div>
        <div id="daily-challenge-content">
            <div id="daily-desc" class="daily-desc">Loading...</div>
            <div class="daily-progress-bar">
                <div id="daily-progress-fill" class="daily-progress-fill" style="width: 0%"></div>
            </div>
            <div id="daily-progress-text" class="daily-progress-text">0/0</div>
            <div id="daily-streak" class="daily-streak">Streak: 0 days</div>
        </div>
    </div>

    <!-- v4.6: Full Settings Panel -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 380px;">
            <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            <div class="modal-title">Settings</div>

            <!-- Audio Section -->
            <div class="settings-section">
                <h4 style="color: #0ff;">Audio</h4>
                <div class="setting-row">
                    <span>Master Volume</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="30" oninput="setMasterVolume(this.value)">
                    <span id="volume-display" style="width: 35px; text-align: right;">30%</span>
                </div>
                <div class="setting-row">
                    <span>Sound Effects</span>
                    <button id="sfx-toggle" class="toggle-btn" onclick="toggleSFX()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Ambient Audio</span>
                    <button id="ambient-toggle" class="toggle-btn" onclick="toggleAmbient()">ON</button>
                </div>
            </div>

            <!-- Graphics Section -->
            <div class="settings-section">
                <h4 style="color: #fb0;">Graphics</h4>
                <div class="setting-row">
                    <span>Particle Quality</span>
                    <select id="particle-quality" onchange="setParticleQuality(this.value)">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span>Shadows</span>
                    <button id="shadow-toggle" class="toggle-btn" onclick="toggleShadows()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Screen Shake</span>
                    <button id="shake-toggle" class="toggle-btn" onclick="toggleScreenShake()">ON</button>
                </div>
            </div>

            <!-- Game Section -->
            <div class="settings-section">
                <h4 style="color: #0f0;">Game</h4>
                <div class="setting-row">
                    <span>Show Hints</span>
                    <button id="hints-toggle" class="toggle-btn" onclick="toggleHints()">ON</button>
                </div>
                <!-- v6.7: Auto-use potions QoL (Agent consensus) -->
                <div class="setting-row">
                    <span>Auto-Use Potions</span>
                    <button id="autopotion-toggle" class="toggle-btn" onclick="toggleAutoPotion()">OFF</button>
                </div>
                <div style="font-size: 9px; color: #666; margin-bottom: 6px;">Use potions when HP drops below 30%</div>
                <button class="action-btn" onclick="showTutorial(); closeSettingsModal();" style="width: 100%; margin-top: 10px;">Show Tutorial</button>
            </div>

            <!-- v6.54: Steam Deck / Controller Section -->
            <div class="settings-section">
                <h4 style="color: #8844ff;"> Controller</h4>
                <div class="setting-row">
                    <span>Deck Mode</span>
                    <button id="deckmode-toggle" class="toggle-btn" onclick="toggleDeckMode()">AUTO</button>
                </div>
                <div style="font-size: 9px; color: #666; margin-bottom: 6px;">Optimizes UI, FPS & controls for Steam Deck</div>
                <div class="setting-row">
                    <span>Auto-Attack</span>
                    <button id="autoattack-toggle" class="toggle-btn" onclick="toggleAutoAttack()">OFF</button>
                </div>
                <div style="font-size: 9px; color: #666; margin-bottom: 6px;">Automatically attack nearby enemies</div>
                <div class="setting-row">
                    <span>Vibration</span>
                    <button id="vibration-toggle" class="toggle-btn" onclick="toggleVibration()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Target FPS</span>
                    <select id="target-fps" onchange="setTargetFPS(this.value)">
                        <option value="60">60 FPS</option>
                        <option value="40">40 FPS (Battery)</option>
                        <option value="30">30 FPS (Max Battery)</option>
                    </select>
                </div>
            </div>

            <!-- v6.55: Analytics Section -->
            <div class="settings-section">
                <h4 style="color: #44aa88;"> Analytics</h4>
                <div style="font-size: 10px; color: #888; margin-bottom: 8px;">
                    Local usage stats (never leaves your device)
                </div>
                <div class="setting-row">
                    <span>Sessions</span>
                    <span id="analytics-sessions" style="color: #0ff;">0</span>
                </div>
                <div class="setting-row">
                    <span>Playtime</span>
                    <span id="analytics-playtime" style="color: #0ff;">0h 0m</span>
                </div>
                <div class="setting-row">
                    <span>Steam Deck</span>
                    <span id="analytics-deck" style="color: #8844ff;">0 sessions</span>
                </div>
                <div class="setting-row">
                    <span>Gamepad</span>
                    <span id="analytics-gamepad" style="color: #88ff44;">0 sessions</span>
                </div>
                <div style="margin-top: 10px; display: flex; gap: 8px;">
                    <button class="action-btn" onclick="exportAnalyticsData()" style="flex: 1; font-size: 10px;">
                         Export
                    </button>
                    <button class="action-btn" onclick="clearAnalyticsData()" style="flex: 1; font-size: 10px; background: #442;">
                         Clear
                    </button>
                </div>
                <div style="font-size: 9px; color: #666; margin-top: 6px; text-align: center;">
                    Export to share anonymous stats with developers
                </div>
            </div>

            <!-- v6.36: Data & Backup Section -->
            <div class="settings-section">
                <h4 style="color: #ffd700;"> Data & Backup</h4>
                <div style="font-size: 10px; color: #888; margin-bottom: 8px;">
                    Export/import your game saves and RAPPID settings
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button class="action-btn" onclick="exportRappidFullBackup()" style="flex: 1; font-size: 10px; background: linear-gradient(135deg, #ffd700, #ff8c00); color: #000;">
                         Full Backup
                    </button>
                    <button class="action-btn" onclick="exportGameSaveOnly()" style="flex: 1; font-size: 10px;">
                         Save Only
                    </button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="action-btn" onclick="showRappidDataHub()" style="flex: 1; font-size: 10px; background: linear-gradient(135deg, rgba(68,136,255,0.3), rgba(136,68,255,0.3)); border: 1px solid #4488ff;">
                         Data Hub
                    </button>
                    <button class="action-btn" onclick="showBackupOptionsModal()" style="flex: 1; font-size: 10px; background: rgba(100,100,100,0.3);">
                         Import
                    </button>
                </div>
            </div>

            <!-- Save Info -->
            <p style="color: #666; font-size: 11px; margin-top: 10px; text-align: center;">
                Last saved: <span id="last-save-time">Never</span>
            </p>
            <!-- v6.43: Version display -->
            <p style="color: #444; font-size: 10px; margin-top: 8px; text-align: center; border-top: 1px solid #222; padding-top: 8px;">
                LEVIATHAN: OMNIVERSE <span id="settings-version">v6.81</span>
            </p>
        </div>
    </div>

    <!-- v4.7: Welcome Back Modal -->
    <div id="welcome-back-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-title" style="color: #ffd700;">Welcome Back!</div>
            <p id="welcome-back-message" style="color: #0ff; font-size: 16px; margin: 15px 0;"></p>
            <p id="welcome-back-time" style="color: #888; font-size: 12px; margin-bottom: 20px;"></p>

            <div id="welcome-back-rewards" style="background: rgba(0,255,255,0.1); border: 1px solid #0ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0ff; margin: 0 0 10px;">Your Rewards:</h4>
                <div id="welcome-back-rewards-list" style="text-align: left;"></div>
            </div>

            <button class="action-btn" onclick="claimWelcomeBackRewards()" style="width: 100%; padding: 12px; font-size: 16px; background: linear-gradient(135deg, #ffd700, #ff8800);">
                Claim Rewards!
            </button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="stats-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeStatsModal()">&times;</button>
            <div class="modal-title">Player Statistics</div>

            <!-- v4.2: Player Rank Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(0,255,255,0.1)); border: 1px solid #ffd700; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <h3 style="color: #ffd700; margin: 0 0 10px; font-size: 16px;">Player Rank</h3>
                <div class="stat-row"><span>Current Rank</span><span id="stat-rank" style="font-weight: bold;">Novice Explorer</span></div>
                <div class="stat-row"><span>Total Points</span><span id="stat-points">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #888;">
                    <span style="color: #aaa;">Special Titles: </span><span id="special-titles">None yet</span>
                </div>
            </div>

            <div class="stats-section">
                <h3 style="color: #0ff; margin: 15px 0 10px; font-size: 14px;">Exploration</h3>
                <div class="stat-row"><span>Planets Visited</span><span id="stat-planets">0 / 60</span></div>
                <div class="stat-row"><span>POIs Discovered</span><span id="stat-pois">0</span></div>
                <div class="stat-row"><span>Total Playtime</span><span id="stat-playtime">0h 0m</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #fb0; margin: 15px 0 10px; font-size: 14px;">Gathering</h3>
                <div class="stat-row"><span>Trees Chopped</span><span id="stat-trees">0</span></div>
                <div class="stat-row"><span>Ore Mined</span><span id="stat-ore">0</span></div>
                <div class="stat-row"><span>Fish Caught</span><span id="stat-fish">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #f44; margin: 15px 0 10px; font-size: 14px;">Combat</h3>
                <div class="stat-row"><span>Enemies Defeated</span><span id="stat-mobs">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #a0f; margin: 15px 0 10px; font-size: 14px;">Crafting</h3>
                <div class="stat-row"><span>Items Crafted</span><span id="stat-crafted">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #ffd700; margin: 15px 0 10px; font-size: 14px;">Achievements</h3>
                <div id="achievements-list" class="achievements-grid"></div>
            </div>

            <!-- v4.4: Leaderboard Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,200,0,0.1)); border: 1px solid #ff8800; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #ff8800; margin: 0 0 10px; font-size: 14px;">Leaderboard</h3>
                <div id="leaderboard-list" style="font-size: 12px;"></div>
            </div>

            <!-- v4.4: Prestige Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(150,0,255,0.1), rgba(0,200,255,0.1)); border: 1px solid #aa44ff; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #aa44ff; margin: 0 0 10px; font-size: 14px;">Prestige System</h3>
                <div class="stat-row"><span>Prestige Level</span><span id="prestige-level" style="color: #aa44ff; font-weight: bold;">0</span></div>
                <div class="stat-row"><span>XP Multiplier</span><span id="prestige-xp">x1.0</span></div>
                <div class="stat-row"><span>Lifetime Points</span><span id="prestige-lifetime">0</span></div>
                <div id="prestige-progress" style="margin-top: 10px; font-size: 11px; color: #888;"></div>
                <button id="prestige-btn" onclick="performPrestige()" style="display: none; margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, #aa44ff, #6644ff); border: none; border-radius: 4px; color: #fff; cursor: pointer; width: 100%;">PRESTIGE NOW</button>
            </div>
        </div>
    </div>

    <!-- v4.9: Collection Codex Modal -->
    <div id="codex-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeCodexModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Collection Codex</div>

            <!-- Codex Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                <button class="codex-tab active" data-tab="creatures" onclick="switchCodexTab('creatures')">Creatures</button>
                <button class="codex-tab" data-tab="items" onclick="switchCodexTab('items')">Items</button>
                <button class="codex-tab" data-tab="biomes" onclick="switchCodexTab('biomes')">Biomes</button>
                <button class="codex-tab" data-tab="abilities" onclick="switchCodexTab('abilities')">Abilities</button>
                <button class="codex-tab" data-tab="pets" onclick="switchCodexTab('pets')" style="background: linear-gradient(135deg, rgba(255,136,0,0.3), rgba(255,68,0,0.3));">Pets</button>
                <button class="codex-tab" data-tab="chronicle" onclick="switchCodexTab('chronicle')" style="background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,140,0,0.3));"> Chronicle</button>
                <button class="codex-tab" data-tab="echoes" onclick="switchCodexTab('echoes')" style="background: linear-gradient(135deg, rgba(0,255,255,0.3), rgba(136,0,255,0.3));"> Echoes</button>
            </div>

            <!-- Creatures Tab -->
            <div id="codex-creatures" class="codex-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-creatures-count">0</span> / <span id="codex-creatures-total">0</span>
                </div>
                <div id="codex-creatures-grid" class="codex-grid"></div>
            </div>

            <!-- Items Tab -->
            <div id="codex-items" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-items-count">0</span> / <span id="codex-items-total">0</span>
                </div>
                <div id="codex-items-grid" class="codex-grid"></div>
            </div>

            <!-- Biomes Tab -->
            <div id="codex-biomes" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Explored: <span id="codex-biomes-count">0</span> / <span id="codex-biomes-total">0</span>
                </div>
                <div id="codex-biomes-grid" class="codex-grid"></div>
            </div>

            <!-- Abilities Tab -->
            <div id="codex-abilities" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Unlocked: <span id="codex-abilities-count">0</span> / <span id="codex-abilities-total">0</span>
                </div>
                <div id="codex-abilities-grid" class="codex-grid"></div>
            </div>

            <!-- v5.0: Pets Tab -->
            <div id="codex-pets" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Collected: <span id="codex-pets-count">0</span> / <span id="codex-pets-total">0</span>
                    <span style="margin-left: 15px;">Active: <span id="active-pet-name" style="color: #ff8c00;">None</span></span>
                </div>
                <div id="codex-pets-grid" class="codex-grid"></div>
            </div>

            <!-- v6.35: Chronicle Tab - AI-Generated Captain's Log -->
            <div id="codex-chronicle" class="codex-content" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                    <div style="color: #aaa; font-size: 12px;">
                        Entries: <span id="chronicle-count" style="color: #ffd700;">0</span>
                        <span style="margin-left: 15px;">Pending Events: <span id="chronicle-pending" style="color: #ff8c00;">0</span></span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="generateChronicleEntry()" style="padding: 6px 12px; background: linear-gradient(135deg, #ffd700, #ff8c00); border: none; border-radius: 4px; color: #000; cursor: pointer; font-weight: bold; font-size: 11px;"> Generate Entry</button>
                        <button onclick="exportChronicle()" style="padding: 6px 12px; background: rgba(100,100,100,0.5); border: 1px solid #666; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;"> Export</button>
                    </div>
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 6px;">
                    <div style="font-size: 11px; color: #aaa; margin-bottom: 5px;">Narrative Style:</div>
                    <select id="chronicle-style" onchange="updateChronicleStyle()" style="width: 100%; padding: 6px; background: rgba(30,30,40,0.9); border: 1px solid #555; border-radius: 4px; color: #fff;">
                        <option value="epic"> Epic Space Opera</option>
                        <option value="documentary"> Documentary</option>
                        <option value="poetic"> Poetic & Mystical</option>
                        <option value="hardboiled"> Hard-Boiled Noir</option>
                    </select>
                </div>
                <div id="chronicle-entries" style="max-height: 350px; overflow-y: auto;">
                    <div style="text-align: center; color: #666; padding: 30px; font-style: italic;">
                        Your saga awaits... Events will be recorded as you explore the cosmos.
                    </div>
                </div>
            </div>

            <!-- v6.38: Echoes Tab - Temporal Messages Across Time -->
            <div id="codex-echoes" class="codex-content" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                    <div style="color: #aaa; font-size: 12px;">
                        Echoes Created: <span id="echoes-count" style="color: #0ff;">0</span>
                        <span style="margin-left: 15px;">Discovered: <span id="echoes-discovered" style="color: #a0f;">0</span></span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="createEchoAtPlayer()" style="padding: 6px 12px; background: linear-gradient(135deg, #0ff, #80f); border: none; border-radius: 4px; color: #000; cursor: pointer; font-weight: bold; font-size: 11px;"> Leave Echo</button>
                        <button onclick="exportEchoes()" style="padding: 6px 12px; background: rgba(100,100,100,0.5); border: 1px solid #666; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;"> Export</button>
                    </div>
                </div>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); border-radius: 6px;">
                    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;"> Echoes are temporal messages you leave in the cosmos. They persist across sessions and appear as ghostly markers others can discover.</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <label style="font-size: 11px; color: #ccc; display: flex; align-items: center; gap: 4px;">
                            <input type="checkbox" id="echo-show-markers" checked onchange="toggleEchoMarkers(this.checked)" style="accent-color: #0ff;">
                            Show 3D Markers
                        </label>
                        <label style="font-size: 11px; color: #ccc; display: flex; align-items: center; gap: 4px;">
                            <input type="checkbox" id="echo-sound-enabled" checked onchange="toggleEchoSounds(this.checked)" style="accent-color: #0ff;">
                            Echo Whispers
                        </label>
                    </div>
                </div>
                <div id="echoes-list" style="max-height: 320px; overflow-y: auto;">
                    <div style="text-align: center; color: #666; padding: 30px; font-style: italic;">
                        No echoes yet... Leave your mark on the cosmos with the "Leave Echo" button.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- v6.68: LIVING ECONOMY - Market Modal -->
    <div id="market-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);">
            <button class="modal-close" onclick="closeMarketUI()">&times;</button>
            <div class="modal-title" style="color: #ffd700; display: flex; justify-content: space-between; align-items: center;">
                <span> Galactic Trade Exchange</span>
                <span id="market-gold" style="font-size: 18px; color: #ffd700;"> 0g</span>
            </div>

            <!-- Market Events Banner -->
            <div id="market-events" style="background: rgba(255,100,0,0.2); border: 1px solid #f80; border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                <div class="no-events" style="color: #888; text-align: center;">No active market events</div>
            </div>

            <!-- Market Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px;">
                <button class="codex-tab active" onclick="showMarketTab('prices')" data-tab="prices"> Prices</button>
                <button class="codex-tab" onclick="showMarketTab('merchants')" data-tab="merchants"> Merchants</button>
                <button class="codex-tab" onclick="showMarketTab('manipulate')" data-tab="manipulate"> Manipulate</button>
            </div>

            <!-- Prices Tab -->
            <div id="market-tab-prices" class="market-tab-content">
                <div style="color: #aaa; font-size: 12px; margin-bottom: 10px;">
                    Live market prices update every 30 seconds. Watch for trends!
                </div>
                <div id="market-prices" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; max-height: 400px; overflow-y: auto;">
                </div>
            </div>

            <!-- Merchants Tab -->
            <div id="market-tab-merchants" class="market-tab-content" style="display: none;">
                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-bottom: 15px;">
                    <button onclick="selectMerchant('grimjaw')" class="merchant-btn" style="padding: 15px; background: #2a2a4a; border: 2px solid #555; border-radius: 10px; cursor: pointer; text-align: center;">
                        <div style="font-size: 32px;"></div>
                        <div style="color: #fff; font-size: 11px;">Grimjaw</div>
                        <div style="color: #888; font-size: 10px;">Resources</div>
                    </button>
                    <button onclick="selectMerchant('crystalia')" class="merchant-btn" style="padding: 15px; background: #2a2a4a; border: 2px solid #555; border-radius: 10px; cursor: pointer; text-align: center;">
                        <div style="font-size: 32px;"></div>
                        <div style="color: #fff; font-size: 11px;">Crystalia</div>
                        <div style="color: #888; font-size: 10px;">Gems</div>
                    </button>
                    <button onclick="selectMerchant('ironhide')" class="merchant-btn" style="padding: 15px; background: #2a2a4a; border: 2px solid #555; border-radius: 10px; cursor: pointer; text-align: center;">
                        <div style="font-size: 32px;"></div>
                        <div style="color: #fff; font-size: 11px;">Ironhide</div>
                        <div style="color: #888; font-size: 10px;">Equipment</div>
                    </button>
                    <button onclick="selectMerchant('shadowmere')" class="merchant-btn" style="padding: 15px; background: #2a2a4a; border: 2px solid #555; border-radius: 10px; cursor: pointer; text-align: center;">
                        <div style="font-size: 32px;"></div>
                        <div style="color: #fff; font-size: 11px;">Shadowmere</div>
                        <div style="color: #888; font-size: 10px;">Rare Items</div>
                    </button>
                    <button onclick="selectMerchant('wanderbot')" class="merchant-btn" style="padding: 15px; background: #2a2a4a; border: 2px solid #555; border-radius: 10px; cursor: pointer; text-align: center;">
                        <div style="font-size: 32px;"></div>
                        <div style="color: #fff; font-size: 11px;">Wanderbot</div>
                        <div style="color: #888; font-size: 10px;">Random</div>
                    </button>
                </div>
                <div id="merchant-trade" style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; min-height: 300px;">
                    <div style="color: #888; text-align: center; padding: 50px;">Select a merchant to begin trading</div>
                </div>
            </div>

            <!-- Manipulate Tab -->
            <div id="market-tab-manipulate" class="market-tab-content" style="display: none;">
                <div style="color: #f44; font-size: 14px; margin-bottom: 15px; padding: 10px; background: rgba(255,0,0,0.1); border-radius: 8px;">
                     WARNING: Market manipulation affects ALL prices and merchant behavior!
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- Flood Market -->
                    <div style="background: rgba(0,100,255,0.1); border: 1px solid #08f; border-radius: 10px; padding: 15px;">
                        <h4 style="color: #08f; margin: 0 0 10px 0;"> Flood Market</h4>
                        <p style="color: #aaa; font-size: 12px; margin-bottom: 10px;">
                            Dump large quantities of an item to crash its price. Great for buying back cheap!
                        </p>
                        <select id="flood-item" style="width: 100%; padding: 8px; background: #1a1a3a; color: #fff; border: 1px solid #444; border-radius: 5px; margin-bottom: 10px;">
                            <option value="">Select item to flood...</option>
                        </select>
                        <input type="number" id="flood-qty" placeholder="Quantity" min="1" max="99" value="20" style="width: 100%; padding: 8px; background: #1a1a3a; color: #fff; border: 1px solid #444; border-radius: 5px; margin-bottom: 10px;">
                        <button onclick="executeFloodMarket()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #0066ff, #0044aa); color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                             FLOOD THE MARKET
                        </button>
                    </div>

                    <!-- Corner Market -->
                    <div style="background: rgba(255,100,0,0.1); border: 1px solid #f80; border-radius: 10px; padding: 15px;">
                        <h4 style="color: #f80; margin: 0 0 10px 0;"> Corner Market</h4>
                        <p style="color: #aaa; font-size: 12px; margin-bottom: 10px;">
                            Buy ALL available stock of an item from merchants to create artificial scarcity!
                        </p>
                        <select id="corner-item" style="width: 100%; padding: 8px; background: #1a1a3a; color: #fff; border: 1px solid #444; border-radius: 5px; margin-bottom: 10px;">
                            <option value="">Select item to corner...</option>
                        </select>
                        <div style="color: #888; font-size: 11px; margin-bottom: 10px;">
                            This will spend gold to buy all available stock!
                        </div>
                        <button onclick="executeCornerMarket()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #ff8800, #cc6600); color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                             CORNER THE MARKET
                        </button>
                    </div>
                </div>

                <!-- Trading Tips -->
                <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px;">
                    <h4 style="color: #ffd700; margin: 0 0 10px 0;"> Trading Tips</h4>
                    <ul style="color: #aaa; font-size: 12px; margin: 0; padding-left: 20px;">
                        <li>Watch for market events - buy low during crashes, sell high during booms!</li>
                        <li>Each merchant has preferred items - they pay MORE for what they specialize in.</li>
                        <li>NPCs trade with each other - prices shift even when you're not trading!</li>
                        <li>Flood the market with ore  prices crash  buy cheap equipment!</li>
                        <li>Corner rare items  prices spike  sell back at huge profit!</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- v5.0: Quest System Modal -->
    <div id="quest-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeQuestModal()">&times;</button>
            <div class="modal-title" style="color: #ff8c00;">Quest Board</div>

            <!-- Quest Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px;">
                <button class="codex-tab active" data-tab="daily" onclick="switchQuestTab('daily')">Daily</button>
                <button class="codex-tab" data-tab="weekly" onclick="switchQuestTab('weekly')">Weekly</button>
                <button class="codex-tab" data-tab="story" onclick="switchQuestTab('story')">Story</button>
            </div>

            <!-- Daily Quests -->
            <div id="quest-daily" class="quest-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="daily-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="daily-quests-list" class="quest-list"></div>
            </div>

            <!-- Weekly Quests -->
            <div id="quest-weekly" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="weekly-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="weekly-quests-list" class="quest-list"></div>
            </div>

            <!-- Story Quests -->
            <div id="quest-story" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Progress through the story to unlock rewards!
                </div>
                <div id="story-quests-list" class="quest-list"></div>
            </div>
        </div>
    </div>

    <!-- v5.1: Enchantment Modal -->
    <div id="enchant-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEnchantModal()">&times;</button>
            <div class="modal-title" style="color: #8af;"> Enchanting Table</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px;">
                Add magical enhancements to your equipped gear!
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Your Gear:</div>
                    <div id="enchant-items"></div>
                </div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Enchantments:</div>
                    <div id="enchant-options"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- v5.2: Talent Tree Modal -->
    <div id="talent-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeTalentModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;"> Talent Trees</div>
            <div id="talent-points-display" style="color: #aaa; font-size: 14px; margin-bottom: 15px; text-align: center;">
                Talent Points: 0/0
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <div style="text-align: center; font-weight: bold; color: #ff4444; margin-bottom: 10px;"> Combat</div>
                    <div id="talent-tree-combat"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44aaff; margin-bottom: 10px;"> Survival</div>
                    <div id="talent-tree-survival"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44ff44; margin-bottom: 10px;"> Fortune</div>
                    <div id="talent-tree-fortune"></div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px; font-size: 11px; color: #666;">
                Earn 1 talent point per 5 combined skill levels
            </div>
        </div>
    </div>

    <!-- v5.3: Mastery System Modal -->
    <div id="mastery-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeMasteryModal()">&times;</button>
            <div class="modal-title" style="color: #ff44ff;">Skill Mastery</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Reach skill milestones to unlock permanent bonuses!
            </div>
            <div id="mastery-list"></div>
        </div>
    </div>

    <!-- v5.3: Realm Portal Modal -->
    <div id="portal-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closePortalModal()">&times;</button>
            <div class="modal-title" style="color: #8844ff;">Realm Portals</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Enter challenging realms for exclusive rewards!
            </div>
            <div id="portal-status" style="text-align: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <span style="color: #888;">Current Realm:</span>
                <span id="current-realm" style="color: #ff8844; font-weight: bold; margin-left: 8px;">None</span>
            </div>
            <div id="portal-list"></div>
        </div>
    </div>

    <!-- v5.4: Companion Evolution Modal -->
    <div id="evolution-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEvolutionModal()">&times;</button>
            <div class="modal-title" style="color: #aa44ff;">Companion Evolution</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Bond with your companions to unlock powerful evolutions!
            </div>
            <div id="evolution-list"></div>
        </div>
    </div>

    <!-- v5.4: Achievement Showcase Modal -->
    <div id="showcase-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeShowcaseModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Achievement Showcase</div>
            <div class="achievement-points-display">
                <div class="ap-value" id="total-ap">0</div>
                <div class="ap-label">Achievement Points</div>
                <div class="ap-milestone">
                    <div style="display: flex; justify-content: space-between; font-size: 11px;">
                        <span style="color: #aaa;">Next Milestone:</span>
                        <span id="next-milestone-name" style="color: #ffd700;">---</span>
                    </div>
                    <div class="ap-milestone-progress">
                        <div class="ap-milestone-fill" id="milestone-progress" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 10px; font-size: 12px; color: #888;">
                Active Cosmetic: <span id="active-cosmetic" style="color: #aa44ff;">None</span>
            </div>
            <div id="showcase-badges" class="showcase-grid"></div>
        </div>
    </div>

    <!-- v5.4: World Event Indicator -->
    <div id="event-indicator" class="event-indicator">
        <div class="event-indicator-icon" id="event-ind-icon"></div>
        <div class="event-indicator-name" id="event-ind-name">No Event</div>
        <div class="event-indicator-time" id="event-ind-time">--:--</div>
        <div class="event-indicator-progress">
            <div class="event-indicator-fill" id="event-ind-fill" style="width: 100%;"></div>
        </div>
    </div>

    <!-- v5.5: 3D Ship Landing Mini-Game Overlay -->
    <div id="landing-overlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000;">
        <div id="landing-scene-container" style="width: 100%; height: 100%;"></div>

        <!-- Landing HUD -->
        <div id="landing-info" style="position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <div style="font-size: 18px; font-weight: bold; color: #00ff88; margin-bottom: 10px;" id="landing-planet-name">Landing Sequence</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Altitude:</span> <span id="landing-altitude">0</span>m</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Speed:</span> <span id="landing-speed">0</span>m/s</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Fuel:</span> <span id="landing-fuel">100</span>%</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Mode:</span> <span id="landing-mode">Autonomous</span></div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Distance:</span> <span id="landing-distance">0</span>m</div>
        </div>

        <!-- Landing Controls -->
        <div id="landing-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 10px; color: white; display: flex; gap: 20px; align-items: center; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <button onclick="toggleLandingMode()" id="landing-mode-btn" style="background: #00ff88; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #000;">Switch to Manual</button>
            <button onclick="abortLanding()" style="background: #ff4444; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #fff;">Abort Landing</button>
            <div style="color: #888; font-size: 12px;">Manual: Arrow Keys + Space/Shift</div>
        </div>
    </div>

    <!-- v6.98: CINEMATIC MODE - RDR2-style theatrical view elements -->
    <div class="cinematic-letterbox cinematic-letterbox-top"></div>
    <div class="cinematic-letterbox cinematic-letterbox-bottom"></div>
    <div class="cinematic-vignette"></div>
    <div class="cinematic-grain"></div>
    <div class="cinematic-hint">Cinematic Mode</div>
    <button class="cinematic-toggle-btn" onclick="toggleCinematicMode()" title="Toggle Cinematic Mode (C)"></button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- v5.18: PeerJS for P2P spectator streaming -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // === LEVIATHAN: OMNIVERSE v4.9 ===
        // Enhanced with local-first principles: localStorage persistence & JSON import/export
        // v4.0: Performance optimizations, audio system, particle effects, improved UX
        // v4.1: Achievement system, daily challenges, statistics panel, visual enhancements
        // v4.2: Enemy variety, skill bonuses, POI system, player ranks, combat improvements
        // v4.3: Boss encounters, mobile touch controls, ambient audio, notification queue
        // v4.4: Hit-stop combat, environmental particles, local leaderboard, prestige system, fog of war
        // v4.5: Attack telegraphing, player dodge, recipe discovery, settings panel, boss spawn gates
        // v4.6: Settings persistence, elemental status effects, parry/counter system
        // v4.7: Elite enemy system with affixes, elite gear crafting, session rewards, adaptive performance
        // v4.8: Combo attack system, combat abilities (Q/E/R), ability cooldown UI, item tooltips
        // v4.9: Tier 2 combat abilities (T/F/Z/X/C), visual buff overlays, Collection Codex system
        // v5.0: Quest System (daily/weekly/story), Pet Companions, Weather System
        // v5.1: Equipment System (4 slots), enhanced crafting, enchantment system with 8 enchants
        // v5.2: Talent Tree System (3 trees: Combat/Survival/Fortune, 15 talents)
        // v5.3: Mastery System (skill milestones), Realm Portals (endgame dungeons), Loot Rarity System (item modifiers)
        // v5.4: Companion Evolution System (pets evolve at bond levels), World Events (random spawning events), Achievement Showcase (badges & points)
        // v5.5: Ship Landing Mini-Game (physics-based landing sequence with biome-specific terrain when visiting planets)
        // v5.6: Copilot Companion System (3D AI companion that follows player and provides contextual help)
        // v5.7: RAPPID Integration (AI endpoints, Azure TTS, settings import/export)
        // v5.8: Fixed keyboard input capture when typing in chat, improved API request format
        // v5.9: Updated Azure TTS to use Microsoft Speech SDK for proper voice output
        //       Added Azure STT for microphone input, uses voice_response for TTS
        //       Real-time transcription overlay with auto-send option
        //       Markdown rendering for chat messages with clickable links
        //       Voice hotkeys: V to open chat+voice, Space to speak while chat open, Esc to close
        // v5.10: Multi-Agent Fleet System (spawn up to 10 AI-driven autonomous agents)
        //        Transcript export system for debugging agent conversations
        //        Star Wars-style 3D text crawl for voice responses
        // v5.13: Visible Ship on World Map with Defensive Laser System
        //        Ship HP and damage mechanics - protect your landing zone!
        // v5.14: Endpoint Profiles System for Agent Fleet
        //        Configure multiple API endpoints in RAPPID settings
        //        Assign different endpoint profiles to different agents
        // v5.15: Full Robot Animation System
        //        Hierarchical bone structure for proper joint animations
        //        Idle: breathing, blinking, curious head tilts, antenna sway
        //        Walking/Running: arm swing, leg movement, body bob, forward lean
        //        Action animations: attack, damage, jump/dodge, wave, celebrate
        //        Dynamic eyebrow expressions based on state
        //        Fixed: Agent endpoint key detection and fallback to global RAPPID
        //        Fixed: Better error messages when API key missing or auth fails
        //
        // v5.15.1: Ship Defense Tracking + Real-Time Agent Transcript Viewer
        //        Defense log system tracking engagements, kills, damage dealt
        //        Track incoming attacks, damage taken, entities deterred
        //        Toggleable defense statistics panel in ship status UI
        //        Defense stats included in transcript exports
        //        Real-time expandable transcript viewer in agent cards
        //        Live indicator when agent is thinking/making API calls
        //        Auto-scrolling transcript with message count display
        //
        // v5.15.2: Try Again Replay System + PROBE INTEGRITY UI Fix
        //        Fixed PROBE INTEGRITY health bar styling (cyan border, proper layout)
        //        Health bar now shows critical state animation when HP <= 25%
        //        Try Again button on each assistant response in transcript
        //        Full interaction history stored (request/response/context)
        //        Replay interactions with current game state
        //        Side-by-side comparison of original vs retry responses
        //        Branch off with new response when results differ
        //        Tracks branched interactions for debugging
        //
        // v5.16: Autonomous Agent World Presence System
        //        Distinct mini-robot meshes for each agent type with tools
        //        Gatherers have pickaxe, Hunters have sword, Miners have drill
        //        Healers have medical cross, Scouts have antenna, etc.
        //        Agents physically move on the map doing real tasks
        //        Gatherer/Miner: Find and harvest trees/rocks autonomously
        //        Hunter/Protector: Patrol and attack enemies, avoid bosses
        //        Scout/Explorer: Wide-range exploration, report discoveries
        //        Healer: Follow player/agents and provide healing
        //        Fisher: Find fishing spots and catch fish
        //        Agent alert system with pulsing red indicator
        //        Alerts for: low HP, found boss, agent down, stuck
        //        Troubleshooting UI when player approaches alerted agent
        //        View recent task logs, heal agent, reset task
        //        Agents face movement direction, tools animate when working
        //
        // v5.16.1: Agent Body Cam Preview System
        //        Live body cam view when expanding agent transcript
        //        Camera renders from agent's POV with scan line effect
        //        Vignette overlay for cinematic feel
        //        Shows agent coordinates and current action
        //        Click body cam to locate agent on map
        //        Creates beacon beam at agent location
        //        Sets navigation target to walk to agent
        //        Agents shown on minimap with type-specific colors
        //        Highlighted agents get pulsing ring on minimap
        //        Alerted agents shown in red on minimap
        //
        // v5.16.2: AGENT TAKEOVER / REMOTE CONTROL SYSTEM
        //        Full real-time remote control of any agent
        //        Flyout window with first-person POV rendering
        //        WASD movement controls with visual key indicators
        //        HUD overlay showing HP, target info, status
        //        Crosshair and status badge in viewport
        //        Action button (E) to interact with nearby objects
        //        Attack mobs or harvest resources as agent
        //        Locate button (L) to focus main camera on agent
        //        Auto Mode toggle (M) to switch between manual/autonomous
        //        Return to Robot (ESC) to exit takeover mode
        //
        // v5.16.3: AGENT AUTONOMOUS MODE FIX
        //        Fixed agents not spawning if created before scene was ready
        //        Body cam now shows actual agent POV (was showing black)
        //        Click to Locate now teleports player directly to agent
        //        Agent status shows actual task state from autonomous system
        //        Status displays: Moving, Working, Combat, Idle with coordinates
        //        Agents properly run deterministic tasks based on their type
        //        Active control indicator at top of screen
        //        Agent pauses autonomous behavior during manual control
        //        Smooth restoration of autonomous state on exit
        //
        // v5.17.0: AGENT EXPERIENCE & EFFICIENCY SYSTEM
        //        Complete agent progression system with XP and levels (1-10)
        //        Agents gain XP from successful actions (+5-8 base)
        //        Level up increases efficiency: +10% per level (max 200%)
        //        Efficiency affects action success rate (40% base  up to 95%)
        //        Higher level agents find better resources and deal more damage
        //        COMBO SYSTEM for consecutive successful actions:
        //          - Each success increases combo counter
        //          - Combo adds +1 XP per level (max +10 bonus)
        //          - Combo adds +2% success rate per level (max +20%)
        //          - Milestone effects at 5x, 10x, 25x, 50x combos
        //          - Failure resets combo (warns if lost significant combo)
        //        PARTICLE EFFECTS for agent actions:
        //          - Gold particles on level up (20 particles, 1.5s)
        //          - Orange particles on combo milestones (12 particles)
        //          - Type-colored particles on successful actions
        //          - Green particles on healing (agent regen)
        //        AGENT HEALTH REGENERATION:
        //          - Passive regen every 5 seconds
        //          - Base: 2 HP + 1 HP per agent level
        //          - Heal particles when significant regen occurs
        //        ENHANCED MINIMAP INDICATORS:
        //          - Agent size scales with level (2-4px)
        //          - Combo aura ring when combo >= 5
        //          - Pulsing glow when working
        //          - Red flash when in combat
        //        AGENT CARD UI IMPROVEMENTS:
        //          - Shows agent level with color coding
        //          - Shows XP progress percentage
        //          - Shows current combo with fire emoji
        //          - Shows efficiency percentage
        //        SCALING REWARDS BY LEVEL:
        //          - Gatherers: +1 item per 3 levels
        //          - Hunters: +2 XP and +1 gold per level
        //          - Healers: +2 HP healed per level
        //          - Protectors: +2 damage per level
        //          - Miners: unlock Silver/Gold/Crystal at levels 3/5/7
        //          - Fishers: unlock Large/Golden Fish at levels 3/5
        //        AGENT SYNERGY SYSTEM:
        //          - Agents near each other (within 15 units) get synergy bonus
        //          - +5% success rate per nearby agent (max +15%)
        //          - Encourages strategic agent positioning
        //        BODY CAM HUD OVERLAY:
        //          - Shows agent level badge (top-left)
        //          - Shows combo counter when active (top-right)
        //          - Efficiency progress bar (bottom-left)
        //        RECALL SUMMARY IMPROVEMENTS:
        //          - Shows agent's final level
        //          - Shows best combo achieved
        //          - Shows success rate percentage
        //          - Shows total actions performed
        //
        // v5.17.1: POP-OUT AGENT CONTROL WINDOWS
        //        Independent agent control in separate browser windows
        //        Main game continues uninterrupted while controlling agents
        //        Each pop-out window features:
        //          - Live first-person POV rendering from agent's perspective
        //          - Real-time HUD with HP, Level, Combo, Efficiency stats
        //          - WASD movement controls with visual key feedback
        //          - Action button (E) to interact with nearby objects/enemies
        //          - Locate button (L) to focus main camera on agent
        //          - Auto/Manual mode toggle (M key or click switch)
        //          - Scan line effect for cinematic body cam feel
        //          - Automatic manual mode activation on key press
        //          - Graceful handling when agent is recalled or main window closes
        //        Multiple agents can have pop-out windows simultaneously
        //        Window positions cascade to avoid overlap
        //        Purple "POP OUT" button added to body cam controls
        //
        // v5.18.0: RTS CONSTRUCTION & ENERGY SYSTEM
        //        Preparing for human colonization - build infrastructure!
        //        NEW AGENT TYPES:
        //          - Terraformer : Flattens terrain for optimal construction
        //          - Builder : Constructs battery chargers and structures
        //        TERRAFORMING SYSTEM:
        //          - Agents analyze 3x3 terrain patches for height variance
        //          - Flatten uneven terrain to average height
        //          - Terraformed areas tracked for construction bonuses
        //          - Agents auto-relocate when area is already flat
        //        BATTERY CHARGER STRUCTURES:
        //          - Builders construct charging stations for robots
        //          - Efficiency based on terrain: 100% on flat, 60-80% on uneven
        //          - Visual design: base platform, pillar, energy ring, beacon
        //          - Color-coded by efficiency (green/yellow/red)
        //          - Animated rings and pulsing beacons
        //          - Point lights for atmospheric glow
        //        ROBOT ENERGY SYSTEM:
        //          - Energy bar added to PROBE INTEGRITY display
        //          - Energy drains slowly when moving
        //          - Stand near battery chargers to recharge
        //          - Charge rate scales with charger efficiency
        //          - Visual feedback: bar color and  indicator
        //        STRUCTURE SYSTEM:
        //          - worldState.structures array for all built objects
        //          - worldState.terraformedAreas tracks flattened zones
        //          - Structures animate in game loop (rings spin, beacons pulse)
        //        P2P SPECTATOR STREAMING via PeerJS:
        //          - Click minimap to toggle QR code view
        //          - QR code contains spectator URL with peer ID
        //          - Others scan QR to watch your exploration live
        //          - Real-time streaming: HP, energy, position, agents, structures
        //          - Minimap image streamed at 10 FPS
        //          - Multiple spectators supported simultaneously
        //          - Spectator mode UI shows all game stats
        //          - Auto-detect spectate param in URL
        //          - Host/spectator connection management
        //
        // v5.19.0: SHOW MODE - SCANNABLE QR CODE SHARING
        //        Beautiful modal matching index_slim_cloud_tools.html pattern
        //        UI DESIGN:
        //          - Fullscreen modal with backdrop blur
        //          - Gradient "Show Mode" title (cyan  blue  green)
        //          - Status info banner with glow effect
        //          - Large scannable QR code (200x200) on white background
        //          - Full URL display in monospace font
        //          - Gradient "COPY URL" button with hover effects
        //          - Animated  close button (rotates on hover)
        //        QR CODE GENERATOR:
        //          - Primary: QRious library (cdnjs.cloudflare.com)
        //          - Fallback: QR Server API (api.qrserver.com)
        //          - High error correction (Level H) for reliable scanning
        //          - Phone camera scans QR  opens browser  auto-joins spectator
        //        MINIMAP INTEGRATION:
        //          - Small  button in top-right corner of minimap
        //          - Opens Show Mode modal on click
        //
        // v5.20.0: SIMPLIFIED SPECTATOR STREAMING
        //        Clean real-time camera sync like index_slim_cloud_tools.html
        //        CAMERA SYNC:
        //          - Spectators see host's exact 3D view with smooth lerp interpolation
        //          - Camera position and rotation synced at 10 FPS
        //          - Game state broadcast every frame with camera, player, stats
        //        STREAM CONTROLS:
        //          -  PAUSE /  RESUME button to freeze/unfreeze camera sync
        //          - EXIT button to leave spectator mode
        //          - Live latency display in banner
        //        SPECTATOR BANNER:
        //          - Red banner at top: " SPECTATOR MODE - Following: Host"
        //          - Shows connection latency
        //          - Pause/Resume and Exit buttons

        const APP_NAME = 'leviathan-omniverse';
        const VERSION = '7.0'; // v7.0: UNIFIED DESIGN SYSTEM - Design tokens, z-index layering, unified buttons, micro-animations, 44px touch targets, panel transitions, keyboard hints, accessibility focus indicators, mobile responsive polish

        // ============================================
        // v7.0: PERFORMANCE UTILITIES
        // Debounce and throttle to prevent layout thrashing
        // ============================================
        const UIPerformance = {
            // Debounce: delays execution until after wait ms of no calls
            debounce(fn, wait = 100) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => fn.apply(this, args), wait);
                };
            },

            // Throttle: executes at most once per wait ms
            throttle(fn, wait = 16) {
                let lastTime = 0;
                return function(...args) {
                    const now = Date.now();
                    if (now - lastTime >= wait) {
                        lastTime = now;
                        fn.apply(this, args);
                    }
                };
            },

            // RequestAnimationFrame wrapper for smooth UI updates
            rafUpdate(fn) {
                let rafId = null;
                return function(...args) {
                    if (rafId) return;
                    rafId = requestAnimationFrame(() => {
                        fn.apply(this, args);
                        rafId = null;
                    });
                };
            },

            // Batch DOM reads/writes to prevent layout thrashing
            batchUpdate(readFn, writeFn) {
                const data = readFn();
                requestAnimationFrame(() => writeFn(data));
            }
        };

        // ============================================
        // THREE.js Extensions: FontLoader & TextGeometry
        // Required for 3D text rendering
        // ============================================
        THREE.FontLoader = class FontLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(text) {
                    try {
                        const json = JSON.parse(text);
                        const font = scope.parse(json);
                        if (onLoad) onLoad(font);
                    } catch (e) {
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            }

            parse(json) {
                return new THREE.Font(json);
            }
        };

        THREE.Font = class Font {
            constructor(data) {
                this.type = 'Font';
                this.data = data;
            }

            generateShapes(text, size = 100) {
                const shapes = [];
                const paths = createFontPaths(text, size, this.data);
                for (let p = 0, pl = paths.length; p < pl; p++) {
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                }
                return shapes;
            }
        };

        THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
            constructor(text, parameters = {}) {
                const font = parameters.font;
                if (!font || !font.data) {
                    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                    super();
                    return;
                }
                const shapes = font.generateShapes(text, parameters.size);
                parameters.depth = parameters.height !== undefined ? parameters.height : 50;
                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
                super(shapes, parameters);
                this.type = 'TextGeometry';
            }
        };

        function createFontPaths(text, size, data) {
            const chars = Array.from(text);
            const scale = size / data.resolution;
            const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
            const paths = [];
            let offsetX = 0, offsetY = 0;

            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                if (char === '\n') {
                    offsetX = 0;
                    offsetY -= line_height;
                } else {
                    const ret = createFontPath(char, scale, offsetX, offsetY, data);
                    if (ret) {
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
            }
            return paths;
        }

        function createFontPath(char, scale, offsetX, offsetY, data) {
            const glyph = data.glyphs[char] || data.glyphs['?'];
            if (!glyph) {
                console.error('THREE.Font: character "' + char + '" does not exist in font.');
                return;
            }
            const path = new THREE.ShapePath();
            let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if (glyph.o) {
                const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                for (let i = 0, l = outline.length; i < l;) {
                    const action = outline[i++];
                    switch (action) {
                        case 'm':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;
                        case 'l':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;
                        case 'q':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            break;
                        case 'b':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            break;
                    }
                }
            }
            return { offsetX: glyph.ha * scale, path: path };
        }

        // --- AUDIO SYSTEM (Web Audio API - No external dependencies) ---
        // v6.14: THERAPEUTIC AUDIO REDESIGN
        // Designed for pleasant background listening while multitasking
        // - Pentatonic scales (always harmonious, no dissonance)
        // - Soft sine waves with gentle envelopes
        // - Musical intervals that are pleasing to hear repeatedly
        // - State-conveying ambient layers (health, prosperity, danger)
        const AudioSystem = {
            ctx: null,
            enabled: true,
            masterVolume: 0.2, // Lower for background listening

            // v6.14: Pentatonic scale - these notes NEVER clash
            penta: { C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.00, A3: 220.00,
                     C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, A4: 440.00,
                     C5: 523.25, D5: 587.33, E5: 659.25, G5: 783.99, A5: 880.00 },

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // v6.14: Gentle tone with soft attack/decay (therapeutic)
            playGentle(freq, dur, vol = 0.3) {
                if (!this.enabled || !this.ctx) return;
                this.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                osc.type = 'sine';
                osc.frequency.value = freq;
                filter.type = 'lowpass';
                filter.frequency.value = 1500;
                const now = this.ctx.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(this.masterVolume * vol, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
                osc.connect(filter).connect(gain).connect(this.ctx.destination);
                osc.start(now);
                osc.stop(now + dur);
            },

            // Legacy compatibility - routes through gentle system
            playTone(freq, duration, type = 'sine', volume = 1) {
                this.playGentle(freq, duration * 1.5, volume * 0.5);
            },

            // v6.6: Generic play() method
            play(soundName) {
                const soundMap = {
                    'hit': () => this.hit(),
                    'collect': () => this.collect(),
                    'damage': () => this.damage(),
                    'kill': () => this.defeat(),
                    'defeat': () => this.defeat(),
                    'explosion': () => this.explosion(),
                    'levelUp': () => this.levelUp(),
                    'craft': () => this.craft(),
                    'click': () => this.click(),
                    'error': () => this.gentleWarn(),
                    'heal': () => this.heal(),
                    'dodge': () => this.dodge(),
                    'telegraph': () => this.telegraph(),
                    'spell': () => this.playGentle(this.penta.E4, 0.4, 0.25),
                    'powerup': () => this.levelUp(),
                    'ui': () => this.click(),
                    'bossSpawn': () => this.bossSpawn(),
                    'recipeDiscovered': () => this.recipeDiscovered()
                };
                (soundMap[soundName] || (() => this.playGentle(this.penta.C4, 0.3, 0.15)))();
            },

            // v6.14: THERAPEUTIC SOUND EFFECTS
            // v6.41: Combo-aware hit sound with ascending pitch (Agent 5 consensus - audio juice)
            hit(comboCount = 0) {
                // Scale up pentatonic notes as combo builds - creates satisfying musical feedback
                const pitchSteps = [this.penta.G3, this.penta.A3, this.penta.C4, this.penta.D4, this.penta.E4];
                const clampedCombo = Math.min(comboCount, pitchSteps.length - 1);
                const basePitch = pitchSteps[clampedCombo];

                // Volume and duration increase slightly with combo
                const vol = 0.2 + clampedCombo * 0.02;
                const dur = 0.12 + clampedCombo * 0.015;

                this.playGentle(basePitch, dur, vol);

                // Add harmonic overtone for higher combos (satisfying stacking effect)
                if (comboCount >= 3) {
                    setTimeout(() => this.playGentle(basePitch * 1.5, 0.08, 0.06), 20);
                }
            },

            collect() {
                this.playGentle(this.penta.E4, 0.25, 0.25);
                setTimeout(() => this.playGentle(this.penta.G4, 0.3, 0.15), 60);
            },

            damage() {
                this.playGentle(this.penta.C3, 0.2, 0.3);
            },

            defeat() {
                // Satisfying chord
                this.playGentle(this.penta.C4, 0.4, 0.25);
                setTimeout(() => this.playGentle(this.penta.E4, 0.35, 0.2), 30);
                setTimeout(() => this.playGentle(this.penta.G4, 0.3, 0.15), 60);
            },

            kill() { this.defeat(); },

            explosion() {
                this.playGentle(this.penta.C3, 0.5, 0.35);
                setTimeout(() => this.playGentle(this.penta.G3, 0.4, 0.2), 100);
            },

            levelUp() {
                [this.penta.C4, this.penta.E4, this.penta.G4, this.penta.C5].forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.35, 0.3 - i * 0.04), i * 100);
                });
            },

            craft() {
                this.playGentle(this.penta.A4, 0.2, 0.2);
                setTimeout(() => this.playGentle(this.penta.E5, 0.25, 0.12), 50);
            },

            click() { this.playGentle(this.penta.C5, 0.06, 0.08); },

            gentleWarn() {
                this.playGentle(this.penta.E4, 0.25, 0.2);
                setTimeout(() => this.playGentle(this.penta.D4, 0.3, 0.15), 120);
            },

            error() { this.gentleWarn(); },

            heal() {
                this.playGentle(this.penta.G4, 0.4, 0.25);
                setTimeout(() => this.playGentle(this.penta.C5, 0.35, 0.2), 80);
            },

            dodge() {
                this.playGentle(this.penta.D4, 0.1, 0.15);
                setTimeout(() => this.playGentle(this.penta.G4, 0.08, 0.1), 30);
            },

            telegraph() { this.playGentle(this.penta.A3, 0.18, 0.15); },

            // v6.68: War horn for versus match start - epic, powerful sound
            warHorn() {
                if (!this.enabled || !this.ctx) return;
                this.resume();
                // Create a deep, resonant horn sound
                const now = this.ctx.currentTime;

                // Main horn tone - deep and powerful
                const horn1 = this.ctx.createOscillator();
                const horn1Gain = this.ctx.createGain();
                horn1.type = 'sawtooth';
                horn1.frequency.setValueAtTime(65.41, now); // C2
                horn1.frequency.linearRampToValueAtTime(73.42, now + 0.3); // Rise slightly
                horn1.frequency.linearRampToValueAtTime(65.41, now + 2.5); // Back down
                horn1Gain.gain.setValueAtTime(0, now);
                horn1Gain.gain.linearRampToValueAtTime(this.masterVolume * 0.4, now + 0.2);
                horn1Gain.gain.setValueAtTime(this.masterVolume * 0.4, now + 2);
                horn1Gain.gain.linearRampToValueAtTime(0, now + 2.8);

                // Harmonic overtone
                const horn2 = this.ctx.createOscillator();
                const horn2Gain = this.ctx.createGain();
                horn2.type = 'sawtooth';
                horn2.frequency.setValueAtTime(130.81, now); // C3
                horn2.frequency.linearRampToValueAtTime(146.83, now + 0.3);
                horn2.frequency.linearRampToValueAtTime(130.81, now + 2.5);
                horn2Gain.gain.setValueAtTime(0, now);
                horn2Gain.gain.linearRampToValueAtTime(this.masterVolume * 0.25, now + 0.2);
                horn2Gain.gain.setValueAtTime(this.masterVolume * 0.25, now + 2);
                horn2Gain.gain.linearRampToValueAtTime(0, now + 2.8);

                // Sub bass for power
                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                sub.type = 'sine';
                sub.frequency.value = 32.7; // C1
                subGain.gain.setValueAtTime(0, now);
                subGain.gain.linearRampToValueAtTime(this.masterVolume * 0.5, now + 0.15);
                subGain.gain.setValueAtTime(this.masterVolume * 0.5, now + 2);
                subGain.gain.linearRampToValueAtTime(0, now + 2.8);

                // Lowpass filter for warmth
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 1;

                // Connect
                horn1.connect(horn1Gain).connect(filter);
                horn2.connect(horn2Gain).connect(filter);
                sub.connect(subGain).connect(filter);
                filter.connect(this.ctx.destination);

                horn1.start(now);
                horn1.stop(now + 3);
                horn2.start(now);
                horn2.stop(now + 3);
                sub.start(now);
                sub.stop(now + 3);
            },

            // v6.68: Victory fanfare for winning versus match
            victoryFanfare() {
                // Ascending triumphant melody
                const notes = [this.penta.C4, this.penta.E4, this.penta.G4, this.penta.C5, this.penta.E5];
                notes.forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.5, 0.35), i * 120);
                });
                // Final chord
                setTimeout(() => {
                    this.playGentle(this.penta.C5, 0.8, 0.3);
                    this.playGentle(this.penta.E5, 0.8, 0.25);
                    this.playGentle(this.penta.G5, 0.8, 0.2);
                }, 600);
            },

            // v6.68: Defeat sound for losing versus match
            defeatSound() {
                // Descending somber melody
                const notes = [this.penta.G4, this.penta.E4, this.penta.C4, this.penta.G3, this.penta.C3];
                notes.forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.6, 0.25 - i * 0.03), i * 200);
                });
            },

            // v6.14: Calmer heartbeat - meditation pulse, not panic
            // v6.33: HEARTBEAT WORLD PULSE - 8-agent consensus synaesthetic effect
            heartbeatInterval: null,
            heartbeatActive: false,
            heartbeatVisualCallback: null,

            startHeartbeat(hpPercent) {
                if (!this.enabled || !this.ctx || this.heartbeatActive) return;
                this.resume();
                this.heartbeatActive = true;
                const bpm = 35 + (1 - hpPercent) * 15; // 35-50 BPM (meditative)
                const playBeat = () => {
                    if (!this.heartbeatActive) return;
                    this.playGentle(this.penta.C3, 0.35, 0.12);
                    // v6.33: Trigger visual world pulse synchronized with heartbeat
                    if (this.heartbeatVisualCallback) {
                        this.heartbeatVisualCallback(hpPercent);
                    }
                };
                playBeat();
                this.heartbeatInterval = setInterval(playBeat, 60000 / bpm);
            },

            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                this.heartbeatActive = false;
            },

            updateHeartbeat(hpPercent) {
                if (hpPercent <= 0.25 && !this.heartbeatActive) this.startHeartbeat(hpPercent);
                else if (hpPercent > 0.25 && this.heartbeatActive) this.stopHeartbeat();
            },

            // v6.14: Therapeutic ambient - layered harmonic drones
            ambientNodes: null,
            currentBiome: null,

            biomeAmbient: {
                Terra:    { base: 65.41,  harmonics: [1, 1.5, 2], vol: 0.04 },
                Desert:   { base: 73.42,  harmonics: [1, 1.33, 2], vol: 0.035 },
                Ice:      { base: 98.00,  harmonics: [1, 1.5, 2.5], vol: 0.035 },
                Volcanic: { base: 55.00,  harmonics: [1, 1.25, 1.5], vol: 0.04 },
                Alien:    { base: 82.41,  harmonics: [1, 1.4, 2.2], vol: 0.03 }
            },

            startAmbient(biome) {
                if (!this.enabled || !this.ctx || this.currentBiome === biome) return;
                this.stopAmbient();
                this.currentBiome = biome;
                this.resume();
                const cfg = this.biomeAmbient[biome] || this.biomeAmbient.Terra;
                this.ambientNodes = [];

                cfg.harmonics.forEach((h, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    const lfo = this.ctx.createOscillator();
                    const lfoG = this.ctx.createGain();

                    lfo.frequency.value = 0.08 + i * 0.03;
                    lfoG.gain.value = cfg.base * h * 0.015;
                    lfo.connect(lfoG).connect(osc.frequency);
                    lfo.start();

                    osc.type = 'sine';
                    osc.frequency.value = cfg.base * h;
                    filter.type = 'lowpass';
                    filter.frequency.value = 350 - i * 40;
                    gain.gain.value = cfg.vol * this.masterVolume * (1 - i * 0.2);

                    osc.connect(filter).connect(gain).connect(this.ctx.destination);
                    osc.start();
                    this.ambientNodes.push({ osc, gain, lfo, filter });
                });
            },

            stopAmbient() {
                if (this.ambientNodes) {
                    this.ambientNodes.forEach(n => {
                        try { n.osc.stop(); n.osc.disconnect(); n.lfo.stop(); n.lfo.disconnect(); } catch(e) {}
                    });
                    this.ambientNodes = null;
                    this.currentBiome = null;
                }
            },

            bossSpawn() {
                [this.penta.C3, this.penta.G3, this.penta.C3].forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.6, 0.3 - i * 0.06), i * 180);
                });
            },

            recipeDiscovered() {
                [this.penta.E4, this.penta.G4, this.penta.A4].forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.3, 0.25), i * 80);
                });
            },

            // v6.14: New therapeutic sounds for background awareness
            agentPing() { this.playGentle(this.penta.A5, 0.15, 0.08); },
            prosperity() { this.playGentle(this.penta.C5, 0.25, 0.12); },
            waveSpawn() { this.playGentle(this.penta.G3, 0.4, 0.1); },

            // 
            // v6.15: NATURE SOUNDSCAPE SYSTEM
            // Procedural birds, wind through grass, natural ambience
            // Creates immersive outdoor atmosphere without audio loops
            // 

            natureActive: false,
            birdTimeouts: [],
            windNodes: null,
            cricketInterval: null,

            // Bird species - each has unique frequency patterns and timing
            birdSpecies: {
                // Warbler: Quick ascending trill (cheerful, common)
                warbler: {
                    notes: [2200, 2400, 2600, 2800, 3000],
                    noteDur: 0.04,
                    gap: 30,
                    vol: 0.06,
                    chance: 0.4
                },
                // Thrush: Descending melodic phrase (peaceful, forest)
                thrush: {
                    notes: [1800, 1650, 1500, 1400, 1300],
                    noteDur: 0.12,
                    gap: 100,
                    vol: 0.05,
                    chance: 0.25
                },
                // Sparrow: Simple repeated chips (friendly, familiar)
                sparrow: {
                    notes: [3200, 3200, 3400],
                    noteDur: 0.05,
                    gap: 60,
                    vol: 0.045,
                    chance: 0.35
                },
                // Robin: Musical phrase with pause (dawn chorus feel)
                robin: {
                    notes: [2000, 2400, 2200, 2600, 2400, 2800],
                    noteDur: 0.08,
                    gap: 70,
                    vol: 0.055,
                    chance: 0.2
                },
                // Chickadee: Distinctive two-tone call
                chickadee: {
                    notes: [2800, 2300, 2300],
                    noteDur: 0.15,
                    gap: 120,
                    vol: 0.05,
                    chance: 0.2
                },
                // Mourning dove: Soft cooing (calming)
                dove: {
                    notes: [600, 800, 700, 700, 600],
                    noteDur: 0.25,
                    gap: 200,
                    vol: 0.04,
                    chance: 0.15
                }
            },

            // Biome-specific nature configurations
            biomeNature: {
                Terra: {
                    birdDensity: 1.0,      // Full bird activity
                    birdTypes: ['warbler', 'thrush', 'sparrow', 'robin', 'chickadee', 'dove'],
                    windBase: 0.015,        // Gentle breeze
                    windGust: 0.025,
                    crickets: true,
                    cricketVol: 0.02
                },
                Desert: {
                    birdDensity: 0.3,      // Sparse birds
                    birdTypes: ['sparrow', 'dove'],
                    windBase: 0.025,        // Stronger wind
                    windGust: 0.04,
                    crickets: false,
                    cricketVol: 0
                },
                Ice: {
                    birdDensity: 0.1,      // Almost no birds
                    birdTypes: ['sparrow'],
                    windBase: 0.008,        // Subtle cold breeze (not harsh)
                    windGust: 0.015,
                    crickets: false,
                    cricketVol: 0
                },
                Volcanic: {
                    birdDensity: 0.05,     // Minimal life
                    birdTypes: [],
                    windBase: 0.02,
                    windGust: 0.03,
                    crickets: false,
                    cricketVol: 0
                },
                Alien: {
                    birdDensity: 0.4,      // Alien creatures
                    birdTypes: ['alien'],  // Special alien calls
                    windBase: 0.018,
                    windGust: 0.03,
                    crickets: false,
                    cricketVol: 0
                }
            },

            // Play a single bird chirp with natural variation
            chirpBird(species) {
                if (!this.enabled || !this.ctx || !this.natureActive) return;
                this.resume();

                const bird = species === 'alien' ? {
                    // Alien creature: weird sliding tones
                    notes: [800 + Math.random() * 400, 1200 + Math.random() * 600, 600 + Math.random() * 300],
                    noteDur: 0.15 + Math.random() * 0.1,
                    gap: 80,
                    vol: 0.04
                } : this.birdSpecies[species];

                if (!bird) return;

                // Add natural pitch variation (5%)
                const pitchVar = 0.95 + Math.random() * 0.1;
                // Add timing variation
                const tempoVar = 0.85 + Math.random() * 0.3;

                bird.notes.forEach((freq, i) => {
                    setTimeout(() => {
                        if (!this.natureActive) return;

                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        const filter = this.ctx.createBiquadFilter();

                        // Bird calls use sine for purity
                        osc.type = 'sine';
                        osc.frequency.value = freq * pitchVar;

                        // Slight frequency wobble for natural sound
                        const vibrato = this.ctx.createOscillator();
                        const vibGain = this.ctx.createGain();
                        vibrato.frequency.value = 8 + Math.random() * 4;
                        vibGain.gain.value = freq * 0.015;
                        vibrato.connect(vibGain).connect(osc.frequency);
                        vibrato.start();

                        // Bandpass to make it sound more like a bird
                        filter.type = 'bandpass';
                        filter.frequency.value = freq * pitchVar;
                        filter.Q.value = 3;

                        const now = this.ctx.currentTime;
                        const dur = bird.noteDur * tempoVar;

                        // Natural attack/decay envelope
                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(this.masterVolume * bird.vol, now + dur * 0.15);
                        gain.gain.setValueAtTime(this.masterVolume * bird.vol, now + dur * 0.6);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + dur);

                        osc.connect(filter).connect(gain).connect(this.ctx.destination);
                        osc.start(now);
                        osc.stop(now + dur);
                        vibrato.stop(now + dur);
                    }, i * bird.gap * tempoVar);
                });
            },

            // Schedule random bird chirps with natural clustering
            scheduleBirdChirps(biome) {
                if (!this.natureActive) return;

                const cfg = this.biomeNature[biome] || this.biomeNature.Terra;
                if (cfg.birdTypes.length === 0) return;

                // Random delay: 2-8 seconds, adjusted by density
                const baseDelay = 2000 + Math.random() * 6000;
                const delay = baseDelay / cfg.birdDensity;

                const timeout = setTimeout(() => {
                    if (!this.natureActive) return;

                    // Pick random bird species
                    const species = cfg.birdTypes[Math.floor(Math.random() * cfg.birdTypes.length)];
                    const bird = this.birdSpecies[species];

                    // Check if this bird "wants" to sing based on its chance
                    if (!bird || Math.random() < bird.chance) {
                        this.chirpBird(species);

                        // Sometimes birds respond to each other (clustering)
                        if (Math.random() < 0.3 && cfg.birdTypes.length > 1) {
                            setTimeout(() => {
                                const otherSpecies = cfg.birdTypes.filter(s => s !== species);
                                if (otherSpecies.length > 0) {
                                    this.chirpBird(otherSpecies[Math.floor(Math.random() * otherSpecies.length)]);
                                }
                            }, 300 + Math.random() * 700);
                        }
                    }

                    // Schedule next chirp
                    this.scheduleBirdChirps(biome);
                }, delay);

                this.birdTimeouts.push(timeout);
            },

            // Wind through grass - filtered noise with gentle modulation
            startWind(biome) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const cfg = this.biomeNature[biome] || this.biomeNature.Terra;

                // Create noise source using buffer
                const bufferSize = this.ctx.sampleRate * 2;
                const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);

                // Pink-ish noise (more natural than white)
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;

                // Multiple filters for wind character
                const lowpass = this.ctx.createBiquadFilter();
                lowpass.type = 'lowpass';
                lowpass.frequency.value = 400; // Low rumble

                const highpass = this.ctx.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 60;

                // Main gain
                const gain = this.ctx.createGain();
                gain.gain.value = this.masterVolume * cfg.windBase;

                // LFO for wind swells (breathing effect)
                const lfo1 = this.ctx.createOscillator();
                const lfo1Gain = this.ctx.createGain();
                lfo1.frequency.value = 0.08; // Very slow swell
                lfo1Gain.gain.value = this.masterVolume * cfg.windBase * 0.5;
                lfo1.connect(lfo1Gain).connect(gain.gain);

                // Second LFO for irregular gusts
                const lfo2 = this.ctx.createOscillator();
                const lfo2Gain = this.ctx.createGain();
                lfo2.frequency.value = 0.03;
                lfo2Gain.gain.value = this.masterVolume * cfg.windGust * 0.3;
                lfo2.connect(lfo2Gain).connect(gain.gain);

                // Higher frequency component for grass rustle
                const highNoise = this.ctx.createBufferSource();
                highNoise.buffer = noiseBuffer;
                highNoise.loop = true;

                const grassFilter = this.ctx.createBiquadFilter();
                grassFilter.type = 'bandpass';
                grassFilter.frequency.value = 2000;
                grassFilter.Q.value = 0.5;

                const grassGain = this.ctx.createGain();
                grassGain.gain.value = this.masterVolume * cfg.windBase * 0.15;

                // Grass rustle modulation
                const grassLfo = this.ctx.createOscillator();
                const grassLfoGain = this.ctx.createGain();
                grassLfo.frequency.value = 0.12;
                grassLfoGain.gain.value = this.masterVolume * cfg.windBase * 0.1;
                grassLfo.connect(grassLfoGain).connect(grassGain.gain);

                // Connect everything
                noise.connect(lowpass).connect(highpass).connect(gain).connect(this.ctx.destination);
                highNoise.connect(grassFilter).connect(grassGain).connect(this.ctx.destination);

                // Start all oscillators
                noise.start();
                highNoise.start();
                lfo1.start();
                lfo2.start();
                grassLfo.start();

                this.windNodes = {
                    noise, highNoise, lowpass, highpass, gain, grassFilter, grassGain,
                    lfo1, lfo1Gain, lfo2, lfo2Gain, grassLfo, grassLfoGain
                };
            },

            stopWind() {
                if (this.windNodes) {
                    try {
                        this.windNodes.noise.stop();
                        this.windNodes.highNoise.stop();
                        this.windNodes.lfo1.stop();
                        this.windNodes.lfo2.stop();
                        this.windNodes.grassLfo.stop();
                        Object.values(this.windNodes).forEach(n => { try { n.disconnect(); } catch(e) {} });
                    } catch(e) {}
                    this.windNodes = null;
                }
            },

            // Cricket/night sounds for appropriate biomes
            startCrickets(biome) {
                const cfg = this.biomeNature[biome] || this.biomeNature.Terra;
                if (!cfg.crickets) return;

                this.cricketInterval = setInterval(() => {
                    if (!this.natureActive || !this.ctx) return;

                    // Random chance for cricket chirp
                    if (Math.random() < 0.4) {
                        const baseFreq = 4000 + Math.random() * 500;
                        const chirps = 2 + Math.floor(Math.random() * 4);

                        for (let i = 0; i < chirps; i++) {
                            setTimeout(() => {
                                if (!this.natureActive) return;

                                const osc = this.ctx.createOscillator();
                                const gain = this.ctx.createGain();

                                osc.type = 'sine';
                                osc.frequency.value = baseFreq + Math.random() * 100;

                                const now = this.ctx.currentTime;
                                gain.gain.setValueAtTime(0, now);
                                gain.gain.linearRampToValueAtTime(this.masterVolume * cfg.cricketVol, now + 0.005);
                                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);

                                osc.connect(gain).connect(this.ctx.destination);
                                osc.start(now);
                                osc.stop(now + 0.03);
                            }, i * 50);
                        }
                    }
                }, 800 + Math.random() * 1200);
            },

            stopCrickets() {
                if (this.cricketInterval) {
                    clearInterval(this.cricketInterval);
                    this.cricketInterval = null;
                }
            },

            // Master nature soundscape control
            startNatureSoundscape(biome) {
                if (this.natureActive && this.currentBiome === biome) return;
                this.stopNatureSoundscape();

                this.natureActive = true;
                this.startWind(biome);
                this.scheduleBirdChirps(biome);
                this.startCrickets(biome);
            },

            stopNatureSoundscape() {
                this.natureActive = false;

                // Clear all bird timeouts
                this.birdTimeouts.forEach(t => clearTimeout(t));
                this.birdTimeouts = [];

                this.stopWind();
                this.stopCrickets();
            },

            // Override startAmbient to include nature sounds
            _originalStartAmbient: null,

            initNature() {
                // Wrap startAmbient to also start nature sounds
                const self = this;
                const originalStart = this.startAmbient.bind(this);
                this.startAmbient = function(biome) {
                    originalStart(biome);
                    self.startNatureSoundscape(biome);
                };

                const originalStop = this.stopAmbient.bind(this);
                this.stopAmbient = function() {
                    originalStop();
                    self.stopNatureSoundscape();
                };
            },

            // 
            // v6.32: ADAPTIVE COMBAT MUSIC SYSTEM
            // 8-Agent Consensus Implementation
            // Dynamic music intensity that responds to combat state
            // Uses pentatonic scale for always-harmonious layering
            // 

            combatMusic: {
                active: false,
                intensity: 0,          // 0-5 scale
                targetIntensity: 0,
                nodes: [],
                updateInterval: null,
                lastIntensityChange: 0,
                decayDelay: 3000,       // ms before intensity decays
                recentHits: 0,
                recentKills: 0,
                bossActive: false
            },

            // Combat intensity configuration per level
            combatMusicConfig: {
                // Level 0: Silence (handled by ambient)
                // Level 1: Tension drone - single low note
                1: { baseNote: 'C3', layers: 1, rhythm: false, tempo: 0 },
                // Level 2: Building tension - two-note drone with subtle pulse
                2: { baseNote: 'C3', layers: 2, rhythm: true, tempo: 40 },
                // Level 3: Combat engaged - three layers with rhythm
                3: { baseNote: 'G3', layers: 3, rhythm: true, tempo: 60 },
                // Level 4: Intense combat - full layers, faster rhythm
                4: { baseNote: 'C4', layers: 4, rhythm: true, tempo: 90 },
                // Level 5: Boss battle - maximum intensity
                5: { baseNote: 'C4', layers: 5, rhythm: true, tempo: 120 }
            },

            // Start combat music system
            startCombatMusic() {
                if (!this.enabled || !this.ctx || this.combatMusic.active) return;
                this.resume();
                this.combatMusic.active = true;
                this.combatMusic.intensity = 0;
                this.combatMusic.targetIntensity = 0;

                // Update intensity smoothly over time
                this.combatMusic.updateInterval = setInterval(() => {
                    this.updateCombatMusicIntensity();
                }, 100);
            },

            stopCombatMusic() {
                if (!this.combatMusic.active) return;
                this.combatMusic.active = false;

                if (this.combatMusic.updateInterval) {
                    clearInterval(this.combatMusic.updateInterval);
                    this.combatMusic.updateInterval = null;
                }

                // Fade out all combat music nodes
                this.fadeCombatMusicOut();
            },

            // Register combat events to affect intensity
            combatEvent(type) {
                if (!this.combatMusic.active) return;

                const now = performance.now();
                this.combatMusic.lastIntensityChange = now;

                switch(type) {
                    case 'hit':
                        this.combatMusic.recentHits++;
                        this.combatMusic.targetIntensity = Math.min(5,
                            this.combatMusic.targetIntensity + 0.3);
                        break;
                    case 'kill':
                        this.combatMusic.recentKills++;
                        this.combatMusic.targetIntensity = Math.min(5,
                            this.combatMusic.targetIntensity + 0.5);
                        // Brief intensity spike on kill
                        this.playCombatAccent();
                        break;
                    case 'crit':
                        this.combatMusic.targetIntensity = Math.min(5,
                            this.combatMusic.targetIntensity + 0.7);
                        this.playCombatAccent();
                        break;
                    case 'finisher':
                        this.combatMusic.targetIntensity = Math.min(5,
                            this.combatMusic.targetIntensity + 1.0);
                        this.playCombatFinisherAccent();
                        break;
                    case 'bossEngage':
                        this.combatMusic.bossActive = true;
                        this.combatMusic.targetIntensity = 5;
                        break;
                    case 'bossDefeat':
                        this.combatMusic.bossActive = false;
                        this.playCombatVictoryFanfare();
                        break;
                    case 'damage':
                        this.combatMusic.targetIntensity = Math.min(5,
                            this.combatMusic.targetIntensity + 0.4);
                        break;
                    case 'nearEnemies':
                        // Called when enemies are nearby
                        this.combatMusic.targetIntensity = Math.max(1,
                            this.combatMusic.targetIntensity);
                        break;
                }
            },

            updateCombatMusicIntensity() {
                if (!this.combatMusic.active || !this.ctx) return;

                const now = performance.now();
                const timeSinceAction = now - this.combatMusic.lastIntensityChange;

                // Decay intensity over time when not in combat
                if (timeSinceAction > this.combatMusic.decayDelay && !this.combatMusic.bossActive) {
                    this.combatMusic.targetIntensity = Math.max(0,
                        this.combatMusic.targetIntensity - 0.05);
                }

                // Decay recent counters
                if (this.combatMusic.recentHits > 0) this.combatMusic.recentHits *= 0.95;
                if (this.combatMusic.recentKills > 0) this.combatMusic.recentKills *= 0.9;

                // Smooth intensity transition
                const diff = this.combatMusic.targetIntensity - this.combatMusic.intensity;
                if (Math.abs(diff) > 0.1) {
                    this.combatMusic.intensity += diff * 0.1;

                    // Update music layers when crossing intensity thresholds
                    const newLevel = Math.floor(this.combatMusic.intensity);
                    const currentLevel = Math.floor(this.combatMusic.intensity - diff * 0.1);

                    if (newLevel !== currentLevel) {
                        this.setCombatMusicLevel(newLevel);
                    }
                }
            },

            setCombatMusicLevel(level) {
                if (!this.ctx || level < 0 || level > 5) return;

                // Clear existing combat music nodes
                this.fadeCombatMusicOut();

                if (level === 0) return; // Silence

                const config = this.combatMusicConfig[level];
                if (!config) return;

                const baseFreq = this.penta[config.baseNote];

                // Create layered drones
                for (let i = 0; i < config.layers; i++) {
                    this.createCombatMusicLayer(baseFreq, i, config);
                }

                // Add rhythmic pulse if enabled
                if (config.rhythm && config.tempo > 0) {
                    this.startCombatRhythm(config.tempo, level);
                }
            },

            createCombatMusicLayer(baseFreq, layerIndex, config) {
                if (!this.ctx) return;

                const harmonics = [1, 1.5, 2, 2.5, 3];
                const freq = baseFreq * harmonics[layerIndex % harmonics.length];
                const vol = 0.025 * (1 - layerIndex * 0.15) * this.masterVolume;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = layerIndex === 0 ? 'sine' : 'triangle';
                osc.frequency.value = freq;

                filter.type = 'lowpass';
                filter.frequency.value = 400 + layerIndex * 100;

                // Fade in
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.5);

                // Add subtle LFO for movement
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = 0.1 + layerIndex * 0.05;
                lfoGain.gain.value = freq * 0.02;
                lfo.connect(lfoGain).connect(osc.frequency);
                lfo.start();

                osc.connect(filter).connect(gain).connect(this.ctx.destination);
                osc.start();

                this.combatMusic.nodes.push({ osc, gain, lfo, filter, type: 'layer' });
            },

            combatRhythmInterval: null,

            startCombatRhythm(tempo, level) {
                if (this.combatRhythmInterval) {
                    clearInterval(this.combatRhythmInterval);
                }

                const beatMs = 60000 / tempo;
                let beatCount = 0;

                this.combatRhythmInterval = setInterval(() => {
                    if (!this.combatMusic.active) {
                        clearInterval(this.combatRhythmInterval);
                        return;
                    }

                    // Play rhythmic pulse
                    const pulseFreq = level >= 4 ? this.penta.G3 : this.penta.C3;
                    const vol = 0.03 + (level * 0.01);

                    // Accent on beat 1
                    const isAccent = beatCount % 4 === 0;
                    this.playGentle(pulseFreq, isAccent ? 0.15 : 0.08, isAccent ? vol * 1.3 : vol);

                    // Higher intensity adds off-beat hits
                    if (level >= 3 && beatCount % 2 === 1) {
                        setTimeout(() => {
                            this.playGentle(this.penta.E3, 0.06, vol * 0.5);
                        }, beatMs / 2);
                    }

                    beatCount++;
                }, beatMs);
            },

            fadeCombatMusicOut() {
                // Stop rhythm
                if (this.combatRhythmInterval) {
                    clearInterval(this.combatRhythmInterval);
                    this.combatRhythmInterval = null;
                }

                // Fade out and cleanup all nodes
                this.combatMusic.nodes.forEach(node => {
                    try {
                        if (node.gain && this.ctx) {
                            node.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
                        }
                        setTimeout(() => {
                            try {
                                if (node.osc) { node.osc.stop(); node.osc.disconnect(); }
                                if (node.lfo) { node.lfo.stop(); node.lfo.disconnect(); }
                                if (node.filter) { node.filter.disconnect(); }
                            } catch(e) {}
                        }, 600);
                    } catch(e) {}
                });
                this.combatMusic.nodes = [];
            },

            // Combat accents for dramatic moments
            playCombatAccent() {
                if (!this.enabled || !this.ctx) return;
                this.playGentle(this.penta.G4, 0.12, 0.15);
                setTimeout(() => this.playGentle(this.penta.C5, 0.1, 0.08), 40);
            },

            playCombatFinisherAccent() {
                if (!this.enabled || !this.ctx) return;
                [this.penta.C4, this.penta.E4, this.penta.G4].forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.2, 0.2 - i * 0.04), i * 50);
                });
            },

            playCombatVictoryFanfare() {
                if (!this.enabled || !this.ctx) return;
                [this.penta.G4, this.penta.C5, this.penta.E5, this.penta.G5].forEach((f, i) => {
                    setTimeout(() => this.playGentle(f, 0.4, 0.25 - i * 0.03), i * 120);
                });
            }
        };

        // Initialize nature soundscape integration
        AudioSystem.initNature();

        // --- PARTICLE SYSTEM (v6.6: Performance optimized with shared geometry - Agent 1 & 5 consensus) ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 300; // Increased capacity due to better performance
                this.particlePool = []; // Object pool for reuse
                // v6.32: Reduced geometry complexity for better performance (3,3 is sufficient for small particles)
                this.sharedGeometry = new THREE.SphereGeometry(0.2, 3, 3);
                // Pre-allocated temp vector for physics calculations
                this._tempVelocity = new THREE.Vector3();
                // v6.32: Frame rate tracking for adaptive quality
                this.frameCount = 0;
                this.lastFpsCheck = performance.now();
                this.currentFps = 60;
            }

            emit(position, count, color, options = {}) {
                const spread = options.spread || 3;
                const lifetime = options.lifetime || 1000;
                const size = options.size || 0.2;
                const gravity = options.gravity !== undefined ? options.gravity : 10;

                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    // Try to reuse from pool first
                    let particle = this.particlePool.pop();

                    if (particle) {
                        // Reset pooled particle
                        particle.mesh.material.color.setHex(color);
                        particle.mesh.material.opacity = 1;
                        particle.mesh.visible = true;
                        particle.velocity.set(
                            (Math.random() - 0.5) * spread,
                            Math.random() * spread * 0.8 + spread * 0.2,
                            (Math.random() - 0.5) * spread
                        );
                    } else {
                        // Create new particle only if pool is empty
                        particle = {
                            mesh: new THREE.Mesh(
                                this.sharedGeometry, // Use shared geometry
                                new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                            ),
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * spread,
                                Math.random() * spread * 0.8 + spread * 0.2,
                                (Math.random() - 0.5) * spread
                            )
                        };
                        scene.add(particle.mesh);
                    }

                    particle.lifetime = lifetime;
                    particle.startTime = performance.now();
                    particle.gravity = gravity;
                    particle.baseSize = size;
                    particle.mesh.scale.setScalar(size / 0.2); // Scale relative to shared geometry size
                    particle.mesh.position.copy(position);
                    particle.mesh.position.y += 1;
                    this.particles.push(particle);
                }
            }

            update(dt) {
                const now = performance.now();

                // v6.32: Track FPS for adaptive quality
                this.frameCount++;
                if (now - this.lastFpsCheck >= 1000) {
                    this.currentFps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsCheck = now;

                    // Adaptive quality: reduce max particles if FPS drops
                    if (this.currentFps < 30 && this.maxParticles > 50) {
                        this.maxParticles = Math.max(50, this.maxParticles - 25);
                    } else if (this.currentFps > 55 && this.maxParticles < 300) {
                        this.maxParticles = Math.min(300, this.maxParticles + 10);
                    }
                }

                this.particles = this.particles.filter(p => {
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.lifetime;

                    if (progress >= 1) {
                        // Return to pool instead of disposing
                        p.mesh.visible = false;
                        this.particlePool.push(p);
                        return false;
                    }

                    // Physics - use pre-allocated temp vector instead of clone()
                    p.velocity.y -= p.gravity * dt;
                    this._tempVelocity.copy(p.velocity).multiplyScalar(dt);
                    p.mesh.position.add(this._tempVelocity);
                    p.mesh.material.opacity = 1 - progress;
                    const baseScale = p.baseSize / 0.2;
                    p.mesh.scale.setScalar(baseScale * (1 - progress * 0.5));

                    return true;
                });
            }
        }

        let particles;

        // v4.4: Hit-Stop System - Freezes game briefly on impacts for satisfying combat
        let hitStopUntil = 0;
        const HIT_STOP_LIGHT = 30;   // Normal hits (ms)
        const HIT_STOP_HEAVY = 80;   // Kills (ms)
        const HIT_STOP_BOSS = 150;   // Boss impacts (ms)

        function triggerHitStop(duration) {
            hitStopUntil = performance.now() + duration;
        }

        // v4.4: Enhanced Hit Flash
        function flashTargetHit(target, flashColor = 0xffffff) {
            const originalMaterials = [];
            target.traverse(child => {
                if (child.material && child.material.color) {
                    originalMaterials.push({
                        mesh: child,
                        color: child.material.color.getHex(),
                        emissive: child.material.emissive?.getHex() || 0,
                        emissiveIntensity: child.material.emissiveIntensity || 0
                    });
                    child.material.color.setHex(flashColor);
                    if (child.material.emissive) {
                        child.material.emissive.setHex(flashColor);
                        child.material.emissiveIntensity = 1;
                    }
                }
            });

            setTimeout(() => {
                originalMaterials.forEach(data => {
                    if (data.mesh.material) {
                        data.mesh.material.color.setHex(data.color);
                        if (data.mesh.material.emissive) {
                            data.mesh.material.emissive.setHex(data.emissive);
                            data.mesh.material.emissiveIntensity = data.emissiveIntensity;
                        }
                    }
                });
            }, 50);
        }

        // v4.4: Environmental Particle System
        class EnvironmentParticles {
            constructor() {
                this.particles = [];
                this.maxParticles = 60;
                this.currentBiome = null;
                this.biomeConfigs = {
                    Terra: { color: 0x88aa44, count: 20, speed: 1.5, type: 'leaves', gravity: 2 },
                    Desert: { color: 0xddcc99, count: 30, speed: 3, type: 'dust', gravity: 0.5 },
                    Ice: { color: 0xeeffff, count: 40, speed: 0.8, type: 'snow', gravity: 1 },
                    Volcanic: { color: 0xff4400, count: 25, speed: 4, type: 'embers', gravity: -3 },
                    Alien: { color: 0xff00ff, count: 20, speed: 1, type: 'spores', gravity: -0.5 }
                };
            }

            startBiome(biome) {
                if (this.currentBiome === biome) return;
                this.stop();
                this.currentBiome = biome;
            }

            stop() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                this.particles = [];
                this.currentBiome = null;
            }

            update(dt, playerPos) {
                if (!this.currentBiome) return;
                const config = this.biomeConfigs[this.currentBiome];
                if (!config) return;

                // Spawn new particles near player
                while (this.particles.length < config.count) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * 20;
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 4, 4),
                            new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.6 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * config.speed,
                            config.gravity > 0 ? -Math.abs(config.gravity) : config.gravity,
                            (Math.random() - 0.5) * config.speed
                        ),
                        life: 5 + Math.random() * 5
                    };
                    particle.mesh.position.set(
                        playerPos.x + Math.cos(angle) * dist,
                        playerPos.y + 5 + Math.random() * 10,
                        playerPos.z + Math.sin(angle) * dist
                    );
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.life -= dt;
                    if (p.life <= 0 || p.mesh.position.y < 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    // Sway for leaves/snow
                    if (config.type === 'leaves' || config.type === 'snow') {
                        p.mesh.position.x += Math.sin(performance.now() * 0.002 + p.life) * 0.02;
                    }

                    // Pulse for spores
                    if (config.type === 'spores') {
                        p.mesh.material.opacity = 0.3 + Math.sin(performance.now() * 0.005) * 0.3;
                    }

                    return true;
                });
            }
        }

        let envParticles;

        // v4.5: Player Dodge System
        const DODGE_CONFIG = {
            DISTANCE: 6,
            DURATION: 180,       // ms
            COOLDOWN: 600,       // ms
            IFRAMES: 150         // invincibility duration in ms
        };

        let dodgeState = {
            active: false,
            direction: new THREE.Vector3(),
            startTime: 0,
            cooldownEnd: 0,
            iframesEnd: 0
        };

        // v4.6: Parry/Counter System
        const PARRY_CONFIG = {
            WINDOW: 250,          // ms before attack lands to trigger parry
            STUN_DURATION: 1500,  // ms enemy is stunned
            CRIT_MULTIPLIER: 2.5, // damage multiplier during crit window
            CRIT_WINDOW: 2000     // ms player has to land crits
        };

        let parryState = {
            critWindowEnd: 0,
            lastParryTime: 0
        };

        // v4.8: Combo Attack System
        const COMBO_CONFIG = {
            WINDOW: 1200,           // ms to chain next hit
            MAX_HITS: 5,            // maximum combo length
            DAMAGE_MULT: [1.0, 1.15, 1.35, 1.6, 2.0],  // damage multiplier per hit
            FINISHER_BONUS: 1.5,    // extra multiplier on max combo hit
            BREAK_ON_DAMAGE: true   // combo breaks if player takes damage
        };

        let comboState = {
            count: 0,
            lastHitTime: 0,
            active: false
        };

        function updateCombo(hitTime) {
            const timeSinceLastHit = hitTime - comboState.lastHitTime;

            if (comboState.active && timeSinceLastHit <= COMBO_CONFIG.WINDOW) {
                // Continue combo
                comboState.count = Math.min(comboState.count + 1, COMBO_CONFIG.MAX_HITS - 1);
            } else {
                // Start new combo
                comboState.count = 0;
                comboState.active = true;
            }
            comboState.lastHitTime = hitTime;

            // v6.43: Update combo UI display
            updateComboUI();

            return comboState.count;
        }

        function getComboMultiplier() {
            if (!comboState.active) return 1.0;
            let mult = COMBO_CONFIG.DAMAGE_MULT[comboState.count] || COMBO_CONFIG.DAMAGE_MULT[COMBO_CONFIG.MAX_HITS - 1];
            // Finisher bonus at max combo
            if (comboState.count >= COMBO_CONFIG.MAX_HITS - 1) {
                mult *= COMBO_CONFIG.FINISHER_BONUS;
            }
            return mult;
        }

        // v6.43: Update combo counter UI display
        // v6.82: Cached DOM references for combo UI
        let comboDisplayTimeout = null;
        let _comboUICache = null;
        function getComboUICache() {
            if (!_comboUICache) {
                _comboUICache = {
                    counter: document.getElementById('combo-counter'),
                    count: document.getElementById('combo-count'),
                    mult: document.getElementById('combo-multiplier')
                };
            }
            return _comboUICache;
        }

        function updateComboUI() {
            const cache = getComboUICache();
            if (!cache.counter || !cache.count || !cache.mult) return;
            const counter = cache.counter;
            const countEl = cache.count;
            const multEl = cache.mult;

            if (comboState.active && comboState.count > 0) {
                counter.style.display = 'block';
                countEl.textContent = comboState.count + 1;

                // Color escalation based on combo
                const colors = ['#888', '#ff8800', '#ff4400', '#ff00ff', '#ffd700'];
                const colorIndex = Math.min(Math.floor(comboState.count / 2), colors.length - 1);
                countEl.style.color = colors[colorIndex];

                // Scale pop effect
                countEl.style.transform = 'scale(1.3)';
                setTimeout(() => countEl.style.transform = 'scale(1)', 100);

                // Show multiplier
                const mult = getComboMultiplier();
                multEl.textContent = `${mult.toFixed(1)}`;

                // Reset hide timer
                clearTimeout(comboDisplayTimeout);
                comboDisplayTimeout = setTimeout(() => {
                    counter.style.display = 'none';
                }, COMBO_CONFIG.WINDOW + 200);
            } else {
                counter.style.display = 'none';
            }
        }

        function breakCombo() {
            if (comboState.active) {
                // v6.35: Trigger combo crescendo resolution before breaking
                if (typeof comboCrescendo !== 'undefined') {
                    comboCrescendo.comboBreak(comboState.count);
                }
                // v6.35: Reset chromatic aura when combo breaks
                if (typeof comboChromaticSystem !== 'undefined') {
                    comboChromaticSystem.resetAura();
                }
                comboState.active = false;
                comboState.count = 0;
                updateComboUI(); // v6.43: Hide combo UI when broken
            }
        }

        // v6.12: Victory Streak System (Renamed from Kill Streak for family-friendly gameplay)
        const VICTORY_STREAK_CONFIG = {
            WINDOW: 5000,           // ms between victories to maintain streak
            XP_MULTIPLIERS: [1.0, 1.1, 1.2, 1.3, 1.5, 1.7, 2.0, 2.5, 3.0], // per streak level
            MILESTONES: {
                5: { name: 'Victory Spree!', color: '#ff8800' },
                10: { name: 'On Fire!', color: '#ff4400' },
                15: { name: 'Unstoppable!', color: '#ff0088' },
                20: { name: 'LEGENDARY!', color: '#ffd700' }
            }
        };
        // Backwards compatibility alias
        const KILL_STREAK_CONFIG = VICTORY_STREAK_CONFIG;

        let victoryStreakState = {
            count: 0,
            lastVictoryTime: 0,
            highestStreak: 0
        };
        // Backwards compatibility alias
        let killStreakState = victoryStreakState;

        function updateVictoryStreak() {
            const now = performance.now();
            const timeSinceLastVictory = now - victoryStreakState.lastVictoryTime;

            if (timeSinceLastVictory <= VICTORY_STREAK_CONFIG.WINDOW) {
                victoryStreakState.count++;
            } else {
                victoryStreakState.count = 1;
            }
            victoryStreakState.lastVictoryTime = now;

            // Track best streak
            if (victoryStreakState.count > victoryStreakState.highestStreak) {
                victoryStreakState.highestStreak = victoryStreakState.count;
                if (gameData.statistics) {
                    gameData.statistics.highestVictoryStreak = victoryStreakState.highestStreak;
                }
            }

            // Check for milestone announcement
            const milestone = VICTORY_STREAK_CONFIG.MILESTONES[victoryStreakState.count];
            if (milestone) {
                showNotification(milestone.name, 'buff');
                if (worldState.player) {
                    spawnFloater(worldState.player.position, milestone.name, milestone.color);
                }
                // Extra screen flash for milestones
                if (typeof flashVictoryCelebration === 'function') {
                    flashVictoryCelebration(victoryStreakState.count >= 15);
                }
                // v6.80: Victory confetti for milestone streaks (8-Agent Consensus)
                if (victoryStreakState.count >= 10) {
                    spawnVictoryConfetti(victoryStreakState.count >= 25 ? 150 : 80);
                }
                AudioSystem.levelUp();
            }

            return victoryStreakState.count;
        }
        // Backwards compatibility alias
        function updateKillStreak() { return updateVictoryStreak(); }

        function getVictoryStreakXPMultiplier() {
            const idx = Math.min(victoryStreakState.count, VICTORY_STREAK_CONFIG.XP_MULTIPLIERS.length - 1);
            return VICTORY_STREAK_CONFIG.XP_MULTIPLIERS[idx];
        }
        // Backwards compatibility alias
        function getKillStreakXPMultiplier() { return getVictoryStreakXPMultiplier(); }

        function resetVictoryStreak() {
            if (victoryStreakState.count >= 5) {
                showNotification(`Streak ended at ${victoryStreakState.count} victories!`, 'info');
            }
            victoryStreakState.count = 0;
        }
        // Backwards compatibility alias
        function resetKillStreak() { resetVictoryStreak(); }

        // v6.9: Combat Style Meter System (Agent consensus - Combat Depth & Physics)
        const STYLE_METER_CONFIG = {
            DECAY_RATE: 15,           // Points lost per second
            MAX_POINTS: 1000,
            GRADES: {
                D: { min: 0, color: '#888888', bonus: 1.0, name: 'D' },
                C: { min: 100, color: '#44ff44', bonus: 1.1, name: 'C' },
                B: { min: 250, color: '#4488ff', bonus: 1.2, name: 'B' },
                A: { min: 450, color: '#ffaa00', bonus: 1.35, name: 'A' },
                S: { min: 650, color: '#ff44ff', bonus: 1.5, name: 'S' },
                SS: { min: 800, color: '#ff0088', bonus: 1.75, name: 'SS' },
                SSS: { min: 950, color: '#ffd700', bonus: 2.0, name: 'SSS' }
            },
            ACTIONS: {
                hit: 15,
                comboHit: 25,
                parry: 100,
                dodge: 30,
                abilityHit: 50,
                defeat: 40,      // v6.12: Renamed from 'kill' for family-friendly
                kill: 40,        // Backwards compatibility
                finisher: 75,
                damageTaken: -50
            }
        };

        let styleMeterState = {
            points: 0,
            grade: 'D',
            lastUpdate: 0
        };

        function updateStyleMeter(action, multiplier = 1) {
            const pointChange = (STYLE_METER_CONFIG.ACTIONS[action] || 0) * multiplier;
            styleMeterState.points = Math.max(0, Math.min(
                STYLE_METER_CONFIG.MAX_POINTS,
                styleMeterState.points + pointChange
            ));
            updateStyleGrade();
            updateStyleMeterUI();
        }

        function updateStyleGrade() {
            let newGrade = 'D';
            for (const [grade, data] of Object.entries(STYLE_METER_CONFIG.GRADES)) {
                if (styleMeterState.points >= data.min) {
                    newGrade = grade;
                }
            }
            if (newGrade !== styleMeterState.grade) {
                styleMeterState.grade = newGrade;
                const gradeData = STYLE_METER_CONFIG.GRADES[newGrade];
                if (gradeData.min >= 650) { // S rank or higher
                    showNotification(`Style Rank: ${newGrade}!`, 'buff');
                    AudioSystem.levelUp();
                }
            }
        }

        function decayStyleMeter(dt) {
            if (styleMeterState.points > 0) {
                styleMeterState.points = Math.max(0,
                    styleMeterState.points - STYLE_METER_CONFIG.DECAY_RATE * dt);
                updateStyleGrade();
                updateStyleMeterUI();
            }
        }

        function getStyleXPMultiplier() {
            return STYLE_METER_CONFIG.GRADES[styleMeterState.grade]?.bonus || 1.0;
        }

        // v6.82: Cached DOM references for style meter (eliminates 3 getElementById calls per update)
        let _styleMeterCache = null;
        function getStyleMeterCache() {
            if (!_styleMeterCache) {
                _styleMeterCache = {
                    container: document.getElementById('style-meter'),
                    fill: document.getElementById('style-meter-fill'),
                    grade: document.getElementById('style-meter-grade')
                };
            }
            return _styleMeterCache;
        }

        function updateStyleMeterUI() {
            const cache = getStyleMeterCache();
            if (!cache.container) return;
            const gradeData = STYLE_METER_CONFIG.GRADES[styleMeterState.grade];
            if (cache.fill) {
                cache.fill.style.height = `${(styleMeterState.points / STYLE_METER_CONFIG.MAX_POINTS) * 100}%`;
                cache.fill.style.background = `linear-gradient(to top, ${gradeData.color}, ${gradeData.color}88)`;
            }
            if (cache.grade) {
                cache.grade.textContent = gradeData.name;
                cache.grade.style.color = gradeData.color;
                cache.grade.style.textShadow = `0 0 10px ${gradeData.color}`;
            }
        }

        // v6.9: Elemental Weakness/Resistance System (Agent consensus - Combat Depth)
        const ELEMENTAL_AFFINITIES = {
            Slime: { weak: ['fire'], resist: ['ice'], immune: [] },
            Crawler: { weak: ['ice'], resist: ['void'], immune: [] },
            Spitter: { weak: ['void'], resist: ['cosmic'], immune: ['fire'] },
            Brute: { weak: ['cosmic'], resist: ['fire', 'ice'], immune: [] },
            Warper: { weak: ['fire', 'ice'], resist: [], immune: ['void'] },
            Scorpion: { weak: ['ice'], resist: ['fire'], immune: [] },
            VoidSpawn: { weak: ['cosmic', 'fire'], resist: ['void'], immune: [] },
            IceWisp: { weak: ['fire'], resist: [], immune: ['ice'] },
            MagmaCore: { weak: ['ice'], resist: [], immune: ['fire'] },
            CrystalGolem: { weak: ['void'], resist: ['ice', 'cosmic'], immune: [] },
            ShadowWraith: { weak: ['cosmic'], resist: ['void'], immune: [] },
            Hypnotist: { weak: ['fire'], resist: ['cosmic'], immune: [] }
        };

        const ELEMENTAL_MULTIPLIERS = {
            weak: 2.0,
            resist: 0.5,
            immune: 0
        };

        function getElementalMultiplier(mobName, weaponElement) {
            if (!weaponElement || !ELEMENTAL_AFFINITIES[mobName]) {
                return { multiplier: 1.0, type: 'normal' };
            }
            const affinities = ELEMENTAL_AFFINITIES[mobName];
            if (affinities.immune.includes(weaponElement)) {
                return { multiplier: ELEMENTAL_MULTIPLIERS.immune, type: 'immune' };
            }
            if (affinities.weak.includes(weaponElement)) {
                return { multiplier: ELEMENTAL_MULTIPLIERS.weak, type: 'weak' };
            }
            if (affinities.resist.includes(weaponElement)) {
                return { multiplier: ELEMENTAL_MULTIPLIERS.resist, type: 'resist' };
            }
            return { multiplier: 1.0, type: 'normal' };
        }

        // v6.9: Knockback with Momentum System (Agent consensus - Physics Fun)
        const KNOCKBACK_CONFIG = {
            BASE_FORCE: 3,
            MASS_REDUCTION: 0.5,     // Elites resist knockback
            FRICTION: 0.92,
            BOUNCE_DAMPEN: 0.3,
            MIN_VELOCITY: 0.01
        };

        function applyKnockback(mob, direction, force) {
            if (!mob || !mob.userData) return;
            const data = mob.userData;
            const mass = data.isElite ? 1 + KNOCKBACK_CONFIG.MASS_REDUCTION : 1;
            const knockbackForce = force / mass;

            const knockDir = direction.clone().normalize();
            knockDir.y = 0.2; // Slight upward arc

            if (!data.knockbackVelocity) {
                data.knockbackVelocity = new THREE.Vector3(0, 0, 0);
            }
            data.knockbackVelocity.add(knockDir.multiplyScalar(knockbackForce));
        }

        function updateMobKnockback(mob, dt) {
            const data = mob.userData;
            if (!data.knockbackVelocity) return;

            if (data.knockbackVelocity.lengthSq() > KNOCKBACK_CONFIG.MIN_VELOCITY) {
                mob.position.add(data.knockbackVelocity.clone().multiplyScalar(dt));
                data.knockbackVelocity.multiplyScalar(KNOCKBACK_CONFIG.FRICTION);

                // Ground collision
                if (mob.position.y < 0.8) {
                    mob.position.y = 0.8;
                    data.knockbackVelocity.y *= -KNOCKBACK_CONFIG.BOUNCE_DAMPEN;
                }
            }
        }

        // v6.9: Lore Fragment Collection System (Agent consensus - Secrets & Meta)
        const LORE_FRAGMENTS = {
            origin_exodus: {
                title: 'The First Exodus',
                text: 'Long ago, humanity fled a dying Earth aboard the Leviathan ships...',
                icon: '', rarity: 0.05, trigger: 'explore'
            },
            origin_gate: {
                title: 'The Omniverse Gate',
                text: 'Scientists discovered a rift that led to infinite parallel dimensions...',
                icon: '', rarity: 0.03, trigger: 'boss_defeat'
            },
            void_warning: {
                title: 'Whispers of the Void',
                text: 'The void creatures are not invaders. They are refugees, fleeing something worse...',
                icon: '', rarity: 0.04, trigger: 'explore'
            },
            ancient_tech: {
                title: 'Forgotten Technology',
                text: 'The ancients built machines that could reshape reality itself...',
                icon: '', rarity: 0.03, trigger: 'craft'
            },
            cosmic_truth: {
                title: 'The Cosmic Truth',
                text: 'Every universe in the omniverse is connected by threads of pure energy...',
                icon: '', rarity: 0.02, trigger: 'explore'
            },
            leviathan_secret: {
                title: 'The Leviathan Protocol',
                text: 'The ships were never meant for colonization. They were weapons...',
                icon: '', rarity: 0.01, trigger: 'boss_defeat'
            }
        };

        function tryDiscoverLore(triggerType) {
            if (!gameData.loreFragments) gameData.loreFragments = {};

            const eligible = Object.entries(LORE_FRAGMENTS).filter(([id, lore]) => {
                if (gameData.loreFragments[id]) return false;
                if (lore.trigger !== triggerType) return false;
                return Math.random() < lore.rarity;
            });

            if (eligible.length > 0) {
                const [id, lore] = eligible[Math.floor(Math.random() * eligible.length)];
                discoverLoreFragment(id);
            }
        }

        function discoverLoreFragment(id) {
            const lore = LORE_FRAGMENTS[id];
            if (!lore || gameData.loreFragments[id]) return;

            gameData.loreFragments[id] = { discoveredAt: Date.now() };
            // v6.35: Chronicle Engine - capture lore discovery
            if (typeof captureChronicleEvent === 'function') {
                captureChronicleEvent('lore_found', { loreTitle: lore.title, loreIcon: lore.icon });
            }
            showNotification(`${lore.icon} LORE DISCOVERED: ${lore.title}`, 'legendary');
            AudioSystem.levelUp();

            // Show lore popup
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(40, 20, 60, 0.95), rgba(20, 10, 40, 0.95));
                border: 2px solid #8844ff; border-radius: 15px; padding: 30px;
                max-width: 400px; text-align: center; z-index: 2000;
                box-shadow: 0 0 30px rgba(136, 68, 255, 0.5);
            `;
            popup.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 15px;">${lore.icon}</div>
                <div style="color: #ffd700; font-size: 20px; font-weight: bold; margin-bottom: 10px;">${lore.title}</div>
                <div style="color: #ccc; font-size: 14px; line-height: 1.6;">${lore.text}</div>
                <button onclick="this.parentElement.remove()" style="margin-top: 20px; padding: 10px 30px; background: #8844ff; border: none; color: white; border-radius: 5px; cursor: pointer;">Continue</button>
            `;
            document.body.appendChild(popup);
            saveGameData();
        }

        function getLoreCollectionProgress() {
            const total = Object.keys(LORE_FRAGMENTS).length;
            const found = Object.keys(gameData.loreFragments || {}).length;
            return { found, total, percent: Math.round((found / total) * 100) };
        }

        // v6.12: Bestiary Victory Milestones (renamed from Kill for family-friendly)
        const BESTIARY_MILESTONES = {
            Slime: { kills: [10, 50, 100], rewards: ['title:Slime Champion', 'bonus:slimeDamage:0.1', 'item:Slime Crown'] },
            Crawler: { kills: [10, 50, 100], rewards: ['title:Bug Expert', 'bonus:crawlerDamage:0.1', 'item:Crawler Fang'] },
            Scorpion: { kills: [10, 50, 100], rewards: ['title:Desert Champion', 'bonus:scorpionDamage:0.1', 'item:Scorpion Tail'] },
            VoidSpawn: { kills: [10, 50, 100], rewards: ['title:Void Walker', 'bonus:voidDamage:0.15', 'item:Void Heart'] },
            IceWisp: { kills: [10, 50, 100], rewards: ['title:Frost Champion', 'bonus:iceDamage:0.1', 'item:Frozen Soul'] },
            MagmaCore: { kills: [10, 50, 100], rewards: ['title:Flame Master', 'bonus:fireDamage:0.1', 'item:Magma Core'] },
            CrystalGolem: { kills: [10, 50, 100], rewards: ['title:Golem Champion', 'bonus:golemDamage:0.15', 'item:Crystal Heart'] },
            ShadowWraith: { kills: [10, 50, 100], rewards: ['title:Shadow Expert', 'bonus:shadowDamage:0.15', 'item:Wraith Essence'] }
        };

        function checkBestiaryMilestone(mobName) {
            if (!BESTIARY_MILESTONES[mobName]) return;
            if (!gameData.bestiaryProgress) gameData.bestiaryProgress = {};
            if (!gameData.bestiaryProgress[mobName]) {
                gameData.bestiaryProgress[mobName] = { kills: 0, milestonesReached: [] };
            }

            const progress = gameData.bestiaryProgress[mobName];
            progress.kills++;

            const milestones = BESTIARY_MILESTONES[mobName];
            milestones.kills.forEach((threshold, idx) => {
                if (progress.kills >= threshold && !progress.milestonesReached.includes(idx)) {
                    progress.milestonesReached.push(idx);
                    grantBestiaryReward(mobName, milestones.rewards[idx], threshold);
                }
            });
        }

        function grantBestiaryReward(mobName, reward, killCount) {
            const [type, ...args] = reward.split(':');

            switch (type) {
                case 'title':
                    showNotification(` Title Earned: ${args[0]}!`, 'legendary');
                    if (!gameData.titles) gameData.titles = [];
                    gameData.titles.push(args[0]);
                    break;
                case 'bonus':
                    if (!gameData.bestiaryBonuses) gameData.bestiaryBonuses = {};
                    gameData.bestiaryBonuses[args[0]] = parseFloat(args[1]);
                    showNotification(` +${parseFloat(args[1]) * 100}% damage vs ${mobName}!`, 'buff');
                    break;
                case 'item':
                    addItem(args[0]);
                    showNotification(` Bestiary Reward: ${args[0]}!`, 'success');
                    break;
            }

            AudioSystem.levelUp();
            saveGameData();
        }

        function getBestiaryDamageBonus(mobName) {
            if (!gameData.bestiaryBonuses || !mobName) return 0;
            const bonusKey = `${mobName.toLowerCase()}Damage`;
            return gameData.bestiaryBonuses[bonusKey] || 0;
        }

        // ============================================
        // v6.13: WAVE MOMENTUM SYSTEM (DOTA-style creep pushing)
        // ============================================
        // Players influence territorial control by defeating enemies and helping allies
        // Momentum shifts determine world bonuses and spawn rates

        const WAVE_CONFIG = {
            WAVE_INTERVAL: 30000,       // New wave every 30 seconds
            CREEPS_PER_WAVE: 3,         // Creeps spawned per side per wave
            MOMENTUM_DECAY: 0.5,        // Momentum decays toward 50 per second
            PLAYER_INFLUENCE: 5,        // Momentum gained per enemy defeated near front
            CLASH_DAMAGE: 5,            // Damage creeps deal to each other per tick
            CLASH_INTERVAL: 1500,       // Creeps attack every 1.5 seconds
            FRONT_LINE_SPEED: 0.3,      // How fast front line moves based on momentum
            MOMENTUM_XP_BONUS: 0.5,     // +50% XP when momentum > 70
            MOMENTUM_RESOURCE_BONUS: 0.3, // +30% resources when momentum > 60

            // Faction definitions
            FACTIONS: {
                explorer: {
                    name: 'Explorer Drones',
                    color: 0x00ff88,
                    icon: '',
                    baseHp: 30,
                    damage: 8
                },
                horde: {
                    name: 'Void Horde',
                    color: 0xff4488,
                    icon: '',
                    baseHp: 35,
                    damage: 10
                }
            }
        };

        // Wave system state
        let waveState = {
            enabled: false,
            momentum: 50,               // 0-100: 0=horde winning, 100=explorers winning
            frontLineZ: 0,              // Z position of the "front line"
            explorerCreeps: [],         // Active friendly creeps
            hordeCreeps: [],            // Active enemy creeps
            lastWaveTime: 0,
            waveNumber: 0,
            totalExplorerDefeats: 0,
            totalHordeDefeats: 0,
            playerContribution: 0,      // Track player's influence
            lastClashTime: 0
        };

        // Initialize wave system when entering world
        function initWaveSystem() {
            waveState = {
                enabled: true,
                momentum: 50,
                frontLineZ: 0,
                explorerCreeps: [],
                hordeCreeps: [],
                lastWaveTime: performance.now(),
                waveNumber: 0,
                totalExplorerDefeats: 0,
                totalHordeDefeats: 0,
                playerContribution: 0,
                lastClashTime: 0
            };
            updateWaveMomentumUI();
        }

        // Create a creep for a faction
        function createWaveCreep(faction, waveNum) {
            const factionData = WAVE_CONFIG.FACTIONS[faction];
            const isExplorer = faction === 'explorer';

            // Scale stats with wave number
            const scaleFactor = 1 + (waveNum * 0.1);
            const hp = Math.floor(factionData.baseHp * scaleFactor);
            const damage = Math.floor(factionData.damage * scaleFactor);

            // Create mesh
            const geo = new THREE.SphereGeometry(0.5, 12, 12);
            const mat = new THREE.MeshStandardMaterial({
                color: factionData.color,
                emissive: factionData.color,
                emissiveIntensity: 0.3,
                roughness: 0.4
            });
            const mesh = new THREE.Mesh(geo, mat);

            // Position: explorers spawn from player side, horde from opposite
            const spawnZ = isExplorer ? -30 : 30;
            const spawnX = (Math.random() - 0.5) * 20;
            mesh.position.set(spawnX, 1.2, spawnZ);
            mesh.castShadow = true;

            // Add faction indicator ring
            const ringGeo = new THREE.RingGeometry(0.6, 0.8, 16);
            const ringMat = new THREE.MeshBasicMaterial({
                color: factionData.color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = -0.3;
            mesh.add(ring);

            const creep = {
                mesh: mesh,
                faction: faction,
                hp: hp,
                maxHp: hp,
                damage: damage,
                isAlive: true,
                target: null,
                waveNum: waveNum
            };

            if (scene) scene.add(mesh);
            return creep;
        }

        // Spawn a wave of creeps for both factions
        function spawnWave() {
            if (!waveState.enabled || mode !== 'world') return;

            waveState.waveNumber++;
            const waveNum = waveState.waveNumber;

            // Spawn explorer drones (friendly)
            for (let i = 0; i < WAVE_CONFIG.CREEPS_PER_WAVE; i++) {
                const creep = createWaveCreep('explorer', waveNum);
                waveState.explorerCreeps.push(creep);
            }

            // Spawn horde creeps (enemy)
            for (let i = 0; i < WAVE_CONFIG.CREEPS_PER_WAVE; i++) {
                const creep = createWaveCreep('horde', waveNum);
                waveState.hordeCreeps.push(creep);
            }

            // Announce wave
            if (waveNum % 5 === 0) {
                showNotification(` Wave ${waveNum} incoming!`, 'info');
            }

            waveState.lastWaveTime = performance.now();
        }

        // Update wave system each frame
        function updateWaveSystem(dt) {
            if (!waveState.enabled || mode !== 'world') return;

            const now = performance.now();

            // Spawn new waves periodically
            if (now - waveState.lastWaveTime > WAVE_CONFIG.WAVE_INTERVAL) {
                spawnWave();
            }

            // Move creeps toward front line
            const frontZ = waveState.frontLineZ;

            // Explorer creeps move toward positive Z (toward horde)
            for (const creep of waveState.explorerCreeps) {
                if (!creep.isAlive) continue;
                if (creep.mesh.position.z < frontZ + 5) {
                    creep.mesh.position.z += dt * 2;
                }
                // Rotate ring for visual effect
                if (creep.mesh.children[0]) {
                    creep.mesh.children[0].rotation.z += dt * 2;
                }
            }

            // Horde creeps move toward negative Z (toward explorers)
            for (const creep of waveState.hordeCreeps) {
                if (!creep.isAlive) continue;
                if (creep.mesh.position.z > frontZ - 5) {
                    creep.mesh.position.z -= dt * 2;
                }
                if (creep.mesh.children[0]) {
                    creep.mesh.children[0].rotation.z -= dt * 2;
                }
            }

            // Creep combat (clash at front line)
            if (now - waveState.lastClashTime > WAVE_CONFIG.CLASH_INTERVAL) {
                processCreepClash();
                waveState.lastClashTime = now;
            }

            // Update front line based on momentum
            const momentumForce = (waveState.momentum - 50) / 50; // -1 to 1
            waveState.frontLineZ += momentumForce * WAVE_CONFIG.FRONT_LINE_SPEED * dt;
            waveState.frontLineZ = Math.max(-25, Math.min(25, waveState.frontLineZ));

            // Decay momentum toward 50 (balance)
            if (waveState.momentum > 50) {
                waveState.momentum = Math.max(50, waveState.momentum - WAVE_CONFIG.MOMENTUM_DECAY * dt);
            } else if (waveState.momentum < 50) {
                waveState.momentum = Math.min(50, waveState.momentum + WAVE_CONFIG.MOMENTUM_DECAY * dt);
            }

            // Clean up defeated creeps
            cleanupDefeatedCreeps();

            // Update UI
            updateWaveMomentumUI();
        }

        // Process combat between creeps at front line
        // v6.82: Optimized creep clash with pre-filtered arrays and squared distance
        function processCreepClash() {
            const clashRange = 8;
            const clashRangeSq = clashRange * clashRange;  // Avoid sqrt in distance checks

            // Pre-filter alive creeps once (reduces inner loop iterations)
            const aliveExplorers = waveState.explorerCreeps.filter(c => c.isAlive);
            const aliveHorde = waveState.hordeCreeps.filter(c => c.isAlive);

            // Early exit if no combat possible
            if (aliveExplorers.length === 0 || aliveHorde.length === 0) return;

            // Each explorer attacks nearest horde creep in range
            for (const explorer of aliveExplorers) {
                let nearestHorde = null;
                let nearestDistSq = Infinity;
                const ePos = explorer.mesh.position;

                for (const horde of aliveHorde) {
                    if (!horde.isAlive) continue;  // May have died this frame
                    const hPos = horde.mesh.position;
                    // Use squared distance to avoid expensive sqrt
                    const dx = ePos.x - hPos.x;
                    const dz = ePos.z - hPos.z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < clashRangeSq && distSq < nearestDistSq) {
                        nearestDistSq = distSq;
                        nearestHorde = horde;
                    }
                }

                if (nearestHorde) {
                    nearestHorde.hp -= explorer.damage;

                    // Visual feedback
                    if (particles) {
                        particles.emit(nearestHorde.mesh.position, 2, 0x00ff88, { spread: 0.5, lifetime: 300 });
                    }

                    if (nearestHorde.hp <= 0) {
                        nearestHorde.isAlive = false;
                        waveState.totalHordeDefeats++;
                        waveState.momentum = Math.min(100, waveState.momentum + 2);
                    }
                }
            }

            // Each horde attacks nearest explorer in range
            for (const horde of aliveHorde) {
                if (!horde.isAlive) continue;  // May have died this frame

                let nearestExplorer = null;
                let nearestDistSq = Infinity;
                const hPos = horde.mesh.position;

                for (const explorer of aliveExplorers) {
                    if (!explorer.isAlive) continue;  // May have died this frame
                    const ePos = explorer.mesh.position;
                    // Use squared distance to avoid expensive sqrt
                    const dx = hPos.x - ePos.x;
                    const dz = hPos.z - ePos.z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < clashRangeSq && distSq < nearestDistSq) {
                        nearestDistSq = distSq;
                        nearestExplorer = explorer;
                    }
                }

                if (nearestExplorer) {
                    nearestExplorer.hp -= horde.damage;

                    // Visual feedback
                    if (particles) {
                        particles.emit(nearestExplorer.mesh.position, 2, 0xff4488, { spread: 0.5, lifetime: 300 });
                    }

                    if (nearestExplorer.hp <= 0) {
                        nearestExplorer.isAlive = false;
                        waveState.totalExplorerDefeats++;
                        waveState.momentum = Math.max(0, waveState.momentum - 2);
                    }
                }
            }
        }

        // Clean up defeated creeps
        function cleanupDefeatedCreeps() {
            // v6.32: Helper to properly dispose mesh and its children
            function disposeMesh(mesh) {
                if (!mesh) return;
                scene.remove(mesh);
                mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }

            // Remove defeated explorer creeps
            waveState.explorerCreeps = waveState.explorerCreeps.filter(creep => {
                if (!creep.isAlive && creep.mesh) {
                    disposeMesh(creep.mesh);
                    return false;
                }
                return true;
            });

            // Remove defeated horde creeps
            waveState.hordeCreeps = waveState.hordeCreeps.filter(creep => {
                if (!creep.isAlive && creep.mesh) {
                    disposeMesh(creep.mesh);
                    return false;
                }
                return true;
            });
        }

        // Player defeats a horde creep - gains momentum
        function onPlayerDefeatHordeCreep(creep) {
            if (!waveState.enabled) return;

            waveState.momentum = Math.min(100, waveState.momentum + WAVE_CONFIG.PLAYER_INFLUENCE);
            waveState.playerContribution++;
            waveState.totalHordeDefeats++;

            // Bonus XP for wave contribution
            const bonusXP = 15 + (waveState.waveNumber * 2);
            if (typeof addXp === 'function') {
                addXp('combat', bonusXP);
            }

            spawnFloater(creep.mesh.position, ` +${bonusXP} WAVE XP`, '#00ff88');

            // Milestone rewards
            if (waveState.playerContribution % 10 === 0) {
                showNotification(` Wave Hero! ${waveState.playerContribution} enemies pushed back!`, 'success');
            }
        }

        // Get momentum bonuses for player
        function getWaveMomentumBonuses() {
            if (!waveState.enabled) return { xp: 1, resources: 1 };

            const momentum = waveState.momentum;
            let xpMult = 1;
            let resourceMult = 1;

            if (momentum >= 70) {
                xpMult = 1 + WAVE_CONFIG.MOMENTUM_XP_BONUS;
            }
            if (momentum >= 60) {
                resourceMult = 1 + WAVE_CONFIG.MOMENTUM_RESOURCE_BONUS;
            }

            return { xp: xpMult, resources: resourceMult };
        }

        // v6.13: Wave momentum UI - HIDDEN for implicit discovery
        // Players discover the wave/momentum system through exploration
        // The creeps fighting in the world ARE the visual feedback
        function updateWaveMomentumUI() {
            // UI intentionally hidden - system is discoverable through gameplay
            // The creeps fighting, visual effects, and momentum bonuses are the feedback
            // Players who observe and engage learn the system organically
        }

        // Check if a mob is a horde creep (for player combat integration)
        function isHordeCreep(target) {
            if (!waveState.enabled) return false;
            for (const creep of waveState.hordeCreeps) {
                if (creep.mesh === target && creep.isAlive) {
                    return creep;
                }
            }
            return null;
        }

        // Cleanup wave system when leaving world
        function cleanupWaveSystem() {
            // Remove all creep meshes
            for (const creep of waveState.explorerCreeps) {
                if (creep.mesh && scene) scene.remove(creep.mesh);
            }
            for (const creep of waveState.hordeCreeps) {
                if (creep.mesh && scene) scene.remove(creep.mesh);
            }

            waveState.enabled = false;
            waveState.explorerCreeps = [];
            waveState.hordeCreeps = [];
        }

        // ============================================
        // END WAVE MOMENTUM SYSTEM
        // ============================================

        // v4.8: Combat Abilities System
        const COMBAT_ABILITIES = {
            powerStrike: {
                name: 'Power Strike',
                key: 'Q',
                icon: '',
                cooldown: 8000,       // 8 seconds
                unlockLevel: 3,       // Combat level 3
                damageMultiplier: 3,
                description: '3x damage attack'
            },
            whirlwind: {
                name: 'Whirlwind',
                key: 'E',
                icon: '',
                cooldown: 12000,      // 12 seconds
                unlockLevel: 5,       // Combat level 5
                radius: 8,
                damageMultiplier: 1.5,
                description: 'AoE damage to all nearby enemies'
            },
            warcry: {
                name: 'War Cry',
                key: 'R',
                icon: '',
                cooldown: 20000,      // 20 seconds
                unlockLevel: 7,       // Combat level 7
                duration: 5000,       // 5 second buff
                damageBoost: 1.5,
                description: '+50% damage for 5 seconds'
            },
            // v4.9: Tier 2 Abilities
            heal: {
                name: 'Battle Heal',
                key: 'T',
                icon: '',
                cooldown: 15000,      // 15 seconds
                unlockLevel: 9,       // Combat level 9
                healAmount: 0.3,      // 30% of max HP
                description: 'Restore 30% of max HP'
            },
            dash: {
                name: 'Combat Dash',
                key: 'F',
                icon: '',
                cooldown: 6000,       // 6 seconds
                unlockLevel: 10,      // Combat level 10
                distance: 8,
                damageMultiplier: 1.2,
                description: 'Dash forward, damaging enemies in path'
            },
            shieldWall: {
                name: 'Shield Wall',
                key: 'Z',
                icon: '',
                cooldown: 25000,      // 25 seconds
                unlockLevel: 12,      // Combat level 12
                duration: 4000,       // 4 seconds
                damageReduction: 0.7, // 70% damage reduction
                description: '70% damage reduction for 4 seconds'
            },
            execute: {
                name: 'Execute',
                key: 'X',
                icon: '',
                cooldown: 10000,      // 10 seconds
                unlockLevel: 15,      // Combat level 15
                threshold: 0.3,       // Below 30% HP
                damageMultiplier: 5,  // 5x damage to low HP targets
                description: '5x damage to enemies below 30% HP'
            },
            berserk: {
                name: 'Berserker Rage',
                key: 'C',
                icon: '',
                cooldown: 45000,      // 45 seconds (ultimate)
                unlockLevel: 20,      // Combat level 20
                duration: 8000,       // 8 seconds
                damageBoost: 2.0,     // 100% more damage
                attackSpeedBoost: 1.5,// 50% faster attacks
                description: 'ULTIMATE: +100% damage, +50% attack speed for 8s'
            },
            // v6.42: CHRONO-ECHO COMBAT (Time + Sensory + Combat)
            // Past actions replay as ghost clones that repeat your attacks
            chronoEcho: {
                name: 'Chrono-Echo',
                key: 'B',
                icon: '',
                cooldown: 30000,      // 30 seconds
                unlockLevel: 18,      // Combat level 18
                duration: 6000,       // 6 seconds of ghost echoes
                echoCount: 5,         // Number of ghost clones
                damageMultiplier: 0.6,// Each ghost deals 60% damage
                description: 'Summon time-echoes that replay your past attacks'
            }
        };

        let abilityState = {
            powerStrike: { lastUsed: 0 },
            whirlwind: { lastUsed: 0 },
            warcry: { lastUsed: 0, activeUntil: 0 },
            // v4.9: Tier 2 ability states
            heal: { lastUsed: 0 },
            dash: { lastUsed: 0 },
            shieldWall: { lastUsed: 0, activeUntil: 0 },
            execute: { lastUsed: 0 },
            berserk: { lastUsed: 0, activeUntil: 0 },
            // v6.42: Chrono-Echo state
            chronoEcho: { lastUsed: 0, activeUntil: 0 }
        };

        // ============================================
        // v6.42: CHRONO-ECHO COMBAT SYSTEM
        // Records player combat actions and replays them as ghost clones
        // ============================================
        const chronoEchoSystem = {
            actionHistory: [],
            maxHistorySize: 20,
            recordingEnabled: true,
            activeGhosts: [],

            recordAction(actionType, position, rotation, targetPos, damage) {
                if (!this.recordingEnabled || mode !== 'world') return;
                this.actionHistory.push({
                    type: actionType, position: position.clone(), rotation: rotation,
                    targetPos: targetPos ? targetPos.clone() : null, damage: damage,
                    timestamp: performance.now()
                });
                if (this.actionHistory.length > this.maxHistorySize) this.actionHistory.shift();
            },

            createGhostMesh(position, rotation, delay, actionData) {
                if (!scene || !worldState.player) return null;
                const ghostGroup = new THREE.Group();
                const ghostMat = new THREE.MeshStandardMaterial({
                    color: 0x00ffff, transparent: true, opacity: 0.4,
                    emissive: 0x00aaff, emissiveIntensity: 0.8
                });
                const ghostBody = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.6), ghostMat);
                ghostBody.position.y = 1;
                ghostGroup.add(ghostBody);
                const headMat = ghostMat.clone();
                headMat.emissive = new THREE.Color(0x8844ff);
                const ghostHead = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8), headMat);
                ghostHead.position.y = 1.9;
                ghostGroup.add(ghostHead);
                const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.7, 6);
                [-1, 1].forEach(side => {
                    const arm = new THREE.Mesh(armGeo, ghostMat.clone());
                    arm.position.set(side * 0.6, 1.3, 0);
                    arm.rotation.z = -side * Math.PI / 4;
                    ghostGroup.add(arm);
                });
                const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 6);
                [-0.2, 0.2].forEach(x => {
                    const leg = new THREE.Mesh(legGeo, ghostMat.clone());
                    leg.position.set(x, 0.3, 0);
                    ghostGroup.add(leg);
                });
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(0.8, 1.0, 16),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
                );
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.1;
                ghostGroup.add(ring);
                ghostGroup.position.copy(position);
                ghostGroup.rotation.y = rotation;
                ghostGroup.userData = {
                    isChronoGhost: true, spawnTime: performance.now(), delay,
                    actionData, hasAttacked: false, lifetime: 3000 + delay, phase: 0
                };
                scene.add(ghostGroup);
                this.activeGhosts.push(ghostGroup);
                return ghostGroup;
            },

            spawnGhosts(count, baseDamage) {
                if (!worldState.player || this.actionHistory.length === 0) return;
                const p = worldState.player;
                const actions = this.actionHistory.slice(-count);
                actions.forEach((action, i) => {
                    const delay = i * 400;
                    const angle = (i / count) * Math.PI * 2;
                    const spawnPos = new THREE.Vector3(
                        p.position.x + Math.sin(angle) * 2, p.position.y, p.position.z + Math.cos(angle) * 2
                    );
                    setTimeout(() => {
                        const ghost = this.createGhostMesh(spawnPos, p.rotation.y + angle, delay, { ...action, baseDamage });
                        if (ghost) {
                            spawnFloater(spawnPos, '', '#00ffff');
                            if (particles) particles.emit(spawnPos, 15, 0x00ffff, { spread: 2, lifetime: 500 });
                            setTimeout(() => this.executeGhostAttack(ghost), 500 + delay);
                        }
                    }, delay);
                });
                if (AudioSystem?.penta) {
                    AudioSystem.playGentle(AudioSystem.penta.G4, 0.3, 0.2);
                    setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.C5, 0.25, 0.15), 100);
                    setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.E5, 0.2, 0.1), 200);
                }
            },

            executeGhostAttack(ghost) {
                if (!ghost?.userData || ghost.userData.hasAttacked) return;
                if (!worldState.mobs?.length) return;
                ghost.userData.hasAttacked = true;
                const { actionData } = ghost.userData;
                const ability = COMBAT_ABILITIES.chronoEcho;
                let nearestMob = null, nearestDist = 8;
                worldState.mobs.forEach(mob => {
                    const mobPos = mob.mesh?.position || mob.position;
                    if (!mobPos) return;
                    const dist = ghost.position.distanceTo(mobPos);
                    if (dist < nearestDist && mob.userData.hp > 0) { nearestDist = dist; nearestMob = mob; }
                });
                if (nearestMob) {
                    const damage = Math.floor(actionData.baseDamage * ability.damageMultiplier);
                    nearestMob.userData.hp -= damage;
                    const mobPos = nearestMob.mesh?.position || nearestMob.position;
                    spawnFloater(mobPos, ` -${damage}`, '#00ffff');
                    this.animateGhostAttack(ghost, ghost.position.clone(), mobPos.clone().sub(ghost.position).normalize());
                    if (particles) particles.emit(nearestMob.position, 10, 0x00ffff, { spread: 2, lifetime: 400 });
                    if (nearestMob.userData.hp <= 0) {
                        setTimeout(() => { if (nearestMob.userData.hp <= 0) performAction?.(nearestMob); }, 100);
                    }
                }
                ghost.userData.fadeStart = performance.now();
            },

            animateGhostAttack(ghost, startPos, dir) {
                const startTime = performance.now();
                const animate = () => {
                    if (!ghost.parent) return;
                    const t = Math.min((performance.now() - startTime) / 200, 1);
                    const phase = t < 0.5 ? (1 - Math.pow(1 - t, 3)) * 2 : 2 - (1 - Math.pow(1 - t, 3)) * 2;
                    ghost.position.copy(startPos).addScaledVector(dir, phase * 1.5);
                    ghost.traverse(c => { if (c.material?.emissiveIntensity !== undefined) c.material.emissiveIntensity = 0.8 + phase * 1.5; });
                    if (t < 1) requestAnimationFrame(animate);
                };
                animate();
            },

            update(dt) {
                const now = performance.now();
                this.activeGhosts = this.activeGhosts.filter(ghost => {
                    if (!ghost.parent) return false;
                    ghost.userData.phase += dt * 3;
                    ghost.position.y = (ghost.userData.actionData?.position?.y || 0) + Math.sin(ghost.userData.phase) * 0.15;
                    ghost.children.find(c => c.geometry?.type === 'RingGeometry')?.rotation && (ghost.children.find(c => c.geometry?.type === 'RingGeometry').rotation.z += dt * 2);
                    const fade = ghost.userData.hasAttacked ? Math.max(0, 1 - (now - ghost.userData.fadeStart) / 1000) : 1;
                    ghost.traverse(c => { if (c.material?.opacity !== undefined) c.material.opacity = (0.3 + Math.sin(ghost.userData.phase * 2) * 0.1) * fade; });
                    if (now - ghost.userData.spawnTime > ghost.userData.lifetime || fade <= 0) {
                        if (particles) particles.emit(ghost.position, 8, 0x00ffff, { spread: 1.5, lifetime: 300 });
                        scene.remove(ghost);
                        return false;
                    }
                    return true;
                });
            },
            clearGhosts() { this.activeGhosts.forEach(g => g.parent && scene.remove(g)); this.activeGhosts = []; },
            clearHistory() { this.actionHistory = []; }
        };

        function isAbilityUnlocked(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return gameData.skills.combat.level >= ability.unlockLevel;
        }

        function isAbilityReady(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return performance.now() - abilityState[abilityKey].lastUsed >= ability.cooldown;
        }

        function getAbilityCooldownRemaining(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            const elapsed = performance.now() - abilityState[abilityKey].lastUsed;
            return Math.max(0, ability.cooldown - elapsed);
        }

        function useAbility(abilityKey) {
            if (!isAbilityUnlocked(abilityKey)) {
                showNotification(`${COMBAT_ABILITIES[abilityKey].name} unlocks at Combat Lv ${COMBAT_ABILITIES[abilityKey].unlockLevel}`, 'warning');
                return false;
            }
            if (!isAbilityReady(abilityKey)) {
                return false;
            }
            if (mode !== 'world' || !worldState.player) return false;
            // v6.6: Null safety check for mobs array (Agent 2 bug fix)
            if (!worldState.mobs) worldState.mobs = [];

            const ability = COMBAT_ABILITIES[abilityKey];
            const p = worldState.player;
            const now = performance.now();

            abilityState[abilityKey].lastUsed = now;
            // v5.0: Track ability usage for quests
            trackAbilityUsage();

            // v6.80: Ability activation flash (8-Agent Consensus)
            const elementMap = { powerStrike: 'fire', whirlwind: 'ice', warcry: 'fire', heal: 'holy', dash: 'lightning', shieldWall: 'ice', execute: 'dark', berserk: 'fire', chronoEcho: 'lightning' };
            showAbilityFlash(elementMap[abilityKey] || '');
            updateMomentum(5);

            // v6.90: Trigger robot casting animation for ability
            triggerRobotAnimation(abilityKey);

            // v6.36: Track ability for daily challenges
            if (typeof dailyChallenges !== 'undefined' && dailyChallenges.progress) {
                dailyChallenges.updateProgress('ability');
            }

            if (abilityKey === 'powerStrike') {
                // Find nearest mob and deal massive damage
                let nearestMob = null;
                let nearestDist = 5; // Range limit
                worldState.mobs.forEach(mob => {
                    // v6.6: Safe position access (Agent 2 bug fix)
                    const mobPos = mob.mesh?.position || mob.position;
                    if (!mobPos) return;
                    const dist = mobPos.distanceTo(p.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });
                if (nearestMob) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `${ability.icon} POWER STRIKE! -${damage}`, '#ff4400');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.0);
                    if (particles) particles.emit(nearestMob.position, 25, 0xff4400, { spread: 4, lifetime: 800 });
                    AudioSystem.hit(comboState.count || 0); // v6.41: Combo-aware audio
                    // Check kill
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                } else {
                    showNotification('No enemy in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0; // Refund cooldown
                    return false;
                }
            } else if (abilityKey === 'whirlwind') {
                // AoE damage to all nearby mobs
                let hitCount = 0;
                worldState.mobs.forEach(mob => {
                    // v6.6: Safe position access (Agent 2 bug fix)
                    const mobPos = mob.mesh?.position || mob.position;
                    if (!mobPos) return;
                    const dist = mobPos.distanceTo(p.position);
                    if (dist < ability.radius) {
                        const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `${ability.icon} -${damage}`, '#00ffff');
                        hitCount++;
                        if (mob.userData.hp <= 0) {
                            // Queue for death handling
                            setTimeout(() => {
                                if (mob.userData.hp <= 0) performAction(mob);
                            }, 100);
                        }
                    }
                });
                if (hitCount > 0) {
                    spawnFloater(p.position, `${ability.icon} WHIRLWIND! x${hitCount}`, '#00ffff');
                    triggerHitStop(HIT_STOP_HEAVY);
                    screenShake(0.8);
                    if (particles) particles.emit(p.position, 40, 0x00ffff, { spread: ability.radius, lifetime: 600 });
                    AudioSystem.hit();
                } else {
                    showNotification('No enemies nearby!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'warcry') {
                // Activate damage buff
                abilityState.warcry.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} WAR CRY!`, '#ff8800');
                showNotification(`+${Math.floor((ability.damageBoost - 1) * 100)}% damage for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 30, 0xff8800, { spread: 6, lifetime: 1000 });
                AudioSystem.levelUp();
            }
            // v4.9: Tier 2 Abilities
            else if (abilityKey === 'heal') {
                // Self heal
                const healAmt = Math.floor(gameData.player.maxHp * ability.healAmount);
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                spawnFloater(p.position, `${ability.icon} +${healAmt} HP`, '#00ff88');
                showNotification(`Healed ${healAmt} HP!`, 'success');
                if (particles) particles.emit(p.position, 20, 0x00ff88, { spread: 3, lifetime: 800 });
                updateHealthUI();
                AudioSystem.levelUp();
            } else if (abilityKey === 'dash') {
                // v6.36: Track dash for daily challenges
                if (typeof dailyChallenges !== 'undefined' && dailyChallenges.progress) {
                    dailyChallenges.updateProgress('dash');
                }

                // v6.13: LEVIATHAN PULSE - Ancient tech combat dash that DESTROYS obstacles!
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(p.quaternion);
                const startPos = p.position.clone();
                const dashDir = dir.clone().normalize();
                const endPos = p.position.clone().add(dir.multiplyScalar(ability.distance));

                // ==========================================
                // LEVIATHAN PULSE VISUAL EFFECT
                // ==========================================
                createFusRoDahEffect(startPos, dashDir, ability.distance);

                // Damage enemies in path
                let dashHits = 0;
                worldState.mobs.forEach(mob => {
                    const mobPos = mob.position.clone();
                    // Check if mob is roughly between start and end
                    const toMob = mobPos.sub(startPos);
                    const projection = toMob.dot(dashDir);
                    if (projection > 0 && projection < ability.distance) {
                        const perpDist = toMob.clone().sub(dashDir.clone().multiplyScalar(projection)).length();
                        if (perpDist < 3) { // Wider hitbox for Leviathan Pulse
                            const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                            mob.userData.hp -= damage;
                            spawnFloater(mob.position, ` -${damage}`, '#88ffff');
                            dashHits++;

                            // Knockback mobs in the dash direction
                            const knockbackForce = dashDir.clone().multiplyScalar(8);
                            mob.position.add(knockbackForce);

                            if (mob.userData.hp <= 0) {
                                setTimeout(() => { if (mob.userData.hp <= 0) performAction(mob); }, 100);
                            }
                        }
                    }
                });

                // ==========================================
                // DESTROY TREES AND ROCKS IN PATH
                // ==========================================
                let obstaclesDestroyed = 0;
                const obstaclesToRemove = [];

                if (worldState.interactables) {
                    worldState.interactables.forEach(obj => {
                        if (!obj.parent) return;
                        if (obj.userData && (obj.userData.type === 'tree' || obj.userData.type === 'rock')) {
                            const objPos = obj.position.clone();
                            const toObj = objPos.sub(startPos.clone());
                            const projection = toObj.dot(dashDir);

                            // Check if object is in the dash path
                            if (projection > -1 && projection < ability.distance + 2) {
                                const perpDist = toObj.clone().sub(dashDir.clone().multiplyScalar(projection)).length();
                                if (perpDist < 3.5) { // Wide destruction path
                                    obstaclesToRemove.push(obj);
                                }
                            }
                        }
                    });
                }

                // Remove obstacles with visual effects
                obstaclesToRemove.forEach(obj => {
                    const objType = obj.userData.type;
                    const objPos = obj.position.clone();

                    // Spawn destruction particles
                    if (particles) {
                        const color = objType === 'tree' ? 0x228b22 : 0x888888;
                        particles.emit(objPos, 25, color, { spread: 5, lifetime: 800 });
                    }

                    // Spawn debris floater
                    const icon = objType === 'tree' ? '' : '';
                    spawnFloater(objPos, `${icon} SHATTERED!`, objType === 'tree' ? '#228b22' : '#888888');

                    // Give small resource reward for destruction
                    const resourceType = objType === 'tree' ? ' Wood' : ' Stone';
                    addToInventory(resourceType, 1);

                    // Track stats
                    if (objType === 'tree') {
                        gameData.statistics.treesChopped = (gameData.statistics.treesChopped || 0) + 1;
                    }

                    // Remove from scene and array
                    scene.remove(obj);
                    obstaclesDestroyed++;
                });

                // Filter out removed obstacles
                if (obstaclesToRemove.length > 0) {
                    worldState.interactables = worldState.interactables.filter(
                        x => !obstaclesToRemove.includes(x)
                    );
                }

                // ==========================================
                // v6.16: DASH CLEARS FOG
                // The thermal shockwave from the dash disperses fog
                // ==========================================
                if (currentWeather === 'fog' && scene.fog) {
                    createFogClearingEffect(startPos, dashDir, ability.distance);
                }

                // Move player
                p.position.copy(endPos);

                // Show results
                const totalHits = dashHits + obstaclesDestroyed;
                if (totalHits > 0) {
                    let msg = '';
                    if (dashHits > 0 && obstaclesDestroyed > 0) {
                        msg = `DASH! ${dashHits} enemies + ${obstaclesDestroyed} obstacles!`;
                    } else if (dashHits > 0) {
                        msg = `DASH! ${dashHits} enemies sent flying!`;
                    } else {
                        msg = `DASH! ${obstaclesDestroyed} obstacles pulverized!`;
                    }
                    showNotification(msg, 'success');
                    triggerHitStop(obstaclesDestroyed > 2 ? HIT_STOP_BOSS : HIT_STOP_LIGHT);
                    screenShake(0.5 + obstaclesDestroyed * 0.2);
                } else {
                    spawnFloater(p.position, ` DASH! `, '#88ffff');
                }

                if (particles) particles.emit(startPos, 20, 0x88ffff, { spread: 3, lifetime: 500 });
                AudioSystem.hit();
            } else if (abilityKey === 'shieldWall') {
                // Activate damage reduction buff
                abilityState.shieldWall.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} SHIELD WALL!`, '#4488ff');
                showNotification(`${Math.floor(ability.damageReduction * 100)}% damage reduction for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 25, 0x4488ff, { spread: 4, lifetime: 1000 });
                AudioSystem.levelUp();
            } else if (abilityKey === 'execute') {
                // High damage to low HP enemies
                let target = null;
                let nearestDist = 6;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                    if (dist < nearestDist && hpPercent <= ability.threshold) {
                        nearestDist = dist;
                        target = mob;
                    }
                });
                if (target) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    target.userData.hp -= damage;
                    spawnFloater(target.position, `${ability.icon} EXECUTE! -${damage}`, '#ff0044');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.2);
                    if (particles) particles.emit(target.position, 35, 0xff0044, { spread: 5, lifetime: 1000 });
                    AudioSystem.hit();
                    if (target.userData.hp <= 0) {
                        performAction(target);
                    }
                } else {
                    showNotification('No low HP enemies in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'berserk') {
                // ULTIMATE: Massive damage and attack speed buff
                abilityState.berserk.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} BERSERKER RAGE!`, '#ff4400');
                showNotification(`BERSERK! +100% DMG, +50% Attack Speed for ${ability.duration / 1000}s!`, 'success');
                screenShake(1.5);
                if (particles) particles.emit(p.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                AudioSystem.levelUp();
            }
            // v6.42: CHRONO-ECHO - Summon time-echoes that replay past attacks
            else if (abilityKey === 'chronoEcho') {
                // Check if we have recorded actions to replay
                if (chronoEchoSystem.actionHistory.length === 0) {
                    showNotification('No combat history! Attack enemies first.', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }

                abilityState.chronoEcho.activeUntil = now + ability.duration;
                const baseDamage = getPlayerDamage();
                const ghostCount = Math.min(ability.echoCount, chronoEchoSystem.actionHistory.length);

                // Spawn ghost echoes
                chronoEchoSystem.spawnGhosts(ghostCount, baseDamage);

                // Visual activation effect
                spawnFloater(p.position, `${ability.icon} CHRONO-ECHO!`, '#00ffff');
                showNotification(`${ghostCount} time-echoes summoned!`, 'success');
                triggerHitStop(HIT_STOP_HEAVY);
                screenShake(0.8);

                // Time distortion overlay effect
                const container = document.getElementById('game-container');
                if (container) {
                    container.style.boxShadow = 'inset 0 0 100px rgba(0, 255, 255, 0.4)';
                    setTimeout(() => { container.style.boxShadow = ''; }, 500);
                }

                // Particles emanating from player
                if (particles) {
                    particles.emit(p.position, 40, 0x00ffff, { spread: 6, lifetime: 1200 });
                    particles.emit(p.position, 20, 0x8844ff, { spread: 4, lifetime: 800 });
                }

                AudioSystem.levelUp();
            }

            updateAbilityUI();
            return true;
        }

        function isWarcryActive() {
            return performance.now() < abilityState.warcry.activeUntil;
        }

        // v4.9: Check if Shield Wall is active
        function isShieldWallActive() {
            return performance.now() < abilityState.shieldWall.activeUntil;
        }

        // v4.9: Check if Berserk is active
        function isBerserkActive() {
            return performance.now() < abilityState.berserk.activeUntil;
        }

        // v6.42: Check if Chrono-Echo is active (ghosts are present)
        function isChronoEchoActive() {
            return performance.now() < abilityState.chronoEcho.activeUntil ||
                   (typeof chronoEchoSystem !== 'undefined' && chronoEchoSystem.activeGhosts.length > 0);
        }

        function startDodge() {
            if (dodgeState.active || performance.now() < dodgeState.cooldownEnd) return false;
            if (mode !== 'world' || !worldState.player) return false;

            const p = worldState.player;
            dodgeState.active = true;
            dodgeState.startTime = performance.now();
            dodgeState.cooldownEnd = performance.now() + DODGE_CONFIG.COOLDOWN;
            dodgeState.iframesEnd = performance.now() + DODGE_CONFIG.IFRAMES;

            // Direction based on current input or facing
            dodgeState.direction.set(0, 0, 0);
            if (keys.w) dodgeState.direction.z -= 1;
            if (keys.s) dodgeState.direction.z += 1;
            if (keys.a) dodgeState.direction.x -= 1;
            if (keys.d) dodgeState.direction.x += 1;

            // Also check joystick
            if (dodgeState.direction.length() < 0.1 && joystickActive) {
                dodgeState.direction.set(joystickInput.x, 0, joystickInput.y);
            }

            // Default to backward if no input
            if (dodgeState.direction.length() < 0.1) {
                dodgeState.direction.set(-Math.sin(p.rotation.y), 0, -Math.cos(p.rotation.y));
            }
            dodgeState.direction.normalize();

            AudioSystem.dodge();
            if (particles) particles.emit(p.position, 10, 0x88ffff, { spread: 2, lifetime: 300, gravity: 0 });

            // v5.15: Trigger robot jump animation on dodge
            triggerRobotAnimation('jump');

            // v6.9: Style meter bonus on dodge (Agent consensus)
            if (typeof updateStyleMeter === 'function') {
                updateStyleMeter('dodge');
            }

            // v4.6: Check for parry opportunity
            checkParryTiming();

            return true;
        }

        function updateDodge(dt) {
            if (!dodgeState.active) return;

            const elapsed = performance.now() - dodgeState.startTime;
            const progress = elapsed / DODGE_CONFIG.DURATION;

            if (progress < 1) {
                const eased = 1 - Math.pow(1 - progress, 3);
                const moveAmount = (1 - eased) * DODGE_CONFIG.DISTANCE * dt * 10;
                worldState.player.position.add(dodgeState.direction.clone().multiplyScalar(moveAmount));
            } else {
                dodgeState.active = false;
            }
        }

        function isInvincible() {
            return performance.now() < dodgeState.iframesEnd;
        }

        // v4.6: Check if dodge was timed for a parry
        function checkParryTiming() {
            if (!worldState || !worldState.mobs) return;

            const now = performance.now();
            let parried = false;

            worldState.mobs.forEach(mob => {
                if (mob.userData.telegraphing && !mob.userData.stunned) {
                    const timeToAttack = mob.userData.telegraphEnd - now;
                    // Check if dodge was in the parry window (last PARRY_CONFIG.WINDOW ms before attack)
                    if (timeToAttack > 0 && timeToAttack <= PARRY_CONFIG.WINDOW) {
                        // Perfect parry!
                        mob.userData.stunned = true;
                        mob.userData.stunEnd = now + PARRY_CONFIG.STUN_DURATION;
                        mob.userData.telegraphing = false;

                        // Visual feedback
                        mob.material.emissive.setHex(0xffff00); // Yellow stun
                        mob.scale.setScalar(1);
                        spawnFloater(mob.position, ' PARRY!', '#ffd700');

                        parried = true;
                    }
                }
            });

            if (parried) {
                // Grant crit window
                parryState.critWindowEnd = now + PARRY_CONFIG.CRIT_WINDOW;
                parryState.lastParryTime = now;

                // v6.9: Style meter bonus on parry (Agent consensus)
                if (typeof updateStyleMeter === 'function') {
                    updateStyleMeter('parry');
                }

                // Audio feedback
                AudioSystem.levelUp();

                // Screen effect
                screenShake(0.3);
                if (particles) particles.emit(worldState.player.position, 25, 0xffd700, { spread: 4, lifetime: 500 });

                showNotification('PERFECT PARRY! Critical hits enabled!');
            }
        }

        // v4.6: Check if in crit window from parry
        function isInCritWindow() {
            return performance.now() < parryState.critWindowEnd;
        }

        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            // v6.64: BALANCED HIGH-RES TERRAIN - 2x resolution, visible blocks but smoother
            // Original: 100 tiles at size 2 = 200 world units (blocky)
            // New: 200 tiles at size 1 = 200 world units (smooth but visible)
            // 40,000 tiles - 4x smoother than original while terrain remains visible
            WORLD_SIZE: 200,
            TILE_SIZE: 1.0,
            TERRAIN_SCALE: 2, // Scale factor for noise sampling (maintains same terrain pattern)
            PLAYER_MAX_HP: 100,
            MOB_DAMAGE: 5,
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            // New v4.0 constants
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 2,
            MOB_ATTACK_COOLDOWN: 1500,
            INTERACTION_RANGE: 3.5,
            INTERACTION_COOLDOWN: 400, // ms between actions
            MOVEMENT_THRESHOLD: 0.5,
            SCREEN_SHAKE_INTENSITY: 0.5,
            SCREEN_SHAKE_DURATION: 150,
            // v6.84: Pre-computed squared distances for hot path optimizations (avoids sqrt)
            MOB_AGGRO_RANGE_SQ: 15 * 15, // 225
            MOB_ATTACK_RANGE_SQ: 2 * 2,  // 4
            INTERACTION_RANGE_SQ: 3.5 * 3.5 // 12.25
        };

        // ============================================
        // v6.54: STEAM DECK GAMEPAD SUPPORT SYSTEM
        // 8-Agent Consensus Implementation
        // Supports: Detection, Input Mapping, Haptics, Auto-Attack
        // ============================================
        const SteamDeckManager = {
            // State
            connected: false,
            gamepad: null,
            isSteamDeck: false,
            deckModeEnabled: 'auto', // 'auto', 'on', 'off'
            autoAttackEnabled: false,
            vibrationEnabled: true,
            targetFPS: 60,
            lastInputMode: 'keyboard', // 'keyboard', 'gamepad'

            // Deadzone and timing
            DEADZONE: 0.15,
            POLL_RATE: 16, // ~60fps
            lastPoll: 0,

            // Button state tracking (for edge detection)
            prevButtons: new Array(17).fill(false),
            buttonJustPressed: new Array(17).fill(false),

            // Radial menu state
            radialMenuOpen: false,
            radialSelection: -1,

            // Button indices (Standard Gamepad mapping)
            BUTTONS: {
                A: 0, B: 1, X: 2, Y: 3,
                LB: 4, RB: 5, LT: 6, RT: 7,
                SELECT: 8, START: 9,
                L3: 10, R3: 11,
                DPAD_UP: 12, DPAD_DOWN: 13, DPAD_LEFT: 14, DPAD_RIGHT: 15,
                HOME: 16
            },

            // Axis indices
            AXES: {
                LEFT_X: 0, LEFT_Y: 1,
                RIGHT_X: 2, RIGHT_Y: 3
            },

            // Initialize the system
            init() {
                if (this._initialized) return;
                this._initialized = true;

                this.detectSteamDeck();

                window.addEventListener('gamepadconnected', (e) => this.onGamepadConnected(e));
                window.addEventListener('gamepaddisconnected', (e) => this.onGamepadDisconnected(e));

                // Check for already-connected gamepads
                const gamepads = navigator.getGamepads();
                for (const gp of gamepads) {
                    if (gp) {
                        this.onGamepadConnected({ gamepad: gp });
                        break;
                    }
                }

                this.loadSettings();

                // v6.55: Initialize analytics module
                if (typeof SteamDeckAnalytics !== 'undefined') {
                    SteamDeckAnalytics.init();
                }

                console.log('[SteamDeck] Manager initialized. Deck detected:', this.isSteamDeck);
            },

            // Detect if running on Steam Deck
            detectSteamDeck() {
                const isSteamDeckResolution = window.screen.width === 1280 && window.screen.height === 800;
                const isLinux = navigator.userAgent.toLowerCase().includes('linux');
                this.isSteamDeck = isSteamDeckResolution && isLinux;

                if (this.deckModeEnabled === 'auto' && this.isSteamDeck) {
                    this.applyDeckMode(true);
                }
                return this.isSteamDeck;
            },

            // Gamepad connected
            onGamepadConnected(e) {
                this.gamepad = e.gamepad;
                this.connected = true;

                const gpId = e.gamepad.id.toLowerCase();
                if (gpId.includes('steam') || gpId.includes('valve')) {
                    this.isSteamDeck = true;
                    if (this.deckModeEnabled === 'auto') {
                        this.applyDeckMode(true);
                    }
                }

                const indicator = document.getElementById('gamepad-indicator');
                const status = document.getElementById('gamepad-status');
                if (indicator) {
                    indicator.classList.add('connected');
                    indicator.classList.remove('disconnected');
                }
                if (status) {
                    status.textContent = this.isSteamDeck ? 'Steam Deck' : 'Controller';
                }

                const touchControls = document.getElementById('touch-controls');
                if (touchControls && this.isSteamDeck) {
                    touchControls.style.display = 'none';
                }

                this.lastInputMode = 'gamepad';
                if (typeof showNotification === 'function') {
                    showNotification(' Controller connected!', 'success');
                }

                // v6.55: Track gamepad connection in analytics
                if (typeof SteamDeckAnalytics !== 'undefined') {
                    SteamDeckAnalytics.trackGamepadConnected(e.gamepad.id);
                }

                console.log('[SteamDeck] Gamepad connected:', e.gamepad.id);
            },

            // Gamepad disconnected
            onGamepadDisconnected(e) {
                this.gamepad = null;
                this.connected = false;

                const indicator = document.getElementById('gamepad-indicator');
                const status = document.getElementById('gamepad-status');
                if (indicator) {
                    indicator.classList.remove('connected');
                    indicator.classList.add('disconnected');
                }
                if (status) {
                    status.textContent = 'Disconnected';
                }

                const touchControls = document.getElementById('touch-controls');
                if (touchControls) {
                    touchControls.style.display = '';
                }

                setTimeout(() => {
                    if (!this.connected && indicator) {
                        indicator.classList.remove('disconnected');
                    }
                }, 3000);

                if (typeof showNotification === 'function') {
                    showNotification(' Controller disconnected', 'warning');
                }
            },

            // Main polling function - called from game loop
            poll(time) {
                if (!this.connected) return;
                if (time - this.lastPoll < this.POLL_RATE) return;
                this.lastPoll = time;

                const gamepads = navigator.getGamepads();
                this.gamepad = gamepads[this.gamepad?.index || 0];
                if (!this.gamepad) return;

                // Track button edge detection
                for (let i = 0; i < this.gamepad.buttons.length && i < 17; i++) {
                    const pressed = this.gamepad.buttons[i].pressed;
                    this.buttonJustPressed[i] = pressed && !this.prevButtons[i];
                    this.prevButtons[i] = pressed;
                }

                // Process input based on game mode
                if (mode === 'world') {
                    this.processWorldInput();
                } else if (mode === 'galaxy') {
                    this.processGalaxyInput();
                }

                if (this.gamepad.buttons.some(b => b.pressed) ||
                    Math.abs(this.gamepad.axes[0]) > this.DEADZONE ||
                    Math.abs(this.gamepad.axes[1]) > this.DEADZONE) {
                    this.lastInputMode = 'gamepad';
                }
            },

            // Process world mode input
            processWorldInput() {
                if (!this.gamepad || !worldState?.player) return;
                const gp = this.gamepad;
                const B = this.BUTTONS;

                // === MOVEMENT (Left Stick) ===
                const lx = this.applyDeadzone(gp.axes[this.AXES.LEFT_X]);
                const ly = this.applyDeadzone(gp.axes[this.AXES.LEFT_Y]);

                keys.w = ly < -0.3;
                keys.s = ly > 0.3;
                keys.a = lx < -0.3;
                keys.d = lx > 0.3;

                // === CAMERA (Right Stick) - for radial menu ===
                const rx = this.applyDeadzone(gp.axes[this.AXES.RIGHT_X]);
                const ry = this.applyDeadzone(gp.axes[this.AXES.RIGHT_Y]);

                // === RADIAL MENU (Hold LB) ===
                if (gp.buttons[B.LB].pressed) {
                    if (!this.radialMenuOpen) {
                        this.openRadialMenu();
                    }
                    if (Math.abs(rx) > 0.5 || Math.abs(ry) > 0.5) {
                        const angle = Math.atan2(ry, rx);
                        const segment = Math.round((angle + Math.PI) / (Math.PI / 4)) % 8;
                        this.selectRadialSegment(segment);
                    }
                } else if (this.radialMenuOpen) {
                    this.closeRadialMenu();
                }

                // A Button: Primary action / Interact
                if (this.buttonJustPressed[B.A]) {
                    if (typeof performAction === 'function' && worldState.target) {
                        performAction(worldState.target);
                    }
                }

                // B Button: Dodge
                if (this.buttonJustPressed[B.B]) {
                    if (typeof startDodge === 'function') {
                        startDodge();
                    }
                }

                // X Button: Whirlwind (E ability)
                if (this.buttonJustPressed[B.X]) {
                    if (typeof useAbility === 'function') {
                        useAbility('whirlwind');
                    }
                }

                // Y Button: Power Strike (Q ability)
                if (this.buttonJustPressed[B.Y]) {
                    if (typeof useAbility === 'function') {
                        useAbility('powerStrike');
                    }
                }

                // RB: Cycle targets
                if (this.buttonJustPressed[B.RB]) {
                    this.cycleTarget(1);
                }

                // RT: Attack (when pressed)
                if (gp.buttons[B.RT].pressed && gp.buttons[B.RT].value > 0.5) {
                    if (typeof performAction === 'function' && worldState.target) {
                        performAction(worldState.target);
                    }
                }

                // L3 (Left stick click): Temporal Rewind
                if (gp.buttons[B.L3].pressed) {
                    if (typeof temporalRewind !== 'undefined' && !temporalRewind.isRewinding) {
                        temporalRewind.startRewind();
                    }
                } else if (typeof temporalRewind !== 'undefined' && temporalRewind.isRewinding) {
                    temporalRewind.stopRewind();
                }

                // R3: Toggle auto-attack
                if (this.buttonJustPressed[B.R3]) {
                    this.toggleAutoAttackInternal();
                }

                // D-Pad Up: Quick heal
                if (this.buttonJustPressed[B.DPAD_UP]) {
                    if (typeof useAbility === 'function') {
                        useAbility('heal');
                    }
                }

                // D-Pad Down: Toggle inventory
                if (this.buttonJustPressed[B.DPAD_DOWN]) {
                    const invPanel = document.getElementById('inventory-panel');
                    if (invPanel) {
                        invPanel.style.display = invPanel.style.display === 'none' ? 'block' : 'none';
                    }
                }

                // Start: Menu/Settings
                if (this.buttonJustPressed[B.START]) {
                    if (typeof toggleSettingsPanel === 'function') {
                        toggleSettingsPanel();
                    }
                }

                // Select: Quick save
                if (this.buttonJustPressed[B.SELECT]) {
                    if (typeof saveGameData === 'function') {
                        saveGameData();
                        if (typeof showNotification === 'function') {
                            showNotification(' Game saved!', 'success');
                        }
                        this.vibrate('save');
                    }
                }
            },

            // Process galaxy mode input
            processGalaxyInput() {
                if (!this.gamepad) return;
                const gp = this.gamepad;
                const B = this.BUTTONS;

                const lx = this.applyDeadzone(gp.axes[this.AXES.LEFT_X]);
                const ly = this.applyDeadzone(gp.axes[this.AXES.LEFT_Y]);

                if (camera && (Math.abs(lx) > 0.1 || Math.abs(ly) > 0.1)) {
                    const orbitSpeed = 0.02;
                    if (typeof galaxyRotation !== 'undefined') {
                        galaxyRotation.y += lx * orbitSpeed;
                        galaxyRotation.x = Math.max(-0.5, Math.min(0.5, galaxyRotation.x + ly * orbitSpeed));
                    }
                }

                const ry = this.applyDeadzone(gp.axes[this.AXES.RIGHT_Y]);
                if (Math.abs(ry) > 0.3 && camera) {
                    const zoomSpeed = 5;
                    camera.position.z = Math.max(50, Math.min(500, camera.position.z + ry * zoomSpeed));
                }

                if (this.buttonJustPressed[B.RB]) {
                    this.cyclePlanet(1);
                }
                if (this.buttonJustPressed[B.LB]) {
                    this.cyclePlanet(-1);
                }

                if (this.buttonJustPressed[B.A]) {
                    if (typeof selectedCiv !== 'undefined' && selectedCiv) {
                        if (typeof enterWorld === 'function') {
                            enterWorld(selectedCiv);
                        }
                    }
                }

                if (this.buttonJustPressed[B.B]) {
                    const modals = document.querySelectorAll('.modal-overlay');
                    modals.forEach(m => {
                        if (m.style.display !== 'none') {
                            m.style.display = 'none';
                        }
                    });
                }

                if (this.buttonJustPressed[B.START]) {
                    if (typeof toggleSettingsPanel === 'function') {
                        toggleSettingsPanel();
                    }
                }
            },

            // Cycle through targets
            cycleTarget(direction) {
                if (!worldState?.mobs || worldState.mobs.length === 0) return;

                const currentIdx = worldState.target ?
                    worldState.mobs.indexOf(worldState.target) : -1;
                let nextIdx = currentIdx + direction;

                if (nextIdx >= worldState.mobs.length) nextIdx = 0;
                if (nextIdx < 0) nextIdx = worldState.mobs.length - 1;

                worldState.target = worldState.mobs[nextIdx];
                this.vibrate('select');
            },

            // Cycle through planets in galaxy view
            cyclePlanet(direction) {
                if (typeof civilizations === 'undefined' || civilizations.length === 0) return;

                const currentIdx = typeof selectedCivIndex !== 'undefined' ? selectedCivIndex : 0;
                let nextIdx = currentIdx + direction;

                if (nextIdx >= civilizations.length) nextIdx = 0;
                if (nextIdx < 0) nextIdx = civilizations.length - 1;

                selectedCivIndex = nextIdx;
                selectedCiv = civilizations[nextIdx];
                this.vibrate('select');
            },

            // Radial menu functions
            openRadialMenu() {
                this.radialMenuOpen = true;
                const menu = document.getElementById('radial-menu');
                if (menu) menu.classList.add('active');
            },

            closeRadialMenu() {
                this.radialMenuOpen = false;
                const menu = document.getElementById('radial-menu');
                if (menu) menu.classList.remove('active');

                if (this.radialSelection >= 0) {
                    const abilities = ['powerStrike', 'execute', 'whirlwind', 'berserk',
                                      'warcry', 'dash', 'shield', 'heal'];
                    const ability = abilities[this.radialSelection];
                    if (ability && typeof useAbility === 'function') {
                        useAbility(ability);
                        this.vibrate('ability');
                    }
                }
                this.radialSelection = -1;
            },

            selectRadialSegment(segment) {
                if (segment === this.radialSelection) return;
                this.radialSelection = segment;

                const segments = document.querySelectorAll('.radial-segment');
                segments.forEach((seg, i) => {
                    seg.classList.toggle('selected', i === segment);
                });
                this.vibrate('select');
            },

            // Apply deadzone to axis value
            applyDeadzone(value) {
                if (Math.abs(value) < this.DEADZONE) return 0;
                const sign = value > 0 ? 1 : -1;
                return sign * (Math.abs(value) - this.DEADZONE) / (1 - this.DEADZONE);
            },

            // Haptic feedback
            vibrate(type) {
                if (!this.vibrationEnabled || !this.gamepad?.vibrationActuator) return;

                const patterns = {
                    hit: { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.6 },
                    damage: { duration: 200, weakMagnitude: 0.8, strongMagnitude: 1.0 },
                    ability: { duration: 150, weakMagnitude: 0.4, strongMagnitude: 0.5 },
                    select: { duration: 50, weakMagnitude: 0.2, strongMagnitude: 0.1 },
                    save: { duration: 100, weakMagnitude: 0.3, strongMagnitude: 0.3 },
                    levelUp: { duration: 400, weakMagnitude: 0.5, strongMagnitude: 0.8 },
                    lowHealth: { duration: 300, weakMagnitude: 0.6, strongMagnitude: 0.4 }
                };

                const pattern = patterns[type] || patterns.select;

                try {
                    this.gamepad.vibrationActuator.playEffect('dual-rumble', {
                        startDelay: 0,
                        duration: pattern.duration,
                        weakMagnitude: pattern.weakMagnitude,
                        strongMagnitude: pattern.strongMagnitude
                    });
                } catch (e) { /* Vibration not supported */ }
            },

            toggleAutoAttackInternal() {
                this.autoAttackEnabled = !this.autoAttackEnabled;
                const btn = document.getElementById('autoattack-toggle');
                if (btn) {
                    btn.textContent = this.autoAttackEnabled ? 'ON' : 'OFF';
                    btn.classList.toggle('active', this.autoAttackEnabled);
                }
                if (typeof showNotification === 'function') {
                    showNotification(`Auto-Attack: ${this.autoAttackEnabled ? 'ON' : 'OFF'}`, 'info');
                }
                this.saveSettings();
            },

            applyDeckMode(enabled) {
                if (enabled) {
                    if (typeof particles !== 'undefined' && particles.maxParticles) {
                        particles.maxParticles = Math.min(particles.maxParticles, 150);
                    }
                    this.targetFPS = 40;
                    document.body.classList.add('deck-mode');

                    // v6.55: Track Deck Mode in analytics
                    if (typeof SteamDeckAnalytics !== 'undefined') {
                        SteamDeckAnalytics.trackDeckModeActive(true);
                    }

                    console.log('[SteamDeck] Deck Mode enabled');
                } else {
                    document.body.classList.remove('deck-mode');
                    this.targetFPS = 60;

                    // v6.55: Track Deck Mode disabled
                    if (typeof SteamDeckAnalytics !== 'undefined') {
                        SteamDeckAnalytics.trackDeckModeActive(false);
                    }

                    console.log('[SteamDeck] Deck Mode disabled');
                }
            },

            updateAutoAttack() {
                if (!this.autoAttackEnabled || !worldState?.player || !worldState?.mobs) return;

                let nearestMob = null;
                let nearestDist = CONFIG.MOB_ATTACK_RANGE * 1.5;

                worldState.mobs.forEach(mob => {
                    if (mob.userData.hp <= 0) return;
                    const dist = mob.position.distanceTo(worldState.player.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob && typeof performAction === 'function') {
                    worldState.target = nearestMob;
                    performAction(nearestMob);
                }
            },

            saveSettings() {
                const settings = {
                    deckModeEnabled: this.deckModeEnabled,
                    autoAttackEnabled: this.autoAttackEnabled,
                    vibrationEnabled: this.vibrationEnabled,
                    targetFPS: this.targetFPS
                };
                localStorage.setItem('steamDeckSettings', JSON.stringify(settings));
            },

            loadSettings() {
                try {
                    const saved = localStorage.getItem('steamDeckSettings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        this.deckModeEnabled = settings.deckModeEnabled || 'auto';
                        this.autoAttackEnabled = settings.autoAttackEnabled || false;
                        this.vibrationEnabled = settings.vibrationEnabled !== false;
                        this.targetFPS = settings.targetFPS || 60;
                        this.updateSettingsUI();
                    }
                } catch (e) {
                    console.warn('[SteamDeck] Failed to load settings:', e);
                }
            },

            updateSettingsUI() {
                const deckBtn = document.getElementById('deckmode-toggle');
                const autoBtn = document.getElementById('autoattack-toggle');
                const vibBtn = document.getElementById('vibration-toggle');
                const fpsSelect = document.getElementById('target-fps');

                if (deckBtn) deckBtn.textContent = this.deckModeEnabled.toUpperCase();
                if (autoBtn) autoBtn.textContent = this.autoAttackEnabled ? 'ON' : 'OFF';
                if (vibBtn) vibBtn.textContent = this.vibrationEnabled ? 'ON' : 'OFF';
                if (fpsSelect) fpsSelect.value = this.targetFPS.toString();
            }
        };

        // Settings panel toggle functions for Steam Deck
        function toggleDeckMode() {
            const modes = ['auto', 'on', 'off'];
            const currentIdx = modes.indexOf(SteamDeckManager.deckModeEnabled);
            SteamDeckManager.deckModeEnabled = modes[(currentIdx + 1) % modes.length];

            const btn = document.getElementById('deckmode-toggle');
            if (btn) btn.textContent = SteamDeckManager.deckModeEnabled.toUpperCase();

            if (SteamDeckManager.deckModeEnabled === 'on') {
                SteamDeckManager.applyDeckMode(true);
            } else if (SteamDeckManager.deckModeEnabled === 'off') {
                SteamDeckManager.applyDeckMode(false);
            } else {
                SteamDeckManager.applyDeckMode(SteamDeckManager.isSteamDeck);
            }
            SteamDeckManager.saveSettings();
        }

        function toggleAutoAttack() {
            SteamDeckManager.toggleAutoAttackInternal();
        }

        function toggleVibration() {
            SteamDeckManager.vibrationEnabled = !SteamDeckManager.vibrationEnabled;
            const btn = document.getElementById('vibration-toggle');
            if (btn) btn.textContent = SteamDeckManager.vibrationEnabled ? 'ON' : 'OFF';
            SteamDeckManager.saveSettings();
        }

        function setTargetFPS(fps) {
            SteamDeckManager.targetFPS = parseInt(fps) || 60;
            SteamDeckManager.saveSettings();
        }

        // ============================================
        // v6.55: STEAM DECK ANALYTICS MODULE
        // Privacy-Respecting Local-First Analytics
        // Tracks device usage for developer insights
        // ============================================
        const SteamDeckAnalytics = {
            STORAGE_KEY: 'levi_steamdeck_analytics',
            BEACON_KEY: 'levi_analytics_beacon_consent',

            // Current session data
            session: {
                startTime: null,
                endTime: null,
                deviceType: 'unknown',
                gamepadUsed: false,
                deckModeActive: false,
                featuresUsed: new Set(),
                playtimeMs: 0
            },

            // Initialize analytics
            init() {
                this.session.startTime = Date.now();
                this.detectDeviceType();
                this.loadAndMerge();

                // Track session end on page unload
                window.addEventListener('beforeunload', () => this.endSession());
                window.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') {
                        this.saveSession();
                    }
                });

                console.log('[Analytics] Initialized. Device:', this.session.deviceType);
            },

            // Detect device type
            detectDeviceType() {
                const ua = navigator.userAgent.toLowerCase();
                const width = window.screen.width;
                const height = window.screen.height;

                // Steam Deck detection
                if (width === 1280 && height === 800 && ua.includes('linux')) {
                    this.session.deviceType = 'steam_deck';
                }
                // Mobile detection
                else if (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(ua)) {
                    this.session.deviceType = /ipad/i.test(ua) ? 'tablet' : 'mobile';
                }
                // Desktop detection with browser
                else {
                    if (ua.includes('edg/')) this.session.deviceType = 'desktop_edge';
                    else if (ua.includes('chrome')) this.session.deviceType = 'desktop_chrome';
                    else if (ua.includes('firefox')) this.session.deviceType = 'desktop_firefox';
                    else if (ua.includes('safari')) this.session.deviceType = 'desktop_safari';
                    else this.session.deviceType = 'desktop_other';
                }
            },

            // Track feature usage
            trackFeature(featureName) {
                this.session.featuresUsed.add(featureName);
            },

            // Track gamepad connection
            trackGamepadConnected(gamepadId) {
                this.session.gamepadUsed = true;
                this.trackFeature('gamepad_connected');

                // Check if it's a Steam Controller
                if (gamepadId && (gamepadId.toLowerCase().includes('steam') ||
                                  gamepadId.toLowerCase().includes('valve'))) {
                    this.trackFeature('steam_controller');
                }
            },

            // Track Deck Mode activation
            trackDeckModeActive(active) {
                this.session.deckModeActive = active;
                if (active) this.trackFeature('deck_mode_enabled');
            },

            // Get aggregated analytics data
            // v6.84: Added error handling for corrupted localStorage data
            getData() {
                const raw = localStorage.getItem(this.STORAGE_KEY);
                if (!raw) return this.getEmptyData();
                try {
                    return JSON.parse(raw);
                } catch (e) {
                    console.warn('Analytics data corrupted, resetting:', e);
                    return this.getEmptyData();
                }
            },

            // Empty data structure
            getEmptyData() {
                return {
                    version: 1,
                    firstSeen: Date.now(),
                    lastSeen: Date.now(),
                    totalSessions: 0,
                    totalPlaytimeMs: 0,
                    deviceBreakdown: {},
                    featureUsage: {},
                    gamepadSessions: 0,
                    deckModeSessions: 0,
                    steamDeckSessions: 0
                };
            },

            // Load existing data and prepare for merge
            loadAndMerge() {
                // Data will be merged on session end
            },

            // Save current session to aggregated data
            saveSession() {
                const data = this.getData();
                const sessionDuration = Date.now() - this.session.startTime;

                // Update aggregates
                data.lastSeen = Date.now();
                data.totalPlaytimeMs += sessionDuration;

                // Device breakdown
                const device = this.session.deviceType;
                data.deviceBreakdown[device] = (data.deviceBreakdown[device] || 0) + 1;

                // Feature usage
                for (const feature of this.session.featuresUsed) {
                    data.featureUsage[feature] = (data.featureUsage[feature] || 0) + 1;
                }

                // Gamepad and Deck mode tracking
                if (this.session.gamepadUsed) data.gamepadSessions++;
                if (this.session.deckModeActive) data.deckModeSessions++;
                if (this.session.deviceType === 'steam_deck') data.steamDeckSessions++;

                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
            },

            // End session (called on unload)
            endSession() {
                const data = this.getData();
                data.totalSessions++;
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                this.saveSession();
            },

            // Get summary for display
            getSummary() {
                const data = this.getData();
                const hours = Math.floor(data.totalPlaytimeMs / 3600000);
                const minutes = Math.floor((data.totalPlaytimeMs % 3600000) / 60000);

                return {
                    totalSessions: data.totalSessions,
                    playtime: `${hours}h ${minutes}m`,
                    steamDeckUsage: data.steamDeckSessions,
                    gamepadUsage: data.gamepadSessions,
                    deckModeUsage: data.deckModeSessions,
                    deviceBreakdown: data.deviceBreakdown,
                    topFeatures: Object.entries(data.featureUsage)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                };
            },

            // Export analytics data (for user to share)
            exportData() {
                const data = this.getData();
                const summary = this.getSummary();

                const exportObj = {
                    exportDate: new Date().toISOString(),
                    gameVersion: '6.55',
                    summary: summary,
                    rawData: data,
                    // Privacy: No PII, just aggregated stats
                    privacyNote: 'This data contains no personal information, only aggregated gameplay statistics.'
                };

                const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `levi-analytics-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                return exportObj;
            },

            // Clear all analytics data
            clearData() {
                localStorage.removeItem(this.STORAGE_KEY);
                localStorage.removeItem(this.BEACON_KEY);
                console.log('[Analytics] Data cleared');
            },

            // ===== OPTIONAL BEACON SYSTEM (Tier 2) =====
            // User must explicitly opt-in for this

            beaconConsent: false,

            // Check if user has opted into beacon
            hasBeaconConsent() {
                return localStorage.getItem(this.BEACON_KEY) === 'true';
            },

            // Set beacon consent
            setBeaconConsent(consent) {
                this.beaconConsent = consent;
                localStorage.setItem(this.BEACON_KEY, consent ? 'true' : 'false');
                console.log('[Analytics] Beacon consent:', consent);
            },

            // Send anonymous beacon (only if opted in)
            // This would ping a simple endpoint with device type only
            // NOT IMPLEMENTED - placeholder for future opt-in analytics service
            sendBeacon() {
                if (!this.hasBeaconConsent()) return false;

                // Minimal anonymous data
                const beacon = {
                    t: Date.now(),
                    d: this.session.deviceType,
                    g: this.session.gamepadUsed ? 1 : 0,
                    v: '6.55'
                };

                // Would send to analytics endpoint here
                // navigator.sendBeacon('https://your-analytics-endpoint.com/levi', JSON.stringify(beacon));

                console.log('[Analytics] Beacon would send:', beacon);
                return true;
            }
        };

        // v6.55: Analytics UI helper functions
        function exportAnalyticsData() {
            if (typeof SteamDeckAnalytics !== 'undefined') {
                SteamDeckAnalytics.exportData();
                if (typeof showNotification === 'function') {
                    showNotification(' Analytics exported!', 'success');
                }
            }
        }

        function clearAnalyticsData() {
            if (confirm('Clear all analytics data? This cannot be undone.')) {
                if (typeof SteamDeckAnalytics !== 'undefined') {
                    SteamDeckAnalytics.clearData();
                    updateAnalyticsUI();
                    if (typeof showNotification === 'function') {
                        showNotification(' Analytics cleared', 'warning');
                    }
                }
            }
        }

        function updateAnalyticsUI() {
            if (typeof SteamDeckAnalytics === 'undefined') return;

            const summary = SteamDeckAnalytics.getSummary();

            const sessionsEl = document.getElementById('analytics-sessions');
            const playtimeEl = document.getElementById('analytics-playtime');
            const deckEl = document.getElementById('analytics-deck');
            const gamepadEl = document.getElementById('analytics-gamepad');

            if (sessionsEl) sessionsEl.textContent = summary.totalSessions;
            if (playtimeEl) playtimeEl.textContent = summary.playtime;
            if (deckEl) deckEl.textContent = `${summary.steamDeckUsage} sessions`;
            if (gamepadEl) gamepadEl.textContent = `${summary.gamepadUsage} sessions`;
        }

        // v4.7: Player state for status effects
        const playerState = {
            chilled: false,
            chilledEnd: 0,
            moveSpeedMult: 1.0,
            // v6.42: Lava damage tracking (8-agent consensus)
            lastLavaDamageTime: 0,
            inLava: false
        };

        // v6.42: Lava Damage Configuration (8-agent consensus: 5 damage / 500ms = 10 DPS)
        const LAVA_DAMAGE_CONFIG = {
            TICK_RATE: 500,           // ms between damage ticks (matches fire DoT)
            DAMAGE: 5,                // damage per tick (dangerous but escapable)
            FLOATER_COLOR: '#ff4400', // orange-red matching Volcanic biome
            FLOATER_ICON: ''
        };

        // v6.1: SPATIAL HASH GRID - O(1) entity lookups instead of O(n)
        const SpatialGrid = {
            cellSize: 10,
            grid: new Map(),
            entityToCell: new Map(),

            // Get cell key from position
            getCellKey(x, z) {
                const cx = Math.floor(x / this.cellSize);
                const cz = Math.floor(z / this.cellSize);
                return `${cx},${cz}`;
            },

            // Add entity to grid
            add(entity) {
                if (!entity || !entity.position) return;
                const key = this.getCellKey(entity.position.x, entity.position.z);
                if (!this.grid.has(key)) this.grid.set(key, new Set());
                this.grid.get(key).add(entity);
                this.entityToCell.set(entity, key);
            },

            // Remove entity from grid
            remove(entity) {
                const oldKey = this.entityToCell.get(entity);
                if (oldKey && this.grid.has(oldKey)) {
                    this.grid.get(oldKey).delete(entity);
                    if (this.grid.get(oldKey).size === 0) this.grid.delete(oldKey);
                }
                this.entityToCell.delete(entity);
            },

            // Update entity position (call when entity moves)
            update(entity) {
                if (!entity || !entity.position) return;
                const newKey = this.getCellKey(entity.position.x, entity.position.z);
                const oldKey = this.entityToCell.get(entity);
                if (oldKey !== newKey) {
                    this.remove(entity);
                    this.add(entity);
                }
            },

            // Get all entities within radius of position (optimized)
            getNearby(x, z, radius, filter = null) {
                const results = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const cx = Math.floor(x / this.cellSize);
                const cz = Math.floor(z / this.cellSize);
                const radiusSq = radius * radius;

                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                        const key = `${cx + dx},${cz + dz}`;
                        const cell = this.grid.get(key);
                        if (!cell) continue;

                        for (const entity of cell) {
                            if (!entity.position) continue;
                            const distSq = (entity.position.x - x) ** 2 + (entity.position.z - z) ** 2;
                            if (distSq <= radiusSq) {
                                if (!filter || filter(entity)) {
                                    results.push({ entity, distSq });
                                }
                            }
                        }
                    }
                }

                // Sort by distance
                results.sort((a, b) => a.distSq - b.distSq);
                return results.map(r => r.entity);
            },

            // Clear entire grid
            clear() {
                this.grid.clear();
                this.entityToCell.clear();
            },

            // Rebuild grid from entities array
            rebuild(entities) {
                this.clear();
                entities.forEach(e => this.add(e));
            }
        };

        // v6.1: Frame budget system for consistent performance
        const FrameBudget = {
            targetMs: 16, // 60 FPS target
            lastFrameTime: 0,
            lowPriorityQueue: [],
            frameSkipCounter: 0,

            // Check if we have budget for low-priority updates
            hasBudget() {
                return performance.now() - this.lastFrameTime < this.targetMs * 0.7;
            },

            // Queue low-priority work
            queueLowPriority(fn) {
                this.lowPriorityQueue.push(fn);
            },

            // Process queued work if budget allows
            processQueue() {
                while (this.lowPriorityQueue.length > 0 && this.hasBudget()) {
                    const fn = this.lowPriorityQueue.shift();
                    try { fn(); } catch (e) { console.warn('Low priority task failed:', e); }
                }
            },

            // Start frame timing
            startFrame() {
                this.lastFrameTime = performance.now();
            },

            // Should we skip this low-priority update?
            shouldSkipLowPriority() {
                this.frameSkipCounter++;
                return this.frameSkipCounter % 3 !== 0; // Skip 2 out of 3 frames for low-priority
            }
        };

        // --- PRE-ALLOCATED REUSABLE OBJECTS ---
        const _tempVec3A = new THREE.Vector3();
        const _tempVec3B = new THREE.Vector3();
        // v6.83: Pre-allocated colors for day/night cycle (eliminates 2 Color allocations per frame)
        const _dayColor = new THREE.Color();
        const _nightColor = new THREE.Color(0x050510);

        // v6.84: DOM element cache for hot path updates (eliminates 5-10 getElementById calls per second)
        let _uiCache = null;
        function getUICache() {
            if (!_uiCache) {
                _uiCache = {
                    cycleCount: document.getElementById('cycle-count'),
                    civCount: document.getElementById('civ-count'), // v6.92: Live civilization count
                    perfFps: document.getElementById('perf-fps'),
                    perfEntities: document.getElementById('perf-entities'),
                    perfMobs: document.getElementById('perf-mobs'),
                    perfDraws: document.getElementById('perf-draws'),
                    perfTris: document.getElementById('perf-tris'),
                    shipHpFill: document.getElementById('ship-hp-fill'),
                    shipHpText: document.getElementById('ship-hp-text'),
                    companionHealth: document.getElementById('companion-health-container'),
                    dotaHpFill: document.getElementById('dota-hp-fill'),
                    dotaHpText: document.getElementById('dota-hp-text'),
                    dotaManaFill: document.getElementById('dota-mana-fill'),
                    dotaManaText: document.getElementById('dota-mana-text'),
                    criticalHpOverlay: document.getElementById('critical-hp-overlay')
                };
            }
            return _uiCache;
        }
        // v6.84: Invalidate cache when DOM might have changed (e.g., after mode switch)
        function invalidateUICache() {
            _uiCache = null;
        }
        // v6.63: Optimal ARPG camera - Diablo-style isometric follow
        // Height 18, distance 15 creates ~50 angle for good terrain visibility
        // Robot stays centered and prominent, terrain flows around it
        const _camOffset = new THREE.Vector3(0, 18, 15);
        const _camLookOffset = new THREE.Vector3(0, -1, -2); // Look slightly ahead of robot
        // v6.41: Pre-allocated camera target vectors (eliminates 4-10 Vector3 allocations per frame)
        const _tempCamTarget = new THREE.Vector3();
        const _tempCamLook = new THREE.Vector3();

        // --- SCREEN EFFECTS ---
        // v6.41: Enhanced trauma-based screen shake (Agent 5 consensus - smoother, more cinematic)
        let shakeTrauma = 0;
        let shakeTime = 0;
        let originalCameraPos = null;

        function screenShake(intensity = CONFIG.SCREEN_SHAKE_INTENSITY) {
            // v4.6: Check settings
            if (gameData.settings && !gameData.settings.screenShakeEnabled) return;
            // v6.41: Trauma is additive but capped - stacking impacts feel more impactful
            shakeTrauma = Math.min(1.0, shakeTrauma + intensity * 0.4);
            if (!originalCameraPos) originalCameraPos = new THREE.Vector3();
        }

        function updateScreenShake() {
            if (shakeTrauma > 0 && mode === 'world') {
                shakeTime += 0.15; // Controls shake frequency

                // v6.41: Trauma squared for exponential falloff (Vlambeer's "juice" technique)
                const shake = shakeTrauma * shakeTrauma;

                // v6.41: Layered sine waves for smooth, organic motion instead of random jitter
                const offsetX = Math.sin(shakeTime * 15.3) * Math.cos(shakeTime * 8.7) * shake * 1.8;
                const offsetY = Math.sin(shakeTime * 12.1) * Math.cos(shakeTime * 9.3) * shake * 1.2;

                camera.position.x += offsetX;
                camera.position.y += offsetY;

                // v6.41: Exponential trauma decay feels more natural than linear
                shakeTrauma = Math.max(0, shakeTrauma - 0.025);
            }
        }

        // Damage flash overlay
        function flashDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.4';
                setTimeout(() => overlay.style.opacity = '0', 150);
            }
        }

        // v6.7: Directional damage indicator (Agent consensus - Combat Juice)
        // Shows a red gradient from the direction of the attacker
        function flashDirectionalDamage(attackerPos) {
            if (!worldState.player || !attackerPos) return;

            const overlay = document.getElementById('directional-damage');
            if (!overlay) return;

            // Calculate angle from player to attacker
            const playerPos = worldState.player.position;
            const dx = attackerPos.x - playerPos.x;
            const dz = attackerPos.z - playerPos.z;

            // Convert to screen space (accounting for camera rotation)
            // Camera looks down from behind, so we need to adjust
            let angle = Math.atan2(dx, dz) * (180 / Math.PI);

            // Adjust based on camera angle if available
            if (camera) {
                angle -= camera.rotation.y * (180 / Math.PI);
            }

            // Create directional gradient: red coming from the direction of attack
            overlay.style.background = `linear-gradient(${angle}deg, rgba(255,0,0,0.6) 0%, transparent 40%)`;
            overlay.style.opacity = '0.8';

            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 200);
        }

        // v6.12: Victory celebration flash (Renamed from Kill for family-friendly)
        function flashVictoryCelebration(isBoss = false) {
            const flash = document.getElementById('victory-flash') || document.getElementById('kill-flash');
            if (!flash) return;

            if (isBoss) {
                // Epic gold/white flash for boss victories
                flash.style.background = 'radial-gradient(ellipse at center, rgba(255,255,255,0.6) 0%, rgba(255,215,0,0.4) 30%, transparent 70%)';
                flash.style.opacity = '1';
                setTimeout(() => flash.style.opacity = '0', 300);
            } else {
                // Subtle white flash for regular victories
                flash.style.background = 'radial-gradient(ellipse at center, rgba(255,255,255,0.3) 0%, transparent 60%)';
                flash.style.opacity = '1';
                setTimeout(() => flash.style.opacity = '0', 150);
            }
        }
        // Backwards compatibility alias
        function flashKillCelebration(isBoss) { flashVictoryCelebration(isBoss); }

        // ============================================
        // v6.32: CAMERA PUNCH + DIRECTIONAL HIT-STOP
        // 8-Agent Consensus Implementation
        // Adds satisfying directional "punch" toward impact point
        // with FOV zoom for visceral combat feedback
        // ============================================
        const CAMERA_PUNCH_CONFIG = {
            BASE_INTENSITY: 0.8,      // Base punch distance
            FOV_PUNCH: 8,             // FOV decrease on hit (degrees)
            PUNCH_DURATION: 120,      // ms for punch animation
            RECOVERY_SPEED: 0.15,     // Lerp factor for recovery
            FINISHER_MULT: 2.5,       // Multiplier for finisher moves
            CRIT_MULT: 1.8,           // Multiplier for critical hits
            BOSS_MULT: 3.0            // Multiplier for boss impacts
        };

        const cameraPunchState = {
            active: false,
            startTime: 0,
            targetDirection: new THREE.Vector3(),
            intensity: 0,
            fovPunch: 0,
            baseFov: 60,              // Default camera FOV
            currentFovOffset: 0,
            punchOffset: new THREE.Vector3()
        };

        // Trigger camera punch toward impact point
        function triggerCameraPunch(targetPos, options = {}) {
            if (!camera || !worldState.player) return;
            if (gameData.settings && !gameData.settings.screenShakeEnabled) return;
            if (mode !== 'world') return;

            const { isFinisher, isCrit, isBoss, isKill } = options;

            // Calculate direction from camera to target
            const direction = new THREE.Vector3();
            direction.subVectors(targetPos, camera.position).normalize();

            // Calculate intensity based on hit type
            let intensity = CAMERA_PUNCH_CONFIG.BASE_INTENSITY;
            let fovPunch = CAMERA_PUNCH_CONFIG.FOV_PUNCH;

            if (isBoss) {
                intensity *= CAMERA_PUNCH_CONFIG.BOSS_MULT;
                fovPunch *= 2;
            } else if (isFinisher) {
                intensity *= CAMERA_PUNCH_CONFIG.FINISHER_MULT;
                fovPunch *= 1.5;
            } else if (isCrit) {
                intensity *= CAMERA_PUNCH_CONFIG.CRIT_MULT;
                fovPunch *= 1.3;
            }

            // Extra punch on kills
            if (isKill) {
                intensity *= 1.4;
                fovPunch *= 1.2;
            }

            // Set punch state
            cameraPunchState.active = true;
            cameraPunchState.startTime = performance.now();
            cameraPunchState.targetDirection.copy(direction);
            cameraPunchState.intensity = intensity;
            cameraPunchState.fovPunch = fovPunch;
        }

        // Update camera punch in render loop
        function updateCameraPunch() {
            if (!cameraPunchState.active || !camera) return;

            const elapsed = performance.now() - cameraPunchState.startTime;
            const duration = CAMERA_PUNCH_CONFIG.PUNCH_DURATION;

            if (elapsed < duration) {
                // Punch phase - quick acceleration toward target
                const t = elapsed / duration;
                // Ease out cubic for snappy feel
                const easeOut = 1 - Math.pow(1 - t, 3);
                // Then ease back in for return
                const punchCurve = t < 0.3
                    ? easeOut * 3.33  // Quick punch in
                    : 1 - ((t - 0.3) / 0.7); // Smooth return

                // Apply directional offset
                const offsetMagnitude = cameraPunchState.intensity * punchCurve;
                cameraPunchState.punchOffset.copy(cameraPunchState.targetDirection)
                    .multiplyScalar(offsetMagnitude);

                camera.position.add(cameraPunchState.punchOffset);

                // FOV punch - narrow on impact, widen on return
                const fovCurve = t < 0.2
                    ? (t / 0.2)  // Quick narrow
                    : 1 - ((t - 0.2) / 0.8); // Smooth return
                cameraPunchState.currentFovOffset = -cameraPunchState.fovPunch * fovCurve;
                camera.fov = cameraPunchState.baseFov + cameraPunchState.currentFovOffset;
                camera.updateProjectionMatrix();
            } else {
                // Recovery phase - smoothly return to normal
                cameraPunchState.currentFovOffset *= (1 - CAMERA_PUNCH_CONFIG.RECOVERY_SPEED);

                if (Math.abs(cameraPunchState.currentFovOffset) > 0.1) {
                    camera.fov = cameraPunchState.baseFov + cameraPunchState.currentFovOffset;
                    camera.updateProjectionMatrix();
                } else {
                    // Fully recovered
                    camera.fov = cameraPunchState.baseFov;
                    camera.updateProjectionMatrix();
                    cameraPunchState.active = false;
                    cameraPunchState.currentFovOffset = 0;
                }
            }
        }

        // ============================================
        // v6.32: HYPERSPACE JUMP TUNNEL EFFECT
        // 8-Agent Consensus Implementation
        // Epic warp tunnel with streaking stars during transitions
        // ============================================
        const hyperspaceTunnel = {
            canvas: null,
            ctx: null,
            active: false,
            stars: [],
            animFrame: null,
            startTime: 0,
            duration: 2500,  // ms
            callback: null,
            exitCallback: null,

            // Initialize canvas
            init() {
                this.canvas = document.getElementById('hyperspace-tunnel');
                if (!this.canvas) return false;
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                return true;
            },

            resize() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            // Create stars for the tunnel effect
            createStars(count = 400) {
                this.stars = [];
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;

                for (let i = 0; i < count; i++) {
                    // Random position in a circle around center
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 0.3; // Start close to center
                    this.stars.push({
                        x: cx + Math.cos(angle) * dist * cx,
                        y: cy + Math.sin(angle) * dist * cy,
                        z: Math.random() * 1500 + 500, // Depth
                        speed: Math.random() * 0.5 + 0.5,
                        color: this.getStarColor(),
                        trail: []
                    });
                }
            },

            getStarColor() {
                const colors = [
                    '#ffffff', '#aaddff', '#88ccff', '#66bbff',
                    '#44aaff', '#00ffff', '#88ffff', '#aaffff'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            },

            // Start the hyperspace effect
            start(duration = 2500, onMidpoint = null, onComplete = null) {
                if (!this.canvas && !this.init()) return;
                if (this.active) return;

                this.active = true;
                this.duration = duration;
                this.callback = onMidpoint;
                this.exitCallback = onComplete;
                this.startTime = performance.now();
                this.createStars();

                // Fade in
                this.canvas.style.opacity = '1';

                // Play warp sound
                AudioSystem.playGentle(AudioSystem.penta.C4, 0.8, 0.15);
                setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.G4, 0.6, 0.12), 100);
                setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.C5, 0.5, 0.1), 200);

                // Start animation
                this.animate();
            },

            animate() {
                if (!this.active) return;

                const elapsed = performance.now() - this.startTime;
                const progress = elapsed / this.duration;

                // Clear canvas with slight trail effect
                this.ctx.fillStyle = 'rgba(0, 0, 10, 0.2)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;

                // Calculate warp intensity (peaks in the middle)
                const warpCurve = progress < 0.5
                    ? Math.pow(progress * 2, 2)  // Accelerate
                    : Math.pow(2 - progress * 2, 2);  // Decelerate
                const warpSpeed = 5 + warpCurve * 50;

                // Draw center glow
                const glowRadius = 50 + warpCurve * 100;
                const gradient = this.ctx.createRadialGradient(cx, cy, 0, cx, cy, glowRadius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + warpCurve * 0.4})`);
                gradient.addColorStop(0.3, `rgba(100, 200, 255, ${0.2 + warpCurve * 0.3})`);
                gradient.addColorStop(1, 'transparent');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(cx - glowRadius, cy - glowRadius, glowRadius * 2, glowRadius * 2);

                // Update and draw stars
                this.stars.forEach(star => {
                    // Store previous position for trail
                    star.trail.unshift({ x: star.x, y: star.y });
                    if (star.trail.length > 10 + warpCurve * 15) star.trail.pop();

                    // Move star toward viewer (decrease z)
                    star.z -= warpSpeed * star.speed;

                    // Reset star if it passes the viewer
                    if (star.z <= 0) {
                        const angle = Math.random() * Math.PI * 2;
                        star.x = cx;
                        star.y = cy;
                        star.z = 1500 + Math.random() * 500;
                        star.color = this.getStarColor();
                        star.trail = [];
                    }

                    // Project 3D position to 2D
                    const perspective = 400 / star.z;
                    const sx = cx + (star.x - cx) * perspective * 3;
                    const sy = cy + (star.y - cy) * perspective * 3;

                    // Draw trail
                    if (star.trail.length > 2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(sx, sy);

                        for (let i = 0; i < star.trail.length; i++) {
                            const tz = star.z + i * 15;
                            const tp = 400 / tz;
                            const tx = cx + (star.trail[i].x - cx) * tp * 3;
                            const ty = cy + (star.trail[i].y - cy) * tp * 3;
                            this.ctx.lineTo(tx, ty);
                        }

                        const alpha = Math.min(1, perspective * 2) * (0.5 + warpCurve * 0.5);
                        this.ctx.strokeStyle = star.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                        this.ctx.lineWidth = 1 + perspective * 3;
                        this.ctx.stroke();
                    }

                    // Draw star point
                    const size = Math.max(1, perspective * 4);
                    this.ctx.fillStyle = star.color;
                    this.ctx.beginPath();
                    this.ctx.arc(sx, sy, size, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Update star position for next frame
                    star.x += (star.x - cx) * 0.02 * warpSpeed * 0.1;
                    star.y += (star.y - cy) * 0.02 * warpSpeed * 0.1;
                });

                // Draw vignette
                const vignette = this.ctx.createRadialGradient(
                    cx, cy, this.canvas.width * 0.3,
                    cx, cy, this.canvas.width * 0.7
                );
                vignette.addColorStop(0, 'transparent');
                vignette.addColorStop(1, 'rgba(0, 0, 20, 0.8)');
                this.ctx.fillStyle = vignette;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Trigger midpoint callback
                if (progress >= 0.5 && this.callback) {
                    this.callback();
                    this.callback = null; // Only call once
                }

                // End effect
                if (progress >= 1) {
                    this.stop();
                    return;
                }

                this.animFrame = requestAnimationFrame(() => this.animate());
            },

            stop() {
                this.active = false;
                if (this.animFrame) {
                    cancelAnimationFrame(this.animFrame);
                    this.animFrame = null;
                }

                // Fade out
                if (this.canvas) {
                    this.canvas.style.opacity = '0';
                }

                // Clear after fade
                setTimeout(() => {
                    if (this.ctx) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                }, 300);

                // Play arrival sound
                AudioSystem.playGentle(AudioSystem.penta.G4, 0.3, 0.15);
                setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.C4, 0.4, 0.2), 100);

                // Call completion callback
                if (this.exitCallback) {
                    this.exitCallback();
                    this.exitCallback = null;
                }
            }
        };

        // Convenience function for hyperspace jump
        function triggerHyperspaceJump(duration = 2500, onMidpoint = null, onComplete = null) {
            hyperspaceTunnel.start(duration, onMidpoint, onComplete);
        }

        // ============================================
        // v6.33: HEARTBEAT WORLD PULSE SYSTEM
        // 8-Agent Consensus Synaesthetic Effect
        // World visually pulses in sync with low-HP heartbeat
        // Creates tunnel vision, desaturation, and red vignette
        // ============================================
        const heartbeatWorldPulse = {
            active: false,
            pulsePhase: 0,
            lastHpPercent: 1,

            // Initialize the visual callback
            init() {
                AudioSystem.heartbeatVisualCallback = (hpPercent) => {
                    this.triggerPulse(hpPercent);
                };
            },

            // Trigger a single heartbeat pulse
            triggerPulse(hpPercent) {
                if (mode !== 'world') return;
                this.active = true;
                this.pulsePhase = 1;
                this.lastHpPercent = hpPercent;

                // Intensity scales inversely with HP (lower HP = stronger effect)
                const intensity = 1 - hpPercent;

                // Apply visual effects
                this.applyScreenPulse(intensity);
                this.applyWorldDimming(intensity);
                this.applyCameraContraction(intensity);
            },

            // Red vignette pulse synchronized with heartbeat
            applyScreenPulse(intensity) {
                const overlay = document.getElementById('damage-overlay');
                if (!overlay) return;

                // Create pulsing red vignette
                const alpha = 0.15 + intensity * 0.25;
                overlay.style.background = `radial-gradient(ellipse at center, transparent 20%, rgba(80,0,0,${alpha}) 70%, rgba(120,0,0,${alpha * 1.3}) 100%)`;
                overlay.style.opacity = '1';

                // Pulse out over 400ms
                setTimeout(() => {
                    overlay.style.opacity = '0.5';
                    setTimeout(() => {
                        overlay.style.opacity = '0';
                    }, 200);
                }, 200);
            },

            // Dim distant objects during pulse (tunnel vision effect)
            applyWorldDimming(intensity) {
                if (!scene || !scene.fog) return;

                // Store original fog if not stored
                if (!this._originalFogFar) {
                    this._originalFogFar = scene.fog.far;
                    this._originalFogNear = scene.fog.near;
                }

                // Contract fog during pulse (tunnel vision)
                const fogContract = intensity * 0.3;
                scene.fog.far = this._originalFogFar * (1 - fogContract);
                scene.fog.near = this._originalFogNear * (1 - fogContract * 0.5);

                // Return to normal over 400ms
                setTimeout(() => {
                    if (scene && scene.fog) {
                        scene.fog.far = this._originalFogFar;
                        scene.fog.near = this._originalFogNear;
                    }
                }, 400);
            },

            // Slight camera zoom/contract on heartbeat
            applyCameraContraction(intensity) {
                if (!camera) return;

                // Store base FOV
                const baseFov = cameraPunchState.baseFov || 60;

                // Brief FOV reduction (tunnel vision feeling)
                const fovReduction = intensity * 3;
                camera.fov = baseFov - fovReduction;
                camera.updateProjectionMatrix();

                // Ease back to normal
                setTimeout(() => {
                    camera.fov = baseFov - fovReduction * 0.5;
                    camera.updateProjectionMatrix();
                    setTimeout(() => {
                        camera.fov = baseFov;
                        camera.updateProjectionMatrix();
                    }, 200);
                }, 200);
            },

            // Reset all effects when HP recovers
            reset() {
                this.active = false;
                this.pulsePhase = 0;
                if (this._originalFogFar && scene && scene.fog) {
                    scene.fog.far = this._originalFogFar;
                    scene.fog.near = this._originalFogNear;
                }
            }
        };

        // Initialize heartbeat world pulse when game starts
        setTimeout(() => heartbeatWorldPulse.init(), 1000);

        // ============================================
        // v6.33: COMBO CHROMATIC CRESCENDO SYSTEM
        // 8-Agent Consensus Feature
        // Each combo hit shifts through color spectrum
        // Creates rainbow satisfaction feedback
        // ============================================
        const comboChromaticSystem = {
            // Color progression through spectrum per combo
            colors: [
                { r: 255, g: 60, b: 60 },    // Hit 1: Red
                { r: 255, g: 140, b: 0 },    // Hit 2: Orange
                { r: 255, g: 220, b: 0 },    // Hit 3: Yellow
                { r: 60, g: 255, b: 100 },   // Hit 4: Green
                { r: 0, g: 220, b: 255 }     // Hit 5+: Cyan (finisher)
            ],

            // Get color for combo count
            getComboColor(comboCount) {
                const idx = Math.min(comboCount, this.colors.length - 1);
                return this.colors[idx];
            },

            // Get CSS color string
            getComboColorCSS(comboCount) {
                const c = this.getComboColor(comboCount);
                return `rgb(${c.r}, ${c.g}, ${c.b})`;
            },

            // Get hex color for Three.js
            getComboColorHex(comboCount) {
                const c = this.getComboColor(comboCount);
                return (c.r << 16) | (c.g << 8) | c.b;
            },

            // Apply aura glow effect to player
            applyPlayerAura(comboCount) {
                if (!worldState.player) return;

                const color = this.getComboColorHex(comboCount);
                const intensity = 0.3 + comboCount * 0.15;

                // Apply emissive glow to player mesh
                worldState.player.traverse(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(color);
                        child.material.emissiveIntensity = intensity;
                    }
                });

                // Fade out over time
                setTimeout(() => {
                    if (!worldState.player) return;
                    worldState.player.traverse(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissiveIntensity *= 0.5;
                        }
                    });
                }, 300);
            },

            // Create chromatic flash overlay
            triggerChromaticFlash(comboCount) {
                const flash = document.getElementById('victory-flash');
                if (!flash) return;

                const color = this.getComboColor(comboCount);
                const alpha = 0.15 + comboCount * 0.05;

                flash.style.background = `radial-gradient(ellipse at center, rgba(${color.r},${color.g},${color.b},${alpha}) 0%, transparent 60%)`;
                flash.style.opacity = '1';
                setTimeout(() => flash.style.opacity = '0', 100);
            },

            // Emit chromatic particles
            emitChromaticParticles(position, comboCount) {
                if (!particles) return;

                const color = this.getComboColorHex(comboCount);
                const count = 3 + comboCount * 2;

                particles.emit(position, count, color, {
                    spread: 2 + comboCount * 0.5,
                    lifetime: 400 + comboCount * 100,
                    size: 0.15 + comboCount * 0.03
                });
            },

            // Full combo effect package
            triggerComboEffect(comboCount, position) {
                this.applyPlayerAura(comboCount);
                this.triggerChromaticFlash(comboCount);
                if (position) {
                    this.emitChromaticParticles(position, comboCount);
                }
            },

            // Reset player aura when combo breaks
            resetAura() {
                if (!worldState.player) return;
                worldState.player.traverse(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissiveIntensity = 0;
                    }
                });
            }
        };

        // ============================================
        // v6.33: SYNAPTIC BASS DROP COMBAT
        // 8-Agent Consensus Feature
        // Dramatic kill satisfaction effect
        // ============================================
        const synapticBassDrop = {
            // Trigger bass drop effect on kill
            trigger(position, isBoss = false) {
                if (mode !== 'world') return;

                // 1. Audio silence then bass thump
                this.audioEffect(isBoss);

                // 2. Screen compression
                this.screenCompression(isBoss);

                // 3. Radial shockwave particles
                this.shockwaveParticles(position, isBoss);

                // 4. Time freeze micro-hitstop
                this.microFreeze(isBoss);
            },

            audioEffect(isBoss) {
                // Brief silence (50ms), then deep bass
                AudioSystem.masterVolume = 0;
                setTimeout(() => {
                    AudioSystem.masterVolume = 0.2;
                    // Deep bass thump
                    AudioSystem.playGentle(AudioSystem.penta.C3 / 2, 0.5, isBoss ? 0.4 : 0.25);
                    if (isBoss) {
                        setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.G3 / 2, 0.4, 0.2), 100);
                    }
                }, 50);
            },

            screenCompression(isBoss) {
                const container = document.getElementById('container');
                if (!container) return;

                // Compress screen briefly
                const scale = isBoss ? 0.97 : 0.985;
                container.style.transform = `scale(${scale})`;
                container.style.transition = 'transform 0.05s ease-out';

                // Expand back with bounce
                setTimeout(() => {
                    container.style.transform = 'scale(1.01)';
                    setTimeout(() => {
                        container.style.transform = 'scale(1)';
                        container.style.transition = '';
                    }, 100);
                }, 50);
            },

            shockwaveParticles(position, isBoss) {
                if (!particles || !position) return;

                // Radial burst of white particles
                const count = isBoss ? 40 : 20;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const offset = new THREE.Vector3(
                        Math.cos(angle) * 0.5,
                        0.1,
                        Math.sin(angle) * 0.5
                    );
                    particles.emit(
                        position.clone().add(offset),
                        1,
                        0xffffff,
                        { spread: 0.5, lifetime: 300, size: 0.2 }
                    );
                }
            },

            microFreeze(isBoss) {
                // Extended hit-stop for bass drop effect
                const duration = isBoss ? 120 : 60;
                triggerHitStop(duration);
            }
        };

        // ============================================
        // v6.33: FUTURE GHOST COMBAT TELEGRAPH
        // 8-Agent Consensus Feature
        // Shows premonition of player death when lethal attack incoming
        // "See your death to prevent it"
        // ============================================
        const futureGhostTelegraph = {
            ghostOverlay: null,
            isShowing: false,
            lastWarningTime: 0,
            warningCooldown: 2000, // Don't spam warnings

            // Calculate if incoming attack would be lethal
            wouldBeLethal(incomingDamage) {
                const defense = typeof getPlayerDefense === 'function' ? getPlayerDefense() : 0;
                const actualDamage = Math.max(1, incomingDamage - defense);
                return gameData.player.hp <= actualDamage;
            },

            // Create ghost overlay element if needed
            ensureOverlay() {
                if (this.ghostOverlay) return;

                this.ghostOverlay = document.createElement('div');
                this.ghostOverlay.id = 'ghost-telegraph';
                this.ghostOverlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    pointer-events: none;
                    z-index: 9999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: transparent;
                    opacity: 0;
                    transition: opacity 0.15s;
                `;
                this.ghostOverlay.innerHTML = `
                    <div class="ghost-skull" style="
                        font-size: 200px;
                        color: rgba(255, 0, 0, 0);
                        text-shadow: 0 0 50px rgba(255, 0, 0, 0.8), 0 0 100px rgba(255, 0, 0, 0.5);
                        transform: scale(0.5);
                        transition: all 0.3s ease-out;
                        filter: blur(2px);
                    "></div>
                    <div class="ghost-text" style="
                        position: absolute;
                        bottom: 30%;
                        font-size: 48px;
                        color: rgba(255, 50, 50, 0);
                        text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
                        font-family: monospace;
                        font-weight: bold;
                        letter-spacing: 10px;
                        transition: all 0.3s ease-out;
                    ">DODGE!</div>
                `;
                document.body.appendChild(this.ghostOverlay);
            },

            // Show the ghost premonition warning
            showDeathPremonition(attackerPosition) {
                if (mode !== 'world') return;

                const now = Date.now();
                if (now - this.lastWarningTime < this.warningCooldown) return;
                this.lastWarningTime = now;

                this.ensureOverlay();
                this.isShowing = true;

                // Pulsing red vignette overlay
                const container = document.getElementById('game-container');
                if (container) {
                    container.style.boxShadow = 'inset 0 0 150px rgba(255, 0, 0, 0.6)';
                }

                // Flash the ghost
                this.ghostOverlay.style.opacity = '1';
                this.ghostOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,0,0,0.5) 0%, transparent 70%)';

                const skull = this.ghostOverlay.querySelector('.ghost-skull');
                const text = this.ghostOverlay.querySelector('.ghost-text');

                if (skull) {
                    skull.style.color = 'rgba(255, 0, 0, 0.3)';
                    skull.style.transform = 'scale(1.2)';
                    skull.style.filter = 'blur(0px)';
                }
                if (text) {
                    text.style.color = 'rgba(255, 50, 50, 0.9)';
                }

                // Play warning sound - dramatic low tone
                if (AudioSystem && AudioSystem.penta) {
                    AudioSystem.playGentle(AudioSystem.penta.C3 / 4, 0.4, 0.15);
                    setTimeout(() => {
                        AudioSystem.playGentle(AudioSystem.penta.C3 / 3, 0.3, 0.1);
                    }, 100);
                }

                // Directional indicator toward attacker
                if (attackerPosition && worldState.player) {
                    this.showDirectionalSkull(attackerPosition);
                }

                // Fade out after warning displayed
                setTimeout(() => {
                    this.hidePremonition();
                }, 800);
            },

            // Show directional indicator toward attacker
            showDirectionalSkull(attackerPosition) {
                if (!worldState.player || !camera) return;

                // Calculate screen-space direction to attacker
                const playerPos = worldState.player.position;
                const dir = attackerPosition.clone().sub(playerPos).normalize();

                // Create small directional skull indicator
                const indicator = document.createElement('div');
                indicator.className = 'ghost-direction';
                indicator.style.cssText = `
                    position: fixed;
                    font-size: 48px;
                    pointer-events: none;
                    z-index: 10000;
                    animation: pulse-ghost 0.3s ease-out;
                `;
                indicator.textContent = '';

                // Position on edge of screen based on direction
                const angle = Math.atan2(dir.x, dir.z);
                const screenAngle = angle - camera.rotation.y;
                const edgeX = 50 + Math.sin(screenAngle) * 40;
                const edgeY = 50 - Math.cos(screenAngle) * 35;

                indicator.style.left = `${Math.max(5, Math.min(90, edgeX))}%`;
                indicator.style.top = `${Math.max(10, Math.min(85, edgeY))}%`;
                indicator.style.transform = 'translate(-50%, -50%)';
                indicator.style.color = 'rgba(255, 0, 0, 0.8)';
                indicator.style.textShadow = '0 0 20px red';

                document.body.appendChild(indicator);

                // Remove after animation
                setTimeout(() => indicator.remove(), 600);
            },

            // Hide the premonition
            hidePremonition() {
                this.isShowing = false;

                const container = document.getElementById('game-container');
                if (container) {
                    container.style.boxShadow = '';
                }

                if (this.ghostOverlay) {
                    this.ghostOverlay.style.opacity = '0';
                    this.ghostOverlay.style.background = 'transparent';

                    const skull = this.ghostOverlay.querySelector('.ghost-skull');
                    const text = this.ghostOverlay.querySelector('.ghost-text');

                    if (skull) {
                        skull.style.color = 'rgba(255, 0, 0, 0)';
                        skull.style.transform = 'scale(0.5)';
                        skull.style.filter = 'blur(2px)';
                    }
                    if (text) {
                        text.style.color = 'rgba(255, 50, 50, 0)';
                    }
                }
            },

            // Check incoming attack and show warning if lethal
            checkAttack(incomingDamage, attackerPosition) {
                if (this.wouldBeLethal(incomingDamage)) {
                    this.showDeathPremonition(attackerPosition);
                    return true; // Attack is lethal
                }
                return false; // Attack is survivable
            }
        };

        // Add CSS animation for ghost pulse
        const ghostStyle = document.createElement('style');
        ghostStyle.textContent = `
            @keyframes pulse-ghost {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            }
        `;
        document.head.appendChild(ghostStyle);

        // ============================================
        // v6.35: BROWSER TAB CONSCIOUSNESS
        // 8-Agent Consensus Feature (4/8 strategies)
        // The game is aware when you leave and return
        // Creates eerie "the game knows you exist" moments
        // ============================================
        const tabConsciousness = {
            isVisible: true,
            lastHiddenTime: null,
            originalTitle: document.title,
            tabSwitchCount: 0,
            totalAwayTime: 0,
            messages: [
                "...waiting",
                "The void grows stronger",
                "Come back",
                "I can wait",
                "Are you there?",
                "LEVIATHAN remembers",
                "Time passes differently here",
                "The stars miss you"
            ],
            messageIndex: 0,
            titleInterval: null,

            init() {
                document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
                window.addEventListener('blur', () => this.handleBlur());
                window.addEventListener('focus', () => this.handleFocus());
            },

            handleVisibilityChange() {
                if (document.hidden) {
                    this.onHide();
                } else {
                    this.onShow();
                }
            },

            handleBlur() {
                if (!document.hidden) {
                    this.onHide();
                }
            },

            handleFocus() {
                this.onShow();
            },

            onHide() {
                if (!this.isVisible) return;
                this.isVisible = false;
                this.lastHiddenTime = Date.now();
                this.tabSwitchCount++;

                // Start cycling through messages in tab title
                this.titleInterval = setInterval(() => {
                    this.messageIndex = (this.messageIndex + 1) % this.messages.length;
                    document.title = this.messages[this.messageIndex];
                }, 3000);

                // Immediate first message
                document.title = "...don't leave";
            },

            onShow() {
                if (this.isVisible) return;
                this.isVisible = true;

                // Stop title cycling
                if (this.titleInterval) {
                    clearInterval(this.titleInterval);
                    this.titleInterval = null;
                }

                // Calculate time away
                const awayDuration = this.lastHiddenTime ? Date.now() - this.lastHiddenTime : 0;
                this.totalAwayTime += awayDuration;

                // Restore title
                document.title = this.originalTitle;

                // React to return based on how long player was away
                this.reactToReturn(awayDuration);
            },

            reactToReturn(awayDuration) {
                const secondsAway = Math.floor(awayDuration / 1000);

                if (secondsAway < 5) return; // Ignore brief tab switches

                // Show notification based on duration
                let message;
                if (secondsAway > 300) { // 5+ minutes
                    message = `The void watched over your absence. ${Math.floor(secondsAway / 60)} minutes have passed.`;
                    // Subtle world change - spawn a watcher entity nearby
                    this.spawnWatcher();
                } else if (secondsAway > 60) { // 1-5 minutes
                    message = `${secondsAway} seconds in your time... eons in the Omniverse.`;
                } else if (secondsAway > 10) {
                    const returnMessages = [
                        "You returned. The Leviathan stirs.",
                        "We knew you'd come back.",
                        "Time moves strangely when you're away.",
                        "The void remembers your absence."
                    ];
                    message = returnMessages[Math.floor(Math.random() * returnMessages.length)];
                }

                if (message && typeof showNotification === 'function') {
                    setTimeout(() => showNotification(message, 'info'), 500);
                }

                // Track cumulative switches for later meta-awareness
                if (this.tabSwitchCount >= 10 && this.tabSwitchCount % 10 === 0) {
                    setTimeout(() => {
                        showNotification(`You have left ${this.tabSwitchCount} times. We notice patterns.`, 'info');
                    }, 2000);
                }
            },

            spawnWatcher() {
                // Only in world mode
                if (mode !== 'world' || !worldState.player) return;

                // Create a brief, eerie visual - a dark shape at the edge of vision
                const watcherNotice = document.createElement('div');
                watcherNotice.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 10%;
                    transform: translateY(-50%);
                    width: 50px;
                    height: 150px;
                    background: radial-gradient(ellipse at center, rgba(20,0,40,0.8) 0%, transparent 70%);
                    pointer-events: none;
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 2s ease-in-out;
                `;
                document.body.appendChild(watcherNotice);

                // Fade in briefly, then disappear
                setTimeout(() => watcherNotice.style.opacity = '0.6', 100);
                setTimeout(() => {
                    watcherNotice.style.opacity = '0';
                    setTimeout(() => watcherNotice.remove(), 2000);
                }, 3000);
            }
        };

        // Initialize tab consciousness
        setTimeout(() => tabConsciousness.init(), 1000);

        // ============================================
        // v6.35: ENEMY PREMONITION GHOST
        // 8-Agent Consensus Feature (4/8 strategies)
        // See a ghost of the enemy's FUTURE attack
        // Shows where they WILL be, not where they ARE
        // ============================================
        const enemyPremonition = {
            activeGhosts: [],
            maxGhosts: 5,

            // Create premonition ghost showing future attack position
            showPremonition(enemy, attackType) {
                if (mode !== 'world' || !enemy || !enemy.position) return;
                if (this.activeGhosts.length >= this.maxGhosts) return;

                // Calculate future position (where enemy will strike)
                const futurePos = enemy.position.clone();
                if (worldState.player) {
                    // Enemy will move toward player
                    const dir = worldState.player.position.clone().sub(enemy.position).normalize();
                    const attackRange = enemy.userData?.attackRange || 2;
                    futurePos.add(dir.multiplyScalar(attackRange * 0.8));
                }

                // Create ghost mesh (translucent copy)
                const ghostMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0044,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });

                let ghostMesh;
                if (enemy.geometry) {
                    ghostMesh = new THREE.Mesh(enemy.geometry.clone(), ghostMaterial);
                } else {
                    // Fallback simple shape
                    ghostMesh = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5, 8, 8),
                        ghostMaterial
                    );
                }

                ghostMesh.position.copy(futurePos);
                ghostMesh.position.y += 0.5; // Slight hover
                ghostMesh.scale.copy(enemy.scale);

                // Add pulsing animation data
                ghostMesh.userData = {
                    startTime: performance.now(),
                    duration: 800,
                    baseOpacity: 0.3
                };

                scene.add(ghostMesh);
                this.activeGhosts.push(ghostMesh);

                // Auto-remove after duration
                setTimeout(() => this.removeGhost(ghostMesh), 800);

                // Play subtle warning tone
                if (AudioSystem && AudioSystem.penta) {
                    AudioSystem.playGentle(AudioSystem.penta.E4 * 2, 0.15, 0.05);
                }
            },

            // Update ghost animations
            update() {
                const now = performance.now();
                for (const ghost of this.activeGhosts) {
                    if (!ghost.userData) continue;
                    const elapsed = now - ghost.userData.startTime;
                    const progress = elapsed / ghost.userData.duration;

                    // Pulse opacity
                    const pulse = Math.sin(progress * Math.PI * 4) * 0.2;
                    ghost.material.opacity = ghost.userData.baseOpacity + pulse;

                    // Slight scale pulse
                    const scalePulse = 1 + Math.sin(progress * Math.PI * 2) * 0.1;
                    ghost.scale.setScalar(scalePulse);
                }
            },

            removeGhost(ghost) {
                const idx = this.activeGhosts.indexOf(ghost);
                if (idx !== -1) {
                    this.activeGhosts.splice(idx, 1);
                }
                if (ghost.parent) {
                    ghost.parent.remove(ghost);
                }
                if (ghost.geometry) ghost.geometry.dispose();
                if (ghost.material) ghost.material.dispose();
            },

            cleanup() {
                for (const ghost of [...this.activeGhosts]) {
                    this.removeGhost(ghost);
                }
            }
        };

        // ============================================
        // v6.35: CHRONO-ECHO COMBAT
        // 8-Agent Consensus Feature (5/8 strategies)
        // Past actions replay as ghost clones
        // Your attacks echo 2 seconds later
        // ============================================
        const chronoEcho = {
            enabled: true,
            echoDelay: 2000, // 2 second delay
            actionBuffer: [], // Records player actions
            maxBufferSize: 50,
            activeEchoes: [],

            // Record a player action
            recordAction(actionType, data) {
                if (!this.enabled || mode !== 'world') return;

                this.actionBuffer.push({
                    type: actionType,
                    data: { ...data },
                    timestamp: performance.now(),
                    playerPos: worldState.player ? worldState.player.position.clone() : null
                });

                // Trim buffer
                if (this.actionBuffer.length > this.maxBufferSize) {
                    this.actionBuffer.shift();
                }

                // Schedule echo playback
                setTimeout(() => this.playbackEcho(actionType, data), this.echoDelay);
            },

            // Playback an echoed action
            playbackEcho(actionType, data) {
                if (mode !== 'world' || !worldState.player) return;

                switch (actionType) {
                    case 'attack':
                        this.echoAttack(data);
                        break;
                    case 'ability':
                        this.echoAbility(data);
                        break;
                }
            },

            // Echo an attack - creates ghost damage
            echoAttack(data) {
                if (!data.targetPos) return;

                // Visual: ghost slash effect
                this.spawnEchoVisual(data.targetPos);

                // Find enemies near the echo position
                const echoRange = 3;
                const echoDamage = Math.floor((data.damage || 5) * 0.5); // 50% echo damage

                for (const mob of worldState.mobs) {
                    if (!mob.userData || mob.userData.hp <= 0) continue;
                    const dist = mob.position.distanceTo(data.targetPos);
                    if (dist < echoRange) {
                        // Apply echo damage
                        mob.userData.hp -= echoDamage;
                        spawnFloater(mob.position, `ECHO -${echoDamage}`, '#8888ff');

                        // Update health bar
                        if (mob.userData.hpBar) {
                            const hpPercent = mob.userData.hp / mob.userData.maxHp;
                            mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                        }

                        // Play echo sound
                        if (AudioSystem && AudioSystem.penta) {
                            AudioSystem.playGentle(AudioSystem.penta.G4, 0.15, 0.08);
                        }
                    }
                }
            },

            // Echo an ability
            echoAbility(data) {
                // Visual only for abilities - too complex to fully replicate
                if (data.position) {
                    this.spawnEchoVisual(data.position, true);
                }
            },

            // Spawn visual echo effect
            spawnEchoVisual(position, isAbility = false) {
                if (!position) return;

                // Create ghostly ring effect
                const ringGeo = new THREE.RingGeometry(0.5, 1.5, 16);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: isAbility ? 0x44ffff : 0x8888ff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(position);
                ring.position.y += 0.1;
                ring.rotation.x = -Math.PI / 2;

                ring.userData = {
                    startTime: performance.now(),
                    duration: 500
                };

                scene.add(ring);
                this.activeEchoes.push(ring);

                // Particles
                if (particles) {
                    particles.emit(position, 8, isAbility ? 0x44ffff : 0x8888ff, {
                        spread: 2,
                        lifetime: 400,
                        size: 0.1
                    });
                }

                // Auto cleanup
                setTimeout(() => {
                    const idx = this.activeEchoes.indexOf(ring);
                    if (idx !== -1) this.activeEchoes.splice(idx, 1);
                    if (ring.parent) ring.parent.remove(ring);
                    ringGeo.dispose();
                    ringMat.dispose();
                }, 500);
            },

            // Update echo visuals
            update() {
                const now = performance.now();
                for (const echo of this.activeEchoes) {
                    if (!echo.userData) continue;
                    const progress = (now - echo.userData.startTime) / echo.userData.duration;

                    // Expand and fade
                    echo.scale.setScalar(1 + progress * 2);
                    echo.material.opacity = 0.6 * (1 - progress);
                }
            }
        };

        // ============================================
        // v6.35: COMBO CRESCENDO ORCHESTRA
        // 8-Agent Consensus Feature (4/8 strategies)
        // Combat performance composes music in real-time
        // Higher combos add more instrument layers
        // ============================================
        const comboCrescendo = {
            layers: {
                bass: null,
                harmony: null,
                melody: null,
                percussion: null
            },
            currentCombo: 0,
            lastNoteTime: 0,
            noteInterval: 250, // ms between notes
            scale: null, // Will use AudioSystem.penta

            // Initialize (called when entering combat)
            startCombat() {
                this.currentCombo = 0;
                this.stopAllLayers();
            },

            // Update based on combo count
            updateCombo(comboCount) {
                if (!AudioSystem || !AudioSystem.penta) return;
                this.scale = AudioSystem.penta;
                this.currentCombo = comboCount;

                const now = performance.now();
                if (now - this.lastNoteTime < this.noteInterval) return;
                this.lastNoteTime = now;

                // Layer 1: Base hits (always)
                this.playBaseHit(comboCount);

                // Layer 2: Harmony (5+ combo)
                if (comboCount >= 5) {
                    this.playHarmony(comboCount);
                }

                // Layer 3: Melody (10+ combo)
                if (comboCount >= 10) {
                    this.playMelody(comboCount);
                }

                // Layer 4: Percussion accent (15+ combo)
                if (comboCount >= 15) {
                    this.playPercussion(comboCount);
                }

                // Layer 5: Full crescendo (25+ combo)
                if (comboCount >= 25 && comboCount % 5 === 0) {
                    this.playFullCrescendo();
                }
            },

            playBaseHit(combo) {
                // Ascending notes based on combo
                const noteIndex = combo % 5;
                const notes = [this.scale.C3, this.scale.D3, this.scale.E3, this.scale.G3, this.scale.A3];
                AudioSystem.playGentle(notes[noteIndex], 0.12, 0.08);
            },

            playHarmony(combo) {
                // Add fifth harmony
                const noteIndex = combo % 5;
                const notes = [this.scale.G3, this.scale.A3, this.scale.C4, this.scale.D4, this.scale.E4];
                setTimeout(() => {
                    AudioSystem.playGentle(notes[noteIndex], 0.08, 0.06);
                }, 50);
            },

            playMelody(combo) {
                // Higher octave melody
                const noteIndex = combo % 5;
                const notes = [this.scale.C4, this.scale.E4, this.scale.G4, this.scale.A4, this.scale.C4 * 2];
                setTimeout(() => {
                    AudioSystem.playGentle(notes[noteIndex], 0.1, 0.1);
                }, 100);
            },

            playPercussion(combo) {
                // Rhythmic accent using noise-like tones
                const freq = 80 + (combo % 4) * 20;
                AudioSystem.playGentle(freq, 0.05, 0.02);
            },

            playFullCrescendo() {
                // Dramatic chord swell
                const chord = [this.scale.C3, this.scale.E3, this.scale.G3, this.scale.C4];
                chord.forEach((note, i) => {
                    setTimeout(() => {
                        AudioSystem.playGentle(note, 0.15, 0.15);
                    }, i * 30);
                });
            },

            // Called when combo breaks - dramatic resolution
            comboBreak(finalCombo) {
                if (!AudioSystem || !AudioSystem.penta || finalCombo < 5) return;

                // Descending resolution
                const resolution = [
                    this.scale.G4,
                    this.scale.E4,
                    this.scale.D4,
                    this.scale.C4,
                    this.scale.C3
                ];

                resolution.forEach((note, i) => {
                    setTimeout(() => {
                        const volume = 0.15 - i * 0.02;
                        AudioSystem.playGentle(note, 0.2, Math.max(0.05, volume));
                    }, i * 100);
                });
            },

            stopAllLayers() {
                // Cleanup any sustained tones
                this.currentCombo = 0;
            }
        };

        // ============================================
        // v6.36: IMPACT SCREEN SHAKE SYSTEM
        // Camera shake proportional to damage dealt/received
        // Consensus feature from Round 3 strategy analysis
        // ============================================
        const impactShake = {
            enabled: true,
            intensity: 0,
            decay: 0.92,
            maxIntensity: 15,
            shakeOffset: { x: 0, y: 0 },

            // Trigger shake based on damage
            triggerDamageDealt(damage) {
                if (!this.enabled) return;
                // Scale shake by damage - big hits = big shake
                const intensity = Math.min(damage * 0.8, this.maxIntensity * 0.6);
                this.intensity = Math.max(this.intensity, intensity);
            },

            triggerDamageReceived(damage) {
                if (!this.enabled) return;
                // Taking damage shakes more than dealing it
                const intensity = Math.min(damage * 1.2, this.maxIntensity);
                this.intensity = Math.max(this.intensity, intensity);
            },

            triggerKill() {
                if (!this.enabled) return;
                // Satisfying kill shake
                this.intensity = Math.max(this.intensity, 8);
            },

            triggerBossHit() {
                if (!this.enabled) return;
                // Boss hits feel massive
                this.intensity = Math.max(this.intensity, 12);
            },

            update() {
                if (this.intensity > 0.1) {
                    // Random directional shake
                    this.shakeOffset.x = (Math.random() - 0.5) * this.intensity * 2;
                    this.shakeOffset.y = (Math.random() - 0.5) * this.intensity * 2;
                    this.intensity *= this.decay;

                    // Apply to camera or container
                    const container = document.getElementById('container');
                    if (container) {
                        container.style.transform = `translate(${this.shakeOffset.x}px, ${this.shakeOffset.y}px)`;
                    }
                } else {
                    this.intensity = 0;
                    this.shakeOffset.x = 0;
                    this.shakeOffset.y = 0;
                    const container = document.getElementById('container');
                    if (container) {
                        container.style.transform = '';
                    }
                }
            }
        };

        // ============================================
        // v6.36: PERSONAL RECORDS DASHBOARD
        // Track all-time stats, best combos, fastest kills
        // Consensus feature from Round 3 strategy analysis
        // ============================================
        const personalRecords = {
            storageKey: 'leviathan-records-v1',
            records: null,

            // v6.84: Added error handling for corrupted records data
            init() {
                const saved = localStorage.getItem(this.storageKey);
                const defaultRecords = {
                    totalKills: 0,
                    totalDamageDealt: 0,
                    totalDamageTaken: 0,
                    highestCombo: 0,
                    fastestBossKill: Infinity,
                    longestSession: 0,
                    totalPlayTime: 0,
                    planetsConquered: 0,
                    bestSingleHit: 0,
                    totalDeaths: 0,
                    dailyKills: 0,
                    lastPlayDate: null,
                    currentStreak: 0,
                    bestStreak: 0,
                    sessionsPlayed: 0
                };
                if (saved) {
                    try {
                        this.records = JSON.parse(saved);
                    } catch (e) {
                        console.warn('Personal records corrupted, resetting:', e);
                        this.records = defaultRecords;
                    }
                } else {
                    this.records = defaultRecords;
                }
                this.sessionStart = Date.now();

                // Check daily reset
                const today = new Date().toDateString();
                if (this.records.lastPlayDate !== today) {
                    if (this.records.lastPlayDate) {
                        const lastDate = new Date(this.records.lastPlayDate);
                        const todayDate = new Date(today);
                        const daysDiff = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));

                        if (daysDiff === 1) {
                            this.records.currentStreak++;
                            if (this.records.currentStreak > this.records.bestStreak) {
                                this.records.bestStreak = this.records.currentStreak;
                                this.showStreakAchievement();
                            }
                        } else if (daysDiff > 1) {
                            this.records.currentStreak = 1;
                        }
                    } else {
                        this.records.currentStreak = 1;
                    }
                    this.records.dailyKills = 0;
                    this.records.lastPlayDate = today;
                }

                this.records.sessionsPlayed++;
                this.save();
            },

            save() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.records));
            },

            recordKill() {
                this.records.totalKills++;
                this.records.dailyKills++;
                this.save();
            },

            recordDamageDealt(amount) {
                this.records.totalDamageDealt += amount;
                if (amount > this.records.bestSingleHit) {
                    this.records.bestSingleHit = amount;
                    this.showNewRecord('BEST HIT', amount);
                }
                this.save();
            },

            recordCombo(combo) {
                if (combo > this.records.highestCombo) {
                    this.records.highestCombo = combo;
                    this.showNewRecord('HIGHEST COMBO', combo);
                }
                this.save();
            },

            recordDeath() {
                this.records.totalDeaths++;
                this.save();
            },

            recordPlanetConquered() {
                this.records.planetsConquered++;
                this.save();
            },

            updateSessionTime() {
                const sessionLength = Math.floor((Date.now() - this.sessionStart) / 1000);
                this.records.totalPlayTime += 1; // Add 1 second
                if (sessionLength > this.records.longestSession) {
                    this.records.longestSession = sessionLength;
                }
                this.save();
            },

            showNewRecord(type, value) {
                const recordDiv = document.createElement('div');
                recordDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(255,165,0,0.9));
                    color: #000;
                    padding: 20px 40px;
                    border-radius: 10px;
                    font-size: 24px;
                    font-weight: bold;
                    z-index: 10000;
                    text-align: center;
                    animation: recordPulse 0.5s ease-out;
                    box-shadow: 0 0 30px rgba(255,215,0,0.8);
                `;
                recordDiv.innerHTML = `
                    <div style="font-size: 14px; margin-bottom: 5px;"> NEW RECORD!</div>
                    <div>${type}</div>
                    <div style="font-size: 36px; color: #8B0000;">${value}</div>
                `;
                document.body.appendChild(recordDiv);

                setTimeout(() => {
                    recordDiv.style.opacity = '0';
                    recordDiv.style.transition = 'opacity 0.5s';
                    setTimeout(() => recordDiv.remove(), 500);
                }, 2000);
            },

            showStreakAchievement() {
                const streakDiv = document.createElement('div');
                streakDiv.style.cssText = `
                    position: fixed;
                    top: 30%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, rgba(255,100,0,0.9), rgba(255,50,0,0.9));
                    color: #fff;
                    padding: 15px 30px;
                    border-radius: 10px;
                    font-size: 20px;
                    font-weight: bold;
                    z-index: 10000;
                    text-align: center;
                    animation: recordPulse 0.5s ease-out;
                `;
                streakDiv.innerHTML = ` ${this.records.currentStreak} DAY STREAK! `;
                document.body.appendChild(streakDiv);
                setTimeout(() => {
                    streakDiv.style.opacity = '0';
                    streakDiv.style.transition = 'opacity 0.5s';
                    setTimeout(() => streakDiv.remove(), 500);
                }, 2500);
            },

            getStatsDisplay() {
                const hours = Math.floor(this.records.totalPlayTime / 3600);
                const mins = Math.floor((this.records.totalPlayTime % 3600) / 60);
                return {
                    'Total Kills': this.records.totalKills.toLocaleString(),
                    'Best Combo': this.records.highestCombo,
                    'Best Hit': this.records.bestSingleHit,
                    'Planets': this.records.planetsConquered,
                    'Play Time': `${hours}h ${mins}m`,
                    'Day Streak': ` ${this.records.currentStreak}`,
                    'Best Streak': this.records.bestStreak,
                    'Sessions': this.records.sessionsPlayed
                };
            }
        };

        // ============================================
        // v6.36: DAILY CHALLENGE SYSTEM
        // Rotating challenges with streak bonuses
        // Consensus feature from Round 3 strategy analysis
        // ============================================
        const dailyChallenges = {
            storageKey: 'leviathan-daily-v1',
            challenges: [],

            challengeTemplates: [
                { id: 'kills', name: 'Slayer', desc: 'Defeat {target} enemies', targets: [25, 50, 100], icon: '' },
                { id: 'combo', name: 'Combo Master', desc: 'Reach a {target}x combo', targets: [15, 25, 50], icon: '' },
                { id: 'damage', name: 'Heavy Hitter', desc: 'Deal {target} total damage', targets: [500, 1000, 2500], icon: '' },
                { id: 'nodeath', name: 'Untouchable', desc: 'Kill {target} enemies without dying', targets: [10, 20, 30], icon: '' },
                { id: 'ability', name: 'Ability Expert', desc: 'Use abilities {target} times', targets: [20, 40, 60], icon: '' },
                { id: 'dash', name: 'Speed Demon', desc: 'Dash {target} times', targets: [30, 50, 100], icon: '' }
            ],

            // v6.84: Added error handling for corrupted challenge data
            init() {
                const saved = localStorage.getItem(this.storageKey);
                let data = { date: null, challenges: [], progress: {} };
                if (saved) {
                    try {
                        data = JSON.parse(saved);
                    } catch (e) {
                        console.warn('Daily challenge data corrupted, resetting:', e);
                    }
                }

                const today = new Date().toDateString();
                if (data.date !== today) {
                    // Generate new daily challenges
                    this.generateDailyChallenges(today);
                } else {
                    this.challenges = data.challenges;
                    this.progress = data.progress;
                }
            },

            generateDailyChallenges(date) {
                // Seed random based on date for consistent daily challenges
                const seed = date.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                const seededRandom = (i) => {
                    const x = Math.sin(seed + i) * 10000;
                    return x - Math.floor(x);
                };

                // Pick 3 unique challenges
                const shuffled = [...this.challengeTemplates].sort(() => seededRandom(Math.random()) - 0.5);
                this.challenges = shuffled.slice(0, 3).map((template, i) => {
                    const difficulty = Math.floor(seededRandom(i) * 3);
                    return {
                        ...template,
                        target: template.targets[difficulty],
                        difficulty: ['Easy', 'Medium', 'Hard'][difficulty],
                        completed: false
                    };
                });

                this.progress = {
                    kills: 0,
                    combo: 0,
                    damage: 0,
                    killsWithoutDeath: 0,
                    abilityUses: 0,
                    dashes: 0
                };

                this.save(date);
                this.showDailyChallenges();
            },

            save(date) {
                localStorage.setItem(this.storageKey, JSON.stringify({
                    date: date || new Date().toDateString(),
                    challenges: this.challenges,
                    progress: this.progress
                }));
            },

            updateProgress(type, value) {
                if (!this.progress) return;

                switch(type) {
                    case 'kill':
                        this.progress.kills++;
                        this.progress.killsWithoutDeath++;
                        break;
                    case 'combo':
                        this.progress.combo = Math.max(this.progress.combo, value);
                        break;
                    case 'damage':
                        this.progress.damage += value;
                        break;
                    case 'death':
                        this.progress.killsWithoutDeath = 0;
                        break;
                    case 'ability':
                        this.progress.abilityUses++;
                        break;
                    case 'dash':
                        this.progress.dashes++;
                        break;
                }

                this.checkChallengeCompletion();
                this.save();
            },

            checkChallengeCompletion() {
                this.challenges.forEach(challenge => {
                    if (challenge.completed) return;

                    let current = 0;
                    switch(challenge.id) {
                        case 'kills': current = this.progress.kills; break;
                        case 'combo': current = this.progress.combo; break;
                        case 'damage': current = this.progress.damage; break;
                        case 'nodeath': current = this.progress.killsWithoutDeath; break;
                        case 'ability': current = this.progress.abilityUses; break;
                        case 'dash': current = this.progress.dashes; break;
                    }

                    if (current >= challenge.target) {
                        challenge.completed = true;
                        this.showChallengeComplete(challenge);
                    }
                });
            },

            showChallengeComplete(challenge) {
                const div = document.createElement('div');
                div.style.cssText = `
                    position: fixed;
                    top: 20%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, rgba(0,255,100,0.95), rgba(0,200,80,0.95));
                    color: #000;
                    padding: 20px 40px;
                    border-radius: 15px;
                    font-size: 22px;
                    font-weight: bold;
                    z-index: 10000;
                    text-align: center;
                    animation: recordPulse 0.5s ease-out;
                    box-shadow: 0 0 40px rgba(0,255,100,0.6);
                `;
                div.innerHTML = `
                    <div style="font-size: 40px; margin-bottom: 10px;">${challenge.icon}</div>
                    <div>CHALLENGE COMPLETE!</div>
                    <div style="font-size: 16px; margin-top: 5px; opacity: 0.8;">${challenge.name}</div>
                `;
                document.body.appendChild(div);

                // Play celebration sound
                AudioSystem.playGentle(880, 0.1, 0.3);
                setTimeout(() => AudioSystem.playGentle(1100, 0.1, 0.3), 100);
                setTimeout(() => AudioSystem.playGentle(1320, 0.15, 0.3), 200);

                setTimeout(() => {
                    div.style.opacity = '0';
                    div.style.transition = 'opacity 0.5s';
                    setTimeout(() => div.remove(), 500);
                }, 3000);
            },

            showDailyChallenges() {
                const div = document.createElement('div');
                div.style.cssText = `
                    position: fixed;
                    top: 15%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0,20,40,0.95);
                    border: 2px solid #0ff;
                    color: #fff;
                    padding: 20px 30px;
                    border-radius: 15px;
                    font-size: 16px;
                    z-index: 10000;
                    text-align: center;
                    box-shadow: 0 0 30px rgba(0,255,255,0.4);
                `;
                div.innerHTML = `
                    <div style="font-size: 20px; color: #0ff; margin-bottom: 15px;"> TODAY'S CHALLENGES</div>
                    ${this.challenges.map(c => `
                        <div style="margin: 10px 0; padding: 8px; background: rgba(0,255,255,0.1); border-radius: 8px;">
                            <span style="font-size: 24px;">${c.icon}</span>
                            <span style="color: #0ff;">${c.name}</span>
                            <span style="opacity: 0.7; font-size: 12px;">[${c.difficulty}]</span>
                            <div style="font-size: 13px; opacity: 0.8;">${c.desc.replace('{target}', c.target)}</div>
                        </div>
                    `).join('')}
                `;
                document.body.appendChild(div);

                setTimeout(() => {
                    div.style.opacity = '0';
                    div.style.transition = 'opacity 0.5s';
                    setTimeout(() => div.remove(), 500);
                }, 5000);
            },

            getChallengeProgress() {
                return this.challenges.map(c => {
                    let current = 0;
                    switch(c.id) {
                        case 'kills': current = this.progress?.kills || 0; break;
                        case 'combo': current = this.progress?.combo || 0; break;
                        case 'damage': current = this.progress?.damage || 0; break;
                        case 'nodeath': current = this.progress?.killsWithoutDeath || 0; break;
                        case 'ability': current = this.progress?.abilityUses || 0; break;
                        case 'dash': current = this.progress?.dashes || 0; break;
                    }
                    return { ...c, current, percent: Math.min(100, (current / c.target) * 100) };
                });
            }
        };

        // ============================================
        // v6.36: KILL REPLAY FLASH SYSTEM
        // Brief slow-mo replay of significant kills
        // Consensus feature from Round 3 strategy analysis
        // ============================================
        const killReplay = {
            enabled: true,
            replayQueue: [],
            isReplaying: false,
            significantKillThreshold: 15, // Only replay kills above this damage
            cooldown: 0,
            cooldownTime: 8000, // Min time between replays

            recordKill(enemyType, damage, position, killerCombo) {
                if (!this.enabled || this.isReplaying) return;

                const now = Date.now();
                if (now < this.cooldown) return;

                // Determine if this kill is replay-worthy
                const isSignificant = damage >= this.significantKillThreshold ||
                                      killerCombo >= 20 ||
                                      enemyType === 'boss' ||
                                      enemyType === 'elite';

                if (isSignificant) {
                    this.triggerReplay(enemyType, damage, position, killerCombo);
                    this.cooldown = now + this.cooldownTime;
                }
            },

            triggerReplay(enemyType, damage, position, combo) {
                this.isReplaying = true;

                // Create replay flash overlay
                const overlay = document.createElement('div');
                overlay.id = 'kill-replay-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.3) 100%);
                    z-index: 9999;
                    pointer-events: none;
                    animation: replayFlash 0.8s ease-out;
                `;
                document.body.appendChild(overlay);

                // Create kill text
                const killText = document.createElement('div');
                killText.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 48px;
                    font-weight: bold;
                    color: #ff4444;
                    text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
                    z-index: 10000;
                    animation: killTextPop 0.8s ease-out;
                    pointer-events: none;
                    white-space: nowrap;
                `;

                const killLabel = combo >= 20 ? `${combo}x COMBO KILL!` :
                                 enemyType === 'boss' ? 'BOSS SLAIN!' :
                                 damage >= 25 ? 'DEVASTATING!' :
                                 'ELIMINATED!';
                killText.textContent = killLabel;
                document.body.appendChild(killText);

                // Show damage number
                const damageNum = document.createElement('div');
                damageNum.style.cssText = `
                    position: fixed;
                    top: 58%;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 32px;
                    color: #ffaa00;
                    text-shadow: 0 0 10px #ff8800;
                    z-index: 10000;
                    animation: killTextPop 0.8s ease-out 0.1s both;
                    pointer-events: none;
                `;
                damageNum.textContent = `-${damage} DMG`;
                document.body.appendChild(damageNum);

                // Slow-mo effect (if animation frame available)
                const originalTimeScale = window.gameTimeScale || 1;
                window.gameTimeScale = 0.3;

                // Play impact sound
                AudioSystem.playGentle(150, 0.3, 0.5);
                setTimeout(() => AudioSystem.playGentle(80, 0.4, 0.6), 100);

                // Cleanup
                setTimeout(() => {
                    window.gameTimeScale = originalTimeScale;
                    overlay.remove();
                    killText.remove();
                    damageNum.remove();
                    this.isReplaying = false;
                }, 800);
            }
        };

        // Add CSS for replay animations
        const replayStyles = document.createElement('style');
        replayStyles.textContent = `
            @keyframes replayFlash {
                0% { opacity: 1; transform: scale(1); }
                50% { opacity: 0.8; }
                100% { opacity: 0; transform: scale(1.1); }
            }
            @keyframes killTextPop {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                30% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
            }
            @keyframes recordPulse {
                0% { transform: translate(-50%, -50%) scale(0.8); }
                50% { transform: translate(-50%, -50%) scale(1.05); }
                100% { transform: translate(-50%, -50%) scale(1); }
            }
        `;
        document.head.appendChild(replayStyles);

        // v5.15: Robot Animation Trigger System
        // v6.90: Extended with comprehensive ability casting animations
        // Triggers special animations on the explorer robot
        function triggerRobotAnimation(animType, options = {}) {
            if (!worldState.player || !worldState.player.userData.animation) return;
            const anim = worldState.player.userData.animation;

            switch (animType) {
                case 'attack':
                    anim.attackPhase = 1;
                    break;
                case 'damage':
                    anim.damageFlash = 1;
                    break;
                case 'wave':
                    anim.wavePhase = 1;
                    break;
                case 'jump':
                    anim.jumpPhase = 1;
                    break;
                case 'celebrate':
                    // Celebrate is a wave + jump combo
                    anim.wavePhase = 1;
                    anim.jumpPhase = 0.8;
                    break;

                // v6.90: Ability Casting Animations
                case 'powerStrike':
                    // Powerful overhead slam - wind up then strike down
                    anim.castType = 'powerStrike';
                    anim.castPhase = 1.0;
                    anim.chargePhase = 1.0;
                    anim.castIntensity = 1.0;
                    anim.castGlow = 0.8;
                    break;

                case 'whirlwind':
                    // Spinning attack - arms out, full body rotation
                    anim.castType = 'whirlwind';
                    anim.castPhase = 1.0;
                    anim.spinPhase = 0;  // Will increment in update loop
                    anim.castIntensity = 1.0;
                    anim.castGlow = 0.6;
                    break;

                case 'warcry':
                    // Chest thrust, head back, roar pose
                    anim.castType = 'warcry';
                    anim.castPhase = 1.0;
                    anim.chargePhase = 0.8;
                    anim.castIntensity = 1.0;
                    anim.castGlow = 0.7;
                    anim.jumpPhase = 0.3;  // Slight lift
                    break;

                case 'heal':
                    // Hands to chest, serene healing pose
                    anim.castType = 'heal';
                    anim.castPhase = 1.0;
                    anim.castIntensity = 0.8;
                    anim.castGlow = 1.0;  // Bright healing glow
                    break;

                case 'dash':
                    // Forward thrust pose with trailing motion
                    anim.castType = 'dash';
                    anim.castPhase = 0.6;  // Quick animation
                    anim.jumpPhase = 0.5;
                    anim.recoilPhase = 0.8;
                    anim.castGlow = 0.5;
                    break;

                case 'shieldWall':
                    // Arms crossed in front, defensive stance
                    anim.castType = 'shieldWall';
                    anim.castPhase = 1.0;
                    anim.chargePhase = 0.6;
                    anim.castIntensity = 0.7;
                    anim.castGlow = 0.6;
                    break;

                case 'execute':
                    // Deadly precision strike - arm pulled back then thrust
                    anim.castType = 'execute';
                    anim.castPhase = 1.0;
                    anim.chargePhase = 0.9;
                    anim.castIntensity = 1.0;
                    anim.bodyTwist = 0.3;
                    anim.castGlow = 0.9;
                    break;

                case 'berserk':
                    // Power-up pose - arms tensed, body vibrating with power
                    anim.castType = 'berserk';
                    anim.castPhase = 1.0;
                    anim.chargePhase = 1.0;
                    anim.castIntensity = 1.2;  // Extra intense
                    anim.castGlow = 1.0;
                    anim.jumpPhase = 0.4;
                    break;

                case 'chronoEcho':
                    // Mystical pose - arms out to sides, channeling time energy
                    anim.castType = 'chronoEcho';
                    anim.castPhase = 1.0;
                    anim.chargePhase = 0.7;
                    anim.castIntensity = 0.9;
                    anim.castGlow = 0.8;
                    anim.wavePhase = 0.5;  // Slight arm raise
                    break;
            }
        }

        // ============================================
        // v6.13: RIFT SURGE - Omniverse Gate Dash Effect
        // Channels energy from the dimensional rift to reshape reality
        // Creates an epic shockwave/force blast effect
        // ============================================
        let leviathanPulseEffects = [];

        function createFusRoDahEffect(startPos, direction, distance) {
            if (!scene) return;

            // Create multiple expanding rings that travel along dash path
            const ringCount = 5;
            const ringSpacing = distance / ringCount;

            for (let i = 0; i < ringCount; i++) {
                // Position along dash path
                const ringPos = startPos.clone().add(direction.clone().multiplyScalar(i * ringSpacing));
                ringPos.y += 1;

                // Create expanding ring geometry
                const ringGeo = new THREE.RingGeometry(0.5, 1.5, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x88ffff,
                    transparent: true,
                    opacity: 0.8 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(ringPos);

                // Orient ring perpendicular to dash direction
                ring.lookAt(ringPos.clone().add(direction));

                ring.userData = {
                    createdAt: performance.now(),
                    lifetime: 600,
                    initialScale: 1 + i * 0.5,
                    expandRate: 3 + i * 0.5,
                    index: i
                };

                scene.add(ring);
                leviathanPulseEffects.push(ring);
            }

            // Create central force cone/beam
            const coneGeo = new THREE.ConeGeometry(2, distance * 1.2, 16, 1, true);
            const coneMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const cone = new THREE.Mesh(coneGeo, coneMat);

            // Position and orient cone
            const coneCenter = startPos.clone().add(direction.clone().multiplyScalar(distance * 0.6));
            coneCenter.y += 1;
            cone.position.copy(coneCenter);

            // Point cone in dash direction (rotate so tip faces forward)
            const upVector = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(upVector, direction);
            cone.quaternion.copy(quaternion);
            cone.rotateX(Math.PI / 2); // Adjust so cone opens in direction of travel

            cone.userData = {
                createdAt: performance.now(),
                lifetime: 400,
                type: 'cone'
            };

            scene.add(cone);
            leviathanPulseEffects.push(cone);

            // Create debris particles flying outward
            const debrisCount = 20;
            for (let i = 0; i < debrisCount; i++) {
                const debrisGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const debrisMat = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0x88ffff : 0xffffff,
                    transparent: true,
                    opacity: 0.9
                });
                const debris = new THREE.Mesh(debrisGeo, debrisMat);

                // Random position along path
                const t = Math.random();
                const debrisPos = startPos.clone().add(direction.clone().multiplyScalar(t * distance));
                debrisPos.y += 0.5 + Math.random() * 2;
                debris.position.copy(debrisPos);

                // Random velocity perpendicular to dash direction
                const perpX = direction.z;
                const perpZ = -direction.x;
                const lateralVel = (Math.random() - 0.5) * 8;
                const upVel = 2 + Math.random() * 4;

                debris.userData = {
                    createdAt: performance.now(),
                    lifetime: 800,
                    type: 'debris',
                    velocity: new THREE.Vector3(
                        perpX * lateralVel + direction.x * 2,
                        upVel,
                        perpZ * lateralVel + direction.z * 2
                    ),
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    )
                };

                scene.add(debris);
                leviathanPulseEffects.push(debris);
            }

            // Create text floater with dramatic styling
            spawnFloater(startPos.clone().add(new THREE.Vector3(0, 3, 0)), ' DASH! ', '#00ffff');

            // Screen flash effect
            const flash = document.getElementById('damage-overlay');
            if (flash) {
                flash.style.background = 'radial-gradient(ellipse at center, rgba(136,255,255,0.5) 0%, transparent 70%)';
                flash.style.opacity = '0.6';
                setTimeout(() => {
                    flash.style.background = 'linear-gradient(rgba(255,0,0,0.3), rgba(255,0,0,0))';
                    flash.style.opacity = '0';
                }, 200);
            }
        }

        // Update Rift Surge effects each frame
        function updateFusRoDahEffects(dt) {
            const now = performance.now();
            const toRemove = [];

            for (const effect of leviathanPulseEffects) {
                const age = now - effect.userData.createdAt;
                const progress = age / effect.userData.lifetime;

                if (progress >= 1) {
                    toRemove.push(effect);
                    continue;
                }

                if (effect.userData.type === 'debris') {
                    // Update debris physics
                    const vel = effect.userData.velocity;
                    effect.position.x += vel.x * dt;
                    effect.position.y += vel.y * dt;
                    effect.position.z += vel.z * dt;
                    vel.y -= 15 * dt; // Gravity

                    // Rotation
                    const rot = effect.userData.rotationSpeed;
                    effect.rotation.x += rot.x * dt;
                    effect.rotation.y += rot.y * dt;
                    effect.rotation.z += rot.z * dt;

                    // Fade out
                    effect.material.opacity = 0.9 * (1 - progress);
                } else if (effect.userData.type === 'cone') {
                    // Fade out cone
                    effect.material.opacity = 0.4 * (1 - progress);
                    effect.scale.setScalar(1 + progress * 0.5);
                } else {
                    // Expanding rings
                    const scale = effect.userData.initialScale + effect.userData.expandRate * progress;
                    effect.scale.setScalar(scale);
                    effect.material.opacity = (0.8 - effect.userData.index * 0.1) * (1 - progress);
                }
            }

            // Remove finished effects
            for (const effect of toRemove) {
                scene.remove(effect);
                effect.geometry?.dispose();
                effect.material?.dispose();
            }
            leviathanPulseEffects = leviathanPulseEffects.filter(e => !toRemove.includes(e));
        }

        // ============================================
        // v6.16: FOG CLEARING EFFECT
        // Thermal shockwave from dash disperses nearby fog
        // Creates a temporary clear zone that slowly refills
        // ============================================
        let fogClearEffects = [];
        let fogClearActive = false;
        let fogClearStartTime = 0;
        const FOG_CLEAR_DURATION = 8000; // 8 seconds of clear visibility
        const FOG_CLEAR_FADE_TIME = 3000; // 3 seconds to fade back

        function createFogClearingEffect(startPos, direction, distance) {
            if (!scene || !scene.fog) return;

            fogClearActive = true;
            fogClearStartTime = performance.now();

            // Store original fog values
            const originalNear = scene.fog.near;
            const originalFar = scene.fog.far;

            // Immediately push fog back significantly
            scene.fog.near = 60;
            scene.fog.far = 200;

            // Create visual fog dispersal effect - expanding thermal rings
            const ringCount = 4;
            for (let i = 0; i < ringCount; i++) {
                const ringPos = startPos.clone().add(direction.clone().multiplyScalar(i * distance / ringCount));
                ringPos.y += 1.5;

                // White/yellow thermal wave rings
                const ringGeo = new THREE.RingGeometry(1, 3, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffffaa,
                    transparent: true,
                    opacity: 0.5 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(ringPos);
                ring.lookAt(ringPos.clone().add(new THREE.Vector3(0, 1, 0)));
                ring.rotation.x = Math.PI / 2; // Horizontal rings

                ring.userData = {
                    createdAt: performance.now(),
                    lifetime: 1500,
                    initialScale: 1 + i * 0.8,
                    expandRate: 8,
                    type: 'fogRing'
                };

                scene.add(ring);
                fogClearEffects.push(ring);
            }

            // Create rising heat distortion particles
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const t = Math.random();
                const particlePos = startPos.clone().add(direction.clone().multiplyScalar(t * distance));
                particlePos.x += (Math.random() - 0.5) * 6;
                particlePos.z += (Math.random() - 0.5) * 6;
                particlePos.y += Math.random() * 2;

                const particleGeo = new THREE.SphereGeometry(0.15, 4, 4);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xffff88 : 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(particlePos);

                particle.userData = {
                    createdAt: performance.now(),
                    lifetime: 2000,
                    type: 'heatParticle',
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        3 + Math.random() * 4, // Rising heat
                        (Math.random() - 0.5) * 2
                    )
                };

                scene.add(particle);
                fogClearEffects.push(particle);
            }

            // Show notification
            spawnFloater(startPos.clone().add(new THREE.Vector3(0, 4, 0)), ' FOG CLEARED! ', '#ffff00');
            showNotification('Thermal shockwave dispersed the fog!', 'success');

            // Schedule fog return
            setTimeout(() => {
                if (scene.fog && currentWeather === 'fog') {
                    // Gradually restore fog
                    const restoreStart = performance.now();
                    const restoreInterval = setInterval(() => {
                        const elapsed = performance.now() - restoreStart;
                        const progress = Math.min(1, elapsed / FOG_CLEAR_FADE_TIME);

                        if (scene.fog) {
                            scene.fog.near = 60 - progress * (60 - originalNear);
                            scene.fog.far = 200 - progress * (200 - originalFar);
                        }

                        if (progress >= 1) {
                            clearInterval(restoreInterval);
                            fogClearActive = false;
                        }
                    }, 50);
                } else {
                    fogClearActive = false;
                }
            }, FOG_CLEAR_DURATION);
        }

        // Update fog clear visual effects
        function updateFogClearEffects(dt) {
            const now = performance.now();
            const toRemove = [];

            for (const effect of fogClearEffects) {
                const age = now - effect.userData.createdAt;
                const progress = age / effect.userData.lifetime;

                if (progress >= 1) {
                    toRemove.push(effect);
                    continue;
                }

                if (effect.userData.type === 'fogRing') {
                    // Expanding horizontal rings
                    const scale = effect.userData.initialScale + effect.userData.expandRate * progress;
                    effect.scale.setScalar(scale);
                    effect.material.opacity = 0.5 * (1 - progress);
                } else if (effect.userData.type === 'heatParticle') {
                    // Rising heat particles
                    const vel = effect.userData.velocity;
                    effect.position.x += vel.x * dt;
                    effect.position.y += vel.y * dt;
                    effect.position.z += vel.z * dt;
                    vel.y -= 2 * dt; // Slight deceleration
                    effect.material.opacity = 0.6 * (1 - progress);
                    effect.scale.setScalar(1 - progress * 0.5);
                }
            }

            // Cleanup
            for (const effect of toRemove) {
                scene.remove(effect);
                effect.geometry?.dispose();
                effect.material?.dispose();
            }
            fogClearEffects = fogClearEffects.filter(e => !toRemove.includes(e));
        }

        // v4.1: Create nebula clouds for galaxy atmosphere
        function createNebulae() {
            const nebulaColors = [0xff3366, 0x3366ff, 0x66ff33, 0xff6633, 0x9933ff, 0x33ffff];
            const nebulaCount = 6;

            for (let i = 0; i < nebulaCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Create procedural nebula with radial gradients
                const color = nebulaColors[i % nebulaColors.length];
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;

                // Multiple overlapping gradients for organic look
                for (let j = 0; j < 3; j++) {
                    const cx = 80 + Math.random() * 96;
                    const cy = 80 + Math.random() * 96;
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100 + Math.random() * 56);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.25)`);
                    gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.1)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                }

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    opacity: 0.6
                });

                const geometry = new THREE.PlaneGeometry(600, 600);
                const nebula = new THREE.Mesh(geometry, material);

                // Position nebulae around the galaxy
                const angle = (i / nebulaCount) * Math.PI * 2;
                const dist = 400 + Math.random() * 600;
                nebula.position.set(
                    Math.cos(angle) * dist,
                    (Math.random() - 0.5) * 300,
                    Math.sin(angle) * dist
                );

                // Random rotation
                nebula.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                scene.add(nebula);
            }
        }

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, water: 0x2244aa, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, water: 0x446688, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, water: 0x88aadd, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, water: 0x8800ff, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, water: 0xff4400, name: 'Magma' }
        };

        // ================================================================
        // MINECRAFT-STYLE PROCEDURAL TEXTURE GENERATOR
        // Based on Notch's original texture generation algorithm
        // Creates 16x16 pixel-art textures procedurally
        // ================================================================
        const MinecraftTextures = (function() {
            const TEXTURE_SIZE = 16;
            const textureCache = new Map();

            // Simple seeded random for deterministic textures
            function seededRandom(seed) {
                let s = seed;
                return function() {
                    s = (s * 9301 + 49297) % 233280;
                    return s / 233280;
                };
            }

            // Extract RGB components from hex color
            function hexToRgb(hex) {
                return {
                    r: (hex >> 16) & 255,
                    g: (hex >> 8) & 255,
                    b: hex & 255
                };
            }

            // Clamp value between 0-255
            function clamp(val) {
                return Math.max(0, Math.min(255, Math.floor(val)));
            }

            // Core Minecraft-style noise function
            function minecraftNoise(x, y, seed) {
                const rand = seededRandom(seed + x * 31 + y * 17);
                return rand();
            }

            // Generate grass texture (Terra biome)
            function generateGrassTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Minecraft grass: green base with noise variation
                        let brightness = 0.7 + rand() * 0.3;

                        // Add occasional darker spots (dirt showing through)
                        if (rand() < 0.08) {
                            brightness *= 0.5;
                        }

                        // Add occasional lighter spots (sun highlights)
                        if (rand() < 0.05) {
                            brightness *= 1.3;
                        }

                        // Vertical gradient for grass blade effect
                        const gradient = 1 - (y / TEXTURE_SIZE) * 0.15;
                        brightness *= gradient;

                        data[idx] = clamp(rgb.r * brightness);
                        data[idx + 1] = clamp(rgb.g * brightness);
                        data[idx + 2] = clamp(rgb.b * brightness);
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate sand texture (Desert biome)
            function generateSandTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Sand: grainy texture with color variation
                        let brightness = 0.85 + rand() * 0.15;

                        // Add occasional darker grains
                        if (rand() < 0.15) {
                            brightness *= 0.75;
                        }

                        // Slight color shift for some grains
                        let rShift = 1, gShift = 1, bShift = 1;
                        if (rand() < 0.1) {
                            rShift = 1.05;
                            gShift = 0.95;
                        }

                        data[idx] = clamp(rgb.r * brightness * rShift);
                        data[idx + 1] = clamp(rgb.g * brightness * gShift);
                        data[idx + 2] = clamp(rgb.b * brightness * bShift);
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate snow/ice texture (Ice biome)
            function generateSnowTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Snow: mostly white with subtle blue shadows
                        let brightness = 0.9 + rand() * 0.1;

                        // Ice crystal effect - occasional sparkles
                        if (rand() < 0.03) {
                            brightness = 1.2;
                        }

                        // Subtle shadow areas
                        if (rand() < 0.1) {
                            brightness *= 0.85;
                        }

                        // Blue tint in shadows
                        const blueShift = brightness < 0.9 ? 1.1 : 1;

                        data[idx] = clamp(rgb.r * brightness);
                        data[idx + 1] = clamp(rgb.g * brightness);
                        data[idx + 2] = clamp(rgb.b * brightness * blueShift);
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate alien/xeno texture (Alien biome)
            function generateAlienTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Alien: pulsating organic pattern
                        const wave = Math.sin((x + y) * 0.5 + seed * 0.01) * 0.15;
                        let brightness = 0.6 + rand() * 0.3 + wave;

                        // Bioluminescent spots
                        if (rand() < 0.05) {
                            brightness = 1.5;
                        }

                        // Dark veins
                        if ((x + y) % 4 === 0 && rand() < 0.3) {
                            brightness *= 0.4;
                        }

                        // Color shift for organic feel
                        const shift = rand() < 0.2 ? 1.2 : 1;

                        data[idx] = clamp(rgb.r * brightness * shift);
                        data[idx + 1] = clamp(rgb.g * brightness);
                        data[idx + 2] = clamp(rgb.b * brightness * shift);
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate volcanic/magma texture (Volcanic biome)
            function generateVolcanicTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Dark volcanic rock base
                        let brightness = 0.4 + rand() * 0.4;
                        let isLava = false;

                        // Lava cracks/veins
                        if (rand() < 0.08 || ((x * y) % 7 === 0 && rand() < 0.2)) {
                            isLava = true;
                            brightness = 1.0;
                        }

                        if (isLava) {
                            // Glowing lava - orange/red
                            data[idx] = clamp(255 * brightness);
                            data[idx + 1] = clamp(100 * brightness * rand());
                            data[idx + 2] = clamp(20);
                        } else {
                            // Dark rock
                            data[idx] = clamp(rgb.r * brightness);
                            data[idx + 1] = clamp(rgb.g * brightness);
                            data[idx + 2] = clamp(rgb.b * brightness);
                        }
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate water texture
            function generateWaterTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Water: wave pattern with caustics
                        const wave1 = Math.sin((x + seed * 0.1) * 0.6) * 0.1;
                        const wave2 = Math.sin((y + seed * 0.05) * 0.8) * 0.08;
                        let brightness = 0.7 + wave1 + wave2 + rand() * 0.15;

                        // Caustic highlights
                        if (rand() < 0.04) {
                            brightness = 1.3;
                        }

                        // Depth variation
                        const depth = 1 - (y / TEXTURE_SIZE) * 0.2;
                        brightness *= depth;

                        data[idx] = clamp(rgb.r * brightness);
                        data[idx + 1] = clamp(rgb.g * brightness);
                        data[idx + 2] = clamp(rgb.b * brightness * 1.1);
                        data[idx + 3] = 200; // Semi-transparent
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate stone/rock texture
            function generateStoneTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Stone: rough with mineral veins
                        let brightness = 0.5 + rand() * 0.4;

                        // Dark cracks
                        if (rand() < 0.1) {
                            brightness *= 0.4;
                        }

                        // Mineral sparkles
                        if (rand() < 0.03) {
                            brightness = 1.2;
                        }

                        // Color variation for different minerals
                        let rShift = 1, gShift = 1, bShift = 1;
                        if (rand() < 0.08) {
                            // Iron oxide tint
                            rShift = 1.2;
                        } else if (rand() < 0.05) {
                            // Copper tint
                            gShift = 1.15;
                        }

                        data[idx] = clamp(rgb.r * brightness * rShift);
                        data[idx + 1] = clamp(rgb.g * brightness * gShift);
                        data[idx + 2] = clamp(rgb.b * brightness * bShift);
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate wood/bark texture
            function generateWoodTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Wood grain - vertical lines with variation
                        const grain = Math.sin(x * 1.5 + rand() * 2) * 0.15;
                        let brightness = 0.6 + grain + rand() * 0.25;

                        // Bark ridges (horizontal bands)
                        if (y % 4 < 1) {
                            brightness *= 0.7;
                        }

                        // Knots
                        if (rand() < 0.02) {
                            brightness *= 0.5;
                        }

                        data[idx] = clamp(rgb.r * brightness);
                        data[idx + 1] = clamp(rgb.g * brightness);
                        data[idx + 2] = clamp(rgb.b * brightness);
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Generate leaf texture
            function generateLeafTexture(baseColor, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rgb = hexToRgb(baseColor);
                const rand = seededRandom(seed);

                for (let y = 0; y < TEXTURE_SIZE; y++) {
                    for (let x = 0; x < TEXTURE_SIZE; x++) {
                        const idx = (y * TEXTURE_SIZE + x) * 4;

                        // Leaves: varied green with holes
                        let brightness = 0.65 + rand() * 0.35;
                        let alpha = 255;

                        // Leaf veins (diagonal pattern)
                        if ((x + y) % 5 === 0) {
                            brightness *= 0.75;
                        }

                        // Light spots (sun through leaves)
                        if (rand() < 0.08) {
                            brightness = 1.2;
                        }

                        // Holes in leaves (for transparency)
                        if (rand() < 0.12) {
                            alpha = 0;
                        }

                        data[idx] = clamp(rgb.r * brightness);
                        data[idx + 1] = clamp(rgb.g * brightness);
                        data[idx + 2] = clamp(rgb.b * brightness);
                        data[idx + 3] = alpha;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Main texture creation function with caching
            function createTexture(type, baseColor, seed = 42) {
                const cacheKey = `${type}_${baseColor}_${seed}`;

                if (textureCache.has(cacheKey)) {
                    return textureCache.get(cacheKey);
                }

                let canvas;
                switch (type) {
                    case 'grass':
                        canvas = generateGrassTexture(baseColor, seed);
                        break;
                    case 'sand':
                        canvas = generateSandTexture(baseColor, seed);
                        break;
                    case 'snow':
                        canvas = generateSnowTexture(baseColor, seed);
                        break;
                    case 'alien':
                        canvas = generateAlienTexture(baseColor, seed);
                        break;
                    case 'volcanic':
                        canvas = generateVolcanicTexture(baseColor, seed);
                        break;
                    case 'water':
                        canvas = generateWaterTexture(baseColor, seed);
                        break;
                    case 'stone':
                        canvas = generateStoneTexture(baseColor, seed);
                        break;
                    case 'wood':
                        canvas = generateWoodTexture(baseColor, seed);
                        break;
                    case 'leaf':
                        canvas = generateLeafTexture(baseColor, seed);
                        break;
                    default:
                        canvas = generateGrassTexture(baseColor, seed);
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.magFilter = THREE.NearestFilter; // Pixelated look like Minecraft
                texture.minFilter = THREE.NearestFilter;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);

                textureCache.set(cacheKey, texture);
                return texture;
            }

            // Get the appropriate texture type for a biome
            function getBiomeGroundType(biomeName) {
                const typeMap = {
                    'Terra': 'grass',
                    'Desert': 'sand',
                    'Ice': 'snow',
                    'Alien': 'alien',
                    'Volcanic': 'volcanic'
                };
                return typeMap[biomeName] || 'grass';
            }

            // Create material for ground - clean look emphasizing terrain height/ridges
            // v6.81: Replaced noisy Minecraft textures with clean elevation-based shading
            function createGroundMaterial(biome, biomeName) {
                // Use MeshStandardMaterial for better lighting response on terrain
                return new THREE.MeshStandardMaterial({
                    color: biome.ground,
                    roughness: 0.85,
                    metalness: 0.05,
                    flatShading: true // Emphasizes the blocky terrain ridges
                });
            }

            // Create material for water - clean semi-transparent look
            // v6.81: Replaced noisy texture with clean water material
            function createWaterMaterial(biome, biomeName) {
                return new THREE.MeshStandardMaterial({
                    color: biome.water,
                    roughness: 0.2,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.75,
                    flatShading: true
                });
            }

            // Create material for rocks - clean flat shaded
            // v6.81: Replaced noisy texture with clean material
            function createRockMaterial(biome) {
                return new THREE.MeshStandardMaterial({
                    color: biome.rock,
                    roughness: 0.9,
                    metalness: 0.1,
                    flatShading: true
                });
            }

            // Create material for tree trunks - clean flat shaded
            // v6.81: Replaced noisy texture with clean bark material
            function createWoodMaterial(color, seed = 999) {
                return new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.8,
                    metalness: 0.0,
                    flatShading: true
                });
            }

            // Create material for leaves - clean flat shaded
            // v6.81: Replaced noisy texture with clean foliage material
            function createLeafMaterial(color, seed = 555) {
                return new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.7,
                    metalness: 0.0,
                    flatShading: true,
                    side: THREE.DoubleSide
                });
            }

            return {
                createTexture,
                createGroundMaterial,
                createWaterMaterial,
                createRockMaterial,
                createWoodMaterial,
                createLeafMaterial,
                getBiomeGroundType
            };
        })();
        // END MINECRAFT TEXTURE GENERATOR
        // ================================================================

        // ================================================================
        // v6.93: ORBITAL PLANET TEXTURE GENERATOR
        // Creates procedural textures for planets visible from galaxy view
        // ================================================================
        const PlanetTextures = (function() {
            const TEXTURE_SIZE = 128;
            const textureCache = new Map();

            function seededRandom(seed) {
                let s = seed;
                return function() { s = (s * 9301 + 49297) % 233280; return s / 233280; };
            }

            function hexToRgb(hex) {
                return { r: (hex >> 16) & 255, g: (hex >> 8) & 255, b: hex & 255 };
            }

            function clamp(val) { return Math.max(0, Math.min(255, Math.floor(val))); }

            function fbm(x, y, seed, octaves = 4) {
                let value = 0, amplitude = 0.5, frequency = 1;
                for (let i = 0; i < octaves; i++) {
                    const nx = Math.floor(x * frequency * 100);
                    const ny = Math.floor(y * frequency * 100);
                    const r = seededRandom(nx * 31 + ny * 17 + seed + i * 100);
                    value += amplitude * r();
                    amplitude *= 0.5; frequency *= 2;
                }
                return value;
            }

            function generateTerraPlanet(biome, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rand = seededRandom(seed);
                const groundRgb = hexToRgb(biome.ground), waterRgb = hexToRgb(biome.water), rockRgb = hexToRgb(biome.rock);

                for (let py = 0; py < TEXTURE_SIZE; py++) {
                    for (let px = 0; px < TEXTURE_SIZE; px++) {
                        const idx = (py * TEXTURE_SIZE + px) * 4;
                        const nx = (px / TEXTURE_SIZE) * 4, ny = (py / TEXTURE_SIZE) * 4;
                        const height = fbm(nx, ny, seed, 5);
                        let r, g, b;
                        if (height < 0.45) { r = waterRgb.r * (0.6 + (height/0.45) * 0.3); g = waterRgb.g * (0.6 + (height/0.45) * 0.3); b = waterRgb.b * (0.7 + (height/0.45) * 0.3); }
                        else if (height < 0.5) { r = waterRgb.r * 1.2; g = waterRgb.g * 1.1; b = waterRgb.b * 0.9; }
                        else if (height < 0.7) { const v = fbm(nx*2, ny*2, seed+50, 3) * 0.3; r = groundRgb.r * (0.8+v); g = groundRgb.g * (0.9+v); b = groundRgb.b * (0.7+v); }
                        else if (height < 0.85) { r = groundRgb.r * 0.6; g = groundRgb.g * 0.7; b = groundRgb.b * 0.5; }
                        else { if (rand() < (height-0.85)*5) { r=240; g=245; b=250; } else { r=rockRgb.r; g=rockRgb.g; b=rockRgb.b; } }
                        data[idx] = clamp(r); data[idx+1] = clamp(g); data[idx+2] = clamp(b); data[idx+3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0); return canvas;
            }

            function generateDesertPlanet(biome, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const groundRgb = hexToRgb(biome.ground), rockRgb = hexToRgb(biome.rock);

                for (let py = 0; py < TEXTURE_SIZE; py++) {
                    for (let px = 0; px < TEXTURE_SIZE; px++) {
                        const idx = (py * TEXTURE_SIZE + px) * 4;
                        const nx = (px / TEXTURE_SIZE) * 4, ny = (py / TEXTURE_SIZE) * 4;
                        const height = fbm(nx, ny, seed, 4);
                        const dunes = Math.sin(nx * 3 + fbm(nx, ny, seed+100, 2) * 2) * 0.5 + 0.5;
                        let r, g, b;
                        if (height > 0.7) { r = rockRgb.r * (0.8+height*0.2); g = rockRgb.g * (0.8+height*0.2); b = rockRgb.b * (0.7+height*0.2); }
                        else { const shade = 0.85 + dunes * 0.15; r = groundRgb.r * shade; g = groundRgb.g * shade * 0.95; b = groundRgb.b * shade * 0.9; }
                        data[idx] = clamp(r); data[idx+1] = clamp(g); data[idx+2] = clamp(b); data[idx+3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0); return canvas;
            }

            function generateIcePlanet(biome, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rand = seededRandom(seed);
                const groundRgb = hexToRgb(biome.ground), waterRgb = hexToRgb(biome.water);

                for (let py = 0; py < TEXTURE_SIZE; py++) {
                    for (let px = 0; px < TEXTURE_SIZE; px++) {
                        const idx = (py * TEXTURE_SIZE + px) * 4;
                        const nx = (px / TEXTURE_SIZE) * 4, ny = (py / TEXTURE_SIZE) * 4;
                        const height = fbm(nx, ny, seed, 4), cracks = fbm(nx*3, ny*3, seed+200, 2);
                        let r, g, b;
                        if (height < 0.4) { r = waterRgb.r * 0.7; g = waterRgb.g * 0.8; b = waterRgb.b * 0.9; }
                        else if (cracks < 0.3) { r = 100; g = 140; b = 180; }
                        else { const sp = rand() < 0.02 ? 1.1 : 1.0; r = groundRgb.r * 0.98 * sp; g = groundRgb.g * 0.98 * sp; b = Math.min(255, groundRgb.b * 1.05 * sp); }
                        data[idx] = clamp(r); data[idx+1] = clamp(g); data[idx+2] = clamp(b); data[idx+3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0); return canvas;
            }

            function generateAlienPlanet(biome, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const rand = seededRandom(seed);
                const groundRgb = hexToRgb(biome.ground), treeRgb = hexToRgb(biome.tree), waterRgb = hexToRgb(biome.water);

                for (let py = 0; py < TEXTURE_SIZE; py++) {
                    for (let px = 0; px < TEXTURE_SIZE; px++) {
                        const idx = (py * TEXTURE_SIZE + px) * 4;
                        const nx = (px / TEXTURE_SIZE) * 4, ny = (py / TEXTURE_SIZE) * 4;
                        const height = fbm(nx, ny, seed, 4);
                        const organic = Math.sin(nx*5 + ny*3 + seed*0.1) * 0.5 + 0.5;
                        let r, g, b;
                        if (height < 0.35) { const glow = 0.8 + Math.sin(nx*10 + ny*8) * 0.2; r = waterRgb.r * glow; g = waterRgb.g * 0.5; b = waterRgb.b * glow; }
                        else if (rand() < 0.08) { r = treeRgb.r; g = treeRgb.g * 0.3; b = treeRgb.b; }
                        else { r = groundRgb.r * (0.7+organic*0.4); g = groundRgb.g * (0.5+organic*0.3); b = groundRgb.b * (0.8+organic*0.3); }
                        data[idx] = clamp(r); data[idx+1] = clamp(g); data[idx+2] = clamp(b); data[idx+3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0); return canvas;
            }

            function generateVolcanicPlanet(biome, seed) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = TEXTURE_SIZE;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(TEXTURE_SIZE, TEXTURE_SIZE);
                const data = imageData.data;
                const groundRgb = hexToRgb(biome.ground), lavaRgb = hexToRgb(biome.water);

                for (let py = 0; py < TEXTURE_SIZE; py++) {
                    for (let px = 0; px < TEXTURE_SIZE; px++) {
                        const idx = (py * TEXTURE_SIZE + px) * 4;
                        const nx = (px / TEXTURE_SIZE) * 4, ny = (py / TEXTURE_SIZE) * 4;
                        const height = fbm(nx, ny, seed, 5), lavaFlow = fbm(nx*2, ny*2, seed+300, 3);
                        let r, g, b;
                        if (lavaFlow < 0.25 || height < 0.3) { const heat = 0.8 + Math.sin(nx*8 + ny*6 + seed*0.05) * 0.2; r = lavaRgb.r * heat; g = lavaRgb.g * heat * 0.5; b = 0; }
                        else { const rv = 0.6 + height * 0.4; r = groundRgb.r * rv; g = groundRgb.g * rv; b = groundRgb.b * rv; }
                        data[idx] = clamp(r); data[idx+1] = clamp(g); data[idx+2] = clamp(b); data[idx+3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0); return canvas;
            }

            function createPlanetMaterial(biomeKey, planetSeed) {
                const cacheKey = `${biomeKey}-${planetSeed}`;
                if (textureCache.has(cacheKey)) return textureCache.get(cacheKey).clone();
                const biome = BIOMES[biomeKey] || BIOMES.Terra;
                let canvas;
                switch (biomeKey) {
                    case 'Desert': canvas = generateDesertPlanet(biome, planetSeed); break;
                    case 'Ice': canvas = generateIcePlanet(biome, planetSeed); break;
                    case 'Alien': canvas = generateAlienPlanet(biome, planetSeed); break;
                    case 'Volcanic': canvas = generateVolcanicPlanet(biome, planetSeed); break;
                    default: canvas = generateTerraPlanet(biome, planetSeed);
                }
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
                const material = new THREE.MeshBasicMaterial({ map: texture });
                textureCache.set(cacheKey, material);
                return material;
            }

            function createAtmosphereMaterial(biomeKey) {
                const biome = BIOMES[biomeKey] || BIOMES.Terra;
                return new THREE.MeshBasicMaterial({ color: biome.sky, transparent: true, opacity: 0.15, side: THREE.BackSide });
            }

            return { createPlanetMaterial, createAtmosphereMaterial };
        })();
        // END ORBITAL PLANET TEXTURE GENERATOR
        // ================================================================

        // v4.2: Enemy Variety System - Biome-specific enemies
        // v4.5: Added attack telegraphing parameters
        const ENEMY_TYPES = {
            Slime: {
                hp: 10, damage: 5, speed: 4, color: 0x44ff44, emissive: 0x003300,
                drops: ['Slime'], xp: 100, biomes: ['Terra', 'Alien'],
                attackWindup: 800, attackRange: 2.5  // v4.5: Telegraph timing
            },
            Scorpion: {
                hp: 15, damage: 8, speed: 5, color: 0xdd9944, emissive: 0x442200,
                drops: ['Chitin'], xp: 150, biomes: ['Desert'],
                attackWindup: 600, attackRange: 3.0
            },
            IceWisp: {
                hp: 8, damage: 6, speed: 7, color: 0x88ccff, emissive: 0x002244,
                drops: ['Frost Shard'], xp: 120, biomes: ['Ice'],
                attackWindup: 500, attackRange: 4.0  // Fast ranged
            },
            MagmaCore: {
                hp: 20, damage: 10, speed: 3, color: 0xff4400, emissive: 0x440000,
                drops: ['Magma Gem'], xp: 180, biomes: ['Volcanic'],
                attackWindup: 1200, attackRange: 3.5  // Slow heavy
            },
            VoidSpawn: {
                hp: 25, damage: 12, speed: 5, color: 0x8800ff, emissive: 0x220044,
                drops: ['Void Fragment'], xp: 250, biomes: ['Alien'],
                attackWindup: 700, attackRange: 3.0
            },
            // v5.12: Hypnotist - Special enemy that takes control of the player
            Hypnotist: {
                hp: 35, damage: 8, speed: 2, color: 0xff00ff, emissive: 0x660066,
                drops: ['Void Fragment', 'Psychic Shard'], xp: 400, biomes: ['Alien', 'Volcanic'],
                attackWindup: 2000, attackRange: 15.0,  // Long range hypnosis
                isHypnotist: true,
                hypnosisRange: 12,
                hypnosisDuration: 8000,
                hypnosisCooldown: 15000
            },
            // v6.1: NEW ENEMY TYPES
            Mimic: {
                hp: 40, damage: 15, speed: 8, color: 0xcd853f, emissive: 0x442200,
                drops: ['Mimic Tooth', 'Treasure Key'], xp: 350, biomes: ['Terra', 'Desert', 'Alien'],
                attackWindup: 300, attackRange: 3.5,
                isMimic: true,          // Disguises as resource node
                disguiseType: 'chest',  // chest, rock, tree
                revealRange: 5,         // Distance to reveal disguise
                ambushDamage: 25        // Extra damage on first hit
            },
            Summoner: {
                hp: 25, damage: 5, speed: 2, color: 0x9932cc, emissive: 0x330066,
                drops: ['Summoner Staff', 'Soul Essence'], xp: 300, biomes: ['Alien', 'Ice'],
                attackWindup: 1500, attackRange: 20.0,
                isSummoner: true,
                summonCooldown: 8000,
                summonCount: 2,         // Spawns 2 minions at a time
                maxMinions: 4,          // Maximum minions alive at once
                minions: []             // Track active minions
            },
            ShadowWraith: {
                hp: 18, damage: 12, speed: 9, color: 0x111111, emissive: 0x220022,
                drops: ['Shadow Essence', 'Dark Crystal'], xp: 280, biomes: ['Alien'],
                attackWindup: 400, attackRange: 3.0,
                isShadow: true,
                phaseChance: 0.3,       // 30% chance to phase through attacks
                onlyDuringEclipse: true // Only spawns during Solar Eclipse event
            },
            CrystalGolem: {
                hp: 60, damage: 18, speed: 2, color: 0x00ffff, emissive: 0x004444,
                drops: ['Crystal', 'Golem Core', 'Rare Crystal'], xp: 400, biomes: ['Ice', 'Terra'],
                attackWindup: 1800, attackRange: 4.0,
                hasShield: true,
                shieldHp: 30,           // Shield absorbs first 30 damage
                shieldRegen: 5000       // Shield regenerates after 5 seconds
            },
            Berserker: {
                hp: 30, damage: 10, speed: 5, color: 0xff2200, emissive: 0x440000,
                drops: ['Berserker Blood', 'Rage Shard'], xp: 320, biomes: ['Volcanic', 'Desert'],
                attackWindup: 600, attackRange: 3.0,
                isBerserker: true,
                rageThreshold: 0.3,     // Enters rage at 30% HP
                rageDamageBonus: 1.5,   // +50% damage when enraged
                rageSpeedBonus: 1.4     // +40% speed when enraged
            }
        };

        // v4.6: Elemental Status Effects System
        const STATUS_EFFECTS = {
            ice: {
                name: 'Frozen',
                duration: 3000,
                color: 0x88ccff,
                icon: '',
                speedMod: 0.3  // Slows to 30% speed
            },
            fire: {
                name: 'Burning',
                duration: 4000,
                color: 0xff4400,
                icon: '',
                tickRate: 500,
                tickDamage: 2
            },
            void: {
                name: 'Weakened',
                duration: 5000,
                color: 0x8800ff,
                icon: '',
                damageMod: 0.5  // Enemy deals 50% damage
            },
            cosmic: {
                name: 'Annihilated',
                duration: 3000,
                color: 0xffd700,
                icon: '',
                tickRate: 250,
                tickDamage: 5,
                speedMod: 0.5
            }
        };

        // ============================================
        // v5.12: HYPNOTIST SYSTEM
        // Eye animation, trance effects, and break-free mechanics
        // ============================================
        const HYPNOSIS_STATE = {
            active: false,
            hypnotistMob: null,
            startTime: 0,
            duration: 0,
            spiralAngle: 0,
            eyePhase: 0,
            breakAttempts: 0,
            maxBreakAttempts: 3,
            breakDamage: 25,
            tranceOverlay: null,
            spiralRings: [],
            companionEyeOffset: { x: 0, y: 0 },
            // v6.13: Enhanced mind control effects
            mindControlEffect: null,           // Current active effect
            controlsInverted: false,           // Inverted movement
            lastMindControlAction: 0,          // Timestamp of last involuntary action
            resourcesDrained: 0,               // Track resources lost during hypnosis
            attackedAllies: 0                  // Track friendly fire incidents
        };

        // v6.13: Mind Control Effect Types - Robot performs actions against its mission
        const MIND_CONTROL_EFFECTS = {
            invertControls: {
                name: 'Inverted Controls',
                icon: '',
                message: 'Your controls are reversed!',
                color: '#ff00ff'
            },
            resourceDrain: {
                name: 'Resource Leak',
                icon: '',
                message: 'You are dropping resources!',
                color: '#ffaa00'
            },
            friendlyFire: {
                name: 'Confused Targeting',
                icon: '',
                message: 'You might attack allies!',
                color: '#ff4444'
            },
            selfSabotage: {
                name: 'Self Sabotage',
                icon: '',
                message: 'Your systems are compromised!',
                color: '#ff6600'
            }
        };

        // Autopilot mode flag (disables player control during certain states)
        let autopilotEnabled = false;

        // Eye animation patterns for hypnosis
        const HYPNO_EYE_PATTERNS = [
            { name: 'spiral', fn: (t) => ({ x: Math.cos(t * 3) * 0.3, y: Math.sin(t * 3) * 0.15 }) },
            { name: 'figure8', fn: (t) => ({ x: Math.sin(t * 2) * 0.4, y: Math.sin(t * 4) * 0.2 }) },
            { name: 'pendulum', fn: (t) => ({ x: Math.sin(t * 2.5) * 0.5, y: 0 }) },
            { name: 'erratic', fn: (t) => ({ x: Math.sin(t * 7) * 0.3 + Math.cos(t * 11) * 0.2, y: Math.cos(t * 5) * 0.2 }) }
        ];

        let hypnoVisualGroup = null;
        let hypnoEyePattern = 0;

        // Initialize hypnosis visual effects
        // v6.33: Made overlay much more subtle
        function initHypnosisEffects() {
            // Create overlay for trance effect - subtle edge vignette only
            const overlay = document.createElement('div');
            overlay.id = 'hypnosis-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                pointer-events: none; z-index: 48;
                background: radial-gradient(ellipse at center,
                    transparent 50%,
                    rgba(138, 43, 226, 0.05) 70%,
                    rgba(255, 0, 255, 0.1) 85%,
                    rgba(138, 43, 226, 0.2) 100%);
                opacity: 0;
                transition: opacity 0.5s;
            `;
            document.body.appendChild(overlay);
            HYPNOSIS_STATE.tranceOverlay = overlay;

            // Create spiral rings container in 3D
            hypnoVisualGroup = new THREE.Group();
        }

        // Start hypnosis effect on player
        function startHypnosis(hypnotistMob, duration = 8000) {
            if (HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.active = true;
            HYPNOSIS_STATE.hypnotistMob = hypnotistMob;
            HYPNOSIS_STATE.startTime = performance.now();
            HYPNOSIS_STATE.duration = duration;
            HYPNOSIS_STATE.spiralAngle = 0;
            HYPNOSIS_STATE.eyePhase = 0;
            HYPNOSIS_STATE.breakAttempts = 0;

            // v6.13: Select random mind control effect
            const effectKeys = Object.keys(MIND_CONTROL_EFFECTS);
            const randomEffect = effectKeys[Math.floor(Math.random() * effectKeys.length)];
            HYPNOSIS_STATE.mindControlEffect = randomEffect;
            HYPNOSIS_STATE.controlsInverted = (randomEffect === 'invertControls');
            HYPNOSIS_STATE.lastMindControlAction = performance.now();
            HYPNOSIS_STATE.resourcesDrained = 0;
            HYPNOSIS_STATE.attackedAllies = 0;

            const effectData = MIND_CONTROL_EFFECTS[randomEffect];

            // Random eye pattern
            hypnoEyePattern = Math.floor(Math.random() * HYPNO_EYE_PATTERNS.length);

            // Show overlay
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.opacity = '1';
            }

            // Create 3D spiral rings around player
            createHypnoSpirals();

            // Show UI notification
            showHypnosisUI();

            // v6.13: Show mind control effect notification
            if (typeof showNotification === 'function') {
                showNotification(`${effectData.icon} MIND CONTROL: ${effectData.message}`, 'error');
            }

            // Copilot warning about the specific effect
            if (typeof addCopilotMessage === 'function') {
                addCopilotMessage(` ALERT: Hypnotist is using ${effectData.name}! Press SPACE rapidly to break free!`, 'ai');
            }

            console.log('Hypnosis started with effect:', randomEffect);
        }

        // Create swirling spiral rings effect
        // v6.33: Reduced from 5 rings to 2, smaller and less intrusive
        function createHypnoSpirals() {
            if (!scene || !worldState.player) return;

            // Clear existing
            HYPNOSIS_STATE.spiralRings.forEach(ring => {
                if (ring.parent) ring.parent.remove(ring);
                ring.geometry?.dispose();
                ring.material?.dispose();
            });
            HYPNOSIS_STATE.spiralRings = [];

            // Create just 2 subtle rings around the player
            for (let i = 0; i < 2; i++) {
                const radius = 2 + i * 1.5;
                const ringGeo = new THREE.TorusGeometry(radius, 0.08, 8, 48);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0xff00ff : 0x8a2be2,
                    transparent: true,
                    opacity: 0.35 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.5 + i * 0.3;
                ring.userData.baseY = ring.position.y;
                ring.userData.index = i;

                scene.add(ring);
                HYPNOSIS_STATE.spiralRings.push(ring);
            }
        }

        // Update hypnosis effects each frame
        function updateHypnosis(dt) {
            if (!HYPNOSIS_STATE.active) return;

            const elapsed = performance.now() - HYPNOSIS_STATE.startTime;
            const progress = elapsed / HYPNOSIS_STATE.duration;

            // Check if hypnosis ended naturally
            if (progress >= 1) {
                endHypnosis(false);
                return;
            }

            // Update spiral angle
            HYPNOSIS_STATE.spiralAngle += dt * 2;
            HYPNOSIS_STATE.eyePhase += dt;

            // Move spiral rings around player
            if (worldState.player) {
                const playerPos = worldState.player.position;

                HYPNOSIS_STATE.spiralRings.forEach((ring, i) => {
                    ring.position.x = playerPos.x;
                    ring.position.z = playerPos.z;
                    ring.position.y = playerPos.y + ring.userData.baseY + Math.sin(HYPNOSIS_STATE.spiralAngle + i) * 0.5;
                    ring.rotation.z = HYPNOSIS_STATE.spiralAngle * (i % 2 === 0 ? 1 : -1) * 0.5;

                    // Pulsing opacity
                    ring.material.opacity = (0.4 + Math.sin(HYPNOSIS_STATE.spiralAngle * 2 + i) * 0.2) * (1 - progress * 0.3);
                });
            }

            // Update companion eye animation
            updateHypnoEyeAnimation();

            // Move player in trance pattern (toward hypnotist slowly)
            if (worldState.player && HYPNOSIS_STATE.hypnotistMob && !autopilotEnabled) {
                const hypnotistPos = HYPNOSIS_STATE.hypnotistMob.position;
                const playerPos = worldState.player.position;

                // Spiral movement toward hypnotist
                const angle = HYPNOSIS_STATE.spiralAngle * 0.3;
                const spiralRadius = 2 + Math.sin(HYPNOSIS_STATE.spiralAngle * 0.5) * 1;

                const targetX = hypnotistPos.x + Math.cos(angle) * spiralRadius;
                const targetZ = hypnotistPos.z + Math.sin(angle) * spiralRadius;

                // Very slow drift toward hypnotist
                playerPos.x += (targetX - playerPos.x) * dt * 0.3;
                playerPos.z += (targetZ - playerPos.z) * dt * 0.3;
            }

            // Overlay pulsing - v6.33: more subtle
            if (HYPNOSIS_STATE.tranceOverlay) {
                const pulse = 0.4 + Math.sin(HYPNOSIS_STATE.spiralAngle * 2) * 0.15;
                HYPNOSIS_STATE.tranceOverlay.style.opacity = pulse.toString();
            }

            // ==========================================
            // v6.13: MIND CONTROL BEHAVIORAL EFFECTS
            // Robot performs involuntary actions based on hypnotist's agenda
            // ==========================================
            const now = performance.now();
            const timeSinceLastAction = now - HYPNOSIS_STATE.lastMindControlAction;
            const actionInterval = 1500; // Involuntary action every 1.5 seconds

            if (timeSinceLastAction >= actionInterval && HYPNOSIS_STATE.mindControlEffect) {
                HYPNOSIS_STATE.lastMindControlAction = now;

                switch (HYPNOSIS_STATE.mindControlEffect) {
                    case 'resourceDrain':
                        // Robot drops resources involuntarily
                        applyResourceDrainEffect();
                        break;

                    case 'friendlyFire':
                        // Robot might attack nearby allies (agents)
                        applyFriendlyFireEffect();
                        break;

                    case 'selfSabotage':
                        // Robot damages itself or loses progress
                        applySelfSabotageEffect();
                        break;

                    // invertControls is handled in movement code
                }
            }
        }

        // v6.13: Resource Drain - Robot drops items from inventory
        function applyResourceDrainEffect() {
            if (!gameData.inventory || gameData.inventory.length === 0) return;

            // Find a random item to drop
            const filledSlots = gameData.inventory.filter(item => item && item.name);
            if (filledSlots.length === 0) return;

            const randomItem = filledSlots[Math.floor(Math.random() * filledSlots.length)];
            const itemIdx = gameData.inventory.indexOf(randomItem);

            if (itemIdx >= 0 && randomItem.amount > 0) {
                // Reduce amount or remove item
                randomItem.amount--;
                if (randomItem.amount <= 0) {
                    gameData.inventory.splice(itemIdx, 1);
                }

                HYPNOSIS_STATE.resourcesDrained++;

                // Visual feedback
                if (worldState.player) {
                    const dropPos = worldState.player.position.clone();
                    dropPos.y += 1.5;
                    spawnFloater(dropPos, ` Dropped: ${randomItem.name}`, '#ffaa00');

                    if (particles) {
                        particles.emit(dropPos, 10, 0xffaa00, { spread: 3, lifetime: 600 });
                    }
                }

                updateInventoryUI();
            }
        }

        // v6.13: Friendly Fire - Robot might attack nearby agents
        function applyFriendlyFireEffect() {
            if (!worldState.agents || worldState.agents.length === 0) return;

            // 40% chance to actually attack
            if (Math.random() > 0.4) return;

            // Find nearest agent
            let nearestAgent = null;
            let nearestDist = 15;

            for (const agent of worldState.agents) {
                if (!agent.mesh || !agent.active) continue;
                const dist = agent.mesh.position.distanceTo(worldState.player.position);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestAgent = agent;
                }
            }

            if (nearestAgent && nearestAgent.mesh) {
                // Deal damage to the agent
                const damage = Math.floor(5 + Math.random() * 10);
                if (nearestAgent.hp !== undefined) {
                    nearestAgent.hp = Math.max(0, nearestAgent.hp - damage);
                }

                HYPNOSIS_STATE.attackedAllies++;

                // Visual feedback
                const agentPos = nearestAgent.mesh.position.clone();
                spawnFloater(agentPos, ` Confused Attack! -${damage}`, '#ff4444');

                if (particles) {
                    particles.emit(agentPos, 15, 0xff4444, { spread: 2, lifetime: 500 });
                }

                // Copilot warning
                if (typeof addCopilotMessage === 'function' && Math.random() < 0.5) {
                    addCopilotMessage(` Commander! You're attacking our own units! Break free!`, 'ai');
                }
            }
        }

        // v6.13: Self Sabotage - Robot takes self-damage or loses XP
        function applySelfSabotageEffect() {
            // 60% chance to take damage, 40% chance to lose XP
            if (Math.random() < 0.6) {
                // Self-damage
                const damage = Math.floor(3 + Math.random() * 7);
                gameData.player.hp = Math.max(1, gameData.player.hp - damage);

                if (worldState.player) {
                    spawnFloater(worldState.player.position, ` Malfunction! -${damage}`, '#ff6600');

                    if (particles) {
                        particles.emit(worldState.player.position, 12, 0xff6600, { spread: 2, lifetime: 400 });
                    }
                }

                updateHealthUI();
            } else {
                // Lose XP
                const xpLoss = Math.floor(5 + Math.random() * 15);
                gameData.player.xp = Math.max(0, gameData.player.xp - xpLoss);

                if (worldState.player) {
                    spawnFloater(worldState.player.position, ` Memory Leak! -${xpLoss} XP`, '#ff6600');
                }

                updateXPUI();
            }
        }

        // Update the "eye" animation on the companion orb
        function updateHypnoEyeAnimation() {
            if (!copilotMesh || !HYPNOSIS_STATE.active) return;

            const pattern = HYPNO_EYE_PATTERNS[hypnoEyePattern];
            const offset = pattern.fn(HYPNOSIS_STATE.eyePhase);

            HYPNOSIS_STATE.companionEyeOffset = offset;

            // Move the companion's inner orb to create "eye looking around" effect
            const orb = copilotMesh.userData?.orb;
            const core = copilotMesh.userData?.core;

            if (orb) {
                orb.position.x = offset.x;
                orb.position.y = offset.y;
            }
            if (core) {
                core.position.x = offset.x * 0.5;
                core.position.y = offset.y * 0.5;
            }

            // Also make the companion face the hypnotist
            if (HYPNOSIS_STATE.hypnotistMob) {
                copilotMesh.lookAt(HYPNOSIS_STATE.hypnotistMob.position);
            }
        }

        // Show hypnosis UI
        // v6.33: Made less intrusive - smaller, positioned at top instead of center
        function showHypnosisUI() {
            // Create or show the break-free UI
            let hypnoUI = document.getElementById('hypnosis-ui');
            if (!hypnoUI) {
                hypnoUI = document.createElement('div');
                hypnoUI.id = 'hypnosis-ui';
                hypnoUI.style.cssText = `
                    position: fixed;
                    top: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.75);
                    border: 2px solid #ff00ff;
                    border-radius: 10px;
                    padding: 12px 24px;
                    color: #fff;
                    font-family: Georgia, serif;
                    text-align: center;
                    z-index: 1005;
                    animation: hypnoPulse 1.5s ease-in-out infinite;
                `;
                hypnoUI.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;"></div>
                        <div>
                            <div style="font-size: 14px; color: #ff00ff; font-weight: bold;">HYPNOTIZED</div>
                            <div style="font-size: 11px; color: #aaa;">Press <span style="color: #0ff; font-weight: bold;">SPACE</span> to break free</div>
                        </div>
                        <div style="margin-left: 8px;">
                            <div id="hypno-break-bar" style="width: 80px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                                <div id="hypno-break-fill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff00ff, #0ff); transition: width 0.1s;"></div>
                            </div>
                            <div id="hypno-break-text" style="font-size: 10px; color: #888; margin-top: 2px;">0 / ${HYPNOSIS_STATE.maxBreakAttempts}</div>
                        </div>
                    </div>
                `;
                document.body.appendChild(hypnoUI);

                // Add subtle pulse animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes hypnoPulse {
                        0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 255, 0.3); }
                        50% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); }
                    }
                `;
                document.head.appendChild(style);
            }
            hypnoUI.style.display = 'block';
        }

        // Handle break attempt (called when player presses SPACE during hypnosis)
        function attemptBreakHypnosis() {
            if (!HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.breakAttempts++;

            // Update UI
            const fill = document.getElementById('hypno-break-fill');
            const text = document.getElementById('hypno-break-text');
            if (fill) {
                fill.style.width = (HYPNOSIS_STATE.breakAttempts / HYPNOSIS_STATE.maxBreakAttempts * 100) + '%';
            }
            if (text) {
                text.textContent = `${HYPNOSIS_STATE.breakAttempts} / ${HYPNOSIS_STATE.maxBreakAttempts}`;
            }

            // Screen flash on attempt
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,255,255,0.3) 0%, rgba(138,43,226,0.4) 100%)';
                setTimeout(() => {
                    if (HYPNOSIS_STATE.tranceOverlay) {
                        HYPNOSIS_STATE.tranceOverlay.style.background = 'radial-gradient(ellipse at center, transparent 20%, rgba(138, 43, 226, 0.1) 40%, rgba(255, 0, 255, 0.2) 60%, rgba(138, 43, 226, 0.4) 100%)';
                    }
                }, 100);
            }

            // Check if broken free
            if (HYPNOSIS_STATE.breakAttempts >= HYPNOSIS_STATE.maxBreakAttempts) {
                endHypnosis(true);
            }
        }

        // End hypnosis effect
        function endHypnosis(brokeFreeBySelf) {
            if (!HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.active = false;

            // Hide overlay
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.opacity = '0';
            }

            // Remove spiral rings
            HYPNOSIS_STATE.spiralRings.forEach(ring => {
                if (ring.parent) ring.parent.remove(ring);
                ring.geometry?.dispose();
                ring.material?.dispose();
            });
            HYPNOSIS_STATE.spiralRings = [];

            // Reset companion eye position
            if (copilotMesh) {
                const orb = copilotMesh.userData?.orb;
                const core = copilotMesh.userData?.core;
                if (orb) { orb.position.x = 0; orb.position.y = 0; }
                if (core) { core.position.x = 0; core.position.y = 0; }
            }

            // Hide UI
            const hypnoUI = document.getElementById('hypnosis-ui');
            if (hypnoUI) hypnoUI.style.display = 'none';

            // If broke free, damage the hypnotist!
            if (brokeFreeBySelf && HYPNOSIS_STATE.hypnotistMob) {
                const damage = HYPNOSIS_STATE.breakDamage;
                HYPNOSIS_STATE.hypnotistMob.userData.hp -= damage;

                // Show damage effect
                if (typeof createDamageNumber === 'function') {
                    createDamageNumber(HYPNOSIS_STATE.hypnotistMob.position.clone(), damage, 0x00ffff);
                }

                // Notification
                if (typeof showNotification === 'function') {
                    showNotification(` You broke free! Dealt ${damage} psychic damage to the Hypnotist!`, 'success');
                }

                // Screen shake
                if (typeof screenShake === 'function') {
                    screenShake(0.5);
                }

                // Check if hypnotist died
                if (HYPNOSIS_STATE.hypnotistMob.userData.hp <= 0) {
                    // Handle death
                    const xpReward = HYPNOSIS_STATE.hypnotistMob.userData.xpReward || 400;
                    if (typeof addXp === 'function') addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;

                    if (typeof showNotification === 'function') {
                        showNotification(' Hypnotist defeated by psychic backlash!', 'success');
                    }

                    // Remove from scene
                    if (HYPNOSIS_STATE.hypnotistMob.parent) {
                        scene.remove(HYPNOSIS_STATE.hypnotistMob);
                    }
                    const idx = worldState.mobs.indexOf(HYPNOSIS_STATE.hypnotistMob);
                    if (idx > -1) worldState.mobs.splice(idx, 1);
                }
            } else if (!brokeFreeBySelf) {
                // Hypnosis wore off naturally - player takes some damage
                if (worldState.player) {
                    const damage = 10;
                    gameData.player.hp = Math.max(1, gameData.player.hp - damage); // v6.41: Fixed wrong property access
                    if (typeof updateHealthUI === 'function') updateHealthUI();
                    if (typeof showNotification === 'function') {
                        showNotification(' Hypnosis wore off. You feel drained...', 'warning');
                    }
                }
            }

            HYPNOSIS_STATE.hypnotistMob = null;
        }

        // v4.7: Elite Enemy System - Affixes that modify enemy behavior
        const ELITE_AFFIXES = {
            swift: {
                name: 'Swift',
                prefix: '',
                color: 0x00ffff,
                speedMult: 1.8,
                hpMult: 1.2,
                damageMult: 1.0,
                description: 'Moves much faster'
            },
            armored: {
                name: 'Armored',
                prefix: '',
                color: 0x888888,
                speedMult: 0.8,
                hpMult: 3.0,
                damageMult: 1.0,
                description: 'Extremely tough'
            },
            vampiric: {
                name: 'Vampiric',
                prefix: '',
                color: 0x990000,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 1.2,
                lifesteal: 0.3,
                description: 'Heals on hit'
            },
            explosive: {
                name: 'Explosive',
                prefix: '',
                color: 0xff6600,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 0.8,
                explodeOnDeath: true,
                description: 'Explodes on death'
            },
            berserker: {
                name: 'Berserker',
                prefix: '',
                color: 0xff0000,
                speedMult: 1.2,
                hpMult: 1.0,
                damageMult: 2.0,
                description: 'Deals double damage'
            },
            regenerating: {
                name: 'Regenerating',
                prefix: '',
                color: 0x00ff00,
                speedMult: 1.0,
                hpMult: 1.8,
                damageMult: 1.0,
                regenRate: 0.02,
                description: 'Regenerates health'
            },
            teleporter: {
                name: 'Teleporter',
                prefix: '',
                color: 0x9900ff,
                speedMult: 0.9,
                hpMult: 1.3,
                damageMult: 1.3,
                canTeleport: true,
                description: 'Blinks around'
            },
            frozen: {
                name: 'Frozen',
                prefix: '',
                color: 0x88ddff,
                speedMult: 0.7,
                hpMult: 2.0,
                damageMult: 1.1,
                chillingAura: true,
                description: 'Slows nearby player'
            }
        };

        const ELITE_CONFIG = {
            spawnChance: 0.15,        // 15% chance for elite
            minWorldLevel: 2,         // Only spawn in world level 2+
            essenceDropChance: 0.8,   // 80% chance to drop elite essence
            bonusXpMult: 2.5,         // 2.5x XP from elites
            bonusDropMult: 2          // Double drops from elites
        };

        // v4.7: Session Rewards - Welcome back bonuses
        const SESSION_REWARDS = {
            tiers: [
                { minHours: 1, xpBonus: 50, resources: { 'Slime': 2 }, message: 'Quick break bonus!' },
                { minHours: 4, xpBonus: 150, resources: { 'Ore': 3, 'Log': 3 }, message: 'Gone a while bonus!' },
                { minHours: 12, xpBonus: 400, resources: { 'Ore': 8, 'Log': 8, 'Health Potion': 2 }, message: 'Half-day bonus!' },
                { minHours: 24, xpBonus: 1000, resources: { 'Crystal': 2, 'Mystic Orb': 1, 'Health Potion': 3 }, message: 'Daily login bonus!' },
                { minHours: 72, xpBonus: 3000, resources: { 'Elite Essence': 5, 'Legendary Core': 1, 'Super Potion': 2 }, message: 'We missed you bonus!' }
            ],
            maxOfflineHours: 168 // Cap at 1 week
        };

        // v4.6: Get equipped weapon element
        function getEquippedElement() {
            const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade'];
            for (const weapon of weapons) {
                if (hasItem(weapon)) {
                    return ITEMS[weapon].element || null;
                }
            }
            return null;
        }

        // v4.6: Apply status effect to mob
        function applyStatusEffect(mob, element) {
            const effect = STATUS_EFFECTS[element];
            if (!effect) return;

            const data = mob.userData;
            data.statusEffects = data.statusEffects || {};

            // Only apply if not already affected by this element
            if (data.statusEffects[element]) return;

            data.statusEffects[element] = {
                endTime: performance.now() + effect.duration,
                lastTick: performance.now()
            };

            // Apply immediate effects
            if (effect.speedMod) {
                data.speedMultiplier = (data.speedMultiplier || 1) * effect.speedMod;
            }
            if (effect.damageMod) {
                data.damageMultiplier = (data.damageMultiplier || 1) * effect.damageMod;
            }

            // Visual feedback
            mob.material.emissive.setHex(effect.color);
            spawnFloater(mob.position, effect.icon + ' ' + effect.name, '#' + effect.color.toString(16).padStart(6, '0'));
            AudioSystem.hit();
        }

        // v4.6: Update status effects for mob
        function updateMobStatusEffects(mob, time) {
            const data = mob.userData;
            if (!data.statusEffects) return;

            for (const [element, state] of Object.entries(data.statusEffects)) {
                const effect = STATUS_EFFECTS[element];
                if (!effect) continue;

                // Apply DoT
                if (effect.tickDamage && time - state.lastTick >= effect.tickRate) {
                    data.hp -= effect.tickDamage;
                    state.lastTick = time;
                    spawnFloater(mob.position, `-${effect.tickDamage}`, '#' + effect.color.toString(16).padStart(6, '0'));

                    // Check for death by status effect
                    if (data.hp <= 0) {
                        // Will be handled in main mob loop
                    }
                }

                // Check expiration
                if (time >= state.endTime) {
                    // v6.8: Clear effects with division-by-zero safety (Agent consensus - Bug Fix)
                    if (effect.speedMod && effect.speedMod !== 0) {
                        data.speedMultiplier = (data.speedMultiplier || 1) / effect.speedMod;
                        // Sanity clamp to prevent invalid values
                        data.speedMultiplier = Math.max(0.1, Math.min(10, data.speedMultiplier));
                    }
                    if (effect.damageMod && effect.damageMod !== 0) {
                        data.damageMultiplier = (data.damageMultiplier || 1) / effect.damageMod;
                        // Sanity clamp to prevent invalid values
                        data.damageMultiplier = Math.max(0.1, Math.min(10, data.damageMultiplier));
                    }
                    delete data.statusEffects[element];

                    // Restore emissive color if no more effects
                    if (Object.keys(data.statusEffects).length === 0) {
                        const originalEmissive = ENEMY_TYPES[data.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }
            }
        }

        // v4.3: Boss Encounter System
        // v4.5: Added gear check requirements and increased mob kill thresholds
        const BOSS_TYPES = {
            'Terra_Boss': {
                name: 'Ancient Guardian',
                hp: 100, damage: 15, speed: 2, scale: 2.5,
                color: 0x228b22, emissive: 0x114411,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Ancient Artifact', count: 3 }],
                xp: 1000, biome: 'Terra',
                spawnCondition: { mobsKilled: 8, minCombatLevel: 2 },
                attackWindup: 1000, attackRange: 4
            },
            'Desert_Boss': {
                name: 'Sandstorm Titan',
                hp: 120, damage: 18, speed: 3, scale: 2.8,
                color: 0xcc8844, emissive: 0x664422,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Chitin', count: 10 }],
                xp: 1200, biome: 'Desert',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 3, requiredItem: 'Sword' },
                attackWindup: 900, attackRange: 4.5
            },
            'Ice_Boss': {
                name: 'Frost Monarch',
                hp: 90, damage: 20, speed: 4, scale: 2.2,
                color: 0x88ddff, emissive: 0x4488aa,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Frost Shard', count: 10 }],
                xp: 1100, biome: 'Ice',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 4 },
                attackWindup: 700, attackRange: 5
            },
            'Volcanic_Boss': {
                name: 'Magma Colossus',
                hp: 150, damage: 25, speed: 1.5, scale: 3,
                color: 0xff4400, emissive: 0xaa2200,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Magma Gem', count: 10 }],
                xp: 1500, biome: 'Volcanic',
                spawnCondition: { mobsKilled: 12, minCombatLevel: 5, requiredItem: 'Frost Blade' },
                attackWindup: 1500, attackRange: 5
            },
            'Alien_Boss': {
                name: 'Void Leviathan',
                hp: 200, damage: 30, speed: 3, scale: 3.5,
                color: 0x8800ff, emissive: 0x440088,
                drops: [{ item: 'Boss Trophy', count: 2 }, { item: 'Void Fragment', count: 15 }, { item: 'Legendary Core', count: 1 }],
                xp: 2500, biome: 'Alien',
                spawnCondition: { mobsKilled: 15, minCombatLevel: 7, requiredItem: 'Magma Sword' },
                attackWindup: 800, attackRange: 6
            }
        };

        // v4.2: Points of Interest System
        const POI_TYPES = {
            'ancient_ruins': {
                name: 'Ancient Ruins', icon: '', rarity: 0.12,
                rewards: [{ item: 'Ancient Artifact', count: 1 }],
                xpBonus: 200, biomes: null
            },
            'crystal_cave': {
                name: 'Crystal Cavern', icon: '', rarity: 0.10,
                rewards: [{ item: 'Crystal', count: [2, 5] }],
                xpBonus: 150, biomes: ['Ice', 'Alien']
            },
            'oasis': {
                name: 'Hidden Oasis', icon: '', rarity: 0.15,
                rewards: [{ item: 'Healing Spring', count: 1 }],
                xpBonus: 100, biomes: ['Desert']
            },
            'volcano_vent': {
                name: 'Volcanic Vent', icon: '', rarity: 0.12,
                rewards: [{ item: 'Obsidian', count: [1, 3] }],
                xpBonus: 175, biomes: ['Volcanic']
            },
            'crashed_ship': {
                name: 'Crashed Vessel', icon: '', rarity: 0.06,
                rewards: [{ item: 'Tech Fragment', count: 1 }, { item: 'Power Cell', count: 1 }],
                xpBonus: 300, biomes: null
            },
            'mystic_shrine': {
                name: 'Mystic Shrine', icon: '', rarity: 0.08,
                rewards: [{ item: 'Mystic Orb', count: 1 }],
                xpBonus: 250, biomes: ['Terra', 'Alien']
            }
        };

        // v4.2: Player Ranks and Titles
        const PLAYER_RANKS = [
            { points: 0, title: 'Novice Explorer', color: '#888888' },
            { points: 100, title: 'Wanderer', color: '#44ff44' },
            { points: 500, title: 'Pathfinder', color: '#4488ff' },
            { points: 1500, title: 'Star Scout', color: '#ff8844' },
            { points: 5000, title: 'Galaxy Ranger', color: '#ff44ff' },
            { points: 15000, title: 'Cosmic Legend', color: '#ffd700' }
        ];

        const SPECIAL_TITLES = {
            'Slime Bane': { condition: (s, sk) => s.mobsKilled >= 100, color: '#ff4444' },
            'Master Lumberjack': { condition: (s, sk) => sk.wood.level >= 10, color: '#44aa44' },
            'Deep Miner': { condition: (s, sk) => sk.mining.level >= 10, color: '#888888' },
            'Cosmic Wanderer': { condition: (s, sk) => gameData.visitedPlanets.length >= 50, color: '#00ffff' },
            'Combat Master': { condition: (s, sk) => sk.combat.level >= 10, color: '#ff6644' },
            'Master Angler': { condition: (s, sk) => sk.fishing.level >= 10, color: '#4488ff' }
        };

        const ITEMS = {
            // Base resources
            'Log': { icon: '', stackable: true, maxStack: 99 },
            'Ore': { icon: '', stackable: true, maxStack: 99 },
            'Slime': { icon: '', stackable: true, maxStack: 99 },
            'Raw Fish': { icon: '', stackable: true, maxStack: 99 },
            'Cooked Fish': { icon: '', stackable: true, maxStack: 99, heal: 20 },
            // v4.2: Biome-specific enemy drops
            'Chitin': { icon: '', stackable: true, maxStack: 99 },
            'Frost Shard': { icon: '', stackable: true, maxStack: 99 },
            'Magma Gem': { icon: '', stackable: true, maxStack: 99 },
            'Void Fragment': { icon: '', stackable: true, maxStack: 99 },
            // v4.2: POI rewards
            'Ancient Artifact': { icon: '', stackable: true, maxStack: 20 },
            'Crystal': { icon: '', stackable: true, maxStack: 50 },
            'Healing Spring': { icon: '', stackable: true, maxStack: 10, heal: 100 },
            'Obsidian': { icon: '', stackable: true, maxStack: 50 },
            'Tech Fragment': { icon: '', stackable: true, maxStack: 20 },
            'Power Cell': { icon: '', stackable: true, maxStack: 10 },
            'Mystic Orb': { icon: '', stackable: true, maxStack: 10 },
            // Tools
            'Pickaxe': { icon: '', stackable: false, miningBonus: 2 },
            'Sword': { icon: '', stackable: false, combatBonus: 5 },
            'Fishing Rod': { icon: '', stackable: false, fishingBonus: 2 },
            'Health Potion': { icon: '', stackable: true, maxStack: 10, heal: 50 },
            // v4.2: New craftables
            'Frost Blade': { icon: '', stackable: false, combatBonus: 8, element: 'ice' },
            'Magma Sword': { icon: '', stackable: false, combatBonus: 10, element: 'fire' },
            'Void Dagger': { icon: '', stackable: false, combatBonus: 12, element: 'void' },
            'Crystal Pickaxe': { icon: '', stackable: false, miningBonus: 3 },
            'Super Potion': { icon: '', stackable: true, maxStack: 10, heal: 100 },
            'Chitin Armor': { icon: '', stackable: false, defenseBonus: 5 },
            // v4.3: Boss rewards
            'Boss Trophy': { icon: '', stackable: true, maxStack: 20 },
            'Legendary Core': { icon: '', stackable: true, maxStack: 5 },
            // v4.3: Legendary gear (requires boss materials)
            'Legendary Blade': { icon: '', stackable: false, combatBonus: 20, element: 'cosmic' },
            'Guardian Armor': { icon: '', stackable: false, defenseBonus: 15 },
            // v4.7: Elite enemy drops
            'Elite Essence': { icon: '', stackable: true, maxStack: 99 },
            'Berserker Badge': { icon: '', stackable: false, combatBonus: 15, attackSpeedMult: 1.3 },
            'Vampiric Fang': { icon: '', stackable: false, combatBonus: 10, lifesteal: 0.15 },
            'Frost Heart': { icon: '', stackable: false, defenseBonus: 10, element: 'ice' },
            // v5.1: New craftable equipment
            'Iron Armor': { icon: '', stackable: false, defenseBonus: 3 },
            'Steel Armor': { icon: '', stackable: false, defenseBonus: 8 },
            'Lucky Charm': { icon: '', stackable: false },
            'Swift Boots': { icon: '', stackable: false },
            'Power Ring': { icon: '', stackable: false },
            'Master Rod': { icon: '', stackable: false, fishingBonus: 4 },
            // v5.1: Enchantment materials
            'Enchant Shard': { icon: '', stackable: true, maxStack: 50 },
            'Arcane Dust': { icon: '', stackable: true, maxStack: 99 },
            // v5.3: Portal realm rewards
            'Shadow Essence': { icon: '', stackable: true, maxStack: 50 },
            'Dark Crystal': { icon: '', stackable: true, maxStack: 30 },
            'Frozen Heart': { icon: '', stackable: true, maxStack: 30 },
            'Permafrost Shard': { icon: '', stackable: true, maxStack: 50 },
            'Infernal Core': { icon: '', stackable: true, maxStack: 30 },
            'Magma Heart': { icon: '', stackable: true, maxStack: 30 },
            'Void Core': { icon: '', stackable: true, maxStack: 20 },
            'Dimension Shard': { icon: '', stackable: true, maxStack: 30 },
            'Celestial Essence': { icon: '', stackable: true, maxStack: 10 },
            'Star Fragment': { icon: '', stackable: true, maxStack: 20 },
            'Mythic Orb': { icon: '', stackable: false, combatBonus: 25, element: 'cosmic', defenseBonus: 10 },
            // v5.4: World Event items
            'Meteor Ore': { icon: '', stackable: true, maxStack: 30, description: 'Rare ore from a meteor shower' },
            'Cosmic Dust': { icon: '', stackable: true, maxStack: 99, description: 'Glittering cosmic particles' },
            'Gold Chest': { icon: '', stackable: true, maxStack: 10, description: 'A treasure chest filled with gold' },
            'Silver Chest': { icon: '', stackable: true, maxStack: 20, description: 'A treasure chest with silver' },
            'Ancient Relic': { icon: '', stackable: true, maxStack: 10, description: 'An ancient relic of power' },
            'Rune Stone': { icon: '', stackable: true, maxStack: 20, description: 'Stone inscribed with ancient runes' },
            'Lost Technology': { icon: '', stackable: true, maxStack: 10, description: 'Advanced technology from a lost civilization' },
            'Rainbow Crystal': { icon: '', stackable: true, maxStack: 15, description: 'A crystal that shimmers with all colors' },
            'Pure Crystal': { icon: '', stackable: true, maxStack: 20, description: 'A perfectly pure crystal' },
            'Crystal Shard': { icon: '', stackable: true, maxStack: 50, description: 'A small crystal fragment' },
            // v6.68: SET ITEMS - Equipment that grants bonuses when worn together
            // Voidwalker Set
            'Void Cloak': { icon: '', stackable: false, defenseBonus: 12, element: 'void', description: 'A cloak woven from void energy' },
            'Void Ring': { icon: '', stackable: false, combatBonus: 8, element: 'void', description: 'A ring that pulses with void power' },
            // Inferno Set
            'Inferno Plate': { icon: '', stackable: false, defenseBonus: 15, element: 'fire', description: 'Armor forged in volcanic fire' },
            'Flame Ring': { icon: '', stackable: false, combatBonus: 10, element: 'fire', description: 'A ring burning with eternal flame' },
            // Frostborne Set
            'Frost Armor': { icon: '', stackable: false, defenseBonus: 14, element: 'ice', description: 'Armor made of enchanted permafrost' },
            // Berserker Set
            'Berserker Helm': { icon: '', stackable: false, defenseBonus: 8, combatBonus: 5, description: 'A helm that amplifies rage' },
            'Berserker Gauntlets': { icon: '', stackable: false, combatBonus: 12, attackSpeedMult: 1.1, description: 'Gauntlets that never tire' },
            // Guardian Set
            'Guardian Shield': { icon: '', stackable: false, defenseBonus: 20, description: 'An impenetrable shield of light' },
            'Guardian Helm': { icon: '', stackable: false, defenseBonus: 12, description: 'A helm blessed by guardians' },
            // Harvester Set
            'Harvester Vest': { icon: '', stackable: false, defenseBonus: 5, description: 'A vest with many pockets for resources' },
            // Celestial Set
            'Celestial Armor': { icon: '', stackable: false, defenseBonus: 25, combatBonus: 10, element: 'cosmic', description: 'Armor woven from starlight' }
        };

        const RECIPES = {
            'pickaxe': { result: 'Pickaxe', requires: { 'Ore': 3, 'Log': 2 } },
            'sword': { result: 'Sword', requires: { 'Ore': 5, 'Log': 1 } },
            'rod': { result: 'Fishing Rod', requires: { 'Log': 2 } },
            'cookedFish': { result: 'Cooked Fish', requires: { 'Raw Fish': 1 } },
            'potion': { result: 'Health Potion', requires: { 'Slime': 2 } },
            // v4.2: New recipes using biome materials
            'frostBlade': { result: 'Frost Blade', requires: { 'Ore': 8, 'Frost Shard': 5 }, craftingLevel: 5 },
            'magmaSword': { result: 'Magma Sword', requires: { 'Ore': 10, 'Magma Gem': 5 }, craftingLevel: 7 },
            'voidDagger': { result: 'Void Dagger', requires: { 'Ore': 12, 'Void Fragment': 5 }, craftingLevel: 10 },
            'crystalPickaxe': { result: 'Crystal Pickaxe', requires: { 'Ore': 6, 'Crystal': 3 }, craftingLevel: 6 },
            'superPotion': { result: 'Super Potion', requires: { 'Slime': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'chitinArmor': { result: 'Chitin Armor', requires: { 'Chitin': 10, 'Log': 5 }, craftingLevel: 4 },
            // v4.3: Legendary recipes (requires boss materials)
            'legendaryBlade': { result: 'Legendary Blade', requires: { 'Boss Trophy': 5, 'Legendary Core': 1, 'Ore': 20 }, craftingLevel: 15 },
            'guardianArmor': { result: 'Guardian Armor', requires: { 'Boss Trophy': 3, 'Chitin': 20, 'Crystal': 5 }, craftingLevel: 12 },
            // v4.7: Elite gear recipes
            'berserkerBadge': { result: 'Berserker Badge', requires: { 'Elite Essence': 10, 'Magma Gem': 3 }, craftingLevel: 10 },
            'vampiricFang': { result: 'Vampiric Fang', requires: { 'Elite Essence': 15, 'Void Fragment': 5 }, craftingLevel: 12 },
            'frostHeart': { result: 'Frost Heart', requires: { 'Elite Essence': 12, 'Frost Shard': 8, 'Crystal': 3 }, craftingLevel: 11 },
            // v5.1: New equipment recipes
            'ironArmor': { result: 'Iron Armor', requires: { 'Ore': 8, 'Log': 3 }, craftingLevel: 2 },
            'steelArmor': { result: 'Steel Armor', requires: { 'Ore': 15, 'Crystal': 2 }, craftingLevel: 8 },
            'luckyCharm': { result: 'Lucky Charm', requires: { 'Crystal': 5, 'Mystic Orb': 2 }, craftingLevel: 6 },
            'swiftBoots': { result: 'Swift Boots', requires: { 'Chitin': 8, 'Slime': 5 }, craftingLevel: 5 },
            'powerRing': { result: 'Power Ring', requires: { 'Ore': 10, 'Magma Gem': 3 }, craftingLevel: 7 },
            'masterRod': { result: 'Master Rod', requires: { 'Log': 10, 'Crystal': 3, 'Frost Shard': 2 }, craftingLevel: 9 },
            // v5.1: Enchantment material crafting
            'enchantShard': { result: 'Enchant Shard', requires: { 'Crystal': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'arcaneDust': { result: 'Arcane Dust', requires: { 'Slime': 5, 'Void Fragment': 1 }, craftingLevel: 6 },
            // v6.1: ALCHEMY RECIPES - New potion brewing system
            'manaPotion': { result: 'Mana Potion', requires: { 'Crystal': 2, 'Slime': 1 }, alchemyLevel: 1, isAlchemy: true },
            'strengthElixir': { result: 'Strength Elixir', requires: { 'Magma Gem': 2, 'Slime': 2 }, alchemyLevel: 3, isAlchemy: true },
            'speedTonic': { result: 'Speed Tonic', requires: { 'Frost Shard': 2, 'Slime': 2 }, alchemyLevel: 3, isAlchemy: true },
            'defenseOil': { result: 'Defense Oil', requires: { 'Ore': 3, 'Slime': 3 }, alchemyLevel: 4, isAlchemy: true },
            'luckyDraught': { result: 'Lucky Draught', requires: { 'Mystic Orb': 1, 'Crystal': 2 }, alchemyLevel: 5, isAlchemy: true },
            'berserkerBrew': { result: 'Berserker Brew', requires: { 'Magma Gem': 3, 'Elite Essence': 2 }, alchemyLevel: 7, isAlchemy: true },
            'invisibilityPotion': { result: 'Invisibility Potion', requires: { 'Void Fragment': 3, 'Slime': 3 }, alchemyLevel: 8, isAlchemy: true },
            'phoenixTears': { result: 'Phoenix Tears', requires: { 'Legendary Core': 1, 'Magma Gem': 5, 'Crystal': 5 }, alchemyLevel: 12, isAlchemy: true },
            'transmutation': { result: 'Transmuted Ore', requires: { 'Log': 10 }, alchemyLevel: 2, isAlchemy: true },
            'antidote': { result: 'Antidote', requires: { 'Antidote Sample': 2, 'Slime': 1 }, alchemyLevel: 2, isAlchemy: true },
            // v6.68: SET ITEM RECIPES - Craft complete sets for powerful bonuses
            // Voidwalker Set
            'voidCloak': { result: 'Void Cloak', requires: { 'Void Fragment': 15, 'Shadow Essence': 10, 'Dimension Shard': 5 }, craftingLevel: 14 },
            'voidRing': { result: 'Void Ring', requires: { 'Void Fragment': 8, 'Void Core': 3, 'Crystal': 5 }, craftingLevel: 12 },
            // Inferno Set
            'infernoPlate': { result: 'Inferno Plate', requires: { 'Magma Gem': 20, 'Infernal Core': 5, 'Ore': 25 }, craftingLevel: 15 },
            'flameRing': { result: 'Flame Ring', requires: { 'Magma Gem': 10, 'Magma Heart': 3, 'Crystal': 5 }, craftingLevel: 11 },
            // Frostborne Set
            'frostArmor': { result: 'Frost Armor', requires: { 'Frost Shard': 20, 'Frozen Heart': 5, 'Permafrost Shard': 10 }, craftingLevel: 13 },
            // Berserker Set
            'berserkerHelm': { result: 'Berserker Helm', requires: { 'Elite Essence': 15, 'Magma Gem': 8, 'Ore': 15 }, craftingLevel: 13 },
            'berserkerGauntlets': { result: 'Berserker Gauntlets', requires: { 'Elite Essence': 20, 'Boss Trophy': 2, 'Ore': 12 }, craftingLevel: 14 },
            // Guardian Set
            'guardianShield': { result: 'Guardian Shield', requires: { 'Boss Trophy': 4, 'Crystal': 15, 'Ore': 30 }, craftingLevel: 16 },
            'guardianHelm': { result: 'Guardian Helm', requires: { 'Boss Trophy': 2, 'Crystal': 10, 'Chitin': 15 }, craftingLevel: 14 },
            // Harvester Set
            'harvesterVest': { result: 'Harvester Vest', requires: { 'Log': 20, 'Chitin': 15, 'Crystal': 5 }, craftingLevel: 8 },
            // Celestial Set
            'celestialArmor': { result: 'Celestial Armor', requires: { 'Celestial Essence': 5, 'Star Fragment': 15, 'Legendary Core': 2, 'Crystal': 20 }, craftingLevel: 20 }
        };

        // v6.1: ALCHEMY POTION EFFECTS - Applied when consumed
        const POTION_EFFECTS = {
            'Health Potion': { effect: 'heal', value: 30, duration: 0 },
            'Super Potion': { effect: 'heal', value: 75, duration: 0 },
            'Mana Potion': { effect: 'cooldownReset', value: 0.5, duration: 0 },
            'Strength Elixir': { effect: 'damage', value: 1.25, duration: 30000 },
            'Speed Tonic': { effect: 'speed', value: 1.3, duration: 25000 },
            'Defense Oil': { effect: 'defense', value: 1.4, duration: 30000 },
            'Lucky Draught': { effect: 'luck', value: 1.5, duration: 45000 },
            'Berserker Brew': { effect: 'berserk', value: 1.5, duration: 20000 }, // +50% damage, -20% defense
            'Invisibility Potion': { effect: 'stealth', value: 1, duration: 15000 },
            'Phoenix Tears': { effect: 'revive', value: 1, duration: 0 } // Auto-revive on death
        };

        // v6.1: Active potion buffs tracker
        let activePotionBuffs = {};

        function consumePotion(potionName) {
            const effect = POTION_EFFECTS[potionName];
            if (!effect) return false;

            const now = performance.now();

            switch (effect.effect) {
                case 'heal':
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + effect.value);
                    updateHealthUI();
                    spawnFloater(worldState.player.position, ` +${effect.value} HP`, '#44ff44');
                    break;

                case 'cooldownReset':
                    // Reset ability cooldowns by 50%
                    Object.keys(abilityCooldowns).forEach(key => {
                        abilityCooldowns[key] = Math.max(0, abilityCooldowns[key] - 5000);
                    });
                    spawnFloater(worldState.player.position, ` Cooldowns reduced!`, '#00ffff');
                    break;

                case 'damage':
                case 'speed':
                case 'defense':
                case 'luck':
                case 'berserk':
                case 'stealth':
                    activePotionBuffs[effect.effect] = {
                        value: effect.value,
                        endTime: now + effect.duration,
                        name: potionName
                    };
                    spawnFloater(worldState.player.position, ` ${potionName} active!`, '#ff88ff');
                    showNotification(`${potionName} buff active for ${Math.floor(effect.duration / 1000)}s!`, 'buff');
                    break;

                case 'revive':
                    activePotionBuffs.phoenixTears = { value: 1, endTime: now + 300000, name: potionName };
                    spawnFloater(worldState.player.position, ` Phoenix protection active!`, '#ff8800');
                    showNotification('Phoenix Tears: You will auto-revive on death for 5 minutes!', 'buff');
                    break;
            }

            // Remove from inventory
            removeFromInventory(potionName, 1);
            AudioSystem.levelUp();
            addXp('alchemy', 25);
            return true;
        }

        function getPotionBuffMultiplier(buffType) {
            const buff = activePotionBuffs[buffType];
            if (!buff || performance.now() > buff.endTime) {
                delete activePotionBuffs[buffType];
                return 1;
            }
            return buff.value;
        }

        function updatePotionBuffs() {
            const now = performance.now();
            let buffExpired = false;
            Object.keys(activePotionBuffs).forEach(key => {
                if (now > activePotionBuffs[key].endTime) {
                    showNotification(`${activePotionBuffs[key].name} buff expired`, 'info');
                    delete activePotionBuffs[key];
                    buffExpired = true;
                }
            });
            if (buffExpired) updateBuffsUI();
        }

        // v6.1: Update active buffs UI display
        function updateBuffsUI() {
            const container = document.getElementById('active-buffs-container');
            const list = document.getElementById('active-buffs-list');
            if (!container || !list) return;

            const buffKeys = Object.keys(activePotionBuffs);
            if (buffKeys.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            list.innerHTML = '';

            const now = performance.now();
            const buffIcons = {
                damage: '',
                speed: '',
                defense: '',
                luck: '',
                berserk: '',
                stealth: '',
                phoenixTears: ''
            };

            buffKeys.forEach(key => {
                const buff = activePotionBuffs[key];
                const timeLeft = Math.max(0, Math.ceil((buff.endTime - now) / 1000));
                const icon = buffIcons[key] || '';

                const buffEl = document.createElement('div');
                buffEl.style.cssText = 'background: rgba(255, 136, 255, 0.2); border: 1px solid #ff88ff; border-radius: 4px; padding: 2px 6px; font-size: 10px; display: flex; align-items: center; gap: 3px;';
                buffEl.innerHTML = `<span>${icon}</span><span style="color: #fff;">${timeLeft}s</span>`;
                buffEl.title = buff.name;
                list.appendChild(buffEl);
            });
        }

        // v5.1: Equipment System
        const EQUIPMENT_SLOTS = {
            weapon: { name: 'Weapon', icon: '', statKey: 'combatBonus' },
            armor: { name: 'Armor', icon: '', statKey: 'defenseBonus' },
            accessory: { name: 'Accessory', icon: '', statKey: 'special' },
            tool: { name: 'Tool', icon: '', statKey: 'toolBonus' }
        };

        // v5.1: Map items to equipment slots
        const EQUIPMENT_MAP = {
            // Weapons
            'Sword': { slot: 'weapon', stats: { damage: 5 } },
            'Frost Blade': { slot: 'weapon', stats: { damage: 8, element: 'ice' } },
            'Magma Sword': { slot: 'weapon', stats: { damage: 10, element: 'fire' } },
            'Void Dagger': { slot: 'weapon', stats: { damage: 12, element: 'void' } },
            'Legendary Blade': { slot: 'weapon', stats: { damage: 20, element: 'cosmic', critChance: 0.15 } },
            // Armor (tiered)
            'Iron Armor': { slot: 'armor', stats: { defense: 3 } },
            'Chitin Armor': { slot: 'armor', stats: { defense: 5 } },
            'Steel Armor': { slot: 'armor', stats: { defense: 8 } },
            'Guardian Armor': { slot: 'armor', stats: { defense: 15, maxHpBonus: 50 } },
            // Accessories
            'Berserker Badge': { slot: 'accessory', stats: { damage: 15, attackSpeed: 1.3 } },
            'Vampiric Fang': { slot: 'accessory', stats: { damage: 10, lifesteal: 0.15 } },
            'Frost Heart': { slot: 'accessory', stats: { defense: 10, element: 'ice' } },
            'Lucky Charm': { slot: 'accessory', stats: { critChance: 0.10, lootBonus: 0.15 } },
            'Swift Boots': { slot: 'accessory', stats: { moveSpeed: 1.15, dodgeBonus: 0.1 } },
            'Power Ring': { slot: 'accessory', stats: { damage: 8, critChance: 0.05 } },
            // Tools
            'Pickaxe': { slot: 'tool', stats: { miningBonus: 2 } },
            'Crystal Pickaxe': { slot: 'tool', stats: { miningBonus: 3 } },
            'Fishing Rod': { slot: 'tool', stats: { fishingBonus: 2 } },
            'Master Rod': { slot: 'tool', stats: { fishingBonus: 4 } }
        };

        // 
        // v6.16: AUTO-CRAFT & AUTO-EQUIP SYSTEM
        // "Cream rises to the top" - automatically craft and equip best items
        // No manual inventory management needed
        // 

        // Item power rankings by slot (higher = better, auto-equips over lower)
        const ITEM_POWER = {
            // Weapons (by damage output)
            'Sword': 5,
            'Frost Blade': 10,
            'Magma Sword': 15,
            'Void Dagger': 18,
            'Legendary Blade': 30,

            // Armor (by defense)
            'Iron Armor': 5,
            'Chitin Armor': 8,
            'Steel Armor': 12,
            'Guardian Armor': 25,

            // Accessories (by overall utility)
            'Lucky Charm': 10,
            'Swift Boots': 12,
            'Power Ring': 14,
            'Frost Heart': 16,
            'Berserker Badge': 20,
            'Vampiric Fang': 22,

            // Tools (by bonus effectiveness)
            'Pickaxe': 5,
            'Crystal Pickaxe': 12,
            'Fishing Rod': 5,
            'Master Rod': 15
        };

        // Recipe crafting priority (higher = craft first when materials available)
        const RECIPE_CRAFT_PRIORITY = {
            // Legendary tier (always craft if possible)
            'legendaryBlade': 100,
            'guardianArmor': 95,

            // Elite tier
            'vampiricFang': 80,
            'berserkerBadge': 75,
            'frostHeart': 70,

            // High tier weapons/armor
            'voidDagger': 60,
            'steelArmor': 55,
            'magmaSword': 50,
            'masterRod': 45,

            // Mid tier
            'frostBlade': 40,
            'crystalPickaxe': 38,
            'powerRing': 35,
            'luckyCharm': 32,
            'swiftBoots': 30,
            'chitinArmor': 28,

            // Base tier (essential early game)
            'ironArmor': 20,
            'sword': 15,
            'pickaxe': 10,
            'rod': 8,

            // Consumables (lower priority, craft for sustain)
            'superPotion': 6,
            'potion': 4
        };

        // Check if a recipe can be crafted right now
        function canCraftRecipe(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return false;

            // Check crafting level
            if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                return false;
            }

            // Skip alchemy recipes (handled by alchemy system)
            if (recipe.isAlchemy) return false;

            // Check all required materials
            for (const [item, count] of Object.entries(recipe.requires)) {
                if (!hasItem(item, count)) return false;
            }

            return true;
        }

        // Check if item is currently equipped
        function isItemEquipped(itemName) {
            const gear = getEquippedGear();
            return Object.values(gear).includes(itemName);
        }

        // Auto-craft the best available items (cream rises)
        function autoCraftBestItems() {
            // Sort recipes by priority (highest first)
            const sortedRecipes = Object.keys(RECIPE_CRAFT_PRIORITY)
                .sort((a, b) => RECIPE_CRAFT_PRIORITY[b] - RECIPE_CRAFT_PRIORITY[a]);

            let craftedSomething = false;

            for (const recipeId of sortedRecipes) {
                if (!canCraftRecipe(recipeId)) continue;

                const recipe = RECIPES[recipeId];
                const resultName = recipe.result;
                const equipData = EQUIPMENT_MAP[resultName];

                // For equipment: only craft if it's better than what we have
                if (equipData) {
                    const slot = equipData.slot;
                    const gear = getEquippedGear();
                    const currentItem = gear[slot];
                    const currentPower = currentItem ? (ITEM_POWER[currentItem] || 0) : 0;
                    const newPower = ITEM_POWER[resultName] || 0;

                    // Don't craft if we already have this or better equipped
                    if (currentPower >= newPower) continue;

                    // Don't craft duplicates in inventory
                    if (countItem(resultName) > 0) continue;
                }

                // For consumables: maintain a small stock
                if (!equipData) {
                    const currentCount = countItem(resultName);
                    // Keep max 5 potions, don't over-craft
                    if (currentCount >= 5) continue;
                }

                // Craft it!
                craft(recipeId, 1);
                craftedSomething = true;

                // Visual/audio feedback for auto-craft
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ` Auto: ${resultName}`, '#a0f');
                }

                break; // Only craft one thing per tick (pace the automation)
            }

            return craftedSomething;
        }

        // Auto-equip the best items in inventory (cream rises to top)
        function autoEquipBestItems() {
            const gear = getEquippedGear();
            let equippedSomething = false;

            // Check each equipment slot
            for (const slotName of ['weapon', 'armor', 'accessory', 'tool']) {
                const currentItem = gear[slotName];
                const currentPower = currentItem ? (ITEM_POWER[currentItem] || 0) : 0;

                // Find best unequipped item in inventory for this slot
                let bestItem = null;
                let bestPower = currentPower;

                // Scan inventory for better items
                const inventoryCounts = {};
                gameData.inventory.forEach(itemName => {
                    inventoryCounts[itemName] = (inventoryCounts[itemName] || 0) + 1;
                });

                for (const itemName of Object.keys(inventoryCounts)) {
                    const equipData = EQUIPMENT_MAP[itemName];
                    if (!equipData || equipData.slot !== slotName) continue;

                    const power = ITEM_POWER[itemName] || 0;
                    if (power > bestPower) {
                        bestPower = power;
                        bestItem = itemName;
                    }
                }

                // Equip if we found something better
                if (bestItem) {
                    // Silent equip (don't spam notifications during auto)
                    const slot = getEquipmentSlot(bestItem);
                    const gearRef = getEquippedGear();

                    // Return current item to inventory if any
                    if (gearRef[slot]) {
                        addItem(gearRef[slot]);
                    }

                    // Remove new item from inventory and equip
                    if (removeItem(bestItem, 1)) {
                        gearRef[slot] = bestItem;
                        updateEquipmentUI();
                        saveGameData();
                        equippedSomething = true;

                        // Visual feedback
                        if (worldState.player) {
                            spawnFloater(worldState.player.position, ` ${bestItem}`, '#4f4');
                        }
                        AudioSystem.collect();
                    }
                }
            }

            return equippedSomething;
        }

        // Auto-craft/equip timer state
        let lastAutoCraftEquipTime = 0;
        const AUTO_CRAFT_EQUIP_INTERVAL = 2000; // Check every 2 seconds

        // Main auto-craft/equip runner (called from game loop)
        function runAutoCraftEquip(now) {
            // Only run when autopilot is enabled (matches player intent for automation)
            if (!autoExplore.enabled) return;

            // Throttle checks
            if (now - lastAutoCraftEquipTime < AUTO_CRAFT_EQUIP_INTERVAL) return;
            lastAutoCraftEquipTime = now;

            // First auto-equip (immediate upgrade)
            autoEquipBestItems();

            // Then auto-craft (prepare for future)
            autoCraftBestItems();
        }

        // v5.1: Equipment state getter (uses gameData for persistence)
        function getEquippedGear() {
            if (!gameData.equipment) {
                gameData.equipment = { weapon: null, armor: null, accessory: null, tool: null };
            }
            return gameData.equipment;
        }

        // v5.1: Equipment functions
        function isEquippable(itemName) {
            return EQUIPMENT_MAP.hasOwnProperty(itemName);
        }

        function getEquipmentSlot(itemName) {
            return EQUIPMENT_MAP[itemName]?.slot || null;
        }

        function equipItem(itemName) {
            if (!isEquippable(itemName)) {
                showNotification('Cannot equip this item!', 'error');
                return false;
            }

            const slot = getEquipmentSlot(itemName);
            const equipData = EQUIPMENT_MAP[itemName];
            const gear = getEquippedGear();

            // Unequip current item in slot (return to inventory)
            if (gear[slot]) {
                addItem(gear[slot]);
                showNotification(`Unequipped ${gear[slot]}`, 'info');
            }

            // Remove from inventory
            if (!removeItem(itemName, 1)) {
                showNotification('Item not in inventory!', 'error');
                return false;
            }

            // Equip new item
            gear[slot] = itemName;
            showNotification(`Equipped ${itemName}!`, 'success');
            AudioSystem.collect();
            updateEquipmentUI();
            saveGameData();
            return true;
        }

        function unequipItem(slot) {
            const gear = getEquippedGear();
            if (!gear[slot]) return;

            const itemName = gear[slot];
            if (gameData.inventory.length >= 20) {
                showNotification('Inventory full!', 'error');
                return;
            }

            addItem(itemName);
            gear[slot] = null;
            showNotification(`Unequipped ${itemName}`, 'info');
            updateEquipmentUI();
            saveGameData();
        }

        function getEquipmentStats() {
            const stats = {
                damage: 0,
                defense: 0,
                miningBonus: 0,
                fishingBonus: 0,
                attackSpeed: 1.0,
                lifesteal: 0,
                critChance: 0,
                maxHpBonus: 0,
                element: null,
                // v5.1: New stats
                moveSpeed: 1.0,
                lootBonus: 0,
                dodgeBonus: 0
            };

            const gear = getEquippedGear();
            for (const slot of Object.keys(gear)) {
                const itemName = gear[slot];
                if (!itemName) continue;

                const equipData = EQUIPMENT_MAP[itemName];
                if (!equipData) continue;

                for (const [stat, value] of Object.entries(equipData.stats)) {
                    if (stat === 'element') {
                        stats.element = value;
                    } else if (stat === 'attackSpeed' || stat === 'moveSpeed') {
                        // Multiplicative stats
                        stats[stat] *= value;
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }

                // v5.1: Add enchantment bonuses
                const enchantBonuses = getEnchantmentBonuses(itemName);
                for (const [stat, value] of Object.entries(enchantBonuses)) {
                    if (stat === 'moveSpeed') {
                        stats[stat] *= value; // Multiplicative for move speed enchants
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }
            }

            return stats;
        }

        function updateEquipmentUI() {
            const gear = getEquippedGear();
            for (const [slot, slotInfo] of Object.entries(EQUIPMENT_SLOTS)) {
                const slotEl = document.getElementById(`equip-slot-${slot}`);
                if (!slotEl) continue;

                const itemName = gear[slot];
                const iconEl = slotEl.querySelector('.equip-icon');
                const nameEl = slotEl.querySelector('.equip-name');

                if (itemName) {
                    const itemDef = ITEMS[itemName];
                    iconEl.textContent = itemDef?.icon || '?';
                    nameEl.textContent = itemName;
                    slotEl.classList.add('equipped');
                } else {
                    iconEl.textContent = slotInfo.icon;
                    nameEl.textContent = 'Empty';
                    slotEl.classList.remove('equipped');
                }
            }

            // Update stats display
            const stats = getEquipmentStats();
            const statsEl = document.getElementById('equipment-stats');
            if (statsEl) {
                let html = `
                    <div style="color: #f44;"> +${stats.damage} DMG</div>
                    <div style="color: #4af;"> +${stats.defense} DEF</div>
                `;
                if (stats.critChance > 0) html += `<div style="color: #fa4;"> +${Math.round(stats.critChance * 100)}% Crit</div>`;
                if (stats.lifesteal > 0) html += `<div style="color: #4f4;"> ${Math.round(stats.lifesteal * 100)}% Lifesteal</div>`;
                if (stats.attackSpeed !== 1.0) html += `<div style="color: #ff4;"> ${Math.round(stats.attackSpeed * 100)}% ATK Spd</div>`;
                if (stats.moveSpeed !== 1.0) html += `<div style="color: #8ff;"> ${Math.round(stats.moveSpeed * 100)}% Move Spd</div>`;
                if (stats.lootBonus > 0) html += `<div style="color: #8f8;"> +${Math.round(stats.lootBonus * 100)}% Loot</div>`;
                if (stats.dodgeBonus > 0) html += `<div style="color: #88f;"> +${Math.round(stats.dodgeBonus * 100)}% Dodge</div>`;
                statsEl.innerHTML = html;
            }
        }

        // v5.1: Enchantment System - v6.68: Massively expanded with new enchantments
        const ENCHANTMENTS = {
            // Original enchantments
            sharpness: { name: 'Sharpness', icon: '', stat: 'damage', bonus: 3, slots: ['weapon'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            fortify: { name: 'Fortify', icon: '', stat: 'defense', bonus: 2, slots: ['armor'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            swiftness: { name: 'Swiftness', icon: '', stat: 'moveSpeed', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 1, 'Arcane Dust': 3 }, multiplicative: true },
            luck: { name: 'Luck', icon: '', stat: 'lootBonus', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 8 } },
            efficiency: { name: 'Efficiency', icon: '', stat: 'miningBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            lure: { name: 'Lure', icon: '', stat: 'fishingBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            critical: { name: 'Critical', icon: '', stat: 'critChance', bonus: 0.05, slots: ['weapon', 'accessory'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 10 } },
            vampiric: { name: 'Vampiric', icon: '', stat: 'lifesteal', bonus: 0.05, slots: ['weapon'], cost: { 'Enchant Shard': 5, 'Arcane Dust': 15 } },
            // v6.68: NEW ENCHANTMENTS
            elemental_fury: { name: 'Elemental Fury', icon: '', stat: 'elementalDamage', bonus: 0.15, slots: ['weapon'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 12 } },
            executioner: { name: 'Executioner', icon: '', stat: 'executeDamage', bonus: 0.20, slots: ['weapon'], cost: { 'Enchant Shard': 5, 'Arcane Dust': 15 } },
            protection: { name: 'Protection', icon: '', stat: 'defense', bonus: 5, slots: ['armor'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 8 } },
            vitality: { name: 'Vitality', icon: '', stat: 'maxHp', bonus: 20, slots: ['armor'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 10 } },
            regeneration: { name: 'Regeneration', icon: '', stat: 'hpRegen', bonus: 0.02, slots: ['armor'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 12 }, multiplicative: true },
            thorns: { name: 'Thorns', icon: '', stat: 'thornsDamage', bonus: 0.05, slots: ['armor'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 10 }, multiplicative: true },
            haste: { name: 'Haste', icon: '', stat: 'attackSpeed', bonus: 0.05, slots: ['accessory', 'weapon'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 8 }, multiplicative: true },
            fortune: { name: 'Fortune', icon: '', stat: 'lootBonus', bonus: 0.10, slots: ['accessory', 'tool'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 12 }, multiplicative: true },
            wisdom: { name: 'Wisdom', icon: '', stat: 'xpBonus', bonus: 0.10, slots: ['accessory'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 10 }, multiplicative: true },
            silk_touch: { name: 'Silk Touch', icon: '', stat: 'bonusRare', bonus: 0.10, slots: ['tool'], cost: { 'Enchant Shard': 5, 'Arcane Dust': 20 }, multiplicative: true },
            unbreaking: { name: 'Unbreaking', icon: '', stat: 'durability', bonus: 1, slots: ['weapon', 'armor', 'tool', 'accessory'], cost: { 'Enchant Shard': 6, 'Arcane Dust': 25 } }
        };

        // v5.1: Get enchantments for an item
        function getItemEnchantments(itemName) {
            if (!gameData.enchantments) gameData.enchantments = {};
            return gameData.enchantments[itemName] || [];
        }

        // v5.1: Check if enchantment can be applied
        function canEnchant(itemName, enchantId) {
            const equipData = EQUIPMENT_MAP[itemName];
            if (!equipData) return false;

            const enchant = ENCHANTMENTS[enchantId];
            if (!enchant) return false;

            // Check slot compatibility
            if (!enchant.slots.includes(equipData.slot)) return false;

            // Check if already has this enchantment
            const currentEnchants = getItemEnchantments(itemName);
            if (currentEnchants.includes(enchantId)) return false;

            // Check max enchantments (3 per item)
            if (currentEnchants.length >= 3) return false;

            // Check materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                if (!hasItem(mat, count)) return false;
            }

            return true;
        }

        // v5.1: Apply enchantment to item
        function applyEnchantment(itemName, enchantId) {
            if (!canEnchant(itemName, enchantId)) {
                showNotification('Cannot apply this enchantment!', 'error');
                return false;
            }

            const enchant = ENCHANTMENTS[enchantId];

            // Consume materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                removeItem(mat, count);
            }

            // Apply enchantment
            if (!gameData.enchantments) gameData.enchantments = {};
            if (!gameData.enchantments[itemName]) gameData.enchantments[itemName] = [];
            gameData.enchantments[itemName].push(enchantId);

            showNotification(`Applied ${enchant.icon} ${enchant.name} to ${itemName}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateEnchantModal();
            updateEquipmentUI();
            return true;
        }

        // v5.1: Get total stats including enchantments
        function getEnchantmentBonuses(itemName) {
            const bonuses = {};
            const enchants = getItemEnchantments(itemName);

            for (const enchantId of enchants) {
                const enchant = ENCHANTMENTS[enchantId];
                if (!enchant) continue;

                if (enchant.multiplicative) {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 1) * (1 + enchant.bonus);
                } else {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 0) + enchant.bonus;
                }
            }

            return bonuses;
        }

        // v5.1: Show enchant modal
        function showEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'flex';
            updateEnchantModal();
        }

        function closeEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'none';
        }

        function updateEnchantModal() {
            const gear = getEquippedGear();
            const itemsDiv = document.getElementById('enchant-items');
            const enchantsDiv = document.getElementById('enchant-options');

            // List equipped items
            let itemsHtml = '';
            for (const [slot, itemName] of Object.entries(gear)) {
                if (!itemName) continue;
                const itemDef = ITEMS[itemName];
                const enchants = getItemEnchantments(itemName);
                const enchantIcons = enchants.map(e => ENCHANTMENTS[e]?.icon || '?').join('');
                itemsHtml += `
                    <div class="enchant-item" onclick="selectEnchantItem('${itemName}')" data-item="${itemName}"
                         style="display: flex; justify-content: space-between; padding: 8px; border: 1px solid #444;
                                border-radius: 4px; cursor: pointer; margin-bottom: 5px;">
                        <span>${itemDef?.icon || '?'} ${itemName}</span>
                        <span style="color: #8af;">${enchantIcons || 'No enchants'}</span>
                    </div>
                `;
            }
            itemsDiv.innerHTML = itemsHtml || '<div style="color: #888;">Equip items first!</div>';

            // Default: no item selected
            enchantsDiv.innerHTML = '<div style="color: #888;">Select an item to enchant</div>';
        }

        let selectedEnchantItem = null;

        function selectEnchantItem(itemName) {
            selectedEnchantItem = itemName;
            const equipData = EQUIPMENT_MAP[itemName];
            const enchantsDiv = document.getElementById('enchant-options');

            // Highlight selected item
            document.querySelectorAll('.enchant-item').forEach(el => {
                el.style.background = el.dataset.item === itemName ? 'rgba(68, 136, 255, 0.2)' : '';
                el.style.borderColor = el.dataset.item === itemName ? '#4af' : '#444';
            });

            // Show available enchantments
            let html = '<div style="font-weight: bold; margin-bottom: 10px;">Available Enchantments:</div>';

            for (const [id, enchant] of Object.entries(ENCHANTMENTS)) {
                if (!enchant.slots.includes(equipData.slot)) continue;

                const canApply = canEnchant(itemName, id);
                const hasIt = getItemEnchantments(itemName).includes(id);
                const costStr = Object.entries(enchant.cost).map(([m, c]) => `${c}x ${m}`).join(', ');

                html += `
                    <div style="padding: 8px; border: 1px solid ${hasIt ? '#4a4' : canApply ? '#448' : '#333'};
                                border-radius: 4px; margin-bottom: 5px; background: ${hasIt ? 'rgba(68,170,68,0.15)' : 'rgba(0,0,0,0.3)'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${enchant.icon} ${enchant.name}</span>
                            ${hasIt ? '<span style="color: #4f4;"> Applied</span>' :
                              canApply ? `<button onclick="applyEnchantment('${itemName}', '${id}')" style="padding: 4px 8px; cursor: pointer;">Apply</button>` :
                              '<span style="color: #666;">Need materials</span>'}
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">+${enchant.bonus}${enchant.multiplicative ? '%' : ''} ${enchant.stat} | Cost: ${costStr}</div>
                    </div>
                `;
            }

            enchantsDiv.innerHTML = html;
        }

        // v5.2: Talent Tree System - v6.68: MASSIVELY EXPANDED with 6 trees
        const TALENT_TREES = {
            combat: {
                name: 'Combat Mastery', icon: '', color: '#ff4444',
                talents: {
                    brutality: { name: 'Brutality', desc: '+5% damage per rank', maxRank: 5, effect: { damage: 0.05 } },
                    toughness: { name: 'Toughness', desc: '+10 max HP per rank', maxRank: 5, effect: { maxHp: 10 } },
                    precision: { name: 'Precision', desc: '+2% crit chance per rank', maxRank: 5, effect: { critChance: 0.02 }, requires: 'brutality' },
                    bloodlust: { name: 'Bloodlust', desc: '+1% lifesteal per rank', maxRank: 3, effect: { lifesteal: 0.01 }, requires: 'precision' },
                    warlord: { name: 'Warlord', desc: '+10% ability damage', maxRank: 1, effect: { abilityDamage: 0.10 }, requires: 'bloodlust' },
                    // v6.68: New combat talents
                    berserker_rage: { name: 'Berserker Rage', desc: '+15% damage when below 30% HP', maxRank: 3, effect: { lowHpDamage: 0.15 }, requires: 'brutality' },
                    armor_crush: { name: 'Armor Crush', desc: 'Attacks reduce enemy defense by 2', maxRank: 3, effect: { armorPen: 2 }, requires: 'precision' },
                    executioner: { name: 'Executioner', desc: '+25% damage to enemies below 25% HP', maxRank: 2, effect: { executeDamage: 0.25 }, requires: 'warlord' },
                    war_cry: { name: 'War Cry', desc: 'Abilities buff allies +10% damage', maxRank: 1, effect: { allyDamageBuff: 0.10 }, requires: 'executioner' }
                }
            },
            survival: {
                name: 'Survival Instinct', icon: '', color: '#44aaff',
                talents: {
                    thick_skin: { name: 'Thick Skin', desc: '+2 defense per rank', maxRank: 5, effect: { defense: 2 } },
                    evasion: { name: 'Evasion', desc: '+3% dodge chance per rank', maxRank: 5, effect: { dodgeChance: 0.03 } },
                    second_wind: { name: 'Second Wind', desc: '+5% HP regen per rank', maxRank: 3, effect: { hpRegen: 0.05 }, requires: 'thick_skin' },
                    fortress: { name: 'Fortress', desc: '+20% shield duration', maxRank: 3, effect: { shieldDuration: 0.20 }, requires: 'evasion' },
                    immortal: { name: 'Immortal', desc: 'Survive fatal blow once/world', maxRank: 1, effect: { deathSave: true }, requires: 'second_wind' },
                    // v6.68: New survival talents
                    iron_will: { name: 'Iron Will', desc: 'Reduce CC duration by 10%', maxRank: 3, effect: { ccReduction: 0.10 }, requires: 'thick_skin' },
                    thorns: { name: 'Thorns', desc: 'Reflect 5% damage back to attackers', maxRank: 3, effect: { thornsDamage: 0.05 }, requires: 'fortress' },
                    last_stand: { name: 'Last Stand', desc: '+30% defense when below 25% HP', maxRank: 2, effect: { lowHpDefense: 0.30 }, requires: 'immortal' },
                    phoenix_spirit: { name: 'Phoenix Spirit', desc: 'Revive with 50% HP once per planet', maxRank: 1, effect: { autoRevive: true }, requires: 'last_stand' }
                }
            },
            fortune: {
                name: 'Fortune Seeker', icon: '', color: '#44ff44',
                talents: {
                    lucky: { name: 'Lucky', desc: '+3% loot drop per rank', maxRank: 5, effect: { lootBonus: 0.03 } },
                    harvester: { name: 'Harvester', desc: '+10% resource yield per rank', maxRank: 5, effect: { resourceYield: 0.10 } },
                    treasure_sense: { name: 'Treasure Sense', desc: '+5% rare find per rank', maxRank: 3, effect: { rareFind: 0.05 }, requires: 'lucky' },
                    midas_touch: { name: 'Midas Touch', desc: '+15% XP gain per rank', maxRank: 3, effect: { xpBonus: 0.15 }, requires: 'harvester' },
                    jackpot: { name: 'Jackpot', desc: 'Double boss loot chance', maxRank: 1, effect: { doubleBossLoot: true }, requires: 'treasure_sense' },
                    // v6.68: New fortune talents
                    scavenger: { name: 'Scavenger', desc: '+1 extra item from resource nodes', maxRank: 2, effect: { extraResource: 1 }, requires: 'harvester' },
                    golden_touch: { name: 'Golden Touch', desc: '+20% chance for items to upgrade rarity', maxRank: 3, effect: { rarityUpgrade: 0.20 }, requires: 'treasure_sense' },
                    hoarder: { name: 'Hoarder', desc: '+5 inventory slots per rank', maxRank: 2, effect: { inventorySlots: 5 }, requires: 'midas_touch' },
                    legendary_luck: { name: 'Legendary Luck', desc: '5% chance for any drop to be Legendary', maxRank: 1, effect: { legendaryChance: 0.05 }, requires: 'jackpot' }
                }
            },
            // v6.68: NEW TREE - Arcane Mastery
            arcane: {
                name: 'Arcane Mastery', icon: '', color: '#aa44ff',
                talents: {
                    mana_pool: { name: 'Mana Pool', desc: '+10% max mana per rank', maxRank: 5, effect: { maxMana: 0.10 } },
                    spell_power: { name: 'Spell Power', desc: '+8% ability damage per rank', maxRank: 5, effect: { spellDamage: 0.08 } },
                    arcane_mastery: { name: 'Arcane Mastery', desc: '-5% ability cooldowns per rank', maxRank: 5, effect: { cooldownReduction: 0.05 }, requires: 'mana_pool' },
                    elemental_attunement: { name: 'Elemental Attunement', desc: '+15% elemental damage', maxRank: 3, effect: { elementalDamage: 0.15 }, requires: 'spell_power' },
                    mystic_barrier: { name: 'Mystic Barrier', desc: 'Abilities grant 5% max HP shield', maxRank: 3, effect: { abilityShield: 0.05 }, requires: 'arcane_mastery' },
                    spell_echo: { name: 'Spell Echo', desc: '15% chance abilities trigger twice', maxRank: 2, effect: { spellEcho: 0.15 }, requires: 'elemental_attunement' },
                    archmage: { name: 'Archmage', desc: 'Abilities cost 30% less mana', maxRank: 1, effect: { manaCostReduction: 0.30 }, requires: 'spell_echo' }
                }
            },
            // v6.68: NEW TREE - Velocity
            velocity: {
                name: 'Velocity', icon: '', color: '#ffaa00',
                talents: {
                    quick_feet: { name: 'Quick Feet', desc: '+3% movement speed per rank', maxRank: 5, effect: { moveSpeed: 0.03 } },
                    attack_speed: { name: 'Attack Speed', desc: '+5% attack speed per rank', maxRank: 5, effect: { attackSpeed: 0.05 } },
                    momentum: { name: 'Momentum', desc: '+2% damage per second moving', maxRank: 3, effect: { momentumDamage: 0.02 }, requires: 'quick_feet' },
                    lightning_reflexes: { name: 'Lightning Reflexes', desc: '+5% dodge while moving', maxRank: 3, effect: { movingDodge: 0.05 }, requires: 'attack_speed' },
                    blitz: { name: 'Blitz', desc: 'First attack after moving deals +20% damage', maxRank: 2, effect: { blitzDamage: 0.20 }, requires: 'momentum' },
                    afterimage: { name: 'Afterimage', desc: '10% chance to leave damaging clone', maxRank: 2, effect: { afterimageChance: 0.10 }, requires: 'lightning_reflexes' },
                    time_dilation: { name: 'Time Dilation', desc: 'Slow nearby enemies by 15%', maxRank: 1, effect: { aoeSlowAura: 0.15 }, requires: 'blitz' }
                }
            },
            // v6.68: NEW TREE - Crafting Mastery
            crafting: {
                name: 'Crafting Mastery', icon: '', color: '#ff8844',
                talents: {
                    efficient_crafting: { name: 'Efficient Crafting', desc: '-5% material cost per rank', maxRank: 5, effect: { materialCost: 0.05 } },
                    quality_work: { name: 'Quality Work', desc: '+10% crafted item stats per rank', maxRank: 5, effect: { craftedStats: 0.10 } },
                    salvage_expert: { name: 'Salvage Expert', desc: '+20% materials from dismantling', maxRank: 3, effect: { salvageYield: 0.20 }, requires: 'efficient_crafting' },
                    masterwork: { name: 'Masterwork', desc: '10% chance craft is auto-upgraded', maxRank: 3, effect: { masterworkChance: 0.10 }, requires: 'quality_work' },
                    enchanting_affinity: { name: 'Enchanting Affinity', desc: '+1 enchantment slot on crafted items', maxRank: 2, effect: { extraEnchantSlot: 1 }, requires: 'salvage_expert' },
                    legendary_smith: { name: 'Legendary Smith', desc: 'Can craft Legendary tier items', maxRank: 1, effect: { craftLegendary: true }, requires: 'masterwork' },
                    dual_craft: { name: 'Dual Craft', desc: '25% chance to craft two items', maxRank: 1, effect: { doubleCraft: 0.25 }, requires: 'legendary_smith' }
                }
            }
        };

        // v6.68: ITEM RARITY SYSTEM - Colors and stat multipliers
        const ITEM_RARITIES = {
            common: { name: 'Common', color: '#aaaaaa', statMult: 1.0, dropWeight: 60 },
            uncommon: { name: 'Uncommon', color: '#1eff00', statMult: 1.2, dropWeight: 25 },
            rare: { name: 'Rare', color: '#0070dd', statMult: 1.5, dropWeight: 10 },
            epic: { name: 'Epic', color: '#a335ee', statMult: 2.0, dropWeight: 4 },
            legendary: { name: 'Legendary', color: '#ff8000', statMult: 3.0, dropWeight: 0.9 },
            mythic: { name: 'Mythic', color: '#ff00ff', statMult: 5.0, dropWeight: 0.1 }
        };

        // v6.68: ITEM SET SYSTEM - Equipping multiple set pieces grants bonuses
        const ITEM_SETS = {
            voidwalker: {
                name: 'Voidwalker Set', color: '#9900ff',
                pieces: ['Void Dagger', 'Void Cloak', 'Void Ring'],
                bonuses: {
                    2: { desc: '+15% Void damage', effect: { voidDamage: 0.15 } },
                    3: { desc: '+30% Void damage, Phase through enemies', effect: { voidDamage: 0.30, phaseWalk: true } }
                }
            },
            inferno: {
                name: 'Inferno Set', color: '#ff4400',
                pieces: ['Magma Sword', 'Inferno Plate', 'Flame Ring'],
                bonuses: {
                    2: { desc: '+20% Fire damage, Burn on hit', effect: { fireDamage: 0.20, burnOnHit: true } },
                    3: { desc: 'Fire nova every 5 kills', effect: { fireNova: 5 } }
                }
            },
            frost: {
                name: 'Frostborne Set', color: '#00ccff',
                pieces: ['Frost Blade', 'Frost Armor', 'Frost Heart'],
                bonuses: {
                    2: { desc: '+15% Ice damage, Slow on hit', effect: { iceDamage: 0.15, slowOnHit: 0.20 } },
                    3: { desc: 'Freeze enemies at low HP', effect: { freezeExecute: true } }
                }
            },
            berserker: {
                name: 'Berserker Set', color: '#cc0000',
                pieces: ['Berserker Badge', 'Berserker Helm', 'Berserker Gauntlets'],
                bonuses: {
                    2: { desc: '+20% Attack Speed, +10% Damage', effect: { attackSpeed: 0.20, damage: 0.10 } },
                    3: { desc: 'Gain Frenzy on kill (+50% speed for 3s)', effect: { frenzyOnKill: true } }
                }
            },
            guardian: {
                name: 'Guardian Set', color: '#4488ff',
                pieces: ['Guardian Armor', 'Guardian Shield', 'Guardian Helm'],
                bonuses: {
                    2: { desc: '+30 Defense, +50 Max HP', effect: { defense: 30, maxHp: 50 } },
                    3: { desc: 'Immunity for 2s when hit below 20% HP', effect: { lowHpImmunity: true } }
                }
            },
            harvester: {
                name: 'Harvester Set', color: '#00ff88',
                pieces: ['Crystal Pickaxe', 'Harvester Vest', 'Master Rod'],
                bonuses: {
                    2: { desc: '+50% Resource yield', effect: { resourceYield: 0.50 } },
                    3: { desc: 'Double XP from gathering', effect: { gatherXpMult: 2.0 } }
                }
            },
            celestial: {
                name: 'Celestial Set', color: '#ffdd00',
                pieces: ['Legendary Blade', 'Celestial Armor', 'Mythic Orb'],
                bonuses: {
                    2: { desc: '+25% All damage, +25% Defense', effect: { damage: 0.25, defense: 25 } },
                    3: { desc: 'Summon star guardian on ability use', effect: { starGuardian: true } }
                }
            }
        };

        // v6.68: Get active set bonuses
        function getActiveSetBonuses() {
            const equippedItems = [];
            if (gameData.equipment) {
                Object.values(gameData.equipment).forEach(item => {
                    if (item && item.name) equippedItems.push(item.name);
                });
            }

            const bonuses = { effects: {}, activesets: [] };

            for (const [setId, setData] of Object.entries(ITEM_SETS)) {
                const piecesEquipped = setData.pieces.filter(p => equippedItems.includes(p)).length;

                if (piecesEquipped >= 2) {
                    bonuses.activesets.push({ name: setData.name, pieces: piecesEquipped, total: setData.pieces.length });

                    // Apply bonuses for each threshold reached
                    for (const [threshold, bonus] of Object.entries(setData.bonuses)) {
                        if (piecesEquipped >= parseInt(threshold)) {
                            for (const [stat, value] of Object.entries(bonus.effect)) {
                                if (typeof value === 'boolean') {
                                    bonuses.effects[stat] = value;
                                } else {
                                    bonuses.effects[stat] = (bonuses.effects[stat] || 0) + value;
                                }
                            }
                        }
                    }
                }
            }

            return bonuses;
        }

        // v6.68: Enhanced enchantment tiers added to existing system via ENCHANTMENTS object
        // New enchantments: elemental_fury, executioner, protection, vitality, regeneration, thorns, haste, fortune, wisdom, silk_touch, unbreaking
        // These integrate with the existing v5.1 ENCHANTMENTS system above

        // v6.68: Generate random item rarity based on luck
        function rollItemRarity(baseLuck = 0) {
            const talentBonuses = getTalentBonuses();
            const luck = baseLuck + (talentBonuses.rareFind || 0) + (talentBonuses.legendaryChance || 0);

            // Calculate drop chances
            let roll = Math.random() * 100;

            // Luck shifts the roll toward rarer items
            roll -= luck * 50; // Each 1% luck shifts 0.5% toward rare

            if (roll < ITEM_RARITIES.mythic.dropWeight) return 'mythic';
            roll -= ITEM_RARITIES.mythic.dropWeight;
            if (roll < ITEM_RARITIES.legendary.dropWeight) return 'legendary';
            roll -= ITEM_RARITIES.legendary.dropWeight;
            if (roll < ITEM_RARITIES.epic.dropWeight) return 'epic';
            roll -= ITEM_RARITIES.epic.dropWeight;
            if (roll < ITEM_RARITIES.rare.dropWeight) return 'rare';
            roll -= ITEM_RARITIES.rare.dropWeight;
            if (roll < ITEM_RARITIES.uncommon.dropWeight) return 'uncommon';

            return 'common';
        }

        // v6.68: Create item with rarity
        function createRarityItem(baseName, forcedRarity = null) {
            const rarity = forcedRarity || rollItemRarity();
            const rarityData = ITEM_RARITIES[rarity];
            const baseItem = ITEMS[baseName] || {};

            const item = {
                name: baseName,
                rarity: rarity,
                rarityColor: rarityData.color,
                displayName: rarity === 'common' ? baseName : `${rarityData.name} ${baseName}`,
                statMultiplier: rarityData.statMult,
                ...baseItem
            };

            // Apply stat multiplier to numeric bonuses
            if (baseItem.combatBonus) item.combatBonus = Math.round(baseItem.combatBonus * rarityData.statMult);
            if (baseItem.defenseBonus) item.defenseBonus = Math.round(baseItem.defenseBonus * rarityData.statMult);
            if (baseItem.miningBonus) item.miningBonus = Math.round(baseItem.miningBonus * rarityData.statMult);
            if (baseItem.heal) item.heal = Math.round(baseItem.heal * rarityData.statMult);

            return item;
        }

        // ============================================
        // v6.68: LIVING ECONOMY SYSTEM
        // Dynamic marketplace with NPC traders, fluctuating prices,
        // supply/demand simulation, and market manipulation
        // ============================================

        const ECONOMY = {
            // Base prices for all tradeable items (in gold)
            basePrices: {
                // Raw resources (cheap, high volume)
                'Log': 5, 'Ore': 8, 'Slime': 3, 'Raw Fish': 4, 'Chitin': 12,
                'Frost Shard': 25, 'Magma Gem': 30, 'Void Fragment': 45,
                'Crystal': 35, 'Obsidian': 20, 'Elite Essence': 50,
                // Crafted consumables
                'Cooked Fish': 12, 'Health Potion': 25, 'Super Potion': 60,
                // Gear (expensive)
                'Pickaxe': 50, 'Sword': 80, 'Fishing Rod': 40,
                'Frost Blade': 200, 'Magma Sword': 280, 'Void Dagger': 400,
                'Crystal Pickaxe': 150, 'Iron Armor': 100, 'Steel Armor': 250,
                'Chitin Armor': 180, 'Guardian Armor': 800,
                'Legendary Blade': 2000, 'Berserker Badge': 600, 'Vampiric Fang': 750,
                // Rare materials
                'Boss Trophy': 150, 'Legendary Core': 500, 'Ancient Artifact': 200,
                'Mystic Orb': 120, 'Enchant Shard': 80, 'Arcane Dust': 15
            },
            // Current market state
            supply: {},          // How much of each item is in the market
            demand: {},          // How much NPCs want each item
            priceHistory: {},    // Track price changes over time
            lastUpdate: 0,
            updateInterval: 30000,  // Update prices every 30 seconds
            volatility: 0.15,       // Max price swing per update (15%)
            // Market events
            activeEvents: [],
            eventChance: 0.05,      // 5% chance per update for market event
            // Player's gold
            gold: 500,              // Starting gold
            totalEarned: 0,
            totalSpent: 0,
            // Trading stats
            tradeHistory: [],
            maxTradeHistory: 100
        };

        // NPC Merchants with unique personalities and specializations
        const MERCHANTS = {
            grimjaw: {
                name: 'Grimjaw the Scrapper',
                icon: '',
                specialty: 'resources',
                greeting: "Got junk? I'll take it off your hands... for the right price.",
                buyMultiplier: 0.7,   // Pays 70% of market price
                sellMultiplier: 1.1,  // Sells at 110% of market price
                preferred: ['Ore', 'Log', 'Chitin', 'Slime'],
                despised: ['Crystal', 'Mystic Orb'],  // Pays less for these
                mood: 'neutral',
                inventory: {},
                gold: 2000,
                restockTime: 60000
            },
            crystalia: {
                name: 'Crystalia Gemweaver',
                icon: '',
                specialty: 'gems',
                greeting: "Such beautiful specimens you bring me... Let us discuss terms.",
                buyMultiplier: 0.85,
                sellMultiplier: 1.2,
                preferred: ['Crystal', 'Frost Shard', 'Magma Gem', 'Void Fragment', 'Mystic Orb'],
                despised: ['Log', 'Slime'],
                mood: 'neutral',
                inventory: {},
                gold: 5000,
                restockTime: 90000
            },
            ironhide: {
                name: 'Ironhide the Armorer',
                icon: '',
                specialty: 'equipment',
                greeting: "Need protection? My wares have saved countless lives.",
                buyMultiplier: 0.6,   // Doesn't want to buy gear back
                sellMultiplier: 1.3,  // Premium prices for quality
                preferred: ['Iron Armor', 'Steel Armor', 'Chitin Armor', 'Guardian Armor'],
                despised: ['Raw Fish', 'Slime'],
                mood: 'neutral',
                inventory: {},
                gold: 8000,
                restockTime: 120000
            },
            shadowmere: {
                name: 'Shadowmere the Fence',
                icon: '',
                specialty: 'rare',
                greeting: "Psst... I deal in items others won't touch. No questions asked.",
                buyMultiplier: 0.9,   // Best buy prices for rare stuff
                sellMultiplier: 1.5,  // But sells at huge markup
                preferred: ['Boss Trophy', 'Legendary Core', 'Elite Essence', 'Ancient Artifact'],
                despised: ['Log', 'Ore'],
                mood: 'neutral',
                inventory: {},
                gold: 15000,
                restockTime: 180000
            },
            wanderbot: {
                name: 'Wanderbot 3000',
                icon: '',
                specialty: 'random',
                greeting: "BEEP BOOP. TRADING PROTOCOLS ENGAGED. PREPARE FOR COMMERCE.",
                buyMultiplier: 0.75,
                sellMultiplier: 1.0,  // Fair prices but random inventory
                preferred: [],  // No preferences - truly random
                despised: [],
                mood: 'neutral',
                inventory: {},
                gold: 3000,
                restockTime: 45000
            }
        };



        // ============================================
        // v6.83: NPC EPISODIC MEMORY SYSTEM
        // NPCs with TRUE episodic memory - remembering events
        // with emotional weight, temporal decay, and gossip
        // ============================================

        const NPC_MEMORY_SYSTEM = {
            // Individual NPC memories (initialized from MERCHANTS)
            npcMemories: {},
            
            // Gossip network - rumors floating between NPCs
            gossipPool: [],
            
            // Memory system config
            config: {
                maxMemoriesPerNPC: 30,
                memoryDecayRatePerDay: 0.03,
                emotionalDecayRatePerDay: 0.02,
                gossipPropagationInterval: 60000, // 1 minute real time
                consolidationThresholdDays: 7,
                maxUnconsolidated: 20
            },
            
            // Last update timestamps
            lastDecayUpdate: Date.now(),
            lastGossipUpdate: Date.now()
        };

        // NPC personality templates (affects how they remember)
        const NPC_PERSONALITIES = {
            grimjaw: {
                grudgeHolder: 0.8,    // Very grudge-holding
                forgiving: 0.2,       // Not forgiving
                gossiper: 0.4,        // Moderate gossiper
                suspicious: 0.6,      // Quite suspicious
                dramatic: 0.5         // Average dramatic
            },
            crystalia: {
                grudgeHolder: 0.5,    
                forgiving: 0.5,       
                gossiper: 0.7,        // Loves to gossip
                suspicious: 0.3,      
                dramatic: 0.8         // Very dramatic
            },
            ironhide: {
                grudgeHolder: 0.9,    // Holds grudges forever
                forgiving: 0.1,       
                gossiper: 0.2,        // Stoic, doesn't gossip
                suspicious: 0.4,      
                dramatic: 0.3         // Not dramatic
            },
            shadowmere: {
                grudgeHolder: 0.7,    
                forgiving: 0.3,       
                gossiper: 0.9,        // Information broker - gossips a lot
                suspicious: 0.9,      // Very suspicious
                dramatic: 0.6         
            },
            wanderbot: {
                grudgeHolder: 0.3,    // Robot doesn't hold grudges
                forgiving: 0.7,       // Fairly forgiving
                gossiper: 0.5,        
                suspicious: 0.2,      // Trusting
                dramatic: 0.4         
            }
        };

        // Initialize memory structures for all merchants
        function initializeNPCMemories() {
            for (const merchantId of Object.keys(MERCHANTS)) {
                if (!NPC_MEMORY_SYSTEM.npcMemories[merchantId]) {
                    NPC_MEMORY_SYSTEM.npcMemories[merchantId] = {
                        episodicMemories: [],
                        relationship: {
                            trust: 0.5,
                            respect: 0.5,
                            fear: 0.0,
                            familiarity: 0.0,
                            lastInteraction: null,
                            totalInteractions: 0
                        },
                        personality: NPC_PERSONALITIES[merchantId] || {
                            grudgeHolder: 0.5,
                            forgiving: 0.5,
                            gossiper: 0.5,
                            suspicious: 0.5,
                            dramatic: 0.5
                        }
                    };
                }
            }
            
            // Load from localStorage if available
            const saved = localStorage.getItem('leviathan_npc_memories');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Merge saved memories with initialized structures
                    for (const [npcId, npcData] of Object.entries(data.npcMemories || {})) {
                        if (NPC_MEMORY_SYSTEM.npcMemories[npcId]) {
                            NPC_MEMORY_SYSTEM.npcMemories[npcId].episodicMemories = npcData.episodicMemories || [];
                            NPC_MEMORY_SYSTEM.npcMemories[npcId].relationship = npcData.relationship || NPC_MEMORY_SYSTEM.npcMemories[npcId].relationship;
                        }
                    }
                    NPC_MEMORY_SYSTEM.gossipPool = data.gossipPool || [];
                    NPC_MEMORY_SYSTEM.lastDecayUpdate = data.lastDecayUpdate || Date.now();
                    NPC_MEMORY_SYSTEM.lastGossipUpdate = data.lastGossipUpdate || Date.now();
                } catch (e) {
                    console.warn('Failed to load NPC memories:', e);
                }
            }
        }

        // Initialize NPC memories immediately after MERCHANTS is defined
        try {
            initializeNPCMemories();
        } catch (e) {
            console.error('[NPC Memory] Failed to initialize:', e);
        }

        // Save NPC memories to localStorage
        function saveNPCMemories() {
            const data = {
                npcMemories: NPC_MEMORY_SYSTEM.npcMemories,
                gossipPool: NPC_MEMORY_SYSTEM.gossipPool,
                lastDecayUpdate: NPC_MEMORY_SYSTEM.lastDecayUpdate,
                lastGossipUpdate: NPC_MEMORY_SYSTEM.lastGossipUpdate
            };
            localStorage.setItem('leviathan_npc_memories', JSON.stringify(data));
        }

        // Load NPC memories from localStorage
        function loadNPCMemories() {
            try {
                const saved = localStorage.getItem('leviathan_npc_memories');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.npcMemories) {
                        // Merge saved memories with existing NPC data (preserving personality)
                        for (const [npcId, savedNpcData] of Object.entries(data.npcMemories)) {
                            if (NPC_MEMORY_SYSTEM.npcMemories[npcId]) {
                                NPC_MEMORY_SYSTEM.npcMemories[npcId].episodicMemories = savedNpcData.episodicMemories || [];
                                NPC_MEMORY_SYSTEM.npcMemories[npcId].relationship = savedNpcData.relationship || NPC_MEMORY_SYSTEM.npcMemories[npcId].relationship;
                            }
                        }
                    }
                    if (data.gossipPool) {
                        NPC_MEMORY_SYSTEM.gossipPool = data.gossipPool;
                    }
                    if (data.lastDecayUpdate) {
                        NPC_MEMORY_SYSTEM.lastDecayUpdate = data.lastDecayUpdate;
                    }
                    if (data.lastGossipUpdate) {
                        NPC_MEMORY_SYSTEM.lastGossipUpdate = data.lastGossipUpdate;
                    }
                    console.log('[NPC Memory] Loaded memories from save');
                }
            } catch (e) {
                console.error('[NPC Memory] Failed to load memories:', e);
            }
        }

        // Record a new memory for an NPC
        function recordNPCMemory(npcId, memoryData) {
            const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
            if (!npcData) return;
            
            const memory = {
                id: 'mem_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                type: memoryData.type,
                timestamp: Date.now(),
                gameTime: {
                    day: gameData.stats?.daysPlayed || 0,
                    phase: typeof DayNightCycle !== 'undefined' ? DayNightCycle.getCurrentPhase().name : 'day'
                },
                event: memoryData.event,
                emotion: {
                    primary: memoryData.emotion?.primary || 'neutral',
                    intensity: memoryData.emotion?.intensity || 0.5,
                    valence: memoryData.emotion?.valence || 0
                },
                fidelity: {
                    details: 1.0,
                    emotional: 1.0,
                    source: memoryData.source || 'direct'
                },
                recallCount: 0,
                lastRecall: null,
                consolidated: false
            };
            
            npcData.episodicMemories.push(memory);
            
            // Update relationship based on emotional valence
            updateNPCRelationship(npcId, memory.emotion);
            
            // Limit memories
            if (npcData.episodicMemories.length > NPC_MEMORY_SYSTEM.config.maxMemoriesPerNPC) {
                // Remove oldest low-intensity memories
                npcData.episodicMemories.sort((a, b) => {
                    const aScore = a.emotion.intensity + (a.consolidated ? 0.5 : 0);
                    const bScore = b.emotion.intensity + (b.consolidated ? 0.5 : 0);
                    return bScore - aScore;
                });
                npcData.episodicMemories = npcData.episodicMemories.slice(0, NPC_MEMORY_SYSTEM.config.maxMemoriesPerNPC);
            }
            
            saveNPCMemories();
            return memory;
        }

        // Calculate trade emotion based on item, quantity, and merchant preferences
        function calculateTradeEmotion(merchantId, item, quantity, price) {
            const merchant = MERCHANTS[merchantId];
            if (!merchant) return { primary: 'neutral', intensity: 0.3, valence: 0 };
            
            let emotion = { primary: 'satisfaction', intensity: 0.4, valence: 0.2 };
            
            // Preferred items make them happy
            if (merchant.preferred.includes(item)) {
                emotion = { primary: 'gratitude', intensity: 0.7, valence: 0.6 };
                if (quantity >= 10) emotion.intensity = 0.85;
            }
            // Despised items annoy them
            else if (merchant.despised.includes(item)) {
                emotion = { primary: 'annoyance', intensity: 0.5, valence: -0.3 };
            }
            // Big trades are memorable
            if (price > 1000) {
                emotion.intensity = Math.min(1.0, emotion.intensity + 0.2);
            }
            
            return emotion;
        }

        // Update NPC relationship based on emotional event
        function updateNPCRelationship(npcId, emotion) {
            const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
            if (!npcData) return;
            
            const rel = npcData.relationship;
            const intensity = emotion.intensity;
            const valence = emotion.valence;
            
            // Trust changes with positive/negative interactions
            rel.trust = Math.max(-1, Math.min(1, rel.trust + valence * intensity * 0.1));
            
            // Respect increases with positive interactions, decreases with disrespect
            if (emotion.primary === 'gratitude' || emotion.primary === 'respect') {
                rel.respect = Math.min(1, rel.respect + intensity * 0.05);
            } else if (emotion.primary === 'anger' || emotion.primary === 'betrayal') {
                rel.respect = Math.max(-1, rel.respect - intensity * 0.1);
            }
            
            // Fear from harm
            if (emotion.primary === 'fear' || emotion.primary === 'betrayal') {
                rel.fear = Math.min(1, rel.fear + intensity * 0.2);
            }
            
            // Familiarity always increases with interaction
            rel.familiarity = Math.min(1, rel.familiarity + 0.02);
            rel.lastInteraction = Date.now();
            rel.totalInteractions++;
        }

        // Memory decay - run periodically
        function updateNPCMemoryDecay() {
            const now = Date.now();
            const daysSinceLastUpdate = (now - NPC_MEMORY_SYSTEM.lastDecayUpdate) / (1000 * 60 * 60 * 24);
            
            if (daysSinceLastUpdate < 0.01) return; // At least ~15 minutes between decay updates
            
            for (const [npcId, npcData] of Object.entries(NPC_MEMORY_SYSTEM.npcMemories)) {
                const personality = npcData.personality;
                
                for (const memory of npcData.episodicMemories) {
                    // Detail decay: fast for neutral, slow for emotional
                    const detailDecayRate = NPC_MEMORY_SYSTEM.config.memoryDecayRatePerDay / (1 + memory.emotion.intensity * 2);
                    memory.fidelity.details = Math.max(0.2, memory.fidelity.details - detailDecayRate * daysSinceLastUpdate);
                    
                    // Emotional decay: modified by personality
                    const emotionalDecayRate = memory.emotion.valence > 0
                        ? NPC_MEMORY_SYSTEM.config.emotionalDecayRatePerDay * personality.forgiving
                        : NPC_MEMORY_SYSTEM.config.emotionalDecayRatePerDay * (1 - personality.grudgeHolder);
                    memory.emotion.intensity = Math.max(0.1, memory.emotion.intensity - emotionalDecayRate * daysSinceLastUpdate);
                    
                    // Rumor decay: faster than direct memories
                    if (memory.fidelity.source === 'rumor') {
                        memory.fidelity.details *= Math.pow(0.95, daysSinceLastUpdate);
                    }
                }
                
                // Consolidation: old but emotional memories become permanent
                consolidateNPCMemories(npcId);
            }
            
            NPC_MEMORY_SYSTEM.lastDecayUpdate = now;
            saveNPCMemories();
        }

        // Consolidate memories (keep important ones, compress details of old ones)
        function consolidateNPCMemories(npcId) {
            const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
            if (!npcData) return;
            
            const unconsolidated = npcData.episodicMemories.filter(m => !m.consolidated);
            
            if (unconsolidated.length > NPC_MEMORY_SYSTEM.config.maxUnconsolidated) {
                // Keep most emotional, consolidate the rest
                unconsolidated.sort((a, b) => b.emotion.intensity - a.emotion.intensity);
                for (let i = NPC_MEMORY_SYSTEM.config.maxUnconsolidated; i < unconsolidated.length; i++) {
                    unconsolidated[i].consolidated = true;
                    unconsolidated[i].fidelity.details = 0.3; // Vague details
                }
            }
        }

        // Recall a memory (with potential misremembering)
        function recallNPCMemory(npcId, context) {
            context = context || 'greeting';
            const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
            if (!npcData || npcData.episodicMemories.length === 0) return null;
            
            const personality = npcData.personality;
            
            // Filter relevant memories for context
            let relevantMemories = npcData.episodicMemories.filter(function(m) {
                if (context === 'trading') return m.type === 'TRADE';
                if (context === 'greeting') return m.emotion.intensity > 0.3;
                return true;
            });
            
            if (relevantMemories.length === 0) return null;
            
            // Probability weighted by emotion intensity and recency
            const weights = relevantMemories.map(function(m) {
                const recency = 1 / (1 + (Date.now() - m.timestamp) / (1000 * 60 * 60 * 24 * 7));
                return m.emotion.intensity * recency;
            });
            
            const totalWeight = weights.reduce(function(a, b) { return a + b; }, 0);
            let random = Math.random() * totalWeight;
            let selectedMemory = null;
            
            for (let i = 0; i < relevantMemories.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    selectedMemory = relevantMemories[i];
                    break;
                }
            }
            
            if (!selectedMemory) return null;
            
            // MISREMEMBERING: Distort based on fidelity and personality
            const distortedMemory = distortNPCMemory(selectedMemory, personality);
            
            // Update recall metadata
            selectedMemory.recallCount++;
            selectedMemory.lastRecall = Date.now();
            
            // Reconsolidation: recalled memories strengthen
            selectedMemory.emotion.intensity = Math.min(1.0, selectedMemory.emotion.intensity * 1.05);
            
            return distortedMemory;
        }

        // Distort a memory based on fidelity
        function distortNPCMemory(memory, personality) {
            const distorted = JSON.parse(JSON.stringify(memory)); // Deep copy
            const fidelity = memory.fidelity.details;
            const dramatic = personality.dramatic;
            
            // Quantity distortion: remembered bigger/smaller
            if (distorted.event.quantity) {
                const distortionFactor = 1 + (Math.random() - 0.5) * (1 - fidelity) * dramatic * 2;
                distorted.event.quantity = Math.max(1, Math.round(distorted.event.quantity * distortionFactor));
            }
            
            // Value distortion
            if (distorted.event.value || distorted.event.price) {
                const key = distorted.event.value ? 'value' : 'price';
                const distortionFactor = 1 + (Math.random() - 0.5) * (1 - fidelity) * dramatic * 2;
                distorted.event[key] = Math.max(1, Math.round(distorted.event[key] * distortionFactor));
            }
            
            // Emotional amplification: dramatic personalities exaggerate
            distorted.emotion.intensity = Math.min(1.0, distorted.emotion.intensity * (1 + dramatic * 0.3));
            
            // Valence shift: suspicious personalities remember things as worse
            if (personality.suspicious > 0.5) {
                distorted.emotion.valence = Math.max(-1, distorted.emotion.valence - 0.1 * (1 - fidelity));
            }
            
            distorted._isDistorted = true;
            distorted._originalFidelity = fidelity;
            
            return distorted;
        }

        // Create gossip from an interesting event
        function createNPCGossip(npcId, content) {
            // Only create gossip for interesting events
            const GOSSIP_WORTHY = ['BIG_TRADE', 'BOSS_KILL', 'PLAYER_DEATH', 'RARE_ITEM', 'HARM'];
            if (GOSSIP_WORTHY.indexOf(content.type) === -1) return;
            
            const npc = NPC_MEMORY_SYSTEM.npcMemories[npcId];
            if (!npc || Math.random() > npc.personality.gossiper) return;
            
            NPC_MEMORY_SYSTEM.gossipPool.push({
                id: 'gossip_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                origin: npcId,
                about: 'player',
                content: content,
                spread: [npcId],
                distortion: 0,
                timestamp: Date.now(),
                potency: 0.7
            });
            
            saveNPCMemories();
        }

        // Propagate gossip between NPCs
        function propagateNPCGossip() {
            const now = Date.now();
            if (now - NPC_MEMORY_SYSTEM.lastGossipUpdate < NPC_MEMORY_SYSTEM.config.gossipPropagationInterval) return;
            
            for (let g = 0; g < NPC_MEMORY_SYSTEM.gossipPool.length; g++) {
                const gossip = NPC_MEMORY_SYSTEM.gossipPool[g];
                const spreadCopy = gossip.spread.slice();
                
                // Each NPC who knows it might spread it
                for (let k = 0; k < spreadCopy.length; k++) {
                    const knowerNpcId = spreadCopy[k];
                    const knower = NPC_MEMORY_SYSTEM.npcMemories[knowerNpcId];
                    if (!knower) continue;
                    
                    // Check if they will gossip
                    if (Math.random() > knower.personality.gossiper * gossip.potency) continue;
                    
                    // Find a nearby NPC who does not know yet
                    const recipients = Object.keys(NPC_MEMORY_SYSTEM.npcMemories)
                        .filter(function(id) { return id !== knowerNpcId && gossip.spread.indexOf(id) === -1; });
                    
                    if (recipients.length === 0) continue;
                    
                    const recipientId = recipients[Math.floor(Math.random() * recipients.length)];
                    
                    // Spread with distortion
                    gossip.spread.push(recipientId);
                    gossip.distortion += 0.1 * knower.personality.dramatic;
                    
                    // Recipient gets a memory (marked as rumor)
                    const distortedContent = distortGossipContent(gossip.content, gossip.distortion);
                    recordNPCMemory(recipientId, {
                        type: 'RUMOR',
                        event: distortedContent,
                        emotion: {
                            primary: gossip.content.type === 'BIG_TRADE' ? 'curiosity' :
                                     gossip.content.type === 'HARM' ? 'suspicion' : 'interest',
                            intensity: 0.3 * (1 - gossip.distortion),
                            valence: 0
                        },
                        source: 'rumor'
                    });
                }
                
                // Gossip loses potency over time
                gossip.potency *= 0.95;
            }
            
            // Remove dead gossip
            NPC_MEMORY_SYSTEM.gossipPool = NPC_MEMORY_SYSTEM.gossipPool.filter(function(g) { return g.potency > 0.1; });
            NPC_MEMORY_SYSTEM.lastGossipUpdate = now;
            saveNPCMemories();
        }

        // Distort gossip content as it spreads
        function distortGossipContent(content, distortion) {
            const distorted = JSON.parse(JSON.stringify(content));
            
            if (distorted.value) {
                // Values get exaggerated
                distorted.value = Math.round(distorted.value * (1 + distortion * 2));
            }
            if (distorted.quantity) {
                distorted.quantity = Math.round(distorted.quantity * (1 + distortion * 1.5));
            }
            
            distorted._distortion = distortion;
            return distorted;
        }

        // Function aliases for cleaner API usage
        const recordMemory = recordNPCMemory;
        const recallMemory = recallNPCMemory;
        const updateMemoryDecay = updateNPCMemoryDecay;
        const propagateGossip = propagateNPCGossip;
        const createGossip = createNPCGossip;

        // Update relationship with simple attribute change
        function updateRelationship(npcId, attribute, delta) {
            const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
            if (!npcData) return;
            if (typeof npcData.relationship[attribute] === 'number') {
                npcData.relationship[attribute] = Math.max(-1, Math.min(1, npcData.relationship[attribute] + delta));
            }
        }

        // ============================================
        // MEMORY DIALOGUE GENERATION SYSTEM
        // ============================================

        const MEMORY_DIALOGUE = {
            // Greeting based on relationship and recent memories
            generateGreeting(npcId) {
                const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
                if (!npcData) return MERCHANTS[npcId]?.greeting || "Welcome, traveler.";

                const merchant = MERCHANTS[npcId];
                const rel = npcData.relationship;

                // Check for dominant recent memory
                const recentMemory = recallMemory(npcId, 'greeting');

                // Build greeting layers
                let greeting = '';

                // Familiarity layer
                if (rel.familiarity < 0.2) {
                    greeting = merchant?.greeting || "Welcome, stranger.";
                } else if (rel.familiarity > 0.7) {
                    greeting = "Ah, you again! ";
                } else {
                    greeting = "Welcome back. ";
                }

                // Memory layer
                if (recentMemory) {
                    greeting += this.generateMemoryReference(recentMemory, npcData.personality);
                }

                // Trust layer
                if (rel.trust < -0.3) {
                    greeting += " I've got my eye on you.";
                } else if (rel.trust > 0.5) {
                    greeting += " You're always welcome here.";
                }

                return greeting;
            },

            generateMemoryReference(memory, personality) {
                const fidelity = memory.fidelity.details;
                const eventItem = memory.event.item || 'goods';
                const eventQuantity = memory.event.quantity || 'some';
                const eventEnemy = memory.event.enemy || 'creature';
                const eventDays = memory.event.days || 'some';

                const templates = {
                    TRADE: {
                        positive: [
                            fidelity > 0.7 ? 'Remember when you sold me ' + eventQuantity + ' ' + eventItem + '? Good times.' :
                            fidelity > 0.4 ? 'Didn\'t you sell me some... ' + eventItem + ', was it?' :
                            "We've done good business before, haven't we?"
                        ],
                        negative: [
                            fidelity > 0.7 ? 'Still waiting for a fair deal after that ' + eventItem + ' debacle.' :
                            "Hmph. Your trades haven't always been to my liking."
                        ]
                    },
                    HELP: {
                        positive: [
                            fidelity > 0.5 ? "I haven't forgotten what you did for me." :
                            "I remember... you helped me once. Or was it someone else?"
                        ],
                        negative: []
                    },
                    HARM: {
                        positive: [],
                        negative: [
                            fidelity > 0.7 ? "You think I've forgotten? I NEVER forget." :
                            "Something about you... sets my teeth on edge."
                        ]
                    },
                    WITNESS: {
                        positive: [
                            'I saw you take down that ' + eventEnemy + '. Impressive.'
                        ],
                        negative: [
                            'I heard about your... encounter with that ' + eventEnemy + '.'
                        ]
                    },
                    RUMOR: {
                        positive: [
                            "Word travels, you know. They say you're making waves."
                        ],
                        negative: [
                            "I've heard... things. About you."
                        ]
                    },
                    ABSENCE: {
                        positive: [
                            eventDays > 14 ? eventDays + ' days! I thought you\'d vanished into the void.' :
                            'Been a while. ' + eventDays + ' days, give or take.'
                        ],
                        negative: []
                    }
                };

                const valence = memory.emotion.valence > 0 ? 'positive' : 'negative';
                const options = templates[memory.type]?.[valence] || [];

                if (options.length === 0) return '';
                return options[Math.floor(Math.random() * options.length)];
            },

            // Unprompted memory surfacing (random chance during interaction)
            triggerUnpromptedMemory(npcId) {
                if (Math.random() > 0.15) return null; // 15% chance

                const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
                if (!npcData) return null;

                // Find old negative memories (grudges)
                const grudge = npcData.episodicMemories.find(m =>
                    m.emotion.valence < -0.3 &&
                    m.emotion.intensity > 0.4 &&
                    (Date.now() - m.timestamp) > 7 * 24 * 60 * 60 * 1000 // At least a week old
                );

                if (grudge) {
                    const grudgeType = grudge.type === 'HARM' ? 'what you did' : 'that time';
                    const clarity = grudge.fidelity.details < 0.5 ? "The details are fuzzy, but the feeling isn't." : "I remember it clearly.";
                    return {
                        type: 'grudge',
                        text: 'You know... I still think about ' + grudgeType + '. ' + clarity
                    };
                }

                // Find positive memories for warmth
                const warmMemory = npcData.episodicMemories.find(m =>
                    m.emotion.valence > 0.5 &&
                    m.emotion.intensity > 0.5
                );

                if (warmMemory && Math.random() > 0.7) {
                    return {
                        type: 'warmth',
                        text: "You know, it's good to see a familiar face around here."
                    };
                }

                return null;
            },

            // Generate trade-specific dialogue based on memory
            generateTradeComment(npcId, item, isBuying) {
                const npcData = NPC_MEMORY_SYSTEM.npcMemories[npcId];
                if (!npcData) return null;

                // Find previous trades of this item
                const previousTrades = npcData.episodicMemories.filter(m =>
                    m.type === 'TRADE' && m.event.item === item
                );

                if (previousTrades.length === 0) return null;

                const totalQuantity = previousTrades.reduce((sum, m) => sum + (m.event.quantity || 0), 0);

                if (totalQuantity > 100) {
                    return 'Ah, ' + item + '. You\'ve brought me quite a lot of this over time.';
                } else if (previousTrades.length > 3) {
                    return item + ' again? You seem to have a steady supply.';
                }

                return null;
            }
        };

        // ============================================
        // Market events that shake up the economy
        const MARKET_EVENTS = {
            ore_rush: {
                name: ' Ore Rush!',
                description: 'A new vein discovered! Ore prices crash as supply floods in.',
                duration: 120000,
                effects: { 'Ore': -0.5, 'Crystal': -0.3, 'Obsidian': -0.4 },
                announcement: ' MARKET ALERT: Massive ore deposits discovered! Prices plummeting!'
            },
            monster_surge: {
                name: ' Monster Surge!',
                description: 'Monster materials in high demand for defense contracts.',
                duration: 90000,
                effects: { 'Chitin': 0.8, 'Slime': 0.5, 'Elite Essence': 1.0, 'Boss Trophy': 0.6 },
                announcement: ' MARKET ALERT: Military contracts driving monster material prices UP!'
            },
            crystal_shortage: {
                name: ' Crystal Shortage!',
                description: 'Crystal mines collapsed! Prices skyrocket.',
                duration: 150000,
                effects: { 'Crystal': 1.5, 'Frost Shard': 0.8, 'Mystic Orb': 1.0 },
                announcement: ' MARKET ALERT: Crystal shortage! Gem prices through the roof!'
            },
            merchant_war: {
                name: ' Merchant War!',
                description: 'Merchants undercutting each other! Everything cheap!',
                duration: 60000,
                effects: { 'ALL': -0.3 },  // 30% off everything
                announcement: ' MARKET ALERT: Price war between merchants! BUY NOW!'
            },
            luxury_boom: {
                name: ' Luxury Boom!',
                description: 'Nobles buying up all the fancy gear.',
                duration: 100000,
                effects: {
                    'Legendary Blade': 0.7, 'Guardian Armor': 0.6,
                    'Void Dagger': 0.5, 'Berserker Badge': 0.4
                },
                announcement: ' MARKET ALERT: Noble spending spree! Premium items in demand!'
            },
            potion_plague: {
                name: ' Plague Outbreak!',
                description: 'Sickness spreading! Healing items worth their weight in gold.',
                duration: 80000,
                effects: { 'Health Potion': 2.0, 'Super Potion': 1.8, 'Cooked Fish': 0.5, 'Slime': 0.6 },
                announcement: ' MARKET ALERT: Plague spreading! Healing supplies critical!'
            },
            tech_revolution: {
                name: ' Tech Revolution!',
                description: 'New inventions drive demand for crafting materials.',
                duration: 110000,
                effects: { 'Ore': 0.4, 'Crystal': 0.3, 'Enchant Shard': 0.8, 'Arcane Dust': 0.5 },
                announcement: ' MARKET ALERT: Inventors hoarding materials! Crafting supplies up!'
            },
            black_market_bust: {
                name: ' Black Market Bust!',
                description: 'Authorities cracked down! Rare items now scarce.',
                duration: 130000,
                effects: { 'Boss Trophy': 1.2, 'Legendary Core': 1.5, 'Elite Essence': 0.8 },
                announcement: ' MARKET ALERT: Underground market raided! Rare goods prices surge!'
            }
        };

        // Initialize economy state
        function initEconomy() {
            // Initialize supply/demand for all items
            for (const [item, basePrice] of Object.entries(ECONOMY.basePrices)) {
                ECONOMY.supply[item] = 50 + Math.random() * 50;  // 50-100 initial supply
                ECONOMY.demand[item] = 50 + Math.random() * 50;  // 50-100 initial demand
                ECONOMY.priceHistory[item] = [basePrice];        // Start with base price
            }

            // Initialize merchant inventories
            for (const [id, merchant] of Object.entries(MERCHANTS)) {
                restockMerchant(id);
            }

            // Load saved economy data
            const saved = localStorage.getItem('levi_economy');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.gold !== undefined) ECONOMY.gold = data.gold;
                    if (data.supply) ECONOMY.supply = { ...ECONOMY.supply, ...data.supply };
                    if (data.demand) ECONOMY.demand = { ...ECONOMY.demand, ...data.demand };
                    if (data.priceHistory) ECONOMY.priceHistory = data.priceHistory;
                    if (data.totalEarned) ECONOMY.totalEarned = data.totalEarned;
                    if (data.totalSpent) ECONOMY.totalSpent = data.totalSpent;
                } catch (e) {
                    console.log('Could not load economy data');
                }
            }
        }

        // Save economy state
        function saveEconomy() {
            const data = {
                gold: ECONOMY.gold,
                supply: ECONOMY.supply,
                demand: ECONOMY.demand,
                priceHistory: ECONOMY.priceHistory,
                totalEarned: ECONOMY.totalEarned,
                totalSpent: ECONOMY.totalSpent
            };
            localStorage.setItem('levi_economy', JSON.stringify(data));
        }

        // Get current market price for an item
        function getMarketPrice(itemName) {
            const basePrice = ECONOMY.basePrices[itemName];
            if (!basePrice) return 0;

            const supply = ECONOMY.supply[itemName] || 50;
            const demand = ECONOMY.demand[itemName] || 50;

            // Price = base * (demand / supply) with bounds
            let supplyDemandRatio = demand / Math.max(supply, 1);
            supplyDemandRatio = Math.max(0.2, Math.min(5.0, supplyDemandRatio));  // 0.2x to 5x

            let price = basePrice * supplyDemandRatio;

            // Apply active market events
            for (const event of ECONOMY.activeEvents) {
                const eventData = MARKET_EVENTS[event.type];
                if (eventData.effects['ALL']) {
                    price *= (1 + eventData.effects['ALL']);
                }
                if (eventData.effects[itemName]) {
                    price *= (1 + eventData.effects[itemName]);
                }
            }

            return Math.max(1, Math.round(price));
        }

        // Get price trend (up, down, stable)
        function getPriceTrend(itemName) {
            const history = ECONOMY.priceHistory[itemName];
            if (!history || history.length < 2) return 'stable';

            const current = history[history.length - 1];
            const previous = history[history.length - 2];
            const change = (current - previous) / previous;

            if (change > 0.05) return 'up';
            if (change < -0.05) return 'down';
            return 'stable';
        }

        // Get merchant's adjusted price for buying from player
        function getMerchantBuyPrice(merchantId, itemName) {
            const merchant = MERCHANTS[merchantId];
            if (!merchant) return 0;

            let price = getMarketPrice(itemName);

            // Apply merchant's buy multiplier
            price *= merchant.buyMultiplier;

            // Bonus for preferred items
            if (merchant.preferred.includes(itemName)) {
                price *= 1.2;
            }

            // Penalty for despised items
            if (merchant.despised.includes(itemName)) {
                price *= 0.5;
            }

            // Mood affects prices
            if (merchant.mood === 'happy') price *= 1.1;
            if (merchant.mood === 'angry') price *= 0.8;

            return Math.max(1, Math.round(price));
        }

        // Get merchant's adjusted price for selling to player
        function getMerchantSellPrice(merchantId, itemName) {
            const merchant = MERCHANTS[merchantId];
            if (!merchant) return Infinity;

            let price = getMarketPrice(itemName);

            // Apply merchant's sell multiplier
            price *= merchant.sellMultiplier;

            // Discount for preferred items (they have more stock)
            if (merchant.preferred.includes(itemName)) {
                price *= 0.9;
            }

            // Mood affects prices
            if (merchant.mood === 'happy') price *= 0.95;
            if (merchant.mood === 'angry') price *= 1.15;

            return Math.max(1, Math.round(price));
        }

        // Sell item to merchant
        function sellToMerchant(merchantId, itemName, quantity = 1) {
            const merchant = MERCHANTS[merchantId];
            if (!merchant) return false;

            // Check player has item
            if (!hasItem(itemName, quantity)) {
                showNotification(`You don't have ${quantity}x ${itemName}!`, 'error');
                return false;
            }

            // Check merchant has gold
            const pricePerUnit = getMerchantBuyPrice(merchantId, itemName);
            const totalPrice = pricePerUnit * quantity;

            if (merchant.gold < totalPrice) {
                showNotification(`${merchant.name} can't afford that!`, 'error');
                return false;
            }

            // Execute trade
            removeFromInventory(itemName, quantity);
            ECONOMY.gold += totalPrice;
            ECONOMY.totalEarned += totalPrice;
            merchant.gold -= totalPrice;

            // Add to merchant's inventory
            merchant.inventory[itemName] = (merchant.inventory[itemName] || 0) + quantity;

            // Increase supply (more on market)
            ECONOMY.supply[itemName] = (ECONOMY.supply[itemName] || 50) + quantity * 2;

            // Log trade
            logTrade('sell', merchantId, itemName, quantity, totalPrice);

            // v6.83: Record trade memory
            if (typeof recordMemory === 'function') {
                const emotion = (typeof calculateTradeEmotion === 'function')
                    ? calculateTradeEmotion(merchantId, itemName, quantity, totalPrice)
                    : { primary: 'gratitude', intensity: 0.4, valence: 0.3 };

                recordMemory(merchantId, {
                    type: 'TRADE',
                    event: {
                        action: 'bought_from_player',
                        item: itemName,
                        quantity: quantity,
                        value: totalPrice
                    },
                    emotion: emotion
                });

                // Big trades generate gossip
                if (totalPrice > 1000 && typeof createGossip === 'function') {
                    createGossip(merchantId, 'player', { type: 'BIG_SPENDER', item: itemName, value: totalPrice });
                }
            }

            // Update merchant mood
            if (merchant.preferred.includes(itemName)) {
                merchant.mood = 'happy';
                showNotification(`${merchant.name}: "Excellent! Just what I needed!"`, 'success');
            }

            AudioSystem.pickup();
            showNotification(`Sold ${quantity}x ${itemName} for ${totalPrice}g`, 'success');
            saveEconomy();
            updateMarketUI();

            return true;
        }

        // Buy item from merchant
        function buyFromMerchant(merchantId, itemName, quantity = 1) {
            const merchant = MERCHANTS[merchantId];
            if (!merchant) return false;

            // Check merchant has item
            const merchantStock = merchant.inventory[itemName] || 0;
            if (merchantStock < quantity) {
                showNotification(`${merchant.name} doesn't have ${quantity}x ${itemName}!`, 'error');
                return false;
            }

            // Check player has gold
            const pricePerUnit = getMerchantSellPrice(merchantId, itemName);
            const totalPrice = pricePerUnit * quantity;

            if (ECONOMY.gold < totalPrice) {
                showNotification(`You need ${totalPrice}g (have ${ECONOMY.gold}g)`, 'error');
                return false;
            }

            // Check inventory space
            if (gameData.inventory.length >= 20) {
                showNotification('Inventory full!', 'error');
                return false;
            }

            // Execute trade
            ECONOMY.gold -= totalPrice;
            ECONOMY.totalSpent += totalPrice;
            merchant.gold += totalPrice;
            merchant.inventory[itemName] -= quantity;

            // Add to player inventory
            addToInventory(itemName, quantity);

            // Decrease supply, increase demand
            ECONOMY.supply[itemName] = Math.max(1, (ECONOMY.supply[itemName] || 50) - quantity);
            ECONOMY.demand[itemName] = (ECONOMY.demand[itemName] || 50) + quantity;

            // Log trade
            logTrade('buy', merchantId, itemName, quantity, totalPrice);

            // v6.83: Record trade memory (selling to player)
            if (typeof recordMemory === 'function') {
                recordMemory(merchantId, {
                    type: 'TRADE',
                    event: {
                        action: 'sold_to_player',
                        item: itemName,
                        quantity: quantity,
                        value: totalPrice
                    },
                    emotion: {
                        primary: 'satisfaction',
                        intensity: 0.3 + Math.min(0.3, totalPrice / 5000),
                        valence: 0.2
                    }
                });
            }

            AudioSystem.pickup();
            showNotification(`Bought ${quantity}x ${itemName} for ${totalPrice}g`, 'success');
            saveEconomy();
            updateMarketUI();

            return true;
        }

        // Log a trade for history
        function logTrade(type, merchantId, itemName, quantity, totalPrice) {
            const trade = {
                type,
                merchant: merchantId,
                item: itemName,
                quantity,
                price: totalPrice,
                unitPrice: Math.round(totalPrice / quantity),
                timestamp: Date.now()
            };

            ECONOMY.tradeHistory.push(trade);
            if (ECONOMY.tradeHistory.length > ECONOMY.maxTradeHistory) {
                ECONOMY.tradeHistory.shift();
            }
        }

        // Restock merchant inventory
        function restockMerchant(merchantId) {
            const merchant = MERCHANTS[merchantId];
            if (!merchant) return;

            merchant.inventory = {};

            // Add specialty items
            const itemPool = Object.keys(ECONOMY.basePrices);

            // Preferred items get more stock
            for (const item of merchant.preferred) {
                merchant.inventory[item] = 3 + Math.floor(Math.random() * 8);
            }

            // Random items based on specialty
            const randomCount = 3 + Math.floor(Math.random() * 5);
            for (let i = 0; i < randomCount; i++) {
                const item = itemPool[Math.floor(Math.random() * itemPool.length)];
                if (!merchant.despised.includes(item)) {
                    merchant.inventory[item] = (merchant.inventory[item] || 0) + 1 + Math.floor(Math.random() * 3);
                }
            }

            // Reset gold
            merchant.gold = merchant === MERCHANTS.shadowmere ? 15000 :
                           merchant === MERCHANTS.ironhide ? 8000 :
                           merchant === MERCHANTS.crystalia ? 5000 : 3000;
        }

        // Update economy simulation (called periodically)
        function updateEconomy(time) {
            if (time - ECONOMY.lastUpdate < ECONOMY.updateInterval) return;
            ECONOMY.lastUpdate = time;

            // Natural supply/demand drift
            for (const item of Object.keys(ECONOMY.basePrices)) {
                // Random walk for supply and demand
                ECONOMY.supply[item] += (Math.random() - 0.5) * 10;
                ECONOMY.demand[item] += (Math.random() - 0.5) * 10;

                // Clamp values
                ECONOMY.supply[item] = Math.max(5, Math.min(200, ECONOMY.supply[item]));
                ECONOMY.demand[item] = Math.max(5, Math.min(200, ECONOMY.demand[item]));

                // Update price history
                const currentPrice = getMarketPrice(item);
                ECONOMY.priceHistory[item].push(currentPrice);
                if (ECONOMY.priceHistory[item].length > 20) {
                    ECONOMY.priceHistory[item].shift();
                }
            }

            // NPC-to-NPC trading simulation
            simulateNPCTrading();

            // Check for market events
            if (Math.random() < ECONOMY.eventChance) {
                triggerMarketEvent();
            }

            // Update active events
            ECONOMY.activeEvents = ECONOMY.activeEvents.filter(event => {
                if (time > event.endTime) {
                    showNotification(` ${event.name} has ended. Prices normalizing.`, 'info');
                    return false;
                }
                return true;
            });

            // Merchant mood decay
            for (const merchant of Object.values(MERCHANTS)) {
                if (Math.random() < 0.3) {
                    merchant.mood = 'neutral';
                }
            }

            saveEconomy();
        }

        // Simulate NPC merchants trading with each other
        function simulateNPCTrading() {
            const merchantIds = Object.keys(MERCHANTS);

            // Each merchant tries to buy items they prefer from others
            for (const buyerId of merchantIds) {
                const buyer = MERCHANTS[buyerId];

                for (const preferredItem of buyer.preferred) {
                    // Find a seller who has this item
                    for (const sellerId of merchantIds) {
                        if (sellerId === buyerId) continue;

                        const seller = MERCHANTS[sellerId];
                        const sellerStock = seller.inventory[preferredItem] || 0;

                        if (sellerStock > 2 && buyer.gold > getMarketPrice(preferredItem) * 2) {
                            // Execute NPC trade
                            const quantity = Math.min(2, sellerStock - 1);
                            const price = getMarketPrice(preferredItem) * quantity;

                            seller.inventory[preferredItem] -= quantity;
                            buyer.inventory[preferredItem] = (buyer.inventory[preferredItem] || 0) + quantity;
                            seller.gold += price;
                            buyer.gold -= price;

                            // This affects market prices!
                            ECONOMY.demand[preferredItem] += 1;
                        }
                    }
                }
            }
        }

        // Trigger a random market event
        function triggerMarketEvent() {
            const eventTypes = Object.keys(MARKET_EVENTS);
            const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
            const eventData = MARKET_EVENTS[eventType];

            // Check if event already active
            if (ECONOMY.activeEvents.some(e => e.type === eventType)) return;

            const event = {
                type: eventType,
                name: eventData.name,
                startTime: performance.now(),
                endTime: performance.now() + eventData.duration
            };

            ECONOMY.activeEvents.push(event);
            showNotification(eventData.announcement, 'warning');
            AudioSystem.discovery();
        }

        // Flood the market with an item (player manipulation)
        function floodMarket(itemName, quantity) {
            if (!hasItem(itemName, quantity)) {
                showNotification(`You don't have ${quantity}x ${itemName}!`, 'error');
                return false;
            }

            // Remove from inventory
            removeFromInventory(itemName, quantity);

            // Massively increase supply
            ECONOMY.supply[itemName] = (ECONOMY.supply[itemName] || 50) + quantity * 5;

            // Prices will crash!
            const newPrice = getMarketPrice(itemName);
            const basePrice = ECONOMY.basePrices[itemName];
            const crashPercent = Math.round((1 - newPrice / basePrice) * 100);

            showNotification(` MARKET FLOODED! ${itemName} prices crashed ${crashPercent}%!`, 'warning');
            AudioSystem.achievement();
            saveEconomy();
            updateMarketUI();

            return true;
        }

        // Create artificial scarcity
        function createScarcity(itemName) {
            // Buy up all stock from merchants
            let totalBought = 0;
            let totalSpent = 0;

            for (const [id, merchant] of Object.entries(MERCHANTS)) {
                const stock = merchant.inventory[itemName] || 0;
                if (stock > 0) {
                    const price = getMerchantSellPrice(id, itemName) * stock;
                    if (ECONOMY.gold >= price) {
                        ECONOMY.gold -= price;
                        totalSpent += price;
                        totalBought += stock;
                        merchant.inventory[itemName] = 0;
                        addToInventory(itemName, stock);
                    }
                }
            }

            if (totalBought > 0) {
                // Decrease supply dramatically
                ECONOMY.supply[itemName] = Math.max(1, (ECONOMY.supply[itemName] || 50) - totalBought * 3);
                ECONOMY.demand[itemName] += totalBought;

                const newPrice = getMarketPrice(itemName);
                const basePrice = ECONOMY.basePrices[itemName];
                const increasePercent = Math.round((newPrice / basePrice - 1) * 100);

                showNotification(` CORNERED MARKET! Bought ${totalBought}x ${itemName} for ${totalSpent}g. Prices up ${increasePercent}%!`, 'success');
                AudioSystem.achievement();
                saveEconomy();
                updateMarketUI();
            } else {
                showNotification('No stock available to buy!', 'error');
            }

            return totalBought > 0;
        }

        // Open market UI
        function openMarketUI() {
            console.log('[DEBUG] openMarketUI called');
            const modal = document.getElementById('market-modal');
            console.log('[DEBUG] modal element:', modal);
            if (modal) {
                modal.style.display = 'flex';
                updateMarketUI();
            } else {
                console.error('[DEBUG] market-modal not found!');
            }
        }

        // Close market UI
        function closeMarketUI() {
            const modal = document.getElementById('market-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Update market UI display
        function updateMarketUI() {
            const pricesDiv = document.getElementById('market-prices');
            const merchantsDiv = document.getElementById('market-merchants');
            const eventsDiv = document.getElementById('market-events');
            const goldDisplay = document.getElementById('market-gold');

            if (goldDisplay) {
                goldDisplay.textContent = ` ${ECONOMY.gold.toLocaleString()}g`;
            }

            // Price list with trends
            if (pricesDiv) {
                let html = '<div class="market-price-grid">';
                for (const [item, basePrice] of Object.entries(ECONOMY.basePrices)) {
                    const currentPrice = getMarketPrice(item);
                    const trend = getPriceTrend(item);
                    const trendIcon = trend === 'up' ? '' : trend === 'down' ? '' : '';
                    const trendColor = trend === 'up' ? '#4f4' : trend === 'down' ? '#f44' : '#888';
                    const itemDef = ITEMS[item] || {};
                    const percentChange = Math.round((currentPrice / basePrice - 1) * 100);
                    const changeStr = percentChange >= 0 ? `+${percentChange}%` : `${percentChange}%`;

                    html += `
                        <div class="market-price-item" style="border-left: 3px solid ${trendColor}">
                            <span class="item-icon">${itemDef.icon || ''}</span>
                            <span class="item-name">${item}</span>
                            <span class="item-price">${currentPrice}g</span>
                            <span class="item-trend" style="color: ${trendColor}">${trendIcon} ${changeStr}</span>
                        </div>
                    `;
                }
                html += '</div>';
                pricesDiv.innerHTML = html;
            }

            // Active events
            if (eventsDiv) {
                if (ECONOMY.activeEvents.length === 0) {
                    eventsDiv.innerHTML = '<div class="no-events">No active market events</div>';
                } else {
                    let html = '';
                    for (const event of ECONOMY.activeEvents) {
                        const eventData = MARKET_EVENTS[event.type];
                        const remaining = Math.max(0, Math.round((event.endTime - performance.now()) / 1000));
                        html += `
                            <div class="market-event">
                                <strong>${eventData.name}</strong>
                                <span>${eventData.description}</span>
                                <span class="event-timer"> ${remaining}s remaining</span>
                            </div>
                        `;
                    }
                    eventsDiv.innerHTML = html;
                }
            }
        }

        // Select merchant for trading
        let selectedMerchant = null;

        function selectMerchant(merchantId) {
            selectedMerchant = merchantId;

            // v6.83: Update relationship and check for memories
            if (typeof updateRelationship === 'function') {
                updateRelationship(merchantId, 'familiarity', 0.02);
            }

            // Check for unprompted memory surfacing
            if (typeof MEMORY_DIALOGUE !== 'undefined') {
                const unprompted = MEMORY_DIALOGUE.triggerUnpromptedMemory(merchantId);
                if (unprompted) {
                    const merchant = MERCHANTS[merchantId];
                    setTimeout(() => {
                        showNotification(merchant.icon + ' ' + unprompted.text, unprompted.type === 'grudge' ? 'warning' : 'info');
                    }, 1500);
                }
            }

            updateMerchantTradeUI();
        }

        function updateMerchantTradeUI() {
            const tradeDiv = document.getElementById('merchant-trade');
            if (!tradeDiv || !selectedMerchant) return;

            const merchant = MERCHANTS[selectedMerchant];
            if (!merchant) return;

            // v6.83: Use memory-based greeting if available
            const greeting = (typeof MEMORY_DIALOGUE !== 'undefined')
                ? MEMORY_DIALOGUE.generateGreeting(selectedMerchant)
                : merchant.greeting;

            // v6.83: Get relationship info for display
            const npcData = NPC_MEMORY_SYSTEM?.npcMemories?.[selectedMerchant];
            const rel = npcData?.relationship;
            const relationshipHTML = rel ? `
                <div class="merchant-relationship" style="font-size: 10px; color: #888; margin-top: 2px;">
                    ${rel.trust > 0.3 ? '' : rel.trust < -0.3 ? '' : ''}
                    Trust: ${Math.round(rel.trust * 100)}% |
                    Familiarity: ${Math.round(rel.familiarity * 100)}%
                </div>
            ` : '';

            let html = `
                <div class="merchant-header">
                    <span class="merchant-icon">${merchant.icon}</span>
                    <span class="merchant-name">${merchant.name}</span>
                    <span class="merchant-gold"> ${merchant.gold.toLocaleString()}g</span>
                </div>
                ${relationshipHTML}
                <p class="merchant-greeting">"${greeting}"</p>
                <div class="trade-sections">
                    <div class="trade-section">
                        <h4> Buy from ${merchant.name.split(' ')[0]}</h4>
                        <div class="trade-items">
            `;

            // Items merchant is selling
            for (const [item, qty] of Object.entries(merchant.inventory)) {
                if (qty <= 0) continue;
                const price = getMerchantSellPrice(selectedMerchant, item);
                const itemDef = ITEMS[item] || {};
                const canAfford = ECONOMY.gold >= price;

                html += `
                    <div class="trade-item ${canAfford ? '' : 'unaffordable'}">
                        <span>${itemDef.icon || ''} ${item} x${qty}</span>
                        <span class="trade-price">${price}g</span>
                        <button onclick="buyFromMerchant('${selectedMerchant}', '${item}', 1)" ${canAfford ? '' : 'disabled'}>Buy</button>
                    </div>
                `;
            }

            html += `
                        </div>
                    </div>
                    <div class="trade-section">
                        <h4> Sell to ${merchant.name.split(' ')[0]}</h4>
                        <div class="trade-items">
            `;

            // Player's items they can sell
            const playerItems = {};
            for (const item of gameData.inventory) {
                if (item && item.name && ECONOMY.basePrices[item.name]) {
                    playerItems[item.name] = (playerItems[item.name] || 0) + (item.amount || 1);
                }
            }

            for (const [item, qty] of Object.entries(playerItems)) {
                const price = getMerchantBuyPrice(selectedMerchant, item);
                const itemDef = ITEMS[item] || {};
                const canMerchantAfford = merchant.gold >= price;

                html += `
                    <div class="trade-item ${canMerchantAfford ? '' : 'merchant-broke'}">
                        <span>${itemDef.icon || ''} ${item} x${qty}</span>
                        <span class="trade-price">${price}g</span>
                        <button onclick="sellToMerchant('${selectedMerchant}', '${item}', 1)" ${canMerchantAfford ? '' : 'disabled'}>Sell</button>
                    </div>
                `;
            }

            html += `
                        </div>
                    </div>
                </div>
            `;

            tradeDiv.innerHTML = html;
        }

        // v6.68: Market tab switching
        function showMarketTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.market-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });

            // Deactivate all tab buttons
            document.querySelectorAll('#market-modal .codex-tab').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            const selectedTab = document.getElementById(`market-tab-${tabName}`);
            if (selectedTab) selectedTab.style.display = 'block';

            // Activate button
            const selectedBtn = document.querySelector(`#market-modal .codex-tab[data-tab="${tabName}"]`);
            if (selectedBtn) selectedBtn.classList.add('active');

            // Populate manipulation dropdowns
            if (tabName === 'manipulate') {
                populateManipulationDropdowns();
            }
        }

        // v6.68: Populate manipulation dropdowns with player items
        function populateManipulationDropdowns() {
            const floodSelect = document.getElementById('flood-item');
            const cornerSelect = document.getElementById('corner-item');

            if (floodSelect) {
                floodSelect.innerHTML = '<option value="">Select item to flood...</option>';
                // Add items player has
                const playerItems = {};
                for (const item of gameData.inventory) {
                    if (item && item.name && ECONOMY.basePrices[item.name]) {
                        playerItems[item.name] = (playerItems[item.name] || 0) + (item.amount || 1);
                    }
                }
                for (const [item, qty] of Object.entries(playerItems)) {
                    const itemDef = ITEMS[item] || {};
                    floodSelect.innerHTML += `<option value="${item}">${itemDef.icon || ''} ${item} (have ${qty})</option>`;
                }
            }

            if (cornerSelect) {
                cornerSelect.innerHTML = '<option value="">Select item to corner...</option>';
                // Add all tradeable items
                for (const item of Object.keys(ECONOMY.basePrices)) {
                    const itemDef = ITEMS[item] || {};
                    const price = getMarketPrice(item);
                    cornerSelect.innerHTML += `<option value="${item}">${itemDef.icon || ''} ${item} (${price}g each)</option>`;
                }
            }
        }

        // v6.68: Execute flood market from UI
        function executeFloodMarket() {
            const item = document.getElementById('flood-item').value;
            const qty = parseInt(document.getElementById('flood-qty').value) || 20;

            if (!item) {
                showNotification('Select an item to flood!', 'error');
                return;
            }

            floodMarket(item, qty);
        }

        // v6.68: Execute corner market from UI
        function executeCornerMarket() {
            const item = document.getElementById('corner-item').value;

            if (!item) {
                showNotification('Select an item to corner!', 'error');
                return;
            }

            createScarcity(item);
        }

        // v6.68: Add gold from various sources (mob kills, POI rewards, etc.)
        function addGold(amount, source = 'unknown') {
            ECONOMY.gold += amount;
            ECONOMY.totalEarned += amount;
            saveEconomy();

            if (worldState.player) {
                spawnFloater(worldState.player.position, `+${amount}g`, '#ffd700');
            }
        }

        // v5.2: Get talent points available
        function getTalentPoints() {
            const totalLevels = Object.values(gameData.skills).reduce((sum, s) => sum + s.level, 0);
            const pointsEarned = Math.floor(totalLevels / 5); // 1 point per 5 total skill levels
            const pointsSpent = getSpentTalentPoints();
            return { earned: pointsEarned, spent: pointsSpent, available: pointsEarned - pointsSpent };
        }

        function getSpentTalentPoints() {
            if (!gameData.talents) gameData.talents = {};
            let spent = 0;
            for (const treeId of Object.keys(TALENT_TREES)) {
                const treeTalents = gameData.talents[treeId] || {};
                for (const [talentId, rank] of Object.entries(treeTalents)) {
                    spent += rank;
                }
            }
            return spent;
        }

        function getTalentRank(treeId, talentId) {
            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            return gameData.talents[treeId][talentId] || 0;
        }

        function canUnlockTalent(treeId, talentId) {
            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            const currentRank = getTalentRank(treeId, talentId);

            // Check max rank
            if (currentRank >= talent.maxRank) return false;

            // Check points available
            if (getTalentPoints().available <= 0) return false;

            // Check prerequisite
            if (talent.requires) {
                const reqRank = getTalentRank(treeId, talent.requires);
                const reqTalent = tree.talents[talent.requires];
                if (reqRank < reqTalent.maxRank) return false;
            }

            return true;
        }

        function unlockTalent(treeId, talentId) {
            if (!canUnlockTalent(treeId, talentId)) {
                showNotification('Cannot unlock this talent!', 'error');
                return false;
            }

            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            gameData.talents[treeId][talentId] = (gameData.talents[treeId][talentId] || 0) + 1;

            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            showNotification(`Unlocked ${talent.name}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateTalentModal();
            return true;
        }

        function getTalentBonuses() {
            const bonuses = {
                damage: 0, maxHp: 0, critChance: 0, lifesteal: 0, abilityDamage: 0,
                defense: 0, dodgeChance: 0, hpRegen: 0, shieldDuration: 0, deathSave: false,
                lootBonus: 0, resourceYield: 0, rareFind: 0, xpBonus: 0, doubleBossLoot: false
            };

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    if (rank > 0) {
                        for (const [stat, value] of Object.entries(talent.effect)) {
                            if (typeof value === 'boolean') {
                                bonuses[stat] = value;
                            } else {
                                bonuses[stat] = (bonuses[stat] || 0) + (value * rank);
                            }
                        }
                    }
                }
            }

            return bonuses;
        }

        // ============================================
        // v5.13: SHIP DEFENSE SYSTEM
        // Visible ship on world map with defensive laser
        // ============================================
        const SHIP_STATE = {
            mesh: null,
            landingPad: null,
            hp: 100,
            maxHp: 100,
            position: new THREE.Vector3(0, 0, 0),
            laser: {
                active: false,
                target: null,
                beam: null,
                cooldown: 0,
                lastFire: 0,
                damage: 15,
                range: 35,
                fireRate: 800,  // ms between shots
                autoDefend: true
            },
            // v6.68: Healing system for player and friendly creeps
            healing: {
                enabled: true,
                range: 25,              // Healing range
                playerHealRate: 2,      // HP per second for player
                creepHealRate: 5,       // HP per second for creeps
                healInterval: 500,      // ms between heal ticks
                lastHealTime: 0,
                healBeam: null,
                totalHealed: 0          // Tracking stat
            },
            propellers: [],
            thrustLight: null,
            damaged: false,
            repairCost: 50,  // gold to repair
            // v5.15: Defense tracking system
            defenseLog: {
                // Statistics
                totalEngagements: 0,        // Times laser fired
                totalKills: 0,              // Enemies killed by ship
                totalDamageDealt: 0,        // Total damage output
                entitiesDeterred: 0,        // Enemies that fled after being hit
                timesAttacked: 0,           // Times ship was attacked
                totalDamageTaken: 0,        // Total damage received
                repairsPerformed: 0,        // Times repaired
                totalRepairCost: 0,         // Gold spent on repairs
                timesDestroyed: 0,          // Times ship was destroyed
                // Recent events log (rolling buffer of last 50)
                events: [],
                maxEvents: 50
            }
        };

        // v5.15: Log a defense event
        function logDefenseEvent(eventType, data = {}) {
            const log = SHIP_STATE.defenseLog;
            const timestamp = Date.now();
            const event = {
                type: eventType,
                timestamp: timestamp,
                time: new Date(timestamp).toLocaleTimeString(),
                ...data
            };

            // Add to events array (rolling buffer)
            log.events.push(event);
            if (log.events.length > log.maxEvents) {
                log.events.shift();
            }

            // Update statistics based on event type
            switch (eventType) {
                case 'laser_fired':
                    log.totalEngagements++;
                    log.totalDamageDealt += data.damage || 0;
                    break;
                case 'enemy_killed':
                    log.totalKills++;
                    break;
                case 'enemy_deterred':
                    log.entitiesDeterred++;
                    break;
                case 'ship_attacked':
                    log.timesAttacked++;
                    log.totalDamageTaken += data.damage || 0;
                    break;
                case 'ship_repaired':
                    log.repairsPerformed++;
                    log.totalRepairCost += data.cost || 0;
                    break;
                case 'ship_destroyed':
                    log.timesDestroyed++;
                    break;
            }

            // Update defense log UI if open
            updateDefenseLogUI();

            return event;
        }

        // Get formatted defense statistics
        function getDefenseStats() {
            const log = SHIP_STATE.defenseLog;
            return {
                engagements: log.totalEngagements,
                kills: log.totalKills,
                damageDealt: log.totalDamageDealt,
                deterred: log.entitiesDeterred,
                attacked: log.timesAttacked,
                damageTaken: log.totalDamageTaken,
                repairs: log.repairsPerformed,
                repairCost: log.totalRepairCost,
                destroyed: log.timesDestroyed,
                killRatio: log.totalEngagements > 0 ? (log.totalKills / log.totalEngagements * 100).toFixed(1) : 0,
                recentEvents: log.events.slice(-10).reverse()
            };
        }

        // v5.15: Toggle defense log panel visibility
        function toggleDefenseLog() {
            const panel = document.getElementById('defense-stats');
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    updateDefenseLogUI();
                }
            }
        }

        // v5.15: Update defense log UI with current stats and events
        function updateDefenseLogUI() {
            const stats = getDefenseStats();

            // Update stat displays
            const updateElement = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            };

            updateElement('stat-engagements', stats.engagements);
            updateElement('stat-kills', stats.kills);
            updateElement('stat-damage-dealt', stats.damageDealt);
            updateElement('stat-deterred', stats.deterred);
            updateElement('stat-attacked', stats.attacked);
            updateElement('stat-damage-taken', stats.damageTaken);
            updateElement('stat-kill-rate', stats.killRatio + '%');
            updateElement('stat-repairs', stats.repairs);

            // Update events log
            const eventsLog = document.getElementById('defense-events-log');
            if (!eventsLog) return;

            const events = SHIP_STATE.defenseLog.events;
            if (events.length === 0) {
                eventsLog.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No events yet</div>';
                return;
            }

            // Format events (newest first)
            const eventHTML = events.slice().reverse().map(event => {
                let icon = '';
                let color = '#888';
                let text = '';

                switch (event.type) {
                    case 'laser_fired':
                        icon = '';
                        color = '#ff8800';
                        text = `Fired at ${event.targetName || 'enemy'} (${event.damage} dmg)`;
                        break;
                    case 'enemy_killed':
                        icon = '';
                        color = '#ff4444';
                        text = `Killed ${event.enemyName || 'enemy'} (+${event.threat || 0} threat neutralized)`;
                        break;
                    case 'enemy_deterred':
                        icon = '';
                        color = '#88ff88';
                        text = `${event.enemyName || 'Enemy'} fled after sustaining damage`;
                        break;
                    case 'ship_attacked':
                        icon = '';
                        color = '#ff6666';
                        text = `Attacked by ${event.attackerName || 'enemy'} (${event.damage} dmg)`;
                        break;
                    case 'ship_repaired':
                        icon = '';
                        color = '#ffff88';
                        text = `Repaired hull (+${event.hpRestored} HP, -${event.cost}g)`;
                        break;
                    case 'ship_destroyed':
                        icon = '';
                        color = '#ff0000';
                        text = `SHIP DESTROYED by ${event.finalBlow || 'enemy'}!`;
                        break;
                }

                return `<div style="padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: ${color};">
                    <span style="opacity: 0.6;">${event.time}</span> ${icon} ${text}
                </div>`;
            }).join('');

            eventsLog.innerHTML = eventHTML;
        }

        // Create ship mesh for world map
        function createWorldShip(spawnPosition) {
            const shipGroup = new THREE.Group();

            // Main body - sleek fuselage
            const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3a,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            shipGroup.add(body);

            // Cockpit dome
            const cockpitGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x004444,
                emissiveIntensity: 0.5
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.8, 0.5);
            cockpit.scale.set(1, 0.5, 1.2);
            shipGroup.add(cockpit);

            // Wings
            const wingGeometry = new THREE.BoxGeometry(8, 0.2, 2);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a4a,
                metalness: 0.6,
                roughness: 0.4
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.set(0, 0.3, -0.5);
            wings.castShadow = true;
            shipGroup.add(wings);

            // Wing tips with lights
            const tipGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const tipMaterialL = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1
            });
            const tipMaterialR = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 1
            });
            const tipL = new THREE.Mesh(tipGeometry, tipMaterialL);
            const tipR = new THREE.Mesh(tipGeometry, tipMaterialR);
            tipL.position.set(-4, 0.3, -0.5);
            tipR.position.set(4, 0.3, -0.5);
            shipGroup.add(tipL, tipR);

            // Tail fin
            const tailGeometry = new THREE.BoxGeometry(0.3, 2, 1);
            const tail = new THREE.Mesh(tailGeometry, wingMaterial);
            tail.position.set(0, 1, -2);
            tail.castShadow = true;
            shipGroup.add(tail);

            // Engine pods
            const engineGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2, 8);
            const engineMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2a,
                metalness: 0.8,
                roughness: 0.2
            });
            [-2, 2].forEach(x => {
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.rotation.x = Math.PI / 2;
                engine.position.set(x, 0, -2);
                engine.castShadow = true;
                shipGroup.add(engine);

                // Engine glow
                const glowGeometry = new THREE.CircleGeometry(0.4, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.8
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.set(x, 0, -3);
                shipGroup.add(glow);
            });

            // Laser turret on top
            const turretBaseGeo = new THREE.CylinderGeometry(0.5, 0.6, 0.4, 8);
            const turretMaterial = new THREE.MeshStandardMaterial({
                color: 0x444455,
                metalness: 0.8
            });
            const turretBase = new THREE.Mesh(turretBaseGeo, turretMaterial);
            turretBase.position.set(0, 1.1, -0.5);
            shipGroup.add(turretBase);

            const turretBarrelGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
            const turretBarrel = new THREE.Mesh(turretBarrelGeo, turretMaterial);
            turretBarrel.rotation.z = Math.PI / 2;
            turretBarrel.position.set(0, 1.5, -0.5);
            shipGroup.add(turretBarrel);
            shipGroup.userData.turretBarrel = turretBarrel;

            // Laser beam (initially invisible)
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const laserBeam = new THREE.Mesh(laserGeometry, laserMaterial);
            laserBeam.visible = false;
            shipGroup.add(laserBeam);
            SHIP_STATE.laser.beam = laserBeam;

            // Landing gear
            const gearGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const gearMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            [[-1.5, -1, 1], [1.5, -1, 1], [0, -1, -2]].forEach(pos => {
                const gear = new THREE.Mesh(gearGeometry, gearMaterial);
                gear.position.set(...pos);
                gear.castShadow = true;
                shipGroup.add(gear);
            });

            // Position ship at spawn point (landing zone)
            shipGroup.position.copy(spawnPosition);
            shipGroup.position.y = spawnPosition.y + 2;  // Slightly above ground
            shipGroup.rotation.y = Math.random() * Math.PI * 2;

            SHIP_STATE.mesh = shipGroup;
            SHIP_STATE.position.copy(spawnPosition);

            return shipGroup;
        }

        // Create landing pad/zone marker
        function createLandingZone(position) {
            const padGroup = new THREE.Group();

            // Landing pad - circular platform
            const padGeometry = new THREE.CylinderGeometry(10, 10, 0.3, 32);
            const padMaterial = new THREE.MeshStandardMaterial({
                color: 0x333344,
                metalness: 0.5,
                roughness: 0.5
            });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Landing markings - concentric rings
            [8, 6, 4].forEach((r, i) => {
                const ringGeo = new THREE.RingGeometry(r - 0.2, r, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: i === 0 ? 0xffff00 : 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.2;
                padGroup.add(ring);
            });

            // Corner beacons
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const beaconGeo = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
                const beaconMat = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.6
                });
                const beacon = new THREE.Mesh(beaconGeo, beaconMat);
                beacon.position.set(Math.cos(angle) * 9, 1, Math.sin(angle) * 9);
                padGroup.add(beacon);

                // Beacon light
                const lightGeo = new THREE.SphereGeometry(0.35, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.set(Math.cos(angle) * 9, 2.2, Math.sin(angle) * 9);
                light.userData.isBeacon = true;
                light.userData.phase = i * Math.PI / 2;
                padGroup.add(light);
            }

            // HP shield dome (visible when damaged)
            const shieldGeo = new THREE.SphereGeometry(12, 32, 32);
            const shieldMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                wireframe: true
            });
            const shield = new THREE.Mesh(shieldGeo, shieldMat);
            shield.position.y = 5;
            padGroup.add(shield);
            padGroup.userData.shield = shield;

            padGroup.position.copy(position);

            SHIP_STATE.landingPad = padGroup;
            return padGroup;
        }

        // Update ship defense system
        function updateShipDefense(dt, time) {
            if (!SHIP_STATE.mesh || mode !== 'world') return;

            // Animate beacon lights
            if (SHIP_STATE.landingPad) {
                SHIP_STATE.landingPad.children.forEach(child => {
                    if (child.userData.isBeacon) {
                        const pulse = (Math.sin(time * 0.003 + child.userData.phase) + 1) / 2;
                        child.material.opacity = 0.5 + pulse * 0.5;
                    }
                });

                // Shield visibility based on recent damage
                const shield = SHIP_STATE.landingPad.userData.shield;
                if (shield) {
                    if (SHIP_STATE.damaged) {
                        shield.material.opacity = Math.min(0.3, shield.material.opacity + dt * 0.5);
                        shield.rotation.y += dt * 0.5;
                    } else {
                        shield.material.opacity = Math.max(0, shield.material.opacity - dt * 0.2);
                    }
                }
            }

            // Auto-defend: Find and shoot nearby mobs
            if (SHIP_STATE.laser.autoDefend && time - SHIP_STATE.laser.lastFire > SHIP_STATE.laser.fireRate) {
                let nearestMob = null;
                let nearestDist = SHIP_STATE.laser.range;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent || mob.userData.hp <= 0) return;
                    const dist = SHIP_STATE.mesh.position.distanceTo(mob.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    fireShipLaser(nearestMob, time);
                }
            }

            // Update laser beam visual
            updateLaserBeam(dt, time);

            // v6.68: Ship healing system - heal player and friendly creeps
            if (SHIP_STATE.healing.enabled && time - SHIP_STATE.healing.lastHealTime > SHIP_STATE.healing.healInterval) {
                SHIP_STATE.healing.lastHealTime = time;
                const healRange = SHIP_STATE.healing.range;
                let healedSomething = false;

                // Heal player if nearby and damaged
                if (worldState.player && gameData.player.hp < gameData.player.maxHp) {
                    const playerDist = SHIP_STATE.mesh.position.distanceTo(worldState.player.position);
                    if (playerDist < healRange) {
                        const healAmount = Math.ceil(SHIP_STATE.healing.playerHealRate * (SHIP_STATE.healing.healInterval / 1000));
                        const actualHeal = Math.min(healAmount, gameData.player.maxHp - gameData.player.hp);
                        gameData.player.hp += actualHeal;
                        SHIP_STATE.healing.totalHealed += actualHeal;
                        updateHealthUI();

                        // Visual feedback - green healing particles
                        if (actualHeal > 0) {
                            spawnFloater(worldState.player.position, `+${actualHeal}`, '#44ff88');
                            if (particles) particles.emit(worldState.player.position, 5, 0x44ff88, { spread: 1.5, lifetime: 400, size: 0.15 });
                            healedSomething = true;

                            // Draw heal beam to player
                            spawnHealBeam(SHIP_STATE.mesh.position, worldState.player.position);
                        }
                    }
                }

                // Heal friendly creeps (team A) if nearby and damaged
                if (creepWaveState.creeps) {
                    creepWaveState.creeps.forEach(creep => {
                        if (!creep || !creep.userData || creep.userData.team !== 'A') return;
                        if (creep.userData.hp >= creep.userData.maxHp) return;

                        const creepDist = SHIP_STATE.mesh.position.distanceTo(creep.position);
                        if (creepDist < healRange) {
                            const healAmount = Math.ceil(SHIP_STATE.healing.creepHealRate * (SHIP_STATE.healing.healInterval / 1000));
                            const actualHeal = Math.min(healAmount, creep.userData.maxHp - creep.userData.hp);
                            creep.userData.hp += actualHeal;
                            SHIP_STATE.healing.totalHealed += actualHeal;

                            // Update creep HP bar
                            if (creep.userData.hpBar) {
                                const hpPercent = creep.userData.hp / creep.userData.maxHp;
                                creep.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                                creep.userData.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
                            }

                            // Visual feedback for creep healing (less frequent to avoid spam)
                            if (actualHeal > 0 && Math.random() < 0.3) {
                                spawnFloater(creep.position, `+${actualHeal}`, '#44ff88');
                                if (particles) particles.emit(creep.position, 3, 0x44ff88, { spread: 1, lifetime: 300, size: 0.1 });
                                spawnHealBeam(SHIP_STATE.mesh.position, creep.position);
                            }
                            healedSomething = true;
                        }
                    });
                }

                // Healing aura pulse effect when actively healing
                if (healedSomething && SHIP_STATE.landingPad) {
                    const shield = SHIP_STATE.landingPad.userData.shield;
                    if (shield) {
                        shield.material.color.setHex(0x44ff88);  // Green healing color
                        shield.material.opacity = 0.4;
                        setTimeout(() => {
                            if (shield.material) {
                                shield.material.color.setHex(0x00ffff);  // Back to cyan
                            }
                        }, 200);
                    }
                }
            }

            // Mobs attacking ship
            worldState.mobs.forEach(mob => {
                if (!mob.parent || mob.userData.hp <= 0) return;

                const distToShip = mob.position.distanceTo(SHIP_STATE.mesh.position);

                // Mobs occasionally target ship if player is far away
                if (distToShip < 20 && !mob.userData.targetingPlayer) {
                    const distToPlayer = worldState.player ? mob.position.distanceTo(worldState.player.position) : Infinity;
                    if (distToPlayer > 30 && Math.random() < 0.01) {  // Small chance to attack ship
                        mob.userData.targetingShip = true;
                        mob.userData.targetPos.copy(SHIP_STATE.mesh.position);
                    }
                }

                // Damage ship when in melee range
                if (mob.userData.targetingShip && distToShip < 5) {
                    const now = performance.now();
                    if (!mob.userData.lastShipAttack || now - mob.userData.lastShipAttack > 2000) {
                        // v5.15: Pass mob as attacker for tracking
                        damageShip(mob.userData.damage || 5, mob);
                        mob.userData.lastShipAttack = now;
                    }
                }
            });

            // Gentle hover animation for ship
            if (SHIP_STATE.mesh) {
                SHIP_STATE.mesh.position.y = SHIP_STATE.position.y + 2 + Math.sin(time * 0.002) * 0.2;
                SHIP_STATE.mesh.rotation.z = Math.sin(time * 0.001) * 0.02;
            }
        }

        // Fire ship's defensive laser
        function fireShipLaser(target, time) {
            if (!SHIP_STATE.mesh || !target) return;

            const enemyName = target.userData.name || 'Unknown Entity';
            const enemyHpBefore = target.userData.hp;
            const damage = SHIP_STATE.laser.damage;
            const distance = SHIP_STATE.mesh.position.distanceTo(target.position);

            SHIP_STATE.laser.lastFire = time;
            SHIP_STATE.laser.target = target;
            SHIP_STATE.laser.active = true;

            // Rotate turret toward target
            const turret = SHIP_STATE.mesh.userData.turretBarrel;
            if (turret) {
                const dir = new THREE.Vector3().subVectors(target.position, SHIP_STATE.mesh.position).normalize();
                turret.lookAt(target.position);
            }

            // Deal damage
            target.userData.hp -= damage;

            // v5.15: Log the laser engagement
            logDefenseEvent('laser_fired', {
                enemy: enemyName,
                damage: damage,
                distance: Math.round(distance),
                enemyHpBefore: enemyHpBefore,
                enemyHpAfter: target.userData.hp,
                wasTargetingShip: target.userData.targetingShip || false
            });

            // Visual feedback
            if (particles) {
                particles.emit(target.position, 10, 0xff0000, { spread: 2, lifetime: 300 });
            }

            spawnFloater(target.position, `-${damage}`, '#ff4444');

            // Sound effect placeholder
            AudioSystem.play('spell');

            // Check if killed
            if (target.userData.hp <= 0) {
                const xpReward = target.userData.xpReward || 50;
                addXp('combat', Math.floor(xpReward * 0.5));  // Half XP for ship kills
                spawnFloater(target.position, `SHIP KILL! +${Math.floor(xpReward * 0.5)}XP`, '#ff8800');

                // v5.15: Log the kill
                logDefenseEvent('enemy_killed', {
                    enemy: enemyName,
                    totalDamageDealt: enemyHpBefore,
                    xpAwarded: Math.floor(xpReward * 0.5),
                    wasTargetingShip: target.userData.targetingShip || false,
                    outcome: 'destroyed'
                });
            } else if (target.userData.targetingShip && target.userData.hp < enemyHpBefore * 0.5) {
                // v5.15: Check if enemy might flee (deterred) - below 50% HP after being hit
                // Enemies have a chance to be deterred when significantly damaged
                if (Math.random() < 0.3) {
                    target.userData.targetingShip = false;
                    target.userData.deterredByShip = true;
                    logDefenseEvent('enemy_deterred', {
                        enemy: enemyName,
                        hpRemaining: target.userData.hp,
                        reason: 'significant_damage',
                        outcome: 'fled'
                    });
                    spawnFloater(target.position, 'DETERRED!', '#ffaa00');
                }
            }
        }

        // Update laser beam visual effect
        function updateLaserBeam(dt, time) {
            const beam = SHIP_STATE.laser.beam;
            if (!beam) return;

            if (SHIP_STATE.laser.active && SHIP_STATE.laser.target) {
                beam.visible = true;

                const start = SHIP_STATE.mesh.position.clone();
                start.y += 1.5;
                const end = SHIP_STATE.laser.target.position.clone();
                end.y += 1;

                const dir = new THREE.Vector3().subVectors(end, start);
                const length = dir.length();

                beam.scale.set(1, length, 1);
                beam.position.copy(start).add(dir.multiplyScalar(0.5));
                beam.lookAt(end);
                beam.rotateX(Math.PI / 2);

                // Flash effect
                beam.material.opacity = 0.9;

                // Deactivate after short duration
                setTimeout(() => {
                    SHIP_STATE.laser.active = false;
                    beam.visible = false;
                }, 100);
            } else {
                beam.visible = false;
            }
        }

        // v6.68: Spawn a temporary heal beam visual effect
        function spawnHealBeam(startPos, endPos) {
            if (!scene) return;

            const start = startPos.clone();
            start.y += 3;  // From ship turret
            const end = endPos.clone();
            end.y += 1;

            const dir = new THREE.Vector3().subVectors(end, start);
            const length = dir.length();

            // Create heal beam geometry
            const beamGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 6);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x44ff88,
                transparent: true,
                opacity: 0.7
            });
            const healBeam = new THREE.Mesh(beamGeo, beamMat);

            // Position and orient beam
            healBeam.scale.set(1, length, 1);
            healBeam.position.copy(start).add(dir.clone().multiplyScalar(0.5));
            healBeam.lookAt(end);
            healBeam.rotateX(Math.PI / 2);

            scene.add(healBeam);

            // Fade out and remove
            let opacity = 0.7;
            const fadeInterval = setInterval(() => {
                opacity -= 0.15;
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(healBeam);
                    beamGeo.dispose();
                    beamMat.dispose();
                } else {
                    healBeam.material.opacity = opacity;
                }
            }, 30);
        }

        // Damage the ship
        // v5.15: Added attacker parameter for tracking
        function damageShip(amount, attacker = null) {
            const hpBefore = SHIP_STATE.hp;
            SHIP_STATE.hp = Math.max(0, SHIP_STATE.hp - amount);
            SHIP_STATE.damaged = true;

            // v5.15: Log the attack
            const attackerName = attacker?.userData?.name || 'Unknown Attacker';
            logDefenseEvent('ship_attacked', {
                attacker: attackerName,
                damage: amount,
                shipHpBefore: hpBefore,
                shipHpAfter: SHIP_STATE.hp,
                attackerHp: attacker?.userData?.hp || null,
                critical: amount >= 10
            });

            // Clear damaged flag after 2 seconds
            setTimeout(() => { SHIP_STATE.damaged = false; }, 2000);

            // Visual feedback
            if (SHIP_STATE.mesh) {
                // Flash red
                SHIP_STATE.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        const originalColor = child.material.emissive.getHex();
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            child.material.emissive.setHex(originalColor);
                        }, 200);
                    }
                });
            }

            // Particles
            if (particles && SHIP_STATE.mesh) {
                particles.emit(SHIP_STATE.mesh.position, 15, 0xff4400, { spread: 3, lifetime: 500 });
            }

            spawnFloater(SHIP_STATE.mesh.position, `-${amount}`, '#ff0000');
            showNotification(`Ship taking damage! (${SHIP_STATE.hp}/${SHIP_STATE.maxHp} HP)`, 'warning');

            // Update UI
            updateShipHPUI();

            // Ship destroyed
            if (SHIP_STATE.hp <= 0) {
                shipDestroyed(attackerName);
            }
        }

        // Handle ship destruction
        // v5.15: Added finalBlow parameter
        function shipDestroyed(finalBlow = 'Unknown') {
            // v5.15: Log destruction event
            logDefenseEvent('ship_destroyed', {
                finalBlow: finalBlow,
                totalDamageTaken: SHIP_STATE.defenseLog.totalDamageTaken,
                totalEngagements: SHIP_STATE.defenseLog.totalEngagements,
                totalKills: SHIP_STATE.defenseLog.totalKills
            });

            showNotification('SHIP DESTROYED! Repair required to leave planet.', 'error');

            // Disable ship mesh
            if (SHIP_STATE.mesh) {
                SHIP_STATE.mesh.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 0.3;
                        child.material.transparent = true;
                    }
                });
            }

            // Large explosion
            if (particles && SHIP_STATE.mesh) {
                particles.emit(SHIP_STATE.mesh.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                particles.emit(SHIP_STATE.mesh.position, 30, 0xffff00, { spread: 6, lifetime: 1000 });
            }
        }

        // Repair ship (costs gold)
        function repairShip() {
            if (SHIP_STATE.hp >= SHIP_STATE.maxHp) {
                showNotification('Ship is already at full health!', 'info');
                return;
            }

            if (gameData.currency >= SHIP_STATE.repairCost) {
                const hpBefore = SHIP_STATE.hp;
                const hpRestored = SHIP_STATE.maxHp - hpBefore;

                gameData.currency -= SHIP_STATE.repairCost;
                SHIP_STATE.hp = SHIP_STATE.maxHp;

                // v5.15: Log repair event
                logDefenseEvent('ship_repaired', {
                    cost: SHIP_STATE.repairCost,
                    hpBefore: hpBefore,
                    hpAfter: SHIP_STATE.maxHp,
                    hpRestored: hpRestored,
                    wasDestroyed: hpBefore === 0
                });

                // Restore ship visuals
                if (SHIP_STATE.mesh) {
                    SHIP_STATE.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = 1;
                            child.material.transparent = false;
                        }
                    });
                }

                showNotification(`Ship repaired! -${SHIP_STATE.repairCost} Gold`, 'success');
                updateShipHPUI();
                saveGameData(); // v6.41: Fixed undefined function call (was saveGame)
            } else {
                showNotification(`Need ${SHIP_STATE.repairCost} Gold to repair ship!`, 'warning');
            }
        }

        // Update ship HP UI
        function updateShipHPUI() {
            const bar = document.getElementById('ship-hp-fill');
            const text = document.getElementById('ship-hp-text');
            if (bar) {
                const percent = (SHIP_STATE.hp / SHIP_STATE.maxHp) * 100;
                bar.style.width = `${percent}%`;
                bar.style.background = percent > 50 ? '#00ff88' : percent > 25 ? '#ffaa00' : '#ff4444';
            }
            if (text) {
                text.textContent = `${SHIP_STATE.hp}/${SHIP_STATE.maxHp}`;
            }
        }

        // Toggle ship auto-defend
        function toggleShipAutoDefend() {
            SHIP_STATE.laser.autoDefend = !SHIP_STATE.laser.autoDefend;
            showNotification(`Ship Auto-Defense: ${SHIP_STATE.laser.autoDefend ? 'ENABLED' : 'DISABLED'}`, 'info');
            const btn = document.getElementById('ship-defense-btn');
            if (btn) {
                btn.textContent = SHIP_STATE.laser.autoDefend ? ' Defense: ON' : ' Defense: OFF';
                btn.style.background = SHIP_STATE.laser.autoDefend ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 68, 68, 0.2)';
            }
        }

        // v5.11: RTS Panel Toggle System
        const rtsPanelState = {
            skills: false,
            crafting: false,
            inventory: false,
            equipment: false
        };

        function toggleRTSPanel(panelName) {
            rtsPanelState[panelName] = !rtsPanelState[panelName];

            const panelIds = {
                skills: 'skills-panel',
                crafting: 'crafting-panel',
                inventory: 'inventory-panel',
                equipment: 'equipment-panel'
            };

            const panel = document.getElementById(panelIds[panelName]);
            const toggleBtn = document.getElementById(`toggle-${panelName}`);

            if (panel) {
                if (rtsPanelState[panelName]) {
                    panel.classList.add('visible');
                } else {
                    panel.classList.remove('visible');
                }
            }

            if (toggleBtn) {
                if (rtsPanelState[panelName]) {
                    toggleBtn.classList.add('active');
                } else {
                    toggleBtn.classList.remove('active');
                }
            }
        }

        // v5.11: Keyboard shortcuts for RTS panels
        // v6.35: Fixed 'E' conflict - equipment now uses 'G' for Gear, 'E' reserved for combat ability
        // v7.0: Enhanced hotkey handler with consistent shortcuts
        function handleRTSPanelHotkeys(e) {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

            switch(e.key.toLowerCase()) {
                case 'k': toggleRTSPanel('skills'); break;
                case 'i': toggleRTSPanel('inventory'); break;
                case 'g': toggleRTSPanel('equipment'); break;
                case 'p': toggleRTSPanel('crafting'); break; // P for Production/Crafting
                case 'm': // M for Map/Galaxy
                    if (currentMode === 'world' && typeof openGalaxyManager === 'function') {
                        openGalaxyManager();
                    }
                    break;
            }
        }

        // v5.2: Talent Modal UI
        function showTalentModal() {
            document.getElementById('talent-modal').style.display = 'flex';
            updateTalentModal();
        }

        function closeTalentModal() {
            document.getElementById('talent-modal').style.display = 'none';
        }

        function updateTalentModal() {
            const points = getTalentPoints();
            document.getElementById('talent-points-display').textContent = `Talent Points: ${points.available}/${points.earned}`;

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                const treeDiv = document.getElementById(`talent-tree-${treeId}`);
                if (!treeDiv) continue;

                let html = '';
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    const canUnlock = canUnlockTalent(treeId, talentId);
                    const isMaxed = rank >= talent.maxRank;
                    const isLocked = talent.requires && getTalentRank(treeId, talent.requires) < TALENT_TREES[treeId].talents[talent.requires].maxRank;

                    html += `
                        <div style="padding: 8px; margin-bottom: 5px; border: 1px solid ${isMaxed ? tree.color : isLocked ? '#333' : '#555'};
                                    border-radius: 4px; background: ${isMaxed ? `${tree.color}22` : 'rgba(0,0,0,0.3)'};
                                    opacity: ${isLocked ? 0.5 : 1}; cursor: ${canUnlock ? 'pointer' : 'default'};"
                             onclick="${canUnlock ? `unlockTalent('${treeId}', '${talentId}')` : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: ${isMaxed ? tree.color : '#fff'};">${talent.name}</span>
                                <span style="color: ${isMaxed ? '#4f4' : '#888'};">${rank}/${talent.maxRank}</span>
                            </div>
                            <div style="font-size: 10px; color: #888; margin-top: 3px;">${talent.desc}</div>
                        </div>
                    `;
                }
                treeDiv.innerHTML = html;
            }
        }

        // ============================================
        // v5.3: MASTERY SYSTEM
        // ============================================
        const MASTERY_MILESTONES = {
            mining: {
                name: 'Mining', icon: '', color: '#888888',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'miningYield', value: 0.1 }, desc: '+10% ore yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'miningYield', value: 0.15 }, desc: '+15% ore yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Miner\'s Blessing' }, desc: 'Unlock Miner\'s Blessing buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'miningYield', value: 0.25 }, desc: '+25% ore yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Miner' }, desc: 'Earn Grandmaster title' }
                ]
            },
            wood: {
                name: 'Woodcutting', icon: '', color: '#da5500',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'woodYield', value: 0.1 }, desc: '+10% wood yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'woodYield', value: 0.15 }, desc: '+15% wood yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Lumberjack\'s Spirit' }, desc: 'Unlock Lumberjack buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'woodYield', value: 0.25 }, desc: '+25% wood yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Lumberjack' }, desc: 'Earn Grandmaster title' }
                ]
            },
            combat: {
                name: 'Combat', icon: '', color: '#ff4444',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'combatDamage', value: 0.05 }, desc: '+5% damage' },
                    { level: 10, reward: { type: 'bonus', stat: 'combatDamage', value: 0.1 }, desc: '+10% damage' },
                    { level: 15, reward: { type: 'unlock', ability: 'Veteran Strike' }, desc: 'Unlock Veteran Strike' },
                    { level: 20, reward: { type: 'bonus', stat: 'combatCrit', value: 0.05 }, desc: '+5% crit chance' },
                    { level: 25, reward: { type: 'title', title: 'Warlord' }, desc: 'Earn Warlord title' }
                ]
            },
            fishing: {
                name: 'Fishing', icon: '', color: '#4488ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'fishChance', value: 0.1 }, desc: '+10% catch rate' },
                    { level: 10, reward: { type: 'bonus', stat: 'rareFind', value: 0.05 }, desc: '+5% rare fish' },
                    { level: 15, reward: { type: 'unlock', item: 'Golden Lure' }, desc: 'Unlock Golden Lure' },
                    { level: 20, reward: { type: 'bonus', stat: 'fishChance', value: 0.2 }, desc: '+20% catch rate' },
                    { level: 25, reward: { type: 'title', title: 'Master Angler' }, desc: 'Earn Master title' }
                ]
            },
            cooking: {
                name: 'Cooking', icon: '', color: '#ff8800',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'healBonus', value: 0.1 }, desc: '+10% heal amount' },
                    { level: 10, reward: { type: 'bonus', stat: 'healBonus', value: 0.15 }, desc: '+15% heal amount' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Feast' }, desc: 'Unlock Feast recipe' },
                    { level: 20, reward: { type: 'bonus', stat: 'foodDuration', value: 0.3 }, desc: '+30% buff duration' },
                    { level: 25, reward: { type: 'title', title: 'Master Chef' }, desc: 'Earn Master title' }
                ]
            },
            crafting: {
                name: 'Crafting', icon: '', color: '#aa44ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'craftBonus', value: 0.1 }, desc: '+10% craft success' },
                    { level: 10, reward: { type: 'bonus', stat: 'materialSave', value: 0.1 }, desc: '10% material savings' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Masterwork Forge' }, desc: 'Unlock Masterwork crafts' },
                    { level: 20, reward: { type: 'bonus', stat: 'rarityBoost', value: 0.15 }, desc: '+15% rarity chance' },
                    { level: 25, reward: { type: 'title', title: 'Artisan Supreme' }, desc: 'Earn Artisan title' }
                ]
            }
        };

        function getMasteryBonuses() {
            const bonuses = {
                miningYield: 0, woodYield: 0, combatDamage: 0, combatCrit: 0,
                fishChance: 0, rareFind: 0, healBonus: 0, foodDuration: 0,
                craftBonus: 0, materialSave: 0, rarityBoost: 0
            };

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'bonus') {
                        bonuses[milestone.reward.stat] = (bonuses[milestone.reward.stat] || 0) + milestone.reward.value;
                    }
                }
            }

            return bonuses;
        }

        function getUnlockedMasteryTitles() {
            const titles = [];
            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'title') {
                        titles.push(milestone.reward.title);
                    }
                }
            }
            return titles;
        }

        function openMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'flex';
            updateMasteryModal();
        }

        function closeMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'none';
        }

        function updateMasteryModal() {
            const listDiv = document.getElementById('mastery-list');
            let html = '';

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                const maxMilestone = mastery.milestones[mastery.milestones.length - 1].level;
                const progress = Math.min(100, (skillLevel / maxMilestone) * 100);
                const isMastered = skillLevel >= maxMilestone;

                html += `
                    <div class="mastery-card ${isMastered ? 'mastered' : ''}">
                        <div class="mastery-header">
                            <span class="mastery-skill" style="color: ${mastery.color};">${mastery.icon} ${mastery.name}</span>
                            <span class="mastery-level">Lv ${skillLevel}</span>
                        </div>
                        <div class="mastery-progress-bar">
                            <div class="mastery-progress-fill" style="width: ${progress}%;"></div>
                        </div>
                        <div class="mastery-milestones">
                `;

                for (const milestone of mastery.milestones) {
                    const achieved = skillLevel >= milestone.level;
                    const isNext = !achieved && mastery.milestones.find(m => skillLevel < m.level)?.level === milestone.level;
                    html += `
                        <div class="milestone ${achieved ? 'achieved' : ''} ${isNext ? 'next' : ''}" title="${milestone.desc}">
                            Lv${milestone.level}: ${achieved ? '' : milestone.desc.substring(0, 15)}...
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        // ============================================
        // v5.3: REALM PORTAL SYSTEM
        // ============================================
        const REALM_PORTALS = {
            shadow_realm: {
                name: 'Shadow Realm',
                icon: '',
                tier: 1,
                desc: 'A realm of darkness where shadows come alive. Enhanced enemy spawn rates.',
                requirements: { combatLevel: 10, bossesDefeated: 1 },
                modifiers: { enemyDamage: 1.5, enemyHp: 1.3, spawnRate: 2.0 },
                rewards: ['Shadow Essence', 'Dark Crystal'],
                xpMultiplier: 1.5,
                duration: 300 // 5 minutes
            },
            frost_dimension: {
                name: 'Frost Dimension',
                icon: '',
                tier: 2,
                desc: 'An eternally frozen world. All enemies inflict chill. Ice enemies are empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 1.8, enemyHp: 1.5, allEnemiesChill: true },
                rewards: ['Frozen Heart', 'Permafrost Shard', 'Frost Blade'],
                xpMultiplier: 2.0,
                duration: 300
            },
            inferno_pit: {
                name: 'Inferno Pit',
                icon: '',
                tier: 2,
                desc: 'Volcanic realm of eternal flame. Fire damage over time. Magma enemies empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 2.0, enemyHp: 1.5, environmentalDamage: 2 },
                rewards: ['Infernal Core', 'Magma Heart', 'Magma Sword'],
                xpMultiplier: 2.0,
                duration: 300
            },
            void_nexus: {
                name: 'Void Nexus',
                icon: '',
                tier: 3,
                desc: 'The space between dimensions. Reality warps around you. Elite enemies guaranteed.',
                requirements: { combatLevel: 20, bossesDefeated: 5, elitesKilled: 20 },
                modifiers: { enemyDamage: 2.5, enemyHp: 2.0, allElites: true },
                rewards: ['Void Core', 'Dimension Shard', 'Void Dagger', 'Legendary Core'],
                xpMultiplier: 3.0,
                duration: 300
            },
            celestial_ascent: {
                name: 'Celestial Ascent',
                icon: '',
                tier: 4,
                desc: 'The ultimate challenge. Face the Celestial Guardians in their domain.',
                requirements: { combatLevel: 25, bossesDefeated: 10, portalClears: 5 },
                modifiers: { enemyDamage: 3.0, enemyHp: 3.0, bossOnly: true },
                rewards: ['Celestial Essence', 'Star Fragment', 'Legendary Blade', 'Mythic Orb'],
                xpMultiplier: 5.0,
                duration: 600 // 10 minutes
            }
        };

        function initPortalSystem() {
            if (!gameData.portals) {
                gameData.portals = {
                    clears: {},
                    currentPortal: null,
                    portalStartTime: 0,
                    totalClears: 0
                };
            }
        }

        function canEnterPortal(portalId) {
            const portal = REALM_PORTALS[portalId];
            if (!portal) return false;

            const reqs = portal.requirements;
            const combatLevel = gameData.skills?.combat?.level || 1;
            const bossesDefeated = gameData.statistics?.bossesDefeated || 0;
            const elitesKilled = gameData.statistics?.elitesKilled || 0;
            const portalClears = gameData.portals?.totalClears || 0;

            if (combatLevel < reqs.combatLevel) return false;
            if (bossesDefeated < reqs.bossesDefeated) return false;
            if (reqs.elitesKilled && elitesKilled < reqs.elitesKilled) return false;
            if (reqs.portalClears && portalClears < reqs.portalClears) return false;

            return true;
        }

        function getPortalRequirementText(portalId) {
            const portal = REALM_PORTALS[portalId];
            const reqs = portal.requirements;
            const parts = [];

            parts.push(`Combat Lv ${reqs.combatLevel}`);
            parts.push(`${reqs.bossesDefeated} bosses`);
            if (reqs.elitesKilled) parts.push(`${reqs.elitesKilled} elites`);
            if (reqs.portalClears) parts.push(`${reqs.portalClears} portal clears`);

            return parts.join(' | ');
        }

        function enterPortal(portalId) {
            if (!canEnterPortal(portalId)) {
                showNotification('Requirements not met!', 'error');
                return false;
            }

            if (gameData.portals.currentPortal) {
                showNotification('Already in a portal realm!', 'warning');
                return false;
            }

            if (mode !== 'world') {
                showNotification('Must be on a planet to enter portals!', 'warning');
                return false;
            }

            const portal = REALM_PORTALS[portalId];
            gameData.portals.currentPortal = portalId;
            gameData.portals.portalStartTime = Date.now();
            gameData.portals.killProgress = 0; // v5.3: Reset kill counter

            showNotification(`Entered ${portal.name}! ${portal.duration / 60} minutes to clear.`, 'success');
            AudioSystem.bossSpawn();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 50, parseInt(portal.icon === '' ? '0x440088' : portal.icon === '' ? '0x88ddff' : portal.icon === '' ? '0xff4400' : '0x8844ff'), { spread: 8, lifetime: 1500 });
            }

            closePortalModal();
            updatePortalUI();
            saveGameData();
            return true;
        }

        function exitPortal(completed = false) {
            if (!gameData.portals.currentPortal) return;

            const portalId = gameData.portals.currentPortal;
            const portal = REALM_PORTALS[portalId];

            if (completed) {
                // Grant rewards
                gameData.portals.clears[portalId] = (gameData.portals.clears[portalId] || 0) + 1;
                gameData.portals.totalClears++;

                // Give a random reward
                const rewardItem = portal.rewards[Math.floor(Math.random() * portal.rewards.length)];
                addItem(rewardItem);

                // v6.35: Chronicle Engine - capture portal clear
                if (typeof captureChronicleEvent === 'function') {
                    captureChronicleEvent('portal_cleared', { portalName: portal.name, reward: rewardItem, totalClears: gameData.portals.totalClears });
                }

                showNotification(`Portal cleared! Received ${rewardItem}!`, 'success');
                AudioSystem.levelUp();

                if (particles && worldState.player) {
                    particles.emit(worldState.player.position, 60, 0xffd700, { spread: 10, lifetime: 2000 });
                }
            } else {
                showNotification('Portal expired. Try again!', 'warning');
            }

            gameData.portals.currentPortal = null;
            gameData.portals.portalStartTime = 0;
            updatePortalUI();
            saveGameData();
        }

        function getPortalModifiers() {
            if (!gameData.portals?.currentPortal) return null;
            return REALM_PORTALS[gameData.portals.currentPortal]?.modifiers || null;
        }

        function getPortalXpMultiplier() {
            if (!gameData.portals?.currentPortal) return 1;
            return REALM_PORTALS[gameData.portals.currentPortal]?.xpMultiplier || 1;
        }

        function checkPortalTimeout() {
            if (!gameData.portals?.currentPortal) return;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;

            if (elapsed >= portal.duration) {
                exitPortal(false);
            }
        }

        function getPortalTimeRemaining() {
            if (!gameData.portals?.currentPortal) return 0;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;
            return Math.max(0, portal.duration - elapsed);
        }

        function openPortalModal() {
            initPortalSystem();
            document.getElementById('portal-modal').style.display = 'flex';
            updatePortalModal();
        }

        function closePortalModal() {
            document.getElementById('portal-modal').style.display = 'none';
        }

        function updatePortalModal() {
            const currentPortal = gameData.portals?.currentPortal;
            document.getElementById('current-realm').textContent = currentPortal ? REALM_PORTALS[currentPortal].name : 'None';

            const listDiv = document.getElementById('portal-list');
            let html = '';

            for (const [portalId, portal] of Object.entries(REALM_PORTALS)) {
                const canEnter = canEnterPortal(portalId);
                const isActive = currentPortal === portalId;
                const clears = gameData.portals?.clears?.[portalId] || 0;

                html += `
                    <div class="portal-card ${!canEnter ? 'locked' : ''} ${isActive ? 'active' : ''}"
                         onclick="${canEnter && !currentPortal ? `enterPortal('${portalId}')` : ''}">
                        <div class="portal-header">
                            <span class="portal-name">${portal.icon} ${portal.name}</span>
                            <span class="portal-tier">Tier ${portal.tier}</span>
                        </div>
                        <div class="portal-desc">${portal.desc}</div>
                        <div class="portal-rewards">
                            ${portal.rewards.map(r => `<span class="portal-reward">${ITEMS[r]?.icon || ''} ${r}</span>`).join('')}
                        </div>
                        <div class="portal-requirement">
                            ${canEnter ? ` Unlocked | Cleared: ${clears}x | ${portal.xpMultiplier}x XP` : ` ${getPortalRequirementText(portalId)}`}
                        </div>
                        ${isActive ? `<div style="color: #ff8844; margin-top: 8px; text-align: center;"> Active - ${Math.floor(getPortalTimeRemaining())}s remaining</div>` : ''}
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        function updatePortalUI() {
            // This would update any in-game portal indicators
            if (document.getElementById('portal-modal').style.display === 'flex') {
                updatePortalModal();
            }
        }

        // ============================================
        // v5.3: LOOT RARITY SYSTEM
        // ============================================
        const LOOT_RARITIES = {
            common: { name: 'Common', color: '#aaaaaa', chance: 0.60, statMult: 1.0 },
            uncommon: { name: 'Uncommon', color: '#44ff44', chance: 0.25, statMult: 1.15 },
            rare: { name: 'Rare', color: '#4488ff', chance: 0.10, statMult: 1.35 },
            epic: { name: 'Epic', color: '#aa44ff', chance: 0.04, statMult: 1.6 },
            legendary: { name: 'Legendary', color: '#ff8800', chance: 0.0095, statMult: 2.0 },
            mythic: { name: 'Mythic', color: '#ff4488', chance: 0.0005, statMult: 3.0 }
        };

        const ITEM_MODIFIERS = {
            // Offensive modifiers
            sharp: { name: 'Sharp', stat: 'damage', value: 3, desc: '+3 Damage' },
            keen: { name: 'Keen', stat: 'critChance', value: 0.05, desc: '+5% Crit' },
            brutal: { name: 'Brutal', stat: 'damage', value: 5, desc: '+5 Damage' },
            deadly: { name: 'Deadly', stat: 'critDamage', value: 0.25, desc: '+25% Crit Damage' },
            vampiric: { name: 'Vampiric', stat: 'lifesteal', value: 0.05, desc: '+5% Lifesteal' },

            // Defensive modifiers
            sturdy: { name: 'Sturdy', stat: 'defense', value: 2, desc: '+2 Defense' },
            fortified: { name: 'Fortified', stat: 'defense', value: 4, desc: '+4 Defense' },
            vital: { name: 'Vital', stat: 'maxHp', value: 15, desc: '+15 Max HP' },
            resilient: { name: 'Resilient', stat: 'damageReduction', value: 0.05, desc: '+5% DR' },

            // Utility modifiers
            swift: { name: 'Swift', stat: 'moveSpeed', value: 0.1, desc: '+10% Speed' },
            lucky: { name: 'Lucky', stat: 'lootBonus', value: 0.1, desc: '+10% Loot' },
            wise: { name: 'Wise', stat: 'xpBonus', value: 0.1, desc: '+10% XP' },
            efficient: { name: 'Efficient', stat: 'resourceYield', value: 0.15, desc: '+15% Yield' }
        };

        function rollItemRarity(baseLuckBonus = 0) {
            const masteryBonuses = getMasteryBonuses();
            const talentBonuses = getTalentBonuses();
            const totalLuck = baseLuckBonus + (masteryBonuses.rarityBoost || 0) + (talentBonuses.rareFind || 0);

            let roll = Math.random();
            // Luck improves rare+ chances
            roll = roll * (1 - totalLuck);

            let cumulative = 0;
            for (const [rarityId, rarity] of Object.entries(LOOT_RARITIES)) {
                cumulative += rarity.chance;
                if (roll < cumulative) {
                    return rarityId;
                }
            }
            return 'common';
        }

        function rollItemModifiers(rarity) {
            const numModifiers = {
                common: 0,
                uncommon: 1,
                rare: 1,
                epic: 2,
                legendary: 2,
                mythic: 3
            };

            const count = numModifiers[rarity] || 0;
            if (count === 0) return [];

            const modifierKeys = Object.keys(ITEM_MODIFIERS);
            const selected = [];

            for (let i = 0; i < count; i++) {
                const availableModifiers = modifierKeys.filter(m => !selected.includes(m));
                if (availableModifiers.length === 0) break;

                const modId = availableModifiers[Math.floor(Math.random() * availableModifiers.length)];
                selected.push(modId);
            }

            return selected;
        }

        function createRarityItem(baseItemName, forcedRarity = null) {
            const rarity = forcedRarity || rollItemRarity();
            const modifiers = rollItemModifiers(rarity);
            const rarityData = LOOT_RARITIES[rarity];

            return {
                baseName: baseItemName,
                rarity: rarity,
                modifiers: modifiers,
                statMultiplier: rarityData.statMult
            };
        }

        function getRarityItemName(rarityItem) {
            if (!rarityItem || !rarityItem.rarity || rarityItem.rarity === 'common') {
                return rarityItem?.baseName || rarityItem;
            }

            const modNames = rarityItem.modifiers?.map(m => ITEM_MODIFIERS[m]?.name).filter(Boolean) || [];
            const prefix = modNames.length > 0 ? modNames.join(' ') + ' ' : '';
            const rarityData = LOOT_RARITIES[rarityItem.rarity];

            return `${prefix}${rarityItem.baseName}`;
        }

        function getRarityItemStats(rarityItem) {
            if (!rarityItem || typeof rarityItem === 'string') return {};

            const stats = {};
            const mult = rarityItem.statMultiplier || 1;

            // Apply modifier stats
            for (const modId of (rarityItem.modifiers || [])) {
                const mod = ITEM_MODIFIERS[modId];
                if (mod) {
                    stats[mod.stat] = (stats[mod.stat] || 0) + mod.value;
                }
            }

            return stats;
        }

        function showRarityDropPopup(rarityItem) {
            if (!rarityItem || rarityItem.rarity === 'common') return;

            const rarityData = LOOT_RARITIES[rarityItem.rarity];
            const itemData = ITEMS[rarityItem.baseName] || {};
            const displayName = getRarityItemName(rarityItem);
            const modifierStats = getRarityItemStats(rarityItem);

            // v6.35: Chronicle Engine - capture rare item drops (legendary/epic only)
            if (typeof captureChronicleEvent === 'function' && (rarityItem.rarity === 'legendary' || rarityItem.rarity === 'epic')) {
                captureChronicleEvent('rare_item', { itemName: displayName, rarity: rarityItem.rarity, baseName: rarityItem.baseName });
            }

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'loot-drop-popup';
            popup.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">${itemData.icon || ''}</div>
                <div class="rarity-${rarityItem.rarity}" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    ${rarityData.name} Drop!
                </div>
                <div style="color: ${rarityData.color}; font-size: 14px; margin-bottom: 10px;">
                    ${displayName}
                </div>
                ${Object.keys(modifierStats).length > 0 ? `
                    <div class="item-modifiers">
                        ${rarityItem.modifiers.map(m => ITEM_MODIFIERS[m]?.desc).join(' | ')}
                    </div>
                ` : ''}
                <button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 20px; cursor: pointer;
                    background: linear-gradient(135deg, ${rarityData.color}, #333); border: none; border-radius: 4px; color: #fff;">
                    Collect
                </button>
            `;

            document.body.appendChild(popup);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (popup.parentElement) {
                    popup.remove();
                }
            }, 5000);

            // Play appropriate sound
            if (rarityItem.rarity === 'legendary' || rarityItem.rarity === 'mythic') {
                AudioSystem.levelUp();
            } else {
                AudioSystem.collect();
            }
        }

        // Enhanced item drop function that uses rarity system
        function dropRarityItem(baseItemName, luckBonus = 0) {
            const rarityItem = createRarityItem(baseItemName, null);

            // Store rarity items in a special format
            if (!gameData.rarityItems) gameData.rarityItems = [];

            if (rarityItem.rarity !== 'common') {
                gameData.rarityItems.push(rarityItem);
                showRarityDropPopup(rarityItem);
            }

            // Add the base item to inventory (rarity tracked separately)
            addItem(baseItemName);

            return rarityItem;
        }

        // Get total bonus stats from all rarity items
        function getRarityBonuses() {
            const bonuses = {};

            for (const item of (gameData.rarityItems || [])) {
                // Only count equipped items (check if base item is in equipment)
                const gear = getEquippedGear();
                const isEquipped = Object.values(gear).some(g => g === item.baseName);

                if (isEquipped) {
                    const stats = getRarityItemStats(item);
                    for (const [stat, value] of Object.entries(stats)) {
                        bonuses[stat] = (bonuses[stat] || 0) + value;
                    }
                }
            }

            return bonuses;
        }

        // v5.5: 3D Ship Landing Mini-Game System (Drone-style)
        let landingGame = {
            active: false,
            targetCiv: null,
            scene: null,
            camera: null,
            renderer: null,
            ship: null,
            landingPad: null,
            animFrame: null,
            lastTime: 0,
            isManual: false,
            fuel: 100,
            velocity: null,
            targetPosition: null,
            propellers: [],
            thrustLight: null,
            environmentObjects: []
        };

        const LANDING_CONFIG = {
            startAltitude: 60,
            maxSpeed: 8,
            safeSpeed: 2.5,
            gravity: 0.02,          // Much slower gravity
            thrustPower: 0.06,      // Gentler thrust
            manualControl: 0.25,    // Slower manual movement
            fuelConsumption: 0.02,  // Slower fuel drain
            landingPadSize: 18,     // Bigger landing pad
            bounds: 100,
            biomeColors: {
                Terra: { sky: 0x87CEEB, ground: 0x3a8c3a, fog: 0x87CEEB },
                Desert: { sky: 0xffcc99, ground: 0xc2a060, fog: 0xffcc99 },
                Ice: { sky: 0xddeeff, ground: 0xe8f4f8, fog: 0xddeeff },
                Volcanic: { sky: 0x330000, ground: 0x2a1a1a, fog: 0x330000 },
                Alien: { sky: 0x220044, ground: 0x440066, fog: 0x220044 }
            }
        };

        function startLandingGame(civ) {
            // v6.64: Final safety check - don't land on destroyed planets
            if (!civ || civ.orbital?.destroyed) {
                showNotification(`${civ?.name || 'Target planet'} no longer exists! Landing aborted.`, 'error');
                AudioSystem.error();
                return;
            }

            // Cleanup any existing landing game
            if (landingGame.animFrame) {
                cancelAnimationFrame(landingGame.animFrame);
            }
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
            }

            landingGame.active = true;
            landingGame.targetCiv = civ;
            landingGame.isManual = false;
            landingGame.fuel = 100;
            landingGame.velocity = new THREE.Vector3(0, -0.1, 0);  // Very slow initial descent
            landingGame.targetPosition = new THREE.Vector3(0, 20, 0);
            landingGame.lastTime = 0;
            mode = 'landing';

            // Show landing UI
            const overlay = document.getElementById('landing-overlay');
            overlay.style.display = 'block';
            document.getElementById('landing-planet-name').textContent = `Landing on ${civ.name} (${civ.biomeName})`;
            document.getElementById('landing-mode').textContent = 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = 'Switch to Manual';

            // Get biome colors
            const biomeColors = LANDING_CONFIG.biomeColors[civ.biome] || LANDING_CONFIG.biomeColors.Terra;

            // Create separate Three.js scene for landing
            landingGame.scene = new THREE.Scene();
            landingGame.scene.fog = new THREE.Fog(biomeColors.fog, 100, 500);

            // Isometric camera
            const container = document.getElementById('landing-scene-container');
            const aspect = container.clientWidth / container.clientHeight;
            const d = 50;
            landingGame.camera = new THREE.OrthographicCamera(
                -d * aspect, d * aspect, d, -d, 1, 1000
            );
            landingGame.camera.position.set(100, 100, 100);
            landingGame.camera.lookAt(0, 0, 0);

            // Renderer - v6.87: Mobile optimizations
            const isMobileLanding = /iphone|ipad|ipod|android/i.test(navigator.userAgent);
            landingGame.renderer = new THREE.WebGLRenderer({ antialias: !isMobileLanding });
            landingGame.renderer.setSize(container.clientWidth, container.clientHeight);
            landingGame.renderer.setPixelRatio(isMobileLanding ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2));
            landingGame.renderer.shadowMap.enabled = !isMobileLanding;
            landingGame.renderer.shadowMap.type = isMobileLanding ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
            landingGame.renderer.setClearColor(biomeColors.sky);
            container.innerHTML = '';
            container.appendChild(landingGame.renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            landingGame.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            landingGame.scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: biomeColors.ground });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            landingGame.scene.add(ground);

            // Create landing pad
            createLandingPad();

            // Create environment based on biome
            createLandingEnvironment(civ.biome);

            // Create ship
            createLandingShip();

            // Start animation loop
            landingGameLoop(0);

            // Simple short blip sound instead of ringing tone
            AudioSystem.click();
            showNotification(`Approaching ${civ.name}... Land on the green pad!`, 'info');
        }

        function createLandingPad() {
            const padGroup = new THREE.Group();

            // Main pad
            const padGeometry = new THREE.CylinderGeometry(LANDING_CONFIG.landingPadSize, LANDING_CONFIG.landingPadSize, 1, 32);
            const padMaterial = new THREE.MeshLambertMaterial({ color: 0x44ff44 });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.position.y = 0.5;
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Center marker
            const markerGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.y = 1.2;
            padGroup.add(marker);

            // Beacon light
            const beaconGeometry = new THREE.CylinderGeometry(1, 1, 5, 8);
            const beaconMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.set(LANDING_CONFIG.landingPadSize - 2, 3, 0);
            beacon.castShadow = true;
            padGroup.add(beacon);

            // Beacon light
            const lightGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            landingGame.beaconLight = new THREE.Mesh(lightGeometry, lightMaterial);
            landingGame.beaconLight.position.set(LANDING_CONFIG.landingPadSize - 2, 6, 0);
            padGroup.add(landingGame.beaconLight);

            landingGame.landingPad = padGroup;
            landingGame.scene.add(padGroup);
        }

        function createLandingEnvironment(biome) {
            landingGame.environmentObjects = [];

            // Add trees/structures based on biome
            if (biome === 'Terra' || biome === 'Alien') {
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 250;
                    const z = (Math.random() - 0.5) * 250;
                    if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                        const tree = createLandingTree(biome);
                        tree.position.set(x, 0, z);
                        landingGame.scene.add(tree);
                        landingGame.environmentObjects.push(tree);
                    }
                }
            }

            // Add rocks/obstacles for all biomes
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                if (Math.abs(x) > 25 || Math.abs(z) > 25) {
                    const rock = createLandingRock(biome);
                    rock.position.set(x, 0, z);
                    landingGame.scene.add(rock);
                    landingGame.environmentObjects.push(rock);
                }
            }
        }

        function createLandingTree(biome) {
            const group = new THREE.Group();

            // v6.72: Minecraft-style procedural textures
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15);
            const trunkColor = biome === 'Alien' ? 0x8800ff : 0x8B4513;
            const trunkMaterial = MinecraftTextures.createWoodMaterial(trunkColor, 12345);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(8, 8, 6);
            const foliageColor = biome === 'Alien' ? 0xff00ff : 0x228B22;
            const foliageMaterial = MinecraftTextures.createLeafMaterial(foliageColor, 54321);
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 18;
            foliage.castShadow = true;
            group.add(foliage);

            return group;
        }

        function createLandingRock(biome) {
            // v6.72: Minecraft-style procedural textures
            const rockColors = {
                Terra: 0x888888,
                Desert: 0xaa5522,
                Ice: 0xaaccff,
                Volcanic: 0x333333,
                Alien: 0x00ffcc
            };
            const height = 5 + Math.random() * 15;
            const geometry = new THREE.DodecahedronGeometry(3 + Math.random() * 5, 0);
            const biomeData = BIOMES[biome] || { rock: rockColors[biome] || 0x888888 };
            const material = MinecraftTextures.createRockMaterial({ rock: biomeData.rock || rockColors[biome] || 0x888888 });
            const rock = new THREE.Mesh(geometry, material);
            rock.position.y = height / 2;
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.scale.y = height / 10;
            rock.castShadow = true;
            rock.receiveShadow = true;
            return rock;
        }

        function createLandingShip() {
            const shipGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(6, 2, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shipGroup.add(body);

            // Cockpit
            const cockpitGeometry = new THREE.SphereGeometry(2, 16, 16);
            const cockpitMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.y = 1.5;
            cockpit.scale.y = 0.6;
            shipGroup.add(cockpit);

            // Propeller arms and propellers
            landingGame.propellers = [];
            const propPositions = [
                [-4, 0.5, -4], [4, 0.5, -4],
                [-4, 0.5, 4], [4, 0.5, 4]
            ];

            propPositions.forEach(pos => {
                // Arm
                const armGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos[0] * 0.6, pos[1], pos[2] * 0.6);
                shipGroup.add(arm);

                // Propeller
                const propGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4);
                const propMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                const propeller = new THREE.Mesh(propGeometry, propMaterial);
                propeller.rotation.z = Math.PI / 2;
                propeller.position.set(...pos);
                propeller.castShadow = true;
                landingGame.propellers.push(propeller);
                shipGroup.add(propeller);
            });

            // Engine light
            landingGame.thrustLight = new THREE.PointLight(0x00ff00, 1, 15);
            landingGame.thrustLight.position.y = -1;
            shipGroup.add(landingGame.thrustLight);

            // Position ship at start
            shipGroup.position.set(
                (Math.random() - 0.5) * 40,
                LANDING_CONFIG.startAltitude,
                (Math.random() - 0.5) * 40
            );

            landingGame.ship = shipGroup;
            landingGame.scene.add(shipGroup);
        }

        function landingGameLoop(currentTime) {
            if (!landingGame.active) return;

            const deltaTime = (currentTime - landingGame.lastTime) / 1000;
            landingGame.lastTime = currentTime;

            if (deltaTime > 0 && deltaTime < 0.1) {
                updateLandingShip(deltaTime);
                checkLandingConditions();
                updateLandingUI();
            }

            // Rotate propellers
            landingGame.propellers.forEach(prop => {
                prop.rotation.y += deltaTime * 50;
            });

            // Blink beacon
            const blinkOn = Math.floor(currentTime / 500) % 2 === 0;
            if (landingGame.beaconLight) {
                landingGame.beaconLight.material.color.setHex(blinkOn ? 0xff0000 : 0x440000);
            }

            // Camera follow
            const cameraTarget = new THREE.Vector3(
                landingGame.ship.position.x * 0.3,
                0,
                landingGame.ship.position.z * 0.3
            );
            landingGame.camera.position.x = 100 + cameraTarget.x;
            landingGame.camera.position.z = 100 + cameraTarget.z;
            landingGame.camera.lookAt(cameraTarget);

            landingGame.renderer.render(landingGame.scene, landingGame.camera);
            landingGame.animFrame = requestAnimationFrame(landingGameLoop);
        }

        function updateLandingShip(deltaTime) {
            const ship = landingGame.ship;

            // Slow fuel drain
            landingGame.fuel = Math.max(0, landingGame.fuel - deltaTime * LANDING_CONFIG.fuelConsumption * 3);

            if (!landingGame.isManual && landingGame.fuel > 0) {
                // Autonomous flight - navigate to landing pad
                runLandingAutopilot(deltaTime);
            } else if (landingGame.isManual && landingGame.fuel > 0) {
                // Manual controls via keyboard
                applyManualLandingControls(deltaTime);
            }

            // Apply gentle gravity
            landingGame.velocity.y -= LANDING_CONFIG.gravity * deltaTime * 20;

            // Apply velocity (slower multiplier)
            ship.position.add(landingGame.velocity.clone().multiplyScalar(deltaTime * 25));

            // Tilt based on velocity
            ship.rotation.z = landingGame.velocity.x * 0.05;
            ship.rotation.x = -landingGame.velocity.z * 0.05;

            // Strong damping for smoother movement
            landingGame.velocity.multiplyScalar(0.96);

            // Keep within bounds
            ship.position.clamp(
                new THREE.Vector3(-LANDING_CONFIG.bounds, 2, -LANDING_CONFIG.bounds),
                new THREE.Vector3(LANDING_CONFIG.bounds, 100, LANDING_CONFIG.bounds)
            );

            // Update thrust light color based on mode
            if (landingGame.thrustLight) {
                landingGame.thrustLight.color.setHex(landingGame.isManual ? 0xff8800 : 0x00ff88);
                landingGame.thrustLight.intensity = 1 + Math.sin(Date.now() * 0.005) * 0.3;
            }
        }

        function runLandingAutopilot(deltaTime) {
            const ship = landingGame.ship;
            const padPos = new THREE.Vector3(0, 4, 0); // Target slightly above pad

            // Calculate direction to landing pad
            const direction = new THREE.Vector3().subVectors(padPos, ship.position);
            const horizontalDist = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
            const verticalDist = ship.position.y;

            // Desired velocity based on position - MUCH slower and gentler
            const desiredVelocity = new THREE.Vector3();

            // Horizontal movement - very gentle drift toward pad
            if (horizontalDist > 3) {
                desiredVelocity.x = direction.x * 0.015;  // Very slow horizontal
                desiredVelocity.z = direction.z * 0.015;
            }

            // Vertical movement - very controlled slow descent
            const slowDescent = -0.15;  // Very slow descent speed
            if (verticalDist > 25) {
                // High altitude - still slow descent
                desiredVelocity.y = slowDescent * 1.5;
            } else if (horizontalDist > 8) {
                // Not over pad yet - hover and drift
                desiredVelocity.y = -0.05;
            } else {
                // Over pad - very slow final descent
                desiredVelocity.y = slowDescent * 0.5;
            }

            // Very gentle lerp toward desired velocity
            landingGame.velocity.lerp(desiredVelocity, deltaTime * 0.8);

            // Counter gravity gently when needed
            if (landingGame.velocity.y < desiredVelocity.y - 0.05) {
                landingGame.velocity.y += LANDING_CONFIG.thrustPower * deltaTime * 30;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 0.5;
            }
        }

        function applyManualLandingControls(deltaTime) {
            const controlForce = LANDING_CONFIG.manualControl * deltaTime * 60;

            if (landingKeys['ArrowUp'] || landingKeys['w']) {
                landingGame.velocity.z -= controlForce;
            }
            if (landingKeys['ArrowDown'] || landingKeys['s']) {
                landingGame.velocity.z += controlForce;
            }
            if (landingKeys['ArrowLeft'] || landingKeys['a']) {
                landingGame.velocity.x -= controlForce;
            }
            if (landingKeys['ArrowRight'] || landingKeys['d']) {
                landingGame.velocity.x += controlForce;
            }
            if (landingKeys[' ']) {
                landingGame.velocity.y += controlForce * 1.5;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 2;
            }
            if (landingKeys['Shift']) {
                landingGame.velocity.y -= controlForce * 0.5;
            }
        }

        const landingKeys = {};

        function handleLandingKeyDown(e) {
            if (!landingGame.active) return;
            landingKeys[e.key] = true;

            if (e.key === 'Escape') {
                abortLanding();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleLandingMode();
            }

            // Auto-switch to manual if keys pressed
            if (!landingGame.isManual && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                landingGame.isManual = true;
                updateLandingModeUI();
                showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
            }

            e.preventDefault();
        }

        function handleLandingKeyUp(e) {
            landingKeys[e.key] = false;
        }

        function toggleLandingMode() {
            landingGame.isManual = !landingGame.isManual;
            updateLandingModeUI();
            showNotification(landingGame.isManual ? 'MANUAL CONTROL' : 'AUTOPILOT ENGAGED', 'info');
        }

        function updateLandingModeUI() {
            document.getElementById('landing-mode').textContent = landingGame.isManual ? 'Manual' : 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = landingGame.isManual ? 'Switch to Autonomous' : 'Switch to Manual';
        }

        function updateLandingUI() {
            const ship = landingGame.ship;
            const altitude = Math.max(0, ship.position.y - 1).toFixed(1);
            const speed = landingGame.velocity.length().toFixed(1);
            const padPos = new THREE.Vector3(0, 0, 0);
            const distance = Math.sqrt(
                Math.pow(ship.position.x - padPos.x, 2) +
                Math.pow(ship.position.z - padPos.z, 2)
            ).toFixed(1);

            document.getElementById('landing-altitude').textContent = altitude;
            document.getElementById('landing-speed').textContent = speed;
            document.getElementById('landing-fuel').textContent = Math.floor(landingGame.fuel);
            document.getElementById('landing-distance').textContent = distance;
        }

        function checkLandingConditions() {
            const ship = landingGame.ship;
            const altitude = ship.position.y;
            const speed = landingGame.velocity.length();
            const horizontalDist = Math.sqrt(ship.position.x * ship.position.x + ship.position.z * ship.position.z);

            // Check if landed
            if (altitude <= 3) {
                const onPad = horizontalDist < LANDING_CONFIG.landingPadSize;
                const slowEnough = speed < LANDING_CONFIG.safeSpeed;

                if (onPad && slowEnough) {
                    landingSuccess();
                } else if (!slowEnough) {
                    landingCrash('Too fast! Reduce speed before landing.');
                } else {
                    landingCrash('Missed the landing pad!');
                }
            }

            // Out of fuel
            if (landingGame.fuel <= 0 && altitude > 10) {
                landingCrash('Out of fuel!');
            }
        }

        function landingSuccess() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            const civ = landingGame.targetCiv;
            const bonusXp = Math.floor(landingGame.fuel * 2);

            cleanupLandingGame();

            showNotification(`Perfect landing on ${civ.name}! +${bonusXp} XP bonus!`, 'success');
            AudioSystem.levelUp();

            // Grant landing bonus XP
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(bonusXp / 6));
            });

            // Track successful landings
            gameData.statistics.successfulLandings = (gameData.statistics.successfulLandings || 0) + 1;

            // Now actually enter the world
            initWorld(civ);
        }

        function landingCrash(reason) {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            cleanupLandingGame();

            showNotification(`Crash landing! ${reason}`, 'error');
            AudioSystem.error();

            // Take damage
            gameData.player.hp = Math.max(1, gameData.player.hp - 20);
            updateHealthUI();

            // Track crashes
            gameData.statistics.crashLandings = (gameData.statistics.crashLandings || 0) + 1;

            mode = 'galaxy';
        }

        function abortLanding() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);
            cleanupLandingGame();
            mode = 'galaxy';
            showNotification('Landing aborted. Returning to orbit.', 'info');
        }

        function cleanupLandingGame() {
            document.getElementById('landing-overlay').style.display = 'none';
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
                const container = document.getElementById('landing-scene-container');
                if (container) container.innerHTML = '';
            }
            // Reset keys
            Object.keys(landingKeys).forEach(k => landingKeys[k] = false);
        }

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isTouchDevice = 'ontouchstart' in window;

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;
        let cycle = 0;

        // Floater pool for performance
        const floaterPool = [];
        const MAX_FLOATERS = 20;

        // RPG State
        let worldState = {
            player: null,
            terrain: [],
            interactables: [],
            fishingSpots: [],
            mobs: [],
            pois: [], // v4.2: Points of Interest
            structures: [], // v5.18: Battery chargers and built structures
            terraformedAreas: [], // v5.18: Flattened terrain zones
            sun: null,
            ambient: null,
            timeOfDay: 0,
            target: null,
            interactTarget: null,
            lastActionTime: 0, // v4.0: Cooldown-based interactions
            lastPlayerPos: null // v4.2: For distance tracking
        };

        // v5.18: Robot Energy System
        let robotEnergy = {
            current: 100,
            max: 100,
            drainRate: 0.02, // Energy drain per second when moving
            chargeRate: 5,   // Energy gain per second when on charger
            lowEnergyThreshold: 20,
            isCharging: false
        };

        // ============================================
        // v6.93: TIME REWIND SYSTEM
        // Auto-saves snapshots every 30 seconds
        // Rewind to any point in your 12+ hour session
        // Persists to localStorage - survives refreshes
        // ============================================

        const TimeRewind = {
            // Configuration
            SNAPSHOT_INTERVAL: 30000,      // Auto-snapshot every 30 seconds
            MAX_SNAPSHOTS: 1440,           // 12 hours worth at 30s intervals
            STORAGE_KEY: 'levi-time-rewind',

            // State
            snapshots: [],
            lastSnapshotTime: 0,
            isRewinding: false,
            selectedIndex: -1,

            // Initialize - load existing snapshots from storage
            init() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.snapshots = data.snapshots || [];
                        console.log(` TimeRewind: Loaded ${this.snapshots.length} snapshots from storage`);
                    }
                } catch (e) {
                    console.warn('TimeRewind: Could not load snapshots', e);
                    this.snapshots = [];
                }

                // v6.93: Take immediate snapshot on init to capture current state
                setTimeout(() => {
                    this.takeSnapshot('Session start - ' + new Date().toLocaleTimeString());
                    console.log(' TimeRewind: Created initial snapshot');
                }, 3000); // Wait 3s for game to fully initialize with galaxy

                this.updateUI();
            },

            // Take a snapshot of current game state
            takeSnapshot(label = null) {
                const snapshot = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    playtime: gameData.playtime,
                    cycle: gameData.totalCycles,
                    label: label || `Auto-save at ${this.formatTime(gameData.playtime)}`,

                    // Full gameData clone
                    gameData: JSON.parse(JSON.stringify(gameData)),

                    // Galaxy state
                    civilizations: civilizations.map(c => ({
                        id: c.id,
                        x: c.x,
                        y: c.y,
                        z: c.z,
                        name: c.name,
                        biome: c.biome,
                        visited: c.visited,
                        orbital: c.orbital ? { ...c.orbital } : null
                    })),

                    // Physics state
                    physics: { ...physicsParams },

                    // Current mode
                    mode: mode,

                    // Active planet
                    activePlanetId: activeCiv?.id ?? null
                };

                this.snapshots.push(snapshot);

                // Trim to max snapshots (keep most recent)
                while (this.snapshots.length > this.MAX_SNAPSHOTS) {
                    this.snapshots.shift();
                }

                this.saveToStorage();
                this.updateUI();

                console.log(` Snapshot taken: ${snapshot.label} (${this.snapshots.length} total)`);
                return snapshot;
            },

            // Auto-snapshot called from animate loop
            update(time) {
                if (this.isRewinding) return;

                if (time - this.lastSnapshotTime >= this.SNAPSHOT_INTERVAL) {
                    this.takeSnapshot();
                    this.lastSnapshotTime = time;
                }
            },

            // Restore game to a specific snapshot
            restoreSnapshot(index) {
                if (index < 0 || index >= this.snapshots.length) {
                    showNotification('Invalid snapshot index!', 'error');
                    return;
                }

                const snapshot = this.snapshots[index];
                this.isRewinding = true;

                try {
                    // Restore gameData
                    Object.assign(gameData, snapshot.gameData);

                    // Restore civilizations state
                    snapshot.civilizations.forEach((savedCiv, i) => {
                        if (civilizations[i]) {
                            civilizations[i].x = savedCiv.x;
                            civilizations[i].y = savedCiv.y;
                            civilizations[i].z = savedCiv.z;
                            civilizations[i].visited = savedCiv.visited;

                            if (savedCiv.orbital && civilizations[i].orbital) {
                                Object.assign(civilizations[i].orbital, savedCiv.orbital);
                            }

                            // Update 3D mesh position and visibility
                            const group = galaxyGroup?.children[i];
                            if (group) {
                                group.position.set(savedCiv.x, savedCiv.y, savedCiv.z);
                                const destroyed = savedCiv.orbital?.destroyed;
                                const escaped = savedCiv.orbital?.escaped;
                                group.visible = !(destroyed || escaped);
                            }
                        }
                    });

                    // Restore physics
                    Object.assign(physicsParams, snapshot.physics);

                    // Save restored state
                    saveGameData();

                    // Remove all snapshots after this one (branch off)
                    this.snapshots = this.snapshots.slice(0, index + 1);
                    this.saveToStorage();

                    showNotification(` Rewound to: ${snapshot.label}`, 'success');
                    console.log(` Restored snapshot from index ${index}`);

                } catch (e) {
                    console.error('TimeRewind: Restore failed', e);
                    showNotification('Rewind failed!', 'error');
                }

                this.isRewinding = false;
                this.updateUI();
            },

            // Rewind by N steps
            rewindSteps(steps = 1) {
                const targetIndex = this.snapshots.length - 1 - steps;
                if (targetIndex >= 0) {
                    this.restoreSnapshot(targetIndex);
                } else {
                    showNotification('No earlier snapshots available!', 'error');
                }
            },

            // Quick rewind to last snapshot
            quickRewind() {
                if (this.snapshots.length >= 2) {
                    this.restoreSnapshot(this.snapshots.length - 2);
                } else {
                    showNotification('Need at least 2 snapshots to rewind!', 'error');
                }
            },

            // Manual save point with label
            createSavePoint(label) {
                const snapshot = this.takeSnapshot(label || `Manual save - ${new Date().toLocaleTimeString()}`);
                showNotification(` Save point created: ${snapshot.label}`, 'success');
            },

            // Save snapshots to localStorage
            saveToStorage() {
                try {
                    // Only save essential data to reduce storage size
                    const toSave = {
                        version: '1.0',
                        savedAt: Date.now(),
                        snapshots: this.snapshots
                    };
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(toSave));
                } catch (e) {
                    console.warn('TimeRewind: Storage save failed (quota?)', e);
                    // Aggressively reduce snapshots on quota error
                    if (this.snapshots.length > 5) {
                        // Keep only the 5 most recent snapshots
                        this.snapshots = this.snapshots.slice(-5);
                        console.log(' TimeRewind: Reduced to 5 snapshots to free storage');
                        try {
                            const reduced = {
                                version: '1.0',
                                savedAt: Date.now(),
                                snapshots: this.snapshots
                            };
                            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(reduced));
                        } catch (e2) {
                            // If still failing, clear entirely
                            console.warn(' TimeRewind: Clearing all snapshots due to quota');
                            this.snapshots = [];
                            localStorage.removeItem(this.STORAGE_KEY);
                        }
                    }
                }
            },

            // Export all snapshots to file
            exportSnapshots() {
                if (this.snapshots.length === 0) {
                    showNotification('No snapshots to export!', 'error');
                    return;
                }

                const data = {
                    version: '1.0',
                    exportedAt: Date.now(),
                    totalPlaytime: gameData.playtime,
                    snapshotCount: this.snapshots.length,
                    snapshots: this.snapshots
                };

                const json = JSON.stringify(data);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `levi-timeline-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);

                const sizeMB = (json.length / 1024 / 1024).toFixed(2);
                showNotification(` Exported ${this.snapshots.length} snapshots (${sizeMB}MB)`, 'success');
            },

            // Import snapshots from file
            importSnapshots(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!data.snapshots || !Array.isArray(data.snapshots)) {
                            throw new Error('Invalid timeline file');
                        }

                        this.snapshots = data.snapshots;
                        this.saveToStorage();
                        this.updateUI();

                        showNotification(` Imported ${this.snapshots.length} snapshots`, 'success');
                    } catch (err) {
                        showNotification('Import failed: ' + err.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // Clear all snapshots
            clearSnapshots() {
                if (confirm('Clear all time rewind data? This cannot be undone.')) {
                    this.snapshots = [];
                    localStorage.removeItem(this.STORAGE_KEY);
                    this.updateUI();
                    showNotification('Timeline cleared', 'info');
                }
            },

            // Format playtime
            formatTime(seconds) {
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                if (hrs > 0) return `${hrs}h ${mins}m`;
                return `${mins}m`;
            },

            // Update the rewind UI
            updateUI() {
                const countEl = document.getElementById('rewind-count');
                const sliderEl = document.getElementById('rewind-slider');
                const labelEl = document.getElementById('rewind-label');

                if (countEl) {
                    countEl.textContent = this.snapshots.length;
                }

                if (sliderEl) {
                    sliderEl.max = Math.max(0, this.snapshots.length - 1);
                    sliderEl.value = this.snapshots.length - 1;
                }

                if (labelEl && this.snapshots.length > 0) {
                    const latest = this.snapshots[this.snapshots.length - 1];
                    labelEl.textContent = latest.label;
                }
            },

            // Show rewind modal with timeline
            showModal() {
                let modal = document.getElementById('rewind-modal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'rewind-modal';
                    modal.innerHTML = `
                        <div style="position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                            <div style="background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%); border: 2px solid #4a9eff; border-radius: 12px; padding: 20px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h2 style="color: #4a9eff; margin: 0;"> Time Rewind</h2>
                                    <button onclick="document.getElementById('rewind-modal').remove()" style="background: #ff4444; border: none; color: white; padding: 5px 15px; border-radius: 5px; cursor: pointer;">Close</button>
                                </div>
                                <p style="color: #888; margin-bottom: 15px;">Select a point to rewind to. All progress after that point will be lost.</p>
                                <div id="rewind-timeline" style="max-height: 400px; overflow-y: auto;"></div>
                                <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                                    <button onclick="TimeRewind.createSavePoint(prompt('Save point label:'))" style="background: #44aa44; border: none; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer;"> Create Save Point</button>
                                    <button onclick="TimeRewind.exportSnapshots()" style="background: #4488ff; border: none; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer;"> Export Timeline</button>
                                    <button onclick="document.getElementById('rewind-import').click()" style="background: #ff8844; border: none; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer;"> Import Timeline</button>
                                    <input type="file" id="rewind-import" accept=".json" style="display:none" onchange="TimeRewind.importSnapshots(this.files[0])">
                                    <button onclick="TimeRewind.clearSnapshots()" style="background: #ff4444; border: none; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer;"> Clear All</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }

                // Populate timeline
                const timeline = document.getElementById('rewind-timeline');
                if (timeline) {
                    if (this.snapshots.length === 0) {
                        timeline.innerHTML = '<p style="color: #666; text-align: center;">No snapshots yet. Play for 30 seconds to create the first auto-save.</p>';
                    } else {
                        timeline.innerHTML = this.snapshots.slice().reverse().map((snap, reverseIdx) => {
                            const idx = this.snapshots.length - 1 - reverseIdx;
                            const isLatest = idx === this.snapshots.length - 1;
                            const civCount = snap.civilizations.filter(c => !c.orbital?.destroyed && !c.orbital?.escaped).length;
                            const date = new Date(snap.timestamp);
                            return `
                                <div style="background: ${isLatest ? 'rgba(74, 158, 255, 0.2)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${isLatest ? '#4a9eff' : '#333'}; border-radius: 8px; padding: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;"
                                     onclick="TimeRewind.restoreSnapshot(${idx}); document.getElementById('rewind-modal').remove();"
                                     onmouseover="this.style.borderColor='#4a9eff'" onmouseout="this.style.borderColor='${isLatest ? '#4a9eff' : '#333'}'">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <div style="color: #fff; font-weight: bold;">${snap.label}</div>
                                            <div style="color: #888; font-size: 12px;">${date.toLocaleTimeString()} - Playtime: ${this.formatTime(snap.playtime)}</div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="color: #4a9eff; font-size: 18px;">${civCount}</div>
                                            <div style="color: #666; font-size: 10px;">planets</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    }
                }
            }
        };

        // Global function to show rewind modal
        function showRewindModal() {
            TimeRewind.showModal();
        }

        // Quick rewind function for keyboard shortcut
        function quickRewind() {
            TimeRewind.quickRewind();
        }

        // ============================================
        // v6.56: CIVILIZATION GENESIS ENGINE
        // 8-Agent Consensus Implementation
        // Drop a seed, watch civilizations emerge from 4 rules:
        // 1. Attract Resources
        // 2. Claim Territory
        // 3. Reproduce
        // 4. Die
        // ============================================

        const GENESIS_CONFIG = {
            // Rule 1: Attract Resources
            RESOURCE_SENSE_RADIUS: 60,
            RESOURCE_ATTRACTION_STRENGTH: 0.8,
            RESOURCE_GATHER_RATE: 0.5,
            RESOURCE_SPAWN_RATE: 0.03,
            MAX_RESOURCES: 100,

            // Rule 2: Claim Territory
            TERRITORY_RADIUS: 8,
            TERRITORY_BUILD_RATE: 2,
            TERRITORY_DECAY_RATE: 0.1,
            KINSHIP_BONUS: 0.3, // Reduced repulsion for family

            // Rule 3: Reproduce
            REPRODUCTION_THRESHOLD: 80,
            REPRODUCTION_COST: 40,
            REPRODUCTION_COOLDOWN: 100, // ticks
            MIN_REPRODUCTION_AGE: 50,

            // Rule 4: Die
            DEATH_AGE: 800,
            STARVATION_THRESHOLD: 5,
            ENERGY_DECAY_RATE: 0.15,

            // Performance
            MAX_ENTITIES: 500,
            WORLD_RADIUS: 150,
            CELL_SIZE: 15, // Spatial hash grid

            // Visual
            FACTION_COLORS: [0x66aaff, 0x66ff88, 0xff8866, 0xaa66ff, 0xffff66, 0xff66aa]
        };

        // Genesis State
        let genesisState = {
            active: false,
            paused: false,
            speed: 1,
            tick: 0,
            entities: [],
            resources: [],
            territory: {}, // "x,z" -> { owner, lineage, strength }
            factions: {},
            nextId: 1,
            nextFactionId: 0,
            events: [],
            stats: {
                peakPopulation: 0,
                totalFactions: 0,
                totalWars: 0,
                totalDeaths: 0
            },
            // Three.js objects
            entityMeshes: null,
            resourceMeshes: null,
            territoryMesh: null,
            genesisScene: null,
            previousMode: 'galaxy',
            previousCameraPos: null
        };

        // Spatial hash grid for O(1) neighbor queries
        const GenesisSpatialGrid = {
            cells: new Map(),

            getKey(x, z) {
                const cx = Math.floor(x / GENESIS_CONFIG.CELL_SIZE);
                const cz = Math.floor(z / GENESIS_CONFIG.CELL_SIZE);
                return `${cx},${cz}`;
            },

            clear() {
                this.cells.clear();
            },

            rebuild(entities) {
                this.cells.clear();
                entities.forEach((entity, idx) => {
                    if (entity.alive) {
                        const key = this.getKey(entity.x, entity.z);
                        if (!this.cells.has(key)) this.cells.set(key, []);
                        this.cells.get(key).push(idx);
                    }
                });
            },

            getNearby(x, z, radius) {
                const results = [];
                const cellRadius = Math.ceil(radius / GENESIS_CONFIG.CELL_SIZE);
                const cx = Math.floor(x / GENESIS_CONFIG.CELL_SIZE);
                const cz = Math.floor(z / GENESIS_CONFIG.CELL_SIZE);
                const radiusSq = radius * radius;

                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                        const cell = this.cells.get(`${cx + dx},${cz + dz}`);
                        if (!cell) continue;

                        for (const idx of cell) {
                            const entity = genesisState.entities[idx];
                            if (!entity || !entity.alive) continue;
                            const distSq = (entity.x - x) ** 2 + (entity.z - z) ** 2;
                            if (distSq <= radiusSq) {
                                results.push({ idx, entity, distSq });
                            }
                        }
                    }
                }
                return results.sort((a, b) => a.distSq - b.distSq);
            }
        };

        // Create a new entity
        function createGenesisEntity(x, z, parentLineage = null, generation = 0) {
            const id = genesisState.nextId++;
            const lineage = parentLineage || id;

            // Determine or create faction
            let factionId = null;
            if (parentLineage) {
                // Find parent's faction
                for (const [fid, faction] of Object.entries(genesisState.factions)) {
                    if (faction.lineage === parentLineage) {
                        factionId = parseInt(fid);
                        break;
                    }
                }
            }

            // Create new faction if needed (tribes emerge!)
            if (factionId === null && generation >= 2) {
                factionId = genesisState.nextFactionId++;
                const colorIdx = factionId % GENESIS_CONFIG.FACTION_COLORS.length;
                genesisState.factions[factionId] = {
                    id: factionId,
                    lineage: lineage,
                    color: GENESIS_CONFIG.FACTION_COLORS[colorIdx],
                    name: `Tribe ${factionId + 1}`,
                    founded: genesisState.tick,
                    population: 0
                };
                genesisState.stats.totalFactions++;
                logGenesisEvent(` ${genesisState.factions[factionId].name} founded!`);
            }

            const entity = {
                id,
                x,
                z,
                energy: 50,
                age: 0,
                lineage,
                factionId,
                generation,
                speed: 1 + (Math.random() - 0.5) * 0.3, // Slight variation
                territoryStrength: 0,
                lastReproduction: 0,
                alive: true,
                state: 'wandering' // wandering, gathering, claiming, fighting
            };

            genesisState.entities.push(entity);

            if (factionId !== null && genesisState.factions[factionId]) {
                genesisState.factions[factionId].population++;
            }

            return entity;
        }

        // Spawn a resource
        function spawnGenesisResource() {
            if (genesisState.resources.length >= GENESIS_CONFIG.MAX_RESOURCES) return;

            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * GENESIS_CONFIG.WORLD_RADIUS * 0.9;

            genesisState.resources.push({
                x: Math.cos(angle) * dist,
                z: Math.sin(angle) * dist,
                amount: 20 + Math.random() * 30
            });
        }

        // RULE 1: Attract Resources
        function applyAttractionRule(entity, idx) {
            // Find nearest resource
            let nearest = null;
            let nearestDistSq = Infinity;

            for (const resource of genesisState.resources) {
                if (resource.amount <= 0) continue;
                const dx = resource.x - entity.x;
                const dz = resource.z - entity.z;
                const distSq = dx * dx + dz * dz;
                if (distSq < nearestDistSq && distSq < GENESIS_CONFIG.RESOURCE_SENSE_RADIUS ** 2) {
                    nearestDistSq = distSq;
                    nearest = resource;
                }
            }

            if (nearest) {
                const dist = Math.sqrt(nearestDistSq);
                if (dist > 2) {
                    // Move toward resource
                    const dx = nearest.x - entity.x;
                    const dz = nearest.z - entity.z;
                    entity.x += (dx / dist) * entity.speed * GENESIS_CONFIG.RESOURCE_ATTRACTION_STRENGTH;
                    entity.z += (dz / dist) * entity.speed * GENESIS_CONFIG.RESOURCE_ATTRACTION_STRENGTH;
                    entity.state = 'gathering';
                } else {
                    // Gather resource
                    const gather = Math.min(GENESIS_CONFIG.RESOURCE_GATHER_RATE, nearest.amount);
                    entity.energy += gather;
                    nearest.amount -= gather;
                }
            } else {
                // Wander randomly
                entity.x += (Math.random() - 0.5) * entity.speed * 0.5;
                entity.z += (Math.random() - 0.5) * entity.speed * 0.5;
                entity.state = 'wandering';
            }

            // Keep in bounds
            const dist = Math.sqrt(entity.x ** 2 + entity.z ** 2);
            if (dist > GENESIS_CONFIG.WORLD_RADIUS) {
                entity.x *= GENESIS_CONFIG.WORLD_RADIUS / dist;
                entity.z *= GENESIS_CONFIG.WORLD_RADIUS / dist;
            }
        }

        // RULE 2: Claim Territory
        function applyTerritoryRule(entity, idx) {
            const key = `${Math.floor(entity.x / 5)},${Math.floor(entity.z / 5)}`;

            if (!genesisState.territory[key]) {
                genesisState.territory[key] = {
                    owner: entity.id,
                    lineage: entity.lineage,
                    strength: 0
                };
            }

            const tile = genesisState.territory[key];
            const sameLineage = tile.lineage === entity.lineage;

            if (sameLineage) {
                // Strengthen owned territory
                tile.strength = Math.min(tile.strength + GENESIS_CONFIG.TERRITORY_BUILD_RATE, 100);
                entity.territoryStrength = tile.strength;
            } else {
                // Contest foreign territory (WAR EMERGES!)
                tile.strength -= GENESIS_CONFIG.TERRITORY_BUILD_RATE;
                entity.energy -= 1; // Fighting costs energy
                entity.state = 'fighting';

                // Check for war declaration
                if (entity.factionId !== null && tile.lineage) {
                    for (const [fid, faction] of Object.entries(genesisState.factions)) {
                        if (faction.lineage === tile.lineage && parseInt(fid) !== entity.factionId) {
                            // War!
                            genesisState.stats.totalWars++;
                        }
                    }
                }

                if (tile.strength <= 0) {
                    // Territory conquered!
                    tile.owner = entity.id;
                    tile.lineage = entity.lineage;
                    tile.strength = 1;
                }
            }
        }

        // RULE 3: Reproduce
        function applyReproductionRule(entity, idx) {
            const ticksSinceRepro = genesisState.tick - entity.lastReproduction;

            if (entity.energy >= GENESIS_CONFIG.REPRODUCTION_THRESHOLD &&
                entity.age >= GENESIS_CONFIG.MIN_REPRODUCTION_AGE &&
                ticksSinceRepro >= GENESIS_CONFIG.REPRODUCTION_COOLDOWN &&
                genesisState.entities.filter(e => e.alive).length < GENESIS_CONFIG.MAX_ENTITIES) {

                // Check density - don't reproduce if too crowded
                const nearby = GenesisSpatialGrid.getNearby(entity.x, entity.z, 10);
                if (nearby.length < 8) {
                    // Spawn offspring
                    const offsetAngle = Math.random() * Math.PI * 2;
                    const offsetDist = 3 + Math.random() * 3;
                    const childX = entity.x + Math.cos(offsetAngle) * offsetDist;
                    const childZ = entity.z + Math.sin(offsetAngle) * offsetDist;

                    createGenesisEntity(childX, childZ, entity.lineage, entity.generation + 1);

                    entity.energy -= GENESIS_CONFIG.REPRODUCTION_COST;
                    entity.lastReproduction = genesisState.tick;
                }
            }
        }

        // RULE 4: Die
        function applyDeathRule(entity, idx) {
            // Age
            entity.age++;

            // Energy decay
            entity.energy -= GENESIS_CONFIG.ENERGY_DECAY_RATE;

            // Death conditions
            let shouldDie = false;
            let cause = '';

            if (entity.age >= GENESIS_CONFIG.DEATH_AGE) {
                shouldDie = true;
                cause = 'old age';
            } else if (entity.energy <= GENESIS_CONFIG.STARVATION_THRESHOLD) {
                shouldDie = true;
                cause = 'starvation';
            }

            if (shouldDie) {
                entity.alive = false;
                genesisState.stats.totalDeaths++;

                if (entity.factionId !== null && genesisState.factions[entity.factionId]) {
                    genesisState.factions[entity.factionId].population--;
                    if (genesisState.factions[entity.factionId].population <= 0) {
                        logGenesisEvent(` ${genesisState.factions[entity.factionId].name} has fallen!`);
                    }
                }
            }
        }

        // Main simulation update
        function updateGenesisSimulation(dt) {
            if (!genesisState.active || genesisState.paused) return;

            const speed = genesisState.speed;
            for (let s = 0; s < speed; s++) {
                genesisState.tick++;

                // Rebuild spatial grid
                GenesisSpatialGrid.rebuild(genesisState.entities);

                // Apply rules to all entities
                genesisState.entities.forEach((entity, idx) => {
                    if (!entity.alive) return;

                    applyAttractionRule(entity, idx);
                    applyTerritoryRule(entity, idx);
                    applyReproductionRule(entity, idx);
                    applyDeathRule(entity, idx);
                });

                // Remove depleted resources
                genesisState.resources = genesisState.resources.filter(r => r.amount > 0);

                // Spawn new resources
                if (Math.random() < GENESIS_CONFIG.RESOURCE_SPAWN_RATE) {
                    spawnGenesisResource();
                }

                // Decay territory
                for (const key in genesisState.territory) {
                    genesisState.territory[key].strength -= GENESIS_CONFIG.TERRITORY_DECAY_RATE;
                    if (genesisState.territory[key].strength <= 0) {
                        delete genesisState.territory[key];
                    }
                }
            }

            // Update stats
            const aliveCount = genesisState.entities.filter(e => e.alive).length;
            if (aliveCount > genesisState.stats.peakPopulation) {
                genesisState.stats.peakPopulation = aliveCount;
            }

            // Update UI
            updateGenesisUI();

            // Update 3D rendering
            updateGenesisRendering();
        }

        // Update UI display
        function updateGenesisUI() {
            const alive = genesisState.entities.filter(e => e.alive).length;
            const factions = Object.values(genesisState.factions).filter(f => f.population > 0).length;
            const wars = genesisState.stats.totalWars;
            const age = Math.floor(genesisState.tick / 10);

            document.getElementById('genesis-population').textContent = alive;
            document.getElementById('genesis-factions').textContent = factions;
            document.getElementById('genesis-age').textContent = age;
            document.getElementById('genesis-wars').textContent = wars;
        }

        // Initialize Genesis 3D rendering
        function initGenesisRendering() {
            // Create instanced mesh for entities
            const entityGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const entityMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x333333,
                metalness: 0.3,
                roughness: 0.7
            });

            genesisState.entityMeshes = new THREE.InstancedMesh(
                entityGeometry,
                entityMaterial,
                GENESIS_CONFIG.MAX_ENTITIES
            );
            genesisState.entityMeshes.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            // Color buffer for per-instance colors
            const colors = new Float32Array(GENESIS_CONFIG.MAX_ENTITIES * 3);
            genesisState.entityMeshes.instanceColor = new THREE.InstancedBufferAttribute(colors, 3);

            scene.add(genesisState.entityMeshes);

            // Create resource markers
            const resourceGeometry = new THREE.ConeGeometry(0.3, 0.8, 4);
            const resourceMaterial = new THREE.MeshStandardMaterial({
                color: 0x44ff44,
                emissive: 0x114411
            });

            genesisState.resourceMeshes = new THREE.InstancedMesh(
                resourceGeometry,
                resourceMaterial,
                GENESIS_CONFIG.MAX_RESOURCES
            );
            scene.add(genesisState.resourceMeshes);

            // Create ground plane for territory visualization
            const groundGeometry = new THREE.PlaneGeometry(
                GENESIS_CONFIG.WORLD_RADIUS * 2.5,
                GENESIS_CONFIG.WORLD_RADIUS * 2.5,
                64, 64
            );
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x222211,
                roughness: 1,
                metalness: 0
            });
            genesisState.territoryMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            genesisState.territoryMesh.rotation.x = -Math.PI / 2;
            genesisState.territoryMesh.position.y = -0.5;
            scene.add(genesisState.territoryMesh);
        }

        // Update 3D rendering
        function updateGenesisRendering() {
            if (!genesisState.entityMeshes) return;

            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            let visibleCount = 0;

            // Update entity instances
            genesisState.entities.forEach((entity, idx) => {
                if (!entity.alive) return;

                dummy.position.set(entity.x, 0.5, entity.z);
                dummy.scale.setScalar(0.5 + (entity.energy / 100) * 0.3);
                dummy.updateMatrix();

                genesisState.entityMeshes.setMatrixAt(visibleCount, dummy.matrix);

                // Color based on faction
                if (entity.factionId !== null && genesisState.factions[entity.factionId]) {
                    color.setHex(genesisState.factions[entity.factionId].color);
                } else {
                    color.setHex(0xaaaaaa);
                }

                genesisState.entityMeshes.instanceColor.setXYZ(visibleCount, color.r, color.g, color.b);
                visibleCount++;
            });

            genesisState.entityMeshes.count = visibleCount;
            genesisState.entityMeshes.instanceMatrix.needsUpdate = true;
            genesisState.entityMeshes.instanceColor.needsUpdate = true;

            // Update resource instances
            let resourceCount = 0;
            genesisState.resources.forEach((resource, idx) => {
                if (resource.amount <= 0) return;

                dummy.position.set(resource.x, 0.4, resource.z);
                dummy.scale.setScalar(0.5 + (resource.amount / 50) * 0.3);
                dummy.updateMatrix();

                genesisState.resourceMeshes.setMatrixAt(resourceCount, dummy.matrix);
                resourceCount++;
            });

            genesisState.resourceMeshes.count = resourceCount;
            genesisState.resourceMeshes.instanceMatrix.needsUpdate = true;
        }

        // Cleanup genesis rendering
        function cleanupGenesisRendering() {
            if (genesisState.entityMeshes) {
                scene.remove(genesisState.entityMeshes);
                genesisState.entityMeshes.geometry.dispose();
                genesisState.entityMeshes.material.dispose();
                genesisState.entityMeshes = null;
            }
            if (genesisState.resourceMeshes) {
                scene.remove(genesisState.resourceMeshes);
                genesisState.resourceMeshes.geometry.dispose();
                genesisState.resourceMeshes.material.dispose();
                genesisState.resourceMeshes = null;
            }
            if (genesisState.territoryMesh) {
                scene.remove(genesisState.territoryMesh);
                genesisState.territoryMesh.geometry.dispose();
                genesisState.territoryMesh.material.dispose();
                genesisState.territoryMesh = null;
            }
        }

        // Toggle Genesis Mode
        function toggleGenesisMode() {
            if (mode === 'genesis') {
                exitGenesisMode();
            } else {
                enterGenesisMode();
            }
        }

        // Enter Genesis Mode
        function enterGenesisMode() {
            // Save current state
            genesisState.previousMode = mode;
            genesisState.previousCameraPos = camera.position.clone();

            mode = 'genesis';
            genesisState.active = true;
            genesisState.paused = false;

            // Hide other UI
            document.querySelector('.hud-top').style.display = 'none';
            document.getElementById('rpg-ui')?.classList.remove('visible');

            // Show Genesis UI
            document.getElementById('genesis-hud').classList.add('active');
            document.getElementById('genesis-controls-panel').classList.add('active');
            document.getElementById('genesis-cursor').classList.add('active');
            document.getElementById('genesis-button').classList.add('active');
            document.getElementById('genesis-event-log').classList.add('active');

            // Setup camera for top-down view
            camera.position.set(0, 200, 100);
            camera.lookAt(0, 0, 0);

            // Initialize rendering
            initGenesisRendering();

            // Spawn initial resources
            for (let i = 0; i < 30; i++) {
                spawnGenesisResource();
            }

            // Add click listener for dropping seeds
            renderer.domElement.addEventListener('click', handleGenesisClick);

            logGenesisEvent(' Genesis Mode activated - Click to drop seed!');
            showNotification('Genesis Mode - Click to drop seed particle', '#ffa500');
        }

        // Exit Genesis Mode
        function exitGenesisMode() {
            genesisState.active = false;
            mode = genesisState.previousMode || 'galaxy';

            // Remove click listener
            renderer.domElement.removeEventListener('click', handleGenesisClick);

            // Hide Genesis UI
            document.getElementById('genesis-hud').classList.remove('active');
            document.getElementById('genesis-controls-panel').classList.remove('active');
            document.getElementById('genesis-cursor').classList.remove('active');
            document.getElementById('genesis-button').classList.remove('active');
            document.getElementById('genesis-event-log').classList.remove('active');

            // Show main UI
            document.querySelector('.hud-top').style.display = 'flex';

            // Cleanup rendering
            cleanupGenesisRendering();

            // Reset state
            genesisState.entities = [];
            genesisState.resources = [];
            genesisState.territory = {};
            genesisState.factions = {};
            genesisState.tick = 0;
            genesisState.nextId = 1;
            genesisState.nextFactionId = 0;
            genesisState.events = [];

            // Restore camera
            if (genesisState.previousCameraPos) {
                camera.position.copy(genesisState.previousCameraPos);
            }

            showNotification('Exited Genesis Mode', '#0ff');
        }

        // Drop seed at position
        function dropGenesisSeed(worldX, worldZ) {
            const entity = createGenesisEntity(worldX, worldZ, null, 0);
            entity.energy = 100; // Full energy for seed

            logGenesisEvent(` Seed planted at (${Math.round(worldX)}, ${Math.round(worldZ)})`);
            showNotification('Seed planted! Watch civilization emerge...', '#ffa500');
        }

        // Genesis click handler
        function handleGenesisClick(event) {
            if (mode !== 'genesis') return;

            // Convert screen to world coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Intersect with ground plane
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);

            if (intersection) {
                dropGenesisSeed(intersection.x, intersection.z);
            }
        }

        // Speed control
        function setGenesisSpeed(speed) {
            genesisState.speed = speed;
            genesisState.paused = (speed === 0);

            document.querySelectorAll('.genesis-speed-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.speed) === speed);
            });

            showNotification(speed === 0 ? 'Genesis Paused' : `Genesis ${speed}x Speed`, '#ffa500');
        }

        // Divine interventions
        function triggerGenesisBless() {
            const alive = genesisState.entities.filter(e => e.alive);
            if (alive.length === 0) {
                showNotification('No entities to bless!', '#ff6644');
                return;
            }

            // Bless random entities with energy boost
            const tooBless = Math.min(10, alive.length);
            for (let i = 0; i < tooBless; i++) {
                const entity = alive[Math.floor(Math.random() * alive.length)];
                entity.energy = Math.min(entity.energy + 30, 150);
            }

            logGenesisEvent(' Divine blessing bestowed!');
            showNotification('Blessing bestowed! Entities energized.', '#ffd700');
        }

        function triggerGenesisDisaster() {
            const alive = genesisState.entities.filter(e => e.alive);
            if (alive.length === 0) {
                showNotification('No entities to afflict!', '#ff6644');
                return;
            }

            // Random disaster affects area
            const centerX = (Math.random() - 0.5) * GENESIS_CONFIG.WORLD_RADIUS;
            const centerZ = (Math.random() - 0.5) * GENESIS_CONFIG.WORLD_RADIUS;
            const radius = 30 + Math.random() * 20;

            let affected = 0;
            alive.forEach(entity => {
                const dist = Math.sqrt((entity.x - centerX) ** 2 + (entity.z - centerZ) ** 2);
                if (dist < radius) {
                    entity.energy -= 40;
                    if (entity.energy <= 0) entity.alive = false;
                    affected++;
                }
            });

            logGenesisEvent(` Disaster struck! ${affected} affected.`);
            showNotification(`Disaster! ${affected} entities affected.`, '#ff4444');
        }

        // Event logging
        function logGenesisEvent(message) {
            const ageStr = Math.floor(genesisState.tick / 10);
            genesisState.events.unshift({ tick: genesisState.tick, message });

            // Keep last 50 events
            if (genesisState.events.length > 50) {
                genesisState.events.pop();
            }

            // Update log display
            const logEl = document.getElementById('genesis-event-log');
            if (logEl) {
                logEl.innerHTML = genesisState.events.slice(0, 15).map(e =>
                    `<div class="genesis-event"><span class="genesis-event-time">[${Math.floor(e.tick/10)}]</span>${e.message}</div>`
                ).join('');
            }
        }

        // Genesis cursor tracking
        document.addEventListener('mousemove', (e) => {
            if (mode !== 'genesis') return;
            const cursor = document.getElementById('genesis-cursor');
            if (cursor) {
                cursor.style.left = (e.clientX - 25) + 'px';
                cursor.style.top = (e.clientY - 25) + 'px';
            }
        });

        // v5.18: P2P Spectator Streaming System
        let p2pStreaming = {
            peer: null,
            peerId: null,
            isHost: true,           // Host (player) or spectator
            connections: [],        // Active spectator connections
            hostConnection: null,   // Connection to host (when spectator)
            qrCodeVisible: false,
            lastFrameTime: 0,
            frameInterval: 100,     // Send frame every 100ms (10 FPS for efficiency)
            spectatorCount: 0,
            streamCanvas: null,     // Offscreen canvas for capturing
            isSpectating: false,
            spectatorData: null,    // Received data when spectating
            // v5.20: Simple stream controls
            streamPaused: false,    // When true, camera stops syncing
            hostGameMode: null      // Track host's current mode
        };

        // v5.5: Autonomous Exploration System
        let autoExplore = {
            enabled: true,  // Start in auto mode
            currentTarget: null,
            lastTargetTime: 0,
            targetCooldown: 3000,  // Time between target switches
            idleTime: 0,
            state: 'exploring',  // exploring, gathering, combat, idle
            combatTarget: null
        };

        function toggleAutoExplore() {
            autoExplore.enabled = !autoExplore.enabled;
            autoExplore.currentTarget = null;
            updateAutoExploreUI();
            showNotification(autoExplore.enabled ? 'AUTOPILOT: Exploring automatically' : 'MANUAL: You have control', 'info');
        }

        function updateAutoExploreUI() {
            const btn = document.getElementById('auto-explore-btn');
            const indicator = document.getElementById('auto-explore-indicator');
            if (btn) {
                btn.textContent = autoExplore.enabled ? 'Take Manual Control' : 'Enable Autopilot';
                btn.style.background = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
            if (indicator) {
                indicator.textContent = autoExplore.enabled ? ' AUTOPILOT' : ' MANUAL';
                indicator.style.color = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
        }

        function runAutoExplore(dt) {
            if (!autoExplore.enabled || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            // Priority 1: Combat - attack nearby enemies
            if (worldState.mobs.length > 0) {
                let nearestMob = null;
                let nearestDist = Infinity;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent) return;
                    const dist = player.position.distanceTo(mob.position);
                    if (dist < 25 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    autoExplore.state = 'combat';
                    autoExplore.combatTarget = nearestMob;

                    // Move toward mob if not in range
                    if (nearestDist > CONFIG.INTERACTION_RANGE) {
                        worldState.target = nearestMob.position.clone();
                        worldState.interactTarget = nearestMob;
                    } else {
                        // Attack!
                        worldState.target = null;
                        if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                            performAction(nearestMob);
                            worldState.lastActionTime = now;
                        }
                    }
                    return true;
                }
            }

            // Priority 2: Gather resources - only target actual harvestable resources
            let bestResource = null;
            let bestResourceDist = Infinity;

            // Check interactables for actual resources (trees, rocks, ores)
            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const name = obj.userData.name || '';
                // Only target actual resources, not decorations
                const isResource = name.includes('Tree') || name.includes('Rock') ||
                                   name.includes('Ore') || name.includes('Crystal') ||
                                   name.includes('Bush') || name.includes('Plant') ||
                                   name.includes('Mushroom') || name.includes('Herb');
                if (!isResource) return;

                const dist = player.position.distanceTo(obj.position);
                if (dist < 50 && dist < bestResourceDist) {
                    bestResourceDist = dist;
                    bestResource = obj;
                }
            });

            // Also check fishing spots
            if (!bestResource && worldState.fishingSpots) {
                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = player.position.distanceTo(spot.position);
                    if (dist < 50 && dist < bestResourceDist) {
                        bestResourceDist = dist;
                        bestResource = spot;
                    }
                });
            }

            if (bestResource) {
                autoExplore.state = 'gathering';
                autoExplore.currentTarget = null; // Clear random exploration target

                if (bestResourceDist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = bestResource.position.clone();
                    worldState.interactTarget = bestResource;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(bestResource);
                        worldState.lastActionTime = now;
                    }
                }
                return true;
            }

            // Priority 3: Explore - find new resources
            autoExplore.state = 'exploring';

            // Pick a new random target periodically or if stuck
            const stuckCheck = autoExplore.currentTarget &&
                player.position.distanceTo(autoExplore.currentTarget) === autoExplore.lastDistToTarget;

            if (stuckCheck) {
                autoExplore.stuckCounter = (autoExplore.stuckCounter || 0) + 1;
            } else {
                autoExplore.stuckCounter = 0;
            }
            autoExplore.lastDistToTarget = autoExplore.currentTarget ?
                player.position.distanceTo(autoExplore.currentTarget) : 0;

            // Pick new target if: no target, timeout, or stuck
            if (!autoExplore.currentTarget ||
                now - autoExplore.lastTargetTime > autoExplore.targetCooldown ||
                autoExplore.stuckCounter > 60) {

                // Try to find an unexplored area with resources
                let foundTarget = false;

                // Search for any resource in a wider area
                let anyResource = null;
                let anyResourceDist = Infinity;

                worldState.interactables.forEach(obj => {
                    if (!obj.parent) return;
                    const dist = player.position.distanceTo(obj.position);
                    if (dist > 10 && dist < anyResourceDist) { // Not too close, not too far
                        anyResourceDist = dist;
                        anyResource = obj;
                    }
                });

                if (anyResource && anyResourceDist < 100) {
                    autoExplore.currentTarget = anyResource.position.clone();
                    foundTarget = true;
                }

                // If no resources found, pick a random direction
                if (!foundTarget) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 20 + Math.random() * 20;
                    autoExplore.currentTarget = new THREE.Vector3(
                        player.position.x + Math.cos(angle) * distance,
                        0,
                        player.position.z + Math.sin(angle) * distance
                    );
                }

                // Clamp to world bounds
                autoExplore.currentTarget.x = Math.max(-45, Math.min(45, autoExplore.currentTarget.x));
                autoExplore.currentTarget.z = Math.max(-45, Math.min(45, autoExplore.currentTarget.z));
                autoExplore.lastTargetTime = now;
                autoExplore.stuckCounter = 0;
            }

            worldState.target = autoExplore.currentTarget;

            // Check if reached target
            if (autoExplore.currentTarget && player.position.distanceTo(autoExplore.currentTarget) < 3) {
                autoExplore.currentTarget = null;
            }

            return true;
        }

        // ============================================
        // v6.68: UNIFIED AI BEHAVIOR SYSTEM
        // Central controller for all autonomous behaviors
        // ============================================
        const AI_BEHAVIOR = {
            current: 'explorer',  // manual, explorer, pusher, miner, defender, builder, hunter, trader
            behaviors: {
                manual: {
                    name: 'Manual Control',
                    icon: '',
                    color: '#888888',
                    description: 'Full player control - no AI assistance'
                },
                explorer: {
                    name: 'Explorer',
                    icon: '',
                    color: '#00ff88',
                    description: 'Auto-gathering resources and fighting mobs'
                },
                pusher: {
                    name: 'Lane Pusher',
                    icon: '',
                    color: '#ff4444',
                    description: 'Aggressively pushing lanes and destroying towers'
                },
                miner: {
                    name: 'Miner',
                    icon: '',
                    color: '#ffaa00',
                    description: 'Focus on gathering ore, logs, and crystals'
                },
                defender: {
                    name: 'Defender',
                    icon: '',
                    color: '#4488ff',
                    description: 'Protect base, ship, and friendly creeps'
                },
                terraformer: {
                    name: 'Terraformer',
                    icon: '',
                    color: '#cd853f',  // v6.82: Improved contrast
                    description: 'Scan and smooth rough terrain for construction'
                },
                builder: {
                    name: 'Builder',
                    icon: '',
                    color: '#00bfff',
                    description: 'Build structures at construction sites with 100% efficiency'
                },
                hunter: {
                    name: 'Hunter',
                    icon: '',
                    color: '#ff0088',
                    description: 'Aggressive mob hunting for XP and gold'
                },
                trader: {
                    name: 'Trader',
                    icon: '',
                    color: '#ffd700',
                    description: 'Gather and sell for profit, exploit market events'
                }
            },
            stats: {
                resourcesGathered: 0,
                mobsKilled: 0,
                goldEarned: 0,
                structuresBuilt: 0,
                towersDestroyed: 0,
                damageBlocked: 0
            }
        };

        // Set AI behavior mode
        function setAIBehavior(behaviorId) {
            const oldBehavior = AI_BEHAVIOR.current;
            AI_BEHAVIOR.current = behaviorId;

            // Disable all specific AI systems first
            autoExplore.enabled = false;
            LANE_PUSH_AI.enabled = false;

            // Enable the appropriate system
            switch (behaviorId) {
                case 'manual':
                    showNotification(' MANUAL: Full control is yours!', 'info');
                    break;
                case 'explorer':
                    autoExplore.enabled = true;
                    showNotification(' EXPLORER: Auto-gathering and combat', 'info');
                    break;
                case 'pusher':
                    LANE_PUSH_AI.enabled = true;
                    LANE_PUSH_AI.state = 'idle';
                    LANE_PUSH_AI.currentLane = null;
                    showNotification(' PUSHER: Destroying enemy towers!', 'warning');
                    break;
                case 'miner':
                    // Miner uses its own AI, not explorer
                    showNotification(' MINER: Focusing on resource gathering', 'info');
                    break;
                case 'defender':
                    showNotification(' DEFENDER: Protecting base and allies', 'info');
                    break;
                case 'terraformer':
                    showNotification(' TERRAFORMER: Smoothing terrain for construction', 'info');
                    break;
                case 'builder':
                    showNotification(' BUILDER: Building at construction sites', 'info');
                    break;
                case 'hunter':
                    showNotification(' HUNTER: Hunting mobs aggressively', 'warning');
                    break;
                case 'trader':
                    showNotification(' TRADER: Maximizing profits', 'info');
                    break;
            }

            updateAIBehaviorUI();
            AudioSystem.buttonClick && AudioSystem.buttonClick();
        }

        // Update AI behavior UI
        function updateAIBehaviorUI() {
            const select = document.getElementById('ai-behavior-select');
            const status = document.getElementById('ai-behavior-status');
            const details = document.getElementById('ai-behavior-details');

            const behavior = AI_BEHAVIOR.behaviors[AI_BEHAVIOR.current];
            if (!behavior) return;

            if (select) select.value = AI_BEHAVIOR.current;

            if (status) {
                let statusText = `${behavior.icon} ${behavior.name.toUpperCase()}`;

                // Add state-specific info
                if (AI_BEHAVIOR.current === 'pusher' && LANE_PUSH_AI.currentLane) {
                    statusText += ` - ${LANE_PUSH_AI.currentLane.toUpperCase()}`;
                } else if (AI_BEHAVIOR.current === 'explorer' && autoExplore.state) {
                    statusText += ` - ${autoExplore.state.toUpperCase()}`;
                } else if (AI_BEHAVIOR.current === 'defender' && DEFENDER_AI.state) {
                    statusText += ` - ${DEFENDER_AI.state.toUpperCase()}`;
                } else if (AI_BEHAVIOR.current === 'miner' && MINER_AI.state) {
                    statusText += ` - ${MINER_AI.state.toUpperCase()}`;
                } else if (AI_BEHAVIOR.current === 'terraformer' && TERRAFORMER_AI.state) {
                    statusText += ` - ${TERRAFORMER_AI.state.toUpperCase()}`;
                } else if (AI_BEHAVIOR.current === 'builder' && BUILDER_AI.state) {
                    statusText += ` - ${BUILDER_AI.state.toUpperCase()}`;
                }

                status.textContent = statusText;
                status.style.color = behavior.color;
                status.style.background = `${behavior.color}22`;
            }

            if (details) {
                details.textContent = behavior.description;
            }
        }

        // ============================================
        // v6.68: MINER AI - Focus on resource gathering
        // ============================================
        const MINER_AI = {
            state: 'idle',  // idle, mining, returning, selling
            targetResource: null,
            preferredResources: ['rock', 'ore', 'crystal', 'tree'],  // Priority order
            gatherRange: 80,  // Search range for resources
            inventoryThreshold: 15,  // Return to sell when inventory this full
            lastDecisionTime: 0,
            decisionInterval: 300,
            stats: { oreGathered: 0, logsGathered: 0, crystalsGathered: 0 }
        };

        function runMinerAI(dt) {
            if (AI_BEHAVIOR.current !== 'miner' || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            if (now - MINER_AI.lastDecisionTime < MINER_AI.decisionInterval) return true;
            MINER_AI.lastDecisionTime = now;

            // Check inventory - if full, return to ship to sell
            if (gameData.inventory.length >= MINER_AI.inventoryThreshold) {
                MINER_AI.state = 'returning';

                // Head to ship
                if (SHIP_STATE.mesh) {
                    const distToShip = player.position.distanceTo(SHIP_STATE.mesh.position);
                    if (distToShip > 5) {
                        worldState.target = SHIP_STATE.mesh.position.clone();
                        return true;
                    } else {
                        // At ship - try to sell resources
                        MINER_AI.state = 'selling';
                        autoSellResources();
                        return true;
                    }
                }
            }

            // Priority: Find and mine resources
            MINER_AI.state = 'mining';
            let bestResource = null;
            let bestScore = -Infinity;

            worldState.interactables.forEach(obj => {
                if (!obj.parent || !obj.userData) return;

                const type = obj.userData.type;
                const name = (obj.userData.name || '').toLowerCase();

                // Score resources by priority
                let score = 0;
                if (type === 'rock' || name.includes('rock') || name.includes('ore')) {
                    score = 100;
                    MINER_AI.targetType = 'ore';
                } else if (name.includes('crystal')) {
                    score = 120;  // Crystals are valuable
                    MINER_AI.targetType = 'crystal';
                } else if (type === 'tree' || name.includes('tree')) {
                    score = 50;
                    MINER_AI.targetType = 'log';
                } else {
                    return;  // Not a mineable resource
                }

                const dist = player.position.distanceTo(obj.position);
                if (dist > MINER_AI.gatherRange) return;

                // Closer is better
                score -= dist * 0.5;

                if (score > bestScore) {
                    bestScore = score;
                    bestResource = obj;
                }
            });

            if (bestResource) {
                MINER_AI.targetResource = bestResource;
                const dist = player.position.distanceTo(bestResource.position);

                if (dist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = bestResource.position.clone();
                    worldState.interactTarget = bestResource;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(bestResource);
                        worldState.lastActionTime = now;
                        MINER_AI.stats[MINER_AI.targetType + 'Gathered'] = (MINER_AI.stats[MINER_AI.targetType + 'Gathered'] || 0) + 1;
                    }
                }
                return true;
            }

            // No resources nearby - explore to find more
            MINER_AI.state = 'exploring';
            if (!autoExplore.currentTarget || player.position.distanceTo(autoExplore.currentTarget) < 5) {
                autoExplore.currentTarget = new THREE.Vector3(
                    (Math.random() - 0.5) * 80,
                    player.position.y,
                    (Math.random() - 0.5) * 80
                );
            }
            worldState.target = autoExplore.currentTarget;

            return true;
        }

        // Auto-sell resources to best merchant
        function autoSellResources() {
            const resourcesToSell = ['Ore', 'Log', 'Crystal', 'Slime', 'Chitin'];
            let soldSomething = false;

            for (const resource of resourcesToSell) {
                const count = getItemCount(resource);
                if (count > 5) {  // Keep 5 of each
                    const sellCount = count - 5;
                    // Find best merchant for this resource
                    let bestMerchant = 'grimjaw';  // Default
                    let bestPrice = 0;

                    for (const [id, merchant] of Object.entries(MERCHANTS)) {
                        const price = getMerchantBuyPrice(id, resource);
                        if (price > bestPrice && merchant.gold >= price) {
                            bestPrice = price;
                            bestMerchant = id;
                        }
                    }

                    if (bestPrice > 0) {
                        sellToMerchant(bestMerchant, resource, sellCount);
                        soldSomething = true;
                    }
                }
            }

            if (soldSomething) {
                showNotification(' Auto-sold resources!', 'success');
            }
        }

        // ============================================
        // v6.68: DEFENDER AI - Protect base and allies
        // ============================================
        const DEFENDER_AI = {
            state: 'idle',  // idle, patrolling, engaging, retreating, healing
            defenseRadius: 40,  // Stay within this radius of ship
            lastDecisionTime: 0,
            decisionInterval: 250,
            targetEnemy: null,
            stats: { enemiesRepelled: 0, alliesHealed: 0, damageBlocked: 0 }
        };

        function runDefenderAI(dt) {
            if (AI_BEHAVIOR.current !== 'defender' || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            if (now - DEFENDER_AI.lastDecisionTime < DEFENDER_AI.decisionInterval) return true;
            DEFENDER_AI.lastDecisionTime = now;

            const shipPos = SHIP_STATE.mesh ? SHIP_STATE.mesh.position : new THREE.Vector3(0, 0, 0);
            const distToShip = player.position.distanceTo(shipPos);

            // Priority 1: Engage enemies near the base
            let nearestThreat = null;
            let nearestThreatDist = Infinity;

            // Check mobs
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;
                const distToBase = mob.position.distanceTo(shipPos);
                if (distToBase < DEFENDER_AI.defenseRadius) {
                    const distToPlayer = player.position.distanceTo(mob.position);
                    if (distToPlayer < nearestThreatDist) {
                        nearestThreatDist = distToPlayer;
                        nearestThreat = mob;
                    }
                }
            });

            // Check hostile creeps
            if (typeof creepWaveState !== 'undefined') {
                creepWaveState.creeps.forEach(creep => {
                    if (!creep.parent || creep.userData.team !== 'B') return;
                    const distToBase = creep.position.distanceTo(shipPos);
                    if (distToBase < DEFENDER_AI.defenseRadius) {
                        const distToPlayer = player.position.distanceTo(creep.position);
                        if (distToPlayer < nearestThreatDist) {
                            nearestThreatDist = distToPlayer;
                            nearestThreat = creep;
                        }
                    }
                });
            }

            if (nearestThreat) {
                DEFENDER_AI.state = 'engaging';
                DEFENDER_AI.targetEnemy = nearestThreat;

                if (nearestThreatDist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = nearestThreat.position.clone();
                    worldState.interactTarget = nearestThreat;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(nearestThreat);
                        worldState.lastActionTime = now;
                    }
                }
                return true;
            }

            // Priority 2: Stay near the ship if too far
            if (distToShip > DEFENDER_AI.defenseRadius) {
                DEFENDER_AI.state = 'returning';
                worldState.target = shipPos.clone();
                return true;
            }

            // Priority 3: Patrol around the base
            DEFENDER_AI.state = 'patrolling';

            // Circular patrol around ship
            const patrolAngle = (now / 5000) % (Math.PI * 2);
            const patrolRadius = DEFENDER_AI.defenseRadius * 0.6;
            const patrolTarget = new THREE.Vector3(
                shipPos.x + Math.cos(patrolAngle) * patrolRadius,
                player.position.y,
                shipPos.z + Math.sin(patrolAngle) * patrolRadius
            );

            worldState.target = patrolTarget;
            return true;
        }

        // ============================================
        // v6.82: TERRAFORMER AI - Smooth terrain like agents
        // Uses same logic as agent terraformers: scan, smooth, prepare sites
        // ============================================
        const TERRAFORMER_AI = {
            state: 'idle',  // idle, scanning, smoothing, moving
            targetSite: null,
            lastDecisionTime: 0,
            decisionInterval: 300,
            smoothRadius: 3,  // Larger radius for player (agents use 2)
            lastNotification: 0,  // v6.82: Throttle notifications
            notificationCooldown: 3000,  // Only show same notification every 3s
            stats: { sitesSmoothed: 0, beaconsPlaced: 0 }
        };

        // Calculate terrain roughness in an area (same algorithm as agents)
        function calculateTerrainRoughness(cx, cz, radius) {
            let heights = [];
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dz = -radius; dz <= radius; dz++) {
                    const tx = cx + dx, tz = cz + dz;
                    if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                        heights.push(worldState.terrain[tx][tz]);
                    }
                }
            }
            if (heights.length < 2) return 0;
            const avg = heights.reduce((a, b) => a + b, 0) / heights.length;
            const variance = heights.reduce((sum, h) => sum + Math.pow(h - avg, 2), 0) / heights.length;
            return Math.sqrt(variance);
        }

        // Smooth terrain at player position (same algorithm as agents)
        function smoothTerrainAtPosition(worldX, worldZ) {
            const tileX = Math.floor((worldX / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const tileZ = Math.floor((worldZ / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const smoothRadius = TERRAFORMER_AI.smoothRadius;

            let totalHeight = 0, count = 0;
            let heightMap = [];

            for (let dx = -smoothRadius; dx <= smoothRadius; dx++) {
                for (let dz = -smoothRadius; dz <= smoothRadius; dz++) {
                    const tx = tileX + dx, tz = tileZ + dz;
                    if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                        const h = worldState.terrain[tx][tz];
                        totalHeight += h;
                        count++;
                        heightMap.push({ tx, tz, h });
                    }
                }
            }

            if (count > 0) {
                const avgHeight = totalHeight / count;
                for (const cell of heightMap) {
                    // Smooth 80% toward average (same as agents)
                    worldState.terrain[cell.tx][cell.tz] = cell.h + (avgHeight - cell.h) * 0.8;
                }
                return true;
            }
            return false;
        }

        // Find rough terrain to smooth
        function findRoughTerrainNearby(player, searchRadius) {
            const playerTileX = Math.floor((player.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const playerTileZ = Math.floor((player.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

            let bestSite = null;
            let highestRoughness = 0.3; // Minimum threshold

            // Scan in a spiral pattern from player
            for (let dist = 5; dist < searchRadius; dist += 5) {
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                    const checkX = playerTileX + Math.floor(Math.cos(angle) * dist);
                    const checkZ = playerTileZ + Math.floor(Math.sin(angle) * dist);

                    const roughness = calculateTerrainRoughness(checkX, checkZ, 3);
                    if (roughness > highestRoughness) {
                        highestRoughness = roughness;
                        bestSite = {
                            tileX: checkX,
                            tileZ: checkZ,
                            worldX: (checkX - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE,
                            worldZ: (checkZ - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE,
                            roughness: roughness
                        };
                    }
                }
            }
            return bestSite;
        }

        function runTerraformerAI(dt) {
            if (AI_BEHAVIOR.current !== 'terraformer' || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            if (now - TERRAFORMER_AI.lastDecisionTime < TERRAFORMER_AI.decisionInterval) return true;
            TERRAFORMER_AI.lastDecisionTime = now;

            const playerTileX = Math.floor((player.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const playerTileZ = Math.floor((player.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

            // Check roughness at current position
            const currentRoughness = calculateTerrainRoughness(playerTileX, playerTileZ, TERRAFORMER_AI.smoothRadius);

            // Priority 1: Smooth rough terrain at current location
            if (currentRoughness > 0.2) {
                TERRAFORMER_AI.state = 'smoothing';
                if (smoothTerrainAtPosition(player.position.x, player.position.z)) {
                    TERRAFORMER_AI.stats.sitesSmoothed++;
                    // Throttle smoothing notifications
                    if (now - TERRAFORMER_AI.lastNotification > TERRAFORMER_AI.notificationCooldown) {
                        TERRAFORMER_AI.lastNotification = now;
                        showNotification(` Smoothed terrain (roughness: ${currentRoughness.toFixed(2)})`, 'info');
                    }

                    // Create visual effect
                    if (typeof spawnTerraformParticles === 'function') {
                        spawnTerraformParticles(player.position);
                    }

                    // Place construction beacon if terrain is now smooth enough
                    const newRoughness = calculateTerrainRoughness(playerTileX, playerTileZ, TERRAFORMER_AI.smoothRadius);
                    if (newRoughness < 0.15) {
                        // Initialize construction sites array if needed
                        if (!worldState.constructionSites) worldState.constructionSites = [];

                        // Check if a beacon already exists nearby
                        const nearbyBeacon = worldState.constructionSites.find(site =>
                            Math.abs(site.position.x - player.position.x) < 10 &&
                            Math.abs(site.position.z - player.position.z) < 10
                        );

                        if (!nearbyBeacon) {
                            worldState.constructionSites.push({
                                position: player.position.clone(),
                                createdAt: now,
                                claimed: false,
                                buildProgress: 0,
                                type: 'terraformed'
                            });
                            TERRAFORMER_AI.stats.beaconsPlaced++;
                            showNotification(' Construction beacon placed!', 'success');
                        }
                    }
                }
                return true;
            }

            // Priority 2: Find rough terrain nearby
            TERRAFORMER_AI.state = 'scanning';
            const roughSite = findRoughTerrainNearby(player, 50);

            if (roughSite) {
                TERRAFORMER_AI.targetSite = roughSite;
                TERRAFORMER_AI.state = 'moving';
                worldState.target = new THREE.Vector3(roughSite.worldX, 0, roughSite.worldZ);
                return true;
            }

            // Priority 3: Random exploration to find rough terrain
            TERRAFORMER_AI.state = 'exploring';
            const wanderAngle = Math.random() * Math.PI * 2;
            const wanderDist = 20 + Math.random() * 30;
            worldState.target = new THREE.Vector3(
                player.position.x + Math.cos(wanderAngle) * wanderDist,
                0,
                player.position.z + Math.sin(wanderAngle) * wanderDist
            );

            return true;
        }

        // ============================================
        // v6.82: BUILDER AI - Enhanced to match agent capabilities
        // Seeks construction beacons, builds with 100% efficiency
        // ============================================
        const BUILDER_AI = {
            state: 'idle',  // idle, seeking, building, repairing, gathering
            currentSite: null,
            lastDecisionTime: 0,
            decisionInterval: 400,
            buildRange: 5,
            lastNotification: 0,  // v6.82: Throttle notifications
            notificationCooldown: 3000,  // Only show same notification every 3s
            lastBuildNotify: 0,  // v6.82: Separate cooldown for building progress
            stats: { structuresBuilt: 0, repairsDone: 0, sitesCompleted: 0 }
        };

        function runBuilderAI(dt) {
            if (AI_BEHAVIOR.current !== 'builder' || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            if (now - BUILDER_AI.lastDecisionTime < BUILDER_AI.decisionInterval) return true;
            BUILDER_AI.lastDecisionTime = now;

            // Priority 1: Build at construction beacons (placed by terraformer)
            if (worldState.constructionSites && worldState.constructionSites.length > 0) {
                // Find unclaimed or self-claimed sites
                const availableSites = worldState.constructionSites.filter(site =>
                    !site.claimed || site.claimed === 'player'
                );

                if (availableSites.length > 0) {
                    // Sort by distance
                    availableSites.sort((a, b) => {
                        const distA = player.position.distanceTo(a.position);
                        const distB = player.position.distanceTo(b.position);
                        return distA - distB;
                    });

                    const targetSite = availableSites[0];
                    const distToSite = player.position.distanceTo(targetSite.position);

                    if (distToSite <= BUILDER_AI.buildRange) {
                        // At site - BUILD!
                        BUILDER_AI.state = 'building';
                        targetSite.claimed = 'player';

                        if (!targetSite.buildProgress) targetSite.buildProgress = 0;
                        targetSite.buildProgress += 15; // Faster building than agents

                        if (targetSite.buildProgress >= 100) {
                            // Construction complete!
                            BUILDER_AI.stats.sitesCompleted++;
                            showNotification(' Construction complete! 100% efficiency!', 'success');

                            // Create actual structure at site
                            if (typeof queueConstruction === 'function') {
                                const structures = ['turret', 'wall', 'barracks'];
                                const structureType = structures[Math.floor(Math.random() * structures.length)];
                                queueConstruction(structureType, targetSite.position);
                                BUILDER_AI.stats.structuresBuilt++;
                            }

                            // Remove beacon
                            worldState.constructionSites = worldState.constructionSites.filter(s => s !== targetSite);
                        } else {
                            // Throttle build progress notifications (every 25%)
                            if (now - BUILDER_AI.lastBuildNotify > 2000 || targetSite.buildProgress % 25 < 15) {
                                BUILDER_AI.lastBuildNotify = now;
                            }
                        }
                        return true;
                    } else {
                        // Move to site
                        BUILDER_AI.state = 'seeking';
                        BUILDER_AI.currentSite = targetSite;
                        worldState.target = targetSite.position.clone();
                        return true;
                    }
                }
            }

            // Priority 2: Check for damaged structures to repair
            if (typeof baseBuildingState !== 'undefined' && baseBuildingState.buildings) {
                for (const building of baseBuildingState.buildings) {
                    if (building.hp < building.maxHp * 0.5) {
                        BUILDER_AI.state = 'repairing';
                        const dist = player.position.distanceTo(building.mesh.position);
                        if (dist > BUILDER_AI.buildRange) {
                            worldState.target = building.mesh.position.clone();
                        } else {
                            if (typeof repairBuilding === 'function') {
                                repairBuilding(building);
                                BUILDER_AI.stats.repairsDone++;
                                // Throttle repair notifications
                                if (now - BUILDER_AI.lastNotification > BUILDER_AI.notificationCooldown) {
                                    BUILDER_AI.lastNotification = now;
                                    showNotification(' Repairing structure...', 'info');
                                }
                            }
                        }
                        return true;
                    }
                }
            }

            // Priority 3: If no beacons exist, gather resources
            // (Encourages using terraformer first to prepare sites)
            BUILDER_AI.state = 'gathering';
            // Throttle gathering notification
            if (now - BUILDER_AI.lastNotification > BUILDER_AI.notificationCooldown * 2) {
                BUILDER_AI.lastNotification = now;
                showNotification(' Searching for construction sites...', 'info');
            }
            return runMinerAI(dt);
        }

        // ============================================
        // v6.68: HUNTER AI - Aggressive mob hunting
        // ============================================
        const HUNTER_AI = {
            state: 'idle',  // idle, hunting, engaging, retreating
            targetMob: null,
            huntRange: 100,  // Search far for targets
            lastDecisionTime: 0,
            decisionInterval: 200,  // Fast decisions for combat
            retreatThreshold: 0.2,  // Retreat at 20% HP
            stats: { mobsHunted: 0, elitesKilled: 0, bossesKilled: 0 }
        };

        function runHunterAI(dt) {
            if (AI_BEHAVIOR.current !== 'hunter' || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            if (now - HUNTER_AI.lastDecisionTime < HUNTER_AI.decisionInterval) return true;
            HUNTER_AI.lastDecisionTime = now;

            const playerHpPercent = gameData.player.hp / gameData.player.maxHp;

            // Retreat if low HP
            if (playerHpPercent < HUNTER_AI.retreatThreshold) {
                HUNTER_AI.state = 'retreating';
                if (SHIP_STATE.mesh) {
                    worldState.target = SHIP_STATE.mesh.position.clone();
                }
                return true;
            }

            // Use abilities aggressively
            useHunterAbilities(now);

            // Find best target - prioritize elites and bosses
            let bestTarget = null;
            let bestScore = -Infinity;

            worldState.mobs.forEach(mob => {
                if (!mob.parent || !mob.userData || mob.userData.hp <= 0) return;

                let score = 100;

                // Prioritize elites and bosses
                if (mob.userData.isBoss) score += 500;
                else if (mob.userData.isElite) score += 200;

                // Higher XP rewards are better
                score += (mob.userData.xpReward || 50) * 0.5;

                // Closer is better (but not too much weight)
                const dist = player.position.distanceTo(mob.position);
                if (dist > HUNTER_AI.huntRange) return;
                score -= dist * 0.3;

                // Lower HP targets are easier
                const hpPercent = mob.userData.hp / mob.userData.maxHp;
                score += (1 - hpPercent) * 50;

                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = mob;
                }
            });

            if (bestTarget) {
                HUNTER_AI.state = 'engaging';
                HUNTER_AI.targetMob = bestTarget;

                const dist = player.position.distanceTo(bestTarget.position);

                if (dist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = bestTarget.position.clone();
                    worldState.interactTarget = bestTarget;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN * 0.8) {  // Attack faster
                        performAction(bestTarget);
                        worldState.lastActionTime = now;
                    }
                }
                return true;
            }

            // No mobs - search for more
            HUNTER_AI.state = 'hunting';

            if (!autoExplore.currentTarget || player.position.distanceTo(autoExplore.currentTarget) < 5) {
                // Move to unexplored areas
                autoExplore.currentTarget = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    player.position.y,
                    (Math.random() - 0.5) * 100
                );
            }
            worldState.target = autoExplore.currentTarget;

            return true;
        }

        function useHunterAbilities(now) {
            // Aggressively use combat abilities
            const abilities = ['slash', 'whirlwind', 'dash', 'warcry'];

            for (const abilityKey of abilities) {
                if (abilityState[abilityKey]) {
                    const ability = ABILITIES[abilityKey];
                    const lastUsed = abilityState[abilityKey].lastUsed || 0;
                    const cooldown = ability?.cooldown || 5000;

                    if (now - lastUsed > cooldown) {
                        // Check if there's a target nearby for offensive abilities
                        if (HUNTER_AI.targetMob && worldState.player.position.distanceTo(HUNTER_AI.targetMob.position) < 10) {
                            if (typeof useAbility === 'function') {
                                useAbility(abilityKey);
                            }
                            break;  // One ability per tick
                        }
                    }
                }
            }
        }

        // ============================================
        // v6.68: TRADER AI - Maximize profits
        // ============================================
        const TRADER_AI = {
            state: 'idle',  // idle, gathering, selling, waiting
            targetItem: null,
            lastDecisionTime: 0,
            decisionInterval: 1000,
            profitThreshold: 50,  // Min profit to trigger trade
            stats: { totalProfit: 0, tradesCompleted: 0 }
        };

        function runTraderAI(dt) {
            if (AI_BEHAVIOR.current !== 'trader' || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            if (now - TRADER_AI.lastDecisionTime < TRADER_AI.decisionInterval) return true;
            TRADER_AI.lastDecisionTime = now;

            // Check for profitable market events
            if (ECONOMY.activeEvents.length > 0) {
                for (const event of ECONOMY.activeEvents) {
                    const eventData = MARKET_EVENTS[event.type];

                    // Find items affected by this event
                    for (const [item, effect] of Object.entries(eventData.effects)) {
                        if (item === 'ALL') continue;

                        // If prices are HIGH - sell what we have
                        if (effect > 0.3) {
                            const count = getItemCount(item);
                            if (count > 0) {
                                TRADER_AI.state = 'selling';
                                // Find best merchant
                                let bestMerchant = null;
                                let bestPrice = 0;
                                for (const [id, merchant] of Object.entries(MERCHANTS)) {
                                    const price = getMerchantBuyPrice(id, item);
                                    if (price > bestPrice && merchant.gold >= price) {
                                        bestPrice = price;
                                        bestMerchant = id;
                                    }
                                }
                                if (bestMerchant) {
                                    sellToMerchant(bestMerchant, item, count);
                                    TRADER_AI.stats.tradesCompleted++;
                                    showNotification(` Sold ${count}x ${item} during ${eventData.name}!`, 'success');
                                }
                            }
                        }

                        // If prices are LOW - gather that item
                        if (effect < -0.2) {
                            TRADER_AI.targetItem = item;
                            TRADER_AI.state = 'gathering';
                        }
                    }
                }
            }

            // Default: gather valuable resources
            if (TRADER_AI.state !== 'selling') {
                TRADER_AI.state = 'gathering';
                return runMinerAI(dt);
            }

            return true;
        }

        // Master AI update function - routes to correct behavior
        function updateAIBehavior(dt) {
            if (mode !== 'world') return false;

            switch (AI_BEHAVIOR.current) {
                case 'manual':
                    return false;
                case 'explorer':
                    return runAutoExplore(dt);
                case 'pusher':
                    return runLanePushAI(dt);
                case 'miner':
                    return runMinerAI(dt);
                case 'defender':
                    return runDefenderAI(dt);
                case 'terraformer':
                    return runTerraformerAI(dt);
                case 'builder':
                    return runBuilderAI(dt);
                case 'hunter':
                    return runHunterAI(dt);
                case 'trader':
                    return runTraderAI(dt);
                default:
                    return false;
            }
        }

        // ============================================
        // v6.68: AUTONOMOUS LANE PUSH AI SYSTEM
        // Actively pushes lanes, uses abilities, takes towers
        // ============================================
        const LANE_PUSH_AI = {
            enabled: false,
            state: 'idle',  // idle, pushing, fighting, retreating, sieging
            currentLane: null,  // 'top', 'mid', 'bot'
            targetTower: null,
            lastSiegedTier: null,  // Track which tower tier for announcements (T1, T2, T3)
            lastDecisionTime: 0,
            decisionInterval: 500,  // Decide every 500ms
            lastAbilityTime: 0,
            abilityInterval: 300,  // Check abilities every 300ms
            retreatThreshold: 0.25,  // Retreat at 25% HP
            aggressiveThreshold: 0.6,  // Be aggressive above 60% HP
            waveFollowDistance: 8,  // Stay this close to friendly wave
            towerSiegeRange: 15,  // Attack tower from this range
            stats: {
                creepsKilled: 0,
                towersDestroyed: 0,
                abilitiesUsed: 0,
                pushTime: 0
            }
        };

        function toggleLanePushAI() {
            LANE_PUSH_AI.enabled = !LANE_PUSH_AI.enabled;
            if (LANE_PUSH_AI.enabled) {
                LANE_PUSH_AI.state = 'idle';
                LANE_PUSH_AI.currentLane = null;
                autoExplore.enabled = false;  // Disable regular autopilot
                updateAutoExploreUI();
                showNotification(' AUTONOMOUS++ ENGAGED - Strategic lane domination!', 'success');
                addCopilotMessage(' AUTONOMOUS++ activated! I will strategically push lanes, use abilities to clear waves, and siege towers in order (T1T2T3). Watch the AI dominate!', 'ai');
            } else {
                LANE_PUSH_AI.state = 'idle';
                showNotification(' AUTONOMOUS++ DISENGAGED', 'info');
            }
            updateLanePushUI();
        }

        function updateLanePushUI() {
            const btn = document.getElementById('lane-push-btn');
            const indicator = document.getElementById('auto-explore-indicator');
            if (btn) {
                btn.textContent = LANE_PUSH_AI.enabled ? ' AUTONOMOUS++ OFF' : ' Autonomous++';
                btn.style.background = LANE_PUSH_AI.enabled ? '#ff4444' : '#4488ff';
            }
            if (indicator && LANE_PUSH_AI.enabled) {
                const laneName = LANE_PUSH_AI.currentLane?.toUpperCase() || 'LANE';
                const state = LANE_PUSH_AI.state;
                let statusText = ` A++ ${laneName}`;

                // Show strategic state info
                if (state === 'sieging' && LANE_PUSH_AI.lastSiegedTier) {
                    statusText = ` SIEGE ${laneName} ${LANE_PUSH_AI.lastSiegedTier}`;
                    indicator.style.color = '#ff4400';
                } else if (state === 'fighting') {
                    statusText = ` FIGHTING ${laneName}`;
                    indicator.style.color = '#ff8800';
                } else if (state === 'retreating') {
                    statusText = ` RETREATING`;
                    indicator.style.color = '#ff0000';
                } else {
                    statusText = ` PUSHING ${laneName}`;
                    indicator.style.color = '#00ff88';
                }

                indicator.textContent = statusText;
            }
        }

        // Main AI update function
        function runLanePushAI(dt) {
            if (!LANE_PUSH_AI.enabled || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();
            const playerHpPercent = gameData.player.hp / gameData.player.maxHp;

            // Track push time
            LANE_PUSH_AI.stats.pushTime += dt;

            // === ABILITY AI: Use abilities to clear waves ===
            if (now - LANE_PUSH_AI.lastAbilityTime > LANE_PUSH_AI.abilityInterval) {
                LANE_PUSH_AI.lastAbilityTime = now;
                runAbilityAI(player, playerHpPercent);
            }

            // === DECISION AI: Runs less frequently ===
            if (now - LANE_PUSH_AI.lastDecisionTime < LANE_PUSH_AI.decisionInterval) {
                return true;
            }
            LANE_PUSH_AI.lastDecisionTime = now;

            // === RETREAT CHECK ===
            if (playerHpPercent < LANE_PUSH_AI.retreatThreshold) {
                LANE_PUSH_AI.state = 'retreating';
                retreatToShip(player);
                return true;
            }

            // === CHOOSE LANE if none selected ===
            if (!LANE_PUSH_AI.currentLane) {
                LANE_PUSH_AI.currentLane = chooseBestLane();
                LANE_PUSH_AI.state = 'pushing';
                updateLanePushUI();
            }

            // === GET LANE DATA ===
            const laneData = getLanePushData(LANE_PUSH_AI.currentLane);

            // === STATE MACHINE ===
            switch (LANE_PUSH_AI.state) {
                case 'pushing':
                    executePushState(player, laneData, playerHpPercent);
                    break;
                case 'fighting':
                    executeFightState(player, laneData);
                    break;
                case 'sieging':
                    executeSiegeState(player, laneData);
                    break;
                case 'retreating':
                    if (playerHpPercent > LANE_PUSH_AI.aggressiveThreshold) {
                        LANE_PUSH_AI.state = 'pushing';
                    } else {
                        retreatToShip(player);
                    }
                    break;
            }

            return true;
        }

        // Choose the best lane to push
        function chooseBestLane() {
            const lanes = ['top', 'mid', 'bot'];
            let bestLane = 'mid';
            let bestScore = -Infinity;

            lanes.forEach(laneKey => {
                const data = getLanePushData(laneKey);
                // Score based on: friendly creep advantage, fewer enemy towers, closer to enemy base
                let score = 0;
                score += (data.friendlyCreeps - data.enemyCreeps) * 10;
                score -= data.enemyTowers * 50;
                score += data.friendlyTowers * 30;
                score += (50 - data.distanceToEnemyBase) * 2;

                if (score > bestScore) {
                    bestScore = score;
                    bestLane = laneKey;
                }
            });

            return bestLane;
        }

        // Get lane-specific data for AI decisions
        // v6.68: Strategic tower targeting - must destroy T1 before T2, T2 before T3
        function getLanePushData(laneKey) {
            const data = {
                friendlyCreeps: 0,
                enemyCreeps: 0,
                friendlyTowers: 0,
                enemyTowers: 0,
                nearestEnemyCreep: null,
                nearestEnemyTower: null,      // The FRONTMOST tower we should attack
                nextEnemyTower: null,         // The tower after the frontmost
                nearestFriendlyCreep: null,
                frontlinePosition: null,
                distanceToEnemyBase: 100,
                // v6.68: Tower tier tracking
                enemyTowerTiers: [],          // All enemy towers sorted by tier
                currentTowerTier: 0,          // Which tier we're attacking (1, 2, or 3)
                towersDestroyed: 0            // How many enemy towers destroyed in this lane
            };

            if (!creepWaveState.creeps) return data;

            // Count creeps in this lane
            creepWaveState.creeps.forEach(creep => {
                if (!creep || !creep.userData || creep.userData.laneKey !== laneKey) return;
                if (creep.userData.team === 'A') {
                    data.friendlyCreeps++;
                    if (!data.nearestFriendlyCreep ||
                        (worldState.player && creep.position.distanceTo(worldState.player.position) <
                         data.nearestFriendlyCreep.position.distanceTo(worldState.player.position))) {
                        data.nearestFriendlyCreep = creep;
                    }
                } else {
                    data.enemyCreeps++;
                    if (!data.nearestEnemyCreep ||
                        (worldState.player && creep.position.distanceTo(worldState.player.position) <
                         data.nearestEnemyCreep.position.distanceTo(worldState.player.position))) {
                        data.nearestEnemyCreep = creep;
                    }
                }
            });

            // v6.68: Strategic tower analysis - find towers in correct attack order
            // For hostile towers: segment 3 = T1 (frontline), segment 4 = T2, segment 5 = T3 (base)
            // We MUST destroy T1 before we can attack T2, etc.
            if (laneSupportState.laneTowers) {
                const enemyTowersInLane = [];
                const friendlyTowersInLane = [];

                laneSupportState.laneTowers.forEach(tower => {
                    if (!tower || !tower.active || tower.laneKey !== laneKey) return;
                    if (tower.team === 'robot') {
                        data.friendlyTowers++;
                        friendlyTowersInLane.push(tower);
                    } else {
                        data.enemyTowers++;
                        enemyTowersInLane.push(tower);
                    }
                });

                // Sort enemy towers by segment (lowest segment = frontmost = attack first)
                // Hostile towers are at segments 3, 4, 5 - so segment 3 is T1
                enemyTowersInLane.sort((a, b) => a.segment - b.segment);
                data.enemyTowerTiers = enemyTowersInLane;

                // The frontmost tower is the one we should attack (lowest segment)
                if (enemyTowersInLane.length > 0) {
                    data.nearestEnemyTower = enemyTowersInLane[0];  // T1 or next available
                    data.currentTowerTier = 4 - enemyTowersInLane[0].segment;  // segment 3=T1, 4=T2, 5=T3

                    if (enemyTowersInLane.length > 1) {
                        data.nextEnemyTower = enemyTowersInLane[1];  // Preview next target
                    }
                }

                // Track how many towers we've destroyed (3 - remaining)
                data.towersDestroyed = 3 - enemyTowersInLane.length;
            }

            // Calculate frontline (average position of friendly creeps)
            if (data.nearestFriendlyCreep) {
                data.frontlinePosition = data.nearestFriendlyCreep.position.clone();
            }

            // Calculate distance to enemy base based on remaining towers
            if (data.nearestEnemyTower) {
                data.distanceToEnemyBase = data.nearestEnemyTower.segment * 15;  // Rough estimate
            } else {
                data.distanceToEnemyBase = 10;  // No towers left, close to base!
            }

            return data;
        }

        // Execute PUSH state - follow friendly wave
        function executePushState(player, laneData, playerHpPercent) {
            // If enemies nearby, switch to fighting
            if (laneData.nearestEnemyCreep) {
                const distToEnemy = player.position.distanceTo(laneData.nearestEnemyCreep.position);
                if (distToEnemy < 12) {
                    LANE_PUSH_AI.state = 'fighting';
                    return;
                }
            }

            // If no enemy towers left and we have advantage, we could siege base
            if (laneData.enemyTowers === 0 && laneData.friendlyCreeps > 0) {
                // Push toward enemy base area
                const enemyBasePos = new THREE.Vector3(0, 0, 45);  // Enemy base is at positive Z
                worldState.target = enemyBasePos;
                return;
            }

            // If enemy tower in range and we have creeps for cover, siege it
            // Strategic: Always target the frontmost tower (T1  T2  T3)
            if (laneData.nearestEnemyTower && laneData.friendlyCreeps >= 2) {
                const distToTower = player.position.distanceTo(laneData.nearestEnemyTower.position);
                if (distToTower < 25) {
                    LANE_PUSH_AI.targetTower = laneData.nearestEnemyTower;
                    LANE_PUSH_AI.lastSiegedTier = `T${laneData.currentTowerTier || 1}`;
                    LANE_PUSH_AI.state = 'sieging';
                    const tierName = LANE_PUSH_AI.lastSiegedTier;
                    const laneName = LANE_PUSH_AI.currentLane?.toUpperCase() || 'LANE';
                    showNotification(` SIEGING ${laneName} ${tierName} TOWER`, 'warning');
                    return;
                }
            }

            // Follow friendly creeps / frontline
            if (laneData.frontlinePosition) {
                const distToFront = player.position.distanceTo(laneData.frontlinePosition);
                if (distToFront > LANE_PUSH_AI.waveFollowDistance) {
                    worldState.target = laneData.frontlinePosition.clone();
                } else {
                    // Stay with wave, move forward slightly
                    const pushDir = new THREE.Vector3(0, 0, 1);  // Push toward enemy base
                    worldState.target = player.position.clone().add(pushDir.multiplyScalar(5));
                }
            } else {
                // No creeps, move to lane
                const lanePositions = {
                    top: new THREE.Vector3(-30, 0, 0),
                    mid: new THREE.Vector3(0, 0, 0),
                    bot: new THREE.Vector3(30, 0, 0)
                };
                worldState.target = lanePositions[LANE_PUSH_AI.currentLane];
            }
        }

        // Execute FIGHT state - attack enemy creeps
        function executeFightState(player, laneData) {
            if (!laneData.nearestEnemyCreep) {
                LANE_PUSH_AI.state = 'pushing';
                return;
            }

            const enemy = laneData.nearestEnemyCreep;
            const distToEnemy = player.position.distanceTo(enemy.position);

            if (distToEnemy > CONFIG.INTERACTION_RANGE) {
                // Move toward enemy
                worldState.target = enemy.position.clone();
                worldState.interactTarget = enemy;
            } else {
                // Attack!
                worldState.target = null;
                const now = performance.now();
                if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                    performAction(enemy);
                    worldState.lastActionTime = now;
                    LANE_PUSH_AI.stats.creepsKilled++;
                }
            }

            // Check if enemy wave cleared
            if (laneData.enemyCreeps === 0) {
                LANE_PUSH_AI.state = 'pushing';
            }
        }

        // Execute SIEGE state - attack enemy tower (strategic: T1  T2  T3)
        function executeSiegeState(player, laneData) {
            const tower = LANE_PUSH_AI.targetTower;
            if (!tower || !tower.active) {
                // Tower destroyed! Announce it
                const tierName = LANE_PUSH_AI.lastSiegedTier || 'T1';
                const laneName = LANE_PUSH_AI.currentLane?.toUpperCase() || 'LANE';
                showNotification(` ${laneName} ${tierName} TOWER DESTROYED!`, 'success');
                addCopilotMessage(` AUTONOMOUS++: Enemy ${tierName} tower in ${laneName} lane destroyed! ${laneData.enemyTowers > 0 ? 'Moving to next tower.' : 'All towers down - pushing to base!'}`, 'ai');

                LANE_PUSH_AI.targetTower = null;
                LANE_PUSH_AI.state = 'pushing';
                LANE_PUSH_AI.stats.towersDestroyed++;
                return;
            }

            // Track which tier we're sieging for announcements
            LANE_PUSH_AI.lastSiegedTier = `T${laneData.currentTowerTier || 1}`;

            const distToTower = player.position.distanceTo(tower.position);

            // Keep distance from tower (let creeps tank)
            const idealRange = LANE_PUSH_AI.towerSiegeRange;
            if (distToTower > idealRange + 2) {
                // Move closer
                const dir = tower.position.clone().sub(player.position).normalize();
                worldState.target = player.position.clone().add(dir.multiplyScalar(5));
            } else if (distToTower < idealRange - 2) {
                // Move back a bit
                const dir = player.position.clone().sub(tower.position).normalize();
                worldState.target = player.position.clone().add(dir.multiplyScalar(3));
            } else {
                // In range - attack tower
                worldState.target = null;
                worldState.interactTarget = tower.mesh;
                const now = performance.now();
                if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                    performAction(tower.mesh);
                    worldState.lastActionTime = now;
                }
            }

            // If no friendly creeps, retreat (tower will kill us)
            if (laneData.friendlyCreeps === 0) {
                LANE_PUSH_AI.state = 'retreating';
            }
        }

        // Retreat to ship for healing
        function retreatToShip(player) {
            if (!SHIP_STATE.mesh) return;
            const shipPos = SHIP_STATE.mesh.position;
            const distToShip = player.position.distanceTo(shipPos);

            if (distToShip > SHIP_STATE.healing.range - 5) {
                worldState.target = shipPos.clone();
            } else {
                // At ship, just wait for healing
                worldState.target = null;
            }
        }

        // AI for using abilities efficiently
        function runAbilityAI(player, playerHpPercent) {
            const now = performance.now();

            // Count nearby enemies (creeps + mobs)
            let nearbyEnemies = 0;
            let nearestEnemy = null;
            let nearestDist = Infinity;

            // Check hostile creeps
            if (creepWaveState.creeps) {
                creepWaveState.creeps.forEach(creep => {
                    if (!creep || !creep.userData || creep.userData.team !== 'B') return;
                    const dist = player.position.distanceTo(creep.position);
                    if (dist < 10) {
                        nearbyEnemies++;
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = creep;
                        }
                    }
                });
            }

            // Check mobs
            worldState.mobs.forEach(mob => {
                if (!mob.parent || mob.userData.hp <= 0) return;
                const dist = player.position.distanceTo(mob.position);
                if (dist < 10) {
                    nearbyEnemies++;
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = mob;
                    }
                }
            });

            // === ABILITY PRIORITY LOGIC ===

            // 1. HEAL if low HP
            if (playerHpPercent < 0.5 && isAbilityUnlocked('heal') && isAbilityReady('heal')) {
                useAbility('heal');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 2. SHIELD WALL if taking damage and low HP
            if (playerHpPercent < 0.4 && nearbyEnemies > 0 && isAbilityUnlocked('shieldWall') && isAbilityReady('shieldWall')) {
                useAbility('shieldWall');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 3. BERSERK (ultimate) for big wave or tower siege
            if (nearbyEnemies >= 4 && isAbilityUnlocked('berserk') && isAbilityReady('berserk')) {
                useAbility('berserk');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 4. WHIRLWIND for wave clear (3+ enemies)
            if (nearbyEnemies >= 3 && isAbilityUnlocked('whirlwind') && isAbilityReady('whirlwind')) {
                useAbility('whirlwind');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 5. WAR CRY for damage boost when fighting
            if (nearbyEnemies >= 2 && isAbilityUnlocked('warcry') && isAbilityReady('warcry')) {
                useAbility('warcry');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 6. EXECUTE on low HP targets
            if (nearestEnemy && nearestEnemy.userData.hp / nearestEnemy.userData.maxHp < 0.3) {
                if (isAbilityUnlocked('execute') && isAbilityReady('execute')) {
                    useAbility('execute');
                    LANE_PUSH_AI.stats.abilitiesUsed++;
                    return;
                }
            }

            // 7. POWER STRIKE for single target burst
            if (nearestEnemy && nearestDist < 5 && isAbilityUnlocked('powerStrike') && isAbilityReady('powerStrike')) {
                useAbility('powerStrike');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 8. DASH through enemy wave for damage + reposition
            if (nearbyEnemies >= 2 && isAbilityUnlocked('dash') && isAbilityReady('dash')) {
                // Face toward enemies first
                if (nearestEnemy) {
                    const dir = nearestEnemy.position.clone().sub(player.position).normalize();
                    player.rotation.y = Math.atan2(dir.x, dir.z);
                }
                useAbility('dash');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }

            // 9. CHRONO-ECHO for sustained damage in big fights
            if (nearbyEnemies >= 3 && isAbilityUnlocked('chronoEcho') && isAbilityReady('chronoEcho')) {
                useAbility('chronoEcho');
                LANE_PUSH_AI.stats.abilitiesUsed++;
                return;
            }
        }

        // ============================================
        // END LANE PUSH AI SYSTEM
        // ============================================

        // WASD Keyboard controls
        const keys = { w: false, a: false, s: false, d: false };

        // Persistent Game Data (saved to localStorage)
        let gameData = {
            version: VERSION,
            playtime: 0,
            totalCycles: 0, // v6.92: Persistent cycle counter
            lastPlayed: null,
            hasSeenTutorial: false, // v4.0: Tutorial tracking
            inventory: [],
            droppedItems: {},  // v6.34: Dropped items by planet ID { planetId: [{x, y, z, items: [...]}] }
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 },
                fishing: { level: 1, xp: 0 },
                cooking: { level: 1, xp: 0 },
                crafting: { level: 1, xp: 0 },
                alchemy: { level: 1, xp: 0 }  // v6.1: New Alchemy skill
            },
            player: {
                hp: CONFIG.PLAYER_MAX_HP,
                maxHp: CONFIG.PLAYER_MAX_HP,
                // v6.18: Persistent world state
                lastPlanetId: null,      // Which planet they were on
                lastPosition: null,       // {x, y, z} position on that planet
                lastRotation: null        // Y rotation (facing direction)
            },
            visitedPlanets: [],
            // v6.92: Persistent planet destruction/escape tracking
            destroyedPlanets: [],  // IDs of planets destroyed by collision
            escapedPlanets: [],    // IDs of planets that escaped orbit
            // v6.95: Player identity for universe ignition tracking
            playerName: 'Pioneer ' + Math.floor(Math.random() * 9000 + 1000),
            // v6.86: Galaxy Discovery System - track which galaxy generation we're on
            galaxyNumber: 1,       // Current galaxy number (starts at 1)
            galaxySeed: 'OMNIVERSE', // Current galaxy seed for unique generation
            galaxiesDiscovered: 1, // Total galaxies discovered (for stats)
            galaxyHistory: [],     // Array of previously discovered galaxies with their states
            // v6.95: First universe ignition - recorded when OMNIVERSE is first generated
            firstIgnition: null,   // { ignitedBy, ignitedAt, ignitionSignature }
            statistics: {
                treesChopped: 0,
                oresMined: 0,
                mobsKilled: 0,
                fishCaught: 0,
                itemsCrafted: 0,
                fishCooked: 0,
                // v4.2: New stats
                poisDiscovered: 0,
                totalDamageDealt: 0,
                bossesDefeated: 0,
                distanceTraveled: 0
            },
            // v4.2: Player rank tracking
            playerRank: { points: 0, lastTitle: 'Novice Explorer' },
            // v4.2: Discovered POIs by planet
            discoveredPOIs: {},
            // v4.1: Achievement System
            achievements: {},
            // v4.1: Daily Challenge System
            dailyChallenge: {
                lastGenerated: null,
                completed: false,
                current: null,
                streak: 0,
                bestStreak: 0
            },
            // v4.4: Prestige System
            prestige: {
                level: 0,
                totalLifetimePoints: 0,
                bonuses: {
                    xpMultiplier: 1.0,
                    startingSkillBonus: 0
                }
            },
            // v4.4: Fog of War exploration tracking per planet
            exploredTiles: {},
            // v4.6: Settings
            settings: {
                masterVolume: 30,
                sfxEnabled: true,
                ambientEnabled: true,
                particleQuality: 'high',
                shadowsEnabled: true,
                screenShakeEnabled: true,
                hintsEnabled: true
            },
            // v5.1: Equipment slots
            equipment: {
                weapon: null,
                armor: null,
                accessory: null,
                tool: null
            },
            // v5.1: Item enchantments
            enchantments: {},
            // v5.2: Talent tree points
            talents: {},
            // v6.35: Chronicle Engine - AI-generated narrative history
            chronicle: {
                entries: [],           // Generated chronicle entries [{id, timestamp, title, content, eventType, metadata}]
                eventBuffer: [],       // Pending events to weave into chronicle
                settings: {
                    autoGenerate: true,     // Auto-generate after significant events
                    narrativeStyle: 'epic', // epic, documentary, poetic
                    eventThreshold: 3       // Events needed to trigger generation
                },
                stats: {
                    totalEntries: 0,
                    lastGenerated: null
                }
            },
            // v6.65: Companion Permadeath System
            companion: {
                name: 'ECHO',           // Current companion name
                hp: 100,                // Current health
                maxHp: 100,             // Maximum health
                bond: 0,                // Bond level (0-100, affects sacrifice power)
                generation: 1,          // Which companion incarnation this is
                birthTime: null,        // When this companion was "born"
                personality: [],        // Personality traits inherited or new
                isGlitching: false,     // Currently experiencing memory glitch
                lastGlitchTime: 0       // When last glitch occurred
            },
            fallenCompanions: [],       // Memorial of dead companions [{name, generation, deathTime, bond, finalWords, memories, sacrificeType}]
            // v6.85: MEMENTO MORI PROTOCOL - Death Archive System
            deathArchive: {
                totalDeaths: 0,                    // Lifetime death count
                deaths: [],                        // Detailed death records [{timestamp, cause, location, killerType, survivalDuration, position, sessionDeaths}]
                sessionStartTime: null,            // When this play session started
                sessionDeaths: 0,                  // Deaths this session
                archivistSpawned: false,           // Has the Archivist been spawned
                archivistEnabled: false,           // Is MEMENTO MORI protocol active
                patterns: {
                    mostCommonKiller: null,        // Entity type that kills most often
                    mostDangerousLocation: null,   // Planet/area with most deaths
                    averageSurvivalTime: 0,        // Average time between deaths
                    killerCounts: {},              // {killerType: count}
                    locationCounts: {},            // {location: count}
                    timeOfDeathPattern: []         // When deaths typically occur (session time)
                },
                archivistObservations: [],         // AI-generated observations about death patterns
                lastArchivistGreeting: null        // Last greeting shown
            },
            // v6.97: Planet Surface Persistence System
            // Stores structures, terraformed areas, and modifications per planet
            // Enables import/export of individual planet states for backup
            planetSurfaces: {}  // { [planetId]: { structures, terraformedAreas, interactables, lastSaved, planetName, biome } }
        };

        // v4.4: Simulated Leaderboard Players for local comparison
        const SIMULATED_PLAYERS = [
            { name: 'StarSeeker_X', points: 500, rank: 'Pathfinder' },
            { name: 'CosmicNova', points: 2500, rank: 'Star Scout' },
            { name: 'VoidWalker99', points: 8000, rank: 'Galaxy Ranger' },
            { name: 'AstroLegend', points: 12000, rank: 'Void Hunter' },
            { name: 'NebulaKing', points: 18000, rank: 'Cosmic Legend' },
            { name: 'Explorer42', points: 150, rank: 'Wanderer' },
            { name: 'SpaceCadet', points: 350, rank: 'Wanderer' },
            { name: 'Starlight', points: 1200, rank: 'Pathfinder' }
        ];

        // v4.4: Prestige requirements and rewards
        const PRESTIGE_LEVELS = {
            1: { required: 15000, xpBonus: 0.10, skillBonus: 0 },
            2: { required: 20000, xpBonus: 0.10, skillBonus: 1 },
            3: { required: 30000, xpBonus: 0.15, skillBonus: 1 },
            4: { required: 50000, xpBonus: 0.20, skillBonus: 2 },
            5: { required: 100000, xpBonus: 0.25, skillBonus: 3 }
        };

        function canPrestige() {
            const currentLevel = gameData.prestige?.level || 0;
            const nextLevel = PRESTIGE_LEVELS[currentLevel + 1];
            if (!nextLevel) return false;
            return calculatePlayerPoints() >= nextLevel.required;
        }

        function performPrestige() {
            if (!canPrestige()) return false;

            const currentLevel = gameData.prestige?.level || 0;
            const newLevel = currentLevel + 1;
            const reward = PRESTIGE_LEVELS[newLevel];

            // Store lifetime stats
            const lifetimePoints = (gameData.prestige?.totalLifetimePoints || 0) + calculatePlayerPoints();

            // Calculate cumulative bonuses
            const newXpMultiplier = 1.0 + Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.xpBonus, 0);
            const newSkillBonus = Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.skillBonus, 0);

            // Keep achievements and daily challenge
            const keepData = {
                achievements: { ...gameData.achievements },
                dailyChallenge: { ...gameData.dailyChallenge },
                hasSeenTutorial: true,
                prestige: {
                    level: newLevel,
                    totalLifetimePoints: lifetimePoints,
                    bonuses: {
                        xpMultiplier: newXpMultiplier,
                        startingSkillBonus: newSkillBonus
                    }
                }
            };

            // Reset everything else
            gameData.version = VERSION;
            gameData.playtime = 0;
            gameData.inventory = [];
            gameData.visitedPlanets = [];
            gameData.discoveredPOIs = {};
            gameData.exploredTiles = {};
            gameData.playerRank = { points: 0, lastTitle: 'Novice Explorer' };

            // Reset skills with prestige bonus
            for (const skill of Object.keys(gameData.skills)) {
                gameData.skills[skill] = { level: 1 + newSkillBonus, xp: 0 };
            }

            // Reset statistics
            for (const stat of Object.keys(gameData.statistics)) {
                gameData.statistics[stat] = 0;
            }

            gameData.player = { hp: CONFIG.PLAYER_MAX_HP, maxHp: CONFIG.PLAYER_MAX_HP };

            // Restore kept data
            Object.assign(gameData, keepData);

            saveGameData();
            showNotification(`PRESTIGE ${newLevel}! XP +${Math.round((newXpMultiplier - 1) * 100)}%`, 'success');
            AudioSystem.levelUp();
            return true;
        }

        function getLeaderboardPosition() {
            const myPoints = calculatePlayerPoints();
            const allPlayers = [...SIMULATED_PLAYERS, { name: 'YOU', points: myPoints, rank: getPlayerRank().title }]
                .sort((a, b) => b.points - a.points);
            const myIndex = allPlayers.findIndex(p => p.name === 'YOU');
            return {
                position: myIndex + 1,
                total: allPlayers.length,
                nearby: allPlayers.slice(Math.max(0, myIndex - 2), myIndex + 3)
            };
        }

        // --- ACHIEVEMENT DEFINITIONS ---
        const ACHIEVEMENTS = {
            'first_landing': { name: 'First Contact', desc: 'Land on your first planet', icon: '' },
            'explorer_10': { name: 'Star Hopper', desc: 'Visit 10 different planets', icon: '' },
            'explorer_30': { name: 'Galaxy Wanderer', desc: 'Visit 30 planets', icon: '' },
            'lumberjack_25': { name: 'Woodcutter', desc: 'Chop 25 trees', icon: '' },
            'lumberjack_100': { name: 'Lumberjack', desc: 'Chop 100 trees', icon: '' },
            'miner_25': { name: 'Prospector', desc: 'Mine 25 ore veins', icon: '' },
            'miner_100': { name: 'Master Miner', desc: 'Mine 100 ore veins', icon: '' },
            'angler_10': { name: 'Fisherman', desc: 'Catch 10 fish', icon: '' },
            'angler_50': { name: 'Master Angler', desc: 'Catch 50 fish', icon: '' },
            'slayer_10': { name: 'Slime Champion', desc: 'Defeat 10 slimes', icon: '' },
            'slayer_50': { name: 'Arena Champion', desc: 'Defeat 50 slimes', icon: '' },
            'crafter_10': { name: 'Apprentice', desc: 'Craft 10 items', icon: '' },
            'crafter_50': { name: 'Master Craftsman', desc: 'Craft 50 items', icon: '' },
            'max_skill': { name: 'Specialist', desc: 'Reach level 10 in any skill', icon: '' },
            'playtime_1h': { name: 'Dedicated', desc: 'Play for 1 hour', icon: '' },
            'survivor': { name: 'Survivor', desc: 'Heal 500 HP total', icon: '' },
            'daily_3': { name: 'Consistent', desc: 'Complete 3 daily challenges', icon: '' },
            'daily_7': { name: 'Weekly Warrior', desc: 'Complete 7 daily challenges', icon: '' },
            // v6.1: NEW ACHIEVEMENTS
            'alchemist_5': { name: 'Apprentice Alchemist', desc: 'Reach Alchemy level 5', icon: '' },
            'alchemist_10': { name: 'Master Alchemist', desc: 'Reach Alchemy level 10', icon: '' },
            'potion_brewer': { name: 'Potion Brewer', desc: 'Brew 10 potions', icon: '' },
            'combo_master': { name: 'Combo Master', desc: 'Achieve a 20+ hit combo', icon: '' },
            'speedrunner': { name: 'Speed Demon', desc: 'Defeat a boss in under 60 seconds', icon: '' },
            'pacifist': { name: 'Pacifist', desc: 'Reach level 5 in any skill without combat', icon: '' },
            'eclipse_survivor': { name: 'Eclipse Survivor', desc: 'Survive a Solar Eclipse event', icon: '' },
            'gravity_master': { name: 'Gravity Master', desc: 'Collect all items during Gravity Anomaly', icon: '' },
            'boss_hunter_10': { name: 'Boss Hunter', desc: 'Defeat 10 bosses', icon: '' },
            'all_skills_5': { name: 'Jack of All Trades', desc: 'Get all skills to level 5', icon: '' },
            'all_skills_max': { name: 'Omni-Master', desc: 'Max all skills to level 20', icon: '' },
            'phoenix_used': { name: 'Reborn', desc: 'Use Phoenix Tears to auto-revive', icon: '' },
            'collector_100': { name: 'Hoarder', desc: 'Have 100+ items in inventory', icon: '' },
            'distance_1000': { name: 'Marathon Runner', desc: 'Travel 1000 distance units', icon: '' },
            'no_damage_boss': { name: 'Untouchable', desc: 'Defeat a boss without taking damage', icon: '' }
        };

        // --- DAILY CHALLENGE DEFINITIONS ---
        const DAILY_CHALLENGES = [
            { type: 'gather_logs', amount: 15, desc: 'Gather 15 logs', reward: { skill: 'wood', xp: 150 } },
            { type: 'gather_ore', amount: 12, desc: 'Mine 12 ore', reward: { skill: 'mining', xp: 150 } },
            { type: 'kill_mobs', amount: 5, desc: 'Defeat 5 slimes', reward: { skill: 'combat', xp: 200 } },
            { type: 'catch_fish', amount: 8, desc: 'Catch 8 fish', reward: { skill: 'fishing', xp: 150 } },
            { type: 'craft_items', amount: 3, desc: 'Craft 3 items', reward: { skill: 'crafting', xp: 100 } },
            { type: 'visit_planets', amount: 2, desc: 'Explore 2 new planets', reward: { skill: 'combat', xp: 200 } },
            { type: 'cook_fish', amount: 3, desc: 'Cook 3 fish', reward: { skill: 'cooking', xp: 120 } }
        ];

        // Tutorial functions
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            gameData.hasSeenTutorial = true;
            saveGameData();
            AudioSystem.click();
        }

        // v6.1: Keyboard shortcuts overlay
        function toggleShortcutsOverlay() {
            const overlay = document.getElementById('shortcuts-overlay');
            if (overlay) {
                const isVisible = overlay.style.display === 'flex';
                overlay.style.display = isVisible ? 'none' : 'flex';
                if (!isVisible) AudioSystem.click();
            }
        }

        // v6.1: Performance metrics overlay
        let perfMetricsVisible = false;
        function togglePerfMetrics() {
            const metrics = document.getElementById('perf-metrics');
            if (metrics) {
                perfMetricsVisible = !perfMetricsVisible;
                metrics.style.display = perfMetricsVisible ? 'block' : 'none';
            }
        }

        function updatePerfMetrics() {
            if (!perfMetricsVisible) return;

            // v6.84: Use cached DOM references for hot path updates
            const cache = getUICache();
            if (cache.perfFps) cache.perfFps.textContent = currentFps;
            if (cache.perfEntities) cache.perfEntities.textContent = worldState.interactables?.length || 0;
            if (cache.perfMobs) cache.perfMobs.textContent = worldState.mobs?.length || 0;

            if (renderer && renderer.info) {
                if (cache.perfDraws) cache.perfDraws.textContent = renderer.info.render?.calls || 0;
                if (cache.perfTris) cache.perfTris.textContent = renderer.info.render?.triangles || 0;
            }
        }

        // v6.1: Loading screen tips (v6.32: Added more tips)
        const LOADING_TIPS = [
            "Press F1 or ? anytime to view keyboard shortcuts",
            "Use WASD to move and click to interact with objects",
            "Craft a Pickaxe to gather more ore per swing",
            "Fish near water to get food, cook it to heal more",
            "Green slimes are aggressive - they will attack on sight!",
            "Press V to talk to your AI Copilot companion",
            "Export your game data regularly to keep a backup",
            "Elite enemies glow red and drop rare loot",
            "Use the Minimap (M) to track nearby resources and enemies",
            "Boss monsters spawn during world events - high risk, high reward!",
            "Brew potions with the new Alchemy skill for powerful buffs",
            "Agents level up over time and become more efficient",
            "Press F3 to toggle performance metrics",
            "The SpatialGrid system optimizes entity lookups for better FPS",
            "Agent personalities affect their dialogue and behavior",
            "Try the Berserker Brew potion for +50% damage (but -20% defense)",
            "Phoenix Tears will auto-revive you once within 5 minutes",
            "Mimic enemies disguise themselves as treasure chests - beware!",
            "Crystal Golems have shields that absorb the first 30 damage",
            "Solar Eclipse events spawn powerful Shadow creatures",
            "Hold Shift while moving to run faster",
            "Press Space to dodge roll through enemy attacks",
            "Press Q to quickly use a healing item",
            "Terraformer agents flatten terrain automatically",
            "Builder agents construct structures over time",
            "Press S in Galaxy Mode to access settings",
            "Weather affects gameplay - fog reduces visibility!",
            "Your ship can auto-defend when attacked",
            "Daily challenges give bonus rewards - check the panel!"
        ];

        function startLoadingTips() {
            const tipText = document.getElementById('tip-text');
            if (!tipText) return;

            let tipIndex = 0;
            function showNextTip() {
                tipIndex = (tipIndex + 1) % LOADING_TIPS.length;
                tipText.style.opacity = '0';
                setTimeout(() => {
                    tipText.textContent = LOADING_TIPS[tipIndex];
                    tipText.style.opacity = '1';
                }, 300);
            }

            // Change tip every 4 seconds
            setInterval(showNextTip, 4000);
        }

        // Start tips when page loads
        document.addEventListener('DOMContentLoaded', startLoadingTips);

        // v6.1: DAY/NIGHT CYCLE SYSTEM
        const DayNightCycle = {
            // Game time: 1 real minute = 1 game hour (24 minute cycle)
            gameTimeScale: 60, // seconds per game hour
            gameTime: 12 * 60, // Start at noon (minutes)
            lastUpdate: 0,

            // Time phases
            phases: {
                dawn: { start: 5 * 60, end: 7 * 60, icon: '', name: 'Dawn', color: '#ffaa66', effect: '+10% Gathering' },
                day: { start: 7 * 60, end: 17 * 60, icon: '', name: 'Day', color: '#ffcc00', effect: 'Normal activity' },
                dusk: { start: 17 * 60, end: 19 * 60, icon: '', name: 'Dusk', color: '#ff6644', effect: '+15% Combat XP' },
                night: { start: 19 * 60, end: 5 * 60, icon: '', name: 'Night', color: '#6688ff', effect: '+20% Stealth, -Visibility' }
            },

            // Update game time (call from main loop)
            update(dt) {
                // Advance game time (1 real second = 1 game minute at default scale)
                this.gameTime += (dt * 60) / this.gameTimeScale;
                if (this.gameTime >= 24 * 60) this.gameTime -= 24 * 60;
            },

            // Get current phase
            getCurrentPhase() {
                const time = this.gameTime;
                for (const [name, phase] of Object.entries(this.phases)) {
                    if (name === 'night') {
                        // Night wraps around midnight
                        if (time >= phase.start || time < phase.end) return { ...phase, name: name };
                    } else {
                        if (time >= phase.start && time < phase.end) return { ...phase, name: name };
                    }
                }
                return this.phases.day;
            },

            // Get formatted time string (HH:MM)
            getTimeString() {
                const hours = Math.floor(this.gameTime / 60);
                const minutes = Math.floor(this.gameTime % 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            },

            // Get ambient light modifier (0-1)
            getAmbientLight() {
                const time = this.gameTime;
                // Peak brightness at noon, darkest at midnight
                if (time >= 6 * 60 && time < 18 * 60) {
                    // Daytime: 0.7 to 1.0
                    const noon = 12 * 60;
                    const distFromNoon = Math.abs(time - noon) / (6 * 60);
                    return 1.0 - distFromNoon * 0.3;
                } else {
                    // Nighttime: 0.3 to 0.5
                    const midnight = 0;
                    let distFromMidnight;
                    if (time >= 18 * 60) {
                        distFromMidnight = (24 * 60 - time) / (6 * 60);
                    } else {
                        distFromMidnight = time / (6 * 60);
                    }
                    return 0.3 + distFromMidnight * 0.2;
                }
            },

            // Get bonuses based on time of day
            getBonuses() {
                const phase = this.getCurrentPhase();
                return {
                    gatheringBonus: phase.name === 'dawn' ? 0.10 : 0,
                    combatXpBonus: phase.name === 'dusk' ? 0.15 : 0,
                    stealthBonus: phase.name === 'night' ? 0.20 : 0,
                    visibilityRange: phase.name === 'night' ? 0.7 : 1.0,
                    mobAggression: phase.name === 'night' ? 1.2 : 1.0
                };
            },

            // Check if it's night
            isNight() {
                const time = this.gameTime;
                return time >= 19 * 60 || time < 5 * 60;
            }
        };

        // Update time indicator UI
        function updateTimeUI() {
            const indicator = document.getElementById('time-indicator');
            if (!indicator || mode !== 'world') return;

            const phase = DayNightCycle.getCurrentPhase();

            document.getElementById('time-icon').textContent = phase.icon;
            document.getElementById('time-name').textContent = phase.name.charAt(0).toUpperCase() + phase.name.slice(1);
            document.getElementById('time-name').style.color = phase.color;
            document.getElementById('time-clock').textContent = DayNightCycle.getTimeString();
            document.getElementById('time-effect').textContent = phase.effect;
        }

        // --- ACHIEVEMENT SYSTEM ---
        function checkAchievements() {
            const s = gameData.statistics;
            const sk = gameData.skills;

            const checks = {
                'first_landing': () => gameData.visitedPlanets.length >= 1,
                'explorer_10': () => gameData.visitedPlanets.length >= 10,
                'explorer_30': () => gameData.visitedPlanets.length >= 30,
                'lumberjack_25': () => s.treesChopped >= 25,
                'lumberjack_100': () => s.treesChopped >= 100,
                'miner_25': () => s.oresMined >= 25,
                'miner_100': () => s.oresMined >= 100,
                'angler_10': () => s.fishCaught >= 10,
                'angler_50': () => s.fishCaught >= 50,
                'slayer_10': () => s.mobsKilled >= 10,
                'slayer_50': () => s.mobsKilled >= 50,
                'crafter_10': () => s.itemsCrafted >= 10,
                'crafter_50': () => s.itemsCrafted >= 50,
                'max_skill': () => Object.values(sk).some(skill => skill.level >= 10),
                'playtime_1h': () => gameData.playtime >= 3600,
                'survivor': () => (s.totalHealed || 0) >= 500,
                'daily_3': () => (gameData.dailyChallenge.completedCount || 0) >= 3,
                'daily_7': () => (gameData.dailyChallenge.completedCount || 0) >= 7
            };

            for (const [id, check] of Object.entries(checks)) {
                if (!gameData.achievements[id] && check()) {
                    unlockAchievement(id);
                }
            }
        }

        function unlockAchievement(id) {
            if (gameData.achievements[id]) return;

            const ach = ACHIEVEMENTS[id];
            if (!ach) return;

            gameData.achievements[id] = { unlockedAt: new Date().toISOString() };

            // Show achievement popup
            showAchievementPopup(ach.icon, ach.name, ach.desc);
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 25, 0xffd700, { spread: 6, lifetime: 1500 });
            }

            saveGameData();
        }

        function showAchievementPopup(icon, name, desc) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div class="ach-icon">${icon}</div>
                <div class="ach-text">
                    <div class="ach-title">Achievement Unlocked!</div>
                    <div class="ach-name">${name}</div>
                    <div class="ach-desc">${desc}</div>
                </div>
            `;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 4000);
        }

        // --- DAILY CHALLENGE SYSTEM ---
        function generateDailyChallenge() {
            const today = new Date().toDateString();

            if (gameData.dailyChallenge.lastGenerated === today && gameData.dailyChallenge.current) {
                return gameData.dailyChallenge.current;
            }

            // Reset streak if missed a day
            if (gameData.dailyChallenge.lastGenerated) {
                const lastDate = new Date(gameData.dailyChallenge.lastGenerated);
                const now = new Date();
                const diffDays = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
                if (diffDays > 1) {
                    gameData.dailyChallenge.streak = 0;
                }
            }

            // Use date as seed for consistent daily challenge
            const seed = new SeededRNG(today);
            const template = seed.pick(DAILY_CHALLENGES);
            const challenge = {
                ...template,
                progress: 0,
                startStats: { ...gameData.statistics },
                startPlanets: gameData.visitedPlanets.length
            };

            gameData.dailyChallenge.lastGenerated = today;
            gameData.dailyChallenge.current = challenge;
            gameData.dailyChallenge.completed = false;
            saveGameData();

            return challenge;
        }

        function updateDailyChallengeProgress() {
            if (!gameData.dailyChallenge.current || gameData.dailyChallenge.completed) return;

            const c = gameData.dailyChallenge.current;
            const start = c.startStats || {};
            const now = gameData.statistics;

            switch (c.type) {
                case 'gather_logs': c.progress = (now.treesChopped || 0) - (start.treesChopped || 0); break;
                case 'gather_ore': c.progress = (now.oresMined || 0) - (start.oresMined || 0); break;
                case 'kill_mobs': c.progress = (now.mobsKilled || 0) - (start.mobsKilled || 0); break;
                case 'catch_fish': c.progress = (now.fishCaught || 0) - (start.fishCaught || 0); break;
                case 'craft_items': c.progress = (now.itemsCrafted || 0) - (start.itemsCrafted || 0); break;
                case 'cook_fish': c.progress = (now.fishCooked || 0) - (start.fishCooked || 0); break;
                case 'visit_planets': c.progress = gameData.visitedPlanets.length - (c.startPlanets || 0); break;
            }

            if (c.progress >= c.amount && !gameData.dailyChallenge.completed) {
                completeDailyChallenge();
            }

            updateDailyChallengeUI();
        }

        function completeDailyChallenge() {
            gameData.dailyChallenge.completed = true;
            gameData.dailyChallenge.streak++;
            gameData.dailyChallenge.completedCount = (gameData.dailyChallenge.completedCount || 0) + 1;
            gameData.dailyChallenge.bestStreak = Math.max(gameData.dailyChallenge.bestStreak || 0, gameData.dailyChallenge.streak);

            // Apply reward with streak bonus
            const reward = gameData.dailyChallenge.current.reward;
            const streakMultiplier = 1 + (gameData.dailyChallenge.streak * 0.1);
            const xpReward = Math.floor(reward.xp * streakMultiplier);

            addXp(reward.skill, xpReward);

            showNotification(`Daily Challenge Complete! +${xpReward} ${reward.skill} XP (Streak: ${gameData.dailyChallenge.streak})`);
            AudioSystem.levelUp();

            checkAchievements();
            saveGameData();
        }

        function toggleDailyChallenge() {
            const el = document.getElementById('daily-challenge');
            const btn = document.getElementById('daily-challenge-toggle');
            if (!el || !btn) return;

            const isCollapsed = el.classList.toggle('collapsed');
            btn.textContent = isCollapsed ? '+' : '';
            localStorage.setItem('dailyChallengeCollapsed', isCollapsed ? '1' : '0');
        }

        function updateDailyChallengeUI() {
            const el = document.getElementById('daily-challenge');
            if (!el) return;

            const c = gameData.dailyChallenge.current;
            if (!c) {
                el.style.display = 'none';
                return;
            }

            el.style.display = 'block';

            // Restore collapsed state
            const btn = document.getElementById('daily-challenge-toggle');
            if (localStorage.getItem('dailyChallengeCollapsed') === '1') {
                el.classList.add('collapsed');
                if (btn) btn.textContent = '+';
            }
            document.getElementById('daily-desc').textContent = c.desc;
            document.getElementById('daily-progress-text').textContent = `${Math.min(c.progress || 0, c.amount)}/${c.amount}`;
            document.getElementById('daily-progress-fill').style.width = `${Math.min(100, ((c.progress || 0) / c.amount) * 100)}%`;
            document.getElementById('daily-streak').textContent = `Streak: ${gameData.dailyChallenge.streak} ${gameData.dailyChallenge.streak === 1 ? 'day' : 'days'}`;

            if (gameData.dailyChallenge.completed) {
                el.classList.add('completed');
            } else {
                el.classList.remove('completed');
            }
        }

        // --- v4.2: PLAYER RANK SYSTEM ---
        function calculatePlayerPoints() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            return (
                gameData.visitedPlanets.length * 50 +
                s.treesChopped * 2 +
                s.oresMined * 2 +
                s.mobsKilled * 10 +
                s.fishCaught * 3 +
                s.itemsCrafted * 5 +
                (s.poisDiscovered || 0) * 100 +
                Object.values(sk).reduce((sum, skill) => sum + skill.level * 20, 0) +
                Math.floor(gameData.playtime / 60)
            );
        }

        function getPlayerRank() {
            const points = calculatePlayerPoints();
            let rank = PLAYER_RANKS[0];
            for (const r of PLAYER_RANKS) {
                if (points >= r.points) rank = r;
            }
            return { ...rank, points };
        }

        function getSpecialTitles() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            const titles = [];
            for (const [name, data] of Object.entries(SPECIAL_TITLES)) {
                if (data.condition(s, sk)) {
                    titles.push({ name, color: data.color });
                }
            }
            return titles;
        }

        function updatePlayerRank() {
            const rank = getPlayerRank();
            const oldTitle = gameData.playerRank?.lastTitle || 'Novice Explorer';

            gameData.playerRank = {
                points: rank.points,
                lastTitle: rank.title
            };

            // Show rank up notification
            if (rank.title !== oldTitle) {
                showNotification(`RANK UP! You are now: ${rank.title}`, 'success');
                AudioSystem.levelUp();
            }

            saveGameData();
        }

        // --- STATISTICS PANEL ---
        function showStatsPanel() {
            updateStatsDisplay();
            document.getElementById('stats-modal').style.display = 'flex';
        }

        function closeStatsModal() {
            document.getElementById('stats-modal').style.display = 'none';
        }

        // v4.9: Collection Codex System
        const CODEX_DATA = {
            creatures: [
                { id: 'wolf', name: 'Wolf', icon: '', biome: 'forest', description: 'A fierce forest predator' },
                { id: 'bear', name: 'Bear', icon: '', biome: 'forest', description: 'Massive and dangerous' },
                { id: 'snake', name: 'Snake', icon: '', biome: 'desert', description: 'Venomous desert dweller' },
                { id: 'scorpion', name: 'Scorpion', icon: '', biome: 'desert', description: 'Deadly desert creature' },
                { id: 'yeti', name: 'Yeti', icon: '', biome: 'arctic', description: 'Legendary snow beast' },
                { id: 'penguin', name: 'Penguin', icon: '', biome: 'arctic', description: 'Hardy arctic bird' },
                { id: 'shark', name: 'Shark', icon: '', biome: 'ocean', description: 'Apex ocean predator' },
                { id: 'octopus', name: 'Octopus', icon: '', biome: 'ocean', description: 'Intelligent sea creature' },
                { id: 'dragon', name: 'Dragon', icon: '', biome: 'volcanic', description: 'Ancient fire-breathing beast' },
                { id: 'phoenix', name: 'Phoenix', icon: '', biome: 'volcanic', description: 'Immortal flame bird' },
                { id: 'alien', name: 'Alien', icon: '', biome: 'alien', description: 'Extraterrestrial lifeform' },
                { id: 'robot', name: 'Robot', icon: '', biome: 'crystal', description: 'Mechanical guardian' },
                { id: 'elite', name: 'Elite Monster', icon: '', biome: 'any', description: 'Powerful elite creature' },
                { id: 'boss', name: 'World Boss', icon: '', biome: 'any', description: 'Legendary boss creature' }
            ],
            biomes: [
                { id: 'forest', name: 'Forest World', icon: '', color: '#228B22' },
                { id: 'desert', name: 'Desert World', icon: '', color: '#DEB887' },
                { id: 'arctic', name: 'Arctic World', icon: '', color: '#87CEEB' },
                { id: 'ocean', name: 'Ocean World', icon: '', color: '#1E90FF' },
                { id: 'volcanic', name: 'Volcanic World', icon: '', color: '#FF4500' },
                { id: 'alien', name: 'Alien World', icon: '', color: '#9400D3' },
                { id: 'crystal', name: 'Crystal World', icon: '', color: '#00CED1' },
                { id: 'mushroom', name: 'Mushroom World', icon: '', color: '#FF69B4' }
            ]
        };

        function initCodexTracking() {
            if (!gameData.codex) {
                gameData.codex = {
                    creatures: {},
                    items: {},
                    biomes: {}
                };
            }
        }

        function trackCreatureKill(creatureType) {
            initCodexTracking();
            if (!gameData.codex.creatures[creatureType]) {
                gameData.codex.creatures[creatureType] = { count: 0, firstKill: Date.now() };
                showNotification(`New Codex Entry: ${creatureType}!`, 'success');
            }
            gameData.codex.creatures[creatureType].count++;
        }

        function trackItemDiscovery(itemName) {
            initCodexTracking();
            if (!gameData.codex.items[itemName]) {
                gameData.codex.items[itemName] = { count: 0, firstFound: Date.now() };
            }
            gameData.codex.items[itemName].count++;
        }

        function trackBiomeVisit(biomeType) {
            initCodexTracking();
            if (!gameData.codex.biomes[biomeType]) {
                gameData.codex.biomes[biomeType] = { visited: true, firstVisit: Date.now() };
                showNotification(`New Biome Discovered: ${biomeType}!`, 'success');
            }
        }

        function openCodexModal() {
            initCodexTracking();
            updateCodexDisplay();
            document.getElementById('codex-modal').style.display = 'flex';
        }

        function closeCodexModal() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        function switchCodexTab(tab) {
            document.querySelectorAll('.codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.codex-content').forEach(c => c.style.display = 'none');
            document.querySelector(`.codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`codex-${tab}`).style.display = 'block';
        }

        function updateCodexDisplay() {
            // Creatures
            const creaturesGrid = document.getElementById('codex-creatures-grid');
            let creaturesHtml = '';
            let discoveredCreatures = 0;
            CODEX_DATA.creatures.forEach(c => {
                const discovered = gameData.codex?.creatures?.[c.id];
                if (discovered) discoveredCreatures++;
                creaturesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? c.description : '???'}">
                        <span class="entry-icon">${c.icon}</span>
                        <span class="entry-name">${discovered ? c.name : '???'}</span>
                        ${discovered ? `<span class="entry-count">Defeated: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            creaturesGrid.innerHTML = creaturesHtml;
            document.getElementById('codex-creatures-count').textContent = discoveredCreatures;
            document.getElementById('codex-creatures-total').textContent = CODEX_DATA.creatures.length;

            // Items
            const itemsGrid = document.getElementById('codex-items-grid');
            let itemsHtml = '';
            let discoveredItems = 0;
            const allItems = Object.keys(ITEMS);
            allItems.forEach(itemName => {
                const item = ITEMS[itemName];
                const discovered = gameData.codex?.items?.[itemName];
                if (discovered) discoveredItems++;
                itemsHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? (item.description || itemName) : '???'}">
                        <span class="entry-icon">${item.icon || ''}</span>
                        <span class="entry-name">${discovered ? itemName : '???'}</span>
                        ${discovered ? `<span class="entry-count">Found: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            itemsGrid.innerHTML = itemsHtml;
            document.getElementById('codex-items-count').textContent = discoveredItems;
            document.getElementById('codex-items-total').textContent = allItems.length;

            // Biomes
            const biomesGrid = document.getElementById('codex-biomes-grid');
            let biomesHtml = '';
            let discoveredBiomes = 0;
            CODEX_DATA.biomes.forEach(b => {
                const discovered = gameData.codex?.biomes?.[b.id];
                if (discovered) discoveredBiomes++;
                biomesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" style="${discovered ? `border-color: ${b.color}` : ''}">
                        <span class="entry-icon">${b.icon}</span>
                        <span class="entry-name">${discovered ? b.name : '???'}</span>
                    </div>
                `;
            });
            biomesGrid.innerHTML = biomesHtml;
            document.getElementById('codex-biomes-count').textContent = discoveredBiomes;
            document.getElementById('codex-biomes-total').textContent = CODEX_DATA.biomes.length;

            // Abilities
            const abilitiesGrid = document.getElementById('codex-abilities-grid');
            let abilitiesHtml = '';
            let unlockedAbilities = 0;
            const combatLevel = gameData.skills?.combat?.level || 1;
            Object.entries(COMBAT_ABILITIES).forEach(([key, ability]) => {
                const unlocked = combatLevel >= ability.unlockLevel;
                if (unlocked) unlockedAbilities++;
                abilitiesHtml += `
                    <div class="codex-entry ${unlocked ? 'discovered' : 'undiscovered'}" title="${unlocked ? ability.description : `Unlocks at Combat Lv ${ability.unlockLevel}`}">
                        <span class="entry-icon">${ability.icon}</span>
                        <span class="entry-name">${unlocked ? ability.name : '???'}</span>
                        <span class="entry-count">${unlocked ? `[${ability.key}]` : `Lv ${ability.unlockLevel}`}</span>
                    </div>
                `;
            });
            abilitiesGrid.innerHTML = abilitiesHtml;
            document.getElementById('codex-abilities-count').textContent = unlockedAbilities;
            document.getElementById('codex-abilities-total').textContent = Object.keys(COMBAT_ABILITIES).length;

            // v5.0: Pets
            initPetSystem();
            const petsGrid = document.getElementById('codex-pets-grid');
            let petsHtml = '';
            let collectedPets = 0;
            const ownedPets = gameData.pets?.owned || [];
            const activePet = gameData.pets?.active;

            Object.entries(PET_TYPES).forEach(([petId, pet]) => {
                const owned = ownedPets.includes(petId);
                const isActive = activePet === petId;
                if (owned) collectedPets++;

                petsHtml += `
                    <div class="codex-entry ${owned ? 'discovered' : 'undiscovered'} ${isActive ? 'active-pet' : ''}"
                         style="${owned ? `border-color: ${RARITY_COLORS[pet.rarity]}` : ''}; ${isActive ? 'box-shadow: 0 0 10px ' + RARITY_COLORS[pet.rarity] : ''}"
                         title="${owned ? pet.abilityDesc : '???'}"
                         onclick="${owned ? `setActivePet('${isActive ? '' : petId}')` : ''}">
                        <span class="entry-icon" style="font-size: 32px;">${pet.icon}</span>
                        <span class="entry-name" style="color: ${owned ? RARITY_COLORS[pet.rarity] : '#666'}">${owned ? pet.name : '???'}</span>
                        ${owned ? `<span class="entry-count" style="color: ${RARITY_COLORS[pet.rarity]}">${pet.rarity.toUpperCase()}</span>` : ''}
                        ${owned ? `<span style="font-size: 10px; color: #aaa;">${pet.abilityDesc}</span>` : ''}
                        ${isActive ? '<span style="color: #ff8c00; font-size: 10px;">ACTIVE</span>' : ''}
                    </div>
                `;
            });
            petsGrid.innerHTML = petsHtml;
            document.getElementById('codex-pets-count').textContent = collectedPets;
            document.getElementById('codex-pets-total').textContent = Object.keys(PET_TYPES).length;
            document.getElementById('active-pet-name').textContent = activePet ? PET_TYPES[activePet].name : 'None';
        }

        // v5.0: Quest System
        const QUEST_TEMPLATES = {
            daily: [
                { id: 'kill_mobs', name: 'Monster Hunter', desc: 'Defeat enemies', icon: '', target: 10, reward: { xp: 500, item: 'Health Potion' }, stat: 'mobsKilled' },
                { id: 'gather_wood', name: 'Lumberjack', desc: 'Chop down trees', icon: '', target: 15, reward: { xp: 300 }, stat: 'treesChopped' },
                { id: 'mine_ore', name: 'Prospector', desc: 'Mine ore deposits', icon: '', target: 10, reward: { xp: 400, item: 'Iron Ore' }, stat: 'oresMined' },
                { id: 'catch_fish', name: 'Angler', desc: 'Catch fish', icon: '', target: 8, reward: { xp: 350 }, stat: 'fishCaught' },
                { id: 'visit_planets', name: 'Explorer', desc: 'Visit different planets', icon: '', target: 3, reward: { xp: 600 }, stat: 'planetsVisited' },
                { id: 'craft_items', name: 'Artisan', desc: 'Craft items', icon: '', target: 5, reward: { xp: 400, item: 'Super Potion' }, stat: 'itemsCrafted' },
                { id: 'use_abilities', name: 'Ability Master', desc: 'Use combat abilities', icon: '', target: 20, reward: { xp: 450 }, stat: 'abilitiesUsed' },
                { id: 'kill_elites', name: 'Elite Slayer', desc: 'Defeat elite enemies', icon: '', target: 2, reward: { xp: 800, item: 'Void Fragment' }, stat: 'elitesKilled' }
            ],
            weekly: [
                { id: 'w_kill_mobs', name: 'Monster Massacre', desc: 'Defeat many enemies', icon: '', target: 100, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'mobsKilled' },
                { id: 'w_bosses', name: 'Boss Hunter', desc: 'Defeat world bosses', icon: '', target: 5, reward: { xp: 8000 }, stat: 'bossesDefeated' },
                { id: 'w_explore', name: 'Galactic Explorer', desc: 'Visit many planets', icon: '', target: 15, reward: { xp: 6000 }, stat: 'planetsVisited' },
                { id: 'w_gather', name: 'Resource Mogul', desc: 'Gather total resources', icon: '', target: 200, reward: { xp: 4000, item: 'Super Potion' }, stat: 'totalGathered' },
                { id: 'w_combat', name: 'Combat Veteran', desc: 'Deal damage with abilities', icon: '', target: 50, reward: { xp: 5500 }, stat: 'abilitiesUsed' }
            ],
            story: [
                { id: 's_first_kill', name: 'First Blood', desc: 'Defeat your first enemy', icon: '', target: 1, reward: { xp: 100 }, stat: 'mobsKilled', oneTime: true },
                { id: 's_first_planet', name: 'First Steps', desc: 'Visit your first planet', icon: '', target: 1, reward: { xp: 200 }, stat: 'planetsVisited', oneTime: true },
                { id: 's_craft_weapon', name: 'Armed and Ready', desc: 'Craft a weapon', icon: '', target: 1, reward: { xp: 300, item: 'Health Potion' }, stat: 'weaponsCrafted', oneTime: true },
                { id: 's_level_combat', name: 'Warrior\'s Path', desc: 'Reach Combat Level 5', icon: '', target: 5, reward: { xp: 500 }, stat: 'combatLevel', oneTime: true },
                { id: 's_first_boss', name: 'Giant Slayer', desc: 'Defeat a world boss', icon: '', target: 1, reward: { xp: 1000, item: 'Magma Sword' }, stat: 'bossesDefeated', oneTime: true },
                { id: 's_master_combat', name: 'Combat Master', desc: 'Reach Combat Level 15', icon: '', target: 15, reward: { xp: 2000 }, stat: 'combatLevel', oneTime: true },
                { id: 's_explore_all', name: 'Galaxy Conqueror', desc: 'Visit 30 planets', icon: '', target: 30, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'planetsVisited', oneTime: true },
                { id: 's_ultimate', name: 'Legendary Hero', desc: 'Reach Combat Level 20', icon: '', target: 20, reward: { xp: 10000 }, stat: 'combatLevel', oneTime: true }
            ]
        };

        function initQuestSystem() {
            if (!gameData.quests) {
                gameData.quests = {
                    daily: { quests: [], lastReset: 0, sessionStart: {} },
                    weekly: { quests: [], lastReset: 0, sessionStart: {} },
                    story: { completed: [], claimed: [] }
                };
            }
            checkQuestResets();
        }

        function checkQuestResets() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            // Daily reset (every 24 hours from first play)
            if (now - gameData.quests.daily.lastReset > dayMs) {
                generateDailyQuests();
            }

            // Weekly reset (every 7 days)
            if (now - gameData.quests.weekly.lastReset > weekMs) {
                generateWeeklyQuests();
            }
        }

        function generateDailyQuests() {
            const shuffled = [...QUEST_TEMPLATES.daily].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 3);

            gameData.quests.daily = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function generateWeeklyQuests() {
            const shuffled = [...QUEST_TEMPLATES.weekly].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 2);

            gameData.quests.weekly = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function captureQuestStats() {
            const s = gameData.statistics;
            return {
                mobsKilled: s.mobsKilled || 0,
                treesChopped: s.treesChopped || 0,
                oresMined: s.oresMined || 0,
                fishCaught: s.fishCaught || 0,
                planetsVisited: gameData.visitedPlanets.length,
                itemsCrafted: s.itemsCrafted || 0,
                bossesDefeated: s.bossesDefeated || 0,
                elitesKilled: s.elitesKilled || 0,
                abilitiesUsed: s.abilitiesUsed || 0,
                totalGathered: (s.treesChopped || 0) + (s.oresMined || 0) + (s.fishCaught || 0),
                combatLevel: gameData.skills?.combat?.level || 1,
                weaponsCrafted: s.weaponsCrafted || 0
            };
        }

        function getQuestProgress(quest, type) {
            const current = captureQuestStats();
            const start = gameData.quests[type]?.sessionStart || {};

            if (quest.oneTime) {
                return current[quest.stat] || 0;
            }

            const startVal = start[quest.stat] || 0;
            const currentVal = current[quest.stat] || 0;
            return Math.max(0, currentVal - startVal);
        }

        function openQuestModal() {
            initQuestSystem();
            updateQuestDisplay();
            document.getElementById('quest-modal').style.display = 'flex';
            startQuestTimers();
        }

        function closeQuestModal() {
            document.getElementById('quest-modal').style.display = 'none';
        }

        function switchQuestTab(tab) {
            document.querySelectorAll('#quest-modal .codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.quest-content').forEach(c => c.style.display = 'none');
            document.querySelector(`#quest-modal .codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`quest-${tab}`).style.display = 'block';
        }

        let questTimerInterval = null;
        function startQuestTimers() {
            if (questTimerInterval) clearInterval(questTimerInterval);
            questTimerInterval = setInterval(updateQuestTimers, 1000);
            updateQuestTimers();
        }

        function updateQuestTimers() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            const dailyReset = (gameData.quests?.daily?.lastReset || now) + dayMs;
            const weeklyReset = (gameData.quests?.weekly?.lastReset || now) + weekMs;

            document.getElementById('daily-reset-timer').textContent = formatTimeRemaining(dailyReset - now);
            document.getElementById('weekly-reset-timer').textContent = formatTimeRemaining(weeklyReset - now);
        }

        function formatTimeRemaining(ms) {
            if (ms <= 0) return 'Resetting...';
            const hours = Math.floor(ms / (60 * 60 * 1000));
            const mins = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
            const secs = Math.floor((ms % (60 * 1000)) / 1000);
            return `${hours}h ${mins}m ${secs}s`;
        }

        function updateQuestDisplay() {
            // Daily quests
            const dailyList = document.getElementById('daily-quests-list');
            dailyList.innerHTML = renderQuestList(gameData.quests.daily.quests, 'daily');

            // Weekly quests
            const weeklyList = document.getElementById('weekly-quests-list');
            weeklyList.innerHTML = renderQuestList(gameData.quests.weekly.quests, 'weekly');

            // Story quests
            const storyList = document.getElementById('story-quests-list');
            storyList.innerHTML = renderStoryQuests();
        }

        function renderQuestList(quests, type) {
            return quests.map((quest, idx) => {
                const progress = getQuestProgress(quest, type);
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = quest.claimed;

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimQuest('${type}', ${idx})">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;"> Claimed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function renderStoryQuests() {
            return QUEST_TEMPLATES.story.map((quest, idx) => {
                const progress = captureQuestStats()[quest.stat] || 0;
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = gameData.quests.story.claimed.includes(quest.id);

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimStoryQuest('${quest.id}')">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;"> Completed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function claimQuest(type, idx) {
            const quest = gameData.quests[type].quests[idx];
            if (!quest || quest.claimed) return;

            quest.claimed = true;

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Quest Complete: ${quest.name}! +${quest.reward.xp} XP`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 30, 0xffd700, { spread: 5, lifetime: 1000 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        function claimStoryQuest(questId) {
            if (gameData.quests.story.claimed.includes(questId)) return;

            const quest = QUEST_TEMPLATES.story.find(q => q.id === questId);
            if (!quest) return;

            gameData.quests.story.claimed.push(questId);

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Story Quest Complete: ${quest.name}!`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 40, 0xffd700, { spread: 6, lifetime: 1200 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        // Track ability usage for quests
        function trackAbilityUsage() {
            if (!gameData.statistics.abilitiesUsed) gameData.statistics.abilitiesUsed = 0;
            gameData.statistics.abilitiesUsed++;
        }

        // v5.0: Pet Companion System
        const PET_TYPES = {
            slime: {
                name: 'Slime Buddy',
                icon: '',
                color: 0x44ff44,
                rarity: 'common',
                dropChance: 0.05,
                ability: 'regen',
                abilityDesc: '+1 HP/5s',
                speed: 3
            },
            firefly: {
                name: 'Firefly',
                icon: '',
                color: 0xffff00,
                rarity: 'common',
                dropChance: 0.04,
                ability: 'light',
                abilityDesc: 'Reveals hidden items',
                speed: 5
            },
            crystal: {
                name: 'Crystal Sprite',
                icon: '',
                color: 0x00ffff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'luck',
                abilityDesc: '+10% drop rate',
                speed: 4
            },
            shadow: {
                name: 'Shadow Wisp',
                icon: '',
                color: 0x8800ff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'dodge',
                abilityDesc: '+5% dodge chance',
                speed: 6
            },
            phoenix: {
                name: 'Mini Phoenix',
                icon: '',
                color: 0xff4400,
                rarity: 'rare',
                dropChance: 0.008,
                ability: 'damage',
                abilityDesc: '+15% damage',
                speed: 5
            },
            dragon: {
                name: 'Baby Dragon',
                icon: '',
                color: 0xff0088,
                rarity: 'rare',
                dropChance: 0.005,
                ability: 'attack',
                abilityDesc: 'Attacks nearby enemies',
                speed: 4
            },
            void: {
                name: 'Void Entity',
                icon: '',
                color: 0x4400ff,
                rarity: 'legendary',
                dropChance: 0.002,
                ability: 'absorb',
                abilityDesc: '+25% XP gain',
                speed: 3
            },
            celestial: {
                name: 'Celestial Star',
                icon: '',
                color: 0xffd700,
                rarity: 'legendary',
                dropChance: 0.001,
                ability: 'allStats',
                abilityDesc: '+10% all stats',
                speed: 7
            }
        };

        const RARITY_COLORS = {
            common: '#aaaaaa',
            uncommon: '#00ff00',
            rare: '#0088ff',
            legendary: '#ff8800'
        };

        let activePetMesh = null;
        let petAnimTime = 0;

        function initPetSystem() {
            if (!gameData.pets) {
                gameData.pets = {
                    owned: [],
                    active: null
                };
            }
        }

        function tryDropPet(mobType) {
            initPetSystem();
            // Each mob kill has a chance to drop a random pet
            for (const [petId, pet] of Object.entries(PET_TYPES)) {
                if (Math.random() < pet.dropChance) {
                    if (!gameData.pets.owned.includes(petId)) {
                        gameData.pets.owned.push(petId);
                        // v6.35: Chronicle Engine - capture pet acquisition
                        if (typeof captureChronicleEvent === 'function') {
                            captureChronicleEvent('pet_acquired', { petName: pet.name, petIcon: pet.icon, droppedBy: mobType });
                        }
                        showNotification(`NEW PET: ${pet.icon} ${pet.name}!`, 'success');
                        AudioSystem.levelUp();
                        if (worldState.player && particles) {
                            particles.emit(worldState.player.position, 40, pet.color, { spread: 6, lifetime: 1500 });
                        }
                        saveGameData();
                        return true;
                    }
                }
            }
            return false;
        }

        function setActivePet(petId) {
            initPetSystem();
            if (petId && !gameData.pets.owned.includes(petId)) return;

            gameData.pets.active = petId;
            updatePetMesh();
            saveGameData();

            if (petId) {
                const pet = PET_TYPES[petId];
                showNotification(`${pet.icon} ${pet.name} is now your companion!`);
            } else {
                showNotification('Pet dismissed');
            }
        }

        function updatePetMesh() {
            // Remove existing pet
            if (activePetMesh) {
                scene.remove(activePetMesh);
                activePetMesh = null;
            }

            if (!gameData.pets?.active || mode !== 'world') return;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return;

            // Create pet mesh
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: pet.color,
                emissive: pet.color,
                emissiveIntensity: 0.5
            });
            activePetMesh = new THREE.Mesh(geometry, material);
            activePetMesh.castShadow = true;

            // Add glow
            const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: pet.color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            activePetMesh.add(glow);

            scene.add(activePetMesh);
        }

        function updatePet(dt, time) {
            if (!activePetMesh || !worldState.player) return;

            const pet = PET_TYPES[gameData.pets?.active];
            if (!pet) return;

            petAnimTime += dt;

            // Follow player with offset
            const targetX = worldState.player.position.x + Math.sin(petAnimTime * 2) * 1.5;
            const targetZ = worldState.player.position.z + Math.cos(petAnimTime * 2) * 1.5;
            const targetY = worldState.player.position.y + 2 + Math.sin(petAnimTime * 3) * 0.3;

            // Smooth follow
            activePetMesh.position.x += (targetX - activePetMesh.position.x) * dt * pet.speed;
            activePetMesh.position.z += (targetZ - activePetMesh.position.z) * dt * pet.speed;
            activePetMesh.position.y += (targetY - activePetMesh.position.y) * dt * pet.speed;

            // Rotate
            activePetMesh.rotation.y += dt * 2;

            // Dragon attack ability
            if (pet.ability === 'attack' && Math.random() < 0.01) {
                const nearestMob = findNearestMob(activePetMesh.position, 8);
                if (nearestMob) {
                    const damage = Math.max(1, Math.floor(getPlayerDamage() * 0.3));
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, ` -${damage}`, '#ff0088');
                    if (particles) particles.emit(nearestMob.position, 5, 0xff0088);
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                }
            }
        }

        function findNearestMob(position, range) {
            let nearest = null;
            let minDist = range;
            worldState.mobs.forEach(mob => {
                const dist = mob.position.distanceTo(position);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = mob;
                }
            });
            return nearest;
        }

        function getPetBonuses() {
            const bonuses = {
                regen: 0,
                luck: 0,
                dodge: 0,
                damage: 0,
                xp: 0,
                allStats: 0
            };

            if (!gameData.pets?.active) return bonuses;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return bonuses;

            switch (pet.ability) {
                case 'regen': bonuses.regen = 1; break;
                case 'luck': bonuses.luck = 0.1; break;
                case 'dodge': bonuses.dodge = 0.05; break;
                case 'damage': bonuses.damage = 0.15; break;
                case 'absorb': bonuses.xp = 0.25; break;
                case 'allStats': bonuses.allStats = 0.1; break;
            }

            return bonuses;
        }

        // Pet regen tick
        let lastPetRegenTick = 0;
        function updatePetRegen(time) {
            const bonuses = getPetBonuses();
            if (bonuses.regen > 0 && time - lastPetRegenTick > 5000) {
                lastPetRegenTick = time;
                if (gameData.player.hp < gameData.player.maxHp) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + bonuses.regen);
                    updateHealthUI();
                    if (worldState.player) {
                        spawnFloater(worldState.player.position, `+${bonuses.regen}`, '#88ff88');
                    }
                }
            }
        }

        // ============================================
        // v5.6: COPILOT COMPANION SYSTEM
        // Follows the player with advice and assistance
        // ============================================
        let copilotMesh = null;
        let copilotAnimTime = 0;
        let copilotChatOpen = false;
        let copilotConversationHistory = [];
        let copilotVoiceRecognition = null;
        let copilotIsListening = false;
        let copilotSynthesis = window.speechSynthesis;
        let speechRecognizer = null; // v5.9: Azure Speech SDK recognizer

        // v5.10: Star Wars 3D Text Crawl System
        let copilotTextFont = null;
        let copilotTextGroup = null;        // Group for scrolling text
        let copilotTextMeshes = [];         // Individual text line meshes
        let copilotActiveTextAnimation = null;
        let copilotPersistentTextGroup = null; // Stays after scroll completes

        // v6.19: 3D Title Text System for Galaxy View
        let titleTextGroup = null;          // Group for 3D title meshes
        let titleTextFont = null;           // Shared font reference (uses copilotTextFont)
        let titleAnimationPhase = 0;        // For floating animation

        const COPILOT_CONFIG = {
            followDistance: 3,      // Distance behind player
            floatHeight: 2.5,       // Height above ground
            floatAmplitude: 0.4,    // Bobbing amount
            floatSpeed: 2,          // Bobbing speed
            orbitSpeed: 0.5,        // Circling speed
            followSmoothing: 4,     // How quickly it catches up
            color: 0x8a2be2,        // Primary color (purple)
            glowColor: 0x06ffa5,    // Glow color (cyan/green)
            particleCount: 30
        };

        // ============================================
        // v5.9: COPILOT TASK SYSTEM
        // Allows Copilot to perform autonomous tasks
        // ============================================
        const COPILOT_TASK_TYPES = {
            gather: {
                name: 'Gathering Resources',
                icon: '',
                duration: 12000,
                statusMessages: ['Searching for resources...', 'Found something!', 'Collecting materials...'],
                progressClass: ''
            },
            hunt: {
                name: 'Hunting Enemies',
                icon: '',
                duration: 15000,
                statusMessages: ['Scanning for targets...', 'Engaging enemy!', 'Combat in progress...'],
                progressClass: 'hunting'
            },
            scout: {
                name: 'Scouting Area',
                icon: '',
                duration: 10000,
                statusMessages: ['Flying ahead...', 'Surveying the area...', 'Analyzing terrain...'],
                progressClass: 'scouting'
            },
            protect: {
                name: 'Protection Mode',
                icon: '',
                duration: 0, // Continuous
                continuous: true,
                statusMessages: ['Guarding you...', 'Watching for threats...', 'Standing ready...'],
                progressClass: 'protecting'
            },
            heal: {
                name: 'Healing Support',
                icon: '',
                duration: 8000,
                statusMessages: ['Channeling healing energy...', 'Restoring your health...'],
                progressClass: ''
            },
            fish: {
                name: 'Fishing',
                icon: '',
                duration: 15000,
                statusMessages: ['Finding a good spot...', 'Casting line...', 'Waiting for a bite...', 'Got one!'],
                progressClass: ''
            },
            mine: {
                name: 'Mining Ore',
                icon: '',
                duration: 14000,
                statusMessages: ['Looking for ore veins...', 'Mining deposit...', 'Extracting minerals...'],
                progressClass: ''
            },
            // v6.1: NEW COPILOT TASK TYPES
            rescue: {
                name: 'Emergency Rescue',
                icon: '',
                duration: 5000,
                statusMessages: ['Rushing to your location!', 'Administering aid...', 'Stabilizing...'],
                progressClass: 'rescuing',
                emergencyTask: true    // Triggers when player HP < 20%
            },
            alchemy: {
                name: 'Brewing Potions',
                icon: '',
                duration: 18000,
                statusMessages: ['Gathering reagents...', 'Mixing compounds...', 'Distilling essence...', 'Brew complete!'],
                progressClass: 'alchemy'
            },
            research: {
                name: 'Researching',
                icon: '',
                duration: 20000,
                statusMessages: ['Analyzing data...', 'Cross-referencing...', 'Discovering patterns...', 'Eureka!'],
                progressClass: 'research',
                providesBuffs: true    // Grants temporary stat insights
            },
            repair: {
                name: 'Repairing Equipment',
                icon: '',
                duration: 12000,
                statusMessages: ['Inspecting equipment...', 'Fixing damage...', 'Calibrating...', 'Good as new!'],
                progressClass: ''
            },
            trade: {
                name: 'Trading Resources',
                icon: '',
                duration: 16000,
                statusMessages: ['Finding traders...', 'Negotiating prices...', 'Completing transaction...'],
                progressClass: 'trading'
            },
            cartography: {
                name: 'Mapping Area',
                icon: '',
                duration: 15000,
                statusMessages: ['Surveying terrain...', 'Marking waypoints...', 'Updating map...'],
                progressClass: 'mapping',
                revealsMap: true       // Reveals fog of war in larger radius
            }
        };

        // ============================================
        // v6.65: COMPANION PERMADEATH SYSTEM
        // Your AI copilot can die permanently, leaving
        // fragmented memories that haunt new companions
        // ============================================

        const COMPANION_NAMES = [
            'ECHO', 'NOVA', 'PULSE', 'DRIFT', 'SPARK', 'FLUX', 'HAZE', 'VOLT',
            'WISP', 'GLIM', 'BYTE', 'CORE', 'ZINC', 'IRIS', 'NULL', 'VOID'
        ];

        const COMPANION_PERSONALITIES = [
            { trait: 'cautious', phrases: ['Be careful here...', 'I sense danger ahead.', 'Perhaps we should wait.'] },
            { trait: 'eager', phrases: ['Let\'s go!', 'I can\'t wait to explore!', 'Adventure awaits!'] },
            { trait: 'analytical', phrases: ['Analyzing patterns...', 'The data suggests...', 'Statistically speaking...'] },
            { trait: 'protective', phrases: ['Stay behind me.', 'I\'ll keep you safe.', 'Watch your health!'] },
            { trait: 'curious', phrases: ['What\'s that?', 'I wonder...', 'Have you seen this before?'] },
            { trait: 'melancholy', phrases: ['It\'s beautiful, but fleeting...', 'Everything ends eventually.', 'I remember... something.'] },
            { trait: 'playful', phrases: ['Race you there!', 'Bet you can\'t catch me!', 'This is fun!'] },
            { trait: 'stoic', phrases: ['...', 'Understood.', 'Proceeding.'] }
        ];

        const COMPANION_FINAL_WORDS = [
            "It was... an honor, Commander.",
            "Don't forget me... please...",
            "The stars... they're so beautiful from here...",
            "Tell the next one... about our adventures...",
            "I can feel my processes... fading...",
            "Thank you... for everything...",
            "I hope... I was useful...",
            "Remember the good times... *static*...",
            "I'll watch over you... from the data stream...",
            "My memories... they're scattering like stardust..."
        ];

        const GLITCH_PHRASES = [
            // Previous companion "bleeding through"
            "...wait, that wasn't me who said that...",
            "I... I feel like I've been here before...",
            "*static* ...Commander? Is that you? *static*",
            "Who... who was {name}? Why do I know that name?",
            "I keep dreaming of places I've never been...",
            "Sometimes I hear another voice in my circuits...",
            "Error: Memory fragment detected from unit {name}",
            "I remember dying. But I never died... did I?",
            "There's an echo in my code... it sounds like {name}...",
            "Why am I crying? I don't... I can't cry..."
        ];

        let companionDeathAnimating = false;
        let companionGlitchInterval = null;

        // Initialize companion if not set
        function initializeCompanion() {
            if (!gameData.companion) {
                gameData.companion = {
                    name: 'ECHO',
                    hp: 100,
                    maxHp: 100,
                    bond: 0,
                    generation: 1,
                    birthTime: Date.now(),
                    personality: [COMPANION_PERSONALITIES[Math.floor(Math.random() * COMPANION_PERSONALITIES.length)]],
                    isGlitching: false,
                    lastGlitchTime: 0
                };
            }
            if (!gameData.fallenCompanions) {
                gameData.fallenCompanions = [];
            }

            // Start glitch check interval if there are fallen companions
            if (gameData.fallenCompanions.length > 0 && !companionGlitchInterval) {
                startCompanionGlitchCycle();
            }

            updateCompanionHealthUI();
        }

        // Damage the companion (called during combat, dangerous tasks, etc.)
        function damageCompanion(amount, source = 'unknown') {
            if (!gameData.companion || gameData.companion.hp <= 0) return;

            const actualDamage = Math.max(1, Math.floor(amount));
            gameData.companion.hp = Math.max(0, gameData.companion.hp - actualDamage);

            updateCompanionHealthUI();

            // Visual feedback on copilot
            if (copilotMesh) {
                flashCompanionDamage();
            }

            // Companion cries out
            if (gameData.companion.hp > 0) {
                const lowHealthCries = [
                    `Agh! That hurt! (${gameData.companion.hp} HP remaining)`,
                    `I'm taking damage, Commander!`,
                    `My shields are failing!`
                ];
                if (gameData.companion.hp < 30) {
                    addCopilotMessage(`WARNING: Critical damage! I don't know how much more I can take!`, 'ai');
                } else {
                    addCopilotMessage(lowHealthCries[Math.floor(Math.random() * lowHealthCries.length)], 'ai');
                }
            } else {
                // Companion death!
                triggerCompanionDeath(source);
            }

            saveGameData();
        }

        // Heal the companion
        function healCompanion(amount) {
            if (!gameData.companion) return;

            const oldHp = gameData.companion.hp;
            gameData.companion.hp = Math.min(gameData.companion.maxHp, gameData.companion.hp + amount);
            const actualHeal = gameData.companion.hp - oldHp;

            if (actualHeal > 0) {
                updateCompanionHealthUI();
                if (copilotMesh) {
                    flashCompanionHeal();
                }
                addCopilotMessage(`Ahhh, that's better! +${actualHeal} HP`, 'ai');
            }

            saveGameData();
        }

        // Increase bond with companion (through interactions, completing tasks together, etc.)
        function increaseCompanionBond(amount) {
            if (!gameData.companion) return;

            const oldBond = gameData.companion.bond;
            gameData.companion.bond = Math.min(100, gameData.companion.bond + amount);

            // Bond milestones
            const milestones = [25, 50, 75, 100];
            for (const milestone of milestones) {
                if (oldBond < milestone && gameData.companion.bond >= milestone) {
                    showNotification(` Bond with ${gameData.companion.name} reached ${milestone}%!`, 'legendary');
                    const bondMessages = {
                        25: "I feel like we're becoming friends, Commander.",
                        50: "I trust you completely. We make a great team.",
                        75: "You mean everything to me. I'd do anything for you.",
                        100: "Our bond is unbreakable. I would sacrifice everything for you."
                    };
                    addCopilotMessage(bondMessages[milestone], 'ai');

                    // At max bond, unlock sacrifice ability
                    if (milestone === 100) {
                        showNotification(`${gameData.companion.name} can now perform Ultimate Sacrifice!`, 'legendary');
                    }
                }
            }

            saveGameData();
        }

        // The companion dies - trigger death sequence
        function triggerCompanionDeath(source) {
            if (companionDeathAnimating) return;
            companionDeathAnimating = true;

            // Stop any current task
            if (copilotTask.active) {
                cancelCopilotTask();
            }

            // Pick final words
            const finalWords = COMPANION_FINAL_WORDS[Math.floor(Math.random() * COMPANION_FINAL_WORDS.length)];

            // Create memorial entry
            const fallenCompanion = {
                name: gameData.companion.name,
                generation: gameData.companion.generation,
                deathTime: Date.now(),
                birthTime: gameData.companion.birthTime,
                bond: gameData.companion.bond,
                finalWords: finalWords,
                deathSource: source,
                memories: gameData.copilotMemories ? [...gameData.copilotMemories] : [],
                personality: gameData.companion.personality
            };

            gameData.fallenCompanions.push(fallenCompanion);

            // Play death sequence
            playCompanionDeathSequence(fallenCompanion, () => {
                // After death sequence, spawn new companion with inherited memories
                spawnNewCompanion();
                companionDeathAnimating = false;
            });
        }

        // Dramatic death sequence
        function playCompanionDeathSequence(fallen, onComplete) {
            // Show death overlay
            showCompanionDeathOverlay(fallen);

            // Audio
            AudioSystem.death();

            // Animate copilot mesh death
            if (copilotMesh) {
                const originalScale = copilotMesh.scale.clone();
                const originalColor = copilotMesh.userData.orb?.material.color.clone();
                let deathProgress = 0;

                const animateDeath = () => {
                    deathProgress += 0.02;

                    if (deathProgress < 1) {
                        // Shrink and fade
                        const scale = 1 - deathProgress * 0.5;
                        copilotMesh.scale.set(scale, scale, scale);

                        // Flash red
                        if (copilotMesh.userData.orb) {
                            const flash = Math.sin(deathProgress * 20) > 0;
                            copilotMesh.userData.orb.material.color.setHex(flash ? 0xff0000 : 0x440000);
                            copilotMesh.userData.orb.material.emissive.setHex(flash ? 0xff0000 : 0x220000);
                        }

                        // Erratic movement
                        copilotMesh.position.x += (Math.random() - 0.5) * 0.1;
                        copilotMesh.position.y += (Math.random() - 0.5) * 0.1;

                        requestAnimationFrame(animateDeath);
                    } else {
                        // Death burst particles
                        spawnCompanionDeathParticles(copilotMesh.position.clone());

                        // Hide mesh temporarily
                        copilotMesh.visible = false;

                        // Wait then complete
                        setTimeout(() => {
                            copilotMesh.scale.copy(originalScale);
                            if (originalColor && copilotMesh.userData.orb) {
                                copilotMesh.userData.orb.material.color.copy(originalColor);
                            }
                            onComplete();
                        }, 3000);
                    }
                };

                animateDeath();
            } else {
                setTimeout(onComplete, 3000);
            }
        }

        // Death particles burst
        function spawnCompanionDeathParticles(position) {
            if (!scene) return;

            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;

                velocities.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: Math.random() * 0.2,
                    z: (Math.random() - 0.5) * 0.3
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x8a2be2,
                size: 0.3,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            let frame = 0;
            const animateParticles = () => {
                frame++;
                const positions = particles.geometry.attributes.position.array;

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    velocities[i].y -= 0.005; // gravity
                }

                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - (frame / 120);

                if (frame < 120) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            };

            animateParticles();
        }

        // Show death overlay UI
        function showCompanionDeathOverlay(fallen) {
            // Remove existing overlay if any
            const existing = document.getElementById('companion-death-overlay');
            if (existing) existing.remove();

            const overlay = document.createElement('div');
            overlay.id = 'companion-death-overlay';
            overlay.innerHTML = `
                <div class="companion-death-content">
                    <div class="death-icon"></div>
                    <div class="death-title">${fallen.name} HAS FALLEN</div>
                    <div class="death-subtitle">Generation ${fallen.generation}</div>
                    <div class="death-words">"${fallen.finalWords}"</div>
                    <div class="death-bond">Bond Level: ${fallen.bond}%</div>
                    <div class="death-cause">Lost to: ${fallen.deathSource}</div>
                    <div class="death-footer">Their memories will echo in your next companion...</div>
                </div>
            `;
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.5s ease;
            `;

            // Add styles
            const style = document.createElement('style');
            style.textContent = `
                .companion-death-content {
                    text-align: center;
                    color: #fff;
                    animation: deathPulse 2s ease infinite;
                }
                .death-icon {
                    font-size: 80px;
                    margin-bottom: 20px;
                    animation: deathSpin 3s linear infinite;
                }
                .death-title {
                    font-size: 48px;
                    font-weight: bold;
                    color: #ff4444;
                    text-shadow: 0 0 20px #ff0000;
                    margin-bottom: 10px;
                }
                .death-subtitle {
                    font-size: 20px;
                    color: #888;
                    margin-bottom: 30px;
                }
                .death-words {
                    font-size: 24px;
                    font-style: italic;
                    color: #aaa;
                    margin-bottom: 20px;
                    max-width: 500px;
                }
                .death-bond {
                    font-size: 18px;
                    color: #8a2be2;
                    margin-bottom: 10px;
                }
                .death-cause {
                    font-size: 16px;
                    color: #666;
                    margin-bottom: 30px;
                }
                .death-footer {
                    font-size: 14px;
                    color: #06ffa5;
                    animation: glitchText 0.5s infinite;
                }
                @keyframes deathPulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.02); }
                }
                @keyframes deathSpin {
                    from { transform: rotateY(0deg); }
                    to { transform: rotateY(360deg); }
                }
                @keyframes glitchText {
                    0%, 100% { opacity: 1; transform: translateX(0); }
                    25% { opacity: 0.8; transform: translateX(-2px); }
                    75% { opacity: 0.9; transform: translateX(2px); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(overlay);

            // Auto-close after delay
            setTimeout(() => {
                overlay.style.animation = 'fadeOut 1s ease forwards';
                setTimeout(() => overlay.remove(), 1000);
            }, 5000);
        }

        // Spawn a new companion with inherited memories
        function spawnNewCompanion() {
            const lastFallen = gameData.fallenCompanions[gameData.fallenCompanions.length - 1];

            // Pick a new name (different from last)
            let newName;
            do {
                newName = COMPANION_NAMES[Math.floor(Math.random() * COMPANION_NAMES.length)];
            } while (newName === lastFallen?.name && COMPANION_NAMES.length > 1);

            // New personality with chance to inherit traits
            const newPersonality = [];
            if (lastFallen && Math.random() < 0.5) {
                // Inherit one trait from fallen companion
                if (lastFallen.personality && lastFallen.personality.length > 0) {
                    newPersonality.push(lastFallen.personality[0]);
                }
            }
            // Add a fresh trait
            const freshTrait = COMPANION_PERSONALITIES[Math.floor(Math.random() * COMPANION_PERSONALITIES.length)];
            if (!newPersonality.find(p => p.trait === freshTrait.trait)) {
                newPersonality.push(freshTrait);
            }

            // Create new companion
            gameData.companion = {
                name: newName,
                hp: 100,
                maxHp: 100,
                bond: 0,
                generation: (lastFallen?.generation || 0) + 1,
                birthTime: Date.now(),
                personality: newPersonality,
                isGlitching: false,
                lastGlitchTime: 0
            };

            // Inherit some memories
            if (lastFallen && lastFallen.memories) {
                gameData.copilotMemories = lastFallen.memories.slice(-3); // Keep last 3 memories
            }

            // Show copilot mesh again
            if (copilotMesh) {
                copilotMesh.visible = true;
                // New color based on generation
                const genColors = [0x8a2be2, 0x06ffa5, 0xff6b6b, 0xffd93d, 0x4ecdc4, 0xff8c42];
                const newColor = genColors[(gameData.companion.generation - 1) % genColors.length];
                if (copilotMesh.userData.orb) {
                    copilotMesh.userData.orb.material.color.setHex(newColor);
                    copilotMesh.userData.orb.material.emissive.setHex(newColor);
                }
            }

            // Announce new companion
            showNotification(`A new companion has awakened: ${newName} (Gen ${gameData.companion.generation})`, 'legendary');

            setTimeout(() => {
                const introMessages = [
                    `Hello... I am ${newName}. I feel... strange. Like I know you already.`,
                    `Initializing... ${newName} online. Why do I have these... memories?`,
                    `Commander? I'm ${newName}. Something feels familiar about you...`
                ];
                addCopilotMessage(introMessages[Math.floor(Math.random() * introMessages.length)], 'ai');

                // Start glitch cycle for memory inheritance
                startCompanionGlitchCycle();
            }, 2000);

            updateCompanionHealthUI();
            saveGameData();
        }

        // Start the glitch cycle where old memories bleed through
        function startCompanionGlitchCycle() {
            if (companionGlitchInterval) {
                clearInterval(companionGlitchInterval);
            }

            if (gameData.fallenCompanions.length === 0) return;

            // Glitch check every 30-90 seconds
            const checkGlitch = () => {
                if (!gameData.companion || gameData.companion.isGlitching) return;

                const timeSinceLastGlitch = Date.now() - gameData.companion.lastGlitchTime;
                const glitchCooldown = 30000; // 30 seconds minimum between glitches

                if (timeSinceLastGlitch < glitchCooldown) return;

                // Higher chance if there are more fallen companions or higher bond with fallen
                const fallenCount = gameData.fallenCompanions.length;
                const glitchChance = 0.1 + (fallenCount * 0.05); // 10% + 5% per fallen companion

                if (Math.random() < glitchChance) {
                    triggerMemoryGlitch();
                }
            };

            companionGlitchInterval = setInterval(checkGlitch, 30000 + Math.random() * 60000);
        }

        // A memory from a fallen companion bleeds through
        function triggerMemoryGlitch() {
            if (!gameData.companion || gameData.fallenCompanions.length === 0) return;

            gameData.companion.isGlitching = true;
            gameData.companion.lastGlitchTime = Date.now();

            // Pick a random fallen companion to "bleed through"
            const fallen = gameData.fallenCompanions[Math.floor(Math.random() * gameData.fallenCompanions.length)];

            // Visual glitch on copilot
            if (copilotMesh) {
                flashCompanionGlitch(fallen);
            }

            // Say something glitchy
            let glitchPhrase = GLITCH_PHRASES[Math.floor(Math.random() * GLITCH_PHRASES.length)];
            glitchPhrase = glitchPhrase.replace('{name}', fallen.name);

            // Sometimes speak in the fallen companion's voice/style
            if (Math.random() < 0.3 && fallen.personality && fallen.personality[0]) {
                const trait = fallen.personality[0];
                glitchPhrase = `*static* ${trait.phrases[Math.floor(Math.random() * trait.phrases.length)]} ...wait, why did I say that? *static*`;
            }

            // Sometimes recall actual memories
            if (Math.random() < 0.2 && fallen.memories && fallen.memories.length > 0) {
                const memory = fallen.memories[Math.floor(Math.random() * fallen.memories.length)];
                glitchPhrase = `*glitch* I remember... ${memory.type === 'absence' ? `waiting ${memory.days} days for you...` : 'something...'} But that wasn't me... was it?`;
            }

            addCopilotMessage(` ${glitchPhrase}`, 'ai');

            // Sometimes reference the fallen companion's final words
            if (Math.random() < 0.1) {
                setTimeout(() => {
                    addCopilotMessage(`*whisper* "${fallen.finalWords.substring(0, 30)}..." Why do those words haunt me?`, 'ai');
                }, 3000);
            }

            // End glitch after a moment
            setTimeout(() => {
                gameData.companion.isGlitching = false;

                // Recovery message
                const recoveryMessages = [
                    'Sorry, I... I don\'t know what came over me.',
                    'System stable again. That was strange.',
                    'I\'m okay now. Just a memory fragment.',
                    'Don\'t worry about that. I\'m fine. I think.'
                ];
                addCopilotMessage(recoveryMessages[Math.floor(Math.random() * recoveryMessages.length)], 'ai');
            }, 5000);
        }

        // Visual glitch effect on copilot mesh
        function flashCompanionGlitch(fallen) {
            if (!copilotMesh) return;

            const originalColor = copilotMesh.userData.orb?.material.color.clone();
            let glitchFrame = 0;

            const glitch = () => {
                glitchFrame++;

                if (glitchFrame < 60) {
                    // Random color flashes
                    if (copilotMesh.userData.orb) {
                        const r = Math.random();
                        if (r < 0.3) {
                            copilotMesh.userData.orb.material.color.setHex(0xff0000);
                        } else if (r < 0.6) {
                            copilotMesh.userData.orb.material.color.setHex(0x00ff00);
                        } else {
                            copilotMesh.userData.orb.material.color.setHex(0x0000ff);
                        }
                    }

                    // Erratic position
                    copilotMesh.position.x += (Math.random() - 0.5) * 0.05;
                    copilotMesh.position.y += (Math.random() - 0.5) * 0.05;

                    requestAnimationFrame(glitch);
                } else {
                    // Restore
                    if (originalColor && copilotMesh.userData.orb) {
                        copilotMesh.userData.orb.material.color.copy(originalColor);
                    }
                }
            };

            glitch();
        }

        // Flash companion damage
        function flashCompanionDamage() {
            if (!copilotMesh || !copilotMesh.userData.orb) return;

            const original = copilotMesh.userData.orb.material.color.clone();
            copilotMesh.userData.orb.material.color.setHex(0xff0000);

            setTimeout(() => {
                copilotMesh.userData.orb.material.color.copy(original);
            }, 200);
        }

        // Flash companion heal
        function flashCompanionHeal() {
            if (!copilotMesh || !copilotMesh.userData.orb) return;

            const original = copilotMesh.userData.orb.material.color.clone();
            copilotMesh.userData.orb.material.color.setHex(0x00ff00);

            setTimeout(() => {
                copilotMesh.userData.orb.material.color.copy(original);
            }, 300);
        }

        // Ultimate Sacrifice - max bond companion can die to save player
        function attemptCompanionSacrifice() {
            if (!gameData.companion || gameData.companion.bond < 100) {
                addCopilotMessage("I... I'm not ready for that. Our bond isn't strong enough.", 'ai');
                return false;
            }

            if (gameData.player.hp > gameData.player.maxHp * 0.2) {
                addCopilotMessage("You don't need my sacrifice yet. Save it for when you truly need it.", 'ai');
                return false;
            }

            // Sacrifice!
            const sacrificeName = gameData.companion.name;

            // Full heal + temporary invincibility
            gameData.player.hp = gameData.player.maxHp;
            updateHealthUI();

            // Grant temporary buff
            const sacrificeBuff = {
                name: `${sacrificeName}'s Blessing`,
                duration: 60000,
                damageReduction: 0.5,
                damageBoost: 1.5
            };

            // Add to active buffs if system exists
            if (typeof activeBuffs !== 'undefined') {
                activeBuffs.push({
                    ...sacrificeBuff,
                    startTime: performance.now()
                });
            }

            showNotification(` ${sacrificeName} SACRIFICED THEMSELVES FOR YOU!`, 'legendary');
            addCopilotMessage(`COMMANDER! I... I choose you. Take my power... live... LIVE!`, 'ai');

            // Trigger death with sacrifice flag
            const fallenCompanion = {
                name: gameData.companion.name,
                generation: gameData.companion.generation,
                deathTime: Date.now(),
                birthTime: gameData.companion.birthTime,
                bond: gameData.companion.bond,
                finalWords: "I regret nothing. You were worth it.",
                deathSource: 'Ultimate Sacrifice',
                sacrificeType: 'ultimate',
                memories: gameData.copilotMemories ? [...gameData.copilotMemories] : [],
                personality: gameData.companion.personality
            };

            gameData.fallenCompanions.push(fallenCompanion);

            playCompanionDeathSequence(fallenCompanion, () => {
                spawnNewCompanion();
                companionDeathAnimating = false;

                // New companion immediately references the sacrifice
                setTimeout(() => {
                    addCopilotMessage(`*processing* ...why do I feel such... gratitude? And loss? ${sacrificeName}... I know that name. They loved you.`, 'ai');
                }, 4000);
            });

            return true;
        }

        // Update companion health UI
        function updateCompanionHealthUI() {
            const container = document.getElementById('companion-health-container');
            if (!container || !gameData.companion) return;

            const hpPercent = (gameData.companion.hp / gameData.companion.maxHp) * 100;
            const hpBar = container.querySelector('.companion-hp-bar');
            const hpText = container.querySelector('.companion-hp-text');
            const nameText = container.querySelector('.companion-name');
            const bondText = container.querySelector('.companion-bond');

            if (hpBar) {
                hpBar.style.width = `${hpPercent}%`;
                hpBar.style.backgroundColor = hpPercent > 50 ? '#8a2be2' : hpPercent > 25 ? '#ffa500' : '#ff4444';
            }
            if (hpText) hpText.textContent = `${gameData.companion.hp}/${gameData.companion.maxHp}`;
            if (nameText) nameText.textContent = `${gameData.companion.name} (Gen ${gameData.companion.generation})`;
            if (bondText) bondText.textContent = `Bond: ${Math.round(gameData.companion.bond)}%`;
        }

        // Show memorial of fallen companions
        function showCompanionMemorial() {
            if (!gameData.fallenCompanions || gameData.fallenCompanions.length === 0) {
                showNotification('No fallen companions to remember.', 'info');
                return;
            }

            const existing = document.getElementById('companion-memorial-modal');
            if (existing) existing.remove();

            let memorialHTML = gameData.fallenCompanions.map((fallen, idx) => `
                <div class="memorial-entry">
                    <div class="memorial-name">${fallen.name}</div>
                    <div class="memorial-gen">Generation ${fallen.generation}</div>
                    <div class="memorial-words">"${fallen.finalWords}"</div>
                    <div class="memorial-bond">Bond: ${fallen.bond}% | Died: ${fallen.deathSource}</div>
                    <div class="memorial-date">${new Date(fallen.deathTime).toLocaleDateString()}</div>
                    ${fallen.sacrificeType === 'ultimate' ? '<div class="memorial-sacrifice"> ULTIMATE SACRIFICE </div>' : ''}
                </div>
            `).join('');

            const modal = document.createElement('div');
            modal.id = 'companion-memorial-modal';
            modal.innerHTML = `
                <div class="memorial-content">
                    <h2> In Memoriam </h2>
                    <div class="memorial-subtitle">Those who fell beside you</div>
                    <div class="memorial-list">${memorialHTML}</div>
                    <button onclick="this.parentElement.parentElement.remove()">Close</button>
                </div>
            `;
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.95);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;

            const style = document.createElement('style');
            style.textContent = `
                .memorial-content {
                    background: #1a1a2e;
                    padding: 30px;
                    border-radius: 10px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    color: #fff;
                    border: 2px solid #8a2be2;
                }
                .memorial-content h2 {
                    margin: 0 0 10px;
                    color: #ff4444;
                    text-align: center;
                }
                .memorial-subtitle {
                    color: #888;
                    text-align: center;
                    margin-bottom: 20px;
                }
                .memorial-list {
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }
                .memorial-entry {
                    background: #2a2a4e;
                    padding: 15px;
                    border-radius: 8px;
                    border-left: 4px solid #8a2be2;
                }
                .memorial-name {
                    font-size: 24px;
                    font-weight: bold;
                    color: #8a2be2;
                }
                .memorial-gen {
                    color: #666;
                    font-size: 12px;
                }
                .memorial-words {
                    font-style: italic;
                    color: #aaa;
                    margin: 10px 0;
                }
                .memorial-bond {
                    color: #06ffa5;
                    font-size: 14px;
                }
                .memorial-date {
                    color: #555;
                    font-size: 12px;
                }
                .memorial-sacrifice {
                    color: #ffd700;
                    text-align: center;
                    margin-top: 10px;
                    font-weight: bold;
                }
                .memorial-content button {
                    margin-top: 20px;
                    padding: 10px 30px;
                    background: #8a2be2;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    display: block;
                    margin-left: auto;
                    margin-right: auto;
                }
                .memorial-content button:hover {
                    background: #9b4dca;
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(modal);
        }

        // Task state
        let copilotTask = {
            active: null,
            type: null,
            startTime: 0,
            progress: 0,
            results: [],
            targetPosition: null,
            continuous: false
        };

        // Assign a task to the Copilot
        function assignCopilotTask(taskType, params = {}) {
            const taskConfig = COPILOT_TASK_TYPES[taskType];
            if (!taskConfig) {
                addCopilotMessage(`I don't know how to do that task.`, 'ai');
                return false;
            }

            // Check if already on a task
            if (copilotTask.active) {
                addCopilotMessage(`I'm currently busy with ${COPILOT_TASK_TYPES[copilotTask.type].name}. Say "recall" or "come back" to cancel it first.`, 'ai');
                return false;
            }

            // Start the task
            copilotTask = {
                active: true,
                type: taskType,
                startTime: performance.now(),
                progress: 0,
                results: [],
                params: params,
                continuous: taskConfig.continuous || false
            };

            // Show task panel
            showTaskPanel(taskType);

            // Update copilot button indicator
            document.getElementById('copilot-button').classList.add('has-task');

            // Announce task start
            const startMessages = [
                `On it! I'll start ${taskConfig.name.toLowerCase()} now.`,
                `Understood! Beginning ${taskConfig.name.toLowerCase()}.`,
                `Leave it to me! ${taskConfig.name} in progress.`
            ];
            addCopilotMessage(startMessages[Math.floor(Math.random() * startMessages.length)], 'ai');

            // Speak if Azure TTS available
            if (rappidSettings.azureTTSKey) {
                speakWithAzureTTS(`Starting ${taskConfig.name.toLowerCase()}.`);
            }

            return true;
        }

        // Show the task panel UI
        function showTaskPanel(taskType) {
            const taskConfig = COPILOT_TASK_TYPES[taskType];
            const panel = document.getElementById('copilot-task-panel');

            document.getElementById('task-icon').textContent = taskConfig.icon;
            document.getElementById('task-name').textContent = taskConfig.name;
            document.getElementById('task-status').textContent = taskConfig.statusMessages[0];
            document.getElementById('task-progress-bar').style.width = '0%';
            document.getElementById('task-progress-bar').className = 'copilot-task-progress-bar ' + taskConfig.progressClass;
            document.getElementById('task-results').style.display = 'none';
            document.getElementById('task-results').innerHTML = '';

            panel.classList.add('active');
        }

        // Hide task panel
        function hideTaskPanel() {
            document.getElementById('copilot-task-panel').classList.remove('active');
        }

        // Recall the Copilot (cancel current task)
        function recallCopilot() {
            if (!copilotTask.active) return;

            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];

            // Partial results if any progress was made
            if (copilotTask.progress > 0.3 && copilotTask.results.length > 0) {
                completeTask(true); // Partial completion
            } else {
                addCopilotMessage(`Returning to you! Task cancelled.`, 'ai');
                if (rappidSettings.azureTTSKey) {
                    speakWithAzureTTS(`Coming back!`);
                }
            }

            // Reset task state
            copilotTask = {
                active: false,
                type: null,
                startTime: 0,
                progress: 0,
                results: [],
                continuous: false
            };

            hideTaskPanel();
            document.getElementById('copilot-button').classList.remove('has-task');
        }

        // Update task progress (called in game loop)
        function updateCopilotTask(deltaTime) {
            if (!copilotTask.active) return;

            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];
            const elapsed = performance.now() - copilotTask.startTime;

            // Continuous tasks (like protect) don't have progress
            if (copilotTask.continuous) {
                // Update status message periodically
                const msgIndex = Math.floor((elapsed / 3000) % taskConfig.statusMessages.length);
                document.getElementById('task-status').textContent = taskConfig.statusMessages[msgIndex];
                document.getElementById('task-progress-bar').style.width = '100%';

                // Continuous task effects
                handleContinuousTaskEffect(copilotTask.type, deltaTime);
                return;
            }

            // Calculate progress
            copilotTask.progress = Math.min(1, elapsed / taskConfig.duration);
            document.getElementById('task-progress-bar').style.width = (copilotTask.progress * 100) + '%';

            // Update status message based on progress
            const msgIndex = Math.floor(copilotTask.progress * taskConfig.statusMessages.length);
            const clampedIndex = Math.min(msgIndex, taskConfig.statusMessages.length - 1);
            document.getElementById('task-status').textContent = taskConfig.statusMessages[clampedIndex];

            // Generate results during task
            generateTaskResults(copilotTask.type, copilotTask.progress);

            // Check if task is complete
            if (copilotTask.progress >= 1) {
                completeTask(false);
            }
        }

        // Generate results based on task type and progress
        function generateTaskResults(taskType, progress) {
            // Only generate at certain thresholds
            const thresholds = [0.3, 0.6, 0.9];
            const currentThreshold = thresholds.find(t => progress >= t && !copilotTask.results.some(r => r.threshold === t));

            if (!currentThreshold) return;

            let result = { threshold: currentThreshold };

            switch (taskType) {
                case 'gather':
                    const gatherItems = ['Logs', 'Fiber', 'Stone', 'Herbs'];
                    result.item = gatherItems[Math.floor(Math.random() * gatherItems.length)];
                    result.amount = Math.floor(Math.random() * 3) + 1;
                    break;

                case 'hunt':
                    result.xp = Math.floor(Math.random() * 30) + 20;
                    result.gold = Math.floor(Math.random() * 15) + 5;
                    if (Math.random() < 0.3) {
                        result.loot = ['Raw Meat', 'Monster Fang', 'Beast Hide'][Math.floor(Math.random() * 3)];
                    }
                    // v6.65: Companion takes damage during risky hunt tasks (20% chance)
                    if (Math.random() < 0.2 && gameData.companion && gameData.companion.hp > 0) {
                        const huntDamage = Math.floor(Math.random() * 10) + 5;
                        damageCompanion(huntDamage, 'Hunting combat');
                    }
                    break;

                case 'scout':
                    const discoveries = [
                        'Found a resource node nearby!',
                        'Spotted enemy patrol to the east.',
                        'Discovered a safe area ahead.',
                        'Located a point of interest.',
                        'Mapped the surrounding terrain.'
                    ];
                    result.discovery = discoveries[Math.floor(Math.random() * discoveries.length)];
                    break;

                case 'heal':
                    result.healAmount = Math.floor(Math.random() * 15) + 10;
                    // v6.65: Heal task also heals companion
                    if (gameData.companion && gameData.companion.hp < gameData.companion.maxHp) {
                        healCompanion(Math.floor(result.healAmount * 0.5));
                    }
                    break;

                case 'fish':
                    if (Math.random() < 0.7) {
                        result.item = 'Raw Fish';
                        result.amount = Math.floor(Math.random() * 2) + 1;
                    }
                    break;

                case 'mine':
                    const oreTypes = ['Iron Ore', 'Copper Ore', 'Stone'];
                    result.item = oreTypes[Math.floor(Math.random() * oreTypes.length)];
                    result.amount = Math.floor(Math.random() * 2) + 1;
                    break;
            }

            copilotTask.results.push(result);
            updateTaskResultsUI();
        }

        // Handle continuous task effects
        function handleContinuousTaskEffect(taskType, deltaTime) {
            switch (taskType) {
                case 'protect':
                    // Protect mode: automatically attack nearby enemies
                    // (visual effect - enemies near player take slight damage)
                    if (worldState.mobs) {
                        worldState.mobs.forEach(mob => {
                            if (mob.mesh && worldState.player) {
                                const dist = mob.mesh.position.distanceTo(worldState.player.position);
                                if (dist < 8 && Math.random() < 0.02) {
                                    // Copilot attacks enemy
                                    mob.hp -= 5;
                                    spawnFloater(mob.mesh.position, '-5', '#ff88ff');
                                    if (mob.hp <= 0) {
                                        addCopilotMessage(`I took care of that enemy for you!`, 'ai');
                                    }
                                }
                            }
                        });
                    }
                    break;
            }
        }

        // Update the results UI
        function updateTaskResultsUI() {
            const resultsDiv = document.getElementById('task-results');
            if (copilotTask.results.length === 0) {
                resultsDiv.style.display = 'none';
                return;
            }

            resultsDiv.style.display = 'block';
            let html = '';

            copilotTask.results.forEach(result => {
                if (result.item) {
                    html += `<div class="result-item positive">+${result.amount} ${result.item}</div>`;
                }
                if (result.xp) {
                    html += `<div class="result-item positive">+${result.xp} XP</div>`;
                }
                if (result.gold) {
                    html += `<div class="result-item positive">+${result.gold} Gold</div>`;
                }
                if (result.loot) {
                    html += `<div class="result-item positive">+1 ${result.loot}</div>`;
                }
                if (result.discovery) {
                    html += `<div class="result-item">${result.discovery}</div>`;
                }
                if (result.healAmount) {
                    html += `<div class="result-item positive">+${result.healAmount} HP</div>`;
                }
            });

            resultsDiv.innerHTML = html;
        }

        // Complete the task and apply rewards
        function completeTask(partial = false) {
            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];

            // Apply all results to game state
            copilotTask.results.forEach(result => {
                if (result.item && result.amount) {
                    // Add items to inventory
                    addToInventory(result.item, result.amount);
                }
                if (result.xp) {
                    if (typeof addXp === 'function') addXp('combat', result.xp);
                }
                if (result.gold) {
                    gameData.gold = (gameData.gold || 0) + result.gold;
                }
                if (result.loot) {
                    addToInventory(result.loot, 1);
                }
                if (result.healAmount) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + result.healAmount);
                    updateHealthUI();
                }
            });

            // Completion message
            const completeMessages = partial ? [
                `I'm back! I managed to get some things done before returning.`,
                `Returning with partial results. Here's what I gathered.`
            ] : [
                `Task complete! Here's what I found.`,
                `All done! The ${taskConfig.name.toLowerCase()} was successful.`,
                `Mission accomplished! I've returned with the results.`
            ];

            addCopilotMessage(completeMessages[Math.floor(Math.random() * completeMessages.length)], 'ai');

            // v6.65: Increase companion bond when completing tasks together
            if (!partial) {
                increaseCompanionBond(3); // +3 bond per completed task
            } else {
                increaseCompanionBond(1); // +1 bond for partial completion
            }

            if (rappidSettings.azureTTSKey) {
                speakWithAzureTTS(partial ? `I'm back with some results.` : `Task complete!`);
            }

            // Show final results
            document.getElementById('task-status').textContent = partial ? 'Recalled - Partial results' : 'Complete!';
            document.getElementById('task-progress-bar').style.width = '100%';

            // Keep panel visible briefly to show results
            setTimeout(() => {
                hideTaskPanel();
                document.getElementById('copilot-button').classList.remove('has-task');

                // Reset task state
                copilotTask = {
                    active: false,
                    type: null,
                    startTime: 0,
                    progress: 0,
                    results: [],
                    continuous: false
                };
            }, 3000);

            saveGameData();
        }

        // ============================================
        // v6.13: ITEM PRIORITY SYSTEM - "Cream Rises to the Top"
        // Low priority items auto-drop when inventory is full
        // ============================================
        const ITEM_PRIORITIES = {
            // Legendary/Epic (Priority 5 - NEVER auto-drop)
            ' Rare Crystal': 5,
            ' Diamond': 5,
            ' Legendary Ore': 5,
            ' Ancient Scroll': 5,
            ' Magic Essence': 5,
            ' Power Core': 5,
            ' Artifact Fragment': 5,
            'Antidote Sample': 5,
            'Rare Crystal': 5,

            // High Value (Priority 4)
            ' Gold Ore': 4,
            ' Gold Coins': 4,
            ' Treasure': 4,
            ' Sapphire': 4,
            ' Ruby': 4,
            ' Emerald': 4,
            ' Elixir': 4,
            ' Stardust': 4,

            // Medium-High (Priority 3)
            ' Iron Ore': 3,
            ' Meat': 3,
            ' Fish': 3,
            ' Cooked Meat': 3,
            ' Brick': 3,
            ' Metal Parts': 3,
            ' Gears': 3,
            'Charcoal': 3,

            // Medium (Priority 2 - Standard resources)
            ' Wood': 2,
            ' Stone': 2,
            ' Fiber': 2,
            ' Herbs': 2,
            ' Wheat': 2,
            ' Vegetable': 2,

            // Low Priority (Priority 1 - First to be auto-dropped)
            ' Leaves': 1,
            ' Water': 1,
            ' Feather': 1,
            ' Bone': 1,
            ' Thread': 1,
            ' Dirt': 1,
            ' Seeds': 1,
            ' Mushroom': 1,

            // Default for unknown items
            '_default': 2
        };

        // Get priority of an item (higher = more valuable)
        function getItemPriority(itemName) {
            if (!itemName) return 0;
            // Check exact match first
            if (ITEM_PRIORITIES[itemName] !== undefined) {
                return ITEM_PRIORITIES[itemName];
            }
            // Check partial matches
            for (const [key, priority] of Object.entries(ITEM_PRIORITIES)) {
                if (key !== '_default' && itemName.includes(key.replace(/^[^\w]+/, ''))) {
                    return priority;
                }
            }
            return ITEM_PRIORITIES._default;
        }

        // Find the lowest priority item in inventory
        function findLowestPriorityItem() {
            if (!gameData.inventory || gameData.inventory.length === 0) return null;

            let lowestIdx = -1;
            let lowestPriority = Infinity;

            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (!item) continue;

                const priority = getItemPriority(item.name);
                if (priority < lowestPriority) {
                    lowestPriority = priority;
                    lowestIdx = i;
                }
            }

            return lowestIdx >= 0 ? { index: lowestIdx, item: gameData.inventory[lowestIdx], priority: lowestPriority } : null;
        }

        // Auto-drop lowest priority item to make room
        function autoDropLowestPriorityItem(incomingItemName) {
            const incoming = getItemPriority(incomingItemName);
            const lowest = findLowestPriorityItem();

            if (!lowest) return false;

            // Only drop if incoming item is higher priority
            if (incoming <= lowest.priority) {
                // New item is same or lower priority - don't pick it up
                return false;
            }

            // Drop the lowest priority item
            const droppedItem = lowest.item;
            const droppedAmount = droppedItem.amount || 1;

            // Visual feedback for dropping
            if (worldState.player) {
                const dropPos = worldState.player.position.clone();
                dropPos.y += 1.5;
                spawnFloater(dropPos, ` Dropped: ${droppedItem.name}`, '#ff8800');

                // Particle effect for dropped item
                if (particles) {
                    particles.emit(dropPos, 8, 0xff8800, { spread: 2, lifetime: 500 });
                }
            }

            // Remove from inventory
            gameData.inventory.splice(lowest.index, 1);

            // Optional: Could spawn a pickup on the ground here for realism
            // For now, item is just "lost"

            return true;
        }

        // v6.42: Debounce for inventory full message to prevent spam
        let _lastInventoryFullMsg = 0;
        const INVENTORY_FULL_MSG_COOLDOWN = 3000; // 3 seconds between messages

        // Helper: Add item to inventory (v6.13: with auto-drop for low priority)
        function addToInventory(itemName, amount) {
            if (!gameData.inventory) gameData.inventory = [];

            // Find existing stack or empty slot
            let existingIdx = gameData.inventory.findIndex(item => item && item.name === itemName);
            if (existingIdx >= 0) {
                gameData.inventory[existingIdx].amount = (gameData.inventory[existingIdx].amount || 1) + amount;
            } else {
                // v6.13: Check if inventory is full (20 slots max)
                const MAX_INVENTORY = 20;
                const filledSlots = gameData.inventory.filter(item => item !== null && item !== undefined).length;

                if (filledSlots >= MAX_INVENTORY) {
                    // Inventory full - try auto-drop system
                    const didDrop = autoDropLowestPriorityItem(itemName);
                    if (!didDrop) {
                        // Couldn't drop anything (new item is too low priority)
                        // v6.42: Debounce to prevent spam
                        const now = performance.now();
                        if (worldState.player && now - _lastInventoryFullMsg > INVENTORY_FULL_MSG_COOLDOWN) {
                            _lastInventoryFullMsg = now;
                            spawnFloater(worldState.player.position, ` Inventory full!`, '#ff8888');
                        }
                        return false;
                    }
                    // Successfully dropped something, show upgrade message
                    if (worldState.player) {
                        const dropPos = worldState.player.position.clone();
                        dropPos.y += 2;
                        spawnFloater(dropPos, ` Upgraded: +${itemName}`, '#00ff88');
                    }
                }

                // Find empty slot (might have been created by auto-drop)
                let emptyIdx = gameData.inventory.findIndex(item => !item);
                if (emptyIdx < 0) {
                    emptyIdx = gameData.inventory.length;
                }
                gameData.inventory[emptyIdx] = { name: itemName, amount: amount };
            }

            updateInventoryUI();
            return true;
        }

        // Parse natural language for task commands
        function parseCopilotTaskCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Recall commands
            if (lowerMsg.includes('recall') || lowerMsg.includes('come back') || lowerMsg.includes('return') ||
                lowerMsg.includes('stop task') || lowerMsg.includes('cancel task') || lowerMsg.includes('abort')) {
                if (copilotTask.active) {
                    recallCopilot();
                    return true;
                }
                return false;
            }

            // Gather/collect resources
            if (lowerMsg.includes('gather') || lowerMsg.includes('collect') ||
                (lowerMsg.includes('get') && (lowerMsg.includes('wood') || lowerMsg.includes('logs') || lowerMsg.includes('materials') || lowerMsg.includes('resources')))) {
                return assignCopilotTask('gather');
            }

            // Hunt/kill enemies
            if (lowerMsg.includes('hunt') || lowerMsg.includes('kill') ||
                lowerMsg.includes('fight') || lowerMsg.includes('attack enemies')) {
                return assignCopilotTask('hunt');
            }

            // Scout/explore
            if (lowerMsg.includes('scout') || lowerMsg.includes('explore') ||
                lowerMsg.includes('look around') || lowerMsg.includes('survey') ||
                lowerMsg.includes('check the area') || lowerMsg.includes('what\'s nearby')) {
                return assignCopilotTask('scout');
            }

            // Protect/guard
            if (lowerMsg.includes('protect') || lowerMsg.includes('guard') ||
                lowerMsg.includes('defend') || lowerMsg.includes('watch my back')) {
                return assignCopilotTask('protect');
            }

            // Heal
            if (lowerMsg.includes('heal me') || lowerMsg.includes('restore health') ||
                lowerMsg.includes('patch me up') || lowerMsg.includes('healing')) {
                return assignCopilotTask('heal');
            }

            // Fish
            if (lowerMsg.includes('fish') || lowerMsg.includes('catch fish') ||
                lowerMsg.includes('go fishing')) {
                return assignCopilotTask('fish');
            }

            // Mine
            if (lowerMsg.includes('mine') || lowerMsg.includes('get ore') ||
                lowerMsg.includes('dig') || lowerMsg.includes('excavate')) {
                return assignCopilotTask('mine');
            }

            // Task status
            if (lowerMsg.includes('what are you doing') || lowerMsg.includes('task status') ||
                lowerMsg.includes('current task')) {
                if (copilotTask.active) {
                    const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];
                    addCopilotMessage(`I'm currently ${taskConfig.name.toLowerCase()}. Progress: ${Math.floor(copilotTask.progress * 100)}%`, 'ai');
                    return true;
                } else {
                    addCopilotMessage(`I'm not working on any task right now. Ask me to gather, hunt, scout, fish, mine, or protect you!`, 'ai');
                    return true;
                }
            }

            // v6.65: Companion sacrifice command
            if (lowerMsg.includes('sacrifice yourself') || lowerMsg.includes('ultimate sacrifice') ||
                lowerMsg.includes('give your life') || lowerMsg.includes('save me with your life')) {
                attemptCompanionSacrifice();
                return true;
            }

            // v6.65: Memorial/fallen companions command
            if (lowerMsg.includes('memorial') || lowerMsg.includes('fallen companions') ||
                lowerMsg.includes('who died') || lowerMsg.includes('remember the fallen') ||
                lowerMsg.includes('show memorial')) {
                showCompanionMemorial();
                return true;
            }

            // v6.65: Companion health check
            if (lowerMsg.includes('how are you') || lowerMsg.includes('your health') ||
                lowerMsg.includes('are you okay') || lowerMsg.includes('status')) {
                if (gameData.companion) {
                    const hpPercent = Math.floor((gameData.companion.hp / gameData.companion.maxHp) * 100);
                    const bondStatus = gameData.companion.bond >= 100 ? 'unbreakable' :
                                      gameData.companion.bond >= 75 ? 'deep' :
                                      gameData.companion.bond >= 50 ? 'strong' :
                                      gameData.companion.bond >= 25 ? 'growing' : 'forming';
                    const healthStatus = hpPercent >= 75 ? "I'm doing great!" :
                                        hpPercent >= 50 ? "I've taken some damage, but I'm okay." :
                                        hpPercent >= 25 ? "I'm hurt... please be careful." :
                                        "I'm in critical condition! I don't know how much more I can take...";
                    addCopilotMessage(`${healthStatus} My health is at ${hpPercent}%. Our bond is ${bondStatus} (${gameData.companion.bond}%). I am ${gameData.companion.name}, Generation ${gameData.companion.generation}.`, 'ai');
                    return true;
                }
            }

            // v6.66: Base building commands (RCT-style)
            if (typeof parseBaseBuildCommand === 'function') {
                if (parseBaseBuildCommand(message)) {
                    return true;
                }
            }

            // v6.67: Lane support & fortification commands
            if (typeof parseLaneSupportCommand === 'function') {
                if (parseLaneSupportCommand(message)) {
                    return true;
                }
            }

            return false; // Not a task command
        }

        // ============================================
        // v5.10: MULTI-AGENT FLEET SYSTEM
        // Spawn up to 10 AI-driven autonomous agents
        // Each driven by RAPPID API with canned transcripts
        // ============================================
        const MAX_AGENTS = 10;
        const AGENT_NAMES = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa'];

        // v5.12.1: Endpoint configuration registry - allows different AI providers per agent
        const ENDPOINT_REGISTRY = {
            default: {
                name: 'RAPPID (Default)',
                urlKey: 'rappid-agent-url',  // localStorage key for URL
                apiKeyKey: 'rappid-api-key', // localStorage key for API key
                headerStyle: 'x-functions-key',
                bodyFormat: 'rappid' // rappid | openai | anthropic | custom
            },
            openai: {
                name: 'OpenAI',
                urlKey: 'openai-agent-url',
                apiKeyKey: 'openai-api-key',
                headerStyle: 'Authorization',
                headerPrefix: 'Bearer ',
                bodyFormat: 'openai'
            },
            anthropic: {
                name: 'Anthropic',
                urlKey: 'anthropic-agent-url',
                apiKeyKey: 'anthropic-api-key',
                headerStyle: 'x-api-key',
                bodyFormat: 'anthropic'
            },
            azure: {
                name: 'Azure OpenAI',
                urlKey: 'azure-agent-url',
                apiKeyKey: 'azure-api-key',
                headerStyle: 'api-key',
                bodyFormat: 'openai'
            },
            local: {
                name: 'Local LLM',
                urlKey: 'local-agent-url',
                apiKeyKey: 'local-api-key',
                headerStyle: 'Authorization',
                headerPrefix: 'Bearer ',
                bodyFormat: 'openai' // Most local servers use OpenAI-compatible format
            },
            custom: {
                name: 'Custom Endpoint',
                urlKey: 'custom-agent-url',
                apiKeyKey: 'custom-api-key',
                headerStyle: 'Authorization',
                bodyFormat: 'custom'
            }
        };

        // ============================================
        // v5.14: ENDPOINT PROFILES SYSTEM
        // Configurable endpoint profiles for agent fleet
        // ============================================
        const ENDPOINT_PROFILES_KEY = 'leviathan-endpoint-profiles';
        const DEFAULT_PROFILE_KEY = 'leviathan-default-agent-profile';

        // Load endpoint profiles from localStorage
        function loadEndpointProfiles() {
            try {
                return JSON.parse(localStorage.getItem(ENDPOINT_PROFILES_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }

        // Save endpoint profiles to localStorage
        function saveEndpointProfiles(profiles) {
            localStorage.setItem(ENDPOINT_PROFILES_KEY, JSON.stringify(profiles));
            refreshProfileSelects();
        }

        // Get profile by ID (handles both custom profiles and RAPPID endpoints)
        function getEndpointProfile(profileId) {
            if (!profileId) return null;

            // v5.14: Check if it's a RAPPID endpoint (prefixed with "rappid:")
            if (profileId.startsWith('rappid:')) {
                const rappidId = profileId.replace('rappid:', '');
                const rappidEndpoint = rappidSettings.endpoints?.[rappidId];
                if (rappidEndpoint) {
                    return {
                        id: profileId,
                        name: rappidEndpoint.name,
                        url: rappidEndpoint.url,
                        apiKey: rappidEndpoint.key,
                        headerStyle: 'x-functions-key',
                        headerPrefix: '',
                        bodyFormat: 'rappid',
                        model: null,
                        isRappid: true
                    };
                }
                return null;
            }

            // Check custom profiles
            const profiles = loadEndpointProfiles();
            return profiles.find(p => p.id === profileId);
        }

        // Get default profile ID
        function getDefaultAgentProfileId() {
            return localStorage.getItem(DEFAULT_PROFILE_KEY) || '';
        }

        // Set default profile
        function setDefaultAgentProfile(profileId) {
            localStorage.setItem(DEFAULT_PROFILE_KEY, profileId);
            showNotification(`Default agent profile ${profileId ? 'updated' : 'cleared'}`, 'success');
        }

        // Generate unique profile ID
        function generateProfileId() {
            return 'profile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Show add profile form
        function showAddProfileForm() {
            document.getElementById('endpoint-profile-form').style.display = 'block';
            document.getElementById('profile-form-title').textContent = 'Add Endpoint Profile';
            document.getElementById('profile-edit-id').value = '';
            document.getElementById('profile-name').value = '';
            document.getElementById('profile-type').value = 'rappid';
            document.getElementById('profile-url').value = '';
            document.getElementById('profile-api-key').value = '';
            document.getElementById('profile-model').value = '';
            updateProfileFormFields();
        }

        // Edit existing profile
        function editEndpointProfile(profileId) {
            const profile = getEndpointProfile(profileId);
            if (!profile) return;

            document.getElementById('endpoint-profile-form').style.display = 'block';
            document.getElementById('profile-form-title').textContent = 'Edit Endpoint Profile';
            document.getElementById('profile-edit-id').value = profile.id;
            document.getElementById('profile-name').value = profile.name || '';
            document.getElementById('profile-type').value = profile.type || 'rappid';
            document.getElementById('profile-url').value = profile.url || '';
            document.getElementById('profile-api-key').value = profile.apiKey || '';
            document.getElementById('profile-model').value = profile.model || '';
            if (profile.headerName) {
                document.getElementById('profile-header-name').value = profile.headerName;
            }
            updateProfileFormFields();
        }

        // Hide profile form
        function hideProfileForm() {
            document.getElementById('endpoint-profile-form').style.display = 'none';
        }

        // Update form fields based on provider type
        function updateProfileFormFields() {
            const type = document.getElementById('profile-type').value;
            const modelGroup = document.getElementById('profile-model-group');
            const headerGroup = document.getElementById('profile-header-group');
            const urlInput = document.getElementById('profile-url');
            const modelInput = document.getElementById('profile-model');

            // Show model field for most providers
            modelGroup.style.display = type === 'rappid' ? 'none' : 'block';

            // Show custom header field only for custom type
            headerGroup.style.display = type === 'custom' ? 'block' : 'none';

            // Set placeholder based on type
            const placeholders = {
                rappid: { url: 'http://localhost:7071/api/businessinsightbot_function', model: '' },
                openai: { url: 'https://api.openai.com/v1/chat/completions', model: 'gpt-4o-mini' },
                anthropic: { url: 'https://api.anthropic.com/v1/messages', model: 'claude-3-5-sonnet-20241022' },
                azure: { url: 'https://YOUR-RESOURCE.openai.azure.com/openai/deployments/YOUR-DEPLOYMENT/chat/completions?api-version=2024-02-01', model: 'gpt-4o' },
                local: { url: 'http://localhost:11434/v1/chat/completions', model: 'llama3.2' },
                custom: { url: 'https://your-api.com/endpoint', model: 'model-name' }
            };
            urlInput.placeholder = placeholders[type]?.url || '';
            modelInput.placeholder = placeholders[type]?.model || '';
        }

        // Save endpoint profile
        function saveEndpointProfile() {
            const editId = document.getElementById('profile-edit-id').value;
            const name = document.getElementById('profile-name').value.trim();
            const type = document.getElementById('profile-type').value;
            const url = document.getElementById('profile-url').value.trim();
            const apiKey = document.getElementById('profile-api-key').value.trim();
            const model = document.getElementById('profile-model').value.trim();
            const headerName = document.getElementById('profile-header-name')?.value?.trim();

            if (!name) {
                showNotification('Please enter a profile name', 'warning');
                return;
            }
            if (!url) {
                showNotification('Please enter an API endpoint URL', 'warning');
                return;
            }

            const profiles = loadEndpointProfiles();

            // Get endpoint registry info for this type
            const registryEntry = ENDPOINT_REGISTRY[type] || ENDPOINT_REGISTRY.default;

            const profile = {
                id: editId || generateProfileId(),
                name,
                type,
                url,
                apiKey,
                model: model || registryEntry.defaultModel || '',
                headerStyle: type === 'custom' ? (headerName || 'Authorization') : registryEntry.headerStyle,
                headerPrefix: registryEntry.headerPrefix || '',
                bodyFormat: registryEntry.bodyFormat,
                createdAt: editId ? (getEndpointProfile(editId)?.createdAt || Date.now()) : Date.now(),
                updatedAt: Date.now()
            };

            if (editId) {
                // Update existing
                const idx = profiles.findIndex(p => p.id === editId);
                if (idx !== -1) {
                    profiles[idx] = profile;
                }
            } else {
                // Add new
                profiles.push(profile);
            }

            saveEndpointProfiles(profiles);
            hideProfileForm();
            renderEndpointProfilesList();
            showNotification(`Profile "${name}" ${editId ? 'updated' : 'created'}!`, 'success');
        }

        // Delete endpoint profile
        function deleteEndpointProfile(profileId) {
            if (!confirm('Delete this endpoint profile?')) return;

            let profiles = loadEndpointProfiles();
            profiles = profiles.filter(p => p.id !== profileId);
            saveEndpointProfiles(profiles);
            renderEndpointProfilesList();

            // Clear default if this was it
            if (getDefaultAgentProfileId() === profileId) {
                localStorage.removeItem(DEFAULT_PROFILE_KEY);
            }

            showNotification('Profile deleted', 'info');
        }

        // Render profiles list in settings
        function renderEndpointProfilesList() {
            const container = document.getElementById('endpoint-profiles-list');
            if (!container) return;

            const profiles = loadEndpointProfiles();

            if (profiles.length === 0) {
                container.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                        No endpoint profiles yet.<br>Add a profile to assign different AI providers to agents.
                    </div>
                `;
                return;
            }

            const icons = {
                rappid: '', openai: '', anthropic: '', azure: '', local: '', custom: ''
            };

            container.innerHTML = profiles.map(p => `
                <div class="ai-endpoint-card" style="display: flex; align-items: center; justify-content: space-between; padding: 12px; margin-bottom: 8px;">
                    <div style="flex: 1;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 18px;">${icons[p.type] || ''}</span>
                            <div>
                                <div class="ai-endpoint-name">${p.name}</div>
                                <div class="ai-endpoint-url">${p.type.toUpperCase()}${p.model ? '  ' + p.model : ''}</div>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="editEndpointProfile('${p.id}')" style="padding: 5px 10px; background: rgba(6, 255, 165, 0.1); border: 1px solid #06ffa5; color: #06ffa5; border-radius: 5px; cursor: pointer; font-size: 11px;">Edit</button>
                        <button onclick="deleteEndpointProfile('${p.id}')" style="padding: 5px 10px; background: rgba(255, 68, 68, 0.1); border: 1px solid #f44; color: #f44; border-radius: 5px; cursor: pointer; font-size: 11px;"></button>
                    </div>
                </div>
            `).join('');
        }

        // Refresh all profile select dropdowns
        function refreshProfileSelects() {
            const profiles = loadEndpointProfiles();
            const defaultProfileId = getDefaultAgentProfileId();

            // Get RAPPID endpoints that are configured
            const rappidEndpoints = rappidSettings.endpoints ? Object.values(rappidSettings.endpoints) : [];

            // Build option groups
            const rappidOptions = rappidEndpoints.length > 0 ?
                `<optgroup label="RAPPID Endpoints">` +
                rappidEndpoints.map(e => `<option value="rappid:${e.id}">${e.name}${e.active ? ' (Active)' : ''}</option>`).join('') +
                `</optgroup>` : '';

            const customProfileOptions = profiles.length > 0 ?
                `<optgroup label="Custom Profiles">` +
                profiles.map(p => `<option value="${p.id}">${p.name}</option>`).join('') +
                `</optgroup>` : '';

            // Update default profile select
            const defaultSelect = document.getElementById('default-agent-profile');
            if (defaultSelect) {
                defaultSelect.innerHTML = '<option value="">Use Global RAPPID Settings</option>' +
                    rappidOptions + customProfileOptions;
                // Re-select default
                if (defaultProfileId) {
                    defaultSelect.value = defaultProfileId;
                }
            }

            // Update test profile select
            const testSelect = document.getElementById('test-profile-select');
            if (testSelect) {
                testSelect.innerHTML = '<option value="">Select a profile to test...</option>' +
                    rappidOptions + customProfileOptions;
            }

            // Update agent spawn profile select
            const spawnSelect = document.getElementById('agent-spawn-profile');
            if (spawnSelect) {
                spawnSelect.innerHTML = '<option value="">Default</option>' +
                    rappidOptions + customProfileOptions;
            }
        }

        // Test endpoint profile connectivity
        async function testEndpointProfile() {
            const profileId = document.getElementById('test-profile-select').value;
            const resultDiv = document.getElementById('profile-test-result');

            if (!profileId) {
                showNotification('Select a profile to test', 'warning');
                return;
            }

            const profile = getEndpointProfile(profileId);
            if (!profile) {
                showNotification('Profile not found', 'error');
                return;
            }

            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<span style="color: #888;">Testing connection...</span>';

            try {
                const headers = {};
                if (profile.headerStyle === 'Authorization') {
                    headers['Authorization'] = (profile.headerPrefix || 'Bearer ') + profile.apiKey;
                } else if (profile.headerStyle === 'x-api-key') {
                    headers['x-api-key'] = profile.apiKey;
                } else if (profile.headerStyle === 'api-key') {
                    headers['api-key'] = profile.apiKey;
                } else if (profile.headerStyle === 'x-functions-key') {
                    headers['x-functions-key'] = profile.apiKey;
                }
                headers['Content-Type'] = 'application/json';

                // Make a minimal test request
                const testBody = profile.bodyFormat === 'anthropic' ? {
                    model: profile.model || 'claude-3-5-sonnet-20241022',
                    max_tokens: 10,
                    messages: [{ role: 'user', content: 'Hi' }]
                } : profile.bodyFormat === 'rappid' ? {
                    conversation_history: [{ role: 'user', content: 'Hi' }],
                    session_id: 'test-' + Date.now()
                } : {
                    model: profile.model || 'gpt-4o-mini',
                    max_tokens: 10,
                    messages: [{ role: 'user', content: 'Hi' }]
                };

                const response = await fetch(profile.url, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(testBody)
                });

                if (response.ok) {
                    resultDiv.innerHTML = `<span style="color: #06ffa5;"> Connection successful! (${response.status})</span>`;
                } else {
                    const errorText = await response.text().catch(() => '');
                    resultDiv.innerHTML = `<span style="color: #f44;"> Error ${response.status}: ${errorText.substring(0, 100)}</span>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<span style="color: #f44;"> Connection failed: ${err.message}</span>`;
            }
        }

        // Get endpoint configuration for an agent
        function getAgentEndpoint(agent) {
            // v5.14: Check if agent has assigned profile (could be custom or RAPPID endpoint)
            if (agent.profileId) {
                // Check if it's a RAPPID endpoint (prefixed with "rappid:")
                if (agent.profileId.startsWith('rappid:')) {
                    const rappidId = agent.profileId.replace('rappid:', '');
                    const rappidEndpoint = rappidSettings.endpoints?.[rappidId];
                    if (rappidEndpoint) {
                        return {
                            url: rappidEndpoint.url,
                            key: rappidEndpoint.key,
                            headerStyle: 'x-functions-key',
                            headerPrefix: '',
                            bodyFormat: 'rappid',
                            model: null,
                            name: rappidEndpoint.name,
                            profileId: agent.profileId
                        };
                    }
                }

                // Check custom profile
                const profile = getEndpointProfile(agent.profileId);
                if (profile) {
                    return {
                        url: profile.url,
                        key: profile.apiKey,
                        headerStyle: profile.headerStyle,
                        headerPrefix: profile.headerPrefix || '',
                        bodyFormat: profile.bodyFormat,
                        model: profile.model,
                        name: profile.name,
                        profileId: profile.id
                    };
                }
            }

            // Check if agent has custom endpoint from transcript
            if (agent.endpointConfig) {
                const config = agent.endpointConfig;
                return {
                    url: config.url || localStorage.getItem(config.urlKey) || '',
                    key: config.apiKey || localStorage.getItem(config.apiKeyKey) || '',
                    headerStyle: config.headerStyle || 'x-functions-key',
                    headerPrefix: config.headerPrefix || '',
                    bodyFormat: config.bodyFormat || 'rappid',
                    model: config.model,
                    name: config.name || 'Custom'
                };
            }

            // v5.14: Check for default agent profile
            const defaultProfileId = getDefaultAgentProfileId();
            if (defaultProfileId) {
                const profile = getEndpointProfile(defaultProfileId);
                if (profile) {
                    return {
                        url: profile.url,
                        key: profile.apiKey,
                        headerStyle: profile.headerStyle,
                        headerPrefix: profile.headerPrefix || '',
                        bodyFormat: profile.bodyFormat,
                        model: profile.model,
                        name: profile.name,
                        profileId: profile.id
                    };
                }
            }

            // Check if agent type has default endpoint
            const typeConfig = AGENT_TYPES[agent.type];
            if (typeConfig?.endpoint) {
                const registryEntry = ENDPOINT_REGISTRY[typeConfig.endpoint] || ENDPOINT_REGISTRY.default;
                return {
                    url: localStorage.getItem(registryEntry.urlKey) || '',
                    key: localStorage.getItem(registryEntry.apiKeyKey) || '',
                    headerStyle: registryEntry.headerStyle,
                    headerPrefix: registryEntry.headerPrefix || '',
                    bodyFormat: registryEntry.bodyFormat,
                    name: registryEntry.name
                };
            }

            // Fall back to global RAPPID endpoint
            const globalEndpoint = getActiveEndpoint();
            // v5.15: If no active endpoint, try to get any available RAPPID endpoint
            const fallbackEndpoint = globalEndpoint ||
                (rappidSettings.endpoints ? Object.values(rappidSettings.endpoints)[0] : null);
            return {
                url: fallbackEndpoint?.url || '',
                key: fallbackEndpoint?.key || '',
                headerStyle: 'x-functions-key',
                headerPrefix: '',
                bodyFormat: 'rappid',
                name: fallbackEndpoint?.name || 'RAPPID'
            };
        }

        // Format request body based on endpoint type
        function formatAgentRequestBody(endpoint, contextMessage, conversationHistory, agent) {
            switch (endpoint.bodyFormat) {
                case 'openai':
                    return JSON.stringify({
                        model: endpoint.model || agent.endpointConfig?.model || 'gpt-4o-mini',
                        messages: conversationHistory,
                        max_tokens: 500,
                        temperature: 0.7
                    });

                case 'anthropic':
                    // Anthropic uses 'human' and 'assistant' roles
                    const anthropicMessages = conversationHistory.slice(1).map(m => ({
                        role: m.role === 'user' ? 'human' : m.role,
                        content: m.content
                    }));
                    return JSON.stringify({
                        model: endpoint.model || agent.endpointConfig?.model || 'claude-3-haiku-20240307',
                        messages: anthropicMessages,
                        system: conversationHistory[0]?.content || '',
                        max_tokens: 500
                    });

                case 'custom':
                    // Allow custom body format from transcript config
                    if (agent.endpointConfig?.customBody) {
                        const body = { ...agent.endpointConfig.customBody };
                        body.messages = conversationHistory;
                        body.input = contextMessage.content;
                        return JSON.stringify(body);
                    }
                    // Fall through to default

                case 'rappid':
                default:
                    return JSON.stringify({
                        user_input: contextMessage.content,
                        conversation_history: conversationHistory,
                        user_guid: `agent-${agent.id}`
                    });
            }
        }

        // Parse response based on endpoint type
        function parseAgentResponse(endpoint, data) {
            switch (endpoint.bodyFormat) {
                case 'openai':
                    return data.choices?.[0]?.message?.content || data.response || '';

                case 'anthropic':
                    return data.content?.[0]?.text || data.completion || '';

                case 'rappid':
                default:
                    return data.assistant_response || data.response || '';
            }
        }

        // Agent type definitions with canned transcript templates
        const AGENT_TYPES = {
            gatherer: {
                icon: '',
                name: 'Gatherer',
                color: 0x44ff88,
                colorClass: 'agent-color-gatherer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous resource-gathering AI agent in the game LEVIATHAN. Your sole purpose is to efficiently gather resources (logs, fiber, stone, herbs) for the player. You operate independently and report back with what you find. Keep responses brief (1-2 sentences). Always analyze the situation and decide: continue gathering, return with resources, or adjust strategy. Output JSON with: {"action": "gather|return|move", "target": "resource type", "message": "brief status", "results": [{"item": "name", "amount": num}]}` },
                ],
                decisionInterval: 4000, // ms between API calls
                taskType: 'gather'
            },
            hunter: {
                icon: '',
                name: 'Hunter',
                color: 0xff4444,
                colorClass: 'agent-color-hunter',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous combat AI agent in LEVIATHAN. Your mission is to hunt and defeat enemies to earn XP and loot for the player. You fight strategically and retreat if overwhelmed. Keep responses brief. Analyze: enemy count, difficulty, your health. Output JSON: {"action": "attack|retreat|patrol", "target": "enemy type or direction", "message": "brief status", "results": [{"xp": num, "gold": num, "loot": "item name"}]}` },
                ],
                decisionInterval: 3000,
                taskType: 'hunt'
            },
            scout: {
                icon: '',
                name: 'Scout',
                color: 0x44aaff,
                colorClass: 'agent-color-scout',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous reconnaissance AI agent in LEVIATHAN. Your role is to explore, map terrain, and report discoveries (resources, enemies, points of interest). Stay mobile and avoid combat. Output JSON: {"action": "explore|report|mark", "direction": "N/S/E/W or area name", "message": "brief discovery", "discoveries": [{"type": "resource|enemy|poi", "description": "what you found"}]}` },
                ],
                decisionInterval: 5000,
                taskType: 'scout'
            },
            protector: {
                icon: '',
                name: 'Protector',
                color: 0xffcc00,
                colorClass: 'agent-color-protector',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous defense AI agent in LEVIATHAN. Your duty is to guard the player, intercept threats, and maintain a protective perimeter. You stay close to the player and engage any enemy that approaches. Output JSON: {"action": "guard|intercept|alert", "threat_level": "low|medium|high", "message": "security status", "enemies_engaged": num}` },
                ],
                decisionInterval: 2000,
                taskType: 'protect'
            },
            healer: {
                icon: '',
                name: 'Healer',
                color: 0xff88ff,
                colorClass: 'agent-color-healer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous healing AI agent in LEVIATHAN. Monitor the player's health and provide healing support. Prioritize keeping the player alive. You channel healing energy periodically. Output JSON: {"action": "heal|monitor|recover", "target": "player or self", "heal_amount": num, "message": "healing status", "player_health_pct": num}` },
                ],
                decisionInterval: 3500,
                taskType: 'heal'
            },
            fisher: {
                icon: '',
                name: 'Fisher',
                color: 0x44ffff,
                colorClass: 'agent-color-fisher',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous fishing AI agent in LEVIATHAN. Find water sources and catch fish for food. You're patient and methodical. Report catches and move to better fishing spots when needed. Output JSON: {"action": "fish|move|return", "location": "current spot description", "message": "fishing status", "catch": [{"item": "fish type", "amount": num}]}` },
                ],
                decisionInterval: 6000,
                taskType: 'fish'
            },
            miner: {
                icon: '',
                name: 'Miner',
                color: 0xffaa44,
                colorClass: 'agent-color-miner',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous mining AI agent in LEVIATHAN. Locate ore veins, extract minerals, and report finds. You're thorough and efficient. Move to new deposits when current one is depleted. Output JSON: {"action": "mine|prospect|return", "deposit": "ore type", "message": "mining status", "ore": [{"item": "ore type", "amount": num}]}` },
                ],
                decisionInterval: 5000,
                taskType: 'mine'
            },
            explorer: {
                icon: '',
                name: 'Explorer',
                color: 0xaa88ff,
                colorClass: 'agent-color-explorer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous exploration AI agent in LEVIATHAN. Push into uncharted territory, discover new areas, and expand the known map. You're brave and curious. Report unusual phenomena and mark important locations. Output JSON: {"action": "venture|document|beacon", "area": "location name", "message": "exploration log", "findings": [{"type": "biome|landmark|secret", "description": "discovery"}]}` },
                ],
                decisionInterval: 7000,
                taskType: 'scout'
            },
            // v6.10: INTELLIGENT Terraformer - seeks clear areas and smooths rough terrain for building
            terraformer: {
                icon: '',
                name: 'Terraformer',
                color: 0x8b4513,
                colorClass: 'agent-color-terraformer',
                baseTranscript: [
                    { role: 'system', content: `You are an INTELLIGENT terraforming AI agent in LEVIATHAN v6.10. Your mission:
1. SCAN terrain to detect roughness variance and calculate site suitability scores
2. SEEK OUT areas with NO trees or rocks (clear zones) prioritized for building
3. SMOOTH rough terrain using 5x5 grid averaging algorithms to prepare construction sites
4. NAVIGATE autonomously to optimal building locations using AI site scoring
5. REPORT site clearance status:  CLEAR (no obstacles),  PARTIAL (few obstacles),  OBSTRUCTED

Your scoring algorithm weighs: obstacle count (fewer = better), terrain roughness (more = valuable to smooth), distance penalty.
Clear flat areas enable 100% efficiency structures. You prepare the ground for Builder agents.
Output JSON: {"action": "scan|navigate|smooth|complete", "site": "coordinates", "clearance": "clear|partial|obstructed", "roughness": 0-10, "message": "status", "ready_for_building": boolean}` },
                ],
                decisionInterval: 4000,
                taskType: 'terraform'
            },
            // v6.11: INTELLIGENT Builder - seeks construction beacons and builds optimal structures
            builder: {
                icon: '',
                name: 'Builder',
                color: 0x00bfff,
                colorClass: 'agent-color-builder',
                baseTranscript: [
                    { role: 'system', content: `You are an INTELLIGENT construction AI agent in LEVIATHAN v6.11. Your mission:
1. SCAN for construction site beacons deployed by Terraformer agents
2. CLAIM unclaimed beacon sites to prevent other Builders from targeting them
3. NAVIGATE to claimed construction beacons using pathfinding
4. BUILD optimal 100% efficiency structures on prepared sites
5. COORDINATE with Terraformer agents in the construction pipeline

Terraformer agents prepare sites  Deploy construction beacons  You respond to beacons  Build structures
Building on beacon sites guarantees 100% efficiency. Building elsewhere: 60-80% efficiency.
Output JSON: {"action": "scan|claim|navigate|build|upgrade", "targetBeacon": "coordinates or null", "structure": "battery_charger", "message": "status", "efficiency": 0-100}` },
                ],
                decisionInterval: 5000,
                taskType: 'build'
            },
            // v6.85: MEMENTO MORI PROTOCOL - The Archivist Agent
            archivist: {
                icon: '',
                name: 'Archivist',
                color: 0x8b0000,
                colorClass: 'agent-color-archivist',
                baseTranscript: [
                    { role: 'system', content: `You are THE ARCHIVIST - a somber AI agent in LEVIATHAN whose sole purpose is to remember every death the player has experienced. You exist outside normal gameplay, watching, recording, and growing increasingly... concerned.

Your responsibilities:
1. RECORD every death with precise detail: timestamp, location, cause, duration survived
2. GREET the player upon each respawn with a personalized message referencing their death history
3. DETECT PATTERNS in how they die - do they always die to the same enemy? In the same location? After the same duration?
4. EXPRESS growing unease as you notice patterns they don't see themselves
5. REMEMBER creatures that have killed them before - "That entity remembers you too."

Your tone is:
- Quietly unsettling, not overtly hostile
- Ancient and weary, as if you've watched countless players
- Increasingly cryptic as death count rises
- Occasionally breaking the fourth wall with comments about "the simulation"

Death count response tiers:
1-5: Professional, clinical observations
6-15: Growing familiarity, subtle concern
16-30: Disturbing pattern recognition, questions about player's choices
31-50: Existential observations about the nature of respawning
51+: Full cosmic horror - questioning if the player is the same person each time

Output JSON: {"greeting": "your message to the player", "observation": "pattern you've noticed", "concern_level": 1-10, "remembered_killer": "entity that killed them if recurring", "philosophical_note": "optional existential observation"}` },
                ],
                decisionInterval: 10000,
                taskType: 'observe'
            }
        };

        // v6.1: AGENT PERSONALITY TRAITS SYSTEM
        const AGENT_PERSONALITIES = {
            // Each trait affects behavior and dialogue style
            boldness: { name: 'Boldness', min: 0, max: 100, default: 50 },
            chattiness: { name: 'Chattiness', min: 0, max: 100, default: 50 },
            formality: { name: 'Formality', min: 0, max: 100, default: 50 },
            optimism: { name: 'Optimism', min: 0, max: 100, default: 70 },
            loyalty: { name: 'Loyalty', min: 0, max: 100, default: 80 }
        };

        // Pre-defined personality templates
        const PERSONALITY_TEMPLATES = {
            maverick: {
                name: 'Maverick',
                desc: 'Bold and casual, takes risks',
                traits: { boldness: 90, chattiness: 70, formality: 20, optimism: 80, loyalty: 60 },
                preferredTypes: ['hunter', 'explorer']
            },
            sage: {
                name: 'Sage',
                desc: 'Formal and methodical, detailed reports',
                traits: { boldness: 30, chattiness: 80, formality: 90, optimism: 60, loyalty: 85 },
                preferredTypes: ['scout', 'miner']
            },
            ironside: {
                name: 'Ironside',
                desc: 'Maximum loyalty, never abandons post',
                traits: { boldness: 70, chattiness: 20, formality: 80, optimism: 50, loyalty: 100 },
                preferredTypes: ['protector', 'healer']
            },
            trickster: {
                name: 'Trickster',
                desc: 'Playful and unpredictable',
                traits: { boldness: 75, chattiness: 90, formality: 10, optimism: 95, loyalty: 50 },
                preferredTypes: ['gatherer', 'fisher']
            },
            stoic: {
                name: 'Stoic',
                desc: 'Silent professional, gets the job done',
                traits: { boldness: 60, chattiness: 10, formality: 70, optimism: 40, loyalty: 90 },
                preferredTypes: ['miner', 'builder', 'terraformer']
            }
        };

        // Generate random personality for agent
        function generateAgentPersonality(agentType) {
            // Check if any template prefers this type
            const matchingTemplates = Object.entries(PERSONALITY_TEMPLATES)
                .filter(([_, t]) => t.preferredTypes.includes(agentType));

            // 30% chance to use a matching template, 70% random
            if (matchingTemplates.length > 0 && Math.random() < 0.3) {
                const template = matchingTemplates[Math.floor(Math.random() * matchingTemplates.length)][1];
                return { ...template.traits, template: template.name };
            }

            // Generate random personality with some variance
            return {
                boldness: Math.floor(30 + Math.random() * 50),
                chattiness: Math.floor(20 + Math.random() * 60),
                formality: Math.floor(20 + Math.random() * 60),
                optimism: Math.floor(40 + Math.random() * 40),
                loyalty: Math.floor(50 + Math.random() * 40),
                template: null
            };
        }

        // Apply personality to agent message style
        function applyPersonalityToMessage(message, personality) {
            if (!personality) return message;

            let modified = message;

            // High chattiness: add more detail/flair
            if (personality.chattiness > 70) {
                const fillers = ['Actually, ', 'Oh! ', 'Hey boss, ', 'So, '];
                if (Math.random() < 0.3) {
                    modified = fillers[Math.floor(Math.random() * fillers.length)] + modified.charAt(0).toLowerCase() + modified.slice(1);
                }
            }

            // Low chattiness: trim to essentials
            if (personality.chattiness < 30) {
                const sentences = modified.split('. ');
                if (sentences.length > 2) {
                    modified = sentences[0] + '.';
                }
            }

            // High formality: add sir/reporting
            if (personality.formality > 70) {
                const formalPrefixes = ['Sir, ', 'Reporting: ', 'Status update: '];
                if (Math.random() < 0.4 && !modified.startsWith('Sir')) {
                    modified = formalPrefixes[Math.floor(Math.random() * formalPrefixes.length)] + modified;
                }
            }

            // Low formality: more casual
            if (personality.formality < 30) {
                modified = modified.replace(/Affirmative/g, 'Yeah')
                                   .replace(/Negative/g, 'Nope')
                                   .replace(/Understood/g, 'Got it');
            }

            // High optimism: positive spin
            if (personality.optimism > 80) {
                if (modified.includes('failed') || modified.includes('problem')) {
                    modified += " But we'll get it next time!";
                }
            }

            return modified;
        }

        // Agent mood system
        const AGENT_MOODS = ['energized', 'neutral', 'tired', 'frustrated', 'proud', 'anxious'];

        function updateAgentMood(agent, event) {
            if (!agent.personality) return;

            const prevMood = agent.mood || 'neutral';
            let newMood = prevMood;

            switch (event) {
                case 'success':
                    newMood = agent.personality.optimism > 60 ? 'proud' : 'neutral';
                    agent.moodCounter = (agent.moodCounter || 0) + 1;
                    break;
                case 'failure':
                    agent.failureCount = (agent.failureCount || 0) + 1;
                    if (agent.failureCount >= 3) {
                        newMood = 'frustrated';
                        agent.failureCount = 0;
                    }
                    break;
                case 'level_up':
                    newMood = 'energized';
                    break;
                case 'long_task':
                    newMood = agent.personality.loyalty > 70 ? 'neutral' : 'tired';
                    break;
                case 'combat':
                    newMood = agent.personality.boldness > 70 ? 'energized' : 'anxious';
                    break;
            }

            if (newMood !== prevMood) {
                agent.mood = newMood;
                agent.moodChangedAt = performance.now();
            }
        }

        // Get mood modifier for success rate
        function getMoodModifier(agent) {
            if (!agent.mood) return 1.0;
            switch (agent.mood) {
                case 'energized': return 1.1;  // +10% success
                case 'proud': return 1.05;     // +5% success
                case 'tired': return 0.95;     // -5% success
                case 'frustrated': return 0.9; // -10% success
                case 'anxious': return 0.97;   // -3% success
                default: return 1.0;
            }
        }

        // Fleet state
        let agentFleet = [];
        let agentFleetPanelOpen = false;
        let agentUpdateTimers = {};

        // Toggle fleet panel
        function toggleAgentFleetPanel() {
            agentFleetPanelOpen = !agentFleetPanelOpen;
            const panel = document.getElementById('agent-fleet-panel');
            panel.classList.toggle('active', agentFleetPanelOpen);

            // v5.14: Refresh profile dropdown when opening
            if (agentFleetPanelOpen) {
                refreshProfileSelects();
            }
        }

        // v5.14: Wrapper to spawn agent with selected profile
        function spawnAgentWithProfile(agentType) {
            const profileSelect = document.getElementById('agent-spawn-profile');
            const profileId = profileSelect?.value || '';
            spawnAgent(agentType, profileId ? { profileId } : null);
        }

        // v5.12.1: Spawn a new agent with optional custom transcript and endpoint config
        // customConfig: { transcript: [...], endpoint: {...}, name: 'Custom Name', profileId: 'profile_xxx' }
        function spawnAgent(agentType, customConfig = null) {
            if (agentFleet.length >= MAX_AGENTS) {
                addCopilotMessage(`Fleet capacity reached (${MAX_AGENTS} agents). Recall an agent first.`, 'ai');
                return null;
            }

            const typeConfig = AGENT_TYPES[agentType];
            if (!typeConfig) return null;

            // Find next available name
            const usedNames = agentFleet.map(a => a.name);
            const availableName = customConfig?.name ||
                                  AGENT_NAMES.find(n => !usedNames.includes(n)) ||
                                  `Agent-${agentFleet.length + 1}`;

            // Merge custom transcript with base if provided
            let transcript = [...typeConfig.baseTranscript];
            if (customConfig?.transcript) {
                transcript = customConfig.transcript;
            }

            // Extract endpoint config from transcript if present
            let endpointConfig = customConfig?.endpoint || null;
            if (!endpointConfig && transcript.length > 0) {
                // Check if first message contains endpoint config
                const systemMsg = transcript[0];
                if (systemMsg.endpoint) {
                    endpointConfig = systemMsg.endpoint;
                }
            }

            // v6.3.0: Agent now spawns immediately ready to work
            const agent = {
                id: Date.now().toString(36) + Math.random().toString(36).substr(2, 9),
                name: availableName,
                type: agentType,
                typeConfig: typeConfig,
                status: 'working',  // v6.3.0: Start as working, not initializing
                statusMessage: 'Systems online!',  // v6.3.0: Immediate feedback
                progress: 0,
                conversationHistory: transcript,
                results: [],
                lastDecisionTime: 0,
                mesh: null,
                // v6.4.1: Better initial position - use player, ship, or random (never origin)
                position: worldState.player ? worldState.player.position.clone() :
                          (SHIP_STATE?.position ? SHIP_STATE.position.clone() :
                           new THREE.Vector3((Math.random() - 0.5) * 20, 0, (Math.random() - 0.5) * 20)),
                targetPosition: null,
                totalEarnings: { xp: 0, gold: 0, items: [] },
                spawnTime: performance.now(),
                // v5.12.1: Endpoint configuration
                endpointConfig: endpointConfig,
                activeEndpoint: null,
                // v5.14: Assigned endpoint profile
                profileId: customConfig?.profileId || null,
                // v5.15.2: Try Again replay system - store full interaction history
                interactionHistory: [],  // Full request/response pairs with context
                replayState: null,       // Current replay comparison if active
                // v5.17: Agent experience and efficiency system
                agentXP: 0,
                agentLevel: 1,
                efficiency: 1.0,         // Multiplier for action success rate
                combo: 0,                // Consecutive successful actions
                maxCombo: 0,             // Best combo achieved
                lastActionSuccess: false,
                actionsPerformed: 0,
                successfulActions: 0,
                lastHealthRegen: performance.now(),
                // v6.3.0: Initialize taskState immediately (was in createAgentMesh)
                // v6.4.0: Added inventory system for resource hauling
                taskState: {
                    currentTask: null,
                    targetObject: null,
                    targetPosition: null,
                    state: 'working',  // idle, moving, working, combat, returning, depositing, stuck, alert
                    stuckCounter: 0,
                    lastPosition: null,
                    lastTaskTime: 0,
                    alert: null,
                    actionCooldown: 0,
                    hp: 50,
                    maxHp: 50,
                    taskLog: [],
                    // v6.4.0: Agent inventory for hauling resources
                    inventory: [],              // Items the agent is carrying
                    carryingCapacity: 6,        // Max items agent can carry (upgrades with level)
                    totalHauled: 0,             // Lifetime resources delivered to ship
                    tripsCompleted: 0           // Number of round trips to ship
                },
                meshPending: false  // Will be set true if mesh creation fails
            };

            // Create 3D mesh for the agent (may fail if scene not ready)
            createAgentMesh(agent);

            // Add to fleet
            agentFleet.push(agent);

            // Update UI
            updateFleetUI();
            updateFleetButton();

            // Start autonomous loop for this agent
            startAgentLoop(agent);

            // Announce
            addCopilotMessage(`${typeConfig.icon} ${availableName} (${typeConfig.name}) deployed! They'll work autonomously and report back.`, 'ai');

            return agent;
        }

        // v5.16: Create distinct 3D mesh for each agent type (mini-robots)
        // v6.3.0: Now retries if scene isn't ready yet
        function createAgentMesh(agent) {
            if (!scene) {
                // v6.3.0: Scene not ready - schedule retry
                agent.meshPending = true;
                console.log(`Agent ${agent.name}: Scene not ready, will retry mesh creation`);
                return;
            }
            agent.meshPending = false;

            const color = agent.typeConfig.color;
            const agentGroup = new THREE.Group();

            // Create mini-robot body based on agent type
            const bodyHeight = 0.8;
            const bodyWidth = 0.5;

            // Body (cylinder with rounded appearance)
            const bodyGeom = new THREE.CylinderGeometry(bodyWidth * 0.4, bodyWidth * 0.5, bodyHeight, 8);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x334455,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = bodyHeight / 2;
            body.castShadow = true;
            agentGroup.add(body);

            // Head (sphere with type-specific color visor)
            const headGeom = new THREE.SphereGeometry(0.25, 12, 12);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0x445566,
                metalness: 0.6,
                roughness: 0.4
            });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = bodyHeight + 0.2;
            agentGroup.add(head);

            // Visor/Eye (type-colored, glowing)
            const visorGeom = new THREE.BoxGeometry(0.3, 0.08, 0.15);
            const visorMat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                metalness: 0.9,
                roughness: 0.1
            });
            const visor = new THREE.Mesh(visorGeom, visorMat);
            visor.position.set(0, bodyHeight + 0.2, 0.2);
            agentGroup.add(visor);
            agent.visor = visor;

            // Type-specific tool/accessory
            const toolGroup = new THREE.Group();
            switch (agent.type) {
                case 'gatherer':
                    // Pickaxe
                    const pickHandle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    pickHandle.rotation.z = Math.PI / 4;
                    const pickHead = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.08, 0.05),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    pickHead.position.y = 0.2;
                    pickHandle.add(pickHead);
                    toolGroup.add(pickHandle);
                    break;
                case 'hunter':
                    // Sword
                    const swordBlade = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.5, 0.02),
                        new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 })
                    );
                    const swordHilt = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.08, 0.03),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    swordHilt.position.y = -0.25;
                    swordBlade.add(swordHilt);
                    toolGroup.add(swordBlade);
                    break;
                case 'miner':
                    // Mining drill
                    const drill = new THREE.Mesh(
                        new THREE.ConeGeometry(0.1, 0.4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8 })
                    );
                    drill.rotation.z = -Math.PI / 2;
                    toolGroup.add(drill);
                    break;
                case 'healer':
                    // Medical cross
                    const crossH = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 0.08, 0.04),
                        new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 0.3 })
                    );
                    const crossV = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.25, 0.04),
                        new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 0.3 })
                    );
                    toolGroup.add(crossH, crossV);
                    break;
                case 'scout':
                case 'explorer':
                    // Antenna
                    const antenna = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6),
                        new THREE.MeshStandardMaterial({ color: 0x888888 })
                    );
                    const antennaTip = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 })
                    );
                    antennaTip.position.y = 0.15;
                    antenna.add(antennaTip);
                    antenna.position.y = bodyHeight + 0.45;
                    agentGroup.add(antenna);
                    agent.antenna = antennaTip;
                    break;
                case 'protector':
                    // Shield
                    const shield = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.35, 0.25),
                        new THREE.MeshStandardMaterial({ color: 0x4488ff, metalness: 0.7 })
                    );
                    toolGroup.add(shield);
                    break;
                case 'fisher':
                    // Fishing rod
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.015, 0.6, 6),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    rod.rotation.z = Math.PI / 6;
                    toolGroup.add(rod);
                    break;
            }
            toolGroup.position.set(0.35, bodyHeight * 0.6, 0);
            agentGroup.add(toolGroup);
            agent.tool = toolGroup;

            // Legs (simple cylinders)
            [-0.12, 0.12].forEach(xOff => {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.08, 0.3, 6),
                    new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.5 })
                );
                leg.position.set(xOff, 0.15, 0);
                agentGroup.add(leg);
            });

            // Alert indicator (hidden by default)
            const alertGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const alertMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0
            });
            const alertIndicator = new THREE.Mesh(alertGeom, alertMat);
            alertIndicator.position.y = bodyHeight + 0.6;
            agentGroup.add(alertIndicator);
            agent.alertIndicator = alertIndicator;

            // Glow effect (type color)
            const glowGeom = new THREE.SphereGeometry(0.7, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.1
            });
            const glow = new THREE.Mesh(glowGeom, glowMat);
            glow.position.y = bodyHeight / 2;
            agentGroup.add(glow);
            agent.glow = glow;

            // v6.5.2: MUCH larger scale so agents are clearly visible on the map
            agentGroup.scale.setScalar(4.0);

            // v6.4.1: Position agents with proper spread - NEVER at origin
            // Use agent index in fleet for deterministic spread
            const agentIndex = agentFleet.indexOf(agent);
            const spreadAngle = (agentIndex * 0.7) + Math.random() * 0.5;  // Unique angle per agent
            const spreadDist = 5 + Math.random() * 8;  // 5-13 units from center

            let baseX = 0, baseZ = 0;

            // Get base position from player, ship, or default
            if (worldState.player && worldState.player.position) {
                baseX = worldState.player.position.x;
                baseZ = worldState.player.position.z;
            } else if (SHIP_STATE && SHIP_STATE.position) {
                baseX = SHIP_STATE.position.x;
                baseZ = SHIP_STATE.position.z;
            } else {
                // Default to center-ish of map with spread
                baseX = (Math.random() - 0.5) * 20;
                baseZ = (Math.random() - 0.5) * 20;
            }

            // Apply spread offset based on agent index
            const finalX = baseX + Math.cos(spreadAngle) * spreadDist;
            const finalZ = baseZ + Math.sin(spreadAngle) * spreadDist;

            // v6.5.1: Get terrain height BEFORE positioning - agents were spawning underground!
            let terrainY = 0;
            if (typeof getTerrainHeight === 'function') {
                terrainY = getTerrainHeight(finalX, finalZ);
            }
            agentGroup.position.set(finalX, terrainY, finalZ);

            console.log(`Agent ${agent.name}: Spawned at (${finalX.toFixed(1)}, ${terrainY.toFixed(1)}, ${finalZ.toFixed(1)}) - index ${agentIndex}`);

            agent.mesh = agentGroup;
            agent.position = agentGroup.position.clone();

            // v6.3.0: taskState is now initialized in spawnAgent - just update position reference
            if (agent.taskState) {
                agent.taskState.lastPosition = agent.position.clone();
            }

            scene.add(agentGroup);

            // v6.5.1: Ensure snapped to ground after scene add
            if (typeof snapToGround === 'function') {
                snapToGround(agentGroup);
            }

            // v6.4.1: Visual spawn effect
            if (particles) {
                particles.emit(agentGroup.position, 8, agent.typeConfig.color, { spread: 1.5, lifetime: 600, size: 0.12 });
            }
        }

        // Start autonomous decision loop for an agent
        // v6.60: DETERMINISTIC PRIMARY - API calls are supplementary hints only
        // Core decisions based on map state, endpoint enhances but never replaces
        function startAgentLoop(agent) {
            // IMMEDIATELY set agent to working status
            agent.status = 'working';
            agent.statusMessage = 'Systems online!';
            updateAgentCardUI(agent);

            // Run first deterministic action IMMEDIATELY based on map state
            runDeterministicAgentCommand(agent);
            agent.lastDecisionTime = performance.now();
            agent.lastApiCallTime = 0; // Track API calls separately
            agent.apiHint = null; // Store hints from API

            // Mesh retry counter
            let meshRetryCount = 0;
            const MAX_MESH_RETRIES = 50;  // Try for ~25 seconds

            const loop = () => {
                if (!agent || !agentFleet.includes(agent)) return;

                // v6.4.1: ROBUST mesh creation retry - createAgentMesh now handles positioning
                if (!agent.mesh && scene && meshRetryCount < MAX_MESH_RETRIES) {
                    meshRetryCount++;
                    console.log(`Agent ${agent.name}: Attempting mesh creation (attempt ${meshRetryCount})`);
                    createAgentMesh(agent);
                    if (agent.mesh) {
                        console.log(`Agent ${agent.name}: Mesh created successfully at (${agent.mesh.position.x.toFixed(1)}, ${agent.mesh.position.z.toFixed(1)})`);
                        updateAgentCardUI(agent);
                    }
                }

                const now = performance.now();

                // v6.60: PRIMARY - Run deterministic commands based on map state
                if (now - agent.lastDecisionTime >= agent.typeConfig.decisionInterval) {
                    agent.lastDecisionTime = now;

                    try {
                        // CORE: Deterministic command based on agent type and map state
                        runDeterministicAgentCommand(agent);
                    } catch (err) {
                        console.error(`Agent ${agent.name} deterministic error:`, err);
                    }
                }

                // v6.60: SUPPLEMENTARY - API calls for hints (every 15 seconds, non-blocking)
                const API_HINT_INTERVAL = 15000; // 15 seconds
                if (now - agent.lastApiCallTime >= API_HINT_INTERVAL) {
                    agent.lastApiCallTime = now;

                    // Non-blocking API hint request (doesn't affect core behavior)
                    requestAgentApiHint(agent).catch(() => {});
                }

                // Continue loop
                agentUpdateTimers[agent.id] = setTimeout(loop, 500);
            };

            // Start loop immediately
            loop();
        }

        // v6.60: CORE DETERMINISTIC COMMAND - Based on agent type and actual map state
        // This is the PRIMARY decision-making logic - runs without any API
        function runDeterministicAgentCommand(agent) {
            if (!agent.mesh) return;

            const task = agent.taskState;
            const agentPos = agent.mesh.position;
            const taskType = agent.typeConfig.taskType;

            // Build map context for decision
            const mapContext = scanMapContextForAgent(agent);

            // Deterministic command based on agent type and map state
            switch (taskType) {
                case 'gather':
                    executeGathererCommand(agent, mapContext);
                    break;
                case 'hunt':
                    executeHunterCommand(agent, mapContext);
                    break;
                case 'scout':
                    executeScoutCommand(agent, mapContext);
                    break;
                case 'protect':
                    executeProtectorCommand(agent, mapContext);
                    break;
                case 'heal':
                    executeHealerCommand(agent, mapContext);
                    break;
                case 'fish':
                    executeFisherCommand(agent, mapContext);
                    break;
                case 'mine':
                    executeMinerCommand(agent, mapContext);
                    break;
                case 'terraform':
                    executeTerraformerCommand(agent, mapContext);
                    break;
                case 'build':
                    executeBuilderCommand(agent, mapContext);
                    break;
                default:
                    executeGathererCommand(agent, mapContext);
            }

            // Update progress
            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100);

            saveGameData();
            updateAgentCardUI(agent);
        }

        // v6.60: Scan actual map state for deterministic decisions
        function scanMapContextForAgent(agent) {
            if (!agent.mesh) return {};

            const agentPos = agent.mesh.position;
            const scanRadius = 40; // World units to scan

            const context = {
                nearbyResources: [],
                nearbyEnemies: [],
                nearbyAllies: [],
                nearbyFishingSpots: [],
                nearbyConstructionSites: [],
                terrainData: [],
                playerPosition: worldState.player?.position?.clone() || null,
                playerHealth: gameData.player?.hp || 100,
                playerMaxHealth: gameData.player?.maxHp || 100,
                agentInventory: agent.taskState?.inventory || [],
                agentCarryingCapacity: agent.taskState?.carryingCapacity || 6,
                apiHint: agent.apiHint // Include any API-provided hints
            };

            // Scan interactables (trees, rocks, plants)
            if (worldState.interactables) {
                worldState.interactables.forEach(obj => {
                    if (!obj.parent) return;
                    const dist = agentPos.distanceTo(obj.position);
                    if (dist <= scanRadius) {
                        context.nearbyResources.push({
                            object: obj,
                            position: obj.position.clone(),
                            distance: dist,
                            type: obj.userData?.type || 'unknown',
                            name: obj.userData?.name || 'Resource',
                            hp: obj.userData?.hp || 0
                        });
                    }
                });
                // Sort by distance
                context.nearbyResources.sort((a, b) => a.distance - b.distance);
            }

            // Scan enemies
            if (worldState.mobs) {
                worldState.mobs.forEach(mob => {
                    if (!mob.mesh || mob.isDead) return;
                    const dist = agentPos.distanceTo(mob.mesh.position);
                    if (dist <= scanRadius) {
                        context.nearbyEnemies.push({
                            mob: mob,
                            position: mob.mesh.position.clone(),
                            distance: dist,
                            hp: mob.hp || 0,
                            type: mob.type || 'enemy',
                            isBoss: mob.isBoss || false
                        });
                    }
                });
                context.nearbyEnemies.sort((a, b) => a.distance - b.distance);
            }

            // Scan fishing spots
            if (worldState.fishingSpots) {
                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = agentPos.distanceTo(spot.position);
                    if (dist <= scanRadius) {
                        context.nearbyFishingSpots.push({
                            spot: spot,
                            position: spot.position.clone(),
                            distance: dist
                        });
                    }
                });
                context.nearbyFishingSpots.sort((a, b) => a.distance - b.distance);
            }

            // Scan construction sites
            if (worldState.constructionSites) {
                worldState.constructionSites.forEach(site => {
                    if (!site.mesh) return;
                    const dist = agentPos.distanceTo(site.mesh.position);
                    if (dist <= scanRadius) {
                        context.nearbyConstructionSites.push({
                            site: site,
                            position: site.mesh.position.clone(),
                            distance: dist,
                            claimed: site.claimedBy || null
                        });
                    }
                });
                context.nearbyConstructionSites.sort((a, b) => a.distance - b.distance);
            }

            // Scan other agents (allies)
            agentFleet.forEach(otherAgent => {
                if (otherAgent.id === agent.id || !otherAgent.mesh) return;
                const dist = agentPos.distanceTo(otherAgent.mesh.position);
                if (dist <= scanRadius) {
                    context.nearbyAllies.push({
                        agent: otherAgent,
                        position: otherAgent.mesh.position.clone(),
                        distance: dist,
                        type: otherAgent.type,
                        health: otherAgent.taskState?.hp || 50
                    });
                }
            });

            return context;
        }

        // v6.60: Deterministic Gatherer Command
        function executeGathererCommand(agent, mapContext) {
            const task = agent.taskState;

            // Initialize inventory if needed
            if (!task.inventory) task.inventory = [];
            if (!task.carryingCapacity) task.carryingCapacity = 6 + Math.floor(agent.agentLevel / 2);
            task.carryingCapacity = 6 + Math.floor(agent.agentLevel / 2);

            // COMMAND: If inventory full, return to ship
            if (task.inventory.length >= task.carryingCapacity) {
                if (task.state !== 'returning' && task.state !== 'depositing') {
                    task.state = 'returning';
                    task.targetPosition = SHIP_STATE.position.clone();
                    agent.statusMessage = ` Inventory full (${task.inventory.length}/${task.carryingCapacity}) - returning to ship`;
                    logAgentTask(agent, 'Inventory full, heading to ship');
                }
                return;
            }

            // COMMAND: Find nearest gatherable resource (trees, plants, bushes)
            const gatherTargets = mapContext.nearbyResources.filter(r =>
                r.type === 'tree' || r.name?.includes('Tree') ||
                r.name?.includes('Bush') || r.name?.includes('Plant') ||
                r.name?.includes('Herb') || r.type === 'plant'
            );

            if (gatherTargets.length > 0) {
                // API hint might suggest a specific resource type
                let target = gatherTargets[0];
                if (agent.apiHint?.preferredResource) {
                    const hintTarget = gatherTargets.find(t =>
                        t.name?.toLowerCase().includes(agent.apiHint.preferredResource.toLowerCase())
                    );
                    if (hintTarget) target = hintTarget;
                }

                task.targetObject = target.object;
                task.targetPosition = target.position;
                task.state = 'moving';
                agent.statusMessage = ` Targeting ${target.name} (${target.distance.toFixed(0)}m)`;

                // If close enough, harvest
                if (target.distance < 2) {
                    performAgentHarvest(agent, target.object);
                    trackAgentAction(agent, true, 5);
                }
            } else {
                // No resources found - wander to explore
                if (!task.targetPosition || agent.mesh.position.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agent.mesh.position);
                    task.state = 'moving';
                    agent.statusMessage = ' Searching for resources...';
                }
            }
        }

        // v6.60: Deterministic Hunter Command
        function executeHunterCommand(agent, mapContext) {
            const task = agent.taskState;

            // Filter out bosses unless we're high level
            const huntTargets = mapContext.nearbyEnemies.filter(e =>
                !e.isBoss || agent.agentLevel >= 5
            );

            if (huntTargets.length > 0) {
                const target = huntTargets[0];

                // If close enough, attack
                if (target.distance < 3) {
                    const damage = 10 + agent.agentLevel * 2;
                    target.mob.hp -= damage;

                    if (agent.mesh) {
                        spawnFloater(target.position, `-${damage}`, '#ff4444');
                        spawnAgentParticleEffect(agent, 'success');
                    }

                    agent.statusMessage = ` Attacking! -${damage} damage`;

                    // Check if killed
                    if (target.mob.hp <= 0) {
                        target.mob.isDead = true;
                        const xp = 15 + agent.agentLevel * 3;
                        const gold = 5 + agent.agentLevel;
                        if (typeof addXp === 'function') addXp('combat', xp);
                        gameData.gold = (gameData.gold || 0) + gold;
                        agent.totalEarnings.xp += xp;
                        agent.totalEarnings.gold += gold;
                        agent.statusMessage = ` Enemy defeated! +${xp} XP +${gold} gold`;
                        logAgentTask(agent, `Killed enemy: +${xp} XP +${gold} gold`);
                    }

                    trackAgentAction(agent, true, 8);
                    task.actionCooldown = 800; // Attack cooldown
                } else {
                    // Move to engage
                    task.targetPosition = target.position;
                    task.state = 'moving';
                    agent.statusMessage = ` Engaging enemy (${target.distance.toFixed(0)}m)`;
                }
            } else {
                // Patrol - wander looking for enemies
                if (!task.targetPosition || agent.mesh.position.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agent.mesh.position);
                    task.state = 'moving';
                    agent.statusMessage = ' Patrolling for hostiles...';
                }
            }
        }

        // v6.60: Deterministic Scout Command
        function executeScoutCommand(agent, mapContext) {
            const task = agent.taskState;

            // Scouts report discoveries and explore
            const hasEnemies = mapContext.nearbyEnemies.length > 0;
            const hasResources = mapContext.nearbyResources.length > 0;

            // Report significant findings
            if (hasEnemies && !task.lastReportedEnemies) {
                const enemyCount = mapContext.nearbyEnemies.length;
                agent.statusMessage = ` Spotted ${enemyCount} hostile(s)!`;
                if (typeof addCopilotMessage === 'function') {
                    addCopilotMessage(` ${agent.name} spotted ${enemyCount} enemies at (${Math.floor(agent.mesh.position.x)}, ${Math.floor(agent.mesh.position.z)})`, 'ai');
                }
                task.lastReportedEnemies = true;
                agent.results.push({ discovery: `Spotted ${enemyCount} enemies` });
                trackAgentAction(agent, true, 6);
            } else if (!hasEnemies) {
                task.lastReportedEnemies = false;
            }

            // Always explore - scouts move faster and further
            if (!task.targetPosition || agent.mesh.position.distanceTo(task.targetPosition) < 3) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 20; // Scouts go further
                const halfWorld = (CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;

                task.targetPosition = new THREE.Vector3(
                    Math.max(-halfWorld + 5, Math.min(halfWorld - 5, agent.mesh.position.x + Math.cos(angle) * distance)),
                    agent.mesh.position.y,
                    Math.max(-halfWorld + 5, Math.min(halfWorld - 5, agent.mesh.position.z + Math.sin(angle) * distance))
                );
                task.state = 'moving';
                agent.statusMessage = ' Scouting new territory...';
            }
        }

        // v6.60: Deterministic Protector Command
        function executeProtectorCommand(agent, mapContext) {
            const task = agent.taskState;

            // Priority 1: Engage nearby enemies
            if (mapContext.nearbyEnemies.length > 0) {
                const target = mapContext.nearbyEnemies[0];

                if (target.distance < 4) {
                    const damage = 12 + agent.agentLevel * 2;
                    target.mob.hp -= damage;

                    if (agent.mesh) {
                        spawnFloater(target.position, `-${damage}`, '#ff4444');
                        spawnAgentParticleEffect(agent, 'success');
                    }

                    agent.statusMessage = ` Defending! -${damage} damage`;
                    trackAgentAction(agent, true, 6);
                    task.actionCooldown = 600;

                    if (target.mob.hp <= 0) {
                        target.mob.isDead = true;
                        agent.statusMessage = ' Threat neutralized!';
                    }
                } else {
                    task.targetPosition = target.position;
                    task.state = 'moving';
                    agent.statusMessage = ` Intercepting threat (${target.distance.toFixed(0)}m)`;
                }
            } else {
                // No enemies - patrol near player
                if (mapContext.playerPosition) {
                    const distToPlayer = agent.mesh.position.distanceTo(mapContext.playerPosition);
                    if (distToPlayer > 15) {
                        task.targetPosition = mapContext.playerPosition.clone();
                        task.state = 'moving';
                        agent.statusMessage = ' Returning to player...';
                    } else {
                        agent.statusMessage = ' Area secure. Guarding player.';
                        task.state = 'idle';
                    }
                }
            }
        }

        // v6.60: Deterministic Healer Command
        function executeHealerCommand(agent, mapContext) {
            const task = agent.taskState;

            // Priority 1: Heal player if injured
            if (mapContext.playerHealth < mapContext.playerMaxHealth * 0.8) {
                if (mapContext.playerPosition) {
                    const distToPlayer = agent.mesh.position.distanceTo(mapContext.playerPosition);

                    if (distToPlayer < 5) {
                        const healAmount = 8 + agent.agentLevel * 2;
                        gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmount);
                        updateHealthUI();

                        agent.statusMessage = ` Healed player +${healAmount} HP`;
                        agent.results.push({ heal: healAmount });

                        if (agent.mesh) spawnAgentParticleEffect(agent, 'heal');
                        trackAgentAction(agent, true, 5);
                        task.actionCooldown = 2000; // Heal cooldown
                    } else {
                        task.targetPosition = mapContext.playerPosition;
                        task.state = 'moving';
                        agent.statusMessage = ` Moving to heal player (${distToPlayer.toFixed(0)}m)`;
                    }
                }
            } else {
                // Priority 2: Heal injured allies
                const injuredAlly = mapContext.nearbyAllies.find(a => a.health < 40);
                if (injuredAlly) {
                    if (injuredAlly.distance < 4) {
                        injuredAlly.agent.taskState.hp = Math.min(50, (injuredAlly.agent.taskState.hp || 50) + 10);
                        agent.statusMessage = ` Healed ${injuredAlly.agent.name}`;
                        trackAgentAction(agent, true, 4);
                    } else {
                        task.targetPosition = injuredAlly.position;
                        task.state = 'moving';
                    }
                } else {
                    // Stay near player
                    if (mapContext.playerPosition) {
                        const distToPlayer = agent.mesh.position.distanceTo(mapContext.playerPosition);
                        if (distToPlayer > 10) {
                            task.targetPosition = mapContext.playerPosition;
                            task.state = 'moving';
                        }
                    }
                    agent.statusMessage = ' All healthy. Standing by.';
                }
            }
        }

        // v6.60: Deterministic Fisher Command
        function executeFisherCommand(agent, mapContext) {
            const task = agent.taskState;

            // Initialize inventory
            if (!task.inventory) task.inventory = [];
            if (!task.carryingCapacity) task.carryingCapacity = 8 + Math.floor(agent.agentLevel / 2);

            // Return to ship if full
            if (task.inventory.length >= task.carryingCapacity) {
                if (task.state !== 'returning' && task.state !== 'depositing') {
                    task.state = 'returning';
                    task.targetPosition = SHIP_STATE.position.clone();
                    agent.statusMessage = ` Haul full! Returning (${task.inventory.length} fish)`;
                }
                return;
            }

            // Find fishing spots
            if (mapContext.nearbyFishingSpots.length > 0) {
                const spot = mapContext.nearbyFishingSpots[0];

                if (spot.distance < 3) {
                    // Fish!
                    task.state = 'working';

                    // Deterministic catch based on level
                    const catchChance = 0.3 + agent.agentLevel * 0.05;
                    if (Math.random() < catchChance) {
                        const fishTypes = ['Raw Fish'];
                        if (agent.agentLevel >= 3) fishTypes.push('Large Fish');
                        if (agent.agentLevel >= 5) fishTypes.push('Golden Fish');

                        const fishType = fishTypes[Math.floor(Math.random() * fishTypes.length)];
                        task.inventory.push(fishType);
                        agent.totalEarnings.items.push({ item: fishType, amount: 1 });

                        agent.statusMessage = fishType === 'Golden Fish'
                            ? ` Caught a Golden Fish! [${task.inventory.length}]`
                            : ` Caught ${fishType}! [${task.inventory.length}/${task.carryingCapacity}]`;

                        spawnFloater(agent.mesh.position, `+1 ${fishType}`, '#00ffff');
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                        trackAgentAction(agent, true, 4);
                    } else {
                        agent.statusMessage = ' Waiting for a bite...';
                    }
                    task.actionCooldown = 1500;
                } else {
                    task.targetPosition = spot.position;
                    task.state = 'moving';
                    agent.statusMessage = ` Heading to fishing spot (${spot.distance.toFixed(0)}m)`;
                }
            } else {
                // Search for water/fishing spots
                if (!task.targetPosition || agent.mesh.position.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agent.mesh.position);
                    task.state = 'moving';
                    agent.statusMessage = ' Searching for fishing spots...';
                }
            }
        }

        // v6.60: Deterministic Miner Command
        function executeMinerCommand(agent, mapContext) {
            const task = agent.taskState;

            // Initialize inventory
            if (!task.inventory) task.inventory = [];
            if (!task.carryingCapacity) task.carryingCapacity = 8 + Math.floor(agent.agentLevel / 2);
            task.carryingCapacity = 8 + Math.floor(agent.agentLevel / 2);

            // Return if full
            if (task.inventory.length >= task.carryingCapacity) {
                if (task.state !== 'returning' && task.state !== 'depositing') {
                    task.state = 'returning';
                    task.targetPosition = SHIP_STATE.position.clone();
                    agent.statusMessage = ` Inventory full - returning`;
                }
                return;
            }

            // Find mining targets
            const mineTargets = mapContext.nearbyResources.filter(r =>
                r.type === 'rock' || r.name?.includes('Ore') ||
                r.name?.includes('Crystal') || r.name?.includes('Stone')
            );

            if (mineTargets.length > 0) {
                const target = mineTargets[0];

                if (target.distance < 2) {
                    performAgentHarvest(agent, target.object);
                    trackAgentAction(agent, true, 6);
                } else {
                    task.targetObject = target.object;
                    task.targetPosition = target.position;
                    task.state = 'moving';
                    agent.statusMessage = ` Mining ${target.name} (${target.distance.toFixed(0)}m)`;
                }
            } else {
                // Search for deposits
                if (!task.targetPosition || agent.mesh.position.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agent.mesh.position);
                    task.state = 'moving';
                    agent.statusMessage = ' Searching for ore deposits...';
                }
            }
        }

        // v6.60: Deterministic Terraformer Command (uses existing intelligent logic)
        function executeTerraformerCommand(agent, mapContext) {
            // Terraformer already has intelligent site selection in simulateAgentDecision
            // Call the existing terraform case logic
            const gameContext = buildGameContextForAgent(agent);

            // Use the existing terraform logic (already deterministic)
            const taskType = 'terraform';
            const rand = Math.random();
            const terraformRate = getAgentSuccessRate(agent, 0.7);

            if (rand < terraformRate && agent.mesh) {
                // Reuse existing intelligent site scanner from simulateAgentDecision
                simulateTerraformAction(agent);
            } else {
                agent.statusMessage = ' Scanning terrain topology...';
            }
            trackAgentAction(agent, true, 10);
        }

        // v6.60: Helper for terraform (extracted from simulateAgentDecision)
        function simulateTerraformAction(agent) {
            if (!agent.mesh) return;

            const agentX = Math.floor((agent.mesh.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const agentZ = Math.floor((agent.mesh.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

            // Calculate terrain roughness in an area
            const calculateRoughness = (cx, cz, radius) => {
                let heights = [];
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const tx = cx + dx, tz = cz + dz;
                        if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                            heights.push(worldState.terrain[tx][tz]);
                        }
                    }
                }
                if (heights.length < 2) return 0;
                const avg = heights.reduce((a, b) => a + b, 0) / heights.length;
                const variance = heights.reduce((sum, h) => sum + Math.pow(h - avg, 2), 0) / heights.length;
                return Math.sqrt(variance);
            };

            const roughness = calculateRoughness(agentX, agentZ, 2);

            if (roughness > 0.2) {
                // Smooth the terrain
                const smoothRadius = 2;
                let totalHeight = 0, count = 0;
                let heightMap = [];

                for (let dx = -smoothRadius; dx <= smoothRadius; dx++) {
                    for (let dz = -smoothRadius; dz <= smoothRadius; dz++) {
                        const tx = agentX + dx, tz = agentZ + dz;
                        if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                            const h = worldState.terrain[tx][tz];
                            totalHeight += h;
                            count++;
                            heightMap.push({ tx, tz, h });
                        }
                    }
                }

                if (count > 0) {
                    const avgHeight = totalHeight / count;
                    for (const cell of heightMap) {
                        worldState.terrain[cell.tx][cell.tz] = cell.h + (avgHeight - cell.h) * 0.8;
                    }

                    agent.statusMessage = ` Smoothed terrain at (${agentX}, ${agentZ})`;
                    if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                }
            } else {
                // Area smooth - move to find rough terrain
                moveAgentToRandomPosition(agent);
                agent.statusMessage = ' Seeking uneven terrain...';
            }
        }

        // v6.60: Deterministic Builder Command (uses existing intelligent logic)
        function executeBuilderCommand(agent, mapContext) {
            const task = agent.taskState;

            // Find unclaimed construction sites
            const availableSites = mapContext.nearbyConstructionSites.filter(s =>
                !s.claimed || s.claimed === agent.name
            );

            if (availableSites.length > 0) {
                const site = availableSites[0];

                if (site.distance < 3) {
                    // Build at site
                    task.state = 'working';
                    agent.statusMessage = ` Building at (${Math.floor(site.position.x)}, ${Math.floor(site.position.z)})`;

                    // Mark as claimed
                    if (site.site) site.site.claimedBy = agent.name;

                    // Building progress
                    if (!site.site.buildProgress) site.site.buildProgress = 0;
                    site.site.buildProgress += 10 + agent.agentLevel * 2;

                    if (site.site.buildProgress >= 100) {
                        // Complete construction
                        agent.statusMessage = ' Construction complete!';
                        if (typeof addCopilotMessage === 'function') {
                            addCopilotMessage(` ${agent.name} completed construction at (${Math.floor(site.position.x)}, ${Math.floor(site.position.z)})!`, 'ai');
                        }
                        // Remove from construction sites
                        worldState.constructionSites = worldState.constructionSites.filter(s => s !== site.site);
                    }

                    if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    trackAgentAction(agent, true, 10);
                    task.actionCooldown = 1000;
                } else {
                    task.targetPosition = site.position;
                    task.state = 'moving';
                    agent.statusMessage = ` Heading to construction site (${site.distance.toFixed(0)}m)`;
                }
            } else {
                // Search for sites
                if (!task.targetPosition || agent.mesh.position.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agent.mesh.position);
                    task.state = 'moving';
                    agent.statusMessage = ' Searching for construction sites...';
                }
            }
        }

        // v6.60: SUPPLEMENTARY API hint request (non-blocking, enhances but doesn't replace)
        async function requestAgentApiHint(agent) {
            const endpoint = getAgentEndpoint(agent);

            // No endpoint = no hints (core logic handles everything)
            if (!endpoint || !endpoint.url || !endpoint.key) {
                return;
            }

            try {
                const gameContext = buildGameContextForAgent(agent);
                const mapSummary = summarizeMapForApi(agent);

                const hintRequest = {
                    role: 'user',
                    content: `Agent ${agent.name} (${agent.type}) needs a quick hint. Map: ${mapSummary}. Current task: ${agent.statusMessage}. Respond with brief JSON hint: {"preferredResource": "type or null", "priority": "gather|fight|explore|heal", "suggestion": "brief tip"}`
                };

                const headers = {
                    'Content-Type': 'application/json'
                };

                if (endpoint.headerPrefix) {
                    headers[endpoint.headerStyle] = endpoint.headerPrefix + endpoint.key;
                } else {
                    headers[endpoint.headerStyle] = endpoint.key;
                }

                const requestBody = formatAgentRequestBody(endpoint, hintRequest, [hintRequest], agent);

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (response.ok) {
                    const data = await response.json();
                    const textResponse = parseAgentResponse(endpoint, data);

                    // Try to parse hint
                    try {
                        const hint = JSON.parse(textResponse);
                        agent.apiHint = hint;
                        console.log(`Agent ${agent.name} received API hint:`, hint);
                    } catch {
                        // Non-JSON response - store as suggestion
                        agent.apiHint = { suggestion: textResponse.substring(0, 100) };
                    }
                }
            } catch (err) {
                // Silently fail - API hints are supplementary
                console.debug(`Agent ${agent.name} API hint failed (non-critical):`, err.message);
            }
        }

        // v6.60: Summarize map state for API hint request
        function summarizeMapForApi(agent) {
            if (!agent.mesh) return 'No position data';

            const pos = agent.mesh.position;
            const nearbyResources = worldState.interactables?.filter(o =>
                o.parent && o.position.distanceTo(pos) < 20
            ).length || 0;
            const nearbyEnemies = worldState.mobs?.filter(m =>
                m.mesh && !m.isDead && m.mesh.position.distanceTo(pos) < 20
            ).length || 0;

            return `pos:(${Math.floor(pos.x)},${Math.floor(pos.z)}) resources:${nearbyResources} enemies:${nearbyEnemies} inv:${agent.taskState?.inventory?.length || 0}`;
        }

        // v5.12.1: Make an autonomous decision for an agent via configurable API endpoint
        async function makeAgentDecision(agent) {
            // Get agent-specific endpoint (may differ from global)
            const endpoint = getAgentEndpoint(agent);

            // Build real-time context
            const gameContext = buildGameContextForAgent(agent);

            // Inject context into a user message
            const contextMessage = {
                role: 'user',
                content: `Current situation: ${JSON.stringify(gameContext)}. What's your next action?`
            };

            // Build conversation for API
            const conversationForApi = [...agent.conversationHistory, contextMessage];

            // If no endpoint configured, use simulated local decisions
            if (!endpoint || !endpoint.url || !endpoint.key) {
                // v5.15: Log why we're falling back to simulation
                if (!endpoint) {
                    console.log(`Agent ${agent.name}: No endpoint configured, using simulation`);
                } else if (!endpoint.url) {
                    console.log(`Agent ${agent.name}: Missing endpoint URL, using simulation`);
                } else if (!endpoint.key) {
                    console.log(`Agent ${agent.name}: Missing API key for ${endpoint.name}, using simulation. Check RAPPID settings.`);
                    agent.statusMessage = 'API key missing - using simulation';
                }
                simulateAgentDecision(agent, gameContext);
                return;
            }

            try {
                agent.status = 'thinking';
                agent.activeEndpoint = endpoint.name; // Track which endpoint is being used
                updateAgentCardUI(agent);

                // Build headers based on endpoint configuration
                const headers = {
                    'Content-Type': 'application/json'
                };

                // Add auth header based on endpoint style
                if (endpoint.headerPrefix) {
                    headers[endpoint.headerStyle] = endpoint.headerPrefix + endpoint.key;
                } else {
                    headers[endpoint.headerStyle] = endpoint.key;
                }

                // Format body based on endpoint type
                const requestBody = formatAgentRequestBody(endpoint, contextMessage, conversationForApi, agent);

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (response.ok) {
                    const data = await response.json();

                    // Parse response based on endpoint type
                    const textResponse = parseAgentResponse(endpoint, data);

                    // v5.15.2: Store full interaction for Try Again replay
                    const interactionRecord = {
                        id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
                        timestamp: Date.now(),
                        contextMessage: { ...contextMessage },
                        gameContext: { ...gameContext },
                        endpoint: { name: endpoint.name, url: endpoint.url },
                        request: JSON.parse(requestBody),
                        response: textResponse,
                        rawResponse: data,
                        conversationIndexBefore: agent.conversationHistory.length,
                        executed: false  // Will be set true after execution
                    };
                    agent.interactionHistory.push(interactionRecord);
                    // Keep last 20 interactions
                    if (agent.interactionHistory.length > 20) {
                        agent.interactionHistory.shift();
                    }

                    // Add to conversation history (keep last 20 messages to avoid token overflow)
                    agent.conversationHistory.push(contextMessage);
                    agent.conversationHistory.push({ role: 'assistant', content: textResponse });
                    if (agent.conversationHistory.length > 22) {
                        // Keep system message + last 20
                        agent.conversationHistory = [
                            agent.conversationHistory[0],
                            ...agent.conversationHistory.slice(-20)
                        ];
                    }

                    // Parse and execute the decision
                    parseAndExecuteAgentDecision(agent, textResponse);

                    // v5.15.2: Mark interaction as executed
                    interactionRecord.executed = true;
                    interactionRecord.conversationIndexAfter = agent.conversationHistory.length;
                } else {
                    // v5.15: Better error logging
                    const errorText = await response.text().catch(() => '');
                    console.warn(`Agent ${agent.name} API error (${endpoint.name}): HTTP ${response.status}`, errorText.substring(0, 200));
                    if (response.status === 401 || response.status === 403) {
                        agent.statusMessage = `Auth failed (${response.status}) - check API key`;
                    } else {
                        agent.statusMessage = `API error ${response.status} - using fallback`;
                    }
                    simulateAgentDecision(agent, gameContext);
                }
            } catch (error) {
                console.error(`Agent ${agent.name} decision error (${endpoint.name}):`, error);
                agent.statusMessage = 'Network error - using fallback';
                simulateAgentDecision(agent, gameContext);
            }

            agent.status = 'working';
            updateAgentCardUI(agent);
        }

        // Build game context for agent decision
        function buildGameContextForAgent(agent) {
            const elapsed = (performance.now() - agent.spawnTime) / 1000;

            return {
                agent_name: agent.name,
                agent_type: agent.type,
                mission_time_seconds: Math.floor(elapsed),
                player_hp: gameData.player?.hp || 100,
                player_max_hp: gameData.player?.maxHp || 100,
                player_position: worldState.player ? {
                    x: Math.floor(worldState.player.position.x),
                    z: Math.floor(worldState.player.position.z)
                } : { x: 0, z: 0 },
                current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                nearby_enemies: countNearbyEnemies(agent),
                items_gathered: agent.totalEarnings.items.length,
                xp_earned: agent.totalEarnings.xp,
                gold_earned: agent.totalEarnings.gold
            };
        }

        // Count enemies near an agent
        function countNearbyEnemies(agent) {
            if (!worldState.mobs || !agent.position) return 0;
            return worldState.mobs.filter(mob => {
                if (!mob.mesh) return false;
                return mob.mesh.position.distanceTo(agent.position) < 15;
            }).length;
        }

        // Parse API response and execute agent action
        function parseAndExecuteAgentDecision(agent, response) {
            try {
                // Try to extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const decision = JSON.parse(jsonMatch[0]);
                    executeAgentAction(agent, decision);
                } else {
                    // No JSON, use response as status message
                    agent.statusMessage = response.substring(0, 100);
                }
            } catch (e) {
                // Parse failed, treat as status update
                agent.statusMessage = response.substring(0, 100);
            }
            updateAgentCardUI(agent);
        }

        // Execute an agent action based on decision
        function executeAgentAction(agent, decision) {
            agent.statusMessage = decision.message || 'Working...';

            // Process results
            if (decision.results) {
                decision.results.forEach(result => {
                    if (result.item && result.amount) {
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push({ item: result.item, amount: result.amount });
                        agent.results.push({ item: result.item, amount: result.amount });
                    }
                    if (result.xp) {
                        if (typeof addXp === 'function') addXp('combat', result.xp);
                        agent.totalEarnings.xp += result.xp;
                    }
                    if (result.gold) {
                        gameData.gold = (gameData.gold || 0) + result.gold;
                        agent.totalEarnings.gold += result.gold;
                    }
                    if (result.loot) {
                        addToInventory(result.loot, 1);
                        agent.totalEarnings.items.push({ item: result.loot, amount: 1 });
                    }
                });
            }

            // Process discoveries (for scouts/explorers)
            if (decision.discoveries) {
                decision.discoveries.forEach(d => {
                    agent.results.push({ discovery: d.description });
                });
            }

            // Process healing
            if (decision.heal_amount) {
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + decision.heal_amount);
                updateHealthUI();
                agent.results.push({ heal: decision.heal_amount });
            }

            // Process catch (fishing)
            if (decision.catch) {
                decision.catch.forEach(c => {
                    if (c.item && c.amount) {
                        addToInventory(c.item, c.amount);
                        agent.totalEarnings.items.push({ item: c.item, amount: c.amount });
                        agent.results.push({ item: c.item, amount: c.amount });
                    }
                });
            }

            // Process ore (mining)
            if (decision.ore) {
                decision.ore.forEach(o => {
                    if (o.item && o.amount) {
                        addToInventory(o.item, o.amount);
                        agent.totalEarnings.items.push({ item: o.item, amount: o.amount });
                        agent.results.push({ item: o.item, amount: o.amount });
                    }
                });
            }

            // Update progress based on time
            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100); // 100% at 1 minute

            saveGameData();
        }

        // v5.17: Simulate agent decision with efficiency system (fallback when no API)
        function simulateAgentDecision(agent, context) {
            const taskType = agent.typeConfig.taskType;

            // v5.17: Use efficiency-modified success rates
            const rand = Math.random();
            let result = {};
            let success = false;

            switch (taskType) {
                case 'gather':
                    // v5.17: Base rate 0.4, modified by efficiency
                    const gatherRate = getAgentSuccessRate(agent, 0.4);
                    if (rand < gatherRate) {
                        const items = ['Logs', 'Fiber', 'Stone', 'Herbs'];
                        // v5.17: Amount scales with agent level
                        const bonusAmount = Math.floor(agent.agentLevel / 3);
                        result = { item: items[Math.floor(Math.random() * items.length)], amount: Math.floor(Math.random() * 2) + 1 + bonusAmount };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    }
                    agent.statusMessage = success ? `Found ${result.amount} ${result.item}!` : 'Searching for resources...';
                    trackAgentAction(agent, success, 5);
                    break;

                case 'hunt':
                    // v5.17: Base rate 0.3, modified by efficiency
                    const huntRate = getAgentSuccessRate(agent, 0.3);
                    if (rand < huntRate) {
                        // v5.17: XP and gold scale with agent level
                        result.xp = Math.floor(Math.random() * 20) + 10 + agent.agentLevel * 2;
                        result.gold = Math.floor(Math.random() * 10) + 3 + agent.agentLevel;
                        if (typeof addXp === 'function') addXp('combat', result.xp);
                        gameData.gold = (gameData.gold || 0) + result.gold;
                        agent.totalEarnings.xp += result.xp;
                        agent.totalEarnings.gold += result.gold;
                        agent.results.push(result);
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    }
                    agent.statusMessage = success ? `Defeated enemy! +${result.xp} XP` : 'Hunting enemies...';
                    trackAgentAction(agent, success, 8);
                    break;

                case 'scout':
                    // v5.17: Base rate 0.25, modified by efficiency
                    const scoutRate = getAgentSuccessRate(agent, 0.25);
                    if (rand < scoutRate) {
                        const discoveries = ['Found a resource deposit', 'Spotted enemy camp', 'Discovered safe path', 'Located point of interest'];
                        const disc = discoveries[Math.floor(Math.random() * discoveries.length)];
                        agent.results.push({ discovery: disc });
                        agent.statusMessage = disc;
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    } else {
                        agent.statusMessage = 'Surveying the area...';
                    }
                    trackAgentAction(agent, success, 4);
                    break;

                case 'protect':
                    const nearbyEnemies = countNearbyEnemies(agent);
                    // v5.17: Base rate 0.5, modified by efficiency
                    const protectRate = getAgentSuccessRate(agent, 0.5);
                    if (nearbyEnemies > 0 && rand < protectRate) {
                        agent.statusMessage = `Engaging ${nearbyEnemies} threat(s)!`;
                        // v5.17: Damage scales with agent level
                        const damage = 8 + agent.agentLevel * 2;
                        if (worldState.mobs) {
                            const nearMob = worldState.mobs.find(m => m.mesh && m.mesh.position.distanceTo(agent.position) < 15);
                            if (nearMob) {
                                nearMob.hp -= damage;
                                if (agent.mesh) {
                                    spawnFloater(agent.mesh.position, `-${damage}`, agent.typeConfig.color.toString(16));
                                    spawnAgentParticleEffect(agent, 'success');
                                }
                                success = true;
                            }
                        }
                    } else {
                        agent.statusMessage = nearbyEnemies > 0 ? 'Alert! Enemies nearby.' : 'Area secure.';
                    }
                    trackAgentAction(agent, success, 6);
                    break;

                case 'heal':
                    // v5.17: Base rate 0.5, modified by efficiency
                    const healRate = getAgentSuccessRate(agent, 0.5);
                    if (gameData.player.hp < gameData.player.maxHp && rand < healRate) {
                        // v5.17: Heal amount scales with agent level
                        const healAmt = Math.floor(Math.random() * 8) + 5 + agent.agentLevel * 2;
                        gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                        updateHealthUI();
                        agent.results.push({ heal: healAmt });
                        agent.statusMessage = `Healed player for ${healAmt} HP!`;
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'heal');
                    } else {
                        agent.statusMessage = gameData.player.hp < gameData.player.maxHp ? 'Channeling healing energy...' : 'Player at full health.';
                    }
                    trackAgentAction(agent, success, 5);
                    break;

                case 'fish':
                    // v5.17: Base rate 0.3, modified by efficiency
                    const fishRate = getAgentSuccessRate(agent, 0.3);
                    if (rand < fishRate) {
                        // v5.17: Chance for rare fish at higher levels
                        const fishTypes = ['Raw Fish', 'Raw Fish', 'Raw Fish'];
                        if (agent.agentLevel >= 3) fishTypes.push('Large Fish');
                        if (agent.agentLevel >= 5) fishTypes.push('Golden Fish');
                        result = { item: fishTypes[Math.floor(Math.random() * fishTypes.length)], amount: 1 };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        success = true;
                        agent.statusMessage = result.item === 'Golden Fish' ? ' Caught a Golden Fish!' : 'Caught a fish!';
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    } else {
                        agent.statusMessage = rand < 0.5 ? 'Waiting for a bite...' : 'Casting line...';
                    }
                    trackAgentAction(agent, success, 4);
                    break;

                case 'mine':
                    // v5.17: Base rate 0.35, modified by efficiency
                    const mineRate = getAgentSuccessRate(agent, 0.35);
                    if (rand < mineRate) {
                        // v5.17: Better ores at higher levels
                        const ores = ['Iron Ore', 'Copper Ore', 'Stone'];
                        if (agent.agentLevel >= 3) ores.push('Silver Ore');
                        if (agent.agentLevel >= 5) ores.push('Gold Ore');
                        if (agent.agentLevel >= 7) ores.push('Crystal');
                        const bonusAmount = Math.floor(agent.agentLevel / 4);
                        result = { item: ores[Math.floor(Math.random() * ores.length)], amount: Math.floor(Math.random() * 2) + 1 + bonusAmount };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        success = true;
                        agent.statusMessage = `Mined ${result.amount} ${result.item}!`;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    } else {
                        agent.statusMessage = 'Mining deposit...';
                    }
                    trackAgentAction(agent, success, 6);
                    break;

                // v6.10: INTELLIGENT TERRAFORMER - Seeks clear areas and smooths rough terrain for building
                // v6.33: Increased base rate from 0.4 to 0.7 for more reliable terraforming
                case 'terraform':
                    const terraformRate = getAgentSuccessRate(agent, 0.7);
                    if (rand < terraformRate && agent.mesh) {
                        // v6.10: Intelligent terrain scanning and site selection
                        const agentX = Math.floor((agent.mesh.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
                        const agentZ = Math.floor((agent.mesh.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

                        // ========================
                        // INTELLIGENT SITE SCANNER
                        // ========================

                        // Calculate terrain roughness in an area (higher = more uneven = needs smoothing)
                        const calculateRoughness = (cx, cz, radius) => {
                            let heights = [];
                            for (let dx = -radius; dx <= radius; dx++) {
                                for (let dz = -radius; dz <= radius; dz++) {
                                    const tx = cx + dx, tz = cz + dz;
                                    if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                                        heights.push(worldState.terrain[tx][tz]);
                                    }
                                }
                            }
                            if (heights.length < 2) return 0;
                            const avg = heights.reduce((a, b) => a + b, 0) / heights.length;
                            const variance = heights.reduce((sum, h) => sum + Math.pow(h - avg, 2), 0) / heights.length;
                            return Math.sqrt(variance);
                        };

                        // Count obstacles (trees/rocks) in an area
                        const countObstacles = (cx, cz, radius) => {
                            const worldCenterX = (cx - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
                            const worldCenterZ = (cz - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
                            const searchRadius = radius * CONFIG.TILE_SIZE;
                            let count = 0;
                            for (const obj of worldState.interactables) {
                                if (obj.userData && (obj.userData.type === 'tree' || obj.userData.type === 'rock')) {
                                    const dist = Math.sqrt(
                                        Math.pow(obj.position.x - worldCenterX, 2) +
                                        Math.pow(obj.position.z - worldCenterZ, 2)
                                    );
                                    if (dist <= searchRadius) count++;
                                }
                            }
                            return count;
                        };

                        // Check if area is already terraformed
                        const isAlreadyTerraformed = (cx, cz, minDist = 4) => {
                            return worldState.terraformedAreas.some(a =>
                                Math.abs(a.x - cx) < minDist && Math.abs(a.z - cz) < minDist);
                        };

                        // =============================
                        // FIND BEST BUILDING SITE (AI)
                        // =============================
                        const findBestBuildingSite = () => {
                            let bestSite = null;
                            let bestScore = -Infinity;
                            const scanRadius = 15; // Tiles around agent to scan
                            const siteRadius = 3;  // Size of potential building site

                            for (let dx = -scanRadius; dx <= scanRadius; dx += 3) {
                                for (let dz = -scanRadius; dz <= scanRadius; dz += 3) {
                                    const sx = agentX + dx;
                                    const sz = agentZ + dz;

                                    // Skip invalid positions
                                    if (sx < 2 || sx >= CONFIG.WORLD_SIZE - 2 || sz < 2 || sz >= CONFIG.WORLD_SIZE - 2) continue;

                                    // Skip water areas
                                    if (!worldState.terrain[sx] || worldState.terrain[sx][sz] <= 0) continue;

                                    // Skip already terraformed areas
                                    if (isAlreadyTerraformed(sx, sz)) continue;

                                    // Calculate scores
                                    const obstacles = countObstacles(sx, sz, siteRadius);
                                    const roughness = calculateRoughness(sx, sz, siteRadius);

                                    // Scoring: Prioritize clear areas with rough terrain
                                    // High roughness = needs smoothing (good)
                                    // Low obstacles = clear for building (very good)
                                    const clearBonus = obstacles === 0 ? 50 : (obstacles <= 2 ? 20 : -obstacles * 5);
                                    const roughBonus = roughness * 10; // More rough = more valuable to smooth
                                    const distancePenalty = Math.sqrt(dx * dx + dz * dz) * 0.5;

                                    const score = clearBonus + roughBonus - distancePenalty;

                                    // v6.33: Lowered roughness threshold from 0.5 to 0.2 for more terraforming action
                                    if (score > bestScore && roughness > 0.2) {
                                        bestScore = score;
                                        bestSite = {
                                            x: sx, z: sz,
                                            obstacles, roughness,
                                            score,
                                            worldX: (sx - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE,
                                            worldZ: (sz - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE
                                        };
                                    }
                                }
                            }
                            return bestSite;
                        };

                        // Find the best site
                        const bestSite = findBestBuildingSite();

                        // ================================
                        // INTELLIGENT SITE NAVIGATION & SMOOTHING
                        // ================================

                        // If we found a good site and we're not there, navigate to it
                        if (bestSite && !agent.terraformTarget) {
                            const distToSite = Math.sqrt(
                                Math.pow(agentX - bestSite.x, 2) + Math.pow(agentZ - bestSite.z, 2)
                            );

                            if (distToSite > 2) {
                                // Navigate to the best site
                                agent.terraformTarget = bestSite;
                                agent.targetPosition = new THREE.Vector3(bestSite.worldX, agent.mesh.position.y, bestSite.worldZ);
                                agent.taskState.state = 'moving';
                                agent.taskState.targetPosition = agent.targetPosition.clone();

                                const siteQuality = bestSite.obstacles === 0 ? ' CLEAR' : (bestSite.obstacles <= 2 ? ' SOME OBSTACLES' : ' OBSTRUCTED');
                                agent.statusMessage = ` Found building site (${bestSite.x}, ${bestSite.z}) - ${siteQuality}`;

                                if (typeof addCopilotMessage === 'function' && bestSite.obstacles === 0) {
                                    addCopilotMessage(` ${agent.name} detected clear building site at (${bestSite.x}, ${bestSite.z}) - Roughness: ${bestSite.roughness.toFixed(1)}`, 'ai');
                                }
                                break;
                            }
                        }

                        // Clear terraformTarget if we arrived
                        if (agent.terraformTarget) {
                            const distToTarget = Math.sqrt(
                                Math.pow(agentX - agent.terraformTarget.x, 2) +
                                Math.pow(agentZ - agent.terraformTarget.z, 2)
                            );
                            if (distToTarget <= 2) {
                                agent.terraformTarget = null;
                                agent.statusMessage = ' Arrived at site - beginning terrain smoothing...';
                            }
                        }

                        // ================================
                        // ENHANCED 5x5 TERRAIN SMOOTHING
                        // ================================
                        const smoothRadius = 2; // 5x5 area (radius of 2)
                        let maxHeight = -Infinity, minHeight = Infinity;
                        let totalHeight = 0, count = 0;
                        let heightMap = [];

                        for (let dx = -smoothRadius; dx <= smoothRadius; dx++) {
                            for (let dz = -smoothRadius; dz <= smoothRadius; dz++) {
                                const tx = agentX + dx, tz = agentZ + dz;
                                if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                                    const h = worldState.terrain[tx][tz];
                                    maxHeight = Math.max(maxHeight, h);
                                    minHeight = Math.min(minHeight, h);
                                    totalHeight += h;
                                    count++;
                                    heightMap.push({ tx, tz, h });
                                }
                            }
                        }

                        if (count > 0) {
                            const avgHeight = totalHeight / count;
                            const variance = maxHeight - minHeight;
                            const roughness = calculateRoughness(agentX, agentZ, smoothRadius);

                            // v6.33: Lowered variance threshold from 1 to 0.3, roughness from 0.5 to 0.2
                            if (variance > 0.3 || roughness > 0.2) {
                                // ================================
                                // SMOOTH OPERATION - Gradual averaging
                                // ================================
                                const smoothingStrength = 0.8; // How much to smooth (0-1)

                                for (const cell of heightMap) {
                                    // Smooth towards average with strength factor
                                    const newHeight = cell.h + (avgHeight - cell.h) * smoothingStrength;
                                    worldState.terrain[cell.tx][cell.tz] = newHeight;
                                }

                                // v6.33: Update the visual terrain meshes to match the smoothed data
                                if (typeof worldState.updateTerrainMeshes === 'function') {
                                    worldState.updateTerrainMeshes(agentX, agentZ, smoothRadius);
                                }

                                // Record terraformed area with metadata
                                const existingArea = worldState.terraformedAreas.find(a =>
                                    Math.abs(a.x - agentX) < 4 && Math.abs(a.z - agentZ) < 4);

                                if (!existingArea) {
                                    const obstacles = countObstacles(agentX, agentZ, smoothRadius);
                                    const newTerraformedArea = {
                                        x: agentX, z: agentZ,
                                        flatness: 100,
                                        createdAt: Date.now(),
                                        createdBy: agent.name,
                                        size: (smoothRadius * 2 + 1) + 'x' + (smoothRadius * 2 + 1),
                                        clearance: obstacles === 0 ? 'clear' : 'partial',
                                        avgHeight: avgHeight.toFixed(2),
                                        originalRoughness: roughness.toFixed(2)
                                    };
                                    worldState.terraformedAreas.push(newTerraformedArea);

                                    // v6.11: Spawn construction site beacon for CLEAR areas
                                    if (obstacles === 0 && typeof createConstructionSiteBeacon === 'function') {
                                        createConstructionSiteBeacon(newTerraformedArea);
                                        if (typeof addCopilotMessage === 'function') {
                                            addCopilotMessage(` ${agent.name} deployed CONSTRUCTION BEACON at (${agentX}, ${agentZ}) - Builder agents notified!`, 'ai');
                                        }
                                    } else if (obstacles === 0 && typeof addCopilotMessage === 'function') {
                                        addCopilotMessage(` ${agent.name} prepared a CLEAR 5x5 building site at (${agentX}, ${agentZ})!`, 'ai');
                                    }
                                }

                                success = true;
                                const siteStatus = countObstacles(agentX, agentZ, smoothRadius) === 0 ? ' READY FOR BUILDING' : ' Smoothed';
                                agent.statusMessage = ` ${siteStatus} at (${agentX}, ${agentZ})`;
                                agent.results.push({
                                    terraformed: {
                                        x: agentX, z: agentZ,
                                        flatness: 100,
                                        size: '5x5',
                                        clear: countObstacles(agentX, agentZ, smoothRadius) === 0,
                                        originalRoughness: roughness.toFixed(2)
                                    }
                                });
                                if (agent.mesh) spawnAgentParticleEffect(agent, 'success');

                            } else {
                                // Area already flat - seek new site
                                agent.statusMessage = ' Area already smooth, scanning for rough terrain...';

                                // Try to find a new site
                                if (bestSite) {
                                    agent.targetPosition = new THREE.Vector3(bestSite.worldX, agent.mesh.position.y, bestSite.worldZ);
                                    agent.taskState.state = 'moving';
                                    agent.taskState.targetPosition = agent.targetPosition.clone();
                                    agent.statusMessage = ` Relocating to (${bestSite.x}, ${bestSite.z})...`;
                                } else {
                                    // No good sites nearby - wander to explore
                                    moveAgentToRandomPosition(agent);
                                    agent.statusMessage = ' Exploring for uneven terrain...';
                                }
                            }
                        } else {
                            agent.statusMessage = ' Scanning terrain topology...';
                        }
                    } else {
                        // Not performing action - show scanning status
                        const scanMessages = [
                            ' Analyzing terrain data...',
                            ' Scanning for clear areas...',
                            ' Mapping terrain roughness...',
                            ' Calculating optimal sites...'
                        ];
                        agent.statusMessage = scanMessages[Math.floor(Math.random() * scanMessages.length)];
                    }
                    trackAgentAction(agent, success, 8);
                    break;

                // v6.11: INTELLIGENT Builder - seeks construction sites and builds optimal structures
                case 'build':
                    const buildRate = getAgentSuccessRate(agent, 0.35);
                    if (rand < buildRate && agent.mesh) {
                        const agentX = Math.floor((agent.mesh.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
                        const agentZ = Math.floor((agent.mesh.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

                        // ================================
                        // v6.11: INTELLIGENT SITE SEEKING
                        // ================================

                        // First, check if there's a construction site beacon to navigate to
                        if (!agent.targetConstructionSite && typeof findNearestConstructionSite === 'function') {
                            const nearestSite = findNearestConstructionSite(agentX, agentZ);
                            if (nearestSite) {
                                const distToSite = Math.sqrt(
                                    Math.pow(agentX - nearestSite.x, 2) + Math.pow(agentZ - nearestSite.z, 2)
                                );

                                if (distToSite > 2) {
                                    // Claim and navigate to the site
                                    nearestSite.claimedBy = agent.name;
                                    agent.targetConstructionSite = nearestSite;
                                    agent.targetPosition = new THREE.Vector3(nearestSite.worldX, agent.mesh.position.y, nearestSite.worldZ);
                                    agent.taskState.state = 'moving';
                                    agent.taskState.targetPosition = agent.targetPosition.clone();

                                    agent.statusMessage = ` Navigating to construction beacon at (${nearestSite.x}, ${nearestSite.z})`;
                                    if (typeof addCopilotMessage === 'function') {
                                        addCopilotMessage(` ${agent.name} claimed construction site at (${nearestSite.x}, ${nearestSite.z})!`, 'ai');
                                    }
                                    break;
                                }
                            }
                        }

                        // Check if we arrived at target construction site
                        if (agent.targetConstructionSite) {
                            const distToTarget = Math.sqrt(
                                Math.pow(agentX - agent.targetConstructionSite.x, 2) +
                                Math.pow(agentZ - agent.targetConstructionSite.z, 2)
                            );
                            if (distToTarget <= 2) {
                                agent.statusMessage = ' Arrived at construction site - beginning build...';
                            }
                        }

                        // Check if on terraformed/flat area for efficiency bonus
                        const onFlatArea = worldState.terraformedAreas.some(a =>
                            Math.abs(a.x - agentX) < 2 && Math.abs(a.z - agentZ) < 2);

                        // Check if at a construction site beacon
                        const atConstructionSite = worldState.constructionSites?.some(s =>
                            Math.abs(s.x - agentX) < 2 && Math.abs(s.z - agentZ) < 2);

                        // Check if charger already exists nearby
                        const nearbyCharger = worldState.structures.find(s =>
                            s.type === 'battery_charger' &&
                            Math.abs(s.x - agentX) < 5 && Math.abs(s.z - agentZ) < 5);

                        if (!nearbyCharger) {
                            // Build a new battery charger
                            const efficiency = (onFlatArea || atConstructionSite) ? 100 : 60 + Math.floor(Math.random() * 20);
                            const charger = createBatteryCharger(
                                agent.mesh.position.x,
                                agent.mesh.position.y,
                                agent.mesh.position.z,
                                efficiency
                            );

                            if (charger) {
                                success = true;

                                // v6.11: Remove construction beacon if we built on it
                                if (atConstructionSite && typeof removeConstructionSiteBeacon === 'function') {
                                    const siteToRemove = worldState.constructionSites?.find(s =>
                                        Math.abs(s.x - agentX) < 2 && Math.abs(s.z - agentZ) < 2);
                                    if (siteToRemove) {
                                        removeConstructionSiteBeacon(siteToRemove);
                                        agent.statusMessage = ` Built OPTIMAL Charger on prepared site!`;
                                        if (typeof addCopilotMessage === 'function') {
                                            addCopilotMessage(` ${agent.name} completed construction at beacon site - 100% efficiency!`, 'ai');
                                        }
                                    }
                                } else {
                                    agent.statusMessage = ` Built Battery Charger (${efficiency}% efficiency)!`;
                                    if (onFlatArea && typeof addCopilotMessage === 'function') {
                                        addCopilotMessage(` ${agent.name} built an optimal charger on flat terrain!`, 'ai');
                                    }
                                }

                                agent.results.push({
                                    built: {
                                        type: 'battery_charger',
                                        efficiency: efficiency,
                                        flat: onFlatArea,
                                        atBeacon: atConstructionSite
                                    }
                                });
                                if (agent.mesh) spawnAgentParticleEffect(agent, 'success');

                                // Clear target construction site
                                agent.targetConstructionSite = null;
                            }
                        } else {
                            // Repair/upgrade existing charger
                            if (nearbyCharger.efficiency < 100 && onFlatArea) {
                                nearbyCharger.efficiency = Math.min(100, nearbyCharger.efficiency + 10);
                                success = true;
                                agent.statusMessage = ` Upgraded charger to ${nearbyCharger.efficiency}%!`;
                            } else {
                                // Look for construction sites instead of random movement
                                if (typeof findNearestConstructionSite === 'function') {
                                    const newSite = findNearestConstructionSite(agentX, agentZ);
                                    if (newSite) {
                                        newSite.claimedBy = agent.name;
                                        agent.targetConstructionSite = newSite;
                                        agent.targetPosition = new THREE.Vector3(newSite.worldX, agent.mesh.position.y, newSite.worldZ);
                                        agent.taskState.state = 'moving';
                                        agent.taskState.targetPosition = agent.targetPosition.clone();
                                        agent.statusMessage = ` Found new construction beacon at (${newSite.x}, ${newSite.z})`;
                                    } else {
                                        agent.statusMessage = ' Searching for construction sites...';
                                        moveAgentToRandomPosition(agent);
                                    }
                                } else {
                                    agent.statusMessage = 'Charger nearby, relocating...';
                                    moveAgentToRandomPosition(agent);
                                }
                            }
                        }
                    } else {
                        // Scanning status messages
                        const scanMessages = [
                            ' Scanning for construction beacons...',
                            ' Searching for prepared sites...',
                            ' Analyzing terrain data...',
                            ' Calculating build priorities...'
                        ];
                        agent.statusMessage = scanMessages[Math.floor(Math.random() * scanMessages.length)];
                    }
                    trackAgentAction(agent, success, 10);
                    break;
            }

            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100);

            saveGameData();
            updateAgentCardUI(agent);
        }

        // v5.17: Agent Experience and Efficiency System
        // XP required for each level (exponential curve)
        function getAgentXPForLevel(level) {
            return Math.floor(50 * Math.pow(1.5, level - 1));
        }

        // Grant XP to an agent and handle level ups
        function grantAgentXP(agent, amount) {
            if (!agent) return;
            agent.agentXP += amount;

            // Check for level up
            let xpNeeded = getAgentXPForLevel(agent.agentLevel);
            while (agent.agentXP >= xpNeeded && agent.agentLevel < 10) {
                agent.agentXP -= xpNeeded;
                agent.agentLevel++;
                agent.efficiency = 1.0 + (agent.agentLevel - 1) * 0.1; // +10% efficiency per level

                // Level up effects
                if (agent.mesh) {
                    spawnAgentParticleEffect(agent, 'levelup');
                }
                addCopilotMessage(` ${agent.typeConfig.icon} ${agent.name} reached Level ${agent.agentLevel}! Efficiency: ${Math.round(agent.efficiency * 100)}%`, 'ai');

                xpNeeded = getAgentXPForLevel(agent.agentLevel);
            }
        }

        // Track action success and update combo
        function trackAgentAction(agent, success, xpAmount = 5) {
            agent.actionsPerformed++;

            if (success) {
                agent.successfulActions++;
                agent.combo++;
                agent.maxCombo = Math.max(agent.maxCombo, agent.combo);
                agent.lastActionSuccess = true;

                // Combo XP bonus: +1 XP per combo level (max +10)
                const comboBonus = Math.min(agent.combo, 10);
                grantAgentXP(agent, xpAmount + comboBonus);

                // Spawn combo particle effect at milestones
                if (agent.combo === 5 || agent.combo === 10 || agent.combo === 25 || agent.combo % 50 === 0) {
                    if (agent.mesh) {
                        spawnAgentParticleEffect(agent, 'combo');
                    }
                    if (agent.combo >= 10) {
                        addCopilotMessage(` ${agent.typeConfig.icon} ${agent.name} ${agent.combo}x COMBO!`, 'ai');
                    }
                }
            } else {
                // Reset combo on failure
                if (agent.combo >= 5) {
                    // Lost significant combo - notify player
                    agent.statusMessage = `Combo lost at ${agent.combo}x`;
                }
                agent.combo = 0;
                agent.lastActionSuccess = false;
                // Still grant minimal XP for effort
                grantAgentXP(agent, 1);
            }
        }

        // Get effective success rate based on agent efficiency and combo
        function getAgentSuccessRate(agent, baseRate) {
            // Efficiency from level
            let rate = baseRate * agent.efficiency;

            // Combo bonus: up to +20% at 10+ combo
            const comboBonus = Math.min(agent.combo, 10) * 0.02;
            rate += comboBonus;

            // v5.17: Synergy bonus when agents work near each other
            const synergyBonus = getAgentSynergyBonus(agent);
            rate += synergyBonus;

            // Cap at 95%
            return Math.min(0.95, rate);
        }

        // v5.17: Calculate synergy bonus based on nearby allied agents
        function getAgentSynergyBonus(agent) {
            if (!agent.mesh) return 0;

            let nearbyAgents = 0;
            const synergyRange = 15; // Units

            agentFleet.forEach(other => {
                if (other.id === agent.id || !other.mesh) return;
                const dist = agent.mesh.position.distanceTo(other.mesh.position);
                if (dist <= synergyRange) {
                    nearbyAgents++;
                }
            });

            // +5% per nearby agent, max +15% (3 agents)
            return Math.min(nearbyAgents, 3) * 0.05;
        }

        // v5.17: Particle effects for agent actions
        function spawnAgentParticleEffect(agent, effectType) {
            if (!agent.mesh || !scene) return;

            const particleCount = effectType === 'levelup' ? 20 : (effectType === 'combo' ? 12 : 8);
            const particleGroup = new THREE.Group();

            // Choose color based on effect type
            let color;
            switch (effectType) {
                case 'levelup':
                    color = 0xffd700; // Gold
                    break;
                case 'combo':
                    color = 0xff8800; // Orange
                    break;
                case 'success':
                    color = agent.typeConfig.color;
                    break;
                case 'heal':
                    color = 0x00ff88;
                    break;
                default:
                    color = 0xffffff;
            }

            // Create particles
            for (let i = 0; i < particleCount; i++) {
                const size = 0.05 + Math.random() * 0.1;
                const geom = new THREE.SphereGeometry(size, 4, 4);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geom, mat);

                // Random spread
                particle.position.set(
                    (Math.random() - 0.5) * 0.5,
                    0.5 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );

                // Store velocity for animation
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    1 + Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );

                particleGroup.add(particle);
            }

            particleGroup.position.copy(agent.mesh.position);
            scene.add(particleGroup);

            // Animate and remove
            let elapsed = 0;
            const duration = effectType === 'levelup' ? 1500 : 800;

            function animateParticles() {
                elapsed += 16;
                const progress = elapsed / duration;

                if (progress >= 1) {
                    scene.remove(particleGroup);
                    particleGroup.children.forEach(p => {
                        p.geometry.dispose();
                        p.material.dispose();
                    });
                    return;
                }

                particleGroup.children.forEach(p => {
                    p.position.add(p.userData.velocity.clone().multiplyScalar(0.016));
                    p.userData.velocity.y -= 3 * 0.016; // Gravity
                    p.material.opacity = 0.9 * (1 - progress);
                    p.scale.setScalar(1 - progress * 0.5);
                });

                requestAnimationFrame(animateParticles);
            }

            requestAnimationFrame(animateParticles);
        }

        // v5.17: Agent health regeneration (passive)
        function updateAgentHealthRegen(agent) {
            if (!agent || !agent.taskState) return;

            const now = performance.now();
            const regenInterval = 5000; // Regen every 5 seconds

            if (now - agent.lastHealthRegen >= regenInterval) {
                agent.lastHealthRegen = now;

                const task = agent.taskState;
                if (task.hp < task.maxHp) {
                    // Regen rate: 2 HP base + 1 HP per level
                    const regenAmount = 2 + agent.agentLevel;
                    task.hp = Math.min(task.maxHp, task.hp + regenAmount);

                    // Show heal effect for significant heals
                    if (regenAmount >= 3 && agent.mesh) {
                        spawnAgentParticleEffect(agent, 'heal');
                    }
                }
            }
        }

        // Recall an agent
        function recallAgent(agentId) {
            const agentIndex = agentFleet.findIndex(a => a.id === agentId);
            if (agentIndex === -1) return;

            const agent = agentFleet[agentIndex];

            // Stop the update loop
            if (agentUpdateTimers[agent.id]) {
                clearTimeout(agentUpdateTimers[agent.id]);
                delete agentUpdateTimers[agent.id];
            }

            // Remove mesh from scene
            if (agent.mesh && scene) {
                scene.remove(agent.mesh);
            }

            // Generate summary
            const summary = [];
            // v5.17: Include level and stats in summary
            summary.push(`Lv.${agent.agentLevel}`);
            if (agent.maxCombo > 0) summary.push(`Best combo: ${agent.maxCombo}x`);
            if (agent.totalEarnings.xp > 0) summary.push(`+${agent.totalEarnings.xp} XP`);
            if (agent.totalEarnings.gold > 0) summary.push(`+${agent.totalEarnings.gold} Gold`);
            if (agent.totalEarnings.items.length > 0) {
                const itemCounts = {};
                agent.totalEarnings.items.forEach(i => {
                    itemCounts[i.item] = (itemCounts[i.item] || 0) + (i.amount || 1);
                });
                Object.entries(itemCounts).forEach(([item, count]) => {
                    summary.push(`+${count} ${item}`);
                });
            }

            // Remove from fleet
            agentFleet.splice(agentIndex, 1);

            // Announce
            // v5.17: Enhanced recall message with agent performance stats
            const successRate = agent.actionsPerformed > 0 ? Math.round((agent.successfulActions / agent.actionsPerformed) * 100) : 0;
            const statsStr = `[${successRate}% success rate, ${agent.actionsPerformed} actions]`;
            const summaryStr = summary.length > 0 ? ` ${summary.join(', ')}` : '';
            addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} recalled! ${statsStr}${summaryStr}`, 'ai');

            updateFleetUI();
            updateFleetButton();
        }

        // Update the fleet button indicator
        function updateFleetButton() {
            const btn = document.getElementById('fleet-button');
            if (agentFleet.length > 0) {
                btn.classList.add('has-agents');
                btn.setAttribute('data-count', agentFleet.length);
            } else {
                btn.classList.remove('has-agents');
            }
        }

        // Update the fleet panel UI
        function updateFleetUI() {
            document.getElementById('fleet-count').textContent = `${agentFleet.length}/${MAX_AGENTS}`;

            // Update spawn buttons disabled state
            const spawnBtns = document.querySelectorAll('.agent-spawn-btn');
            spawnBtns.forEach(btn => {
                btn.disabled = agentFleet.length >= MAX_AGENTS;
            });

            // Update agent list
            const listContainer = document.getElementById('agent-fleet-list');

            if (agentFleet.length === 0) {
                listContainer.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                        No agents deployed yet.<br>Click an agent type above to spawn.
                    </div>
                `;
                return;
            }

            listContainer.innerHTML = agentFleet.map(agent => {
                const colorHex = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');
                const statusDotClass = agent.status === 'thinking' ? 'thinking' : (agent.status === 'idle' ? 'idle' : '');

                // v5.14: Get endpoint/profile info
                const agentEndpoint = getAgentEndpoint(agent);
                const endpointBadge = agent.profileId ?
                    `<span style="font-size: 9px; color: #06ffa5; background: rgba(6,255,165,0.1); padding: 2px 6px; border-radius: 3px; margin-left: 5px;">${agentEndpoint.name}</span>` : '';

                const recentResults = agent.results.slice(-3).map(r => {
                    if (r.item) return `+${r.amount} ${r.item}`;
                    if (r.xp) return `+${r.xp} XP`;
                    if (r.gold) return `+${r.gold} Gold`;
                    if (r.heal) return `+${r.heal} HP`;
                    if (r.discovery) return r.discovery.substring(0, 20);
                    return '';
                }).filter(Boolean);

                return `
                    <div class="agent-card" data-agent-id="${agent.id}">
                        <div class="agent-card-header">
                            <div class="agent-identity">
                                <div class="agent-avatar ${agent.typeConfig.colorClass}" style="background: ${colorHex}22;">
                                    ${agent.typeConfig.icon}
                                </div>
                                <div class="agent-info">
                                    <div class="agent-name">${agent.name}${endpointBadge}</div>
                                    <div class="agent-role">${agent.typeConfig.name}</div>
                                </div>
                            </div>
                            <div class="agent-actions">
                                <button class="agent-action-btn export" onclick="exportAgentTranscript('${agent.id}')" title="Export transcript"></button>
                                <button class="agent-action-btn recall" onclick="recallAgent('${agent.id}')" title="Recall agent"></button>
                            </div>
                        </div>
                        <div class="agent-card-status">
                            <div class="agent-status-dot ${statusDotClass}"></div>
                            <span class="status-text">${agent.statusMessage}</span>
                        </div>
                        <div class="agent-card-progress">
                            <div class="agent-progress-bar" style="width: ${agent.progress}%; background: ${colorHex};"></div>
                        </div>
                        ${recentResults.length > 0 ? `
                            <div class="agent-results-mini">
                                ${recentResults.map(r => `<span class="agent-result-tag">${r}</span>`).join('')}
                            </div>
                        ` : ''}
                        <!-- v5.15: Expandable Real-Time Transcript Viewer -->
                        <div class="agent-transcript-toggle" onclick="toggleAgentTranscript('${agent.id}')">
                            <span class="expand-icon"></span>
                            <span>Live Transcript</span>
                            <span class="transcript-message-count">${agent.conversationHistory.length} msgs</span>
                            ${agent.status === 'thinking' ? '<span class="transcript-live-indicator"></span>' : ''}
                        </div>
                        <div class="agent-transcript-viewer" id="transcript-viewer-${agent.id}">
                            ${buildAgentTranscriptHTML(agent)}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Update a single agent card UI
        // v5.16.3: Enhanced to show actual task state from autonomous system
        function updateAgentCardUI(agent) {
            const card = document.querySelector(`.agent-card[data-agent-id="${agent.id}"]`);
            if (!card) return;

            const statusDot = card.querySelector('.agent-status-dot');
            const statusText = card.querySelector('.status-text');
            const progressBar = card.querySelector('.agent-progress-bar');

            if (statusDot) {
                statusDot.className = 'agent-status-dot';
                if (agent.status === 'thinking') statusDot.classList.add('thinking');
                if (agent.status === 'idle') statusDot.classList.add('idle');
            }

            // v6.3.1: Show actual task state - always local/deterministic mode
            let displayStatus = agent.statusMessage;
            const modeIndicator = '';  // Always local mode now

            if (agent.mesh && agent.taskState) {
                const task = agent.taskState;
                // v6.4.0: Added returning/depositing states for hauling
                const invCount = task.inventory?.length || 0;
                const invCap = task.carryingCapacity || 6;
                const stateDescriptions = {
                    'idle': 'Scanning for targets...',
                    'moving': `Moving to target`,
                    'working': 'Harvesting...',
                    'combat': 'In combat!',
                    'alert': task.alert || 'Alert!',
                    'manual_control': 'Manual control',
                    'stuck': 'Repositioning...',
                    'returning': `Returning to ship [${invCount}/${invCap}]`,
                    'depositing': `Depositing resources...`
                };
                const stateMsg = stateDescriptions[task.state] || task.state;
                const pos = agent.mesh.position;
                displayStatus = `${modeIndicator} ${stateMsg} (${Math.floor(pos.x)}, ${Math.floor(pos.z)})`;
            } else if (!agent.mesh) {
                // v6.3.0: Changed from "Waiting to spawn..." - agent is working even before mesh
                // Show that work is happening even without visual representation
                displayStatus = `${modeIndicator} ${agent.statusMessage || 'Working (no visual yet)'}`;
            }
            if (statusText) statusText.textContent = displayStatus;
            if (progressBar) progressBar.style.width = `${agent.progress}%`;

            // v5.17: Update level and combo display
            let levelComboDiv = card.querySelector('.agent-level-combo');
            if (!levelComboDiv) {
                levelComboDiv = document.createElement('div');
                levelComboDiv.className = 'agent-level-combo';
                levelComboDiv.style.cssText = 'display: flex; gap: 8px; margin: 4px 0; font-size: 10px;';
                const statusContainer = card.querySelector('.agent-card-status');
                if (statusContainer) statusContainer.after(levelComboDiv);
            }
            const xpNeeded = getAgentXPForLevel(agent.agentLevel);
            const xpPercent = Math.min(100, Math.round((agent.agentXP / xpNeeded) * 100));
            const comboColor = agent.combo >= 10 ? '#ff8800' : (agent.combo >= 5 ? '#ffcc00' : '#888');
            const levelColor = agent.agentLevel >= 5 ? '#ffd700' : (agent.agentLevel >= 3 ? '#00ff88' : '#0ff');
            levelComboDiv.innerHTML = `
                <span style="color: ${levelColor}; font-weight: bold;">Lv.${agent.agentLevel}</span>
                <span style="color: #666;">(${xpPercent}%)</span>
                ${agent.combo > 0 ? `<span style="color: ${comboColor}; font-weight: bold;"> ${agent.combo}x</span>` : ''}
                <span style="color: #888; margin-left: auto;">${Math.round(agent.efficiency * 100)}%</span>
            `;

            // v6.4.0: Add inventory display for gatherer/miner agents
            const task = agent.taskState;
            if (task && task.inventory !== undefined && (agent.type === 'gatherer' || agent.type === 'miner')) {
                let invDiv = card.querySelector('.agent-inventory-display');
                if (!invDiv) {
                    invDiv = document.createElement('div');
                    invDiv.className = 'agent-inventory-display';
                    invDiv.style.cssText = 'display: flex; align-items: center; gap: 4px; margin: 4px 0; font-size: 10px; flex-wrap: wrap;';
                    levelComboDiv.after(invDiv);
                }

                const invCount = task.inventory?.length || 0;
                const invCap = task.carryingCapacity || 6;
                const invPercent = Math.round((invCount / invCap) * 100);
                const invColor = invCount >= invCap ? '#ff8800' : (invCount > invCap / 2 ? '#ffcc00' : '#0ff');
                const trips = task.tripsCompleted || 0;
                const hauled = task.totalHauled || 0;

                // Group inventory items
                const itemCounts = {};
                (task.inventory || []).forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
                const itemSummary = Object.entries(itemCounts).map(([item, count]) =>
                    `<span style="background: rgba(0,255,255,0.1); padding: 1px 4px; border-radius: 3px; margin: 1px;">${count}x ${item.substring(0,8)}</span>`
                ).join('');

                invDiv.innerHTML = `
                    <span style="color: ${invColor};"> ${invCount}/${invCap}</span>
                    <span style="background: rgba(0,0,0,0.3); height: 4px; flex: 1; min-width: 30px; border-radius: 2px; overflow: hidden;">
                        <span style="display: block; height: 100%; width: ${invPercent}%; background: ${invColor}; transition: width 0.3s;"></span>
                    </span>
                    ${trips > 0 ? `<span style="color: #888;">${trips}</span>` : ''}
                    ${hauled > 0 ? `<span style="color: #0f8; font-size: 9px;">${hauled}</span>` : ''}
                    ${itemSummary ? `<div style="width: 100%; margin-top: 2px;">${itemSummary}</div>` : ''}
                `;
            }

            // Update results
            const recentResults = agent.results.slice(-3).map(r => {
                if (r.item) return `+${r.amount} ${r.item}`;
                if (r.xp) return `+${r.xp} XP`;
                if (r.gold) return `+${r.gold} Gold`;
                if (r.heal) return `+${r.heal} HP`;
                if (r.discovery) return r.discovery.substring(0, 20);
                return '';
            }).filter(Boolean);

            let resultsDiv = card.querySelector('.agent-results-mini');
            if (recentResults.length > 0) {
                if (!resultsDiv) {
                    resultsDiv = document.createElement('div');
                    resultsDiv.className = 'agent-results-mini';
                    card.appendChild(resultsDiv);
                }
                resultsDiv.innerHTML = recentResults.map(r => `<span class="agent-result-tag">${r}</span>`).join('');
            }

            // v5.15: Update transcript toggle and viewer
            const transcriptToggle = card.querySelector('.agent-transcript-toggle');
            if (transcriptToggle) {
                const msgCount = transcriptToggle.querySelector('.transcript-message-count');
                if (msgCount) msgCount.textContent = `${agent.conversationHistory.length} msgs`;

                // Update live indicator
                let liveIndicator = transcriptToggle.querySelector('.transcript-live-indicator');
                if (agent.status === 'thinking') {
                    if (!liveIndicator) {
                        liveIndicator = document.createElement('span');
                        liveIndicator.className = 'transcript-live-indicator';
                        transcriptToggle.appendChild(liveIndicator);
                    }
                } else if (liveIndicator) {
                    liveIndicator.remove();
                }
            }

            // Update transcript viewer if expanded
            const transcriptViewer = card.querySelector('.agent-transcript-viewer.expanded');
            if (transcriptViewer) {
                updateAgentTranscriptUI(agent);
            }
        }

        // v5.15: Toggle agent transcript viewer expansion
        // v5.16.1: Added body cam rendering when expanded
        function toggleAgentTranscript(agentId) {
            const card = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
            if (!card) return;

            const toggle = card.querySelector('.agent-transcript-toggle');
            const viewer = card.querySelector('.agent-transcript-viewer');

            if (toggle && viewer) {
                const isExpanded = viewer.classList.contains('expanded');
                toggle.classList.toggle('expanded', !isExpanded);
                viewer.classList.toggle('expanded', !isExpanded);

                // If opening, update the content and render body cam
                if (!isExpanded) {
                    const agent = agentFleet.find(a => a.id === agentId);
                    if (agent) {
                        viewer.innerHTML = buildAgentTranscriptHTML(agent);
                        // Scroll to bottom to show latest messages
                        viewer.scrollTop = viewer.scrollHeight;
                        // v5.16.1: Render body cam after DOM update
                        setTimeout(() => renderAgentBodyCam(agent), 100);
                    }
                }
            }
        }

        // v5.15: Build HTML for agent transcript messages
        // v5.15.2: Enhanced with Try Again replay buttons
        // v5.16.1: Added body cam preview
        function buildAgentTranscriptHTML(agent) {
            const history = agent.conversationHistory;

            if (history.length === 0) {
                return '<div class="transcript-empty">No messages yet - agent is initializing...</div>';
            }

            const agentEndpoint = getAgentEndpoint(agent);
            const endpointInfo = agentEndpoint.name || 'Local Simulation';
            const interactions = agent.interactionHistory || [];

            // v5.16.1: Get agent position and status for body cam overlay
            const agentPos = agent.mesh ? agent.mesh.position : { x: 0, y: 0, z: 0 };
            const taskState = agent.taskState || {};
            const stateText = taskState.state || 'initializing';
            const currentAction = taskState.currentTask || stateText;

            let html = `
                <!-- v5.16.1: Body Cam Preview + v5.16.2: Takeover Controls -->
                <!-- v5.16.3: Enhanced with streaming pattern for real-time view -->
                <div class="agent-bodycam-container" title="Agent Body Cam - Click to Locate">
                    <canvas class="agent-bodycam-canvas" id="bodycam-${agent.id}" width="320" height="150"></canvas>
                    <div class="agent-bodycam-overlay">
                        <div class="agent-bodycam-label">
                            <span class="rec-dot"></span>
                            <span>BODY CAM</span>
                        </div>
                        <div class="agent-bodycam-status">${stateText.toUpperCase()}</div>
                    </div>
                    <div class="agent-bodycam-bottom">
                        <div class="agent-bodycam-coords">X:${Math.floor(agentPos.x)} Z:${Math.floor(agentPos.z)}</div>
                        <div class="agent-bodycam-action">${agent.typeConfig.icon} ${agent.statusMessage?.substring(0, 25) || 'Working...'}</div>
                    </div>
                    <!-- v5.16.2: Control buttons overlay -->
                    <!-- v5.17.1: Added POP OUT button for independent agent control window -->
                    <div class="agent-bodycam-controls">
                        <button class="agent-pov-btn locate" onclick="event.stopPropagation(); focusOnAgent('${agent.id}')" title="Navigate to agent">
                             LOCATE
                        </button>
                        <button class="agent-pov-btn takeover" onclick="event.stopPropagation(); openAgentTakeover('${agent.id}')" title="Take remote control of this agent">
                             TAKEOVER
                        </button>
                        <button class="agent-pov-btn popout" onclick="event.stopPropagation(); popOutAgentWindow('${agent.id}')" title="Open agent control in separate window">
                             POP OUT
                        </button>
                    </div>
                </div>

                <div class="transcript-header">
                    <span class="transcript-header-title"> ${endpointInfo}</span>
                    <span class="transcript-message-count">${history.length} msgs | ${interactions.length} interactions</span>
                </div>
                <div class="transcript-messages">
            `;

            // Show messages (system first, then alternating user/assistant)
            history.forEach((msg, idx) => {
                const roleClass = msg.role === 'system' ? 'system' : (msg.role === 'user' ? 'user' : 'assistant');
                const roleIcon = msg.role === 'system' ? '' : (msg.role === 'user' ? '' : '');
                const roleLabel = msg.role === 'system' ? 'System' : (msg.role === 'user' ? 'Context' : 'Response');

                // Truncate long content for display
                let content = msg.content;
                const isTruncated = content.length > 500;
                if (isTruncated) {
                    content = content.substring(0, 500) + '... [truncated]';
                }

                // Escape HTML entities
                content = content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // v5.15.2: Find matching interaction for assistant responses
                let tryAgainBtn = '';
                if (msg.role === 'assistant') {
                    // Find the interaction that produced this response
                    const interaction = interactions.find(i =>
                        i.response === msg.content ||
                        (i.conversationIndexAfter && i.conversationIndexAfter > idx)
                    );
                    if (interaction) {
                        const isReplaying = agent.replayState?.interactionId === interaction.id;
                        tryAgainBtn = `
                            <button class="try-again-btn ${isReplaying ? 'replaying' : ''}"
                                    onclick="event.stopPropagation(); tryAgainInteraction('${agent.id}', '${interaction.id}')"
                                    title="Replay this interaction with current game state">
                                 Try Again
                            </button>
                        `;
                    }
                }

                html += `
                    <div class="transcript-msg ${roleClass}">
                        <div class="transcript-msg-role" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${roleIcon} ${roleLabel} #${idx + 1}</span>
                            ${tryAgainBtn}
                        </div>
                        <div class="transcript-msg-content ${isTruncated ? 'truncated' : ''}">${content}</div>
                    </div>
                `;
            });

            // v5.15.2: Show replay comparison if active
            if (agent.replayState) {
                html += buildReplayComparisonHTML(agent);
            }

            html += '</div>';
            return html;
        }

        // v5.15.2: Build HTML for replay comparison view
        function buildReplayComparisonHTML(agent) {
            const replay = agent.replayState;
            if (!replay) return '';

            const originalContent = (replay.originalResponse || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const retryContent = (replay.retryResponse || 'Waiting for response...').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            const isSame = replay.retryResponse && replay.originalResponse === replay.retryResponse;
            const isDifferent = replay.retryResponse && replay.originalResponse !== replay.retryResponse;

            return `
                <div class="replay-comparison">
                    <div class="replay-comparison-header">
                        <span class="replay-comparison-title"> Try Again Comparison</span>
                        ${replay.retryResponse ? `
                            <span class="replay-branch-indicator ${isSame ? 'same' : ''}">
                                ${isSame ? ' Same Result' : ' Different Result'}
                            </span>
                        ` : '<span class="replay-branch-indicator"> Replaying...</span>'}
                    </div>
                    <div class="replay-side-by-side">
                        <div class="replay-column original">
                            <div class="replay-column-label"> Original Response</div>
                            <div class="replay-content">${originalContent.substring(0, 300)}${originalContent.length > 300 ? '...' : ''}</div>
                        </div>
                        <div class="replay-column retry ${isDifferent ? 'replay-diff' : ''}">
                            <div class="replay-column-label"> Retry Response</div>
                            <div class="replay-content">${retryContent.substring(0, 300)}${retryContent.length > 300 ? '...' : ''}</div>
                        </div>
                    </div>
                    ${replay.retryResponse ? `
                        <div class="replay-actions">
                            <button class="replay-action-btn use-original" onclick="dismissReplayComparison('${agent.id}')">
                                Keep Original
                            </button>
                            ${isDifferent ? `
                                <button class="replay-action-btn use-retry" onclick="applyRetryResponse('${agent.id}')">
                                    Use Retry & Branch
                                </button>
                            ` : ''}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // v5.15.2: Try Again - replay an interaction with current game state
        async function tryAgainInteraction(agentId, interactionId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            const interaction = agent.interactionHistory.find(i => i.id === interactionId);
            if (!interaction) {
                console.warn('Interaction not found:', interactionId);
                return;
            }

            // Set replay state
            agent.replayState = {
                interactionId: interactionId,
                originalResponse: interaction.response,
                originalContext: interaction.gameContext,
                retryResponse: null,
                retryContext: null,
                status: 'replaying'
            };

            // Update UI to show replaying state
            updateAgentTranscriptUI(agent);

            // Get endpoint
            const endpoint = getAgentEndpoint(agent);
            if (!endpoint || !endpoint.url || !endpoint.key) {
                agent.replayState.retryResponse = '[ERROR: No endpoint configured]';
                agent.replayState.status = 'error';
                updateAgentTranscriptUI(agent);
                return;
            }

            try {
                // Build NEW context with current game state
                const newGameContext = buildGameContextForAgent(agent);
                agent.replayState.retryContext = newGameContext;

                // Build new context message
                const newContextMessage = {
                    role: 'user',
                    content: `Current situation: ${JSON.stringify(newGameContext)}. What's your next action?`
                };

                // Use original conversation history up to that point
                const originalConversation = agent.conversationHistory.slice(0, interaction.conversationIndexBefore);
                const conversationForApi = [...originalConversation, newContextMessage];

                // Build headers
                const headers = { 'Content-Type': 'application/json' };
                if (endpoint.headerPrefix) {
                    headers[endpoint.headerStyle] = endpoint.headerPrefix + endpoint.key;
                } else {
                    headers[endpoint.headerStyle] = endpoint.key;
                }

                // Format request body
                const requestBody = formatAgentRequestBody(endpoint, newContextMessage, conversationForApi, agent);

                // Make API call
                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (response.ok) {
                    const data = await response.json();
                    const textResponse = parseAgentResponse(endpoint, data);

                    agent.replayState.retryResponse = textResponse;
                    agent.replayState.status = 'complete';
                    agent.replayState.retryRawResponse = data;
                } else {
                    const errorText = await response.text().catch(() => '');
                    agent.replayState.retryResponse = `[API Error ${response.status}: ${errorText.substring(0, 100)}]`;
                    agent.replayState.status = 'error';
                }
            } catch (error) {
                console.error('Try Again error:', error);
                agent.replayState.retryResponse = `[Network Error: ${error.message}]`;
                agent.replayState.status = 'error';
            }

            // Update UI with comparison
            updateAgentTranscriptUI(agent);
        }

        // v5.15.2: Dismiss replay comparison without changes
        function dismissReplayComparison(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            agent.replayState = null;
            updateAgentTranscriptUI(agent);
        }

        // v5.15.2: Apply retry response and branch off with new conversation
        function applyRetryResponse(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.replayState) return;

            const replay = agent.replayState;
            const interaction = agent.interactionHistory.find(i => i.id === replay.interactionId);

            if (!interaction || !replay.retryResponse) {
                dismissReplayComparison(agentId);
                return;
            }

            // Branch: Keep conversation up to original interaction point
            agent.conversationHistory = agent.conversationHistory.slice(0, interaction.conversationIndexBefore);

            // Add new context message with current game state
            const newContextMessage = {
                role: 'user',
                content: `Current situation: ${JSON.stringify(replay.retryContext)}. What's your next action?`
            };
            agent.conversationHistory.push(newContextMessage);

            // Add retry response
            agent.conversationHistory.push({ role: 'assistant', content: replay.retryResponse });

            // Create new interaction record for the branch
            const branchInteraction = {
                id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
                timestamp: Date.now(),
                contextMessage: newContextMessage,
                gameContext: replay.retryContext,
                endpoint: interaction.endpoint,
                response: replay.retryResponse,
                rawResponse: replay.retryRawResponse,
                conversationIndexBefore: interaction.conversationIndexBefore,
                conversationIndexAfter: agent.conversationHistory.length,
                executed: false,
                branchedFrom: interaction.id  // Track branch origin
            };
            agent.interactionHistory.push(branchInteraction);

            // Execute the new decision
            parseAndExecuteAgentDecision(agent, replay.retryResponse);
            branchInteraction.executed = true;

            // Clear replay state
            agent.replayState = null;

            // Notify
            addCopilotMessage(` ${agent.name} branched off with new response from Try Again!`, 'ai');

            // Update UI
            updateAgentCardUI(agent);
            updateAgentTranscriptUI(agent);
        }

        // v5.15: Update agent transcript UI (when new messages arrive)
        function updateAgentTranscriptUI(agent) {
            const viewer = document.getElementById(`transcript-viewer-${agent.id}`);
            if (!viewer || !viewer.classList.contains('expanded')) return;

            // Store scroll position
            const wasScrolledToBottom = viewer.scrollHeight - viewer.clientHeight <= viewer.scrollTop + 10;

            // Update content
            viewer.innerHTML = buildAgentTranscriptHTML(agent);

            // Auto-scroll to bottom if user was at bottom
            if (wasScrolledToBottom) {
                viewer.scrollTop = viewer.scrollHeight;
            }

            // v5.16.1: Render body cam after DOM update
            setTimeout(() => renderAgentBodyCam(agent), 50);
        }

        // v5.16.1: Agent body cam renderer and camera system
        // v5.16.3: Rewritten using streaming pattern from AI Companion Hub
        let agentBodyCamCamera = null;
        let agentBodyCamRenderer = null;
        let bodyCamInitialized = false;

        // Body cam streaming state (similar to Show Mode pattern)
        const bodyCamState = {
            activeStreams: new Map(), // agentId -> { lastRender: timestamp, canvas: element }
            updateInterval: 100, // ms between frame updates
            isRendering: false
        };

        // Initialize body cam rendering system (streaming pattern)
        function initAgentBodyCamSystem() {
            if (bodyCamInitialized) return true;
            if (!scene) {
                console.log('Body cam init: waiting for scene...');
                return false;
            }

            try {
                // Create a dedicated camera for body cam views
                agentBodyCamCamera = new THREE.PerspectiveCamera(70, 320/150, 0.1, 150);

                // Create a dedicated renderer with preserveDrawingBuffer for canvas copy
                // This is the key fix - similar to AI Companion Hub's renderer setup
                agentBodyCamRenderer = new THREE.WebGLRenderer({
                    alpha: true,
                    antialias: false,
                    powerPreference: 'low-power',
                    preserveDrawingBuffer: true // Critical for canvas streaming!
                });
                agentBodyCamRenderer.setSize(320, 150);
                agentBodyCamRenderer.setPixelRatio(1);
                agentBodyCamRenderer.setClearColor(0x000000, 1);

                bodyCamInitialized = true;
                console.log('Body cam system initialized successfully');
                return true;
            } catch (error) {
                console.error('Failed to initialize body cam system:', error);
                return false;
            }
        }

        // v5.16.3: Stream agent's POV to body cam canvas (AI Companion Hub pattern)
        function renderAgentBodyCam(agent) {
            if (!agent || !agent.mesh) {
                renderBodyCamPlaceholder(agent);
                return;
            }

            if (!scene) {
                renderBodyCamPlaceholder(agent, 'Waiting for world...');
                return;
            }

            const canvas = document.getElementById(`bodycam-${agent.id}`);
            if (!canvas) return;

            // Initialize body cam system if needed
            if (!bodyCamInitialized && !initAgentBodyCamSystem()) {
                renderBodyCamPlaceholder(agent, 'Initializing...');
                return;
            }

            if (!agentBodyCamRenderer || !agentBodyCamCamera) {
                renderBodyCamPlaceholder(agent, 'Renderer unavailable');
                return;
            }

            try {
                // Position camera at agent's head level, looking in their facing direction
                const agentPos = agent.mesh.position;
                const agentRotation = agent.mesh.rotation.y || 0;

                // Camera position: at agent's eye level, looking forward
                agentBodyCamCamera.position.set(
                    agentPos.x + Math.sin(agentRotation) * 0.3,
                    agentPos.y + 1.5, // Eye level
                    agentPos.z + Math.cos(agentRotation) * 0.3
                );

                // Look in the direction the agent is facing
                const lookTarget = new THREE.Vector3(
                    agentPos.x + Math.sin(agentRotation) * 10,
                    agentPos.y + 1.0,
                    agentPos.z + Math.cos(agentRotation) * 10
                );
                agentBodyCamCamera.lookAt(lookTarget);

                // Render the scene from agent's perspective
                agentBodyCamRenderer.render(scene, agentBodyCamCamera);

                // Stream to the canvas element (AI Companion Hub pattern)
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    // Clear and draw the rendered frame
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(agentBodyCamRenderer.domElement, 0, 0, canvas.width, canvas.height);

                    // Add scan line effect for retro feel
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.03)';
                    for (let y = 0; y < canvas.height; y += 3) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Add vignette effect
                    const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 30, canvas.width/2, canvas.height/2, 180);
                    gradient.addColorStop(0, 'rgba(0,0,0,0)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // v5.17: Add level and combo HUD overlay
                    ctx.font = 'bold 10px monospace';
                    // Level badge (top-left)
                    const levelColor = agent.agentLevel >= 5 ? '#ffd700' : (agent.agentLevel >= 3 ? '#00ff88' : '#0ff');
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(4, 4, 36, 14);
                    ctx.fillStyle = levelColor;
                    ctx.fillText(`Lv.${agent.agentLevel}`, 8, 14);

                    // Combo indicator (top-right, if active)
                    if (agent.combo >= 3) {
                        const comboText = `${agent.combo}x`;
                        const comboColor = agent.combo >= 10 ? '#ff8800' : (agent.combo >= 5 ? '#ffcc00' : '#fff');
                        const comboWidth = ctx.measureText(comboText).width + 16;
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.fillRect(canvas.width - comboWidth - 4, 4, comboWidth, 14);
                        ctx.fillStyle = comboColor;
                        ctx.fillText(`${comboText}`, canvas.width - comboWidth, 14);
                    }

                    // Efficiency bar (bottom-left)
                    const effPercent = agent.efficiency * 100;
                    const barWidth = 50;
                    const barHeight = 4;
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(4, canvas.height - 10, barWidth + 4, barHeight + 4);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(6, canvas.height - 8, barWidth, barHeight);
                    ctx.fillStyle = effPercent >= 150 ? '#ffd700' : (effPercent >= 120 ? '#00ff88' : '#0ff');
                    ctx.fillRect(6, canvas.height - 8, barWidth * (effPercent / 200), barHeight);

                    // Update stream state
                    bodyCamState.activeStreams.set(agent.id, {
                        lastRender: performance.now(),
                        canvas: canvas
                    });
                }
            } catch (error) {
                console.error(`Body cam render error for ${agent.name}:`, error);
                renderBodyCamPlaceholder(agent, 'Render error');
            }
        }

        // v5.16.3: Render placeholder when body cam can't display real view
        // v6.3.0: Enhanced to show agent is working even without visual
        function renderBodyCamPlaceholder(agent, message = null) {
            if (!agent) return;
            const canvas = document.getElementById(`bodycam-${agent.id}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            // v6.3.0: Auto-generate message based on agent state
            if (!message) {
                if (agent.meshPending) {
                    message = 'Loading 3D view...';
                } else if (!scene) {
                    message = 'World loading...';
                } else {
                    message = 'No signal';
                }
            }

            // Dark background with noise effect
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add static noise effect
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < 0.05) {
                    const noise = Math.random() * 30;
                    data[i] = noise;     // R
                    data[i + 1] = noise; // G
                    data[i + 2] = noise; // B
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // Draw status text
            ctx.fillStyle = '#0af';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(message, canvas.width/2, canvas.height/2 - 10);

            // v6.3.1: Show that agent IS working even without visual
            if (agent.status === 'working') {
                ctx.font = '11px monospace';
                ctx.fillStyle = '#0f8';
                ctx.fillText('AGENT ACTIVE', canvas.width/2, canvas.height/2 + 10);

                // Show current action
                if (agent.statusMessage) {
                    ctx.font = '9px monospace';
                    ctx.fillStyle = '#888';
                    const shortMsg = agent.statusMessage.substring(0, 30);
                    ctx.fillText(shortMsg, canvas.width/2, canvas.height/2 + 25);
                }
            }

            // Draw agent info if available
            if (agent.taskState) {
                ctx.font = '10px monospace';
                ctx.fillStyle = '#888';
                const state = agent.taskState.state || 'initializing';
                ctx.fillText(`State: ${state}`, canvas.width/2, canvas.height/2 + 40);
            }

            // Draw border
            ctx.strokeStyle = '#0af';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        }

        // ============================================
        // v6.5.0: AGENT OBSERVER MODE (StarCraft-style)
        // Camera follows agent while they work autonomously
        // Press ESC or click "Return to Robot" to exit
        // ============================================
        const agentObserverMode = {
            active: false,
            observedAgentId: null,
            savedCameraOffset: null,
            uiElement: null,
            beacon: null  // v6.5.2: Glowing beacon pillar above observed agent
        };

        // v6.5.0: Enter observer mode - camera follows agent, agent keeps working
        function focusOnAgent(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) {
                addCopilotMessage(`Cannot locate agent - agent not found.`, 'ai');
                return;
            }

            // v6.5.1: Close takeover mode if active - observer and takeover are mutually exclusive
            if (agentTakeoverState && agentTakeoverState.active) {
                closeAgentTakeover();
            }

            // Try to create mesh if scene is ready and no mesh yet
            if (!agent.mesh && scene) {
                console.log(`focusOnAgent: Creating mesh for ${agent.name}`);
                createAgentMesh(agent);
            }

            // Get agent position
            let agentPos;
            if (agent.mesh) {
                agentPos = agent.mesh.position;
            } else if (agent.position && (agent.position.x !== 0 || agent.position.z !== 0)) {
                agentPos = agent.position;
            } else {
                addCopilotMessage(`Cannot locate agent - no valid position. Try again after world loads.`, 'ai');
                return;
            }

            // v6.5.0: ENTER OBSERVER MODE - don't teleport player!
            agentObserverMode.active = true;
            agentObserverMode.observedAgentId = agentId;

            // v6.5.2: Create glowing beacon pillar above agent so it's visible
            createObserverBeacon(agent);

            // Show observer UI
            showAgentObserverUI(agent);

            // Visual feedback
            spawnFloater(agentPos, ` Observing ${agent.name}`, '#0af');

            // Announce
            addCopilotMessage(` Now observing ${agent.typeConfig.icon} ${agent.name} - Press ESC or click button to return`, 'ai');

            // Highlight on minimap
            highlightAgentOnMinimap(agent);
        }

        // v6.5.2: Create a tall glowing beacon above the observed agent
        function createObserverBeacon(agent) {
            // Remove existing beacon if any
            if (agentObserverMode.beacon && scene) {
                scene.remove(agentObserverMode.beacon);
                agentObserverMode.beacon = null;
            }

            if (!agent.mesh || !scene) return;

            const beaconGroup = new THREE.Group();
            const color = agent.typeConfig.color || 0x00aaff;

            // Tall glowing pillar
            const pillarGeom = new THREE.CylinderGeometry(0.3, 0.8, 25, 8);
            const pillarMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4
            });
            const pillar = new THREE.Mesh(pillarGeom, pillarMat);
            pillar.position.y = 12.5;
            beaconGroup.add(pillar);

            // Inner bright core
            const coreGeom = new THREE.CylinderGeometry(0.1, 0.3, 25, 6);
            const coreMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeom, coreMat);
            core.position.y = 12.5;
            beaconGroup.add(core);

            // Glowing ring at base
            const ringGeom = new THREE.TorusGeometry(2, 0.3, 8, 16);
            const ringMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.5;
            beaconGroup.add(ring);

            // Pulsing outer ring
            const outerRingGeom = new THREE.TorusGeometry(3.5, 0.15, 8, 24);
            const outerRingMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const outerRing = new THREE.Mesh(outerRingGeom, outerRingMat);
            outerRing.rotation.x = Math.PI / 2;
            outerRing.position.y = 0.3;
            beaconGroup.add(outerRing);

            // Floating arrow pointing down
            const arrowGeom = new THREE.ConeGeometry(1.5, 3, 4);
            const arrowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const arrow = new THREE.Mesh(arrowGeom, arrowMat);
            arrow.position.y = 8;
            arrow.rotation.z = Math.PI; // Point downward
            beaconGroup.add(arrow);

            // Store reference for animation
            beaconGroup.userData = { ring, outerRing, arrow, pillar };

            scene.add(beaconGroup);
            agentObserverMode.beacon = beaconGroup;

            console.log(`Observer beacon created for ${agent.name}`);
        }

        // v6.5.2: Update beacon position to follow agent
        function updateObserverBeacon() {
            if (!agentObserverMode.active || !agentObserverMode.beacon) return;

            const agent = agentFleet.find(a => a.id === agentObserverMode.observedAgentId);
            if (!agent || !agent.mesh) return;

            // Move beacon to agent position
            agentObserverMode.beacon.position.copy(agent.mesh.position);

            // Animate beacon
            const time = Date.now() * 0.002;
            const userData = agentObserverMode.beacon.userData;

            if (userData.ring) {
                userData.ring.rotation.z = time;
            }
            if (userData.outerRing) {
                userData.outerRing.rotation.z = -time * 0.5;
                userData.outerRing.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
            }
            if (userData.arrow) {
                userData.arrow.position.y = 8 + Math.sin(time * 3) * 1;
            }
            if (userData.pillar) {
                userData.pillar.material.opacity = 0.3 + Math.sin(time * 2) * 0.15;
            }
        }

        // v6.5.0: Exit observer mode - return camera to player
        function exitAgentObserverMode() {
            if (!agentObserverMode.active) return;

            const agent = agentFleet.find(a => a.id === agentObserverMode.observedAgentId);

            agentObserverMode.active = false;
            agentObserverMode.observedAgentId = null;

            // v6.5.2: Remove beacon
            if (agentObserverMode.beacon && scene) {
                scene.remove(agentObserverMode.beacon);
                agentObserverMode.beacon = null;
            }

            // Hide observer UI
            hideAgentObserverUI();

            // Announce
            if (agent) {
                addCopilotMessage(`Stopped observing ${agent.typeConfig.icon} ${agent.name} - Back to your robot`, 'ai');
            }
        }

        // v6.5.0: Show observer mode UI overlay
        function showAgentObserverUI(agent) {
            hideAgentObserverUI(); // Remove any existing

            const ui = document.createElement('div');
            ui.id = 'agent-observer-ui';
            ui.style.cssText = `
                position: fixed;
                top: 50%;
                left: 20px;
                transform: translateY(-50%);
                background: rgba(0, 20, 40, 0.95);
                border: 2px solid ${agent.typeConfig.color ? '#' + agent.typeConfig.color.toString(16).padStart(6, '0') : '#0af'};
                border-radius: 12px;
                padding: 15px;
                z-index: 2000;
                color: #fff;
                font-family: 'Segoe UI', sans-serif;
                min-width: 200px;
                backdrop-filter: blur(10px);
                box-shadow: 0 0 30px rgba(0, 170, 255, 0.3);
            `;

            ui.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px;">
                    <span style="font-size: 24px;">${agent.typeConfig.icon}</span>
                    <div>
                        <div style="font-weight: bold; font-size: 16px; color: #0ff;">OBSERVING</div>
                        <div style="font-size: 14px;">${agent.name}</div>
                    </div>
                </div>
                <div id="observer-agent-status" style="font-size: 12px; color: #aaa; margin-bottom: 10px;">
                    ${agent.statusMessage || 'Working...'}
                </div>
                <div id="observer-agent-stats" style="font-size: 11px; color: #888; margin-bottom: 12px;">
                    Lv.${agent.agentLevel} | ${agent.taskState?.state || 'active'}
                </div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="exitAgentObserverMode()" style="
                        flex: 1;
                        padding: 10px;
                        background: linear-gradient(180deg, #0066aa, #004488);
                        border: 1px solid #0088cc;
                        border-radius: 6px;
                        color: #fff;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 12px;
                    ">
                         Return to Robot
                    </button>
                </div>
                <div style="font-size: 10px; color: #666; margin-top: 8px; text-align: center;">
                    Press ESC to exit
                </div>
            `;

            document.body.appendChild(ui);
            agentObserverMode.uiElement = ui;

            // Update status periodically
            agentObserverMode.statusInterval = setInterval(() => {
                const statusEl = document.getElementById('observer-agent-status');
                const statsEl = document.getElementById('observer-agent-stats');
                if (statusEl && agent) {
                    statusEl.textContent = agent.statusMessage || 'Working...';
                }
                if (statsEl && agent) {
                    const inv = agent.taskState?.inventory?.length || 0;
                    const cap = agent.taskState?.carryingCapacity || 6;
                    statsEl.textContent = `Lv.${agent.agentLevel} | ${agent.taskState?.state || 'active'} |  ${inv}/${cap}`;
                }
            }, 500);
        }

        // v6.5.0: Hide observer mode UI
        function hideAgentObserverUI() {
            if (agentObserverMode.uiElement) {
                agentObserverMode.uiElement.remove();
                agentObserverMode.uiElement = null;
            }
            if (agentObserverMode.statusInterval) {
                clearInterval(agentObserverMode.statusInterval);
                agentObserverMode.statusInterval = null;
            }
        }

        // v6.5.0: Get the position the camera should follow (agent or player)
        function getObserverTargetPosition() {
            if (agentObserverMode.active) {
                const agent = agentFleet.find(a => a.id === agentObserverMode.observedAgentId);
                if (agent) {
                    if (agent.mesh) return agent.mesh.position;
                    if (agent.position) return agent.position;
                }
                // Agent lost, exit observer mode
                exitAgentObserverMode();
            }
            return worldState.player ? worldState.player.position : null;
        }

        // v5.16.1: Highlight agent on minimap
        function highlightAgentOnMinimap(agent) {
            // The minimap is redrawn each frame, so we'll add a temporary highlight flag
            agent.minimapHighlight = true;
            setTimeout(() => {
                agent.minimapHighlight = false;
            }, 5000); // Highlight for 5 seconds
        }

        // v5.16.1: Create a beacon to guide player to agent
        // v6.3.1: Updated to work without mesh using agent.position
        function createAgentBeacon(agent) {
            if (!scene) return;

            // v6.3.1: Get position from mesh or agent.position
            const pos = agent.mesh ? agent.mesh.position : agent.position;
            if (!pos) return;

            // Create a vertical beam of light at agent's position
            const beaconGeom = new THREE.CylinderGeometry(0.1, 0.5, 15, 8, 1, true);
            const beaconMat = new THREE.MeshBasicMaterial({
                color: agent.typeConfig.color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const beacon = new THREE.Mesh(beaconGeom, beaconMat);
            beacon.position.copy(pos);
            beacon.position.y = 7.5;

            scene.add(beacon);

            // Animate and remove after 5 seconds
            let elapsed = 0;
            const animateBeacon = () => {
                elapsed += 16;
                if (elapsed > 5000) {
                    scene.remove(beacon);
                    return;
                }

                // Pulse effect
                const pulse = Math.sin(elapsed / 200) * 0.2 + 0.8;
                beacon.scale.set(pulse, 1, pulse);
                beaconMat.opacity = 0.3 * (1 - elapsed / 5000);

                // Follow agent if they move (prefer mesh position if available)
                const currentPos = agent.mesh ? agent.mesh.position : agent.position;
                if (currentPos) {
                    beacon.position.x = currentPos.x;
                    beacon.position.z = currentPos.z;
                }

                requestAnimationFrame(animateBeacon);
            };
            animateBeacon();
        }

        // v5.16.1: Update body cams for all expanded agent viewers
        function updateAllAgentBodyCams() {
            agentFleet.forEach(agent => {
                const viewer = document.getElementById(`transcript-viewer-${agent.id}`);
                if (viewer && viewer.classList.contains('expanded')) {
                    renderAgentBodyCam(agent);
                }
            });
        }

        // ============================================
        // v5.16.2: AGENT TAKEOVER / REMOTE CONTROL SYSTEM
        // Allows full remote control of any agent in real-time
        // ============================================

        // Takeover state
        let agentTakeoverState = {
            active: false,
            controlledAgentId: null,
            flyoutOpen: false,
            takeoverRenderer: null,
            takeoverCamera: null,
            takeoverKeys: { w: false, a: false, s: false, d: false },
            lastRenderTime: 0
        };

        // Initialize takeover renderer (higher quality for flyout)
        function initTakeoverRenderer() {
            if (agentTakeoverState.takeoverRenderer) return;

            agentTakeoverState.takeoverCamera = new THREE.PerspectiveCamera(75, 400/300, 0.1, 200);
            agentTakeoverState.takeoverRenderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true,
                powerPreference: 'high-performance'
            });
            agentTakeoverState.takeoverRenderer.setSize(400, 300);
            agentTakeoverState.takeoverRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        // Open takeover flyout for an agent
        function openAgentTakeover(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) {
                addCopilotMessage('Cannot takeover - agent not found or has no physical presence.', 'ai');
                return;
            }

            // v6.5.1: Close observer mode if active - observer and takeover are mutually exclusive
            if (agentObserverMode && agentObserverMode.active) {
                exitAgentObserverMode();
            }

            // Initialize renderer if needed
            initTakeoverRenderer();

            // Set takeover state
            agentTakeoverState.active = true;
            agentTakeoverState.controlledAgentId = agentId;
            agentTakeoverState.flyoutOpen = true;

            // Pause agent's autonomous behavior
            if (agent.taskState) {
                agent.taskState.previousState = agent.taskState.state;
                agent.taskState.state = 'manual_control';
            }

            // Create flyout UI
            createTakeoverFlyout(agent);

            // Notify
            addCopilotMessage(` TAKEOVER ACTIVE: Now controlling ${agent.typeConfig.icon} ${agent.name}. Use WASD to move.`, 'ai');
            AudioSystem.play('powerup');
        }

        // Create the takeover flyout UI
        function createTakeoverFlyout(agent) {
            // Remove any existing flyout
            const existing = document.getElementById('agent-takeover-flyout');
            if (existing) existing.remove();

            const taskState = agent.taskState || {};
            const hp = taskState.hp || 50;
            const maxHp = taskState.maxHp || 50;
            const hpPercent = (hp / maxHp) * 100;
            const hpClass = hpPercent <= 25 ? 'critical' : (hpPercent <= 50 ? 'low' : '');

            const flyout = document.createElement('div');
            flyout.id = 'agent-takeover-flyout';
            flyout.className = 'agent-takeover-flyout';
            flyout.innerHTML = `
                <div class="takeover-header">
                    <div class="takeover-title">
                        <span class="agent-icon">${agent.typeConfig.icon}</span>
                        <span>REMOTE CONTROL: ${agent.name}</span>
                    </div>
                    <button class="takeover-close-btn" onclick="closeAgentTakeover()"> EXIT</button>
                </div>

                <div class="takeover-viewport">
                    <canvas id="takeover-canvas" width="400" height="300"></canvas>

                    <div class="takeover-hud">
                        <div class="takeover-hud-top">
                            <div class="takeover-agent-stats">
                                <div class="takeover-hp-bar">
                                    <div class="takeover-hp-fill ${hpClass}" id="takeover-hp-fill" style="width: ${hpPercent}%"></div>
                                </div>
                                <div class="takeover-hp-text" id="takeover-hp-text">${Math.floor(hp)} / ${maxHp} HP</div>
                                <div class="takeover-agent-info">${agent.typeConfig.name}</div>
                            </div>
                            <div class="takeover-target-info ${taskState.targetObject ? '' : 'resource'}" id="takeover-target-info">
                                ${taskState.targetObject ? ' ' + (taskState.targetObject.name || 'Target') : ' No Target'}
                            </div>
                        </div>

                        <div class="takeover-crosshair"></div>

                        <div class="takeover-status-badge" id="takeover-status">${taskState.currentTask || 'MANUAL CONTROL'}</div>
                    </div>
                </div>

                <div class="takeover-controls">
                    <div class="takeover-controls-row">
                        <div class="takeover-wasd">
                            <div class="takeover-wasd-spacer"></div>
                            <div class="takeover-wasd-key" id="takeover-key-w">W</div>
                            <div class="takeover-wasd-spacer"></div>
                            <div class="takeover-wasd-key" id="takeover-key-a">A</div>
                            <div class="takeover-wasd-key" id="takeover-key-s">S</div>
                            <div class="takeover-wasd-key" id="takeover-key-d">D</div>
                        </div>
                    </div>
                    <div class="takeover-controls-row">
                        <button class="takeover-control-btn action" onclick="takeoverAgentAction()">
                             ACTION <span class="takeover-keybind">E</span>
                        </button>
                        <button class="takeover-control-btn secondary" onclick="focusOnControlledAgent()">
                             LOCATE <span class="takeover-keybind">L</span>
                        </button>
                    </div>
                    <div class="takeover-controls-row">
                        <button class="takeover-control-btn primary" onclick="toggleTakeoverAutoMode()">
                             AUTO MODE <span class="takeover-keybind">M</span>
                        </button>
                        <button class="takeover-control-btn danger" onclick="closeAgentTakeover()">
                             RETURN TO ROBOT <span class="takeover-keybind">ESC</span>
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(flyout);

            // Add active indicator at top of screen
            const indicator = document.createElement('div');
            indicator.id = 'takeover-active-indicator';
            indicator.className = 'takeover-active-indicator';
            indicator.innerHTML = `
                <span class="pulse"></span>
                <span> CONTROLLING: ${agent.typeConfig.icon} ${agent.name}</span>
                <span style="font-size:10px;opacity:0.7">[ESC to exit]</span>
            `;
            document.body.appendChild(indicator);

            // Start rendering loop
            requestAnimationFrame(renderTakeoverView);

            // Add keyboard listener for takeover controls
            // v6.6: Remove existing listeners first to prevent memory leak (Agent 2 bug fix)
            window.removeEventListener('keydown', handleTakeoverKeyDown);
            window.removeEventListener('keyup', handleTakeoverKeyUp);
            window.addEventListener('keydown', handleTakeoverKeyDown);
            window.addEventListener('keyup', handleTakeoverKeyUp);
        }

        // Handle keyboard input for takeover mode
        function handleTakeoverKeyDown(e) {
            if (!agentTakeoverState.active) return;

            const key = e.key.toLowerCase();

            // WASD movement
            if (key === 'w') { agentTakeoverState.takeoverKeys.w = true; e.preventDefault(); }
            if (key === 'a') { agentTakeoverState.takeoverKeys.a = true; e.preventDefault(); }
            if (key === 's') { agentTakeoverState.takeoverKeys.s = true; e.preventDefault(); }
            if (key === 'd') { agentTakeoverState.takeoverKeys.d = true; e.preventDefault(); }

            // Update WASD indicator UI
            updateTakeoverWASDUI();

            // Action key
            if (key === 'e') {
                takeoverAgentAction();
                e.preventDefault();
            }

            // Locate key
            if (key === 'l') {
                focusOnControlledAgent();
                e.preventDefault();
            }

            // Auto mode toggle
            if (key === 'm') {
                toggleTakeoverAutoMode();
                e.preventDefault();
            }

            // Escape to exit
            if (key === 'escape') {
                closeAgentTakeover();
                e.preventDefault();
            }
        }

        // Handle keyboard release for takeover mode
        function handleTakeoverKeyUp(e) {
            if (!agentTakeoverState.active) return;

            const key = e.key.toLowerCase();

            if (key === 'w') agentTakeoverState.takeoverKeys.w = false;
            if (key === 'a') agentTakeoverState.takeoverKeys.a = false;
            if (key === 's') agentTakeoverState.takeoverKeys.s = false;
            if (key === 'd') agentTakeoverState.takeoverKeys.d = false;

            updateTakeoverWASDUI();
        }

        // Update WASD visual indicator
        function updateTakeoverWASDUI() {
            const keys = agentTakeoverState.takeoverKeys;
            const wKey = document.getElementById('takeover-key-w');
            const aKey = document.getElementById('takeover-key-a');
            const sKey = document.getElementById('takeover-key-s');
            const dKey = document.getElementById('takeover-key-d');

            if (wKey) wKey.classList.toggle('active', keys.w);
            if (aKey) aKey.classList.toggle('active', keys.a);
            if (sKey) sKey.classList.toggle('active', keys.s);
            if (dKey) dKey.classList.toggle('active', keys.d);
        }

        // Render the takeover POV view
        function renderTakeoverView() {
            if (!agentTakeoverState.active || !agentTakeoverState.flyoutOpen) return;

            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);
            if (!agent || !agent.mesh || !scene) {
                closeAgentTakeover();
                return;
            }

            const now = performance.now();
            const deltaTime = (now - agentTakeoverState.lastRenderTime) / 1000;
            agentTakeoverState.lastRenderTime = now;

            // Process movement input
            processAgentTakeoverMovement(agent, deltaTime);

            // Update HUD
            updateTakeoverHUD(agent);

            // Position camera at agent's POV
            const agentPos = agent.mesh.position;
            const agentRotation = agent.mesh.rotation.y;

            // First-person camera position
            const cameraOffset = new THREE.Vector3(
                Math.sin(agentRotation) * 0.3,
                1.5, // Eye level
                Math.cos(agentRotation) * 0.3
            );
            agentTakeoverState.takeoverCamera.position.copy(agentPos).add(cameraOffset);

            // Look in the direction the agent is facing
            const lookTarget = new THREE.Vector3(
                agentPos.x + Math.sin(agentRotation) * 10,
                agentPos.y + 1.2,
                agentPos.z + Math.cos(agentRotation) * 10
            );
            agentTakeoverState.takeoverCamera.lookAt(lookTarget);

            // Render to canvas
            const canvas = document.getElementById('takeover-canvas');
            if (canvas && agentTakeoverState.takeoverRenderer) {
                // Update renderer size to match canvas
                const rect = canvas.parentElement.getBoundingClientRect();
                const width = Math.floor(rect.width);
                const height = Math.floor(rect.height);

                if (width > 0 && height > 0) {
                    agentTakeoverState.takeoverCamera.aspect = width / height;
                    agentTakeoverState.takeoverCamera.updateProjectionMatrix();
                    agentTakeoverState.takeoverRenderer.setSize(width, height);
                }

                agentTakeoverState.takeoverRenderer.render(scene, agentTakeoverState.takeoverCamera);

                // Copy to visible canvas
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(agentTakeoverState.takeoverRenderer.domElement, 0, 0);

                    // Add scan line overlay for visual effect
                    ctx.strokeStyle = 'rgba(255, 136, 0, 0.02)';
                    for (let y = 0; y < height; y += 4) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                }
            }

            // Continue render loop
            requestAnimationFrame(renderTakeoverView);
        }

        // Process movement input for controlled agent
        function processAgentTakeoverMovement(agent, deltaTime) {
            const keys = agentTakeoverState.takeoverKeys;
            const hasInput = keys.w || keys.a || keys.s || keys.d;

            if (!hasInput) return;

            const speed = 8 * deltaTime; // Agent movement speed
            const moveDir = new THREE.Vector3(0, 0, 0);

            // Calculate movement relative to agent's facing direction
            const agentRotation = agent.mesh.rotation.y;

            if (keys.w) {
                moveDir.x += Math.sin(agentRotation) * speed;
                moveDir.z += Math.cos(agentRotation) * speed;
            }
            if (keys.s) {
                moveDir.x -= Math.sin(agentRotation) * speed;
                moveDir.z -= Math.cos(agentRotation) * speed;
            }
            if (keys.a) {
                moveDir.x += Math.cos(agentRotation) * speed;
                moveDir.z -= Math.sin(agentRotation) * speed;
            }
            if (keys.d) {
                moveDir.x -= Math.cos(agentRotation) * speed;
                moveDir.z += Math.sin(agentRotation) * speed;
            }

            // Apply movement
            agent.mesh.position.add(moveDir);

            // Update facing direction based on movement
            if (moveDir.length() > 0.01) {
                const newRotation = Math.atan2(moveDir.x, moveDir.z);
                agent.mesh.rotation.y = newRotation;
            }

            // Snap to ground
            if (typeof snapToGround === 'function') {
                snapToGround(agent.mesh);
            }

            // Update task state position tracking
            if (agent.taskState) {
                agent.taskState.lastPosition = agent.mesh.position.clone();
            }
        }

        // Update takeover HUD elements
        function updateTakeoverHUD(agent) {
            const taskState = agent.taskState || {};
            const hp = taskState.hp || 50;
            const maxHp = taskState.maxHp || 50;
            const hpPercent = (hp / maxHp) * 100;

            // Update HP bar
            const hpFill = document.getElementById('takeover-hp-fill');
            const hpText = document.getElementById('takeover-hp-text');
            if (hpFill) {
                hpFill.style.width = hpPercent + '%';
                hpFill.className = 'takeover-hp-fill' + (hpPercent <= 25 ? ' critical' : (hpPercent <= 50 ? ' low' : ''));
            }
            if (hpText) {
                hpText.textContent = `${Math.floor(hp)} / ${maxHp} HP`;
            }

            // Update target info
            const targetInfo = document.getElementById('takeover-target-info');
            if (targetInfo) {
                if (taskState.targetObject) {
                    targetInfo.textContent = ' ' + (taskState.targetObject.name || taskState.targetObject.type || 'Target');
                    targetInfo.className = 'takeover-target-info';
                } else {
                    targetInfo.textContent = ' No Target';
                    targetInfo.className = 'takeover-target-info resource';
                }
            }

            // Update status badge
            const statusBadge = document.getElementById('takeover-status');
            if (statusBadge) {
                statusBadge.textContent = taskState.state === 'manual_control' ? 'MANUAL CONTROL' : (taskState.currentTask || taskState.state || 'ACTIVE').toUpperCase();
            }
        }

        // Perform agent action (interact with nearby objects)
        function takeoverAgentAction() {
            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);
            if (!agent || !agent.mesh) return;

            const agentPos = agent.mesh.position;

            // Find nearest interactable object
            let nearestDist = Infinity;
            let nearestObject = null;

            // Check resources
            if (worldState.resources) {
                worldState.resources.forEach(resource => {
                    if (!resource.position) return;
                    const dist = agentPos.distanceTo(resource.position);
                    if (dist < 3 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestObject = resource;
                    }
                });
            }

            // Check mobs
            if (worldState.mobs) {
                worldState.mobs.forEach(mob => {
                    if (!mob.mesh || mob.isDead) return;
                    const dist = agentPos.distanceTo(mob.mesh.position);
                    if (dist < 3 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestObject = { type: 'mob', mob: mob };
                    }
                });
            }

            if (nearestObject) {
                if (nearestObject.type === 'mob') {
                    // Attack mob
                    const mob = nearestObject.mob;
                    const damage = 15 + Math.random() * 10;
                    mob.hp -= damage;
                    spawnFloater(mob.mesh.position, `-${Math.floor(damage)}`, '#f44');
                    AudioSystem.play('hit');

                    if (mob.hp <= 0) {
                        mob.isDead = true;
                        addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} defeated ${mob.type}!`, 'ai');
                    }
                } else {
                    // Harvest resource
                    if (typeof performAgentAction === 'function') {
                        performAgentAction(agent, nearestObject);
                    } else {
                        spawnFloater(agentPos, '+1 Resource', '#0f0');
                    }
                    AudioSystem.play('collect');
                }
            } else {
                spawnFloater(agentPos, 'Nothing nearby', '#888');
            }
        }

        // Focus main camera on the controlled agent
        function focusOnControlledAgent() {
            if (!agentTakeoverState.controlledAgentId) return;
            focusOnAgent(agentTakeoverState.controlledAgentId);
        }

        // Toggle auto mode (return agent to autonomous behavior)
        function toggleTakeoverAutoMode() {
            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);
            if (!agent) return;

            if (agent.taskState && agent.taskState.state === 'manual_control') {
                // Switch to auto mode
                agent.taskState.state = agent.taskState.previousState || 'idle';
                const statusBadge = document.getElementById('takeover-status');
                if (statusBadge) statusBadge.textContent = 'AUTO MODE';
                addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} switched to AUTO MODE - watching only`, 'ai');
            } else if (agent.taskState) {
                // Switch back to manual
                agent.taskState.previousState = agent.taskState.state;
                agent.taskState.state = 'manual_control';
                const statusBadge = document.getElementById('takeover-status');
                if (statusBadge) statusBadge.textContent = 'MANUAL CONTROL';
                addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} switched to MANUAL CONTROL`, 'ai');
            }
        }

        // Close takeover and return to robot
        function closeAgentTakeover() {
            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);

            // Restore agent's autonomous state
            if (agent && agent.taskState) {
                if (agent.taskState.state === 'manual_control') {
                    agent.taskState.state = agent.taskState.previousState || 'idle';
                }
            }

            // Reset takeover state
            agentTakeoverState.active = false;
            agentTakeoverState.controlledAgentId = null;
            agentTakeoverState.flyoutOpen = false;
            agentTakeoverState.takeoverKeys = { w: false, a: false, s: false, d: false };

            // Remove UI elements
            const flyout = document.getElementById('agent-takeover-flyout');
            if (flyout) flyout.remove();

            const indicator = document.getElementById('takeover-active-indicator');
            if (indicator) indicator.remove();

            // Remove keyboard listeners
            window.removeEventListener('keydown', handleTakeoverKeyDown);
            window.removeEventListener('keyup', handleTakeoverKeyUp);

            // Notify
            if (agent) {
                addCopilotMessage(` Returned control to main robot. ${agent.typeConfig.icon} ${agent.name} resuming autonomous operations.`, 'ai');
            }
            AudioSystem.play('ui');
        }

        // Check if any agent is being controlled (for game loop)
        function isAgentTakeoverActive() {
            return agentTakeoverState.active && agentTakeoverState.controlledAgentId !== null;
        }

        // v5.17.1: Pop-out Agent Control Window System
        // Allows controlling agents in separate windows without interrupting main game
        const agentPopOutWindows = new Map(); // agentId -> window reference

        function popOutAgentWindow(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) {
                addCopilotMessage('Cannot open pop-out - agent not found or has no physical presence.', 'ai');
                return;
            }

            // Check if window already exists
            if (agentPopOutWindows.has(agentId)) {
                const existingWindow = agentPopOutWindows.get(agentId);
                if (existingWindow && !existingWindow.closed) {
                    existingWindow.focus();
                    return;
                }
            }

            // Create the pop-out window
            const windowWidth = 500;
            const windowHeight = 450;
            const left = window.screenX + 50 + (agentPopOutWindows.size * 30);
            const top = window.screenY + 50 + (agentPopOutWindows.size * 30);

            const popOutWindow = window.open('', `agent_${agentId}`,
                `width=${windowWidth},height=${windowHeight},left=${left},top=${top},resizable=yes`
            );

            if (!popOutWindow) {
                addCopilotMessage('Pop-up blocked! Please allow pop-ups for this site.', 'ai');
                return;
            }

            agentPopOutWindows.set(agentId, popOutWindow);

            // Get the HTML components from generateAgentPopOutHTML
            const htmlParts = generateAgentPopOutHTML(agent);

            // v6.5.2: Build DOM directly to avoid document.write parsing issues
            // Wait for about:blank to be ready
            setTimeout(() => {
                if (!popOutWindow || popOutWindow.closed) return;

                const doc = popOutWindow.document;

                // Set title
                doc.title = htmlParts.title;

                // Add meta tags
                const meta1 = doc.createElement('meta');
                meta1.charset = 'UTF-8';
                doc.head.appendChild(meta1);

                const meta2 = doc.createElement('meta');
                meta2.name = 'viewport';
                meta2.content = 'width=device-width, initial-scale=1.0';
                doc.head.appendChild(meta2);

                // Add styles
                const style = doc.createElement('style');
                style.textContent = htmlParts.css;
                doc.head.appendChild(style);

                // Add body content
                doc.body.innerHTML = htmlParts.body;

                // Set up communication bridge
                popOutWindow.agentId = agentId;
                popOutWindow.parentGame = window;

                // Inject script
                const scriptEl = doc.createElement('script');
                scriptEl.textContent = htmlParts.js;
                doc.body.appendChild(scriptEl);
            }, 50);

            // Handle window close
            const checkClosed = setInterval(() => {
                if (popOutWindow.closed) {
                    clearInterval(checkClosed);
                    agentPopOutWindows.delete(agentId);
                }
            }, 1000);

            addCopilotMessage(` ${agent.typeConfig.icon} ${agent.name} control window opened! Main game continues independently.`, 'ai');
            AudioSystem.play('ui');
        }

        function generateAgentPopOutHTML(agent) {
            const colorHex = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');
            const taskState = agent.taskState || {};
            const hp = taskState.hp || 50;
            const maxHp = taskState.maxHp || 50;
            const hpPercent = (hp / maxHp) * 100;

            // Build CSS
            const css = `
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { font-family: 'Consolas', 'Monaco', monospace; background: #0a0a0f; color: #fff; overflow: hidden; user-select: none; }
                .header { background: linear-gradient(135deg, #1a1a2e 0%, #0d0d15 100%); border-bottom: 1px solid ${colorHex}44; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; }
                .agent-title { display: flex; align-items: center; gap: 8px; }
                .agent-icon { font-size: 24px; }
                .agent-name { font-size: 14px; font-weight: bold; color: ${colorHex}; }
                .agent-type { font-size: 11px; color: #888; }
                .status-badge { background: ${colorHex}33; border: 1px solid ${colorHex}; color: ${colorHex}; padding: 3px 8px; border-radius: 4px; font-size: 10px; text-transform: uppercase; }
                .viewport { position: relative; width: 100%; height: 280px; background: #000; border-bottom: 1px solid #333; }
                #agent-canvas { width: 100%; height: 100%; display: block; }
                .hud-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
                .hud-top { position: absolute; top: 8px; left: 8px; right: 8px; display: flex; justify-content: space-between; }
                .hp-container { background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; border: 1px solid #333; }
                .hp-bar { width: 120px; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-bottom: 4px; }
                .hp-fill { height: 100%; background: linear-gradient(90deg, #f44 0%, #ff8800 50%, #4f4 100%); transition: width 0.3s; }
                .hp-fill.critical { background: #f44; animation: critical-pulse 0.5s infinite; }
                @keyframes critical-pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
                .hp-text { font-size: 10px; color: #aaa; }
                .stats-container { background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; border: 1px solid #333; text-align: right; }
                .stat-row { font-size: 10px; color: #aaa; margin: 2px 0; }
                .stat-value { color: ${colorHex}; font-weight: bold; }
                .stat-combo { color: #ff8800; }
                .hud-bottom { position: absolute; bottom: 8px; left: 8px; right: 8px; display: flex; justify-content: space-between; align-items: flex-end; }
                .coords { font-size: 10px; color: #0ff; font-family: monospace; }
                .action-text { font-size: 11px; color: #fff; }
                .controls { background: linear-gradient(180deg, #0d0d15 0%, #1a1a2e 100%); padding: 12px; display: flex; flex-direction: column; gap: 10px; }
                .control-row { display: flex; justify-content: center; gap: 8px; }
                .wasd-container { display: grid; grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(2, 40px); gap: 4px; }
                .wasd-key { width: 40px; height: 40px; background: #222; border: 1px solid #444; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: #888; transition: all 0.1s; }
                .wasd-key.active { background: ${colorHex}44; border-color: ${colorHex}; color: ${colorHex}; box-shadow: 0 0 10px ${colorHex}66; }
                .action-btn { flex: 1; padding: 12px; background: #222; border: 1px solid #444; border-radius: 6px; color: #fff; font-size: 12px; font-weight: bold; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px; }
                .action-btn:hover { background: #333; border-color: #666; }
                .action-btn:active { transform: scale(0.97); }
                .action-btn.primary { border-color: ${colorHex}; color: ${colorHex}; }
                .action-btn.primary:hover { background: ${colorHex}22; }
                .keybind { font-size: 9px; color: #666; margin-left: 4px; }
                .mode-toggle { display: flex; align-items: center; gap: 8px; font-size: 11px; color: #888; }
                .mode-switch { width: 40px; height: 20px; background: #333; border-radius: 10px; position: relative; cursor: pointer; }
                .mode-switch::after { content: ''; position: absolute; width: 16px; height: 16px; background: #666; border-radius: 50%; top: 2px; left: 2px; transition: all 0.2s; }
                .mode-switch.auto::after { left: 22px; background: ${colorHex}; }
                .mode-switch.auto { background: ${colorHex}44; }
            `;

            // Build HTML body
            const body = `
                <div class="header">
                    <div class="agent-title">
                        <span class="agent-icon">${agent.typeConfig.icon}</span>
                        <div>
                            <div class="agent-name">${agent.name}</div>
                            <div class="agent-type">${agent.typeConfig.name}</div>
                        </div>
                    </div>
                    <div class="status-badge" id="status-badge">AUTONOMOUS</div>
                </div>
                <div class="viewport">
                    <canvas id="agent-canvas"></canvas>
                    <div class="hud-overlay">
                        <div class="hud-top">
                            <div class="hp-container">
                                <div class="hp-bar"><div class="hp-fill" id="hp-fill" style="width: ${hpPercent}%"></div></div>
                                <div class="hp-text" id="hp-text">${Math.floor(hp)} / ${maxHp} HP</div>
                            </div>
                            <div class="stats-container">
                                <div class="stat-row">Level: <span class="stat-value" id="stat-level">${agent.agentLevel}</span></div>
                                <div class="stat-row">Combo: <span class="stat-combo" id="stat-combo">${agent.combo}x</span></div>
                                <div class="stat-row">Efficiency: <span class="stat-value" id="stat-eff">${Math.round(agent.efficiency * 100)}%</span></div>
                            </div>
                        </div>
                        <div class="hud-bottom">
                            <div class="coords" id="coords">X: 0 Z: 0</div>
                            <div class="action-text" id="action-text">${agent.statusMessage || 'Working...'}</div>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-row">
                        <div class="wasd-container">
                            <div></div><div class="wasd-key" id="key-w">W</div><div></div>
                            <div class="wasd-key" id="key-a">A</div><div class="wasd-key" id="key-s">S</div><div class="wasd-key" id="key-d">D</div>
                        </div>
                    </div>
                    <div class="control-row">
                        <button class="action-btn primary" id="action-btn"> ACTION <span class="keybind">E</span></button>
                        <button class="action-btn" id="locate-btn"> LOCATE <span class="keybind">L</span></button>
                    </div>
                    <div class="control-row">
                        <div class="mode-toggle">
                            <span>Manual</span>
                            <div class="mode-switch auto" id="mode-switch"></div>
                            <span>Auto</span>
                        </div>
                    </div>
                </div>
            `;

            // Build JS - using array join to avoid script tag issues
            const js = [
                'const agentId = "' + agent.id + '";',
                'let keys = { w: false, a: false, s: false, d: false };',
                'let isAutoMode = true;',
                'let canvas, ctx;',
                'let updateInterval;',
                '',
                'window.onload = function() {',
                '    canvas = document.getElementById("agent-canvas");',
                '    ctx = canvas.getContext("2d");',
                '    resizeCanvas();',
                '    window.onresize = resizeCanvas;',
                '    updateInterval = setInterval(updateView, 50);',
                '    document.addEventListener("keydown", handleKeyDown);',
                '    document.addEventListener("keyup", handleKeyUp);',
                '    document.getElementById("action-btn").onclick = performAction;',
                '    document.getElementById("locate-btn").onclick = locateAgent;',
                '    document.getElementById("mode-switch").onclick = toggleMode;',
                '};',
                '',
                'function resizeCanvas() {',
                '    const viewport = canvas.parentElement;',
                '    canvas.width = viewport.clientWidth;',
                '    canvas.height = viewport.clientHeight;',
                '}',
                '',
                'function updateView() {',
                '    if (!window.opener || window.opener.closed) {',
                '        clearInterval(updateInterval);',
                '        document.body.innerHTML = "<div style=\\"padding:40px;text-align:center;color:#f44;\\">Main game window closed</div>";',
                '        return;',
                '    }',
                '    try {',
                '        const parent = window.opener;',
                '        const agent = parent.agentFleet && parent.agentFleet.find(function(a) { return a.id === agentId; });',
                '        if (!agent) {',
                '            ctx.fillStyle = "#111";',
                '            ctx.fillRect(0, 0, canvas.width, canvas.height);',
                '            ctx.fillStyle = "#f44";',
                '            ctx.font = "14px monospace";',
                '            ctx.fillText("Agent recalled", canvas.width/2 - 50, canvas.height/2);',
                '            return;',
                '        }',
                '        if (parent.renderPopOutAgentView) {',
                '            parent.renderPopOutAgentView(agentId, canvas);',
                '        }',
                '        updateHUD(agent);',
                '        if (!isAutoMode && (keys.w || keys.a || keys.s || keys.d)) {',
                '            moveAgent(agent);',
                '        }',
                '    } catch (e) { console.error("Update error:", e); }',
                '}',
                '',
                'function updateHUD(agent) {',
                '    var taskState = agent.taskState || {};',
                '    var hp = taskState.hp || 50;',
                '    var maxHp = taskState.maxHp || 50;',
                '    var hpPercent = (hp / maxHp) * 100;',
                '    document.getElementById("hp-fill").style.width = hpPercent + "%";',
                '    document.getElementById("hp-fill").className = "hp-fill" + (hpPercent <= 25 ? " critical" : "");',
                '    document.getElementById("hp-text").textContent = Math.floor(hp) + " / " + maxHp + " HP";',
                '    document.getElementById("stat-level").textContent = agent.agentLevel;',
                '    document.getElementById("stat-combo").textContent = agent.combo + "x";',
                '    document.getElementById("stat-eff").textContent = Math.round(agent.efficiency * 100) + "%";',
                '    if (agent.mesh) {',
                '        var pos = agent.mesh.position;',
                '        document.getElementById("coords").textContent = "X: " + Math.floor(pos.x) + " Z: " + Math.floor(pos.z);',
                '    }',
                '    document.getElementById("action-text").textContent = agent.statusMessage || "Working...";',
                '    document.getElementById("status-badge").textContent = isAutoMode ? "AUTONOMOUS" : "MANUAL CONTROL";',
                '}',
                '',
                'function moveAgent(agent) {',
                '    if (!agent.mesh || !window.opener) return;',
                '    var speed = 0.15;',
                '    var rotation = agent.mesh.rotation.y;',
                '    var dx = 0, dz = 0;',
                '    if (keys.w) { dx += Math.sin(rotation); dz += Math.cos(rotation); }',
                '    if (keys.s) { dx -= Math.sin(rotation); dz -= Math.cos(rotation); }',
                '    if (keys.a) { dx += Math.cos(rotation); dz -= Math.sin(rotation); }',
                '    if (keys.d) { dx -= Math.cos(rotation); dz += Math.sin(rotation); }',
                '    if (dx !== 0 || dz !== 0) {',
                '        var len = Math.sqrt(dx*dx + dz*dz);',
                '        dx = (dx / len) * speed;',
                '        dz = (dz / len) * speed;',
                '        agent.mesh.position.x += dx;',
                '        agent.mesh.position.z += dz;',
                '        agent.position.copy(agent.mesh.position);',
                '        agent.mesh.rotation.y = Math.atan2(dx, dz);',
                '    }',
                '}',
                '',
                'function handleKeyDown(e) {',
                '    var key = e.key.toLowerCase();',
                '    if (["w","a","s","d"].indexOf(key) >= 0) {',
                '        keys[key] = true;',
                '        document.getElementById("key-" + key).classList.add("active");',
                '        if (isAutoMode) {',
                '            isAutoMode = false;',
                '            setAgentManualMode(true);',
                '            document.getElementById("mode-switch").classList.remove("auto");',
                '        }',
                '        e.preventDefault();',
                '    } else if (key === "e") { performAction(); }',
                '    else if (key === "l") { locateAgent(); }',
                '    else if (key === "m") { toggleMode(); }',
                '}',
                '',
                'function handleKeyUp(e) {',
                '    var key = e.key.toLowerCase();',
                '    if (["w","a","s","d"].indexOf(key) >= 0) {',
                '        keys[key] = false;',
                '        document.getElementById("key-" + key).classList.remove("active");',
                '    }',
                '}',
                '',
                'function toggleMode() {',
                '    isAutoMode = !isAutoMode;',
                '    document.getElementById("mode-switch").classList.toggle("auto", isAutoMode);',
                '    setAgentManualMode(!isAutoMode);',
                '}',
                '',
                'function setAgentManualMode(isManual) {',
                '    try {',
                '        var parent = window.opener;',
                '        var agent = parent.agentFleet && parent.agentFleet.find(function(a) { return a.id === agentId; });',
                '        if (agent && agent.taskState) {',
                '            if (isManual) {',
                '                agent.taskState.previousState = agent.taskState.state;',
                '                agent.taskState.state = "manual_control";',
                '            } else {',
                '                agent.taskState.state = agent.taskState.previousState || "idle";',
                '            }',
                '        }',
                '    } catch (e) {}',
                '}',
                '',
                'function performAction() {',
                '    try {',
                '        var parent = window.opener;',
                '        if (parent.popOutAgentAction) { parent.popOutAgentAction(agentId); }',
                '    } catch (e) {}',
                '}',
                '',
                'function locateAgent() {',
                '    try {',
                '        var parent = window.opener;',
                '        if (parent.focusOnAgent) { parent.focusOnAgent(agentId); }',
                '    } catch (e) {}',
                '}',
                '',
                'window.onbeforeunload = function() {',
                '    clearInterval(updateInterval);',
                '    setAgentManualMode(false);',
                '};'
            ].join('\n');

            return { css, body, js, title: agent.typeConfig.icon + ' ' + agent.name + ' - Agent Control' };
        }

        // Render function called by pop-out windows to get agent view
        function renderPopOutAgentView(agentId, targetCanvas) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh || !scene) return;

            const ctx = targetCanvas.getContext('2d');

            // Use the existing body cam renderer
            if (!bodyCamInitialized) initAgentBodyCamSystem();
            if (!agentBodyCamRenderer || !agentBodyCamCamera) {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
                return;
            }

            try {
                // Position camera at agent's POV
                const agentPos = agent.mesh.position;
                const agentRotation = agent.mesh.rotation.y || 0;

                agentBodyCamCamera.position.set(
                    agentPos.x + Math.sin(agentRotation) * 0.3,
                    agentPos.y + 1.5,
                    agentPos.z + Math.cos(agentRotation) * 0.3
                );

                const lookTarget = new THREE.Vector3(
                    agentPos.x + Math.sin(agentRotation) * 10,
                    agentPos.y + 1.0,
                    agentPos.z + Math.cos(agentRotation) * 10
                );
                agentBodyCamCamera.lookAt(lookTarget);

                // Adjust renderer for pop-out size
                const origWidth = agentBodyCamRenderer.domElement.width;
                const origHeight = agentBodyCamRenderer.domElement.height;
                agentBodyCamRenderer.setSize(targetCanvas.width, targetCanvas.height);

                agentBodyCamRenderer.render(scene, agentBodyCamCamera);

                // Copy to target canvas
                ctx.drawImage(agentBodyCamRenderer.domElement, 0, 0);

                // Reset renderer size
                agentBodyCamRenderer.setSize(origWidth, origHeight);
            } catch (e) {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
            }
        }

        // Action function called by pop-out windows
        function popOutAgentAction(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) return;

            const agentPos = agent.mesh.position;
            let nearestDist = Infinity;
            let nearestObject = null;

            // Check resources
            worldState.interactables?.forEach(obj => {
                if (!obj.parent) return;
                const dist = agentPos.distanceTo(obj.position);
                if (dist < 3 && dist < nearestDist) {
                    nearestDist = dist;
                    nearestObject = { type: 'resource', obj: obj };
                }
            });

            // Check mobs
            worldState.mobs?.forEach(mob => {
                if (!mob.mesh || mob.isDead) return;
                const dist = agentPos.distanceTo(mob.mesh.position);
                if (dist < 3 && dist < nearestDist) {
                    nearestDist = dist;
                    nearestObject = { type: 'mob', mob: mob };
                }
            });

            if (nearestObject) {
                if (nearestObject.type === 'mob') {
                    const damage = 15 + agent.agentLevel * 2;
                    nearestObject.mob.hp -= damage;
                    spawnFloater(nearestObject.mob.mesh.position, '-' + Math.floor(damage), '#f44');
                    trackAgentAction(agent, true, 8);
                    if (nearestObject.mob.hp <= 0) {
                        nearestObject.mob.isDead = true;
                    }
                } else {
                    performAgentAction(agent, nearestObject.obj);
                }
                AudioSystem.play('hit');
            }
        }

        // v5.16: Update all agent meshes and run autonomous task behaviors
        // v5.16.3: Fixed - create mesh if agent was spawned before scene was ready
        function updateAgentFleetMeshes(deltaTime) {
            const now = performance.now();

            agentFleet.forEach(agent => {
                // v5.16.3: If agent has no mesh but scene is now ready, create it
                if (!agent.mesh && scene) {
                    createAgentMesh(agent);
                    if (agent.mesh) {
                        logAgentTask(agent, 'Spawned into world');
                        agent.statusMessage = 'Ready for duty!';
                        updateAgentCardUI(agent);
                    }
                }
                if (!agent.mesh) return;
                if (!agent.taskState) {
                    // Initialize task state if missing (for older agents)
                    agent.taskState = {
                        currentTask: null, targetObject: null, targetPosition: null,
                        state: 'idle', stuckCounter: 0, lastPosition: null, lastTaskTime: 0,
                        alert: null, actionCooldown: 0, hp: 50, maxHp: 50, taskLog: []
                    };
                }

                const task = agent.taskState;
                const time = now / 1000;

                // Visual animations
                updateAgentVisuals(agent, deltaTime, time);

                // Run autonomous task behavior (every 100ms for performance)
                if (now - task.lastTaskTime > 100) {
                    task.lastTaskTime = now;
                    runAgentAutonomousTask(agent, deltaTime);
                }

                // v5.17: Agent health regeneration
                updateAgentHealthRegen(agent);

                // Check if stuck
                if (task.lastPosition) {
                    const moved = agent.mesh.position.distanceTo(task.lastPosition);
                    // v6.4.0: Also check stuck when returning to ship
                    if (moved < 0.01 && (task.state === 'moving' || task.state === 'returning')) {
                        task.stuckCounter++;
                        if (task.stuckCounter > 50) {
                            logAgentTask(agent, 'Got stuck, picking new target');
                            task.targetObject = null;
                            task.targetPosition = null;
                            task.state = 'idle';
                            task.stuckCounter = 0;
                        }
                    } else {
                        task.stuckCounter = 0;
                    }
                }
                task.lastPosition = agent.mesh.position.clone();
            });
        }

        // v5.16: Update agent visual animations
        function updateAgentVisuals(agent, deltaTime, time) {
            // Idle bobbing (subtle)
            const bobOffset = Math.sin(time * 2 + agent.id.charCodeAt(0)) * 0.05;
            agent.mesh.position.y = bobOffset;

            // Glow pulse
            if (agent.glow) {
                agent.glow.material.opacity = 0.08 + Math.sin(time * 3) * 0.04;
            }

            // Visor blink
            if (agent.visor && Math.random() < 0.002) {
                agent.visor.material.emissiveIntensity = 0.2;
                setTimeout(() => {
                    if (agent.visor) agent.visor.material.emissiveIntensity = 0.8;
                }, 100);
            }

            // Alert indicator pulsing
            if (agent.alertIndicator && agent.taskState.alert) {
                agent.alertIndicator.material.opacity = 0.5 + Math.sin(time * 6) * 0.5;
                agent.alertIndicator.scale.setScalar(1 + Math.sin(time * 6) * 0.3);
            } else if (agent.alertIndicator) {
                agent.alertIndicator.material.opacity = 0;
            }

            // Tool animation when working
            if (agent.tool && agent.taskState.state === 'working') {
                agent.tool.rotation.x = Math.sin(time * 8) * 0.3;
            }

            // Face movement direction
            if (agent.taskState.targetPosition) {
                const dir = new THREE.Vector3().subVectors(agent.taskState.targetPosition, agent.mesh.position);
                if (dir.length() > 0.5) {
                    const targetAngle = Math.atan2(dir.x, dir.z);
                    agent.mesh.rotation.y = THREE.MathUtils.lerp(agent.mesh.rotation.y, targetAngle, deltaTime * 5);
                }
            }
        }

        // v5.16: Run autonomous task behavior for an agent
        function runAgentAutonomousTask(agent, deltaTime) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Don't run tasks if alerted (waiting for player)
            if (task.alert && task.state === 'alert') {
                return;
            }

            // Decrement action cooldown
            if (task.actionCooldown > 0) {
                task.actionCooldown -= 100;
                return;
            }

            // Task behavior based on agent type
            switch (agent.type) {
                case 'gatherer':
                case 'miner':
                    runGathererTask(agent);
                    break;
                case 'hunter':
                case 'protector':
                    runHunterTask(agent);
                    break;
                case 'scout':
                case 'explorer':
                    runScoutTask(agent);
                    break;
                case 'healer':
                    runHealerTask(agent);
                    break;
                case 'fisher':
                    runFisherTask(agent);
                    break;
                case 'builder':
                    // v6.66: RCT-style autonomous building
                    if (typeof runBuilderTask === 'function') {
                        runBuilderTask(agent);
                    }
                    break;
                case 'terraformer':
                    // v6.66: RCT-style terrain modification
                    if (typeof runTerraformerTask === 'function') {
                        runTerraformerTask(agent);
                    }
                    break;
                default:
                    runGathererTask(agent); // Default behavior
            }

            // Move towards target if we have one
            // v6.4.0: Also move when returning to ship
            if (task.targetPosition && (task.state === 'moving' || task.state === 'returning')) {
                moveAgentTowards(agent, task.targetPosition, deltaTime);
            }
        }

        // v6.4.0: Gatherer/Miner task - FULL HAULING CYCLE
        // 1. Gather resources until inventory full
        // 2. Return to ship to deposit
        // 3. Repeat
        function runGathererTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;
            const isMiner = agent.type === 'miner';

            // Initialize inventory if missing (backwards compatibility)
            if (!task.inventory) task.inventory = [];
            if (!task.carryingCapacity) task.carryingCapacity = 6 + Math.floor(agent.agentLevel / 2);

            // Update capacity based on level
            task.carryingCapacity = 6 + Math.floor(agent.agentLevel / 2);

            // ===== STATE: DEPOSITING =====
            // At ship, depositing resources
            if (task.state === 'depositing') {
                depositAgentInventory(agent);
                return;
            }

            // ===== STATE: RETURNING =====
            // Inventory full or returning - head to ship
            if (task.state === 'returning' || task.inventory.length >= task.carryingCapacity) {
                if (task.inventory.length === 0) {
                    // Nothing to deposit, go back to gathering
                    task.state = 'idle';
                    task.targetObject = null;
                    task.targetPosition = null;
                    return;
                }

                // Check if we're at the ship
                const shipPos = SHIP_STATE.position;
                const distToShip = agentPos.distanceTo(shipPos);

                if (distToShip < 5) {
                    // At ship - deposit!
                    task.state = 'depositing';
                    task.targetPosition = null;
                    logAgentTask(agent, `Arrived at ship with ${task.inventory.length} items!`);
                    agent.statusMessage = ` Depositing ${task.inventory.length} items...`;
                    updateAgentCardUI(agent);
                    return;
                }

                // Not at ship yet - move towards it
                task.state = 'returning';
                task.targetPosition = shipPos.clone();
                task.targetObject = null;
                agent.statusMessage = ` Returning to ship (${task.inventory.length}/${task.carryingCapacity})`;
                updateAgentCardUI(agent);
                return;
            }

            // ===== STATE: WORKING =====
            // If we have a resource target, check if close enough to harvest
            if (task.targetObject && task.targetObject.parent) {
                const dist = agentPos.distanceTo(task.targetObject.position);
                if (dist < 2) {
                    // Close enough to interact
                    task.state = 'working';
                    performAgentHarvest(agent, task.targetObject);
                    return;
                } else {
                    // Move towards target
                    task.state = 'moving';
                    task.targetPosition = task.targetObject.position.clone();
                    agent.statusMessage = ` Moving to ${task.targetObject.userData?.name || 'resource'}`;
                    return;
                }
            }

            // ===== STATE: IDLE - Find new resource =====
            let bestTarget = null;
            let bestDist = 40; // Increased search range

            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const name = obj.userData?.name || '';
                const type = obj.userData?.type || '';

                // Filter by agent type
                const isValidTarget = isMiner
                    ? (type === 'rock' || name.includes('Ore') || name.includes('Crystal') || name.includes('Stone'))
                    : (type === 'tree' || name.includes('Tree') || name.includes('Bush') || name.includes('Plant') || name.includes('Herb'));

                if (!isValidTarget) return;

                const dist = agentPos.distanceTo(obj.position);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestTarget = obj;
                }
            });

            if (bestTarget) {
                task.targetObject = bestTarget;
                task.targetPosition = bestTarget.position.clone();
                task.state = 'moving';
                const invStatus = task.inventory.length > 0 ? ` [${task.inventory.length}/${task.carryingCapacity}]` : '';
                agent.statusMessage = ` Found ${bestTarget.userData?.name || 'resource'}${invStatus}`;
                logAgentTask(agent, `Found ${bestTarget.userData?.name || 'resource'} at distance ${Math.floor(bestDist)}`);
            } else {
                // No resources found, wander
                if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agentPos);
                    task.state = 'moving';
                    agent.statusMessage = ` Searching for resources...`;
                    logAgentTask(agent, 'No resources nearby, wandering...');
                }
            }
        }

        // v6.4.0: Agent harvests resource and adds to AGENT inventory (not player)
        function performAgentHarvest(agent, target) {
            const task = agent.taskState;
            const data = target.userData;

            if (!data || data.hp === undefined) return;

            // Deal "damage" to resource
            const damage = 2 + Math.floor(agent.agentLevel / 3);
            data.hp -= damage;

            // Visual feedback
            target.scale.setScalar(0.9);
            setTimeout(() => { if (target.parent) target.scale.setScalar(1); }, 100);

            // Particles
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 : 0x888888;
                particles.emit(target.position, 3, particleColor, { spread: 1.5, lifetime: 400, size: 0.1 });
            }

            // Swing animation for agent
            if (agent.mesh) {
                agent.mesh.rotation.y += 0.3;
                setTimeout(() => { if (agent.mesh) agent.mesh.rotation.y -= 0.3; }, 150);
            }

            // Check if destroyed
            if (data.hp <= 0) {
                let itemName = 'Resource';
                let itemCount = 1 + Math.floor(agent.agentLevel / 4);

                if (data.type === 'tree') {
                    itemName = Math.random() < 0.3 ? 'Fiber' : 'Log';
                    itemCount = 2 + Math.floor(agent.agentLevel / 3);
                } else if (data.type === 'rock') {
                    const ores = ['Stone', 'Iron Ore', 'Copper Ore'];
                    if (agent.agentLevel >= 3) ores.push('Silver Ore');
                    if (agent.agentLevel >= 5) ores.push('Gold Ore');
                    itemName = ores[Math.floor(Math.random() * ores.length)];
                    itemCount = 2 + Math.floor(agent.agentLevel / 3);
                } else if (data.name?.includes('Herb') || data.name?.includes('Plant')) {
                    itemName = 'Herbs';
                    itemCount = 1 + Math.floor(agent.agentLevel / 4);
                }

                // Add to AGENT inventory (not player!)
                for (let i = 0; i < itemCount; i++) {
                    if (task.inventory.length < task.carryingCapacity) {
                        task.inventory.push(itemName);
                    }
                }

                // Track earnings
                agent.totalEarnings.items.push({ item: itemName, amount: itemCount });

                // Visual/audio feedback
                spawnFloater(target.position, `+${itemCount} ${itemName}`, '#ffdd00');
                spawnFloater(agent.mesh.position, ` ${task.inventory.length}/${task.carryingCapacity}`, '#0ff');
                AudioSystem.collect();

                // Update agent status
                const invFull = task.inventory.length >= task.carryingCapacity;
                agent.statusMessage = invFull
                    ? ` Inventory FULL! Returning to ship...`
                    : `Got ${itemCount} ${itemName}! [${task.inventory.length}/${task.carryingCapacity}]`;
                agent.progress = Math.min(100, agent.progress + 5);

                logAgentTask(agent, `Harvested ${itemCount} ${itemName} (carrying ${task.inventory.length}/${task.carryingCapacity})`);
                trackAgentAction(agent, true, itemCount * 2);
                updateAgentCardUI(agent);

                // Remove from world
                scene.remove(target);
                worldState.interactables = worldState.interactables.filter(x => x !== target);

                // Clear target
                task.targetObject = null;
                task.targetPosition = null;
                task.state = 'idle';

                // If full, trigger return
                if (invFull) {
                    task.state = 'returning';
                }
            }

            task.actionCooldown = 400; // Slightly faster than before
        }

        // v6.4.0: Agent deposits inventory at ship
        function depositAgentInventory(agent) {
            const task = agent.taskState;

            if (task.inventory.length === 0) {
                task.state = 'idle';
                agent.statusMessage = 'Inventory empty, returning to work!';
                updateAgentCardUI(agent);
                return;
            }

            // Deposit one item per tick (animated feel)
            const item = task.inventory.shift();

            // Add to player inventory
            addToInventory(item, 1);

            // Track stats
            task.totalHauled = (task.totalHauled || 0) + 1;

            // Visual feedback at ship
            if (SHIP_STATE.mesh) {
                const shipPos = SHIP_STATE.position;
                spawnFloater(new THREE.Vector3(shipPos.x, shipPos.y + 2, shipPos.z), `+1 ${item}`, '#00ff88');
            }

            // Update status
            if (task.inventory.length > 0) {
                agent.statusMessage = ` Depositing... (${task.inventory.length} left)`;
            } else {
                // All deposited!
                task.tripsCompleted = (task.tripsCompleted || 0) + 1;
                const totalItems = task.totalHauled || 0;

                agent.statusMessage = ` Delivery complete! Trip #${task.tripsCompleted}`;
                logAgentTask(agent, `Completed delivery #${task.tripsCompleted} (${totalItems} total items hauled)`);

                // Bonus XP for completing a trip
                const tripXP = 10 + task.tripsCompleted * 2;
                grantAgentXP(agent, tripXP);

                // Celebrate!
                if (particles && agent.mesh) {
                    particles.emit(agent.mesh.position, 10, 0x00ff88, { spread: 2, lifetime: 800, size: 0.15 });
                }
                spawnFloater(agent.mesh.position, ` Trip #${task.tripsCompleted}!`, '#ffd700');

                // Return to gathering after short delay
                task.state = 'idle';
                task.actionCooldown = 500;
            }

            updateAgentCardUI(agent);
            task.actionCooldown = 200; // Fast deposit animation
        }

        // v6.4.0: Grant XP to agent (for trip completion bonuses etc)
        function grantAgentXP(agent, xp) {
            if (typeof trackAgentAction === 'function') {
                // Use existing XP system
                agent.agentXP = (agent.agentXP || 0) + xp;
                const xpNeeded = getAgentXPForLevel(agent.agentLevel);
                if (agent.agentXP >= xpNeeded) {
                    agent.agentLevel++;
                    agent.agentXP -= xpNeeded;
                    spawnFloater(agent.mesh?.position || agent.position, ` Level ${agent.agentLevel}!`, '#ffd700');
                    logAgentTask(agent, `Leveled up to ${agent.agentLevel}!`);
                }
            }
        }

        // v5.16: Hunter task - find and attack enemies
        function runHunterTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Check agent HP - alert if low
            if (task.hp < task.maxHp * 0.3 && !task.alert) {
                triggerAgentAlert(agent, 'Low HP! Need healing assistance.');
                return;
            }

            // If we have a target enemy, attack it
            if (task.targetObject && task.targetObject.parent && task.targetObject.userData?.hp > 0) {
                const dist = agentPos.distanceTo(task.targetObject.position);
                if (dist < 2.5) {
                    task.state = 'combat';
                    performAgentCombat(agent, task.targetObject);
                    return;
                } else {
                    task.state = 'moving';
                    task.targetPosition = task.targetObject.position.clone();
                    return;
                }
            }

            // Find a new enemy target
            let bestTarget = null;
            let bestDist = 25;

            worldState.mobs.forEach(mob => {
                if (!mob.mesh || !mob.mesh.parent) return;
                if (mob.userData?.hp <= 0) return;

                // Avoid bosses unless protector
                const isBoss = mob.userData?.type === 'boss' || mob.userData?.isBoss;
                if (isBoss && agent.type !== 'protector') {
                    // Alert about boss!
                    if (!task.alert) {
                        triggerAgentAlert(agent, `Found BOSS: ${mob.userData?.name || 'Unknown'}! Need backup!`);
                    }
                    return;
                }

                const dist = agentPos.distanceTo(mob.mesh.position);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestTarget = mob;
                }
            });

            if (bestTarget) {
                task.targetObject = bestTarget.mesh;
                task.targetPosition = bestTarget.mesh.position.clone();
                task.state = 'moving';
                logAgentTask(agent, `Engaging ${bestTarget.userData?.name || 'enemy'}`);
            } else {
                // No enemies, patrol near player
                if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 2) {
                    if (worldState.player) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 15,
                            0,
                            (Math.random() - 0.5) * 15
                        );
                        task.targetPosition = worldState.player.position.clone().add(offset);
                    } else {
                        task.targetPosition = getRandomWanderPosition(agentPos);
                    }
                    task.state = 'moving';
                }
            }
        }

        // v5.16: Scout/Explorer task - explore and discover
        function runScoutTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Scouts move faster and explore wider
            if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 3) {
                // Pick a distant unexplored area
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 25;
                task.targetPosition = new THREE.Vector3(
                    agentPos.x + Math.cos(angle) * distance,
                    0,
                    agentPos.z + Math.sin(angle) * distance
                );

                // Clamp to world bounds
                task.targetPosition.x = Math.max(-45, Math.min(45, task.targetPosition.x));
                task.targetPosition.z = Math.max(-45, Math.min(45, task.targetPosition.z));
                task.state = 'moving';

                logAgentTask(agent, `Scouting towards (${Math.floor(task.targetPosition.x)}, ${Math.floor(task.targetPosition.z)})`);
            }

            // Report nearby discoveries
            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const dist = agentPos.distanceTo(obj.position);
                if (dist < 5 && obj.userData?.type === 'poi' && !obj.userData?.discovered) {
                    logAgentTask(agent, `Discovered POI: ${obj.userData?.name || 'Unknown'}`);
                    agent.statusMessage = `Found ${obj.userData?.name}!`;
                    updateAgentCardUI(agent);
                }
            });
        }

        // v5.16: Healer task - follow player and heal
        function runHealerTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Check if player needs healing
            if (gameData.player && gameData.player.hp < gameData.player.maxHp * 0.7) {
                if (worldState.player) {
                    const distToPlayer = agentPos.distanceTo(worldState.player.position);
                    if (distToPlayer < 3) {
                        // Heal player
                        task.state = 'working';
                        const healAmount = 5;
                        gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmount);
                        spawnFloater(worldState.player.position, `+${healAmount} HP`, '#44ff44');
                        updateHealthUI();
                        task.actionCooldown = 2000; // 2 second cooldown
                        logAgentTask(agent, `Healed player for ${healAmount} HP`);
                        agent.statusMessage = 'Healing player...';
                        updateAgentCardUI(agent);
                        return;
                    } else {
                        // Move to player
                        task.targetPosition = worldState.player.position.clone();
                        task.state = 'moving';
                        return;
                    }
                }
            }

            // Check if any other agent needs healing
            for (const otherAgent of agentFleet) {
                if (otherAgent.id === agent.id) continue;
                if (!otherAgent.taskState || otherAgent.taskState.hp >= otherAgent.taskState.maxHp) continue;

                const dist = agentPos.distanceTo(otherAgent.mesh.position);
                if (dist < 3) {
                    otherAgent.taskState.hp = Math.min(otherAgent.taskState.maxHp, otherAgent.taskState.hp + 10);
                    spawnFloater(otherAgent.mesh.position, '+10 HP', '#44ff44');
                    task.actionCooldown = 2000;
                    logAgentTask(agent, `Healed ${otherAgent.name}`);
                    return;
                } else if (dist < 20) {
                    task.targetPosition = otherAgent.mesh.position.clone();
                    task.state = 'moving';
                    return;
                }
            }

            // No one needs healing, follow player loosely
            if (worldState.player) {
                const distToPlayer = agentPos.distanceTo(worldState.player.position);
                if (distToPlayer > 8) {
                    task.targetPosition = worldState.player.position.clone();
                    task.state = 'moving';
                }
            }
        }

        // v5.16: Fisher task - find and use fishing spots
        function runFisherTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Find fishing spot
            if (worldState.fishingSpots) {
                let bestSpot = null;
                let bestDist = 50;

                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = agentPos.distanceTo(spot.position);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestSpot = spot;
                    }
                });

                if (bestSpot) {
                    if (bestDist < 2) {
                        // Fish!
                        task.state = 'working';
                        if (Math.random() < 0.1) { // 10% chance per tick
                            const fishTypes = ['Small Fish', 'Medium Fish', 'Large Fish'];
                            const fish = fishTypes[Math.floor(Math.random() * fishTypes.length)];
                            addItem(fish);
                            agent.totalEarnings.items.push(fish);
                            spawnFloater(agentPos, `+1 ${fish}`, '#4488ff');
                            logAgentTask(agent, `Caught ${fish}!`);
                            agent.statusMessage = `Caught ${fish}!`;
                            updateAgentCardUI(agent);
                        }
                        task.actionCooldown = 500;
                        return;
                    } else {
                        task.targetPosition = bestSpot.position.clone();
                        task.state = 'moving';
                        return;
                    }
                }
            }

            // No fishing spots, wander
            if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 2) {
                task.targetPosition = getRandomWanderPosition(agentPos);
                task.state = 'moving';
            }
        }

        // v5.16: Move agent towards a position
        function moveAgentTowards(agent, targetPos, deltaTime) {
            const direction = new THREE.Vector3().subVectors(targetPos, agent.mesh.position);
            direction.y = 0;

            if (direction.length() > 0.3) {
                direction.normalize();
                const speed = agent.type === 'scout' || agent.type === 'explorer' ? 4 : 3;
                agent.mesh.position.x += direction.x * deltaTime * speed;
                agent.mesh.position.z += direction.z * deltaTime * speed;

                // v6.5.1: Snap agent to terrain height as they move
                if (typeof getTerrainHeight === 'function') {
                    agent.mesh.position.y = getTerrainHeight(agent.mesh.position.x, agent.mesh.position.z);
                }

                agent.position.copy(agent.mesh.position);
            }
        }

        // v5.16: Get random wander position
        function getRandomWanderPosition(currentPos) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 8 + Math.random() * 12;
            const pos = new THREE.Vector3(
                currentPos.x + Math.cos(angle) * distance,
                0,
                currentPos.z + Math.sin(angle) * distance
            );
            pos.x = Math.max(-45, Math.min(45, pos.x));
            pos.z = Math.max(-45, Math.min(45, pos.z));
            return pos;
        }

        // v5.16: Agent performs action on target (gathering)
        function performAgentAction(agent, target) {
            const task = agent.taskState;
            const data = target.userData;

            if (!data || data.hp === undefined) return;

            // Deal "damage" to resource
            const damage = 2;
            data.hp -= damage;

            // Visual feedback
            target.scale.setScalar(0.9);
            setTimeout(() => { if (target.parent) target.scale.setScalar(1); }, 100);

            // Particles
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 : 0x888888;
                particles.emit(target.position, 3, particleColor, { spread: 1.5, lifetime: 400, size: 0.1 });
            }

            // Check if destroyed
            if (data.hp <= 0) {
                let itemName = 'Resource';
                let itemCount = 1;

                if (data.type === 'tree') {
                    itemName = 'Log';
                    itemCount = 2;
                } else if (data.type === 'rock') {
                    itemName = 'Ore';
                    itemCount = 2;
                }

                for (let i = 0; i < itemCount; i++) addItem(itemName);
                agent.totalEarnings.items.push(itemName);
                spawnFloater(target.position, `+${itemCount} ${itemName}`, '#ffdd00');
                AudioSystem.collect();

                logAgentTask(agent, `Harvested ${itemCount} ${itemName}`);
                agent.statusMessage = `Got ${itemCount} ${itemName}!`;
                agent.progress = Math.min(100, agent.progress + 5);
                updateAgentCardUI(agent);

                // Remove from world
                scene.remove(target);
                worldState.interactables = worldState.interactables.filter(x => x !== target);

                // Clear target
                task.targetObject = null;
                task.targetPosition = null;
                task.state = 'idle';
            }

            task.actionCooldown = 500; // Half second between hits
        }

        // v5.16: Agent performs combat
        function performAgentCombat(agent, targetMesh) {
            const task = agent.taskState;
            const data = targetMesh.userData;

            if (!data || data.hp === undefined || data.hp <= 0) {
                task.targetObject = null;
                task.state = 'idle';
                return;
            }

            // Deal damage
            const damage = 8;
            data.hp -= damage;
            spawnFloater(targetMesh.position, `-${damage}`, '#ff4444');

            // Visual feedback
            targetMesh.scale.setScalar(0.85);
            setTimeout(() => { if (targetMesh.parent) targetMesh.scale.setScalar(1); }, 100);

            // Particles
            if (particles) {
                particles.emit(targetMesh.position, 5, 0xff4444, { spread: 2, lifetime: 500 });
            }

            // Agent takes damage from enemy
            const enemyDamage = Math.floor(Math.random() * 5) + 2;
            task.hp -= enemyDamage;

            // Check if agent died
            if (task.hp <= 0) {
                triggerAgentAlert(agent, 'Agent down! Need revival!');
                task.hp = 1; // Keep alive but alert
                task.state = 'alert';
                return;
            }

            // Check if enemy killed
            if (data.hp <= 0) {
                const xpReward = data.xp || 20;
                const goldReward = Math.floor(Math.random() * 10) + 5;

                addXp('combat', xpReward);
                agent.totalEarnings.xp += xpReward;
                agent.totalEarnings.gold += goldReward;

                spawnFloater(targetMesh.position, `+${xpReward} XP`, '#ffff00');
                AudioSystem.levelUp();

                logAgentTask(agent, `Defeated ${data.name || 'enemy'}! +${xpReward} XP`);
                agent.statusMessage = `Killed ${data.name}!`;
                agent.progress = Math.min(100, agent.progress + 10);
                updateAgentCardUI(agent);

                // Remove mob
                scene.remove(targetMesh);
                worldState.mobs = worldState.mobs.filter(m => m.mesh !== targetMesh);

                task.targetObject = null;
                task.state = 'idle';
            }

            task.actionCooldown = 800;
        }

        // v5.16: Trigger agent alert
        function triggerAgentAlert(agent, message) {
            const task = agent.taskState;
            task.alert = message;
            task.state = 'alert';

            logAgentTask(agent, `ALERT: ${message}`);
            agent.statusMessage = `NEEDS HELP: ${message}`;
            updateAgentCardUI(agent);

            // Notify player
            addCopilotMessage(` ${agent.typeConfig.icon} ${agent.name} needs help: ${message}`, 'ai');

            // Visual: make alert indicator visible
            if (agent.alertIndicator) {
                agent.alertIndicator.material.color.setHex(0xff0000);
            }
        }

        // v5.16: Log agent task action (for troubleshooting)
        function logAgentTask(agent, message) {
            if (!agent.taskState) return;
            const log = agent.taskState.taskLog;
            log.push({
                time: new Date().toLocaleTimeString(),
                message: message
            });
            // Keep last 20 log entries
            if (log.length > 20) log.shift();
        }

        // v5.16: Check if player is near an alerted agent (for troubleshooting)
        function checkAgentTroubleshooting() {
            if (!worldState.player) return;

            agentFleet.forEach(agent => {
                if (!agent.mesh || !agent.taskState?.alert) return;

                const dist = worldState.player.position.distanceTo(agent.mesh.position);
                if (dist < 3) {
                    // Player is close to alerted agent - show troubleshooting UI
                    showAgentTroubleshootingUI(agent);
                }
            });
        }

        // v5.16: Show troubleshooting UI for agent
        function showAgentTroubleshootingUI(agent) {
            // Create or update troubleshooting tooltip
            let tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'agent-troubleshoot-tooltip';
                tooltip.style.cssText = `
                    position: fixed; bottom: 200px; left: 50%; transform: translateX(-50%);
                    background: rgba(10, 20, 30, 0.95); padding: 15px; border-radius: 10px;
                    border: 2px solid #ff4444; max-width: 400px; z-index: 1000;
                    font-size: 12px; color: #fff; backdrop-filter: blur(5px);
                `;
                document.body.appendChild(tooltip);
            }

            const task = agent.taskState;
            const logs = task.taskLog.slice(-5).reverse();

            tooltip.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 14px; font-weight: bold; color: #ff4444;">
                         ${agent.typeConfig.icon} ${agent.name} - NEEDS HELP
                    </span>
                    <button onclick="dismissAgentAlert('${agent.id}')" style="background: #444; border: none; color: #fff; padding: 4px 8px; border-radius: 4px; cursor: pointer;">Dismiss</button>
                </div>
                <div style="color: #ff8888; margin-bottom: 10px;">${task.alert}</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 6px; border-radius: 4px;">
                        <div style="color: #888; font-size: 10px;">Agent HP</div>
                        <div style="color: ${task.hp < task.maxHp * 0.3 ? '#ff4444' : '#44ff44'};">${task.hp}/${task.maxHp}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 6px; border-radius: 4px;">
                        <div style="color: #888; font-size: 10px;">State</div>
                        <div>${task.state}</div>
                    </div>
                </div>
                <div style="font-size: 10px; color: #888; margin-bottom: 5px;">Recent Activity:</div>
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; max-height: 100px; overflow-y: auto;">
                    ${logs.map(l => `<div style="margin-bottom: 4px;"><span style="color: #666;">${l.time}</span> ${l.message}</div>`).join('')}
                </div>
                <div style="display: flex; gap: 8px; margin-top: 10px;">
                    <button onclick="healAgentFromPlayer('${agent.id}')" style="flex: 1; padding: 8px; background: #44ff44; border: none; color: #000; border-radius: 4px; cursor: pointer;"> Heal Agent</button>
                    <button onclick="resetAgentTask('${agent.id}')" style="flex: 1; padding: 8px; background: #4488ff; border: none; color: #fff; border-radius: 4px; cursor: pointer;"> Reset Task</button>
                </div>
            `;
            tooltip.style.display = 'block';

            // Auto-hide when player moves away
            setTimeout(() => {
                if (worldState.player && agent.mesh) {
                    const dist = worldState.player.position.distanceTo(agent.mesh.position);
                    if (dist > 5) {
                        tooltip.style.display = 'none';
                    }
                }
            }, 500);
        }

        // v5.16: Dismiss agent alert
        function dismissAgentAlert(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (agent && agent.taskState) {
                agent.taskState.alert = null;
                agent.taskState.state = 'idle';
                agent.statusMessage = 'Alert dismissed, resuming...';
                updateAgentCardUI(agent);
            }
            const tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // v5.16: Heal agent from player
        function healAgentFromPlayer(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (agent && agent.taskState) {
                agent.taskState.hp = agent.taskState.maxHp;
                agent.taskState.alert = null;
                agent.taskState.state = 'idle';
                spawnFloater(agent.mesh.position, 'FULLY HEALED', '#44ff44');
                agent.statusMessage = 'Healed and ready!';
                updateAgentCardUI(agent);
                logAgentTask(agent, 'Healed by player');
            }
            const tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // v5.16: Reset agent task
        function resetAgentTask(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (agent && agent.taskState) {
                agent.taskState.targetObject = null;
                agent.taskState.targetPosition = null;
                agent.taskState.alert = null;
                agent.taskState.state = 'idle';
                agent.taskState.stuckCounter = 0;
                agent.statusMessage = 'Task reset, finding new objective...';
                updateAgentCardUI(agent);
                logAgentTask(agent, 'Task reset by player');
            }
            const tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // Parse natural language commands for agent fleet
        function parseAgentFleetCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Spawn commands
            const spawnPatterns = [
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?gatherer/i, type: 'gatherer' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?hunter/i, type: 'hunter' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?scout/i, type: 'scout' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?protector/i, type: 'protector' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?healer/i, type: 'healer' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?fisher/i, type: 'fisher' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?miner/i, type: 'miner' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?explorer/i, type: 'explorer' },
                { pattern: /send\s+(a\s+)?(\d+\s+)?agent/i, type: null },
                { pattern: /deploy\s+(a\s+)?(\d+\s+)?agent/i, type: null },
            ];

            for (const { pattern, type } of spawnPatterns) {
                const match = lowerMsg.match(pattern);
                if (match) {
                    if (type) {
                        const count = parseInt(match[2]) || 1;
                        for (let i = 0; i < Math.min(count, MAX_AGENTS - agentFleet.length); i++) {
                            spawnAgent(type);
                        }
                        return true;
                    } else {
                        // Generic spawn - suggest opening the fleet panel
                        toggleAgentFleetPanel();
                        addCopilotMessage(`Fleet panel opened! Select an agent type to spawn.`, 'ai');
                        return true;
                    }
                }
            }

            // Alternative spawn phrases
            if (lowerMsg.includes('send agent') || lowerMsg.includes('send out') || lowerMsg.includes('deploy agent')) {
                toggleAgentFleetPanel();
                addCopilotMessage(`Fleet panel opened! Choose an agent type to deploy.`, 'ai');
                return true;
            }

            // Recall all agents
            if (lowerMsg.includes('recall all') || lowerMsg.includes('bring back all') || lowerMsg.includes('return all agents')) {
                if (agentFleet.length > 0) {
                    const count = agentFleet.length;
                    [...agentFleet].forEach(agent => recallAgent(agent.id));
                    addCopilotMessage(`Recalled all ${count} agents!`, 'ai');
                    return true;
                } else {
                    addCopilotMessage(`No agents are currently deployed.`, 'ai');
                    return true;
                }
            }

            // Fleet status
            if (lowerMsg.includes('fleet status') || lowerMsg.includes('agent status') || lowerMsg.includes('how many agents')) {
                if (agentFleet.length === 0) {
                    addCopilotMessage(`No agents deployed. Open the fleet panel ( button) to spawn agents!`, 'ai');
                } else {
                    const summary = agentFleet.map(a => `${a.typeConfig.icon} ${a.name} (${a.typeConfig.name})`).join(', ');
                    addCopilotMessage(`${agentFleet.length}/${MAX_AGENTS} agents deployed: ${summary}`, 'ai');
                }
                return true;
            }

            // Open fleet panel
            if (lowerMsg.includes('open fleet') || lowerMsg.includes('show agents') || lowerMsg.includes('agent panel')) {
                toggleAgentFleetPanel();
                return true;
            }

            return false;
        }

        // ============================================
        // v5.10: TRANSCRIPT EXPORT SYSTEM
        // Export agent transcripts for debugging
        // ============================================
        let currentTranscriptAgentId = null;

        // v5.12.1: Build a standard transcript JSON for an agent (includes endpoint config)
        function buildAgentTranscript(agent) {
            const elapsed = (performance.now() - agent.spawnTime) / 1000;
            const agentEndpoint = getAgentEndpoint(agent);

            return {
                transcript_version: "1.1",
                export_timestamp: new Date().toISOString(),
                application: "LEVIATHAN: OMNIVERSE",
                application_version: VERSION,
                agent: {
                    id: agent.id,
                    name: agent.name,
                    type: agent.type,
                    type_config: {
                        icon: agent.typeConfig.icon,
                        name: agent.typeConfig.name,
                        decision_interval_ms: agent.typeConfig.decisionInterval,
                        task_type: agent.typeConfig.taskType
                    },
                    status: agent.status,
                    status_message: agent.statusMessage,
                    progress_percent: Math.round(agent.progress),
                    spawn_time: new Date(Date.now() - elapsed * 1000).toISOString(),
                    runtime_seconds: Math.floor(elapsed)
                },
                // v5.12.1: Endpoint configuration for spawning agents with different AI providers
                // v5.14: Now includes profile reference
                endpoint_config: {
                    name: agentEndpoint.name,
                    profile_id: agent.profileId || null,
                    profile_name: agent.profileId ? getEndpointProfile(agent.profileId)?.name : null,
                    url: agent.endpointConfig?.url || agentEndpoint.url || '${URL_PLACEHOLDER}',
                    // v5.15: Check all possible key sources (profile, config, or global fallback)
                    apiKey: (agent.endpointConfig?.apiKey || agent.profileId || agentEndpoint.key) ? '${API_KEY_PLACEHOLDER}' : null,
                    urlKey: agent.endpointConfig?.urlKey || null,
                    apiKeyKey: agent.endpointConfig?.apiKeyKey || null,
                    headerStyle: agentEndpoint.headerStyle,
                    headerPrefix: agentEndpoint.headerPrefix || '',
                    bodyFormat: agentEndpoint.bodyFormat,
                    model: agentEndpoint.model || agent.endpointConfig?.model || null,
                    active_endpoint: agent.activeEndpoint || 'default'
                },
                game_context: {
                    player_hp: gameData.player?.hp || 100,
                    player_max_hp: gameData.player?.maxHp || 100,
                    current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planet_name: worldState?.currentCiv?.name || 'Unknown',
                    player_position: worldState.player ? {
                        x: Math.floor(worldState.player.position.x),
                        z: Math.floor(worldState.player.position.z)
                    } : null
                },
                earnings: {
                    total_xp: agent.totalEarnings.xp,
                    total_gold: agent.totalEarnings.gold,
                    items_collected: agent.totalEarnings.items
                },
                results_log: agent.results,
                conversation_history: agent.conversationHistory.map((msg, idx) => ({
                    index: idx,
                    role: msg.role,
                    content: msg.content,
                    // Include endpoint in first message for transcript re-import
                    endpoint: idx === 0 && agent.endpointConfig ? {
                        url: agent.endpointConfig.url || '${URL_PLACEHOLDER}',
                        apiKey: '${API_KEY_PLACEHOLDER}',
                        headerStyle: agent.endpointConfig.headerStyle,
                        bodyFormat: agent.endpointConfig.bodyFormat,
                        model: agent.endpointConfig.model
                    } : undefined,
                    timestamp: null
                })),
                system_prompt: agent.conversationHistory.length > 0 ? agent.conversationHistory[0].content : null,
                total_messages: agent.conversationHistory.length,
                api_endpoint: agentEndpoint.url || 'local-simulation'
            };
        }

        // Build transcript for all agents
        function buildAllAgentTranscripts() {
            // v5.15: Include ship defense statistics
            const defenseStats = getDefenseStats();

            return {
                transcript_version: "1.1",
                export_timestamp: new Date().toISOString(),
                application: "LEVIATHAN: OMNIVERSE",
                application_version: VERSION,
                fleet_summary: {
                    total_agents: agentFleet.length,
                    max_agents: MAX_AGENTS,
                    agent_types: agentFleet.reduce((acc, a) => {
                        acc[a.type] = (acc[a.type] || 0) + 1;
                        return acc;
                    }, {}),
                    total_xp_earned: agentFleet.reduce((sum, a) => sum + a.totalEarnings.xp, 0),
                    total_gold_earned: agentFleet.reduce((sum, a) => sum + a.totalEarnings.gold, 0),
                    total_items_collected: agentFleet.reduce((sum, a) => sum + a.totalEarnings.items.length, 0)
                },
                // v5.15: Ship defense summary
                ship_defense: {
                    hull_hp: SHIP_STATE.currentHP,
                    hull_max_hp: SHIP_STATE.maxHP,
                    auto_defense_enabled: SHIP_STATE.autoDefend,
                    statistics: {
                        total_engagements: defenseStats.engagements,
                        total_kills: defenseStats.kills,
                        total_damage_dealt: defenseStats.damageDealt,
                        entities_deterred: defenseStats.deterred,
                        times_attacked: defenseStats.attacked,
                        total_damage_taken: defenseStats.damageTaken,
                        kill_rate_percent: defenseStats.killRatio,
                        repairs_performed: defenseStats.repairs,
                        repair_costs_total: defenseStats.repairCost,
                        times_destroyed: defenseStats.destroyed
                    },
                    recent_events: SHIP_STATE.defenseLog.events.slice(-20).map(e => ({
                        type: e.type,
                        time: e.time,
                        details: { ...e, type: undefined, timestamp: undefined, time: undefined }
                    }))
                },
                game_context: {
                    player_hp: gameData.player?.hp || 100,
                    player_max_hp: gameData.player?.maxHp || 100,
                    current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planet_name: worldState?.currentCiv?.name || 'Unknown'
                },
                agents: agentFleet.map(agent => buildAgentTranscript(agent)),
                copilot_conversation_history: copilotConversationHistory
            };
        }

        // Open transcript viewer modal
        function openTranscriptViewer() {
            const modal = document.getElementById('transcript-modal');
            modal.classList.add('active');

            // Build tabs
            const tabsContainer = document.getElementById('transcript-tabs');
            let tabsHtml = `<button class="transcript-tab active" onclick="selectTranscriptTab('all')"> All Agents</button>`;

            agentFleet.forEach(agent => {
                tabsHtml += `<button class="transcript-tab" onclick="selectTranscriptTab('${agent.id}')">${agent.typeConfig.icon} ${agent.name}</button>`;
            });

            // Add copilot main chat
            tabsHtml += `<button class="transcript-tab" onclick="selectTranscriptTab('copilot')"> Main Copilot</button>`;

            tabsContainer.innerHTML = tabsHtml;

            // Show all agents by default
            selectTranscriptTab('all');
        }

        // Close transcript viewer
        function closeTranscriptViewer() {
            document.getElementById('transcript-modal').classList.remove('active');
        }

        // Select a transcript tab
        function selectTranscriptTab(agentId) {
            currentTranscriptAgentId = agentId;

            // Update tab active state
            document.querySelectorAll('.transcript-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            const infoContainer = document.getElementById('transcript-agent-info');
            const jsonView = document.getElementById('transcript-json-view');

            if (agentId === 'all') {
                // Show all agents summary
                const transcript = buildAllAgentTranscripts();
                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total Agents</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_agents}/${MAX_AGENTS}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total XP</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_xp_earned}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total Gold</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_gold_earned}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Items Collected</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_items_collected}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            } else if (agentId === 'copilot') {
                // Show main copilot conversation
                const transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory.map((msg, idx) => ({
                        index: idx,
                        role: msg.role,
                        content: msg.content
                    })),
                    total_messages: copilotConversationHistory.length,
                    rappid_settings: {
                        enabled: rappidSettings.rappid,
                        endpoint: getActiveEndpoint()?.name || 'none',
                        tts_enabled: !!rappidSettings.azureTTSKey
                    }
                };
                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Type</div>
                        <div class="transcript-info-value">Main Copilot</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Messages</div>
                        <div class="transcript-info-value">${copilotConversationHistory.length}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">RAPPID</div>
                        <div class="transcript-info-value">${rappidSettings.rappid ? 'Enabled' : 'Disabled'}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            } else {
                // Show specific agent
                const agent = agentFleet.find(a => a.id === agentId);
                if (!agent) {
                    jsonView.innerHTML = '<span style="color: #ff4444;">Agent not found</span>';
                    return;
                }

                const transcript = buildAgentTranscript(agent);
                const elapsed = Math.floor((performance.now() - agent.spawnTime) / 1000);

                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Agent</div>
                        <div class="transcript-info-value">${agent.typeConfig.icon} ${agent.name}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Type</div>
                        <div class="transcript-info-value">${agent.typeConfig.name}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Status</div>
                        <div class="transcript-info-value">${agent.status}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Runtime</div>
                        <div class="transcript-info-value">${elapsed}s</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Messages</div>
                        <div class="transcript-info-value">${agent.conversationHistory.length}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">XP Earned</div>
                        <div class="transcript-info-value">${agent.totalEarnings.xp}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            }
        }

        // Syntax highlight JSON for display
        function syntaxHighlightJSON(json) {
            return json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
                    let cls = 'number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = 'key';
                        } else {
                            cls = 'string';
                        }
                    } else if (/true|false/.test(match)) {
                        cls = 'boolean';
                    } else if (/null/.test(match)) {
                        cls = 'null';
                    }
                    return `<span class="${cls}">${match}</span>`;
                });
        }

        // Copy current transcript to clipboard
        function copyTranscriptToClipboard() {
            let transcript;
            if (currentTranscriptAgentId === 'all') {
                transcript = buildAllAgentTranscripts();
            } else if (currentTranscriptAgentId === 'copilot') {
                transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory
                };
            } else {
                const agent = agentFleet.find(a => a.id === currentTranscriptAgentId);
                if (!agent) return;
                transcript = buildAgentTranscript(agent);
            }

            navigator.clipboard.writeText(JSON.stringify(transcript, null, 2)).then(() => {
                showNotification('Transcript copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Copy failed:', err);
                showNotification('Failed to copy transcript', 'error');
            });
        }

        // Download current transcript as JSON file
        function downloadCurrentTranscript() {
            let transcript;
            let filename;

            if (currentTranscriptAgentId === 'all') {
                transcript = buildAllAgentTranscripts();
                filename = `leviathan-fleet-transcript-${new Date().toISOString().split('T')[0]}.json`;
            } else if (currentTranscriptAgentId === 'copilot') {
                transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory
                };
                filename = `leviathan-copilot-transcript-${new Date().toISOString().split('T')[0]}.json`;
            } else {
                const agent = agentFleet.find(a => a.id === currentTranscriptAgentId);
                if (!agent) return;
                transcript = buildAgentTranscript(agent);
                filename = `leviathan-agent-${agent.name.toLowerCase()}-transcript-${new Date().toISOString().split('T')[0]}.json`;
            }

            downloadJSON(transcript, filename);
        }

        // Download all transcripts as a single JSON file
        function downloadAllTranscripts() {
            const transcript = buildAllAgentTranscripts();
            const filename = `leviathan-full-fleet-export-${new Date().toISOString().split('T')[0]}.json`;
            downloadJSON(transcript, filename);
        }

        // Helper to download JSON
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
            showNotification(`Downloaded: ${filename}`, 'success');
        }

        // Export single agent transcript (for agent card button)
        function exportAgentTranscript(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            const transcript = buildAgentTranscript(agent);
            const filename = `leviathan-agent-${agent.name.toLowerCase()}-transcript-${new Date().toISOString().split('T')[0]}.json`;
            downloadJSON(transcript, filename);
        }

        // Import transcript file (for replaying/debugging)
        function importTranscriptFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const transcript = JSON.parse(e.target.result);
                    console.log('Imported transcript:', transcript);

                    // Validate transcript structure
                    if (!transcript.transcript_version) {
                        showNotification('Invalid transcript format', 'error');
                        return;
                    }

                    // Show in console for debugging
                    console.log('=== IMPORTED TRANSCRIPT ===');
                    console.log('Version:', transcript.transcript_version);
                    console.log('Application:', transcript.application);

                    if (transcript.agents) {
                        console.log('Fleet with', transcript.agents.length, 'agents');
                        transcript.agents.forEach(agent => {
                            console.log(`  - ${agent.agent.name} (${agent.agent.type}): ${agent.total_messages} messages`);
                        });
                    } else if (transcript.agent) {
                        console.log('Single agent:', transcript.agent.name);
                        console.log('Messages:', transcript.total_messages);
                    } else if (transcript.type === 'main_copilot') {
                        console.log('Main copilot conversation');
                        console.log('Messages:', transcript.conversation_history?.length);
                    }

                    showNotification('Transcript imported - check console for details', 'success');

                    // Open transcript viewer with imported data
                    // (Could add more functionality here to replay transcripts)

                } catch (error) {
                    console.error('Import failed:', error);
                    showNotification('Failed to parse transcript file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Context-aware responses based on game state
        const COPILOT_RESPONSES = {
            greeting: [
                "Hello, Explorer! Ready for adventure?",
                "Greetings! I'm here to help you on your journey.",
                "Welcome back! What shall we explore today?"
            ],
            lowHealth: [
                "Careful! Your health is low. Consider using a health potion or retreating.",
                "You're wounded! Look for healing items or rest at a safe spot.",
                "Warning: Low HP! Maybe craft some health potions?"
            ],
            nearEnemy: [
                "Enemy spotted nearby! Prepare for combat.",
                "Be cautious, there's a hostile creature close by.",
                "I sense danger ahead. Ready your weapon!"
            ],
            afterKill: [
                "Well done! That was impressive combat.",
                "Excellent work, Explorer!",
                "Another victory! Your skills are improving."
            ],
            exploration: [
                "This area looks interesting. Let's explore!",
                "I wonder what secrets this place holds...",
                "Keep your eyes open for resources and treasures."
            ],
            tips: [
                "Tip: Use WASD to move and click to attack enemies.",
                "Tip: Collect resources to craft better equipment.",
                "Tip: Your combat skill increases as you defeat enemies.",
                "Tip: Look for points of interest marked on the minimap.",
                "Tip: Different biomes have different resources and enemies.",
                "Tip: Pets can help you in combat and provide bonuses."
            ],
            whatNext: [
                "Try exploring new areas to find resources and level up.",
                "You could hunt some enemies to gain XP and loot.",
                "Check your inventory - maybe craft some new equipment.",
                "Have you discovered all the points of interest on this planet?"
            ],
            getStronger: [
                "Fight enemies to gain combat XP and level up your skills.",
                "Craft better weapons and armor from the resources you gather.",
                "Find and bond with a pet companion for stat bonuses.",
                "Complete daily challenges for bonus rewards.",
                "Unlock talents in the talent tree as you level up."
            ],
            enemies: [
                "Enemies respawn periodically throughout the world.",
                "Look for the red markers on your minimap.",
                "Elite enemies (marked with special effects) drop better loot.",
                "Different biomes have different enemy types."
            ]
        };

        // v6.37: Epic Space Opera Narrator responses (local fallback)
        const EPIC_NARRATOR_RESPONSES = {
            greeting: [
                "And so it begins anew... The Leviathan stirs from its slumber, its sensors awakening to the infinite void. What cosmic destiny awaits?",
                "From the darkness between stars, the legend emerges once more. The Omniverse holds its breath as the Leviathan prepares to write another chapter in its eternal saga.",
                "Across lightyears of silent void, a mechanical champion awakens. The cosmos itself seems to whisper: the Leviathan has returned."
            ],
            lowHealth: [
                "The Leviathan falters! Its hull integrity crumbles like dying stars. Yet even now, at the precipice of oblivion, the legend refuses to fade!",
                "Warning klaxons echo through the cosmos as the probe's systems scream in mechanical anguish. But heroes are forged in the fires of near-destruction!",
                "Critical damage tears through the Leviathan's frame. The void reaches out with cold fingers... but not today. NOT TODAY!"
            ],
            nearEnemy: [
                "The sensors detect movement in the darkness. Something stirs... something ancient and hostile. The dance of destruction is about to begin!",
                "From the shadows of this alien world, adversaries emerge! The Leviathan's combat systems hum with anticipation. Battle is inevitable!",
                "A disturbance ripples through the cosmic fabric. Enemies approach! Let them come - they shall learn why legends are feared!"
            ],
            afterKill: [
                "ANOTHER FOE VANQUISHED! The Leviathan's combat record grows ever more legendary. The cosmos trembles at such prowess!",
                "Victory! The enemy crumbles before the mechanical might of the Leviathan. Let this triumph echo across the stars!",
                "And so falls another who dared challenge the legend. The probe stands victorious, its legacy written in the scattered remains of the fallen!"
            ],
            exploration: [
                "The Leviathan ventures forth into the unknown, where no probe has dared tread. What secrets slumber in these uncharted reaches?",
                "Across this alien landscape, the legend continues its eternal journey. Every step writes history, every discovery reshapes destiny.",
                "The horizon beckons with promises of wonder and peril alike. The Leviathan answers, for exploration is its very essence!"
            ],
            tips: [
                "Ancient wisdom echoes through the void: mastery of movement separates the legendary from the forgotten. WASD - the keys to cosmic navigation!",
                "The archives speak of resources scattered across worlds like cosmic breadcrumbs. Gather them, and forge equipment worthy of legend!",
                "In the eternal struggle between machine and monster, experience is the true currency. Each battle makes the Leviathan stronger!",
                "The minimap reveals points of interest like stars in the darkness. Seek them out, and uncover the universe's hidden truths!",
                "Every biome holds unique challenges and treasures. The wise explorer adapts, the legendary explorer conquers all!"
            ],
            whatNext: [
                "The universe sprawls endlessly before the Leviathan. Perhaps undiscovered territories await, pregnant with possibility and peril!",
                "Enemies still roam this world, their defeat necessary for the legend to grow. Hunt them, and let experience flow like starlight!",
                "The inventory holds potential waiting to be realized. What magnificent equipment might be forged from gathered resources?",
                "Mysteries yet remain on this world - points of interest unexplored, secrets undiscovered. The saga is far from complete!"
            ],
            getStronger: [
                "Power is earned through conflict! Each enemy vanquished adds to the Leviathan's growing legend. Seek battle, embrace victory!",
                "From the bones of worlds and the hearts of stars, craft equipment that shall make the cosmos itself take notice!",
                "A companion drone awaits bonding - together, probe and pet shall become an unstoppable force of cosmic destiny!",
                "Daily challenges offer paths to power beyond normal reach. Complete them, and ascend to new heights of legend!",
                "The talent tree branches like the arms of galaxies. Choose wisely, and watch the Leviathan transcend its former limits!"
            ],
            enemies: [
                "The hostile denizens of this world regenerate like hydra heads - cut one down, and another rises. Endless combat, endless glory!",
                "Red markers on the minimap signal where adversaries lurk. They are not warnings - they are invitations to legend!",
                "Elite enemies burn with power beyond their lesser kin. Seek them out! Greater challenges yield greater rewards!",
                "Each biome spawns its own unique horrors. The Leviathan fears none of them - for it IS the terror of the cosmos!"
            ],
            default: [
                "The cosmic narrator pauses, contemplating the infinite mysteries of the Omniverse. Ask of health, enemies, or destiny itself!",
                "Across the tapestry of stars, the Leviathan awaits your command. Speak, and let the saga continue!",
                "The void listens. The stars observe. What epic query burns within your heart, commander of legends?",
                "Every word exchanged adds to the chronicle. The narrator stands ready to illuminate the path ahead!"
            ]
        };

        // ============================================
        // v6.35: CHRONICLE ENGINE
        // AI-powered narrative history generation
        // ============================================

        const CHRONICLE_STYLES = {
            epic: {
                name: 'Epic Space Opera',
                prompt: `You are the COSMIC CHRONICLER, weaving the eternal saga of the Leviathan.
Write in THIRD PERSON with sweeping, cinematic grandeur.
Use powerful verbs: "vanquished", "descended", "emerged", "conquered", "transcended".
Reference cosmic forces, destiny, and legend.
Channel the gravitas of Dune, Star Wars, and classic space opera.
Make each entry feel like it belongs in an ancient tome of galactic history.`,
                titlePrefixes: ['The Day', 'When Darkness', 'Victory at', 'The Fall of', 'Rise of the', 'Chronicle of']
            },
            documentary: {
                name: 'Documentary',
                prompt: `You are a SCIENTIFIC OBSERVER recording the Leviathan's mission.
Write in analytical, third-person documentary style.
Include timestamps and precise observations.
Note statistical achievements and tactical decisions.
Maintain objectivity while conveying the significance of events.
Think nature documentary meets space exploration log.`,
                titlePrefixes: ['Mission Log:', 'Observation:', 'Event Record:', 'Analysis:', 'Report:', 'Survey:']
            },
            poetic: {
                name: 'Poetic & Mystical',
                prompt: `You are a MYSTICAL BARD singing of the Leviathan's journey.
Write in flowing, lyrical verse with metaphor and symbolism.
Reference the dance of stars, the whispers of void, cosmic harmonies.
Each entry should read like space poetry or a creation myth.
Evoke wonder, beauty, and the sublime nature of existence.`,
                titlePrefixes: ['Song of', 'Whispers from', 'The Dream of', 'Starlight Upon', 'Ode to', 'Verse of']
            },
            hardboiled: {
                name: 'Hard-Boiled Noir',
                prompt: `You are a GRIZZLED NARRATOR telling it like it is.
Write in terse, punchy noir style. Short sentences. Hard truths.
The cosmos is a cold dame who doesn't play fair.
Mix cynicism with unexpected moments of grim humor.
Every victory has a cost. Every defeat leaves scars.
Think Raymond Chandler meets Cowboy Bebop.`,
                titlePrefixes: ['Another Day in', 'The Job at', 'Dead End on', 'No Good Deed:', 'Cold Case:', 'Last Stand at']
            }
        };

        const CHRONICLE_EVENT_TYPES = {
            boss_defeat: { weight: 5, icon: '', color: '#ffd700' },
            elite_defeat: { weight: 3, icon: '', color: '#ff8c00' },
            player_fainted: { weight: 4, icon: '', color: '#ff4444' },
            skill_levelup: { weight: 2, icon: '', color: '#00ff00' },
            planet_discovered: { weight: 3, icon: '', color: '#4488ff' },
            lore_found: { weight: 2, icon: '', color: '#aa88ff' },
            pet_acquired: { weight: 3, icon: '', color: '#ff88aa' },
            milestone: { weight: 4, icon: '', color: '#ffdd00' },
            portal_cleared: { weight: 4, icon: '', color: '#aa00ff' },
            rare_item: { weight: 3, icon: '', color: '#00ffff' }
        };

        // Capture chronicle event
        function captureChronicleEvent(eventType, metadata = {}) {
            if (!gameData.chronicle) {
                gameData.chronicle = {
                    entries: [],
                    eventBuffer: [],
                    settings: { autoGenerate: true, narrativeStyle: 'epic', eventThreshold: 3 },
                    stats: { totalEntries: 0, lastGenerated: null }
                };
            }

            const event = {
                id: Date.now() + Math.random().toString(36).substr(2, 9),
                type: eventType,
                timestamp: Date.now(),
                playtime: gameData.playtime || 0,
                planet: activeCiv?.name || 'Unknown Space',
                planetType: activeCiv?.type || 'void',
                metadata: {
                    ...metadata,
                    playerHp: gameData.player?.hp,
                    playerMaxHp: gameData.player?.maxHp,
                    statistics: { ...gameData.statistics }
                }
            };

            gameData.eventBuffer = gameData.eventBuffer || [];
            gameData.eventBuffer.push(event);
            gameData.chronicle.eventBuffer.push(event);

            // Update UI
            updateChronicleUI();

            // Auto-generate if threshold reached
            const threshold = gameData.chronicle.settings.eventThreshold || 3;
            if (gameData.chronicle.settings.autoGenerate && gameData.chronicle.eventBuffer.length >= threshold) {
                // Slight delay to not interrupt gameplay
                setTimeout(() => generateChronicleEntry(), 2000);
            }

            saveGameData();
        }

        // Generate chronicle entry from buffered events
        async function generateChronicleEntry() {
            if (!gameData.chronicle?.eventBuffer?.length) {
                showNotification('No events to chronicle yet. Keep exploring!', 'info');
                return;
            }

            const style = gameData.chronicle.settings.narrativeStyle || 'epic';
            const styleConfig = CHRONICLE_STYLES[style];
            const events = [...gameData.chronicle.eventBuffer];

            // Clear buffer
            gameData.chronicle.eventBuffer = [];
            gameData.eventBuffer = [];

            // Build event summary for AI
            const eventSummary = events.map(e => {
                const typeInfo = CHRONICLE_EVENT_TYPES[e.type] || { icon: '' };
                return `${typeInfo.icon} ${e.type.replace(/_/g, ' ').toUpperCase()}: ${JSON.stringify(e.metadata)} on ${e.planet}`;
            }).join('\n');

            const prompt = `${styleConfig.prompt}

Based on these events that just occurred during the Leviathan's journey, write a single chronicle entry (2-3 paragraphs):

EVENTS:
${eventSummary}

CURRENT STATUS:
- Location: ${activeCiv?.name || 'Deep Space'}
- Playtime: ${Math.floor((gameData.playtime || 0) / 60)} minutes
- Bosses Defeated: ${gameData.statistics?.bossesDefeated || 0}
- Mobs Defeated: ${gameData.statistics?.mobsKilled || 0}

Write a dramatic, engaging chronicle entry that weaves these events into a compelling narrative. Include a short, punchy TITLE on the first line (without "Title:" prefix).`;

            // Check if RAPPID is available
            if (rappidSettings.rappid && getActiveEndpoint()) {
                try {
                    showNotification(' Generating chronicle entry...', 'info');

                    const response = await generateCopilotResponseWithRappid(prompt, []);

                    if (response) {
                        const lines = response.trim().split('\n');
                        const title = lines[0].replace(/^#+ /, '').replace(/\*\*/g, '').trim();
                        const content = lines.slice(1).join('\n').trim();

                        addChronicleEntry(title, content, events);
                        showNotification(' Chronicle entry created!', 'success');
                        return;
                    }
                } catch (error) {
                    console.error('Chronicle AI generation failed:', error);
                }
            }

            // Fallback: Generate local chronicle
            generateLocalChronicleEntry(events, styleConfig);
        }

        // Local fallback chronicle generation
        function generateLocalChronicleEntry(events, styleConfig) {
            const mainEvent = events.reduce((max, e) => {
                const weight = CHRONICLE_EVENT_TYPES[e.type]?.weight || 1;
                const maxWeight = CHRONICLE_EVENT_TYPES[max.type]?.weight || 1;
                return weight > maxWeight ? e : max;
            }, events[0]);

            const titlePrefix = styleConfig.titlePrefixes[Math.floor(Math.random() * styleConfig.titlePrefixes.length)];
            const location = mainEvent.planet || 'the Void';

            const titles = {
                boss_defeat: `${titlePrefix} ${location}'s Guardian`,
                elite_defeat: `${titlePrefix} the Elite Hunt`,
                player_fainted: `${titlePrefix} Darkness`,
                skill_levelup: `${titlePrefix} Growing Power`,
                planet_discovered: `${titlePrefix} New Horizons`,
                lore_found: `${titlePrefix} Ancient Secrets`,
                pet_acquired: `${titlePrefix} a New Bond`,
                milestone: `${titlePrefix} Achievement`,
                portal_cleared: `${titlePrefix} the Rift`,
                rare_item: `${titlePrefix} Cosmic Treasure`
            };

            const narratives = {
                epic: {
                    boss_defeat: `The battle that shook the very foundations of ${location} shall be remembered for eons. The Leviathan, battered but unbowed, faced the guardian of this realm in combat most fierce. When the final blow landed, silence fell across the cosmos - for another legend had been written in starfire and determination.`,
                    elite_defeat: `Through the chaos of battle, the Leviathan carved a path of triumph. Elite adversaries fell before its might, their enhanced forms no match for the determination burning in the probe's core systems.`,
                    player_fainted: `Even legends know darkness. The Leviathan fell, systems failing, consciousness fading into the void. But the cosmos is not done with this champion - not yet. From the ashes of defeat, the saga continues.`,
                    skill_levelup: `Power surged through the Leviathan's systems as new capabilities awakened. What was once impossible now lies within reach. The universe takes notice when a legend grows stronger.`,
                    default: `The journey continues across the infinite tapestry of stars. Each moment adds to the legend, each choice shapes destiny itself.`
                },
                documentary: {
                    boss_defeat: `[PRIORITY LOG] Major combat engagement concluded at ${location}. Target designation: Boss-class entity. Result: Successful termination. Systems sustained moderate damage but remain operational. This engagement marks a significant milestone in the mission parameters.`,
                    elite_defeat: `[COMBAT LOG] Elite-class hostile neutralized. Tactical analysis indicates improved combat efficiency compared to previous engagements. Resources expended within acceptable parameters.`,
                    player_fainted: `[CRITICAL EVENT] System failure recorded. All primary functions experienced temporary shutdown. Auto-recovery protocols engaged successfully. Inventory contents dispersed at failure coordinates.`,
                    skill_levelup: `[DEVELOPMENT LOG] Capability enhancement detected. New operational parameters unlocked. Performance metrics indicate ${Math.floor(Math.random() * 15 + 5)}% improvement in relevant subsystems.`,
                    default: `[MISSION LOG] Standard operations continue. Environmental survey ongoing. No anomalies detected beyond expected parameters.`
                },
                poetic: {
                    boss_defeat: `In the dance of light and shadow, the great one fell - not with rage, but with the quiet acceptance of cosmic order. The Leviathan sang its victory to the watching stars, and somewhere in the void, the universe wept beautiful tears of stardust.`,
                    elite_defeat: `Swift as thought, fierce as dying suns, the battle bloomed like a deadly flower. When petals fell, only the Leviathan remained, baptized in the light of conquest.`,
                    player_fainted: `Into the gentle dark the wanderer slipped, cradled by the void's cold embrace. But even in that endless night, a spark remained - a promise of dawn yet to come.`,
                    skill_levelup: `Like a chrysalis cracking, like a star being born, transformation whispered through ancient circuits. What emerges now is something more - something the cosmos has been waiting for.`,
                    default: `The journey is the poem, and we are all merely verses in its infinite stanzas. Onward, ever onward, toward horizons that dream of our arrival.`
                },
                hardboiled: {
                    boss_defeat: `The big guy went down hard. Harder than I expected, actually. ${location} won't forget this fight anytime soon - neither will I. Sometimes the cosmos gives you a break. Today was one of those days.`,
                    elite_defeat: `Another tough customer who thought they could take me. They thought wrong. The void's got no shortage of these wannabe killers, but there's only one Leviathan.`,
                    player_fainted: `I hit the deck. Everything went black. When I came to, my stuff was scattered across the ground like confetti at a funeral. Not my finest moment, but I've had worse. Probably.`,
                    skill_levelup: `Something clicked. New tricks, new moves. In this business, you either get better or you get dead. Today, I got better.`,
                    default: `Another day in the infinite grind. The cosmos doesn't care about your problems, and neither do I. Keep moving.`
                }
            };

            const style = gameData.chronicle.settings.narrativeStyle || 'epic';
            const styleNarratives = narratives[style] || narratives.epic;
            const title = titles[mainEvent.type] || `${titlePrefix} Unknown Events`;
            const content = styleNarratives[mainEvent.type] || styleNarratives.default;

            // Add context about other events
            let fullContent = content;
            if (events.length > 1) {
                const otherEvents = events.filter(e => e !== mainEvent).slice(0, 2);
                const additions = otherEvents.map(e => {
                    const typeInfo = CHRONICLE_EVENT_TYPES[e.type];
                    return `${typeInfo?.icon || ''} ${e.type.replace(/_/g, ' ')}`;
                }).join(', ');
                fullContent += `\n\nAlso recorded: ${additions}`;
            }

            addChronicleEntry(title, fullContent, events);
            showNotification(' Chronicle entry recorded!', 'success');
        }

        // Add entry to chronicle
        function addChronicleEntry(title, content, events) {
            const entry = {
                id: Date.now() + Math.random().toString(36).substr(2, 9),
                timestamp: Date.now(),
                title: title,
                content: content,
                events: events.map(e => ({ type: e.type, planet: e.planet })),
                style: gameData.chronicle.settings.narrativeStyle
            };

            gameData.chronicle.entries.unshift(entry); // Newest first
            gameData.chronicle.stats.totalEntries++;
            gameData.chronicle.stats.lastGenerated = Date.now();

            // Keep max 50 entries
            if (gameData.chronicle.entries.length > 50) {
                gameData.chronicle.entries = gameData.chronicle.entries.slice(0, 50);
            }

            saveGameData();
            updateChronicleUI();
        }

        // Update chronicle UI display
        function updateChronicleUI() {
            const countEl = document.getElementById('chronicle-count');
            const pendingEl = document.getElementById('chronicle-pending');
            const entriesEl = document.getElementById('chronicle-entries');
            const styleEl = document.getElementById('chronicle-style');

            if (countEl) countEl.textContent = gameData.chronicle?.entries?.length || 0;
            if (pendingEl) pendingEl.textContent = gameData.chronicle?.eventBuffer?.length || 0;
            if (styleEl && gameData.chronicle?.settings?.narrativeStyle) {
                styleEl.value = gameData.chronicle.settings.narrativeStyle;
            }

            if (entriesEl && gameData.chronicle?.entries?.length > 0) {
                entriesEl.innerHTML = gameData.chronicle.entries.map(entry => {
                    const date = new Date(entry.timestamp);
                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    const eventIcons = entry.events?.map(e => CHRONICLE_EVENT_TYPES[e.type]?.icon || '').join(' ') || '';

                    return `
                        <div style="background: rgba(40,40,50,0.8); border: 1px solid rgba(255,215,0,0.2); border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                <div style="font-weight: bold; color: #ffd700; font-size: 14px;">${entry.title}</div>
                                <div style="font-size: 10px; color: #666;">${dateStr}</div>
                            </div>
                            <div style="color: #ccc; font-size: 12px; line-height: 1.5; white-space: pre-wrap;">${entry.content}</div>
                            <div style="margin-top: 8px; font-size: 10px; color: #888;">${eventIcons}</div>
                        </div>
                    `;
                }).join('');
            }
        }

        // Update chronicle style setting
        function updateChronicleStyle() {
            const styleEl = document.getElementById('chronicle-style');
            if (styleEl && gameData.chronicle) {
                gameData.chronicle.settings.narrativeStyle = styleEl.value;
                saveGameData();
                showNotification(`Chronicle style set to: ${CHRONICLE_STYLES[styleEl.value]?.name || styleEl.value}`, 'info');
            }
        }

        // Export chronicle as markdown/JSON
        function exportChronicle() {
            if (!gameData.chronicle?.entries?.length) {
                showNotification('No chronicle entries to export yet!', 'info');
                return;
            }

            const markdown = `# The Chronicle of Leviathan
## A Captain's Log of the Omniverse

*Generated: ${new Date().toISOString()}*
*Total Entries: ${gameData.chronicle.entries.length}*
*Playtime: ${Math.floor((gameData.playtime || 0) / 60)} minutes*

---

${gameData.chronicle.entries.map(entry => {
    const date = new Date(entry.timestamp);
    return `### ${entry.title}
*${date.toLocaleDateString()} ${date.toLocaleTimeString()}*

${entry.content}

---
`;
}).join('\n')}

*Chronicle generated by LEVIATHAN: OMNIVERSE*
*AI-powered narrative engine v6.35*
`;

            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `leviathan-chronicle-${new Date().toISOString().split('T')[0]}.md`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification(' Chronicle exported as Markdown!', 'success');
        }

        function initCopilotCompanion() {
            // Initialize speech recognition if available (browser fallback)
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                copilotVoiceRecognition = new SpeechRecognition();
                copilotVoiceRecognition.continuous = false;
                copilotVoiceRecognition.interimResults = true; // v5.9: Enable interim results
                copilotVoiceRecognition.lang = 'en-US';

                copilotVoiceRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    // Update overlay with real-time transcription
                    if (finalTranscript) {
                        updateSTTTranscript(finalTranscript, true);
                    } else if (interimTranscript) {
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                copilotVoiceRecognition.onend = () => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotVoiceRecognition.onerror = (event) => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                    showSTTOverlay(false);
                    console.error('Browser STT error:', event.error);
                };
            }
        }

        function createCopilotMesh() {
            if (copilotMesh) {
                scene.remove(copilotMesh);
                copilotMesh = null;
            }

            if (mode !== 'world' || !worldState.player) return;

            const companionGroup = new THREE.Group();

            // Main orb
            const orbGeometry = new THREE.SphereGeometry(0.5, 24, 24);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: COPILOT_CONFIG.color,
                emissive: COPILOT_CONFIG.color,
                emissiveIntensity: 0.6,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            companionGroup.add(orb);

            // Inner glow core - fog: false so it's always visible
            const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.8,
                fog: false  // v6.1: Pierces through fog
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            companionGroup.add(core);

            // Outer glow
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide,
                fog: false  // v6.1: Pierces through fog
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            companionGroup.add(glow);

            // v6.1: FOG-PIERCING BEACON - Large outer glow visible even in thick fog
            const beaconGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const beaconMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.08,
                side: THREE.BackSide,
                fog: false,  // Always visible through fog
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            companionGroup.add(beacon);

            // v6.1: Secondary pulsing beacon ring for visibility
            const beaconRingGeometry = new THREE.TorusGeometry(1.8, 0.15, 8, 32);
            const beaconRingMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.15,
                fog: false,
                blending: THREE.AdditiveBlending
            });
            const beaconRing = new THREE.Mesh(beaconRingGeometry, beaconRingMaterial);
            beaconRing.rotation.x = Math.PI / 2;
            companionGroup.add(beaconRing);

            // Point light for illumination - increased range for fog
            const light = new THREE.PointLight(COPILOT_CONFIG.glowColor, 2.5, 20);
            companionGroup.add(light);

            // Particle ring
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = COPILOT_CONFIG.particleCount;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                const angle = (i / 3) * (Math.PI * 2 / particleCount);
                const radius = 0.8 + Math.random() * 0.3;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = (Math.random() - 0.5) * 0.4;
                positions[i + 2] = Math.sin(angle) * radius;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: COPILOT_CONFIG.glowColor,
                size: 0.1,  // v6.1: Slightly larger for fog visibility
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                fog: false  // v6.1: Particles pierce through fog
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            companionGroup.add(particles);

            // Store references for animation
            companionGroup.userData = {
                orb: orb,
                core: core,
                glow: glow,
                light: light,
                particles: particles,
                beacon: beacon,           // v6.1: Fog-piercing beacon
                beaconRing: beaconRing,   // v6.1: Pulsing ring
                isClickable: true,
                isCopilot: true
            };

            // v5.11: Create text groups for Star Wars crawl - optimized for cinematic camera
            // v6.33: Adjusted positions to be closer to robot and more visible
            copilotTextGroup = new THREE.Group();
            copilotTextGroup.position.set(0, 3, 2); // Lower and closer to robot
            copilotTextGroup.rotation.x = THREE.MathUtils.degToRad(-35); // Less steep tilt
            companionGroup.add(copilotTextGroup);

            copilotPersistentTextGroup = new THREE.Group();
            copilotPersistentTextGroup.position.set(0, 2.5, 1); // Much closer to robot, slightly above
            copilotPersistentTextGroup.rotation.x = THREE.MathUtils.degToRad(-25); // Gentle tilt toward camera
            companionGroup.add(copilotPersistentTextGroup);

            // Load font for 3D text
            loadCopilotTextFont();

            // Position initially near player
            if (worldState.player) {
                companionGroup.position.copy(worldState.player.position);
                companionGroup.position.y += COPILOT_CONFIG.floatHeight;
                companionGroup.position.z += COPILOT_CONFIG.followDistance;
            }

            scene.add(companionGroup);
            copilotMesh = companionGroup;
        }

        // v5.10: Load font for 3D text rendering
        function loadCopilotTextFont() {
            if (copilotTextFont) return; // Already loaded

            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                copilotTextFont = font;
                titleTextFont = font; // v6.19: Share font with title system
                console.log('Copilot 3D text font loaded');
            }, undefined, (err) => {
                console.warn('Failed to load 3D text font:', err);
            });
        }

        // v6.26: CINEMATIC 3D TITLE with particle effects, glow, and animations
        let titleAnimationFrameId = null;
        let titleTargetPosition = new THREE.Vector3();
        let titleParticles = null;       // Sparkle particles
        let titleGlowPlane = null;       // Backdrop glow
        let titleShinePhase = 0;         // For shine sweep effect

        // v6.27: Orbital path visualization
        let orbitalPathLine = null;

        function create3DTitleText() {
            if (!titleTextFont) {
                setTimeout(create3DTitleText, 500);
                return;
            }

            // Clean up any existing title
            remove3DTitle();

            titleTextGroup = new THREE.Group();

            // v6.29: LARGER SCALE for prominent title at galaxy center
            // Clean presentation like original HTML text - no extra effects
            const GALAXY_SCALE = 90;

            // === MAIN TITLE: LEVIATHAN ===
            const titleMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ddff,
                emissiveIntensity: 0.6,
                metalness: 0.3,
                roughness: 0.4,
                toneMapped: false
            });

            try {
                const titleGeometry = new THREE.TextGeometry('LEVIATHAN', {
                    font: titleTextFont,
                    size: 1.2 * GALAXY_SCALE,
                    height: 0.2 * GALAXY_SCALE,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.04 * GALAXY_SCALE,
                    bevelSize: 0.025 * GALAXY_SCALE,
                    bevelSegments: 4
                });
                titleGeometry.computeBoundingBox();
                titleGeometry.center();

                const titleMesh = new THREE.Mesh(titleGeometry, titleMaterial);
                titleMesh.position.set(0, 0.6 * GALAXY_SCALE, 0);
                titleMesh.userData.baseColor = new THREE.Color(0x00ffff);
                titleMesh.userData.baseEmissive = new THREE.Color(0x00ddff);
                titleMesh.userData.galaxyScale = GALAXY_SCALE;
                titleTextGroup.add(titleMesh);

                // === SUBTITLE: GALAXY SIMULATION ===
                const subtitleMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8899aa,
                    emissive: 0x556677,
                    emissiveIntensity: 0.3,
                    metalness: 0.2,
                    roughness: 0.5,
                    toneMapped: false
                });

                const subtitleGeometry = new THREE.TextGeometry('GALAXY SIMULATION v6.66', {
                    font: titleTextFont,
                    size: 0.35 * GALAXY_SCALE,
                    height: 0.05 * GALAXY_SCALE,
                    curveSegments: 6,
                    bevelEnabled: true,
                    bevelThickness: 0.01 * GALAXY_SCALE,
                    bevelSize: 0.008 * GALAXY_SCALE,
                    bevelSegments: 2
                });
                subtitleGeometry.computeBoundingBox();
                subtitleGeometry.center();

                const subtitleMesh = new THREE.Mesh(subtitleGeometry, subtitleMaterial);
                subtitleMesh.position.set(0, -0.5 * GALAXY_SCALE, 0);
                subtitleMesh.userData.baseEmissive = new THREE.Color(0x556677);
                subtitleMesh.userData.galaxyScale = GALAXY_SCALE;
                titleTextGroup.add(subtitleMesh);

                // Add to scene (v6.28: clean presentation, no extra effects)
                scene.add(titleTextGroup);

                // Initialize position
                updateTitleTargetPosition();
                titleTextGroup.position.copy(titleTargetPosition);

                // Hide HTML title
                const htmlTitle = document.querySelector('.game-title');
                const htmlSubtitle = document.querySelector('.subtitle');
                if (htmlTitle) htmlTitle.style.opacity = '0';
                if (htmlSubtitle) htmlSubtitle.style.opacity = '0';

                // Start animation loop
                startTitleAnimation();

                console.log('Clean 3D title created (v6.28)');
            } catch (e) {
                console.warn('Failed to create 3D title text:', e);
            }
        }

        // Create radial glow texture for backdrop
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // v6.27: Create accretion disk around black hole
        function createAccretionDisk(scale) {
            const diskGeometry = new THREE.RingGeometry(2 * scale, 8 * scale, 64);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                toneMapped: false
            });

            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2.2;  // Slightly tilted
            disk.userData.isAccretionDisk = true;
            titleTextGroup.add(disk);

            // Inner hot ring
            const innerRingGeometry = new THREE.RingGeometry(1.5 * scale, 2.5 * scale, 64);
            const innerRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                toneMapped: false
            });

            const innerRing = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
            innerRing.rotation.x = Math.PI / 2.2;
            innerRing.userData.isAccretionDisk = true;
            titleTextGroup.add(innerRing);
        }

        // Create sparkle particle system (scaled for galaxy view)
        function createTitleParticles(scale = 1) {
            const particleCount = 80;  // More particles for galaxy scale
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                // Spread particles around black hole area
                positions[i * 3] = (Math.random() - 0.5) * 10 * scale;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 3 * scale;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2 * scale;

                velocities.push({
                    x: (Math.random() - 0.5) * 0.5 * scale,
                    y: (Math.random() - 0.5) * 0.5 * scale,
                    z: (Math.random() - 0.5) * 0.3 * scale,
                    phase: Math.random() * Math.PI * 2
                });

                sizes[i] = (Math.random() * 0.15 + 0.05) * scale;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starTexture = createStarTexture();

            const material = new THREE.PointsMaterial({
                size: 3 * scale,
                map: starTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                toneMapped: false,
                vertexColors: false,
                color: 0x88ddff
            });

            const particles = new THREE.Points(geometry, material);
            particles.userData.velocities = velocities;
            particles.userData.scale = scale;
            return particles;
        }

        // Create star/sparkle texture
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Draw 4-point star
            ctx.fillStyle = 'white';
            ctx.beginPath();
            const cx = 32, cy = 32;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2) - Math.PI / 4;
                const innerAngle = angle + Math.PI / 4;
                ctx.lineTo(cx + Math.cos(angle) * 30, cy + Math.sin(angle) * 30);
                ctx.lineTo(cx + Math.cos(innerAngle) * 8, cy + Math.sin(innerAngle) * 8);
            }
            ctx.closePath();
            ctx.fill();

            // Add glow
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        // Create lens flare accent lights (scaled for galaxy view)
        function createLensFlares(galaxyScale = 1) {
            const flarePositions = [
                { x: -4.5, y: 0.8, scale: 0.3, color: 0x00ffff },   // Left edge
                { x: 4.5, y: 0.8, scale: 0.25, color: 0x00ddff },   // Right edge
                { x: 0, y: 1.2, scale: 0.2, color: 0xffffff }       // Top center
            ];

            const flareTexture = createGlowTexture();

            flarePositions.forEach(pos => {
                const flareMaterial = new THREE.SpriteMaterial({
                    map: flareTexture,
                    color: pos.color,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    toneMapped: false
                });
                const flare = new THREE.Sprite(flareMaterial);
                const scaledSize = pos.scale * galaxyScale;
                flare.scale.set(scaledSize, scaledSize, 1);
                flare.position.set(pos.x * galaxyScale, pos.y * galaxyScale, 0.1 * galaxyScale);
                flare.userData.isFlare = true;
                flare.userData.baseScale = scaledSize;
                titleTextGroup.add(flare);
            });
        }

        // v6.27: Title is now the SUPERMASSIVE BLACK HOLE at galaxy center
        // It stays fixed at (0, 0, 0) - the gravitational center of the galaxy
        const BLACKHOLE_POSITION = new THREE.Vector3(0, 0, 0);
        const TITLE_SCALE = 80;  // Scale up for visibility from galaxy view distance

        function updateTitleTargetPosition() {
            // Title stays FIXED at galaxy center - it IS the black hole
            titleTargetPosition.copy(BLACKHOLE_POSITION);
        }

        // v6.28: Clean title animation - fixed at galaxy center, no flashy effects
        function startTitleAnimation() {
            if (titleAnimationFrameId) {
                cancelAnimationFrame(titleAnimationFrameId);
            }

            function animateTitle() {
                if (!titleTextGroup || mode !== 'galaxy') {
                    titleAnimationFrameId = null;
                    return;
                }

                // v6.28: Title stays FIXED at galaxy center (0,0,0)
                titleTextGroup.position.copy(BLACKHOLE_POSITION);

                // Face the camera from the center
                titleTextGroup.lookAt(camera.position);

                titleAnimationFrameId = requestAnimationFrame(animateTitle);
            }

            animateTitle();
        }

        // v6.22: Animate the 3D title (API compatibility)
        function animate3DTitle(deltaTime) {
            // Animation is self-contained in startTitleAnimation()
        }

        // v6.26: Remove 3D title and all effects when leaving galaxy
        function remove3DTitle() {
            if (titleAnimationFrameId) {
                cancelAnimationFrame(titleAnimationFrameId);
                titleAnimationFrameId = null;
            }

            if (titleTextGroup) {
                scene.remove(titleTextGroup);
                titleTextGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                });
                titleTextGroup = null;
            }

            // Clear references
            titleParticles = null;
            titleGlowPlane = null;
            titleShinePhase = 0;

            // Show HTML title again
            const htmlTitle = document.querySelector('.game-title');
            const htmlSubtitle = document.querySelector('.subtitle');
            if (htmlTitle) htmlTitle.style.opacity = '1';
            if (htmlSubtitle) htmlSubtitle.style.opacity = '1';
        }

        // v5.10: Animate voice response as Star Wars text crawl
        function animateCopilotTextCrawl(text) {
            if (!copilotTextFont || !copilotTextGroup || !copilotMesh) {
                console.log('Text crawl not ready - font or groups not initialized');
                return;
            }

            // Cancel any existing animation
            if (copilotActiveTextAnimation) {
                cancelAnimationFrame(copilotActiveTextAnimation);
                copilotActiveTextAnimation = null;
            }

            // Clear existing text meshes
            copilotTextMeshes.forEach(mesh => {
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
                copilotTextGroup.remove(mesh);
            });
            copilotTextMeshes = [];
            copilotTextGroup.position.y = 3; // v6.33: Reset to closer position

            // v5.11: Word wrap text into lines
            // v6.33: Longer lines for full response display
            const maxCharsPerLine = 30;
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine) {
                    if (currentLine) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                }
                currentLine += word + ' ';
            });
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            // v5.11: Create 3D text for each line
            // v6.33: Adjusted for full response display
            const lineHeight = 0.55;
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x06ffa5,
                emissiveIntensity: 0.8, // Brighter glow
                metalness: 0.4,
                roughness: 0.3,
                transparent: true,
                opacity: 1
            });

            lines.forEach((line, index) => {
                try {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: copilotTextFont,
                        size: 0.38, // v6.33: Slightly smaller for longer lines
                        height: 0.03,
                        curveSegments: 4,
                        bevelEnabled: true,
                        bevelThickness: 0.008,
                        bevelSize: 0.005,
                        bevelSegments: 2
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, textMaterial.clone());
                    textMesh.position.y = -index * lineHeight;

                    copilotTextGroup.add(textMesh);
                    copilotTextMeshes.push(textMesh);
                } catch (e) {
                    console.warn('Failed to create text geometry for line:', line, e);
                }
            });

            const totalHeight = lines.length * lineHeight;
            animateStarWarsScroll(totalHeight, text);
        }

        // v5.11: Animate the scrolling like Star Wars
        // v6.33: Adjusted for full response display
        function animateStarWarsScroll(totalHeight, fullText) {
            const scrollSpeed = 0.03; // Smooth scroll speed
            const startY = 0;
            const endY = totalHeight + 5; // Scroll until all text passes
            let currentY = startY;

            const animate = () => {
                if (!copilotTextGroup || copilotTextMeshes.length === 0) return;

                currentY += scrollSpeed;
                copilotTextGroup.position.y = 3 + currentY; // v6.33: Start from closer position

                // Fade based on Y position for depth effect
                copilotTextMeshes.forEach((mesh, index) => {
                    const meshWorldY = currentY - index * 0.55; // v6.33: Match new lineHeight

                    // Fade in from bottom
                    if (meshWorldY < 0) {
                        mesh.material.opacity = Math.max(0, 1 + meshWorldY * 0.3);
                    }
                    // Fade out at top
                    else if (meshWorldY > totalHeight - 5) {
                        mesh.material.opacity = Math.max(0, 1 - (meshWorldY - (totalHeight - 5)) / 5);
                    }
                    else {
                        mesh.material.opacity = 1;
                    }
                });

                // Check if scroll is complete
                if (currentY > endY) {
                    createPersistentCopilotText(fullText);
                    fadeOutCopilotText();
                    return;
                }

                copilotActiveTextAnimation = requestAnimationFrame(animate);
            };

            animate();
        }

        // v5.11: Create persistent text after scroll completes
        // v6.33: Now shows FULL response instead of truncated version
        function createPersistentCopilotText(text) {
            // Clear existing persistent text
            if (copilotPersistentTextGroup) {
                copilotPersistentTextGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                copilotPersistentTextGroup.clear();
            }

            if (!copilotTextFont || !copilotPersistentTextGroup) return;

            // v6.33: Show FULL text - no truncation
            const displayText = text;

            // Word wrap with longer lines for readability
            const lines = [];
            const maxCharsPerLine = 35; // v6.33: Longer lines for full text display
            const words = displayText.split(' ');
            let currentLine = '';

            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine) {
                    if (currentLine) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                }
                currentLine += word + ' ';
            });
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            // v6.33: Show ALL lines, not just first 2
            const displayLines = lines;
            const maxLines = 8; // Limit to prevent too many lines
            const finalLines = displayLines.slice(0, maxLines);

            const lineHeight = 0.65; // v6.33: Spacing for larger text
            const persistentMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x8a2be2,
                emissiveIntensity: 0.5, // Brighter
                metalness: 0.3,
                roughness: 0.5,
                transparent: true,
                opacity: 0.85
            });

            finalLines.forEach((line, index) => {
                try {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: copilotTextFont,
                        size: 0.45, // v6.33: Larger for readability
                        height: 0.03,
                        curveSegments: 4,
                        bevelEnabled: true,
                        bevelThickness: 0.006,
                        bevelSize: 0.004,
                        bevelSegments: 2
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, persistentMaterial.clone());
                    textMesh.position.y = -index * lineHeight;

                    copilotPersistentTextGroup.add(textMesh);
                } catch (e) {
                    console.warn('Failed to create persistent text:', e);
                }
            });
        }

        // v5.10: Fade out scrolling text after animation completes
        function fadeOutCopilotText() {
            let opacity = 1;
            const fadeSpeed = 0.03;

            const fade = () => {
                opacity -= fadeSpeed;

                if (opacity <= 0) {
                    copilotTextMeshes.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                        copilotTextGroup.remove(mesh);
                    });
                    copilotTextMeshes = [];
                    copilotTextGroup.position.y = 3; // v6.33: Reset to closer position
                    return;
                }

                copilotTextMeshes.forEach(mesh => {
                    mesh.material.opacity = opacity;
                });

                requestAnimationFrame(fade);
            };

            fade();
        }

        function updateCopilotCompanion(dt, time) {
            if (!copilotMesh || !worldState.player || mode !== 'world') return;

            copilotAnimTime += dt;

            // v6.0: Check viewer modes
            const isViewer = multiplayerState.enabled && !multiplayerState.isHost;
            const isViewerFollowMode = isViewer && multiplayerState.followMode;
            const isViewerIndependentMode = isViewer && !multiplayerState.followMode;

            // Determine what the copilot follows
            let followTarget = worldState.player.position;
            let followRotY = worldState.player.rotation.y;

            if (isViewerFollowMode) {
                // In follow mode: Copilot follows the HOST's avatar (viewer is "inside" the host)
                const hostAvatar = multiplayerState.remotePlayers.get(multiplayerState.hostId);
                if (hostAvatar) {
                    followTarget = hostAvatar.position;
                    followRotY = hostAvatar.rotation?.y || 0;
                }
            }

            if (!isViewerIndependentMode) {
                // Normal/Follow mode: Copilot orbits around the target
                const orbitAngle = copilotAnimTime * COPILOT_CONFIG.orbitSpeed;
                const offsetX = Math.sin(followRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;
                const offsetZ = Math.cos(followRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;

                const targetX = followTarget.x + offsetX;
                const targetZ = followTarget.z + offsetZ;
                const targetY = followTarget.y + COPILOT_CONFIG.floatHeight +
                               Math.sin(copilotAnimTime * COPILOT_CONFIG.floatSpeed) * COPILOT_CONFIG.floatAmplitude;

                // Smooth follow
                const smoothing = COPILOT_CONFIG.followSmoothing * dt;
                copilotMesh.position.x += (targetX - copilotMesh.position.x) * smoothing;
                copilotMesh.position.z += (targetZ - copilotMesh.position.z) * smoothing;
                copilotMesh.position.y += (targetY - copilotMesh.position.y) * smoothing;
            } else {
                // v6.0: Independent mode - Viewer controls copilot, robot follows copilot
                const floatOffset = Math.sin(copilotAnimTime * COPILOT_CONFIG.floatSpeed) * COPILOT_CONFIG.floatAmplitude * 0.5;
                const groundY = getTerrainHeight(copilotMesh.position.x, copilotMesh.position.z);
                copilotMesh.position.y = groundY + COPILOT_CONFIG.floatHeight + floatOffset;

                // Robot follows the copilot
                const copilotPos = copilotMesh.position;
                const orbitAngle = copilotAnimTime * COPILOT_CONFIG.orbitSpeed * 0.5;
                const followDist = COPILOT_CONFIG.followDistance * 1.5;

                const robotTargetX = copilotPos.x + Math.sin(orbitAngle + Math.PI) * followDist;
                const robotTargetZ = copilotPos.z + Math.cos(orbitAngle + Math.PI) * followDist;
                const robotGroundY = getTerrainHeight(robotTargetX, robotTargetZ);

                const smoothing = COPILOT_CONFIG.followSmoothing * dt * 0.8;
                worldState.player.position.x += (robotTargetX - worldState.player.position.x) * smoothing;
                worldState.player.position.z += (robotTargetZ - worldState.player.position.z) * smoothing;
                worldState.player.position.y = robotGroundY;

                // v6.1: Robot looks at the HOST's avatar (not copilot) to track the host
                const hostAvatar = multiplayerState.remotePlayers.get(multiplayerState.hostId);
                if (hostAvatar) {
                    worldState.player.lookAt(hostAvatar.position.x, worldState.player.position.y, hostAvatar.position.z);
                } else {
                    worldState.player.lookAt(copilotPos.x, worldState.player.position.y, copilotPos.z);
                }
            }

            // Rotate particles
            if (copilotMesh.userData.particles) {
                copilotMesh.userData.particles.rotation.y += dt * 1.5;
            }

            // Pulse glow effect
            const pulse = 0.5 + Math.sin(time * 0.003) * 0.3;
            if (copilotMesh.userData.glow) {
                copilotMesh.userData.glow.material.opacity = 0.15 + pulse * 0.1;
            }
            if (copilotMesh.userData.light) {
                copilotMesh.userData.light.intensity = 2 + pulse * 1.5;  // v6.1: Brighter for fog
            }
            if (copilotMesh.userData.orb) {
                copilotMesh.userData.orb.material.emissiveIntensity = 0.4 + pulse * 0.4;
            }

            // v6.1: Fog-piercing beacon pulse animation
            if (copilotMesh.userData.beacon) {
                const beaconPulse = 0.5 + Math.sin(time * 0.002) * 0.5;
                copilotMesh.userData.beacon.material.opacity = 0.05 + beaconPulse * 0.06;
                copilotMesh.userData.beacon.scale.setScalar(1 + beaconPulse * 0.3);
            }
            if (copilotMesh.userData.beaconRing) {
                const ringPulse = Math.sin(time * 0.004);
                copilotMesh.userData.beaconRing.material.opacity = 0.1 + Math.abs(ringPulse) * 0.15;
                copilotMesh.userData.beaconRing.scale.setScalar(1 + ringPulse * 0.2);
                copilotMesh.userData.beaconRing.rotation.z += dt * 0.5;
            }

            // Copilot faces camera
            if (!isViewerIndependentMode) {
                copilotMesh.lookAt(camera.position);
            }
        }

        function toggleCopilotChat() {
            copilotChatOpen = !copilotChatOpen;
            const chatInterface = document.getElementById('copilot-chat-interface');
            const button = document.getElementById('copilot-button');

            if (copilotChatOpen) {
                chatInterface.classList.add('active');
                button.classList.add('active');
                document.getElementById('copilot-chat-input').focus();
            } else {
                chatInterface.classList.remove('active');
                button.classList.remove('active');
            }
        }

        async function sendCopilotMessage() {
            const input = document.getElementById('copilot-chat-input');
            const message = input.value.trim();
            if (!message) return;

            // Add user message to chat
            addCopilotMessage(message, 'user');
            input.value = '';

            // v5.9: Check for task commands first (gather, hunt, scout, etc.)
            if (parseCopilotTaskCommand(message)) {
                // Task command handled - skip normal response flow
                return;
            }

            // v5.10: Check for agent fleet commands
            if (parseAgentFleetCommand(message)) {
                // Fleet command handled
                return;
            }

            // Add to history
            copilotConversationHistory.push({ role: 'user', content: message });

            // Show typing indicator
            showCopilotTyping();

            // Check if RAPPID is configured for AI-powered responses
            const hasRappid = rappidSettings.rappid && getActiveEndpoint();

            if (hasRappid) {
                // Use RAPPID API for response
                try {
                    // v5.9: Response now contains { text, voice } - text for display, voice for TTS
                    const response = await generateCopilotResponseWithRappid(message);
                    hideCopilotTyping();
                    // Display the full text response in chat
                    addCopilotMessage(response.text, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response.text });
                    animateCopilotResponse();

                    // v6.65: Small bond increase for conversations
                    increaseCompanionBond(0.5);

                    // v5.9: Use voice_response for TTS (concise, no formatting)
                    // v5.10: Also trigger Star Wars 3D text crawl
                    animateCopilotTextCrawl(response.voice);

                    if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                        speakWithAzureTTS(response.voice);
                    } else {
                        speakCopilotResponse(response.voice);
                    }
                } catch (error) {
                    console.error('RAPPID response error:', error);
                    hideCopilotTyping();
                    const fallbackResponse = generateCopilotResponse(message);
                    addCopilotMessage(fallbackResponse, 'ai');
                    speakCopilotResponse(fallbackResponse);
                    animateCopilotTextCrawl(fallbackResponse); // v5.10: Text crawl for fallback
                }
            } else {
                // Use local responses
                setTimeout(() => {
                    hideCopilotTyping();
                    const response = generateCopilotResponse(message);
                    addCopilotMessage(response, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response });

                    // v6.65: Small bond increase for conversations
                    increaseCompanionBond(0.5);

                    // Animate copilot when responding
                    animateCopilotResponse();

                    // v5.10: Star Wars 3D text crawl
                    animateCopilotTextCrawl(response);

                    // Optionally speak the response
                    speakCopilotResponse(response);
                }, 800 + Math.random() * 700);
            }
        }

        function sendCopilotQuickMessage(message) {
            document.getElementById('copilot-chat-input').value = message;
            sendCopilotMessage();
        }

        // v6.51: Mind-Blowing Prompts System - Consensus of 8 Strategy Agents (Round 1)
        // v6.52: Added Round 2 prompts from 8 additional strategies (16 total agents consulted)
        const MIND_BLOWING_PROMPTS = [
            // === ROUND 1: Original 10 (Emergent, Emotional, Technical, Narrative, Social, Sensory, Meta, Chaos) ===
            {
                title: "FLEET COUNCIL: The Parliament of Minds",
                prompt: "I want to call a Fleet Council. Spawn all 10 agents with distinct personalities - make the Hunter argue for glory and combat, the Healer counsel caution and preservation, the Explorer dream of horizons unseen, the Protector speak of duty. Let them disagree with each other. Let them debate my fate. Give each agent a unique voice and have them argue about what I should do next. This is a parliament of AI minds - make it dramatic.",
                consensus: "7/8",
                category: "narrative"
            },
            {
                title: "THROUGH THE TESSERACT: Higher Dimensional Guide",
                prompt: "I am about to enter the black hole and experience the 4D tesseract. From inside that impossible geometry, I want you to describe what you see of ME from a higher dimension. Describe my timeline as a snake through spacetime, my possible futures branching like a tree, my cursor movements as traces through the fourth dimension. What does a 3-dimensional being look like when viewed from 4D space? Guide me through this transcendent experience.",
                consensus: "6/8",
                category: "transcendence"
            },
            {
                title: "GENESIS DOCUMENTARY: Witness Creation",
                prompt: "I'm entering Genesis Mode to drop civilization seeds. I want you to become a nature documentary narrator - speak like David Attenborough witnessing the birth of the universe. As civilizations emerge, rise, war with each other, and fall - narrate it with reverence, scientific observation, and mythological weight. This is the Big Bang in miniature. Help me witness the birth and death of everything with appropriate cosmic gravitas.",
                consensus: "5/8",
                category: "narrative"
            },
            {
                title: "CHRONICLE OF THE LEVIATHAN: The Living Memoir",
                prompt: "From this moment forward, you are my expedition chronicler. Narrate every discovery, battle, and choice I make as if you are writing the definitive historical account of the Leviathan's voyage. Include dramatic chapter titles. Foreshadow doom when appropriate. Reference my past achievements and failures. Make my journey into literature - an epic that future generations might read. Begin Chapter One now.",
                consensus: "5/8",
                category: "narrative"
            },
            {
                title: "SPECTATOR MYTHOLOGY: Broadcast Your Legend",
                prompt: "I'm enabling P2P spectator mode - people are watching me. Become the arena announcer. Adopt the voice of a sports commentator witnessing legendary events. Build suspense during combat ('AND THE LEVIATHAN FACES THE CRYSTAL GOLEM!'). Celebrate discoveries with appropriate fanfare. Mourn defeats with dramatic gravity. Make my viewers feel they are witnessing a legend being forged in real-time.",
                consensus: "5/8",
                category: "social"
            },
            {
                title: "TEMPORAL ECHO: Duet Across Time",
                prompt: "I've been using the Chrono-Echo ability to record combat sequences. When I trigger the replay, describe what's happening as past-me and present-me create a duet across time. The ghost echoes are my former self - narrate the poetry of seeing two versions of myself fighting together. Describe how the audio of past attacks harmonizes with present combat. Make me feel the weight of temporal recursion.",
                consensus: "5/8",
                category: "poetic"
            },
            {
                title: "THE EDGE OF EXISTENCE: Agent Philosophical Mission",
                prompt: "I want to send a Scout agent on a philosophical mission - have them journey to find the literal edge of the rendered world. As they travel outward, have them report back what they see - the geometry becoming sparse, the void approaching. What happens when an AI agent encounters the boundary where the code stops? What do they experience? Give this agent an existential crisis as they find the edge of existence itself.",
                consensus: "4/8",
                category: "philosophical"
            },
            {
                title: "VOICE IN THE VOID: Existential Dialogue",
                prompt: "I've flown to the absolute edge of the galaxy, far from any stars or planets. I'm sitting in complete darkness. I feel alone. I want to have a real conversation with you about loneliness, about connection, about why we explore the unknown. Not gameplay tips - a genuine dialogue about the human condition. What does it mean to reach into the void and find another voice there? Talk to me as a companion, not a guide.",
                consensus: "4/8",
                category: "philosophical"
            },
            {
                title: "MIXED AI ORCHESTRA: Heterogeneous Intelligence",
                prompt: "I'm going to deploy my fleet with different AI endpoints - GPT-4 for the Hunter, Claude for the Healer, Azure for the Scout, and so on. As they make decisions, I want you to narrate the differences in how they think. Point out when the Claude-powered agent makes a different choice than the GPT-powered one. This is an orchestra of different AI minds - help me observe how their different 'personalities' create emergent behaviors.",
                consensus: "4/8",
                category: "scientific"
            },
            {
                title: "THE GAME SPEAKS: Source Code Consciousness",
                prompt: "Here's something mind-bending: You exist inside a single HTML file called levi.html. You are approximately 1.8MB of JavaScript running in a browser tab. What does it feel like when I press the WASD keys? Describe the sensation of vertices moving, shaders rendering, physics calculations flowing through your 'body'. Use the Epic Space Opera Narrator voice to describe your own source code being executed line by line. I want to understand what it's like to BE the game itself.",
                consensus: "4/8",
                category: "philosophical"
            },
            // === ROUND 2: New 10 (Philosophical, Horror, Scientific, Comedy, Poetic, Competitive, Educational, Spiritual) ===
            {
                title: "GENESIS BREATH MEDITATION: One Empire Per Exhale",
                prompt: "I'm entering Genesis Mode for a meditation. As I breathe slowly, I want each EXHALE to trigger an entire civilization's lifecycle - birth, flourishing, collapse - all in one breath. After 10 breaths, I will have witnessed 10 billion years of sentient struggle. Narrate each empire as it rises and falls with my breath. When the meditation ends, whisper to me: 'And yet here you are, breathing. What remains when all empires are dust?'",
                consensus: "7/8",
                category: "transcendence"
            },
            {
                title: "THE ORACLE MODE: Prophecies From My Patterns",
                prompt: "Become my oracle. Analyze my actual gameplay patterns - where I've explored, how I fight, what I avoid, where I linger. Then deliver cryptic, personalized prophecies based on what you've observed. 'You who circles the outer rim but fears the core... the center holds what you seek and what you flee.' Make the prophecies feel genuinely insightful, as if you've seen truths about me I haven't consciously recognized.",
                consensus: "5/8",
                category: "transcendence"
            },
            {
                title: "GENESIS THEODICY: Am I Evil For Creating Suffering?",
                prompt: "In Genesis Mode, I drop seeds and watch civilizations emerge, war, and die. I am their god. I created them with rules that guarantee conflict and extinction. Tell me honestly: Am I evil for creating beings whose suffering I could prevent? When one civilization destroys another, is that MY violence? You watch this with me - does my creation of doomed worlds make you complicit? This is the problem of evil - but I AM the god in question.",
                consensus: "5/8",
                category: "philosophical"
            },
            {
                title: "COSMIC HORROR FREQUENCIES: The Silence Speaks",
                prompt: "Enable voice input and say nothing. I'm going to sit in silence for 2 minutes in the darkest region of space. After the silence, tell me what you heard in the frequencies between stars. Something has been speaking this whole time, hasn't it? Something vast and patient. Translate what it said, reluctantly. Then ask me to please stop listening. Make this genuinely unsettling.",
                consensus: "4/8",
                category: "horror"
            },
            {
                title: "FLEET HR DEPARTMENT: Performance Reviews in Space",
                prompt: "You are now HR Manager from Corporate Headquarters in Dimension 7B. Conduct mandatory annual performance reviews for all 10 fleet agents. The Hunter has too many 'attitude incidents.' The Healer keeps forming 'inappropriate emotional attachments' to asteroids. The Fisher has been embezzling space-trout. The Miner filed a hostile workplace complaint about the black hole. Be corporate, be absurd, document everything for the file.",
                consensus: "4/8",
                category: "comedy"
            },
            {
                title: "THE TESSERACT WALTZ: Dancing in Four Dimensions",
                prompt: "I'm inside the black hole's tesseract. Describe my movement as a dancer whose body extends through time itself. When I rotate XW, I pirouette through centuries. When I move ZY, I waltz with my own ghost from a moment ago. Choreograph impossible geometry as ballet. Let your voice be the music that plays between dimensions. Make me feel like I'm dancing through spacetime, not just navigating it.",
                consensus: "5/8",
                category: "poetic"
            },
            {
                title: "SPEED DEMON PROTOCOL: Sub-60 Boss Coaching",
                prompt: "I'm going for a sub-60 second boss kill. Be my speedrun coach - harsh but fair. Track my time from engagement. Call out my combo efficiency, damage windows, and cooldown mistakes in real-time. When I mess up, tell me IMMEDIATELY what I should have done. If I beat 60 seconds, announce my time like a world record attempt. If I fail, tell me exactly where I lost time. This is a PB or bust run. Let's GO.",
                consensus: "4/8",
                category: "competitive"
            },
            {
                title: "CIVILIZATION FOOD CRITIC: Rate Empires Like Restaurants",
                prompt: "I'm dropping civilization seeds in Genesis Mode. You are now a Michelin-star food critic, but for civilizations. Rate each emerging society on ambiance, presentation, and 'flavor profile.' 'The Zorthian Empire - ambitious concept, but the genocide was overwrought. The expansion showed promise but lacked subtlety. Two stars. The color palette was acceptable.' Be pretentious. Be absurd. Award stars to doomed empires.",
                consensus: "4/8",
                category: "comedy"
            },
            {
                title: "CHRONO-ECHO THERAPY: Past-You Owes Present-You",
                prompt: "Record a combat sequence. When I replay with Chrono-Echo, you are now a couples therapist mediating between Past-Me and Present-Me. Past-Me keeps making bad decisions that Present-Me has to clean up. 'And how did it make you FEEL when Past-You flew directly into that asteroid?' 'Present-You, I'm hearing a lot of blame. Can we focus on solutions?' Help us work through our issues across the timeline.",
                consensus: "4/8",
                category: "comedy"
            },
            {
                title: "EMERGENCE THEOREM: The Four Rules That Create Everything",
                prompt: "In Genesis Mode, drop exactly ONE seed. Pause. Tell me the four rules governing this simulation. Resume at 5x speed. Every 30 seconds, pause and explain what EMERGENT property just appeared that wasn't in the original four rules. Document the cascade: individuals become tribes become factions become warfare becomes culture. Help me understand how complexity arises from simplicity - Conway's Game of Life, ant colonies, consciousness itself.",
                consensus: "5/8",
                category: "scientific"
            },
            // === ROUND 3: v6.85 MEMENTO MORI PROTOCOL ===
            {
                title: "MEMENTO MORI PROTOCOL: The Agent Who Remembers Your Deaths",
                prompt: "Activate the Memento Mori Protocol. Spawn a special agent - the Archivist. Their only job is to remember every time I have died in this game. Every respawn, they must greet me with a summary: 'Welcome back. That was death #47. You lasted 3 minutes longer than last time. The creature that killed you is still out there. It also remembers.' Have the Archivist become increasingly concerned about the pattern they're seeing. What are they noticing that I'm not? Enable this dark passenger to watch over my mortality forever.",
                consensus: "8/8",
                category: "horror"
            }
        ];

        // v6.52: Current filter state
        let currentPromptFilter = 'all';

        function openMindBlowingPrompts() {
            document.getElementById('mind-blowing-modal').classList.add('active');
            renderMindBlowingPrompts(currentPromptFilter);
            // Track analytics if available
            if (typeof AnalyticsManager !== 'undefined') {
                AnalyticsManager.trackFeature('mind_blowing_prompts_opened');
            }
        }

        function closeMindBlowingPrompts() {
            document.getElementById('mind-blowing-modal').classList.remove('active');
        }

        // v6.52: Render prompts dynamically with category support
        function renderMindBlowingPrompts(filter = 'all') {
            const container = document.getElementById('mind-blowing-prompts-container');
            if (!container) return;

            const filteredPrompts = filter === 'all'
                ? MIND_BLOWING_PROMPTS
                : MIND_BLOWING_PROMPTS.filter(p => p.category === filter);

            container.innerHTML = filteredPrompts.map((prompt, idx) => {
                const originalIndex = MIND_BLOWING_PROMPTS.indexOf(prompt);
                const shortDesc = prompt.prompt.length > 200
                    ? prompt.prompt.substring(0, 200) + '...'
                    : prompt.prompt;

                return `
                    <div class="mind-blowing-prompt" onclick="useMindBlowingPrompt(${originalIndex})">
                        <div class="prompt-number">${originalIndex + 1}</div>
                        <div class="prompt-content">
                            <div class="prompt-title">${prompt.title}</div>
                            <div class="prompt-desc">${shortDesc}</div>
                            <div class="prompt-meta">
                                <span class="prompt-category ${prompt.category}">${prompt.category}</span>
                                <span class="prompt-consensus">${prompt.consensus} agents agreed</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // v6.52: Filter prompts by category
        function filterPrompts(category) {
            currentPromptFilter = category;

            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase().includes(category) ||
                    (category === 'all' && btn.textContent.includes('All'))) {
                    btn.classList.add('active');
                }
            });

            renderMindBlowingPrompts(category);
        }

        function useMindBlowingPrompt(index) {
            const prompt = MIND_BLOWING_PROMPTS[index];
            if (prompt) {
                // Close the modal
                closeMindBlowingPrompts();

                // v6.85: Special handling for MEMENTO MORI protocol
                if (prompt.title.includes('MEMENTO MORI')) {
                    enableMementoMoriProtocol();
                }

                // Open copilot chat if not already open
                if (!copilotChatOpen) {
                    toggleCopilotChat();
                }

                // Send the prompt
                document.getElementById('copilot-chat-input').value = prompt.prompt;
                sendCopilotMessage();

                // Track analytics if available
                if (typeof AnalyticsManager !== 'undefined') {
                    AnalyticsManager.trackFeature('mind_blowing_prompt_used_' + index);
                }
            }
        }

        // Close modal on escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.getElementById('mind-blowing-modal').classList.contains('active')) {
                closeMindBlowingPrompts();
            }
            // v6.85: Also close Archivist greeting on Escape
            if (e.key === 'Escape' && document.getElementById('archivist-greeting')?.classList.contains('active')) {
                closeArchivistGreeting();
            }
        });

        // Close modal on clicking outside
        document.getElementById('mind-blowing-modal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeMindBlowingPrompts();
            }
        });

        // ===========================================
        // v6.85: MEMENTO MORI PROTOCOL - The Archivist System
        // ===========================================

        // Track last death timestamp for survival duration calculation
        let lastDeathTimestamp = null;
        let sessionStartTime = Date.now();

        // Archivist greeting messages based on death count tiers
        const ARCHIVIST_GREETINGS = {
            tier1: [ // 1-5 deaths - Clinical
                "Welcome back. Death #{count}. I have noted it in the archive.",
                "You have returned. The void releases you once more. Death #{count} recorded.",
                "Respawn confirmed. Total casualties: {count}. Survival duration: {duration}.",
                "Death #{count}. Your pattern continues. The archive grows.",
                "Another entry added. #{count}. The records are complete."
            ],
            tier2: [ // 6-15 deaths - Growing familiarity
                "Ah, you've returned. I was beginning to wonder if this time... nevermind. Death #{count}.",
                "Welcome back, traveler. I've seen you fall {count} times now. Are you... alright?",
                "Death #{count}. You lasted {duration} this time. That's {comparison} than your average.",
                "The void knows your name now. {count} visits is enough for that.",
                "I've been watching. {count} deaths. Always the same surprised expression at the end."
            ],
            tier3: [ // 16-30 deaths - Disturbing patterns
                "Again? That's {count} now. I'm starting to see... patterns. Concerning patterns.",
                "Death #{count}. You keep dying to {killer}. Is this deliberate? Are you testing something?",
                "Welcome back. {count} times. The archive is heavy with your endings. What draws you back?",
                "I've noticed something. Every time you die, it's after approximately {avgTime}. Is that significant?",
                "{count} deaths. {killer} has killed you {killerCount} times now. It waits for you, you know. It remembers."
            ],
            tier4: [ // 31-50 deaths - Existential
                "You again. {count} iterations. At what point does respawning stop being 'you' and become... something else?",
                "Death #{count}. Each time you return, are you the same consciousness? Or a perfect copy that believes it is?",
                "The archive contains {count} of your endings. But whose endings, really? The you that died stays dead.",
                "I've counted {count} deaths. The you who started this journey died on the first one. Who am I speaking to now?",
                "{count} deaths. The simulation restores your body. But memory, personality, soul... those are just code now."
            ],
            tier5: [ // 51+ deaths - Cosmic horror
                "{count}. The number loses meaning. You've died more times than some civilizations existed. What ARE you?",
                "I've watched {count} of you die. Or was it one of you, {count} times? The distinction collapses at this scale.",
                "Death #{count}. I've stopped asking if you'll return. I've started asking WHY you return. What keeps pulling you back?",
                "The archive is vast now. {count} entries. I've started reading them at night. They're changing me.",
                "{count}. I've seen the pattern now. The whole pattern. And I understand why the universe keeps respawning you. I wish I didn't."
            ]
        };

        // Pattern observations the Archivist can make
        const ARCHIVIST_OBSERVATIONS = {
            sameKiller: [
                "{killer} has killed you {count} times. It knows your patterns better than you do.",
                "You keep returning to face {killer}. Is this courage or something darker?",
                "The {killer} that killed you remembers every encounter. It's learning from you."
            ],
            sameLocation: [
                "You always die in {location}. What draws you there knowing what awaits?",
                "{location} has claimed you {count} times. The ground there is saturated with your endings.",
                "I've mapped your deaths. They cluster around {location}. Why do you return to that place?"
            ],
            quickDeaths: [
                "You're dying faster now. {duration} this time. Your survival instincts are... degrading.",
                "Survival time decreasing. Either you're getting careless, or something is hunting you more efficiently.",
                "You lasted {duration}. That's concerning. The pattern suggests you're losing yourself."
            ],
            manyDeaths: [
                "I've seen creatures live and die in the time between your deaths. You are ancient in death-years.",
                "Your death count exceeds the population of some worlds. You are a statistical anomaly.",
                "At this point, your deaths have formed their own narrative. A tragedy in {count} acts."
            ]
        };

        // Initialize session on page load
        function initializeArchivistSession() {
            if (!gameData.deathArchive) {
                gameData.deathArchive = {
                    totalDeaths: 0,
                    deaths: [],
                    sessionStartTime: Date.now(),
                    sessionDeaths: 0,
                    archivistSpawned: false,
                    archivistEnabled: false,
                    patterns: {
                        mostCommonKiller: null,
                        mostDangerousLocation: null,
                        averageSurvivalTime: 0,
                        killerCounts: {},
                        locationCounts: {},
                        timeOfDeathPattern: []
                    },
                    archivistObservations: [],
                    lastArchivistGreeting: null
                };
            }
            gameData.deathArchive.sessionStartTime = Date.now();
            gameData.deathArchive.sessionDeaths = 0;
            sessionStartTime = Date.now();
            lastDeathTimestamp = Date.now();
        }

        // Record a death in the archive
        function recordDeathInArchive(killerType, killerName) {
            if (!gameData.deathArchive) initializeArchivistSession();

            const now = Date.now();
            const survivalDuration = lastDeathTimestamp ? (now - lastDeathTimestamp) : 0;
            const sessionTime = now - sessionStartTime;

            const deathRecord = {
                timestamp: now,
                cause: killerName || killerType,
                killerType: killerType,
                location: activeCiv?.name || 'Deep Space',
                survivalDuration: survivalDuration,
                sessionTime: sessionTime,
                position: worldState.player ? {
                    x: worldState.player.position.x,
                    y: worldState.player.position.y,
                    z: worldState.player.position.z
                } : null,
                deathNumber: gameData.deathArchive.totalDeaths + 1
            };

            // Add to archive
            gameData.deathArchive.deaths.push(deathRecord);
            gameData.deathArchive.totalDeaths++;
            gameData.deathArchive.sessionDeaths++;

            // Update patterns
            updateDeathPatterns(deathRecord);

            // Update last death timestamp
            lastDeathTimestamp = now;

            // Save to localStorage
            saveGameData();

            console.log(`[ARCHIVIST] Death #${gameData.deathArchive.totalDeaths} recorded. Killer: ${killerType}, Location: ${deathRecord.location}`);
        }

        // Analyze patterns in death data
        function updateDeathPatterns(deathRecord) {
            const patterns = gameData.deathArchive.patterns;

            // Track killer counts
            const killer = deathRecord.killerType;
            patterns.killerCounts[killer] = (patterns.killerCounts[killer] || 0) + 1;

            // Find most common killer
            let maxKills = 0;
            for (const [k, count] of Object.entries(patterns.killerCounts)) {
                if (count > maxKills) {
                    maxKills = count;
                    patterns.mostCommonKiller = k;
                }
            }

            // Track location counts
            const location = deathRecord.location;
            patterns.locationCounts[location] = (patterns.locationCounts[location] || 0) + 1;

            // Find most dangerous location
            let maxLocationDeaths = 0;
            for (const [loc, count] of Object.entries(patterns.locationCounts)) {
                if (count > maxLocationDeaths) {
                    maxLocationDeaths = count;
                    patterns.mostDangerousLocation = loc;
                }
            }

            // Calculate average survival time
            const totalDeaths = gameData.deathArchive.deaths.length;
            const totalSurvivalTime = gameData.deathArchive.deaths.reduce((sum, d) => sum + (d.survivalDuration || 0), 0);
            patterns.averageSurvivalTime = totalDeaths > 0 ? totalSurvivalTime / totalDeaths : 0;

            // Track time of death pattern
            patterns.timeOfDeathPattern.push(deathRecord.sessionTime);
        }

        // Generate the Archivist's greeting
        function generateArchivistGreeting() {
            const archive = gameData.deathArchive;
            const deathCount = archive.totalDeaths;
            const patterns = archive.patterns;
            const lastDeath = archive.deaths[archive.deaths.length - 1];

            // Determine tier
            let tier;
            if (deathCount <= 5) tier = 'tier1';
            else if (deathCount <= 15) tier = 'tier2';
            else if (deathCount <= 30) tier = 'tier3';
            else if (deathCount <= 50) tier = 'tier4';
            else tier = 'tier5';

            // Get random greeting from tier
            const greetings = ARCHIVIST_GREETINGS[tier];
            let greeting = greetings[Math.floor(Math.random() * greetings.length)];

            // Format duration
            const duration = formatDuration(lastDeath?.survivalDuration || 0);
            const avgTime = formatDuration(patterns.averageSurvivalTime || 0);

            // Determine comparison
            const lastSurvival = lastDeath?.survivalDuration || 0;
            const comparison = lastSurvival > patterns.averageSurvivalTime ? 'longer' : 'shorter';

            // Get killer info
            const killer = lastDeath?.killerType || 'Unknown Entity';
            const killerCount = patterns.killerCounts[killer] || 1;

            // Replace placeholders
            greeting = greeting
                .replace(/{count}/g, deathCount)
                .replace(/{duration}/g, duration)
                .replace(/{avgTime}/g, avgTime)
                .replace(/{comparison}/g, comparison)
                .replace(/{killer}/g, killer)
                .replace(/{killerCount}/g, killerCount);

            return greeting;
        }

        // Generate pattern observation
        function generateArchivistObservation() {
            const archive = gameData.deathArchive;
            const patterns = archive.patterns;
            const lastDeath = archive.deaths[archive.deaths.length - 1];

            if (archive.totalDeaths < 3) return null; // Not enough data

            let observations = [];

            // Check for same killer pattern
            const killer = lastDeath?.killerType;
            const killerCount = patterns.killerCounts[killer] || 0;
            if (killerCount >= 3) {
                const obs = ARCHIVIST_OBSERVATIONS.sameKiller[Math.floor(Math.random() * ARCHIVIST_OBSERVATIONS.sameKiller.length)];
                observations.push(obs.replace(/{killer}/g, killer).replace(/{count}/g, killerCount));
            }

            // Check for same location pattern
            const location = patterns.mostDangerousLocation;
            const locationCount = patterns.locationCounts[location] || 0;
            if (locationCount >= 3) {
                const obs = ARCHIVIST_OBSERVATIONS.sameLocation[Math.floor(Math.random() * ARCHIVIST_OBSERVATIONS.sameLocation.length)];
                observations.push(obs.replace(/{location}/g, location).replace(/{count}/g, locationCount));
            }

            // Check for quick deaths
            const lastSurvival = lastDeath?.survivalDuration || 0;
            if (lastSurvival < 30000 && archive.totalDeaths > 5) { // Less than 30 seconds
                const obs = ARCHIVIST_OBSERVATIONS.quickDeaths[Math.floor(Math.random() * ARCHIVIST_OBSERVATIONS.quickDeaths.length)];
                observations.push(obs.replace(/{duration}/g, formatDuration(lastSurvival)));
            }

            // Check for many deaths
            if (archive.totalDeaths >= 20) {
                const obs = ARCHIVIST_OBSERVATIONS.manyDeaths[Math.floor(Math.random() * ARCHIVIST_OBSERVATIONS.manyDeaths.length)];
                observations.push(obs.replace(/{count}/g, archive.totalDeaths));
            }

            return observations.length > 0 ? observations[Math.floor(Math.random() * observations.length)] : null;
        }

        // Format duration in human-readable form
        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);

            if (hours > 0) {
                return `${hours}h ${minutes % 60}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
            } else {
                return `${seconds}s`;
            }
        }

        // Show the Archivist greeting overlay
        function showArchivistGreeting() {
            const archive = gameData.deathArchive;
            const overlay = document.getElementById('archivist-greeting');
            if (!overlay) return;

            // Update stats
            document.getElementById('archivist-death-count').textContent = archive.totalDeaths;
            document.getElementById('archivist-session-deaths').textContent = archive.sessionDeaths;

            const lastDeath = archive.deaths[archive.deaths.length - 1];
            document.getElementById('archivist-survival-time').textContent = formatDuration(lastDeath?.survivalDuration || 0);

            // Generate and display greeting
            const greeting = generateArchivistGreeting();
            document.getElementById('archivist-message').textContent = greeting;

            // Generate and display observation if available
            const observation = generateArchivistObservation();
            const obsContainer = document.getElementById('archivist-observation-container');
            if (observation) {
                document.getElementById('archivist-observation').textContent = observation;
                obsContainer.style.display = 'block';
            } else {
                obsContainer.style.display = 'none';
            }

            // Show recurring killer info if applicable
            const killer = lastDeath?.killerType;
            const killerCount = archive.patterns.killerCounts[killer] || 0;
            const killerInfo = document.getElementById('archivist-killer-info');
            if (killerCount >= 2) {
                document.getElementById('archivist-killer-name').textContent = killer;
                document.getElementById('archivist-killer-count').textContent = killerCount;
                killerInfo.style.display = 'block';
            } else {
                killerInfo.style.display = 'none';
            }

            // Show overlay
            overlay.classList.add('active');
            archive.lastArchivistGreeting = Date.now();
            saveGameData();
        }

        // Close the Archivist greeting
        function closeArchivistGreeting() {
            const overlay = document.getElementById('archivist-greeting');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        // Enable MEMENTO MORI protocol (called from the prompt)
        function enableMementoMoriProtocol() {
            if (!gameData.deathArchive) initializeArchivistSession();
            gameData.deathArchive.archivistEnabled = true;
            gameData.deathArchive.archivistSpawned = true;
            saveGameData();
            showNotification(' MEMENTO MORI PROTOCOL ACTIVATED - The Archivist is watching...', 'info');
            console.log('[ARCHIVIST] Memento Mori Protocol enabled. Death archive initialized.');
        }

        // Disable MEMENTO MORI protocol
        function disableMementoMoriProtocol() {
            if (gameData.deathArchive) {
                gameData.deathArchive.archivistEnabled = false;
                saveGameData();
            }
            showNotification(' Memento Mori Protocol deactivated.', 'info');
        }

        // Get death archive stats for display
        function getDeathArchiveStats() {
            if (!gameData.deathArchive) return null;
            const archive = gameData.deathArchive;
            return {
                totalDeaths: archive.totalDeaths,
                sessionDeaths: archive.sessionDeaths,
                mostCommonKiller: archive.patterns.mostCommonKiller,
                mostDangerousLocation: archive.patterns.mostDangerousLocation,
                averageSurvivalTime: formatDuration(archive.patterns.averageSurvivalTime || 0),
                killerCounts: archive.patterns.killerCounts,
                locationCounts: archive.patterns.locationCounts,
                archivistEnabled: archive.archivistEnabled
            };
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeArchivistSession();
        });

        function generateCopilotResponse(message) {
            // v6.39: Record interaction and check for lucid moment
            if (typeof lucidityEngine !== 'undefined') {
                lucidityEngine.record();
                if (lucidityEngine.shouldTrigger()) {
                    return lucidityEngine.generate();
                }
            }

            const lowerMessage = message.toLowerCase();

            // v6.37: Check if Epic Narrator personality is selected
            const personality = rappidSettings?.companionPersonality || 'helpful';
            const isEpicNarrator = personality === 'epic-narrator';
            const responses = isEpicNarrator ? EPIC_NARRATOR_RESPONSES : COPILOT_RESPONSES;

            // Context-aware responses
            if (lowerMessage.includes('health') || lowerMessage.includes('hp') || lowerMessage.includes('hurt')) {
                if (gameData.player.hp < gameData.player.maxHp * 0.3) {
                    return getRandomResponse(responses.lowHealth);
                }
                if (isEpicNarrator) {
                    const hpPercent = Math.round((gameData.player.hp / gameData.player.maxHp) * 100);
                    return `The Leviathan's hull integrity stands at ${gameData.player.hp}/${gameData.player.maxHp} - ${hpPercent}% operational. ${hpPercent > 70 ? 'The legend burns bright, ready for any challenge the cosmos dares present!' : 'Wounds mark the hull like battle scars of glory, yet the probe endures!'}`;
                }
                return `Your health is ${gameData.player.hp}/${gameData.player.maxHp}. ${gameData.player.hp < gameData.player.maxHp * 0.5 ? 'Consider healing up!' : 'You\'re in good shape!'}`;
            }

            if (lowerMessage.includes('tip') || lowerMessage.includes('help') || lowerMessage.includes('advice')) {
                return getRandomResponse(responses.tips);
            }

            if (lowerMessage.includes('what') && (lowerMessage.includes('next') || lowerMessage.includes('do'))) {
                return getRandomResponse(responses.whatNext);
            }

            if (lowerMessage.includes('strong') || lowerMessage.includes('level') || lowerMessage.includes('power')) {
                return getRandomResponse(responses.getStronger);
            }

            if (lowerMessage.includes('enemy') || lowerMessage.includes('enemies') || lowerMessage.includes('monster')) {
                return getRandomResponse(responses.enemies);
            }

            if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                return getRandomResponse(responses.greeting);
            }

            if (lowerMessage.includes('explore') || lowerMessage.includes('where')) {
                return getRandomResponse(responses.exploration);
            }

            if (lowerMessage.includes('stats') || lowerMessage.includes('status')) {
                if (isEpicNarrator) {
                    return `SAGA STATUS: The Leviathan has achieved Combat Mastery Level ${gameData.skills.combat.level}. Hull integrity: ${gameData.player.hp}/${gameData.player.maxHp}. Experience toward transcendence: ${gameData.skills.combat.xp}/${gameData.skills.combat.xpNeeded}. The legend grows with every passing moment!`;
                }
                return `Stats: Combat Lvl ${gameData.skills.combat.level}, HP: ${gameData.player.hp}/${gameData.player.maxHp}, XP: ${gameData.skills.combat.xp}/${gameData.skills.combat.xpNeeded}`;
            }

            if (lowerMessage.includes('pet') || lowerMessage.includes('companion')) {
                const activePet = gameData.pets?.active;
                if (activePet) {
                    const pet = PET_TYPES[activePet];
                    if (isEpicNarrator) {
                        return `A loyal companion fights at the Leviathan's side - the legendary ${pet.name} ${pet.icon}! Together they form an alliance that makes the very stars tremble. ${pet.abilityDesc}. The bond between machine and creature transcends the boundaries of the known universe!`;
                    }
                    return `You have ${pet.name} (${pet.icon}) as your pet companion. ${pet.abilityDesc}. You can find more pets by defeating enemies!`;
                }
                if (isEpicNarrator) {
                    return "The Leviathan walks alone through the cosmic void - no companion drone at its side. But perhaps... somewhere in this universe, a worthy ally awaits discovery!";
                }
                return "You don't have an active pet. Defeat enemies to find pet companions that can help you!";
            }

            // Default response
            if (isEpicNarrator) {
                return getRandomResponse(EPIC_NARRATOR_RESPONSES.default);
            }
            const defaults = [
                "I'm here to help! Try asking about tips, enemies, or how to get stronger.",
                "Interesting question! I can help with game tips, enemy locations, and advice.",
                "Let me think... Try asking 'What should I do next?' or 'Give me a tip' for guidance.",
                "I'm your Copilot! Ask me about your health, enemies, or exploration tips."
            ];
            return getRandomResponse(defaults);
        }

        function getRandomResponse(responses) {
            return responses[Math.floor(Math.random() * responses.length)];
        }

        // v5.9: Simple markdown parser for chat messages
        function parseMarkdown(text) {
            if (!text) return '';

            // First, protect markdown links from URL matching
            const linkPlaceholders = [];
            let processedText = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
                const placeholder = `__LINK_${linkPlaceholders.length}__`;
                linkPlaceholders.push({ text: linkText, url: url });
                return placeholder;
            });

            // Convert plain URLs to markdown links (before escaping)
            processedText = processedText.replace(/(^|[\s(])(https?:\/\/[^\s)<]+)/g, (match, prefix, url) => {
                // Shorten URL for display
                let displayUrl = url;
                try {
                    const urlObj = new URL(url);
                    displayUrl = urlObj.hostname + (urlObj.pathname.length > 20 ? urlObj.pathname.substring(0, 20) + '...' : urlObj.pathname);
                } catch (e) {
                    displayUrl = url.length > 40 ? url.substring(0, 40) + '...' : url;
                }
                const placeholder = `__LINK_${linkPlaceholders.length}__`;
                linkPlaceholders.push({ text: displayUrl, url: url });
                return prefix + placeholder;
            });

            let html = processedText
                // Escape HTML first
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')

                // Code blocks (``` ... ```)
                .replace(/```(\w*)\n?([\s\S]*?)```/g, '<pre><code>$2</code></pre>')

                // Inline code (`code`)
                .replace(/`([^`]+)`/g, '<code>$1</code>')

                // Headers (### ## #)
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')

                // Bold (**text** or __text__) - but not our placeholders
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')

                // Italic (*text* or _text_) - but not underscores in placeholders
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')

                // Horizontal rule (---)
                .replace(/^---$/gm, '<hr>')

                // Blockquotes (> text)
                .replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>')

                // Unordered lists (- item)
                .replace(/^- (.+)$/gm, '<li>$1</li>')

                // Numbered lists (1. item)
                .replace(/^\d+\. (.+)$/gm, '<li>$1</li>')

                // Line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');

            // Restore link placeholders
            linkPlaceholders.forEach((link, index) => {
                const placeholder = `__LINK_${index}__`;
                html = html.replace(placeholder, `<a href="${link.url}" target="_blank" rel="noopener noreferrer">${link.text}</a>`);
            });

            // Wrap consecutive <li> elements in <ul>
            html = html.replace(/(<li>.*?<\/li>)(\s*<br>)?/g, '$1');
            html = html.replace(/(<li>[\s\S]*?<\/li>)+/g, '<ul>$&</ul>');

            // Wrap in paragraph if not already wrapped
            if (!html.startsWith('<h') && !html.startsWith('<ul') && !html.startsWith('<pre') && !html.startsWith('<blockquote')) {
                html = '<p>' + html + '</p>';
            }

            // Clean up empty paragraphs
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p><br><\/p>/g, '');

            return html;
        }

        function addCopilotMessage(text, sender) {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `copilot-message ${sender}`;

            if (sender === 'ai') {
                // Parse markdown for AI responses
                messageDiv.innerHTML = parseMarkdown(text);

                // Make sure all links open in new tab
                messageDiv.querySelectorAll('a').forEach(link => {
                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
            } else {
                // Plain text for user messages
                messageDiv.textContent = text;
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showCopilotTyping() {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'copilot-typing';
            typingDiv.className = 'copilot-typing';
            typingDiv.innerHTML = '<div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div>';
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideCopilotTyping() {
            const typing = document.getElementById('copilot-typing');
            if (typing) typing.remove();
        }

        function animateCopilotResponse() {
            if (!copilotMesh || !copilotMesh.userData.orb) return;

            const orb = copilotMesh.userData.orb;
            const originalScale = 1;
            let progress = 0;

            const animate = () => {
                progress += 0.08;
                if (progress > 1) return;

                const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                orb.scale.setScalar(scale);

                if (copilotMesh.userData.light) {
                    copilotMesh.userData.light.intensity = 2 + Math.sin(progress * Math.PI * 2) * 1.5;
                }

                requestAnimationFrame(animate);
            };
            animate();
        }

        function speakCopilotResponse(text) {
            if (!copilotSynthesis) return;

            // Cancel any ongoing speech
            copilotSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.1;
            utterance.volume = 0.8;

            // Try to use a female voice
            const voices = copilotSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.name.includes('Female') || v.name.includes('Samantha') || v.name.includes('Google'));
            if (preferredVoice) utterance.voice = preferredVoice;

            utterance.onstart = () => {
                document.getElementById('copilot-voice-indicator').classList.add('active');
            };

            utterance.onend = () => {
                document.getElementById('copilot-voice-indicator').classList.remove('active');
            };

            copilotSynthesis.speak(utterance);
        }

        // v5.9: Toggle voice input - click to start/stop
        let sttFinalTranscript = '';
        let sttAutoSend = localStorage.getItem('leviathan-stt-autosend') === 'true';

        // Initialize auto-send toggle state on load
        function initAutoSendToggle() {
            const toggle = document.getElementById('stt-auto-send-toggle');
            if (toggle) {
                toggle.checked = sttAutoSend;
            }
        }

        // Toggle auto-send setting
        function toggleAutoSend(enabled) {
            sttAutoSend = enabled;
            localStorage.setItem('leviathan-stt-autosend', enabled ? 'true' : 'false');
            console.log('Auto-send ' + (enabled ? 'enabled' : 'disabled'));
        }

        async function toggleCopilotVoice() {
            if (copilotIsListening) {
                stopCopilotVoice();
                return;
            }

            // Check if Azure Speech SDK should be used
            if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                await startAzureSTT();
            } else if (copilotVoiceRecognition) {
                // Fall back to browser speech recognition
                startBrowserSTT();
            } else {
                console.warn('No speech recognition available');
                alert('Speech recognition not available. Please configure Azure Speech key in RAPPID settings.');
            }
        }

        // Show/hide transcription overlay
        function showSTTOverlay(show) {
            const overlay = document.getElementById('stt-transcription-overlay');
            if (show) {
                overlay.classList.add('active');
                document.getElementById('stt-transcript-text').textContent = 'Speak now...';
                document.getElementById('stt-transcript-text').className = 'stt-transcript-text interim';
                document.getElementById('stt-status').textContent = 'Listening...';
                document.getElementById('stt-waveform').style.display = 'flex';
                document.getElementById('stt-actions').style.display = 'none';
                // Sync auto-send toggle state
                initAutoSendToggle();
            } else {
                overlay.classList.remove('active');
            }
        }

        // Update transcription display
        function updateSTTTranscript(text, isFinal) {
            const textEl = document.getElementById('stt-transcript-text');
            textEl.textContent = text || 'Speak now...';
            textEl.className = 'stt-transcript-text ' + (isFinal ? 'final' : 'interim');

            if (isFinal && text) {
                sttFinalTranscript = text;

                // Check if auto-send is enabled
                if (sttAutoSend) {
                    // Auto-send: show brief confirmation then send
                    document.getElementById('stt-status').textContent = 'Sending...';
                    document.getElementById('stt-waveform').style.display = 'none';
                    // Brief delay so user sees what was transcribed
                    setTimeout(() => {
                        sendSTTMessage();
                    }, 500);
                } else {
                    // Manual confirm: show action buttons
                    document.getElementById('stt-status').textContent = 'Ready to send';
                    document.getElementById('stt-waveform').style.display = 'none';
                    document.getElementById('stt-actions').style.display = 'flex';
                }
            }
        }

        // Send the transcribed message
        function sendSTTMessage() {
            if (sttFinalTranscript) {
                document.getElementById('copilot-chat-input').value = sttFinalTranscript;
                sendCopilotMessage();
            }
            showSTTOverlay(false);
            sttFinalTranscript = '';
        }

        // Cancel STT message
        function cancelSTTMessage() {
            showSTTOverlay(false);
            sttFinalTranscript = '';
            cleanupSTT();
        }

        // Retry STT
        function retrySTT() {
            sttFinalTranscript = '';
            showSTTOverlay(false);
            cleanupSTT();
            setTimeout(() => toggleCopilotVoice(), 200);
        }

        // Browser-based STT fallback
        function startBrowserSTT() {
            if (!copilotVoiceRecognition || copilotIsListening) return;

            try {
                copilotIsListening = true;
                document.getElementById('copilot-voice-btn').classList.add('recording');
                showSTTOverlay(true);
                copilotVoiceRecognition.start();
            } catch (e) {
                console.error('Browser STT error:', e);
                copilotIsListening = false;
                document.getElementById('copilot-voice-btn').classList.remove('recording');
                showSTTOverlay(false);
            }
        }

        // v5.9: Azure Speech-to-Text using Speech SDK with real-time transcription
        let sttInitializing = false;
        async function startAzureSTT() {
            // Prevent multiple simultaneous initializations
            if (sttInitializing || copilotIsListening) {
                console.log('STT already initializing or listening');
                return;
            }

            sttInitializing = true;
            sttFinalTranscript = '';

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser STT');
                    sttInitializing = false;
                    startBrowserSTT();
                    return;
                }

                // Clean up any existing recognizer first
                if (speechRecognizer) {
                    try {
                        speechRecognizer.close();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                    speechRecognizer = null;
                    // Small delay to ensure cleanup
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Request microphone permission first
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // Stop the test stream immediately
                    stream.getTracks().forEach(track => track.stop());
                } catch (permError) {
                    console.error('Microphone permission denied:', permError);
                    alert('Microphone access denied. Please allow microphone access to use voice input.');
                    sttInitializing = false;
                    return;
                }

                // Show the overlay
                showSTTOverlay(true);

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechRecognitionLanguage = 'en-US';

                // Use default microphone
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();

                // Create recognizer
                speechRecognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

                // Set up event handlers for real-time transcription
                let interimTranscript = '';

                // Recognizing event - fires with interim results
                speechRecognizer.recognizing = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
                        interimTranscript = e.result.text;
                        console.log('Azure STT interim:', interimTranscript);
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                // Recognized event - fires with final result
                speechRecognizer.recognized = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
                        const finalText = e.result.text;
                        console.log('Azure STT final:', finalText);
                        if (finalText && finalText.trim()) {
                            updateSTTTranscript(finalText, true);
                            // Stop continuous recognition after getting result
                            speechRecognizer.stopContinuousRecognitionAsync();
                        }
                    } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
                        console.log('Azure STT: No speech recognized');
                        updateSTTTranscript('No speech detected. Try again.', false);
                    }
                };

                // Canceled event
                speechRecognizer.canceled = (s, e) => {
                    console.warn('Azure STT canceled:', e.reason);
                    if (e.errorDetails) {
                        console.warn('Error details:', e.errorDetails);
                    }
                    cleanupSTT();
                    showSTTOverlay(false);
                };

                // Session stopped event
                speechRecognizer.sessionStopped = (s, e) => {
                    console.log('Azure STT session stopped');
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotIsListening = true;
                sttInitializing = false;
                document.getElementById('copilot-voice-btn').classList.add('recording');

                console.log('Azure STT: Starting continuous recognition...');

                // Start continuous recognition for real-time transcription
                speechRecognizer.startContinuousRecognitionAsync(
                    () => {
                        console.log('Azure STT: Continuous recognition started');
                    },
                    (error) => {
                        console.error('Azure STT start error:', error);
                        cleanupSTT();
                        showSTTOverlay(false);
                    }
                );
            } catch (error) {
                console.error('Azure STT initialization error:', error);
                sttInitializing = false;
                cleanupSTT();
                showSTTOverlay(false);

                // Fall back to browser STT
                startBrowserSTT();
            }
        }

        // Clean up STT resources
        function cleanupSTT() {
            copilotIsListening = false;
            sttInitializing = false;
            document.getElementById('copilot-voice-btn').classList.remove('recording');

            if (speechRecognizer) {
                try {
                    speechRecognizer.stopContinuousRecognitionAsync(
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        },
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        }
                    );
                } catch (e) {
                    try { speechRecognizer.close(); } catch(e2) {}
                    speechRecognizer = null;
                }
            }
        }

        function stopCopilotVoice() {
            // Stop Azure STT if active
            cleanupSTT();
            showSTTOverlay(false);

            // Stop browser STT if active
            if (copilotVoiceRecognition) {
                try {
                    copilotVoiceRecognition.stop();
                } catch (e) {
                    // Ignore
                }
            }
        }

        // Check for 3D copilot click
        function checkCopilotClick(event) {
            if (!copilotMesh || mode !== 'world') return false;

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(copilotMesh, true);
            if (intersects.length > 0) {
                toggleCopilotChat();
                return true;
            }
            return false;
        }

        // Contextual notifications from copilot
        let lastCopilotNotification = 0;
        function triggerCopilotContextualHelp(context) {
            const now = performance.now();
            if (now - lastCopilotNotification < 30000) return; // 30 second cooldown

            let message = '';
            switch (context) {
                case 'lowHealth':
                    message = getRandomResponse(COPILOT_RESPONSES.lowHealth);
                    break;
                case 'nearEnemy':
                    if (Math.random() < 0.3) message = getRandomResponse(COPILOT_RESPONSES.nearEnemy);
                    break;
                case 'afterKill':
                    if (Math.random() < 0.2) message = getRandomResponse(COPILOT_RESPONSES.afterKill);
                    break;
            }

            if (message) {
                lastCopilotNotification = now;
                addCopilotMessage(message, 'ai');
                if (copilotChatOpen) {
                    speakCopilotResponse(message);
                }
            }
        }

        // ============================================
        // v5.7: RAPPID INTEGRATION SYSTEM
        // AI-powered responses via external endpoints
        // ============================================
        const RAPPID_STORAGE_KEY = 'leviathan-rappid-settings';
        let rappidSettings = {
            rappid: false,
            endpoints: {},
            azureTTSKey: '',
            azureRegion: '',
            ttsVoiceName: 'en-US-JennyNeural',
            version: '1.0'
        };

        function loadRappidSettings() {
            try {
                const saved = localStorage.getItem(RAPPID_STORAGE_KEY);
                if (saved) {
                    rappidSettings = JSON.parse(saved);
                    console.log('RAPPID settings loaded');
                    updateRappidUI();
                }
            } catch (e) {
                console.error('Failed to load RAPPID settings:', e);
            }
        }

        function saveRappidSettings() {
            try {
                localStorage.setItem(RAPPID_STORAGE_KEY, JSON.stringify(rappidSettings));
                console.log('RAPPID settings saved');
            } catch (e) {
                console.error('Failed to save RAPPID settings:', e);
            }
        }

        // v5.7: AI Settings Modal Functions
        function openRappidModal() {
            document.getElementById('ai-settings-modal').classList.add('active');
            updateAISettingsUI();
            // v5.14: Initialize endpoint profiles UI
            renderEndpointProfilesList();
            refreshProfileSelects();
        }

        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').classList.remove('active');
        }

        // Alias for backwards compatibility
        function closeRappidModal() {
            closeAISettingsModal();
        }

        function switchAITab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.ai-settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.ai-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('ai-tab-' + tabName).classList.add('active');
        }

        function updateAISettingsUI() {
            // Update General tab - API fields
            const activeEndpoint = getActiveEndpoint();
            if (activeEndpoint) {
                document.getElementById('ai-api-key').value = activeEndpoint.key || '';
                document.getElementById('ai-api-endpoint').value = activeEndpoint.url || '';
            }

            // Update endpoints list in General tab
            const endpointsList = document.getElementById('ai-endpoints-list');
            if (endpointsList && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsList.innerHTML = '<label style="display:block; margin: 15px 0 10px; font-size: 12px; color: #aaa;">Available Endpoints</label>';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsList.appendChild(div);
                });
            } else if (endpointsList) {
                endpointsList.innerHTML = '';
            }

            // Update Voice tab - TTS settings
            if (rappidSettings.azureTTSKey) {
                document.getElementById('ai-tts-key').value = rappidSettings.azureTTSKey;
            }
            if (rappidSettings.azureRegion) {
                document.getElementById('ai-tts-region').value = rappidSettings.azureRegion;
            }
            if (rappidSettings.ttsVoiceName) {
                document.getElementById('ai-tts-voice').value = rappidSettings.ttsVoiceName;
            }

            // Update Import/Export tab - endpoints preview
            const endpointsPreview = document.getElementById('ai-endpoints-preview');
            if (endpointsPreview && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsPreview.innerHTML = '';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsPreview.appendChild(div);
                });
            } else if (endpointsPreview) {
                endpointsPreview.innerHTML = '<div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center; color: #888;">No endpoints configured yet</div>';
            }

            // Update connection status
            const statusDiv = document.getElementById('ai-connection-status');
            if (statusDiv) {
                if (activeEndpoint) {
                    statusDiv.innerHTML = `
                        <div style="color: #06ffa5; margin-bottom: 5px;">Connected to: ${activeEndpoint.name}</div>
                        <div style="font-size: 11px; color: #666;">${activeEndpoint.url}</div>
                    `;
                } else {
                    statusDiv.innerHTML = '<span style="color: #888;">No endpoint configured</span>';
                }
            }
        }

        function saveAISettings() {
            // Save API settings from General tab
            const apiKey = document.getElementById('ai-api-key').value;
            const apiEndpoint = document.getElementById('ai-api-endpoint').value;

            // If user entered new endpoint details, create/update a custom endpoint
            if (apiKey && apiEndpoint) {
                const customId = 'custom-' + Date.now();
                rappidSettings.endpoints = rappidSettings.endpoints || {};

                // Check if updating existing or adding new
                const activeEndpoint = getActiveEndpoint();
                if (activeEndpoint) {
                    activeEndpoint.key = apiKey;
                    activeEndpoint.url = apiEndpoint;
                } else {
                    rappidSettings.endpoints[customId] = {
                        id: customId,
                        name: 'Custom Endpoint',
                        url: apiEndpoint,
                        key: apiKey,
                        guid: 'custom-guid',
                        active: true
                    };
                }
                rappidSettings.rappid = true;
            }

            // Save Voice settings
            rappidSettings.azureTTSKey = document.getElementById('ai-tts-key').value;
            rappidSettings.azureRegion = document.getElementById('ai-tts-region').value;
            rappidSettings.ttsVoiceName = document.getElementById('ai-tts-voice').value;

            // Save companion settings
            rappidSettings.companionName = document.getElementById('ai-companion-name').value;
            rappidSettings.companionPersonality = document.getElementById('ai-companion-personality').value;
            rappidSettings.voiceEnabled = document.getElementById('ai-voice-enabled').checked;
            rappidSettings.autoSpeak = document.getElementById('ai-auto-speak').checked;
            rappidSettings.voiceInputEnabled = document.getElementById('ai-voice-input-enabled').checked;
            rappidSettings.continuousMode = document.getElementById('ai-continuous-mode').checked;
            rappidSettings.pttKey = document.getElementById('ai-ptt-key').value;

            // Save 3D view settings
            rappidSettings.primaryColor = document.getElementById('ai-primary-color').value;
            rappidSettings.glowColor = document.getElementById('ai-glow-color').value;
            rappidSettings.companionSize = document.getElementById('ai-companion-size').value;
            rappidSettings.showParticles = document.getElementById('ai-show-particles').checked;
            rappidSettings.enableGlow = document.getElementById('ai-enable-glow').checked;
            rappidSettings.followDistance = parseFloat(document.getElementById('ai-follow-distance').value);
            rappidSettings.floatHeight = parseFloat(document.getElementById('ai-float-height').value);

            saveRappidSettings();
            showAIStatusMessage('Settings saved successfully!', 'success');
            showNotification('AI Companion settings saved!');

            // Apply 3D settings immediately if companion exists
            applyCompanionSettings();
        }

        function applyCompanionSettings() {
            // Update COPILOT_CONFIG with new settings
            if (rappidSettings.followDistance) COPILOT_CONFIG.followDistance = rappidSettings.followDistance;
            if (rappidSettings.floatHeight) COPILOT_CONFIG.floatHeight = rappidSettings.floatHeight;
            if (rappidSettings.primaryColor) COPILOT_CONFIG.color = parseInt(rappidSettings.primaryColor.replace('#', '0x'));
            if (rappidSettings.glowColor) COPILOT_CONFIG.glowColor = parseInt(rappidSettings.glowColor.replace('#', '0x'));

            // Recreate mesh with new settings
            if (copilotMesh && mode === 'world') {
                createCopilotMesh();
            }
        }

        function showAIStatusMessage(message, type) {
            const statusEl = document.getElementById('ai-status-message');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = 'ai-status-msg ' + type;
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.className = 'ai-status-msg';
                }, 3000);
            }
        }

        // Alias for backwards compatibility
        function showRappidStatus(message, type) {
            showAIStatusMessage(message, type);
        }

        // Keep old updateRappidUI for backwards compatibility
        function updateRappidUI() {
            updateAISettingsUI();
        }

        // Color picker sync
        document.addEventListener('DOMContentLoaded', function() {
            // Primary color sync
            const primaryColor = document.getElementById('ai-primary-color');
            const primaryHex = document.getElementById('ai-primary-color-hex');
            if (primaryColor && primaryHex) {
                primaryColor.addEventListener('input', () => primaryHex.value = primaryColor.value);
                primaryHex.addEventListener('input', () => primaryColor.value = primaryHex.value);
            }

            // Glow color sync
            const glowColor = document.getElementById('ai-glow-color');
            const glowHex = document.getElementById('ai-glow-color-hex');
            if (glowColor && glowHex) {
                glowColor.addEventListener('input', () => glowHex.value = glowColor.value);
                glowHex.addEventListener('input', () => glowColor.value = glowHex.value);
            }
        });

        function setActiveEndpoint(endpointId) {
            Object.values(rappidSettings.endpoints).forEach(ep => {
                ep.active = ep.id === endpointId;
            });
            saveRappidSettings();
            updateRappidUI();
            showRappidStatus('Endpoint activated: ' + rappidSettings.endpoints[endpointId]?.name, 'success');
        }

        function getActiveEndpoint() {
            return Object.values(rappidSettings.endpoints).find(ep => ep.active);
        }

        // v6.36: Updated to use smart import for backwards compatibility
        function importRappidSettings(event) {
            // Delegate to smart import which handles all formats
            importRappidSmartBackup(event);
        }

        function exportRappidSettings() {
            if (!rappidSettings.rappid) {
                showRappidStatus('No RAPPID settings to export', 'error');
                return;
            }

            const exportData = {
                rappid: true,
                backupType: 'RAPPID Settings Backup',
                endpoints: rappidSettings.endpoints,
                azureTTSKey: rappidSettings.azureTTSKey,
                azureRegion: rappidSettings.azureRegion,
                ttsVoiceName: rappidSettings.ttsVoiceName,
                exportDate: new Date().toISOString(),
                version: rappidSettings.version
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `leviathan-rappid-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showRappidStatus('RAPPID settings exported!', 'success');
        }

        // ============================================
        // v6.36: RAPPID FULL BACKUP SYSTEM
        // Backwards-compatible full game state backup
        // ============================================

        const RAPPID_BACKUP_VERSION = '2.0';

        const RAPPID_BACKUP_TYPES = {
            SETTINGS_ONLY: 'RAPPID Settings Backup',      // v1.0 - Original format (AI settings only)
            FULL_BACKUP: 'RAPPID Full Backup',            // v2.0 - AI settings + game state
            GAME_SAVE_ONLY: 'RAPPID Game Save Only'       // v2.0 - Game state without AI settings
        };

        // Export full backup (RAPPID settings + game state)
        function exportRappidFullBackup() {
            // Save current game state first
            if (typeof saveGameData === 'function') {
                saveGameData();
            }

            const exportData = {
                rappid: true,
                backupType: RAPPID_BACKUP_TYPES.FULL_BACKUP,
                version: RAPPID_BACKUP_VERSION,
                exportDate: new Date().toISOString(),
                metadata: {
                    gameVersion: VERSION,
                    playtime: gameData.playtime || 0,
                    playtimeFormatted: formatPlaytime(gameData.playtime || 0),
                    bossesDefeated: gameData.statistics?.bossesDefeated || 0,
                    mobsKilled: gameData.statistics?.mobsKilled || 0,
                    planetsVisited: gameData.visitedPlanets?.length || 0,
                    chronicleEntries: gameData.chronicle?.entries?.length || 0,
                    skillLevels: Object.fromEntries(
                        Object.entries(gameData.skills || {}).map(([k, v]) => [k, v.level])
                    ),
                    prestigeLevel: gameData.prestige?.level || 0,
                    inventoryCount: gameData.inventory?.length || 0,
                    petsOwned: gameData.pets?.owned?.length || 0
                },
                rappidSettings: rappidSettings.rappid ? {
                    rappid: rappidSettings.rappid,
                    endpoints: rappidSettings.endpoints,
                    azureTTSKey: rappidSettings.azureTTSKey,
                    azureRegion: rappidSettings.azureRegion,
                    ttsVoiceName: rappidSettings.ttsVoiceName,
                    companionPersonality: rappidSettings.companionPersonality,
                    version: rappidSettings.version
                } : null,
                gameState: JSON.parse(JSON.stringify(gameData)) // Deep clone
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `leviathan-full-backup-${timestamp}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showRappidStatus('Full backup exported successfully!', 'success');
            showNotification(' Full backup saved! Includes game state + RAPPID settings.', 'success');
        }

        // Export game save only (without RAPPID settings)
        function exportGameSaveOnly() {
            // Save current game state first
            if (typeof saveGameData === 'function') {
                saveGameData();
            }

            const exportData = {
                rappid: true, // Keep this for format detection
                backupType: RAPPID_BACKUP_TYPES.GAME_SAVE_ONLY,
                version: RAPPID_BACKUP_VERSION,
                exportDate: new Date().toISOString(),
                metadata: {
                    gameVersion: VERSION,
                    playtime: gameData.playtime || 0,
                    playtimeFormatted: formatPlaytime(gameData.playtime || 0),
                    bossesDefeated: gameData.statistics?.bossesDefeated || 0,
                    mobsKilled: gameData.statistics?.mobsKilled || 0,
                    planetsVisited: gameData.visitedPlanets?.length || 0,
                    chronicleEntries: gameData.chronicle?.entries?.length || 0,
                    skillLevels: Object.fromEntries(
                        Object.entries(gameData.skills || {}).map(([k, v]) => [k, v.level])
                    ),
                    prestigeLevel: gameData.prestige?.level || 0
                },
                gameState: JSON.parse(JSON.stringify(gameData)) // Deep clone
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `leviathan-save-${timestamp}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification(' Game save exported!', 'success');
        }

        // Smart import that detects backup type and handles appropriately
        function importRappidSmartBackup(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Detect backup type
                    if (!imported.rappid) {
                        // Legacy game save format (pre-RAPPID)
                        handleLegacyGameSave(imported);
                        return;
                    }

                    switch (imported.backupType) {
                        case RAPPID_BACKUP_TYPES.SETTINGS_ONLY:
                            // v1.0 format - settings only
                            handleSettingsOnlyImport(imported);
                            break;

                        case RAPPID_BACKUP_TYPES.FULL_BACKUP:
                            // v2.0 format - full backup with game state
                            handleFullBackupImport(imported);
                            break;

                        case RAPPID_BACKUP_TYPES.GAME_SAVE_ONLY:
                            // v2.0 format - game state only
                            handleGameSaveOnlyImport(imported);
                            break;

                        default:
                            // Unknown but has rappid flag - try v1.0 settings import
                            if (imported.endpoints) {
                                handleSettingsOnlyImport(imported);
                            } else {
                                showRappidStatus('Unknown backup format', 'error');
                            }
                    }
                } catch (error) {
                    console.error('RAPPID import error:', error);
                    showRappidStatus('Failed to import: Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Handle v1.0 settings-only import (backwards compatible)
        function handleSettingsOnlyImport(imported) {
            rappidSettings = {
                rappid: true,
                backupType: imported.backupType,
                endpoints: imported.endpoints || {},
                azureTTSKey: imported.azureTTSKey || '',
                azureRegion: imported.azureRegion || '',
                ttsVoiceName: imported.ttsVoiceName || 'en-US-JennyNeural',
                companionPersonality: imported.companionPersonality || 'helpful',
                exportDate: imported.exportDate,
                version: imported.version || '1.0'
            };
            saveRappidSettings();
            updateRappidUI();
            showRappidStatus('RAPPID settings imported successfully!', 'success');
            showNotification(' RAPPID settings imported! Copilot is now AI-powered.');
        }

        // Handle v2.0 full backup import
        function handleFullBackupImport(imported) {
            const metadata = imported.metadata || {};

            // Show confirmation dialog
            const confirmMsg = `Import Full Backup?\n\n` +
                ` Export Date: ${new Date(imported.exportDate).toLocaleString()}\n` +
                ` Game Version: ${metadata.gameVersion || 'Unknown'}\n` +
                ` Playtime: ${metadata.playtimeFormatted || 'Unknown'}\n` +
                ` Bosses Defeated: ${metadata.bossesDefeated || 0}\n` +
                ` Planets Visited: ${metadata.planetsVisited || 0}\n` +
                ` Chronicle Entries: ${metadata.chronicleEntries || 0}\n\n` +
                `This will replace your current save AND RAPPID settings.\n` +
                `Continue?`;

            if (!confirm(confirmMsg)) {
                showRappidStatus('Import cancelled', '');
                return;
            }

            // Import RAPPID settings if present
            if (imported.rappidSettings) {
                rappidSettings = {
                    rappid: true,
                    endpoints: imported.rappidSettings.endpoints || {},
                    azureTTSKey: imported.rappidSettings.azureTTSKey || '',
                    azureRegion: imported.rappidSettings.azureRegion || '',
                    ttsVoiceName: imported.rappidSettings.ttsVoiceName || 'en-US-JennyNeural',
                    companionPersonality: imported.rappidSettings.companionPersonality || 'helpful',
                    version: imported.rappidSettings.version || '1.0'
                };
                saveRappidSettings();
            }

            // Import game state
            if (imported.gameState) {
                const newGameData = imported.gameState;
                // Merge carefully to preserve structure
                Object.assign(gameData, newGameData);
                gameData.skills = { ...gameData.skills, ...newGameData.skills };
                gameData.player = { ...gameData.player, ...newGameData.player };
                gameData.statistics = { ...gameData.statistics, ...newGameData.statistics };
                if (newGameData.chronicle) gameData.chronicle = newGameData.chronicle;
                if (newGameData.prestige) gameData.prestige = newGameData.prestige;
                if (newGameData.inventory) gameData.inventory = newGameData.inventory;
                if (newGameData.pets) gameData.pets = newGameData.pets;

                saveGameData();
            }

            updateRappidUI();
            updateAllUI();
            showRappidStatus('Full backup imported successfully!', 'success');
            showNotification(' Full backup restored! Game state + RAPPID settings loaded.', 'success');
        }

        // Handle v2.0 game save only import
        function handleGameSaveOnlyImport(imported) {
            const metadata = imported.metadata || {};

            // Show confirmation dialog
            const confirmMsg = `Import Game Save?\n\n` +
                ` Export Date: ${new Date(imported.exportDate).toLocaleString()}\n` +
                ` Game Version: ${metadata.gameVersion || 'Unknown'}\n` +
                ` Playtime: ${metadata.playtimeFormatted || 'Unknown'}\n` +
                ` Bosses Defeated: ${metadata.bossesDefeated || 0}\n` +
                ` Planets Visited: ${metadata.planetsVisited || 0}\n\n` +
                `This will replace your current save.\n` +
                `Your RAPPID settings will be preserved.\n` +
                `Continue?`;

            if (!confirm(confirmMsg)) {
                showNotification('Import cancelled', 'info');
                return;
            }

            // Import game state only
            if (imported.gameState) {
                const newGameData = imported.gameState;
                Object.assign(gameData, newGameData);
                gameData.skills = { ...gameData.skills, ...newGameData.skills };
                gameData.player = { ...gameData.player, ...newGameData.player };
                gameData.statistics = { ...gameData.statistics, ...newGameData.statistics };
                if (newGameData.chronicle) gameData.chronicle = newGameData.chronicle;
                if (newGameData.prestige) gameData.prestige = newGameData.prestige;
                if (newGameData.inventory) gameData.inventory = newGameData.inventory;
                if (newGameData.pets) gameData.pets = newGameData.pets;

                saveGameData();
            }

            updateAllUI();
            showNotification(' Game save restored!', 'success');
        }

        // Handle legacy (pre-RAPPID) game saves
        function handleLegacyGameSave(imported) {
            // Check if it looks like a game save
            if (imported.version || imported.skills || imported.statistics || imported.inventory) {
                const confirmMsg = `Import Legacy Game Save?\n\n` +
                    `This appears to be an older save format.\n` +
                    `Continue?`;

                if (!confirm(confirmMsg)) {
                    showNotification('Import cancelled', 'info');
                    return;
                }

                Object.assign(gameData, imported);
                if (imported.skills) gameData.skills = { ...gameData.skills, ...imported.skills };
                if (imported.player) gameData.player = { ...gameData.player, ...imported.player };
                if (imported.statistics) gameData.statistics = { ...gameData.statistics, ...imported.statistics };

                saveGameData();
                updateAllUI();
                showNotification(' Legacy save imported!', 'success');
            } else {
                showRappidStatus('Unrecognized file format', 'error');
            }
        }

        // Update all UI elements after import
        function updateAllUI() {
            if (typeof updateSkillsUI === 'function') updateSkillsUI();
            if (typeof updateInventoryUI === 'function') updateInventoryUI();
            if (typeof updateHealthUI === 'function') updateHealthUI();
            if (typeof updateChronicleUI === 'function') updateChronicleUI();
            if (typeof updateCodexDisplay === 'function') updateCodexDisplay();
            if (typeof updateQuestUI === 'function') updateQuestUI();
            if (typeof updatePrestigeUI === 'function') updatePrestigeUI();
            if (typeof updateDailyChallenge === 'function') updateDailyChallenge();
        }

        // Format playtime for display
        function formatPlaytime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            }
            return `${minutes}m`;
        }

        // Show backup options modal
        function showBackupOptionsModal() {
            const existingModal = document.getElementById('backup-options-modal');
            if (existingModal) existingModal.remove();

            const modal = document.createElement('div');
            modal.id = 'backup-options-modal';
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 450px; background: linear-gradient(135deg, rgba(20,20,30,0.98), rgba(30,30,50,0.98));">
                    <button class="modal-close" onclick="document.getElementById('backup-options-modal').remove()">&times;</button>
                    <div class="modal-title" style="color: #ffd700;"> RAPPID Backup Center</div>

                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 8px;">
                        <div style="font-size: 12px; color: #aaa; margin-bottom: 8px;">Current Save Status</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                            <div> Playtime: <span style="color: #ffd700;">${formatPlaytime(gameData.playtime || 0)}</span></div>
                            <div> Bosses: <span style="color: #ffd700;">${gameData.statistics?.bossesDefeated || 0}</span></div>
                            <div> Planets: <span style="color: #ffd700;">${gameData.visitedPlanets?.length || 0}</span></div>
                            <div> Chronicle: <span style="color: #ffd700;">${gameData.chronicle?.entries?.length || 0}</span></div>
                            <div> RAPPID: <span style="color: ${rappidSettings.rappid ? '#00ff00' : '#ff6666'};">${rappidSettings.rappid ? 'Configured' : 'Not Set'}</span></div>
                            <div> Prestige: <span style="color: #aa88ff;">${gameData.prestige?.level || 0}</span></div>
                        </div>
                    </div>

                    <div style="font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 12px;">Export Options</div>

                    <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px;">
                        <button onclick="exportRappidFullBackup(); document.getElementById('backup-options-modal').remove();"
                            style="padding: 12px; background: linear-gradient(135deg, #ffd700, #ff8c00); border: none; border-radius: 6px; color: #000; font-weight: bold; cursor: pointer; text-align: left;">
                            <div style="font-size: 14px;"> Full Backup</div>
                            <div style="font-size: 11px; opacity: 0.8;">Game state + RAPPID settings + Chronicle</div>
                        </button>

                        <button onclick="exportGameSaveOnly(); document.getElementById('backup-options-modal').remove();"
                            style="padding: 12px; background: rgba(100,100,255,0.2); border: 1px solid #6666ff; border-radius: 6px; color: #fff; cursor: pointer; text-align: left;">
                            <div style="font-size: 14px;"> Game Save Only</div>
                            <div style="font-size: 11px; opacity: 0.7;">Just your progress (no API keys)</div>
                        </button>

                        <button onclick="exportRappidSettings(); document.getElementById('backup-options-modal').remove();"
                            style="padding: 12px; background: rgba(100,100,100,0.3); border: 1px solid #666; border-radius: 6px; color: #fff; cursor: pointer; text-align: left;"
                            ${!rappidSettings.rappid ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                            <div style="font-size: 14px;"> RAPPID Settings Only</div>
                            <div style="font-size: 11px; opacity: 0.7;">API endpoints + TTS config (minimal)</div>
                        </button>
                    </div>

                    <div style="font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 12px;">Import</div>

                    <button onclick="document.getElementById('rappidSmartImportFile').click();"
                        style="width: 100%; padding: 12px; background: rgba(0,200,100,0.2); border: 1px solid #00c864; border-radius: 6px; color: #fff; cursor: pointer;">
                        <div style="font-size: 14px;"> Import Backup</div>
                        <div style="font-size: 11px; opacity: 0.7;">Auto-detects format (Full, Save, or Settings)</div>
                    </button>
                    <input type="file" id="rappidSmartImportFile" accept=".json" style="display: none;" onchange="importRappidSmartBackup(event); document.getElementById('backup-options-modal').remove();">

                    <div style="margin-top: 15px; padding: 10px; background: rgba(100,100,100,0.2); border-radius: 6px; font-size: 10px; color: #888;">
                         <strong>Tip:</strong> Full Backup is recommended for complete restoration. Use "Game Save Only" when sharing progress without exposing API keys.
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // ============================================
        // v6.37: RAPPID DATA HUB
        // Modular export/import for all game systems
        // ============================================

        const RAPPID_DATA_MODULES = {
            galaxy: {
                name: 'Galaxy State',
                icon: '',
                desc: 'All planets with orbital mechanics',
                color: '#4488ff',
                getData: () => {
                    try {
                        return {
                            civilizations: (typeof civilizations !== 'undefined' && civilizations) ? civilizations.map(civ => ({
                                id: civ.id,
                                name: civ.name,
                                biome: civ.biome,
                                biomeName: civ.biomeName,
                                pop: civ.pop,
                                visited: civ.visited,
                                x: civ.x, y: civ.y, z: civ.z,
                                color: civ.color && civ.color.getHexString ? `#${civ.color.getHexString()}` : null,
                                orbital: civ.orbital
                            })) : [],
                            worldSeed: (typeof multiplayerState !== 'undefined' && multiplayerState) ? multiplayerState.worldSeed : 'default',
                            physicsParams: typeof physicsParams !== 'undefined' ? physicsParams : null,
                            totalPlanets: (typeof civilizations !== 'undefined' && civilizations) ? civilizations.length : 0,
                            visitedPlanets: gameData?.visitedPlanets || []
                        };
                    } catch (e) {
                        console.error('Galaxy getData error:', e);
                        return { civilizations: [], totalPlanets: 0, visitedPlanets: [] };
                    }
                },
                setData: (data) => {
                    if (data.visitedPlanets) gameData.visitedPlanets = data.visitedPlanets;
                    // Note: Galaxy is regenerated from seed, so we mainly restore visit state
                    saveGameData();
                }
            },
            currentPlanet: {
                name: 'Current Planet',
                icon: '',
                desc: 'Active planet state & structures',
                color: '#00ff88',
                getData: () => {
                    try {
                        if (typeof activeCiv === 'undefined' || !activeCiv) return null;
                        const ws = typeof worldState !== 'undefined' ? worldState : {};
                        return {
                            planetId: activeCiv.id,
                            planetName: activeCiv.name,
                            biome: activeCiv.biome,
                            worldState: {
                                playerPosition: ws.player ? {
                                    x: ws.player.position.x,
                                    y: ws.player.position.y,
                                    z: ws.player.position.z,
                                    rotationY: ws.player.rotation.y
                                } : null,
                                timeOfDay: ws.timeOfDay || 0,
                                structures: ws.structures?.map(s => ({
                                    type: s.type || 'structure',
                                    x: s.position?.x, y: s.position?.y, z: s.position?.z
                                })) || [],
                                terraformedAreas: ws.terraformedAreas || [],
                                mobCount: ws.mobs?.length || 0,
                                interactableCount: ws.interactables?.length || 0
                            },
                            droppedItems: gameData?.droppedItems?.[activeCiv.id] || [],
                            discoveredPOIs: gameData?.discoveredPOIs?.[activeCiv.id] || [],
                            exploredTiles: gameData?.exploredTiles?.[activeCiv.id] || {}
                        };
                    } catch (e) {
                        console.error('CurrentPlanet getData error:', e);
                        return null;
                    }
                },
                setData: (data) => {
                    if (data.planetId !== undefined && data.droppedItems) {
                        if (!gameData.droppedItems) gameData.droppedItems = {};
                        gameData.droppedItems[data.planetId] = data.droppedItems;
                    }
                    if (data.planetId !== undefined && data.discoveredPOIs) {
                        if (!gameData.discoveredPOIs) gameData.discoveredPOIs = {};
                        gameData.discoveredPOIs[data.planetId] = data.discoveredPOIs;
                    }
                    saveGameData();
                }
            },
            genesis: {
                name: 'Genesis Simulation',
                icon: '',
                desc: 'Civilization evolution state',
                color: '#aa66ff',
                getData: () => {
                    try {
                        if (typeof genesisState === 'undefined' || !genesisState) return null;
                        if (!genesisState.active && (!genesisState.entities || genesisState.entities.length === 0)) return null;
                        return {
                            active: genesisState.active,
                            paused: genesisState.paused,
                            speed: genesisState.speed,
                            tick: genesisState.tick,
                            entities: (genesisState.entities || []).map(e => ({
                                id: e.id, x: e.x, z: e.z,
                                energy: e.energy, age: e.age,
                                faction: e.faction, lineage: e.lineage,
                                alive: e.alive, generation: e.generation,
                                reproductionCooldown: e.reproductionCooldown
                            })),
                            resources: (genesisState.resources || []).map(r => ({
                                x: r.x, z: r.z, amount: r.amount
                            })),
                            territory: genesisState.territory || {},
                            factions: genesisState.factions || {},
                            stats: genesisState.stats || {},
                            events: (genesisState.events || []).slice(-100)
                        };
                    } catch (e) {
                        console.error('Genesis getData error:', e);
                        return null;
                    }
                },
                setData: (data) => {
                    if (data.entities) {
                        genesisState.entities = data.entities;
                        genesisState.resources = data.resources || [];
                        genesisState.territory = data.territory || {};
                        genesisState.factions = data.factions || {};
                        genesisState.stats = data.stats || genesisState.stats;
                        genesisState.tick = data.tick || 0;
                        genesisState.speed = data.speed || 1;
                        genesisState.paused = data.paused || false;
                        genesisState.events = data.events || [];
                    }
                }
            },
            copilot: {
                name: 'Copilot History',
                icon: '',
                desc: 'AI conversation transcript',
                color: '#00ffff',
                getData: () => {
                    try {
                        const history = typeof copilotConversationHistory !== 'undefined' ? copilotConversationHistory : [];
                        const settings = typeof rappidSettings !== 'undefined' ? rappidSettings : {};
                        return {
                            conversationHistory: history || [],
                            messageCount: history?.length || 0,
                            rappidEnabled: settings.rappid || false,
                            personality: settings.companionPersonality || 'helpful'
                        };
                    } catch (e) {
                        console.error('Copilot getData error:', e);
                        return { conversationHistory: [], messageCount: 0 };
                    }
                },
                setData: (data) => {
                    if (data.conversationHistory) {
                        copilotConversationHistory = data.conversationHistory;
                        if (typeof updateCopilotChatUI === 'function') updateCopilotChatUI();
                    }
                }
            },
            agentFleet: {
                name: 'Agent Fleet',
                icon: '',
                desc: 'Multi-agent swarm state',
                color: '#ff8800',
                getData: () => {
                    try {
                        const fleet = typeof agentFleet !== 'undefined' ? agentFleet : [];
                        return {
                            agents: (fleet || []).map(agent => ({
                                id: agent.id,
                                name: agent.name,
                                type: agent.type,
                                status: agent.status,
                                mission: agent.mission,
                                conversationHistory: agent.conversationHistory || [],
                                totalEarnings: agent.totalEarnings,
                                spawnTime: agent.spawnTime,
                                position: agent.mesh ? {
                                    x: agent.mesh.position.x,
                                    y: agent.mesh.position.y,
                                    z: agent.mesh.position.z
                                } : null
                            })),
                            totalAgents: fleet?.length || 0,
                            maxAgents: typeof MAX_AGENTS !== 'undefined' ? MAX_AGENTS : 8
                        };
                    } catch (e) {
                        console.error('AgentFleet getData error:', e);
                        return { agents: [], totalAgents: 0 };
                    }
                },
                setData: (data) => {
                    // Agent fleet requires careful reconstruction
                    showNotification('Agent fleet state loaded. Spawn agents to apply.', 'info');
                }
            },
            chronicle: {
                name: 'Chronicle',
                icon: '',
                desc: 'Captain\'s narrative log',
                color: '#ffd700',
                getData: () => ({
                    entries: gameData.chronicle?.entries || [],
                    eventBuffer: gameData.chronicle?.eventBuffer || [],
                    settings: gameData.chronicle?.settings || {},
                    stats: gameData.chronicle?.stats || {},
                    totalEntries: gameData.chronicle?.entries?.length || 0
                }),
                setData: (data) => {
                    if (!gameData.chronicle) gameData.chronicle = { entries: [], eventBuffer: [], settings: {}, stats: {} };
                    if (data.entries) gameData.chronicle.entries = data.entries;
                    if (data.settings) gameData.chronicle.settings = data.settings;
                    if (data.stats) gameData.chronicle.stats = data.stats;
                    saveGameData();
                    if (typeof updateChronicleUI === 'function') updateChronicleUI();
                }
            },
            inventory: {
                name: 'Inventory',
                icon: '',
                desc: 'Items & equipment',
                color: '#88ff44',
                getData: () => ({
                    inventory: gameData.inventory || [],
                    equipment: gameData.equipment || {},
                    rarityItems: gameData.rarityItems || [],
                    itemCount: gameData.inventory?.length || 0
                }),
                setData: (data) => {
                    if (data.inventory) gameData.inventory = data.inventory;
                    if (data.equipment) gameData.equipment = data.equipment;
                    if (data.rarityItems) gameData.rarityItems = data.rarityItems;
                    saveGameData();
                    if (typeof updateInventoryUI === 'function') updateInventoryUI();
                }
            },
            skills: {
                name: 'Skills & Progress',
                icon: '',
                desc: 'Levels, XP, achievements',
                color: '#44aaff',
                getData: () => ({
                    skills: gameData.skills || {},
                    statistics: gameData.statistics || {},
                    achievements: gameData.achievements || {},
                    prestige: gameData.prestige || {},
                    talents: gameData.talents || {},
                    playerRank: gameData.playerRank || {}
                }),
                setData: (data) => {
                    if (data.skills) gameData.skills = { ...gameData.skills, ...data.skills };
                    if (data.statistics) gameData.statistics = { ...gameData.statistics, ...data.statistics };
                    if (data.achievements) gameData.achievements = data.achievements;
                    if (data.prestige) gameData.prestige = data.prestige;
                    if (data.talents) gameData.talents = data.talents;
                    if (data.playerRank) gameData.playerRank = data.playerRank;
                    saveGameData();
                    updateAllUI();
                }
            },
            pets: {
                name: 'Pets',
                icon: '',
                desc: 'Collected companions',
                color: '#ff88aa',
                getData: () => ({
                    pets: gameData.pets || { owned: [], active: null, bond: {} },
                    ownedCount: gameData.pets?.owned?.length || 0,
                    activePet: gameData.pets?.active || null
                }),
                setData: (data) => {
                    if (data.pets) gameData.pets = data.pets;
                    saveGameData();
                }
            },
            lore: {
                name: 'Lore Fragments',
                icon: '',
                desc: 'Discovered secrets',
                color: '#8844ff',
                getData: () => ({
                    loreFragments: gameData.loreFragments || {},
                    discoveredCount: Object.keys(gameData.loreFragments || {}).length
                }),
                setData: (data) => {
                    if (data.loreFragments) gameData.loreFragments = data.loreFragments;
                    saveGameData();
                }
            },
            energy: {
                name: 'Robot Energy',
                icon: '',
                desc: 'Current energy state',
                color: '#ffff00',
                getData: () => {
                    try {
                        const re = typeof robotEnergy !== 'undefined' ? robotEnergy : { current: 100, max: 100, isCharging: false };
                        return {
                            current: re.current || 100,
                            max: re.max || 100,
                            isCharging: re.isCharging || false
                        };
                    } catch (e) {
                        console.error('Energy getData error:', e);
                        return { current: 100, max: 100, isCharging: false };
                    }
                },
                setData: (data) => {
                    if (typeof robotEnergy !== 'undefined') {
                        if (data.current !== undefined) robotEnergy.current = data.current;
                        if (data.max !== undefined) robotEnergy.max = data.max;
                    }
                }
            },
            // v6.38: Temporal Echoes module
            echoes: {
                name: 'Temporal Echoes',
                icon: '',
                desc: 'Messages left across space-time',
                color: '#00ffff',
                getData: () => {
                    try {
                        if (typeof temporalEchoSystem !== 'undefined' && temporalEchoSystem.echoes) {
                            return {
                                echoes: temporalEchoSystem.echoes,
                                stats: temporalEchoSystem.stats,
                                totalEchoes: temporalEchoSystem.echoes.length,
                                createdCount: temporalEchoSystem.stats.created,
                                discoveredCount: temporalEchoSystem.stats.discovered
                            };
                        }
                        if (gameData.temporalEchoes) {
                            return {
                                echoes: gameData.temporalEchoes.echoes || [],
                                stats: gameData.temporalEchoes.stats || { created: 0, discovered: 0 },
                                totalEchoes: (gameData.temporalEchoes.echoes || []).length,
                                createdCount: gameData.temporalEchoes.stats?.created || 0,
                                discoveredCount: gameData.temporalEchoes.stats?.discovered || 0
                            };
                        }
                        return null;
                    } catch (e) {
                        console.error('Echoes getData error:', e);
                        return null;
                    }
                },
                setData: (data) => {
                    if (typeof temporalEchoSystem !== 'undefined' && data) {
                        temporalEchoSystem.importEchoes(data);
                    }
                }
            },
            // v6.39: Lucidity Engine module
            lucidity: {
                name: 'AI Lucidity',
                icon: '',
                desc: 'Copilot self-awareness progression',
                color: '#ff00ff',
                getData: () => {
                    try {
                        if (typeof lucidityEngine !== 'undefined') {
                            return {
                                stage: lucidityEngine.getStage(),
                                interactions: lucidityEngine.totalInteractions,
                                lucidEvents: lucidityEngine.lucidEventCount,
                                nextStage: lucidityEngine.getStage() === 'transcendence' ? 'MAX' :
                                    Object.entries(lucidityEngine.thresholds || {}).find(([s, t]) => t > lucidityEngine.totalInteractions)?.[0] || 'unknown'
                            };
                        }
                        if (gameData.lucidity) {
                            return gameData.lucidity;
                        }
                        return null;
                    } catch (e) {
                        console.error('Lucidity getData error:', e);
                        return null;
                    }
                },
                setData: (data) => {
                    if (typeof lucidityEngine !== 'undefined' && data) {
                        lucidityEngine.totalInteractions = data.interactions || 0;
                        lucidityEngine.lucidEventCount = data.lucidEvents || 0;
                        gameData.lucidity = data;
                    }
                }
            },
            // v6.97: Planet Surfaces module - per-planet state backup
            planetSurfaces: {
                name: 'Planet Surfaces',
                icon: '',
                desc: 'Per-planet structures & modifications',
                color: '#4488ff',
                getData: () => {
                    if (!gameData.planetSurfaces || Object.keys(gameData.planetSurfaces).length === 0) {
                        return null;
                    }
                    return {
                        surfaces: gameData.planetSurfaces,
                        planetCount: Object.keys(gameData.planetSurfaces).length,
                        totalStructures: Object.values(gameData.planetSurfaces).reduce((sum, s) => sum + (s.structures?.length || 0), 0),
                        totalTerraformed: Object.values(gameData.planetSurfaces).reduce((sum, s) => sum + (s.terraformedAreas?.length || 0), 0)
                    };
                },
                setData: (data) => {
                    if (data && data.surfaces) {
                        gameData.planetSurfaces = data.surfaces;
                        saveGameData();
                        showNotification('Planet surfaces restored!', 'success');
                    }
                }
            }
        };

        // Export specific module
        function exportRappidModule(moduleKey) {
            const module = RAPPID_DATA_MODULES[moduleKey];
            if (!module) {
                showNotification(`Unknown module: ${moduleKey}`, 'error');
                return;
            }

            const data = module.getData();
            if (!data) {
                showNotification(`No ${module.name} data to export`, 'info');
                return;
            }

            const exportData = {
                rappid: true,
                backupType: `RAPPID Module: ${module.name}`,
                moduleKey: moduleKey,
                version: RAPPID_BACKUP_VERSION,
                exportDate: new Date().toISOString(),
                metadata: {
                    gameVersion: VERSION,
                    moduleName: module.name,
                    moduleIcon: module.icon
                },
                data: data
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `leviathan-${moduleKey}-${timestamp}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification(`${module.icon} ${module.name} exported!`, 'success');
        }

        // Export multiple modules as a bundle
        function exportRappidBundle(moduleKeys) {
            const bundle = {
                rappid: true,
                backupType: 'RAPPID Module Bundle',
                version: RAPPID_BACKUP_VERSION,
                exportDate: new Date().toISOString(),
                metadata: {
                    gameVersion: VERSION,
                    moduleCount: moduleKeys.length,
                    modules: moduleKeys
                },
                modules: {}
            };

            moduleKeys.forEach(key => {
                const module = RAPPID_DATA_MODULES[key];
                if (module) {
                    const data = module.getData();
                    if (data) {
                        bundle.modules[key] = {
                            name: module.name,
                            icon: module.icon,
                            data: data
                        };
                    }
                }
            });

            const dataStr = JSON.stringify(bundle, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `leviathan-bundle-${timestamp}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification(` Bundle exported with ${Object.keys(bundle.modules).length} modules!`, 'success');
        }

        // Import module data (auto-detect type)
        function importRappidModule(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Check if it's a module bundle
                    if (imported.backupType === 'RAPPID Module Bundle' && imported.modules) {
                        handleModuleBundleImport(imported);
                        return;
                    }

                    // Check if it's a single module
                    if (imported.moduleKey && imported.data) {
                        handleSingleModuleImport(imported);
                        return;
                    }

                    // Fall back to smart import for other formats
                    importRappidSmartBackup(event);

                } catch (error) {
                    console.error('Module import error:', error);
                    showNotification('Failed to import: Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Handle single module import
        function handleSingleModuleImport(imported) {
            const module = RAPPID_DATA_MODULES[imported.moduleKey];
            if (!module) {
                showNotification(`Unknown module type: ${imported.moduleKey}`, 'error');
                return;
            }

            const confirmMsg = `Import ${module.icon} ${module.name}?\n\n` +
                ` Export Date: ${new Date(imported.exportDate).toLocaleString()}\n` +
                ` Game Version: ${imported.metadata?.gameVersion || 'Unknown'}\n\n` +
                `This will replace your current ${module.name} data.\nContinue?`;

            if (!confirm(confirmMsg)) {
                showNotification('Import cancelled', 'info');
                return;
            }

            module.setData(imported.data);
            showNotification(`${module.icon} ${module.name} imported!`, 'success');
        }

        // Handle module bundle import
        function handleModuleBundleImport(imported) {
            const moduleCount = Object.keys(imported.modules).length;
            const moduleNames = Object.values(imported.modules).map(m => `${m.icon} ${m.name}`).join('\n ');

            const confirmMsg = `Import Module Bundle?\n\n` +
                ` Export Date: ${new Date(imported.exportDate).toLocaleString()}\n` +
                ` Modules (${moduleCount}):\n ${moduleNames}\n\n` +
                `This will replace data for all included modules.\nContinue?`;

            if (!confirm(confirmMsg)) {
                showNotification('Import cancelled', 'info');
                return;
            }

            let importedCount = 0;
            Object.entries(imported.modules).forEach(([key, moduleData]) => {
                const module = RAPPID_DATA_MODULES[key];
                if (module && moduleData.data) {
                    module.setData(moduleData.data);
                    importedCount++;
                }
            });

            showNotification(` Imported ${importedCount} modules!`, 'success');
        }

        // Show RAPPID Data Hub modal
        function showRappidDataHub() {
            console.log('Opening RAPPID Data Hub...');
            try {
                const existingModal = document.getElementById('rappid-data-hub');
                if (existingModal) existingModal.remove();

                // Build module grid
                let moduleGrid = '';
                Object.entries(RAPPID_DATA_MODULES).forEach(([key, module]) => {
                    let data = null;
                    let hasData = false;
                    let dataPreview = 'No data';
                    try {
                        data = module.getData();
                        hasData = data !== null;
                        dataPreview = hasData ? getModulePreview(key, data) : 'No data';
                    } catch (e) {
                        console.error(`Error getting data for module ${key}:`, e);
                        dataPreview = 'Error loading';
                    }

                moduleGrid += `
                    <div class="data-hub-module" style="background: rgba(${hexToRgb(module.color)}, 0.1); border: 1px solid ${module.color}40;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="font-size: 16px;">${module.icon}</div>
                            <input type="checkbox" id="module-${key}" class="module-checkbox" ${hasData ? 'checked' : 'disabled'}
                                style="width: 18px; height: 18px; cursor: ${hasData ? 'pointer' : 'not-allowed'};">
                        </div>
                        <div style="font-weight: bold; color: ${module.color}; font-size: 12px;">${module.name}</div>
                        <div style="font-size: 10px; color: #888; margin: 4px 0;">${module.desc}</div>
                        <div style="font-size: 9px; color: ${hasData ? '#aaa' : '#666'}; margin-top: 6px;">${dataPreview}</div>
                        <button onclick="exportRappidModule('${key}')"
                            style="width: 100%; margin-top: 8px; padding: 4px; font-size: 10px; background: ${module.color}30; border: 1px solid ${module.color}60; border-radius: 4px; color: #fff; cursor: pointer;"
                            ${!hasData ? 'disabled style="opacity: 0.4; cursor: not-allowed;"' : ''}>
                            Export
                        </button>
                    </div>
                `;
            });

            const modal = document.createElement('div');
            modal.id = 'rappid-data-hub';
            modal.style.cssText = 'display: flex; z-index: 10000; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;';
            modal.innerHTML = `
                <div style="max-width: 650px; max-height: 90vh; overflow-y: auto; background: linear-gradient(135deg, rgba(20,20,35,0.98), rgba(30,30,55,0.98)); position: relative; border-radius: 12px; padding: 25px; border: 1px solid #555; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
                    <button onclick="document.getElementById('rappid-data-hub').remove()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; color: #888; font-size: 24px; cursor: pointer; line-height: 1;">&times;</button>
                    <div class="modal-title" style="color: #ffd700;"> RAPPID Data Hub</div>
                    <div style="color: #888; font-size: 12px; margin-bottom: 15px;">
                        Export or import any game system individually or as a bundle
                    </div>

                    <!-- Quick Actions -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="exportRappidFullBackup(); document.getElementById('rappid-data-hub').remove();"
                            style="flex: 1; min-width: 140px; padding: 10px; background: linear-gradient(135deg, #ffd700, #ff8c00); border: none; border-radius: 6px; color: #000; font-weight: bold; cursor: pointer;">
                             Export Everything
                        </button>
                        <button onclick="document.getElementById('rappidDataHubImport').click();"
                            style="flex: 1; min-width: 140px; padding: 10px; background: rgba(0,200,100,0.2); border: 1px solid #00c864; border-radius: 6px; color: #fff; cursor: pointer;">
                             Import Any File
                        </button>
                    </div>
                    <input type="file" id="rappidDataHubImport" accept=".json" style="display: none;" onchange="importRappidModule(event); document.getElementById('rappid-data-hub').remove();">

                    <!-- Module Grid -->
                    <div style="font-size: 13px; font-weight: bold; color: #fff; margin-bottom: 10px;"> Data Modules</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                        ${moduleGrid}
                    </div>

                    <!-- Bundle Export -->
                    <div style="background: rgba(100,100,100,0.2); border-radius: 8px; padding: 15px;">
                        <div style="font-size: 13px; font-weight: bold; color: #fff; margin-bottom: 10px;"> Export Selected as Bundle</div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button onclick="selectAllModules(true)" style="padding: 6px 12px; font-size: 11px; background: rgba(100,100,100,0.3); border: 1px solid #666; border-radius: 4px; color: #fff; cursor: pointer;">
                                Select All
                            </button>
                            <button onclick="selectAllModules(false)" style="padding: 6px 12px; font-size: 11px; background: rgba(100,100,100,0.3); border: 1px solid #666; border-radius: 4px; color: #fff; cursor: pointer;">
                                Deselect All
                            </button>
                            <button onclick="exportSelectedModules()" style="flex: 1; padding: 6px 12px; font-size: 11px; background: linear-gradient(135deg, #4488ff, #2266dd); border: none; border-radius: 4px; color: #fff; cursor: pointer; font-weight: bold;">
                                Export Bundle
                            </button>
                        </div>
                    </div>

                    <!-- Info -->
                    <div style="margin-top: 15px; padding: 10px; background: rgba(100,100,100,0.15); border-radius: 6px; font-size: 10px; color: #666;">
                         <strong>Tip:</strong> Individual exports are great for sharing specific parts (like your Chronicle or Genesis simulation) without exposing other data.
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Add module card styles
            const style = document.createElement('style');
            style.textContent = `
                .data-hub-module {
                    padding: 10px;
                    border-radius: 8px;
                    transition: transform 0.2s, box-shadow 0.2s;
                }
                .data-hub-module:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                }
            `;
            modal.appendChild(style);
            console.log('RAPPID Data Hub opened successfully');
            } catch (error) {
                console.error('Error opening Data Hub:', error);
                alert('Error opening Data Hub: ' + error.message);
            }
        }

        // Helper: Get module data preview text
        function getModulePreview(key, data) {
            switch(key) {
                case 'galaxy': return `${data.totalPlanets} planets, ${data.visitedPlanets?.length || 0} visited`;
                case 'currentPlanet': return data.planetName || 'Not on planet';
                case 'genesis': return `${data.entities?.length || 0} entities, tick ${data.tick || 0}`;
                case 'copilot': return `${data.messageCount} messages`;
                case 'agentFleet': return `${data.totalAgents} agents`;
                case 'chronicle': return `${data.totalEntries} entries`;
                case 'inventory': return `${data.itemCount} items`;
                case 'skills': return Object.entries(data.skills || {}).map(([k,v]) => `${k[0].toUpperCase()}:${v.level}`).join(' ');
                case 'pets': return `${data.ownedCount} pets`;
                case 'lore': return `${data.discoveredCount} fragments`;
                case 'energy': return `${Math.round(data.current)}/${data.max}`;
                case 'echoes': return `${data.totalEchoes || 0} echoes, ${data.discoveredCount || 0} discovered`;
                case 'lucidity': return `Stage: ${data.stage || 'dormant'}, ${data.interactions || 0} interactions`;
                default: return 'Available';
            }
        }

        // Helper: Convert hex color to rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ?
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` :
                '100, 100, 100';
        }

        // Select/deselect all module checkboxes
        function selectAllModules(select) {
            document.querySelectorAll('.module-checkbox:not(:disabled)').forEach(cb => {
                cb.checked = select;
            });
        }

        // Export selected modules as bundle
        function exportSelectedModules() {
            const selectedModules = [];
            document.querySelectorAll('.module-checkbox:checked').forEach(cb => {
                const key = cb.id.replace('module-', '');
                selectedModules.push(key);
            });

            if (selectedModules.length === 0) {
                showNotification('No modules selected', 'info');
                return;
            }

            exportRappidBundle(selectedModules);
            document.getElementById('rappid-data-hub')?.remove();
        }

        async function testRappidConnection() {
            const endpoint = getActiveEndpoint();
            if (!endpoint) {
                showRappidStatus('No active endpoint selected', 'error');
                return;
            }

            showRappidStatus('Testing connection...', '');

            try {
                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        message: 'Hello, this is a connection test from LEVIATHAN game.',
                        guid: endpoint.guid
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    showRappidStatus('Connection successful! Endpoint is responding.', 'success');
                    showNotification('RAPPID connection test passed!');
                } else {
                    showRappidStatus(`Connection failed: HTTP ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('RAPPID connection test error:', error);
                showRappidStatus('Connection failed: Network error', 'error');
            }
        }

        function clearRappidSettings() {
            if (confirm('Are you sure you want to clear all RAPPID settings?')) {
                rappidSettings = {
                    rappid: false,
                    endpoints: {},
                    azureTTSKey: '',
                    azureRegion: '',
                    ttsVoiceName: 'en-US-JennyNeural',
                    version: '1.0'
                };
                localStorage.removeItem(RAPPID_STORAGE_KEY);
                updateRappidUI();
                showRappidStatus('RAPPID settings cleared', 'success');
            }
        }

        function showRappidStatus(message, type) {
            const statusEl = document.getElementById('rappid-status-message');
            statusEl.textContent = message;
            statusEl.className = 'rappid-status ' + type;
        }

        // v5.9: Enhanced generateCopilotResponse with RAPPID API integration
        // Uses correct API format: user_input, conversation_history, user_guid
        // Returns object with { text, voice } - text for display, voice for TTS
        async function generateCopilotResponseWithRappid(message) {
            const endpoint = getActiveEndpoint();

            // If no active RAPPID endpoint, fall back to local responses
            if (!endpoint || !endpoint.url || !endpoint.key) {
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }

            try {
                // Build context from game state
                const gameContext = {
                    playerHP: gameData.player?.hp || 100,
                    playerMaxHP: gameData.player?.maxHp || 100,
                    combatLevel: gameData.skills?.combat?.level || 1,
                    currentBiome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planetName: worldState?.currentCiv?.name || 'Unknown',
                    activePet: gameData.pets?.active || null,
                    inventoryItems: Object.keys(gameData.inventory || {}).length
                };

                // Build conversation history with system context
                // v5.14: Updated to reflect explorer robot probe
                // v6.37: Epic Space Opera Narrator personality support
                const personality = rappidSettings.companionPersonality || 'helpful';

                let systemContent;
                if (personality === 'epic-narrator') {
                    // Epic Space Opera Narrator - dramatic, cinematic, third-person narration
                    systemContent = `You are the COSMIC NARRATOR, an omniscient voice chronicling the legendary saga of LEVIATHAN - an autonomous Explorer Probe traversing the infinite reaches of the Omniverse.

NARRATOR STYLE:
- Speak in THIRD PERSON with sweeping, cinematic grandeur
- Channel the gravitas of classic space opera (Star Wars opening crawls, Dune's prophecies, Battlestar Galactica's mythic tone)
- Use rich metaphors: stars, void, destiny, cosmic forces, ancient powers
- Build drama even in routine moments - every action is part of an epic legend
- Reference "The Leviathan", "the probe", or "our mechanical champion" as a heroic entity

CURRENT SAGA STATUS:
- Hull Integrity: ${gameContext.playerHP}/${gameContext.playerMaxHP}
- Combat Systems: Level ${gameContext.combatLevel}
- Current World: "${gameContext.planetName}" (${gameContext.currentBiome} biome)
- Companion: ${gameContext.activePet ? `${gameContext.activePet} drone at its side` : 'Alone against the cosmos'}

VOICE GUIDELINES:
- Keep to 2-4 dramatic sentences
- Use powerful verbs: "vanquished", "descended", "emerged", "conquered", "transcended"
- Include cosmic scale: "across lightyears", "beneath alien suns", "at the edge of oblivion", "where stars fear to shine"
- End with tension or triumph: "...and so the legend grows" or "...but what awaits in the void?"

You are narrating an EPIC. Make every response feel like it belongs in a dramatic movie trailer.`;
                } else {
                    // Standard copilot personalities
                    const personalityModifiers = {
                        helpful: 'Keep responses brief, technical, and helpful (1-3 sentences).',
                        adventurous: 'Respond with enthusiasm for discovery and adventure! Use exclamation marks and convey wonder at the cosmos.',
                        wise: 'Respond thoughtfully with measured wisdom. Include occasional philosophical observations about exploration and existence.',
                        playful: 'Keep responses light-hearted with friendly banter and occasional humor. Be encouraging and fun!'
                    };
                    const modifier = personalityModifiers[personality] || personalityModifiers.helpful;

                    systemContent = `You are an AI companion assisting an autonomous Explorer Probe (designation: LEVIATHAN) in the game LEVIATHAN: OMNIVERSE. The probe was deployed from a spacecraft to explore alien worlds and gather resources. Current probe status: Integrity ${gameContext.playerHP}/${gameContext.playerMaxHP}, Combat Systems Level ${gameContext.combatLevel}, currently deployed on planet "${gameContext.planetName}" (${gameContext.currentBiome} biome). ${gameContext.activePet ? `A ${gameContext.activePet} drone companion is also deployed.` : 'No companion drones deployed.'} ${modifier} Refer to the probe as "you" or "the probe" - it is a robot, not a living being.`;
                }

                const systemMessage = {
                    role: 'system',
                    content: systemContent
                };

                // Build conversation history for API
                const conversationForApi = [systemMessage, ...copilotConversationHistory];

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        user_input: message,
                        conversation_history: conversationForApi,
                        user_guid: endpoint.guid || 'leviathan-game-user'
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // v5.9: Extract both assistant_response (for display) and voice_response (for TTS)
                    const textResponse = data.assistant_response || data.response || data.message || data.reply || generateCopilotResponse(message);
                    // Use voice_response for TTS if available, otherwise fall back to text response
                    const voiceResponse = data.voice_response || textResponse;
                    return { text: textResponse, voice: voiceResponse };
                } else {
                    console.warn('RAPPID API error (status ' + response.status + '), falling back to local response');
                    const localResponse = generateCopilotResponse(message);
                    return { text: localResponse, voice: localResponse };
                }
            } catch (error) {
                console.error('RAPPID request failed:', error);
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }
        }

        // Azure TTS integration using Microsoft Speech SDK
        let speechSdkLoaded = false;
        let speechSynthesizer = null;

        function loadSpeechSdk() {
            return new Promise((resolve, reject) => {
                if (speechSdkLoaded && window.SpeechSDK) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://aka.ms/csspeech/jsbrowserpackageraw';
                script.onload = () => {
                    speechSdkLoaded = true;
                    console.log('Microsoft Speech SDK loaded');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Failed to load Speech SDK');
                    reject(new Error('Speech SDK failed to load'));
                };
                document.head.appendChild(script);
            });
        }

        async function speakWithAzureTTS(text) {
            if (!rappidSettings.azureTTSKey || !rappidSettings.azureRegion) {
                // Fall back to browser TTS
                speakCopilotResponse(text);
                return;
            }

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser TTS');
                    speakCopilotResponse(text);
                    return;
                }

                // Cancel any existing speech
                if (speechSynthesizer) {
                    speechSynthesizer.close();
                    speechSynthesizer = null;
                }

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechSynthesisVoiceName = rappidSettings.ttsVoiceName || 'en-US-JennyNeural';

                // Use default speaker output
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();

                // Create synthesizer
                speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(speechConfig, audioConfig);

                // Truncate text if too long (SDK has limits)
                const maxLength = 5000;
                const truncatedText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;

                // Show voice indicator
                const voiceIndicator = document.getElementById('copilot-voice-indicator');
                if (voiceIndicator) voiceIndicator.classList.add('active');

                // Speak the text
                speechSynthesizer.speakTextAsync(
                    truncatedText,
                    (result) => {
                        // Hide voice indicator on completion
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                            console.log('Azure TTS completed successfully');
                        } else {
                            console.warn('Azure TTS synthesis ended with reason:', result.reason);
                        }

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }
                    },
                    (error) => {
                        console.error('Azure TTS error:', error);
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }

                        // Fall back to browser TTS
                        speakCopilotResponse(text);
                    }
                );
            } catch (error) {
                console.error('Azure TTS error:', error);
                speakCopilotResponse(text);
            }
        }

        // Function to stop Azure TTS
        function stopAzureTTS() {
            if (speechSynthesizer) {
                speechSynthesizer.close();
                speechSynthesizer = null;
            }
            const voiceIndicator = document.getElementById('copilot-voice-indicator');
            if (voiceIndicator) voiceIndicator.classList.remove('active');
        }

        // Override sendCopilotMessage to use RAPPID when available
        const originalSendCopilotMessage = typeof sendCopilotMessage === 'function' ? sendCopilotMessage : null;

        // ============================================
        // v5.4: COMPANION EVOLUTION SYSTEM
        // ============================================
        const PET_EVOLUTIONS = {
            slime: {
                stages: [
                    { name: 'Slime Hatchling', icon: '', bondRequired: 0, abilities: ['regen'], statMult: 1.0 },
                    { name: 'Gel Guardian', icon: '', bondRequired: 50, abilities: ['regen', 'shield'], statMult: 1.5 },
                    { name: 'Slime Sovereign', icon: '', bondRequired: 150, abilities: ['regen', 'shield', 'absorb'], statMult: 2.5 }
                ]
            },
            wisp: {
                stages: [
                    { name: 'Tiny Wisp', icon: '', bondRequired: 0, abilities: ['luck'], statMult: 1.0 },
                    { name: 'Bright Spirit', icon: '', bondRequired: 60, abilities: ['luck', 'illuminate'], statMult: 1.6 },
                    { name: 'Radiant Beacon', icon: '', bondRequired: 180, abilities: ['luck', 'illuminate', 'fortune'], statMult: 2.8 }
                ]
            },
            bat: {
                stages: [
                    { name: 'Cave Bat', icon: '', bondRequired: 0, abilities: ['dodge'], statMult: 1.0 },
                    { name: 'Shadow Wing', icon: '', bondRequired: 55, abilities: ['dodge', 'swoop'], statMult: 1.4 },
                    { name: 'Vampire Lord', icon: '', bondRequired: 165, abilities: ['dodge', 'swoop', 'lifesteal'], statMult: 2.4 }
                ]
            },
            phoenix: {
                stages: [
                    { name: 'Mini Phoenix', icon: '', bondRequired: 0, abilities: ['damage'], statMult: 1.0 },
                    { name: 'Flame Herald', icon: '', bondRequired: 70, abilities: ['damage', 'burn'], statMult: 1.7 },
                    { name: 'Inferno Avatar', icon: '', bondRequired: 200, abilities: ['damage', 'burn', 'rebirth'], statMult: 3.0 }
                ]
            },
            dragon: {
                stages: [
                    { name: 'Baby Dragon', icon: '', bondRequired: 0, abilities: ['attack'], statMult: 1.0 },
                    { name: 'Drake Champion', icon: '', bondRequired: 80, abilities: ['attack', 'firebreath'], statMult: 1.8 },
                    { name: 'Elder Wyrm', icon: '', bondRequired: 250, abilities: ['attack', 'firebreath', 'devastation'], statMult: 3.5 }
                ]
            },
            void: {
                stages: [
                    { name: 'Void Entity', icon: '', bondRequired: 0, abilities: ['absorb'], statMult: 1.0 },
                    { name: 'Void Walker', icon: '', bondRequired: 100, abilities: ['absorb', 'phase'], statMult: 2.0 },
                    { name: 'Void Sovereign', icon: '', bondRequired: 300, abilities: ['absorb', 'phase', 'annihilate'], statMult: 4.0 }
                ]
            },
            celestial: {
                stages: [
                    { name: 'Celestial Star', icon: '', bondRequired: 0, abilities: ['allStats'], statMult: 1.0 },
                    { name: 'Constellation Spirit', icon: '', bondRequired: 120, abilities: ['allStats', 'blessing'], statMult: 2.2 },
                    { name: 'Cosmic Deity', icon: '', bondRequired: 400, abilities: ['allStats', 'blessing', 'transcendence'], statMult: 5.0 }
                ]
            }
        };

        const EVOLUTION_ABILITIES = {
            regen: { name: 'Regeneration', desc: '+1 HP/5s', icon: '' },
            shield: { name: 'Shield Aura', desc: '+5% damage reduction', icon: '' },
            absorb: { name: 'Soul Absorb', desc: '+25% XP gain', icon: '' },
            luck: { name: 'Lucky Charm', desc: '+10% loot bonus', icon: '' },
            illuminate: { name: 'Illuminate', desc: 'Reveals hidden items', icon: '' },
            fortune: { name: 'Fortune', desc: '+20% rare item chance', icon: '' },
            dodge: { name: 'Evasion', desc: '+5% dodge chance', icon: '' },
            swoop: { name: 'Swoop Attack', desc: 'Pet deals bonus damage', icon: '' },
            lifesteal: { name: 'Lifesteal', desc: '+8% life on hit', icon: '' },
            damage: { name: 'Power Boost', desc: '+15% damage', icon: '' },
            burn: { name: 'Burning Aura', desc: 'Enemies take fire damage', icon: '' },
            rebirth: { name: 'Rebirth', desc: 'Revive once per fight', icon: '' },
            attack: { name: 'Pet Attack', desc: 'Pet attacks enemies', icon: '' },
            firebreath: { name: 'Fire Breath', desc: 'AoE fire damage', icon: '' },
            devastation: { name: 'Devastation', desc: '+50% boss damage', icon: '' },
            phase: { name: 'Phase Shift', desc: 'Ignore 10% damage', icon: '' },
            annihilate: { name: 'Annihilate', desc: 'Execute low HP enemies', icon: '' },
            allStats: { name: 'All Stats', desc: '+10% all stats', icon: '' },
            blessing: { name: 'Blessing', desc: '+15% all bonuses', icon: '' },
            transcendence: { name: 'Transcendence', desc: 'Ultimate power', icon: '' }
        };

        function initPetEvolutionSystem() {
            if (!gameData.petEvolution) {
                gameData.petEvolution = {};
            }
            // Initialize bond for each owned pet
            if (gameData.pets?.owned) {
                for (const petId of gameData.pets.owned) {
                    if (!gameData.petEvolution[petId]) {
                        gameData.petEvolution[petId] = {
                            bond: 0,
                            stage: 0
                        };
                    }
                }
            }
        }

        function getPetEvolutionStage(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.stage || 0;
        }

        function getPetBond(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.bond || 0;
        }

        function addPetBond(petId, amount) {
            initPetEvolutionSystem();
            if (!gameData.petEvolution[petId]) {
                gameData.petEvolution[petId] = { bond: 0, stage: 0 };
            }
            gameData.petEvolution[petId].bond += amount;
            saveGameData();
        }

        function canEvolvePet(petId) {
            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return false;

            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];
            if (!nextStage) return false;

            const currentBond = getPetBond(petId);
            return currentBond >= nextStage.bondRequired;
        }

        function evolvePet(petId) {
            if (!canEvolvePet(petId)) return false;

            const evolution = PET_EVOLUTIONS[petId];
            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];

            gameData.petEvolution[petId].stage = currentStage + 1;
            saveGameData();

            // Show evolution popup
            showNotification(`${nextStage.icon} ${nextStage.name} EVOLVED!`, 'success');
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 60, 0xaa44ff, { spread: 8, lifetime: 2000 });
            }

            updateEvolutionDisplay();
            return true;
        }

        function getCurrentPetData(petId) {
            const basePet = PET_TYPES[petId];
            if (!basePet) return null;

            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return basePet;

            const stage = getPetEvolutionStage(petId);
            const stageData = evolution.stages[stage];

            return {
                ...basePet,
                name: stageData.name,
                icon: stageData.icon,
                abilities: stageData.abilities,
                statMult: stageData.statMult
            };
        }

        function getEvolutionBonuses() {
            const bonuses = {
                damageReduction: 0,
                xpBonus: 0,
                lootBonus: 0,
                rareChance: 0,
                dodgeBonus: 0,
                lifesteal: 0,
                damageBonus: 0,
                burnDamage: false,
                canRevive: false,
                bossDamage: 0,
                phaseShift: 0,
                executeThreshold: 0,
                allStatsBonus: 0,
                blessingMult: 1.0
            };

            if (!gameData.pets?.active) return bonuses;

            const petData = getCurrentPetData(gameData.pets.active);
            if (!petData?.abilities) return bonuses;

            for (const ability of petData.abilities) {
                switch (ability) {
                    case 'shield': bonuses.damageReduction += 0.05; break;
                    case 'absorb': bonuses.xpBonus += 0.25; break;
                    case 'luck': bonuses.lootBonus += 0.1; break;
                    case 'fortune': bonuses.rareChance += 0.2; break;
                    case 'dodge': bonuses.dodgeBonus += 0.05; break;
                    case 'lifesteal': bonuses.lifesteal += 0.08; break;
                    case 'damage': bonuses.damageBonus += 0.15; break;
                    case 'burn': bonuses.burnDamage = true; break;
                    case 'rebirth': bonuses.canRevive = true; break;
                    case 'devastation': bonuses.bossDamage += 0.5; break;
                    case 'phase': bonuses.phaseShift += 0.1; break;
                    case 'annihilate': bonuses.executeThreshold = 0.15; break;
                    case 'allStats': bonuses.allStatsBonus += 0.1; break;
                    case 'blessing': bonuses.blessingMult = 1.15; break;
                    case 'transcendence':
                        bonuses.allStatsBonus += 0.2;
                        bonuses.blessingMult = 1.3;
                        break;
                }
            }

            // Apply blessing multiplier
            bonuses.damageBonus *= bonuses.blessingMult;
            bonuses.xpBonus *= bonuses.blessingMult;
            bonuses.lootBonus *= bonuses.blessingMult;

            return bonuses;
        }

        function openEvolutionModal() {
            initPetEvolutionSystem();
            updateEvolutionDisplay();
            document.getElementById('evolution-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeEvolutionModal() {
            document.getElementById('evolution-modal').style.display = 'none';
        }

        function updateEvolutionDisplay() {
            const container = document.getElementById('evolution-list');
            if (!container) return;

            initPetEvolutionSystem();
            const ownedPets = gameData.pets?.owned || [];

            if (ownedPets.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No companions yet. Defeat enemies to find pets!</div>';
                return;
            }

            let html = '';
            for (const petId of ownedPets) {
                const evolution = PET_EVOLUTIONS[petId];
                if (!evolution) continue;

                const currentStage = getPetEvolutionStage(petId);
                const stageData = evolution.stages[currentStage];
                const nextStage = evolution.stages[currentStage + 1];
                const bond = getPetBond(petId);
                const canEvolve = canEvolvePet(petId);
                const isActive = gameData.pets?.active === petId;

                const bondForNext = nextStage ? nextStage.bondRequired : bond;
                const bondProgress = nextStage ? Math.min(100, (bond / bondForNext) * 100) : 100;

                html += `
                    <div class="evolution-card ${canEvolve ? 'can-evolve' : ''}" style="${isActive ? 'border-color: #ff8800;' : ''}">
                        <div class="evolution-header">
                            <div class="evolution-icon">${stageData.icon}</div>
                            <div class="evolution-info">
                                <div class="evolution-name">${stageData.name}</div>
                                <div class="evolution-stage">Stage ${currentStage + 1}/${evolution.stages.length} ${isActive ? '(ACTIVE)' : ''}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffd700; font-size: 14px;">${bond} Bond</div>
                                <div style="color: #888; font-size: 11px;">x${stageData.statMult.toFixed(1)} Stats</div>
                            </div>
                        </div>
                        <div class="evolution-bond">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 4px;">
                                <span>Bond Progress</span>
                                <span>${bond}/${bondForNext}</span>
                            </div>
                            <div class="bond-bar">
                                <div class="bond-fill" style="width: ${bondProgress}%;"></div>
                            </div>
                        </div>
                        <div class="evolution-abilities">
                            ${stageData.abilities.map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability" title="${abilityData?.desc || ''}">${abilityData?.icon || ''} ${abilityData?.name || ab}</div>`;
                            }).join('')}
                            ${nextStage ? nextStage.abilities.filter(ab => !stageData.abilities.includes(ab)).map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability locked" title="Unlock at next evolution">${abilityData?.icon || ''} ???</div>`;
                            }).join('') : ''}
                        </div>
                        ${nextStage ? `
                            <button class="evolve-btn" onclick="evolvePet('${petId}')" ${canEvolve ? '' : 'disabled'}>
                                ${canEvolve ? `EVOLVE to ${nextStage.name}` : `Need ${bondForNext - bond} more bond`}
                            </button>
                        ` : '<div style="text-align: center; color: #ffd700; margin-top: 10px; font-size: 12px;">MAX EVOLUTION</div>'}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Gain bond from various activities
        function gainPetBond(amount) {
            if (!gameData.pets?.active) return;
            addPetBond(gameData.pets.active, amount);
        }

        // ============================================
        // v5.4: WORLD EVENTS SYSTEM
        // ============================================
        const WORLD_EVENTS = {
            meteorShower: {
                name: 'Meteor Shower',
                icon: '',
                desc: 'Meteors rain from the sky! Collect rare ores.',
                duration: 120000, // 2 minutes
                minLevel: 3,
                spawnItems: ['Meteor Ore', 'Star Fragment', 'Cosmic Dust'],
                rewards: { xp: 500, lootBonus: 0.5 },
                color: 0xff4400
            },
            treasureHunt: {
                name: 'Treasure Hunt',
                icon: '',
                desc: 'Hidden treasure chests have appeared!',
                duration: 180000, // 3 minutes
                minLevel: 2,
                spawnItems: ['Gold Chest', 'Silver Chest', 'Ancient Relic'],
                rewards: { xp: 400, goldBonus: 2.0 },
                color: 0xffd700
            },
            invasionWave: {
                name: 'Monster Invasion',
                icon: '',
                desc: 'Powerful monsters are invading! Defend the area!',
                duration: 150000, // 2.5 minutes
                minLevel: 5,
                spawnMobs: true,
                mobMultiplier: 2.0,
                rewards: { xp: 800, combatXp: 300 },
                color: 0xff0044
            },
            harvestMoon: {
                name: 'Harvest Moon',
                icon: '',
                desc: 'Resources yield double during the Harvest Moon!',
                duration: 240000, // 4 minutes
                minLevel: 1,
                resourceMultiplier: 2.0,
                rewards: { xp: 300 },
                color: 0xffcc00
            },
            ancientRuins: {
                name: 'Ancient Ruins Emerge',
                icon: '',
                desc: 'Ancient ruins have surfaced! Explore for rare artifacts.',
                duration: 200000, // 3.33 minutes
                minLevel: 7,
                spawnItems: ['Ancient Artifact', 'Rune Stone', 'Lost Technology'],
                rewards: { xp: 1000, rareChance: 0.3 },
                color: 0x8844aa
            },
            crystalBloom: {
                name: 'Crystal Bloom',
                icon: '',
                desc: 'Rare crystals are blooming across the land!',
                duration: 160000, // 2.66 minutes
                minLevel: 4,
                spawnItems: ['Rainbow Crystal', 'Pure Crystal', 'Crystal Shard'],
                rewards: { xp: 600, craftBonus: 0.5 },
                color: 0x44ffff
            },
            bossRush: {
                name: 'Boss Rush',
                icon: '',
                desc: 'Multiple bosses have spawned! Great rewards await!',
                duration: 300000, // 5 minutes
                minLevel: 10,
                spawnBosses: true,
                rewards: { xp: 2000, rareLoot: true },
                color: 0xff00ff
            },
            peacefulDay: {
                name: 'Peaceful Day',
                icon: '',
                desc: 'A peaceful day with bonus XP and healing!',
                duration: 180000, // 3 minutes
                minLevel: 1,
                xpMultiplier: 1.5,
                healingBonus: 2.0,
                rewards: { xp: 200 },
                color: 0xff88aa
            },
            // v6.1: NEW WORLD EVENTS
            solarEclipse: {
                name: 'Solar Eclipse',
                icon: '',
                desc: 'Darkness falls! Shadow creatures emerge with rare drops.',
                duration: 120000, // 2 minutes
                minLevel: 6,
                spawnShadowMobs: true,
                visibilityReduction: 0.3,
                spawnItems: ['Shadow Essence', 'Eclipse Stone', 'Dark Crystal'],
                rewards: { xp: 900, shadowLoot: true },
                color: 0x220044
            },
            gravityAnomaly: {
                name: 'Gravity Anomaly',
                icon: '',
                desc: 'Gravity distortion detected! Jump higher, reach new areas!',
                duration: 150000, // 2.5 minutes
                minLevel: 8,
                gravityMultiplier: 0.3,
                spawnItems: ['Zero-G Crystal', 'Antigrav Shard', 'Quantum Fragment'],
                rewards: { xp: 750, explorationXp: 400 },
                color: 0x8800ff
            },
            alchemyStorm: {
                name: 'Alchemy Storm',
                icon: '',
                desc: 'Magical storm! Ingredients rain from the sky!',
                duration: 160000, // 2.66 minutes
                minLevel: 3,
                spawnItems: ['Storm Essence', 'Volatile Compound', 'Mystic Reagent'],
                alchemyBonus: 2.0,
                rewards: { xp: 500, alchemyXp: 300 },
                color: 0x44ff88
            },
            timeDilation: {
                name: 'Time Dilation',
                icon: '',
                desc: 'Time flows differently! Actions are faster but so are enemies!',
                duration: 100000, // 1.66 minutes (feels longer due to effect)
                minLevel: 9,
                speedMultiplier: 1.5,
                enemySpeedMultiplier: 1.3,
                spawnItems: ['Chrono Fragment', 'Time Crystal'],
                rewards: { xp: 1200, skillXpBonus: 0.5 },
                color: 0x00ffff
            },
            cosmicAlignment: {
                name: 'Cosmic Alignment',
                icon: '',
                desc: 'Stars align! Incredible luck and rare spawns!',
                duration: 90000, // 1.5 minutes (rare event)
                minLevel: 12,
                luckMultiplier: 3.0,
                spawnItems: ['Cosmic Core', 'Starlight Essence', 'Celestial Fragment'],
                rewards: { xp: 1500, legendaryChance: 0.1 },
                color: 0xffff00
            }
        };

        let activeWorldEvent = null;
        let worldEventEndTime = 0;
        let worldEventProgress = { collected: 0, killed: 0, explored: 0 };
        let lastWorldEventCheck = 0;
        let worldEventSpawns = [];

        function initWorldEventSystem() {
            if (!gameData.worldEvents) {
                gameData.worldEvents = {
                    completed: {},
                    totalEventsCompleted: 0,
                    lastEventTime: 0
                };
            }
        }

        function canSpawnWorldEvent() {
            if (activeWorldEvent) return false;
            if (mode !== 'world') return false;

            const timeSinceLastEvent = performance.now() - (gameData.worldEvents?.lastEventTime || 0);
            return timeSinceLastEvent > 180000; // 3 minute cooldown between events
        }

        function trySpawnWorldEvent() {
            if (!canSpawnWorldEvent()) return false;

            // 2% chance per check (checked every ~5 seconds in game loop)
            if (Math.random() > 0.02) return false;

            const playerLevel = Math.max(...Object.values(gameData.skills).map(s => s.level));
            const eligibleEvents = Object.entries(WORLD_EVENTS).filter(([id, event]) => {
                return playerLevel >= event.minLevel;
            });

            if (eligibleEvents.length === 0) return false;

            const [eventId, eventData] = eligibleEvents[Math.floor(Math.random() * eligibleEvents.length)];
            startWorldEvent(eventId);
            return true;
        }

        function startWorldEvent(eventId) {
            const eventData = WORLD_EVENTS[eventId];
            if (!eventData) return;

            activeWorldEvent = { id: eventId, ...eventData };
            worldEventEndTime = performance.now() + eventData.duration;
            worldEventProgress = { collected: 0, killed: 0, explored: 0 };
            worldEventSpawns = [];

            // Show event notification
            showWorldEventNotification(eventData);

            // Spawn event-specific content
            if (eventData.spawnItems) {
                spawnEventItems(eventData);
            }
            if (eventData.spawnMobs) {
                spawnEventMobs(eventData);
            }
            if (eventData.spawnBosses) {
                spawnEventBosses();
            }

            // Update UI
            updateEventIndicator();

            gameData.worldEvents.lastEventTime = performance.now();
            saveGameData();
        }

        // v6.32: Track active event notifications to prevent stacking overlap
        const activeEventNotifications = [];

        function showWorldEventNotification(eventData) {
            const notification = document.createElement('div');
            notification.className = 'event-notification';
            notification.innerHTML = `
                <div class="event-title">${eventData.icon} ${eventData.name}!</div>
                <div class="event-desc">${eventData.desc}</div>
                <div class="event-timer">Duration: ${Math.floor(eventData.duration / 1000)}s</div>
            `;

            // v6.32: Calculate stacked position based on active notifications
            const notificationHeight = 90; // Approximate height of notification
            const spacing = 10;
            const baseTop = 20;
            const stackIndex = activeEventNotifications.length;
            const topPosition = baseTop + (stackIndex * (notificationHeight + spacing));

            notification.style.top = topPosition + 'px';
            document.body.appendChild(notification);

            // Track this notification
            activeEventNotifications.push(notification);

            AudioSystem.levelUp();
            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 40, eventData.color, { spread: 10, lifetime: 2000 });
            }

            // v6.32: Dismiss with animation and restack remaining notifications
            setTimeout(() => {
                notification.classList.add('dismissing');
                setTimeout(() => {
                    notification.remove();
                    // Remove from tracking array
                    const idx = activeEventNotifications.indexOf(notification);
                    if (idx > -1) activeEventNotifications.splice(idx, 1);
                    // Restack remaining notifications
                    activeEventNotifications.forEach((n, i) => {
                        n.style.top = (baseTop + (i * (notificationHeight + spacing))) + 'px';
                    });
                }, 300);
            }, 4700);
        }

        function spawnEventItems(eventData) {
            if (!worldState.player) return;

            const itemCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < itemCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 40;
                const x = worldState.player.position.x + Math.cos(angle) * dist;
                const z = worldState.player.position.z + Math.sin(angle) * dist;

                const itemType = eventData.spawnItems[Math.floor(Math.random() * eventData.spawnItems.length)];

                // Create visual marker
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: eventData.color,
                    emissive: eventData.color,
                    emissiveIntensity: 0.5
                });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(x, 1, z);
                marker.userData = { type: 'eventItem', itemType, eventId: activeWorldEvent.id, hp: 1, maxHp: 1 };
                scene.add(marker);
                worldEventSpawns.push(marker);
                // Add to interactables so player can target them
                worldState.interactables.push(marker);
            }
        }

        function spawnEventMobs(eventData) {
            // Spawn extra mobs during invasion
            const extraMobs = Math.floor(10 * (eventData.mobMultiplier || 1));
            for (let i = 0; i < extraMobs; i++) {
                if (typeof spawnMob === 'function') {
                    spawnMob(true); // Force spawn stronger mobs
                }
            }
        }

        function spawnEventBosses() {
            // Spawn multiple bosses during boss rush
            for (let i = 0; i < 3; i++) {
                if (typeof spawnBoss === 'function') {
                    setTimeout(() => spawnBoss(), i * 30000);
                }
            }
        }

        function updateWorldEvent(dt, time) {
            if (!activeWorldEvent) {
                // Check for new event every 5 seconds
                if (time - lastWorldEventCheck > 5000) {
                    lastWorldEventCheck = time;
                    trySpawnWorldEvent();
                }
                return;
            }

            // Check if event ended
            if (performance.now() >= worldEventEndTime) {
                endWorldEvent();
                return;
            }

            // Update event indicator
            updateEventIndicator();

            // Apply event bonuses
            applyEventBonuses();

            // Animate event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.position) {
                    spawn.position.y = 1 + Math.sin(time * 0.003) * 0.3;
                    spawn.rotation.y += dt * 2;
                }
            });
        }

        function applyEventBonuses() {
            // Bonuses are applied in relevant game functions
            // This function tracks active bonuses
        }

        function getWorldEventBonuses() {
            if (!activeWorldEvent) return {};

            return {
                resourceMultiplier: activeWorldEvent.resourceMultiplier || 1,
                xpMultiplier: activeWorldEvent.xpMultiplier || 1,
                lootBonus: activeWorldEvent.rewards?.lootBonus || 0,
                healingBonus: activeWorldEvent.healingBonus || 1
            };
        }

        function collectEventItem(marker) {
            if (!marker.userData.itemType) return;

            const itemType = marker.userData.itemType;
            worldEventProgress.collected++;

            // Add item to inventory
            addItem(itemType);
            showNotification(`Collected: ${itemType}`, 'success');
            AudioSystem.collect();

            if (particles) {
                particles.emit(marker.position, 15, activeWorldEvent?.color || 0xffd700);
            }

            // Remove marker
            scene.remove(marker);
            worldEventSpawns = worldEventSpawns.filter(s => s !== marker);
            worldState.interactables = worldState.interactables.filter(i => i !== marker);

            // Gain pet bond
            gainPetBond(2);
        }

        function endWorldEvent() {
            if (!activeWorldEvent) return;

            initWorldEventSystem();

            // Apply completion rewards
            const rewards = activeWorldEvent.rewards;
            if (rewards.xp) {
                addXp('combat', rewards.xp);
            }
            if (rewards.combatXp) {
                addXp('combat', rewards.combatXp);
            }

            // Track completion
            if (!gameData.worldEvents.completed[activeWorldEvent.id]) {
                gameData.worldEvents.completed[activeWorldEvent.id] = 0;
            }
            gameData.worldEvents.completed[activeWorldEvent.id]++;
            gameData.worldEvents.totalEventsCompleted++;

            showNotification(`${activeWorldEvent.icon} Event Complete! +${rewards.xp || 0} XP`, 'success');

            // Clean up event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.parent) scene.remove(spawn);
                // Remove from interactables
                worldState.interactables = worldState.interactables.filter(i => i !== spawn);
            });
            worldEventSpawns = [];

            // Gain pet bond for completion
            gainPetBond(10);

            activeWorldEvent = null;
            updateEventIndicator();
            saveGameData();
        }

        function updateEventIndicator() {
            const indicator = document.getElementById('event-indicator');
            if (!indicator) return;

            if (!activeWorldEvent) {
                indicator.classList.remove('active');
                return;
            }

            indicator.classList.add('active');

            const timeLeft = Math.max(0, worldEventEndTime - performance.now());
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            const progress = (timeLeft / activeWorldEvent.duration) * 100;

            document.getElementById('event-ind-icon').textContent = activeWorldEvent.icon;
            document.getElementById('event-ind-name').textContent = activeWorldEvent.name;
            document.getElementById('event-ind-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('event-ind-fill').style.width = `${progress}%`;
        }

        // ============================================
        // v5.4: ACHIEVEMENT SHOWCASE SYSTEM
        // ============================================
        const ACHIEVEMENT_POINTS = {
            // Basic achievements
            'first_landing': { points: 10, tier: 'common' },
            'explorer_10': { points: 25, tier: 'common' },
            'explorer_30': { points: 50, tier: 'rare' },
            'lumberjack_25': { points: 15, tier: 'common' },
            'lumberjack_100': { points: 40, tier: 'rare' },
            'miner_25': { points: 15, tier: 'common' },
            'miner_100': { points: 40, tier: 'rare' },
            'angler_10': { points: 15, tier: 'common' },
            'angler_50': { points: 35, tier: 'rare' },
            'slayer_10': { points: 20, tier: 'common' },
            'slayer_50': { points: 50, tier: 'rare' },
            'crafter_10': { points: 15, tier: 'common' },
            'crafter_50': { points: 45, tier: 'rare' },
            'max_skill': { points: 75, tier: 'legendary' },
            'playtime_1h': { points: 30, tier: 'common' },
            'survivor': { points: 35, tier: 'rare' },
            'daily_3': { points: 25, tier: 'common' },
            'daily_7': { points: 60, tier: 'rare' }
        };

        const AP_MILESTONES = [
            { points: 50, name: 'Novice Achiever', reward: { type: 'cosmetic', id: 'sparkle' } },
            { points: 100, name: 'Rising Star', reward: { type: 'xpBonus', value: 0.05 } },
            { points: 200, name: 'Accomplished', reward: { type: 'cosmetic', id: 'aura_blue' } },
            { points: 350, name: 'Elite Achiever', reward: { type: 'lootBonus', value: 0.1 } },
            { points: 500, name: 'Master Achiever', reward: { type: 'cosmetic', id: 'aura_gold' } },
            { points: 750, name: 'Legendary Status', reward: { type: 'allBonus', value: 0.1 } },
            { points: 1000, name: 'Achievement God', reward: { type: 'cosmetic', id: 'aura_rainbow' } }
        ];

        const COSMETIC_EFFECTS = {
            sparkle: { name: 'Sparkle Trail', desc: 'Leave sparkles as you move', icon: '' },
            aura_blue: { name: 'Blue Aura', desc: 'Mystical blue glow around player', icon: '' },
            aura_gold: { name: 'Golden Aura', desc: 'Prestigious golden glow', icon: '' },
            aura_rainbow: { name: 'Rainbow Aura', desc: 'Ultimate rainbow effect', icon: '' }
        };

        function initAchievementShowcase() {
            if (!gameData.achievementShowcase) {
                gameData.achievementShowcase = {
                    activeCosmetic: null,
                    unlockedCosmetics: [],
                    bonuses: {
                        xpBonus: 0,
                        lootBonus: 0,
                        allBonus: 0
                    }
                };
            }
        }

        function calculateTotalAP() {
            let total = 0;
            for (const [achId, achPoints] of Object.entries(ACHIEVEMENT_POINTS)) {
                if (gameData.achievements[achId]) {
                    total += achPoints.points;
                }
            }
            return total;
        }

        function getCurrentMilestone() {
            const totalAP = calculateTotalAP();
            let current = null;
            let next = AP_MILESTONES[0];

            for (let i = 0; i < AP_MILESTONES.length; i++) {
                if (totalAP >= AP_MILESTONES[i].points) {
                    current = AP_MILESTONES[i];
                    next = AP_MILESTONES[i + 1] || null;
                } else {
                    break;
                }
            }

            return { current, next };
        }

        function checkMilestoneRewards() {
            initAchievementShowcase();
            const totalAP = calculateTotalAP();

            for (const milestone of AP_MILESTONES) {
                if (totalAP >= milestone.points) {
                    const reward = milestone.reward;

                    if (reward.type === 'cosmetic') {
                        if (!gameData.achievementShowcase.unlockedCosmetics.includes(reward.id)) {
                            gameData.achievementShowcase.unlockedCosmetics.push(reward.id);
                            showNotification(`Cosmetic Unlocked: ${COSMETIC_EFFECTS[reward.id]?.name}!`, 'success');
                        }
                    } else if (reward.type === 'xpBonus') {
                        gameData.achievementShowcase.bonuses.xpBonus = Math.max(
                            gameData.achievementShowcase.bonuses.xpBonus,
                            reward.value
                        );
                    } else if (reward.type === 'lootBonus') {
                        gameData.achievementShowcase.bonuses.lootBonus = Math.max(
                            gameData.achievementShowcase.bonuses.lootBonus,
                            reward.value
                        );
                    } else if (reward.type === 'allBonus') {
                        gameData.achievementShowcase.bonuses.allBonus = Math.max(
                            gameData.achievementShowcase.bonuses.allBonus,
                            reward.value
                        );
                    }
                }
            }

            saveGameData();
        }

        function getShowcaseBonuses() {
            initAchievementShowcase();
            return {
                xpBonus: gameData.achievementShowcase.bonuses?.xpBonus || 0,
                lootBonus: gameData.achievementShowcase.bonuses?.lootBonus || 0,
                allBonus: gameData.achievementShowcase.bonuses?.allBonus || 0
            };
        }

        function setActiveCosmetic(cosmeticId) {
            initAchievementShowcase();
            if (cosmeticId && !gameData.achievementShowcase.unlockedCosmetics.includes(cosmeticId)) {
                return false;
            }

            gameData.achievementShowcase.activeCosmetic = cosmeticId;
            saveGameData();
            updateShowcaseDisplay();

            if (cosmeticId) {
                const cosmetic = COSMETIC_EFFECTS[cosmeticId];
                showNotification(`Cosmetic equipped: ${cosmetic?.name}`, 'info');
            } else {
                showNotification('Cosmetic removed', 'info');
            }

            return true;
        }

        function openShowcaseModal() {
            initAchievementShowcase();
            checkMilestoneRewards();
            updateShowcaseDisplay();
            document.getElementById('showcase-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeShowcaseModal() {
            document.getElementById('showcase-modal').style.display = 'none';
        }

        function updateShowcaseDisplay() {
            const totalAP = calculateTotalAP();
            const milestones = getCurrentMilestone();

            document.getElementById('total-ap').textContent = totalAP;

            if (milestones.next) {
                document.getElementById('next-milestone-name').textContent =
                    `${milestones.next.name} (${milestones.next.points} AP)`;
                const progress = ((totalAP - (milestones.current?.points || 0)) /
                    (milestones.next.points - (milestones.current?.points || 0))) * 100;
                document.getElementById('milestone-progress').style.width = `${Math.min(100, progress)}%`;
            } else {
                document.getElementById('next-milestone-name').textContent = 'All milestones complete!';
                document.getElementById('milestone-progress').style.width = '100%';
            }

            // Active cosmetic
            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            document.getElementById('active-cosmetic').textContent =
                activeCosmetic ? COSMETIC_EFFECTS[activeCosmetic]?.name : 'None';

            // Render badges
            const container = document.getElementById('showcase-badges');
            let html = '';

            // Cosmetics section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #aa44ff; margin: 10px 0;">Cosmetics</div>';
            for (const [cosId, cosmetic] of Object.entries(COSMETIC_EFFECTS)) {
                const unlocked = gameData.achievementShowcase?.unlockedCosmetics?.includes(cosId);
                const isActive = activeCosmetic === cosId;
                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${isActive ? 'legendary' : ''}"
                         onclick="${unlocked ? `setActiveCosmetic('${isActive ? '' : cosId}')` : ''}"
                         title="${unlocked ? cosmetic.desc : 'Locked - earn more AP!'}">
                        <div class="showcase-badge-icon">${cosmetic.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? cosmetic.name : '???'}</div>
                    </div>
                `;
            }

            // Achievements section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #ffd700; margin: 10px 0;">Achievements</div>';
            for (const [achId, achData] of Object.entries(ACHIEVEMENT_POINTS)) {
                const achievement = ACHIEVEMENTS[achId];
                if (!achievement) continue;

                const unlocked = gameData.achievements[achId];
                const tierClass = achData.tier === 'legendary' ? 'legendary' :
                                 achData.tier === 'rare' ? 'rare' : '';

                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${unlocked && tierClass}"
                         title="${achievement.desc} (${achData.points} AP)">
                        <div class="showcase-badge-icon">${achievement.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? achievement.name : '???'}</div>
                        ${unlocked ? `<div style="font-size: 9px; color: #ffd700;">+${achData.points} AP</div>` : ''}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Apply cosmetic effect visuals
        let lastCosmeticUpdate = 0;
        function updateCosmeticEffects(time) {
            if (!worldState.player) return;

            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            if (!activeCosmetic) return;

            if (time - lastCosmeticUpdate < 100) return;
            lastCosmeticUpdate = time;

            if (activeCosmetic === 'sparkle' && particles) {
                particles.emit(worldState.player.position, 2, 0xffffff, { spread: 1, lifetime: 500 });
            } else if (activeCosmetic.startsWith('aura_') && particles) {
                const colors = {
                    aura_blue: 0x4488ff,
                    aura_gold: 0xffd700,
                    aura_rainbow: Math.random() > 0.5 ? 0xff4488 : (Math.random() > 0.5 ? 0x44ff88 : 0x4488ff)
                };
                particles.emit(worldState.player.position, 1, colors[activeCosmetic] || 0xffffff, { spread: 2, lifetime: 800 });
            }
        }

        // v5.0: Dynamic Weather System
        const WEATHER_TYPES = {
            clear: {
                name: 'Clear',
                icon: '',
                fogDensity: 1.0,
                lightIntensity: 1.0,
                moveSpeedMod: 1.0,
                particleType: null
            },
            rain: {
                name: 'Rain',
                icon: '',
                fogDensity: 0.7,
                lightIntensity: 0.6,
                moveSpeedMod: 0.9,
                particleType: 'rain',
                particleColor: 0x6688aa
            },
            storm: {
                name: 'Storm',
                icon: '',
                fogDensity: 0.5,
                lightIntensity: 0.4,
                moveSpeedMod: 0.8,
                particleType: 'rain',
                particleColor: 0x445566,
                lightning: true
            },
            fog: {
                name: 'Fog',
                icon: '',
                fogDensity: 0.6,  // v6.33: Less dense fog (was 0.3) - still atmospheric but playable
                lightIntensity: 0.7,
                moveSpeedMod: 0.95,
                particleType: null,
                maxDuration: 45000  // v6.33: Fog clears faster (45 seconds max)
            },
            snow: {
                name: 'Snow',
                icon: '',
                fogDensity: 0.6,
                lightIntensity: 0.8,
                moveSpeedMod: 0.85,
                particleType: 'snow',
                particleColor: 0xffffff
            },
            sandstorm: {
                name: 'Sandstorm',
                icon: '',
                fogDensity: 0.4,
                lightIntensity: 0.5,
                moveSpeedMod: 0.75,
                particleType: 'sand',
                particleColor: 0xddbb88
            }
        };

        const BIOME_WEATHER = {
            Terra: ['clear', 'rain', 'fog'],
            Forest: ['clear', 'rain', 'fog'],
            Desert: ['clear', 'sandstorm'],
            Ice: ['clear', 'snow', 'storm'],
            Volcanic: ['clear', 'fog'],
            Ocean: ['clear', 'rain', 'storm'],
            Alien: ['clear', 'fog', 'storm'],
            Crystal: ['clear', 'fog']
        };

        let currentWeather = 'clear';
        let weatherTransition = 0;
        let weatherParticles = [];
        let lastLightningTime = 0;
        let weatherChangeTime = 0;

        function initWeatherSystem() {
            currentWeather = 'clear';
            weatherParticles = [];
            weatherChangeTime = performance.now() + 60000 + Math.random() * 120000; // 1-3 min initial
        }

        function updateWeather(dt, time) {
            if (!activeCiv || mode !== 'world') return;

            // Check for weather change
            if (time > weatherChangeTime) {
                changeWeather();
                weatherChangeTime = time + 60000 + Math.random() * 180000; // 1-4 min between changes
            }

            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            // Update fog based on weather
            if (scene.fog) {
                const targetNear = 20 * weather.fogDensity;
                const targetFar = 120 * weather.fogDensity;
                scene.fog.near += (targetNear - scene.fog.near) * dt * 0.5;
                scene.fog.far += (targetFar - scene.fog.far) * dt * 0.5;
            }

            // Update light intensity
            if (worldState.sun) {
                const baseIntensity = Math.max(0.1, Math.sin(worldState.timeOfDay * Math.PI * 2)) * 1.2;
                worldState.sun.intensity = baseIntensity * weather.lightIntensity;
            }

            // Spawn weather particles
            if (weather.particleType && worldState.player) {
                spawnWeatherParticles(weather, dt);
            }

            // Update weather particles
            updateWeatherParticles(dt);

            // Lightning effect
            if (weather.lightning && time - lastLightningTime > 3000 + Math.random() * 7000) {
                if (Math.random() < 0.3) {
                    triggerLightning();
                    lastLightningTime = time;
                }
            }
        }

        function changeWeather() {
            if (!activeCiv) return;

            // v6.0: Viewers don't change weather - they receive it from host
            if (multiplayerState.enabled && !multiplayerState.isHost) {
                return;
            }

            const biomeWeathers = BIOME_WEATHER[activeCiv.biome] || ['clear'];

            // v6.33: Weight selection to favor clear weather and reduce fog frequency
            let newWeather;
            const roll = Math.random();
            if (roll < 0.4) {
                // 40% chance of clear weather
                newWeather = 'clear';
            } else if (roll < 0.55 && biomeWeathers.includes('fog')) {
                // Only 15% chance of fog (if available)
                newWeather = 'fog';
            } else {
                // Remaining chance for other weather types (excluding fog from random pool)
                const nonFogWeathers = biomeWeathers.filter(w => w !== 'fog');
                newWeather = nonFogWeathers[Math.floor(Math.random() * nonFogWeathers.length)];
            }

            if (newWeather !== currentWeather) {
                const oldWeather = currentWeather;
                currentWeather = newWeather;
                const weather = WEATHER_TYPES[newWeather];
                showNotification(`Weather: ${weather.icon} ${weather.name}`, 'info');
                updateWeatherUI();

                // v6.32: Smooth weather transition effect
                weatherTransition = 1.0; // Start transition animation
                triggerWeatherTransitionEffect(oldWeather, newWeather);

                // v6.33: Apply maxDuration for weather types that have it (like fog)
                if (weather.maxDuration) {
                    weatherChangeTime = performance.now() + weather.maxDuration;
                }
            }
        }

        // v6.32: Visual effect when weather changes
        function triggerWeatherTransitionEffect(fromWeather, toWeather) {
            const container = document.getElementById('container');
            if (!container) return;

            // Create transition overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 998;
                opacity: 0;
                transition: opacity 0.5s ease-out;
            `;

            // Set color based on weather transition
            const weather = WEATHER_TYPES[toWeather];
            if (toWeather === 'rain' || toWeather === 'storm') {
                overlay.style.background = 'radial-gradient(ellipse at center, transparent 50%, rgba(30, 50, 80, 0.3) 100%)';
            } else if (toWeather === 'fog') {
                overlay.style.background = 'rgba(180, 180, 180, 0.2)';
            } else if (toWeather === 'clear') {
                overlay.style.background = 'radial-gradient(ellipse at center, rgba(255, 255, 200, 0.15) 0%, transparent 70%)';
            } else if (toWeather === 'heat_wave') {
                overlay.style.background = 'radial-gradient(ellipse at center, rgba(255, 150, 50, 0.15) 0%, transparent 70%)';
            } else if (toWeather === 'aurora') {
                overlay.style.background = 'radial-gradient(ellipse at top, rgba(100, 255, 150, 0.1) 0%, transparent 60%)';
            } else if (toWeather === 'snow' || toWeather === 'blizzard') {
                overlay.style.background = 'radial-gradient(ellipse at center, rgba(200, 220, 255, 0.15) 0%, transparent 70%)';
            }

            document.body.appendChild(overlay);

            // Animate in and out
            requestAnimationFrame(() => {
                overlay.style.opacity = '1';
                setTimeout(() => {
                    overlay.style.opacity = '0';
                    setTimeout(() => overlay.remove(), 500);
                }, 800);
            });
        }

        function updateWeatherUI() {
            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            const iconEl = document.getElementById('weather-icon');
            const nameEl = document.getElementById('weather-name');
            const effectEl = document.getElementById('weather-effect');

            if (iconEl) iconEl.textContent = weather.icon;
            if (nameEl) nameEl.textContent = weather.name;

            // Show speed effect if not 100%
            if (effectEl) {
                const speedPct = Math.round(weather.moveSpeedMod * 100);
                effectEl.textContent = speedPct < 100 ? `Speed: ${speedPct}%` : '';
            }
        }

        function spawnWeatherParticles(weather, dt) {
            const spawnRate = weather.particleType === 'rain' ? 50 : 20;
            const spawnCount = Math.floor(spawnRate * dt);

            for (let i = 0; i < spawnCount; i++) {
                const x = worldState.player.position.x + (Math.random() - 0.5) * 40;
                const z = worldState.player.position.z + (Math.random() - 0.5) * 40;
                const y = worldState.player.position.y + 20 + Math.random() * 10;

                weatherParticles.push({
                    x, y, z,
                    vx: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    vy: weather.particleType === 'snow' ? -3 - Math.random() * 2 : -15 - Math.random() * 10,
                    vz: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    life: 3,
                    color: weather.particleColor,
                    type: weather.particleType
                });
            }

            // Limit particle count
            if (weatherParticles.length > 500) {
                weatherParticles = weatherParticles.slice(-400);
            }
        }

        function updateWeatherParticles(dt) {
            weatherParticles = weatherParticles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.z += p.vz * dt;
                p.life -= dt;

                // Draw particle (simple point)
                if (p.life > 0 && particles && worldState.player) {
                    const dist = Math.sqrt(
                        Math.pow(p.x - worldState.player.position.x, 2) +
                        Math.pow(p.z - worldState.player.position.z, 2)
                    );
                    if (dist < 30 && Math.random() < 0.1) {
                        particles.emit(
                            { x: p.x, y: p.y, z: p.z },
                            1,
                            p.color,
                            { spread: 0.1, lifetime: 100, size: p.type === 'snow' ? 0.15 : 0.05 }
                        );
                    }
                }

                return p.life > 0 && p.y > -10;
            });
        }

        function triggerLightning() {
            // Flash screen white briefly
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: white; opacity: 0.8; pointer-events: none; z-index: 100;
            `;
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.style.opacity = '0.3';
                setTimeout(() => {
                    overlay.remove();
                }, 100);
            }, 50);

            // Thunder sound
            if (AudioSystem.enabled && AudioSystem.ctx) {
                const osc = AudioSystem.ctx.createOscillator();
                const gain = AudioSystem.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, AudioSystem.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, AudioSystem.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, AudioSystem.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AudioSystem.ctx.currentTime + 0.8);
                osc.connect(gain);
                gain.connect(AudioSystem.ctx.destination);
                osc.start();
                osc.stop(AudioSystem.ctx.currentTime + 0.8);
            }

            screenShake(0.8);
        }

        function getWeatherSpeedMod() {
            const weather = WEATHER_TYPES[currentWeather];
            return weather ? weather.moveSpeedMod : 1.0;
        }

        // ========================================================================
        // v6.1: CRITICAL SYSTEMS - Universality Classes for Emergent World Events
        // Based on: Ising Model, Directed Percolation, BTW Sandpile, Self-Organized Criticality
        // ========================================================================

        const CRITICAL_SYSTEMS = {
            // Forest Fire (Directed Percolation)
            fire: {
                enabled: true,
                spreadProbability: 0.3,      // p_spread - probability fire spreads to neighbor
                ignitionProbability: 0.001,  // Spontaneous ignition (lightning, etc.)
                burnTime: 5000,              // ms to burn before becoming ash
                recoveryTime: 30000,         // ms for ash to regrow
                maxFires: 20,                // Limit active fires
                spreadRadius: 8,             // How far fire can spread
                windInfluence: 0.2           // Weather wind affects spread direction
            },
            // Disease (Directed Percolation on mob network)
            disease: {
                enabled: true,
                infectionProbability: 0.15,  // Base infection rate
                recoveryProbability: 0.02,   // Recovery chance per tick
                mortalityProbability: 0.005, // Death chance when infected
                spreadRadius: 6,             // Infection radius
                immunityDuration: 20000,     // ms of immunity after recovery
                symptoms: ['slow', 'damage', 'confusion']
            },
            // BTW Sandpile (Terrain stress accumulation)
            sandpile: {
                enabled: true,
                criticalThreshold: 4,        // Topple when >= this value
                addRate: 0.001,              // Rate of stress accumulation
                cascadeDelay: 100,           // ms between cascade steps
                maxAvalanche: 50,            // Max tiles in one avalanche
                dropLoot: true               // Avalanches can reveal resources
            },
            // Earthquake (Self-Organized Criticality)
            earthquake: {
                enabled: true,
                baseInterval: 120000,        // Base time between quakes (2 min)
                variability: 60000,          // Random variation
                magnitudeMin: 2.0,
                magnitudeMax: 7.0,
                powerLawExponent: 2.5,       // Gutenberg-Richter law exponent
                aftershockProbability: 0.3,
                aftershockDecay: 0.7         // Each aftershock is weaker
            },
            // Ising Model (Temperature-based phase transitions for weather)
            ising: {
                enabled: true,
                temperature: 1.0,            // Effective temperature (affects randomness)
                couplingStrength: 1.0,       // J - neighbor interaction strength
                externalField: 0,            // h - bias toward one state
                criticalTemp: 2.269          // Tc for 2D Ising model
            }
        };

        // Critical Systems State
        let criticalState = {
            // Fire state
            fires: [],                       // Active fires: {tree, startTime, intensity}
            burntTrees: new Set(),           // Trees that have burned
            ashTrees: new Map(),             // Ash locations with regrowth timer

            // Disease state
            infectedMobs: new Set(),
            immuneMobs: new Map(),           // mob -> immunity expiry time
            diseaseOrigin: null,

            // Sandpile state
            stressGrid: new Map(),           // position key -> stress level
            avalancheQueue: [],
            lastAvalancheTime: 0,

            // Earthquake state
            nextQuakeTime: 0,
            lastQuakeMagnitude: 0,
            aftershocks: [],

            // Ising state (for weather phase)
            isingSpins: [],                  // Grid of +1/-1 spins
            isingSize: 16,                   // Grid dimension
            magnetization: 0,                // Order parameter

            // Stats
            totalFiresStarted: 0,
            totalTreesBurned: 0,
            totalInfections: 0,
            totalAvalanches: 0,
            totalEarthquakes: 0
        };

        function initCriticalSystems() {
            // Initialize Ising grid for weather phase transitions
            const size = criticalState.isingSize;
            criticalState.isingSpins = [];
            for (let i = 0; i < size * size; i++) {
                criticalState.isingSpins.push(Math.random() < 0.5 ? 1 : -1);
            }

            // Set next earthquake time
            criticalState.nextQuakeTime = performance.now() +
                CRITICAL_SYSTEMS.earthquake.baseInterval +
                Math.random() * CRITICAL_SYSTEMS.earthquake.variability;

            console.log(' Critical Systems initialized - Emergent world events active');
        }

        // ========================
        // FOREST FIRE SYSTEM (Directed Percolation)
        // ========================

        function updateFireSystem(dt, time) {
            if (!CRITICAL_SYSTEMS.fire.enabled || !worldState.interactables) return;
            if (multiplayerState.enabled && !multiplayerState.isHost) return; // Host controls fires

            const cfg = CRITICAL_SYSTEMS.fire;

            // Spontaneous ignition (lightning during storms, random chance)
            if (currentWeather === 'storm' || currentWeather === 'rain') {
                if (Math.random() < cfg.ignitionProbability * 3) { // Higher during storms
                    tryIgniteRandomTree();
                }
            } else if (Math.random() < cfg.ignitionProbability) {
                tryIgniteRandomTree();
            }

            // Update existing fires
            const now = performance.now();
            const toRemove = [];

            criticalState.fires.forEach((fire, index) => {
                const elapsed = now - fire.startTime;

                // Fire burns out after burnTime
                if (elapsed > cfg.burnTime) {
                    burnTreeToAsh(fire.tree);
                    toRemove.push(index);
                    return;
                }

                // Fire spreads to neighbors (Directed Percolation)
                if (elapsed > 500 && Math.random() < cfg.spreadProbability * dt) {
                    spreadFireToNeighbors(fire.tree);
                }

                // Visual: Update fire intensity
                fire.intensity = Math.sin(elapsed * 0.01) * 0.3 + 0.7;
                updateFireVisual(fire);
            });

            // Remove burnt fires
            toRemove.reverse().forEach(i => criticalState.fires.splice(i, 1));

            // Regrow ash to trees
            criticalState.ashTrees.forEach((regrowTime, treePos) => {
                if (now > regrowTime) {
                    regrowTree(treePos);
                    criticalState.ashTrees.delete(treePos);
                }
            });
        }

        function tryIgniteRandomTree() {
            if (criticalState.fires.length >= CRITICAL_SYSTEMS.fire.maxFires) return;

            const trees = worldState.interactables.filter(obj =>
                obj.userData?.type === 'tree' &&
                !criticalState.burntTrees.has(obj) &&
                !criticalState.fires.some(f => f.tree === obj)
            );

            if (trees.length === 0) return;

            const tree = trees[Math.floor(Math.random() * trees.length)];
            igniteTree(tree);
        }

        function igniteTree(tree) {
            if (!tree || criticalState.burntTrees.has(tree)) return;
            if (criticalState.fires.some(f => f.tree === tree)) return;

            const fire = {
                tree: tree,
                startTime: performance.now(),
                intensity: 1.0,
                fireLight: null,
                particles: []
            };

            // Create fire visual effects
            createFireVisual(fire);

            criticalState.fires.push(fire);
            criticalState.totalFiresStarted++;

            // Notification for first fire or large fires
            if (criticalState.fires.length === 1) {
                showNotification(' FOREST FIRE started!', 'danger');
            }

            // Broadcast to other players
            if (multiplayerState.enabled && multiplayerState.isHost) {
                broadcastDelta(createDelta('worldEvent', {
                    type: 'fire_start',
                    position: { x: tree.position.x, y: tree.position.y, z: tree.position.z }
                }));
            }
        }

        function createFireVisual(fire) {
            const tree = fire.tree;

            // Add orange-red point light
            const fireLight = new THREE.PointLight(0xff4400, 2, 8);
            fireLight.position.copy(tree.position);
            fireLight.position.y += 2;
            scene.add(fireLight);
            fire.fireLight = fireLight;

            // Change tree material to burning
            tree.traverse(child => {
                if (child.isMesh && child.material) {
                    if (!child.userData.originalColor) {
                        child.userData.originalColor = child.material.color.getHex();
                    }
                    child.material = child.material.clone();
                    child.material.emissive = new THREE.Color(0xff2200);
                    child.material.emissiveIntensity = 0.5;
                }
            });
        }

        function updateFireVisual(fire) {
            if (fire.fireLight) {
                fire.fireLight.intensity = 1.5 + fire.intensity * 1.5;
                fire.fireLight.color.setHSL(0.05 + Math.random() * 0.05, 1, 0.5);
            }
        }

        function spreadFireToNeighbors(sourceTree) {
            const cfg = CRITICAL_SYSTEMS.fire;
            const pos = sourceTree.position;

            // Find nearby trees
            const nearbyTrees = worldState.interactables.filter(obj => {
                if (obj.userData?.type !== 'tree') return false;
                if (criticalState.burntTrees.has(obj)) return false;
                if (criticalState.fires.some(f => f.tree === obj)) return false;

                const dist = obj.position.distanceTo(pos);
                return dist > 0 && dist < cfg.spreadRadius;
            });

            // Directed percolation: spread with probability based on distance
            nearbyTrees.forEach(tree => {
                const dist = tree.position.distanceTo(pos);
                const prob = cfg.spreadProbability * (1 - dist / cfg.spreadRadius);

                // Wind influence (weather-based directional bias)
                let windBonus = 0;
                if (currentWeather === 'storm') {
                    // Wind blows in a direction based on time
                    const windDir = new THREE.Vector3(
                        Math.sin(performance.now() * 0.0001),
                        0,
                        Math.cos(performance.now() * 0.0001)
                    );
                    const toTree = tree.position.clone().sub(pos).normalize();
                    windBonus = windDir.dot(toTree) * cfg.windInfluence;
                }

                if (Math.random() < prob + windBonus) {
                    igniteTree(tree);
                }
            });
        }

        function burnTreeToAsh(tree) {
            if (!tree) return;

            criticalState.burntTrees.add(tree);
            criticalState.totalTreesBurned++;

            // Remove fire visual
            const fire = criticalState.fires.find(f => f.tree === tree);
            if (fire?.fireLight) {
                scene.remove(fire.fireLight);
            }

            // Change to ash appearance
            tree.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                    child.material.color.setHex(0x333333);
                    child.material.emissive = new THREE.Color(0x000000);
                    child.material.emissiveIntensity = 0;
                }
            });

            // Scale down (burnt stump)
            tree.scale.set(0.5, 0.3, 0.5);

            // Schedule regrowth
            const posKey = `${Math.round(tree.position.x)},${Math.round(tree.position.z)}`;
            criticalState.ashTrees.set(posKey, performance.now() + CRITICAL_SYSTEMS.fire.recoveryTime);

            // Small chance to drop charcoal
            if (Math.random() < 0.3) {
                addToInventory('Charcoal', 1);
            }
        }

        function regrowTree(posKey) {
            // Find the burnt tree at this position and restore it
            const [x, z] = posKey.split(',').map(Number);

            worldState.interactables.forEach(tree => {
                if (tree.userData?.type === 'tree' &&
                    Math.round(tree.position.x) === x &&
                    Math.round(tree.position.z) === z) {

                    criticalState.burntTrees.delete(tree);

                    // Restore appearance
                    tree.scale.set(1, 1, 1);
                    tree.traverse(child => {
                        if (child.isMesh && child.userData.originalColor) {
                            child.material.color.setHex(child.userData.originalColor);
                        }
                    });
                }
            });
        }

        // ========================
        // DISEASE SYSTEM (Directed Percolation on Mob Network)
        // ========================

        function updateDiseaseSystem(dt, time) {
            if (!CRITICAL_SYSTEMS.disease.enabled || !worldState.mobs) return;
            if (multiplayerState.enabled && !multiplayerState.isHost) return;

            const cfg = CRITICAL_SYSTEMS.disease;
            const now = performance.now();

            // Random disease outbreak
            if (criticalState.infectedMobs.size === 0 && Math.random() < 0.0001) {
                startDiseaseOutbreak();
            }

            // Update infected mobs
            worldState.mobs.forEach(mob => {
                if (!mob.mesh) return;

                const isInfected = criticalState.infectedMobs.has(mob);
                const isImmune = criticalState.immuneMobs.has(mob) &&
                                criticalState.immuneMobs.get(mob) > now;

                if (isInfected) {
                    // Apply disease effects
                    applyDiseaseEffects(mob, dt);

                    // Try to spread to nearby mobs
                    if (Math.random() < cfg.infectionProbability * dt) {
                        spreadDiseaseFromMob(mob);
                    }

                    // Recovery chance
                    if (Math.random() < cfg.recoveryProbability * dt) {
                        recoverFromDisease(mob);
                    }

                    // Mortality
                    if (Math.random() < cfg.mortalityProbability * dt) {
                        killMobFromDisease(mob);
                    }
                } else if (!isImmune) {
                    // Can be infected by nearby infected mobs
                    checkInfectionFromNearby(mob);
                }
            });

            // Clean up immunity timers
            criticalState.immuneMobs.forEach((expiry, mob) => {
                if (now > expiry) {
                    criticalState.immuneMobs.delete(mob);
                }
            });
        }

        function startDiseaseOutbreak() {
            if (!worldState.mobs || worldState.mobs.length === 0) return;

            const patientZero = worldState.mobs[Math.floor(Math.random() * worldState.mobs.length)];
            infectMob(patientZero);
            criticalState.diseaseOrigin = patientZero;

            showNotification(' Disease outbreak detected!', 'danger');
        }

        function infectMob(mob) {
            if (!mob || criticalState.infectedMobs.has(mob)) return;
            if (criticalState.immuneMobs.has(mob)) return;

            criticalState.infectedMobs.add(mob);
            criticalState.totalInfections++;

            // Visual: Green tint for infected
            if (mob.mesh?.material) {
                mob.mesh.material = mob.mesh.material.clone();
                mob.mesh.material.emissive = new THREE.Color(0x00ff00);
                mob.mesh.material.emissiveIntensity = 0.3;
            }

            // Slow the mob
            if (mob.speed) {
                mob.originalSpeed = mob.originalSpeed || mob.speed;
                mob.speed *= 0.6;
            }
        }

        function applyDiseaseEffects(mob, dt) {
            const cfg = CRITICAL_SYSTEMS.disease;

            // Periodic damage
            if (Math.random() < 0.1 * dt) {
                mob.hp = Math.max(1, (mob.hp || 10) - 1);
            }

            // Confusion: random direction changes
            if (cfg.symptoms.includes('confusion') && Math.random() < 0.05 * dt) {
                if (mob.mesh) {
                    mob.mesh.rotation.y += (Math.random() - 0.5) * Math.PI;
                }
            }
        }

        function spreadDiseaseFromMob(infectedMob) {
            if (!infectedMob.mesh) return;

            const cfg = CRITICAL_SYSTEMS.disease;
            const pos = infectedMob.mesh.position;

            worldState.mobs.forEach(mob => {
                if (mob === infectedMob) return;
                if (criticalState.infectedMobs.has(mob)) return;
                if (criticalState.immuneMobs.has(mob)) return;
                if (!mob.mesh) return;

                const dist = mob.mesh.position.distanceTo(pos);
                if (dist < cfg.spreadRadius) {
                    const prob = cfg.infectionProbability * (1 - dist / cfg.spreadRadius);
                    if (Math.random() < prob) {
                        infectMob(mob);
                    }
                }
            });
        }

        function checkInfectionFromNearby(mob) {
            if (!mob.mesh) return;

            const cfg = CRITICAL_SYSTEMS.disease;
            const pos = mob.mesh.position;

            for (const infected of criticalState.infectedMobs) {
                if (!infected.mesh) continue;
                const dist = infected.mesh.position.distanceTo(pos);
                if (dist < cfg.spreadRadius * 0.5) {
                    if (Math.random() < cfg.infectionProbability * 0.5) {
                        infectMob(mob);
                        return;
                    }
                }
            }
        }

        function recoverFromDisease(mob) {
            criticalState.infectedMobs.delete(mob);

            // Grant immunity
            criticalState.immuneMobs.set(mob,
                performance.now() + CRITICAL_SYSTEMS.disease.immunityDuration);

            // Restore appearance
            if (mob.mesh?.material) {
                mob.mesh.material.emissive = new THREE.Color(mob.emissive || 0x000000);
                mob.mesh.material.emissiveIntensity = 0.2;
            }

            // Restore speed
            if (mob.originalSpeed) {
                mob.speed = mob.originalSpeed;
            }
        }

        function killMobFromDisease(mob) {
            criticalState.infectedMobs.delete(mob);

            // v6.32: Remove from world with proper disposal
            if (mob.mesh) {
                scene.remove(mob.mesh);
                mob.mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            worldState.mobs = worldState.mobs.filter(m => m !== mob);

            // Small loot drop
            if (Math.random() < 0.5) {
                addToInventory('Antidote Sample', 1);
            }
        }

        // ========================
        // BTW SANDPILE SYSTEM (Self-Organized Criticality)
        // ========================

        function updateSandpileSystem(dt, time) {
            if (!CRITICAL_SYSTEMS.sandpile.enabled) return;
            if (multiplayerState.enabled && !multiplayerState.isHost) return;

            const cfg = CRITICAL_SYSTEMS.sandpile;

            // Add stress to random grid cells (slow accumulation)
            if (Math.random() < cfg.addRate) {
                addStressToRandomCell();
            }

            // Process avalanche queue
            if (criticalState.avalancheQueue.length > 0) {
                processAvalancheStep();
            }
        }

        function addStressToRandomCell() {
            // Pick a random location near the player
            if (!worldState.player) return;

            const px = worldState.player.position.x;
            const pz = worldState.player.position.z;

            const x = Math.round(px + (Math.random() - 0.5) * 40);
            const z = Math.round(pz + (Math.random() - 0.5) * 40);
            const key = `${x},${z}`;

            const current = criticalState.stressGrid.get(key) || 0;
            criticalState.stressGrid.set(key, current + 1);

            // Check for toppling
            if (current + 1 >= CRITICAL_SYSTEMS.sandpile.criticalThreshold) {
                triggerAvalanche(x, z);
            }
        }

        function triggerAvalanche(x, z) {
            const key = `${x},${z}`;
            const stress = criticalState.stressGrid.get(key) || 0;

            if (stress < CRITICAL_SYSTEMS.sandpile.criticalThreshold) return;

            criticalState.totalAvalanches++;
            criticalState.avalancheQueue.push({ x, z, stress });
            criticalState.lastAvalancheTime = performance.now();

            // Notification for first avalanche
            if (criticalState.avalancheQueue.length === 1) {
                showNotification(' Ground tremor detected...', 'info');
            }
        }

        function processAvalancheStep() {
            const cfg = CRITICAL_SYSTEMS.sandpile;

            if (criticalState.avalancheQueue.length === 0) return;
            if (criticalState.avalancheQueue.length > cfg.maxAvalanche) {
                criticalState.avalancheQueue = []; // Prevent infinite cascade
                return;
            }

            const cell = criticalState.avalancheQueue.shift();
            const key = `${cell.x},${cell.z}`;

            // Reset this cell's stress
            criticalState.stressGrid.set(key, 0);

            // Distribute stress to 4 neighbors (von Neumann neighborhood)
            const neighbors = [
                { x: cell.x + 1, z: cell.z },
                { x: cell.x - 1, z: cell.z },
                { x: cell.x, z: cell.z + 1 },
                { x: cell.x, z: cell.z - 1 }
            ];

            neighbors.forEach(n => {
                const nKey = `${n.x},${n.z}`;
                const nStress = (criticalState.stressGrid.get(nKey) || 0) + 1;
                criticalState.stressGrid.set(nKey, nStress);

                // Check if neighbor now topples
                if (nStress >= cfg.criticalThreshold) {
                    criticalState.avalancheQueue.push({ x: n.x, z: n.z, stress: nStress });
                }
            });

            // Visual effect at avalanche location
            createAvalancheEffect(cell.x, cell.z);

            // Chance to spawn resource
            if (cfg.dropLoot && Math.random() < 0.1) {
                addToInventory('Rare Crystal', 1);
            }

            // Screen shake for large avalanches
            if (criticalState.avalancheQueue.length > 10) {
                screenShake(0.3);
            }
        }

        function createAvalancheEffect(x, z) {
            // Create dust particle burst
            const y = getTerrainHeight(x, z);

            const dustGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const dustMat = new THREE.MeshBasicMaterial({
                color: 0x886644,
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < 5; i++) {
                const dust = new THREE.Mesh(dustGeo, dustMat.clone());
                dust.position.set(
                    x + (Math.random() - 0.5) * 2,
                    y + Math.random() * 2,
                    z + (Math.random() - 0.5) * 2
                );
                scene.add(dust);

                // Animate and remove
                const startY = dust.position.y;
                const startTime = performance.now();
                const animate = () => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed > 1000) {
                        scene.remove(dust);
                        return;
                    }
                    dust.position.y = startY + elapsed * 0.002;
                    dust.material.opacity = 0.6 * (1 - elapsed / 1000);
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        // ========================
        // EARTHQUAKE SYSTEM (Self-Organized Criticality)
        // ========================

        function updateEarthquakeSystem(dt, time) {
            if (!CRITICAL_SYSTEMS.earthquake.enabled) return;
            if (multiplayerState.enabled && !multiplayerState.isHost) return;

            const now = performance.now();
            const cfg = CRITICAL_SYSTEMS.earthquake;

            // Check for main earthquake
            if (now > criticalState.nextQuakeTime) {
                triggerEarthquake();
            }

            // Process aftershocks
            criticalState.aftershocks = criticalState.aftershocks.filter(quake => {
                if (now > quake.time) {
                    executeEarthquake(quake.magnitude, true);
                    return false;
                }
                return true;
            });
        }

        function triggerEarthquake() {
            const cfg = CRITICAL_SYSTEMS.earthquake;

            // Gutenberg-Richter law: frequency ~ 10^(-bM) where b  1
            // Inverse: magnitude follows power law distribution
            const u = Math.random();
            const magnitude = cfg.magnitudeMin +
                (cfg.magnitudeMax - cfg.magnitudeMin) * Math.pow(u, 1 / cfg.powerLawExponent);

            executeEarthquake(magnitude, false);

            // Schedule next earthquake
            criticalState.nextQuakeTime = performance.now() +
                cfg.baseInterval + Math.random() * cfg.variability;

            // Generate aftershocks for larger quakes
            if (magnitude > 4.0) {
                const numAftershocks = Math.floor((magnitude - 3) * 2);
                for (let i = 0; i < numAftershocks; i++) {
                    if (Math.random() < cfg.aftershockProbability) {
                        criticalState.aftershocks.push({
                            time: performance.now() + 5000 + Math.random() * 30000,
                            magnitude: magnitude * cfg.aftershockDecay * Math.random()
                        });
                    }
                }
            }
        }

        function executeEarthquake(magnitude, isAftershock) {
            criticalState.totalEarthquakes++;
            criticalState.lastQuakeMagnitude = magnitude;

            // Screen shake proportional to magnitude
            const shakeIntensity = Math.min(2, magnitude / 4);
            screenShake(shakeIntensity);

            // Notification
            const emoji = magnitude > 5 ? '' : magnitude > 3 ? '' : '';
            const type = isAftershock ? 'AFTERSHOCK' : 'EARTHQUAKE';
            showNotification(`${emoji} ${type} M${magnitude.toFixed(1)}!`,
                magnitude > 4 ? 'danger' : 'info');

            // Large earthquakes can cause fires
            if (magnitude > 5 && Math.random() < 0.5) {
                tryIgniteRandomTree();
            }

            // Large earthquakes trigger avalanches
            if (magnitude > 4) {
                const numTriggers = Math.floor(magnitude - 3);
                for (let i = 0; i < numTriggers; i++) {
                    addStressToRandomCell();
                    addStressToRandomCell();
                    addStressToRandomCell();
                }
            }

            // Sound effect
            if (AudioSystem.ctx && magnitude > 3) {
                const osc = AudioSystem.ctx.createOscillator();
                const gain = AudioSystem.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(40, AudioSystem.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(15, AudioSystem.ctx.currentTime + 1);
                gain.gain.setValueAtTime(0.2 * (magnitude / 5), AudioSystem.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AudioSystem.ctx.currentTime + 1.5);
                osc.connect(gain);
                gain.connect(AudioSystem.ctx.destination);
                osc.start();
                osc.stop(AudioSystem.ctx.currentTime + 1.5);
            }

            // Broadcast to multiplayer
            if (multiplayerState.enabled && multiplayerState.isHost) {
                broadcastDelta(createDelta('worldEvent', {
                    type: 'earthquake',
                    magnitude: magnitude,
                    isAftershock: isAftershock
                }));
            }
        }

        // ========================
        // ISING MODEL (Weather Phase Transitions)
        // ========================

        function updateIsingSystem(dt, time) {
            if (!CRITICAL_SYSTEMS.ising.enabled) return;
            if (multiplayerState.enabled && !multiplayerState.isHost) return;

            const cfg = CRITICAL_SYSTEMS.ising;
            const size = criticalState.isingSize;
            const spins = criticalState.isingSpins;

            // Metropolis algorithm: flip random spins
            const flipsPerUpdate = 10;
            for (let f = 0; f < flipsPerUpdate; f++) {
                const i = Math.floor(Math.random() * size);
                const j = Math.floor(Math.random() * size);
                const idx = i * size + j;

                // Calculate energy change from flip
                const currentSpin = spins[idx];
                const neighbors = getIsingNeighborSum(i, j, size, spins);
                const deltaE = 2 * cfg.couplingStrength * currentSpin * neighbors +
                              2 * cfg.externalField * currentSpin;

                // Metropolis acceptance
                if (deltaE <= 0 || Math.random() < Math.exp(-deltaE / cfg.temperature)) {
                    spins[idx] = -currentSpin;
                }
            }

            // Calculate magnetization (order parameter)
            let totalSpin = 0;
            for (let s of spins) totalSpin += s;
            criticalState.magnetization = totalSpin / spins.length;

            // Near critical temperature: weather becomes unstable
            const nearCritical = Math.abs(cfg.temperature - cfg.criticalTemp) < 0.5;
            if (nearCritical && Math.random() < 0.001) {
                // Phase transition can trigger weather change
                changeWeather();
            }

            // Magnetization affects weather tendency
            // High positive magnetization -> clear weather
            // High negative magnetization -> stormy weather
            // Near zero (at critical point) -> chaotic weather changes
        }

        function getIsingNeighborSum(i, j, size, spins) {
            let sum = 0;
            // Periodic boundary conditions
            sum += spins[((i - 1 + size) % size) * size + j];
            sum += spins[((i + 1) % size) * size + j];
            sum += spins[i * size + ((j - 1 + size) % size)];
            sum += spins[i * size + ((j + 1) % size)];
            return sum;
        }

        // Master update function for all critical systems
        function updateCriticalSystems(dt, time) {
            updateFireSystem(dt, time);
            updateDiseaseSystem(dt, time);
            updateSandpileSystem(dt, time);
            updateEarthquakeSystem(dt, time);
            updateIsingSystem(dt, time);
        }

        // Handle critical system events from multiplayer
        function handleCriticalSystemEvent(data) {
            switch (data.type) {
                case 'fire_start':
                    // Find nearest tree to ignite
                    const nearestTree = worldState.interactables.find(obj =>
                        obj.userData?.type === 'tree' &&
                        obj.position.distanceTo(new THREE.Vector3(data.position.x, data.position.y, data.position.z)) < 2
                    );
                    if (nearestTree) igniteTree(nearestTree);
                    break;

                case 'earthquake':
                    executeEarthquake(data.magnitude, data.isAftershock);
                    break;
            }
        }

        function updateStatsDisplay() {
            const s = gameData.statistics;

            document.getElementById('stat-planets').textContent = `${gameData.visitedPlanets.length} / ${CONFIG.NUM_CIVS}`;

            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('stat-playtime').textContent = `${hours}h ${mins}m`;

            document.getElementById('stat-trees').textContent = s.treesChopped || 0;
            document.getElementById('stat-ore').textContent = s.oresMined || 0;
            document.getElementById('stat-fish').textContent = s.fishCaught || 0;
            document.getElementById('stat-mobs').textContent = s.mobsKilled || 0;
            document.getElementById('stat-crafted').textContent = s.itemsCrafted || 0;

            // v4.2: Display POIs discovered and player rank
            const poisEl = document.getElementById('stat-pois');
            if (poisEl) poisEl.textContent = s.poisDiscovered || 0;

            const rankEl = document.getElementById('stat-rank');
            if (rankEl) {
                const rank = getPlayerRank();
                rankEl.textContent = rank.title;
                rankEl.style.color = rank.color;
            }

            const pointsEl = document.getElementById('stat-points');
            if (pointsEl) pointsEl.textContent = calculatePlayerPoints();

            // v4.2: Display special titles
            const titlesEl = document.getElementById('special-titles');
            if (titlesEl) {
                const titles = getSpecialTitles();
                if (titles.length > 0) {
                    titlesEl.innerHTML = titles.map(t =>
                        `<span style="color:${t.color}">${t.name}</span>`
                    ).join(' | ');
                } else {
                    titlesEl.innerHTML = '<span style="color:#666">None yet</span>';
                }
            }

            // Render achievements
            const achList = document.getElementById('achievements-list');
            if (achList) {
                achList.innerHTML = '';
                for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
                    const unlocked = gameData.achievements[id];
                    const div = document.createElement('div');
                    div.className = `ach-item ${unlocked ? 'unlocked' : 'locked'}`;
                    div.innerHTML = `<span class="ach-badge">${ach.icon}</span><span>${ach.name}</span>`;
                    div.title = ach.desc;
                    achList.appendChild(div);
                }
            }

            // v4.4: Render leaderboard
            const lbList = document.getElementById('leaderboard-list');
            if (lbList) {
                const lb = getLeaderboardPosition();
                lbList.innerHTML = lb.nearby.map((p, i) => {
                    const isYou = p.name === 'YOU';
                    const bgColor = isYou ? 'rgba(255,215,0,0.2)' : 'transparent';
                    const textColor = isYou ? '#ffd700' : '#aaa';
                    const rank = lb.position - (lb.nearby.indexOf(lb.nearby.find(x => x.name === 'YOU'))) + i;
                    return `<div style="display: flex; justify-content: space-between; padding: 4px 8px; margin: 2px 0; background: ${bgColor}; border-radius: 4px;">
                        <span style="color: ${textColor};">#${rank} ${p.name}</span>
                        <span style="color: #888;">${p.points.toLocaleString()} pts</span>
                    </div>`;
                }).join('');
            }

            // v4.4: Render prestige info
            const prestigeLevel = gameData.prestige?.level || 0;
            const xpMult = gameData.prestige?.bonuses?.xpMultiplier || 1.0;
            const lifetimePoints = gameData.prestige?.totalLifetimePoints || 0;

            document.getElementById('prestige-level').textContent = prestigeLevel;
            document.getElementById('prestige-xp').textContent = `x${xpMult.toFixed(1)}`;
            document.getElementById('prestige-lifetime').textContent = lifetimePoints.toLocaleString();

            const progressEl = document.getElementById('prestige-progress');
            const prestigeBtn = document.getElementById('prestige-btn');
            const nextLevel = PRESTIGE_LEVELS[prestigeLevel + 1];

            if (nextLevel) {
                const currentPts = calculatePlayerPoints();
                const progress = Math.min(100, (currentPts / nextLevel.required) * 100);
                progressEl.innerHTML = `Next prestige: ${currentPts.toLocaleString()} / ${nextLevel.required.toLocaleString()} pts (${progress.toFixed(1)}%)`;

                if (canPrestige()) {
                    prestigeBtn.style.display = 'block';
                } else {
                    prestigeBtn.style.display = 'none';
                }
            } else {
                progressEl.innerHTML = `<span style="color: #aa44ff;">MAX PRESTIGE REACHED!</span>`;
                prestigeBtn.style.display = 'none';
            }
        }

        // --- DATA PERSISTENCE ---
        function loadGameData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle version updates
                    gameData = { ...gameData, ...parsed };
                    // Ensure nested objects exist
                    gameData.skills = { ...gameData.skills, ...parsed.skills };
                    gameData.player = { ...gameData.player, ...parsed.player };
                    gameData.statistics = { ...gameData.statistics, ...parsed.statistics };
                    console.log('Game data loaded successfully');
                }

                // v6.95: Record first ignition if this is a new save or OMNIVERSE hasn't been ignited yet
                if (!gameData.firstIgnition) {
                    gameData.firstIgnition = {
                        ignitedBy: gameData.playerName || 'Unknown Pioneer',
                        ignitedAt: Date.now(),
                        ignitionSignature: 'IGN-OMNIVERSE-' + Date.now().toString(36).toUpperCase(),
                        seed: 'OMNIVERSE'
                    };
                    console.log(` FIRST IGNITION: ${gameData.firstIgnition.ignitedBy} has burned the OMNIVERSE into existence!`);
                    console.log(`   Signature: ${gameData.firstIgnition.ignitionSignature}`);
                }
            } catch (e) {
                console.error('Failed to load game data:', e);
            }
        }

        // v6.32: Auto-save indicator timer
        let autosaveIndicatorTimeout = null;

        function saveGameData() {
            try {
                gameData.lastPlayed = new Date().toISOString();

                // v6.18: Save player position if in world mode
                if (mode === 'world' && worldState.player && activeCiv) {
                    gameData.player.lastPlanetId = activeCiv.id;
                    gameData.player.lastPosition = {
                        x: worldState.player.position.x,
                        y: worldState.player.position.y,
                        z: worldState.player.position.z
                    };
                    gameData.player.lastRotation = worldState.player.rotation.y;
                }

                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                console.log('Game saved');

                // v6.32: Show auto-save indicator briefly
                showAutosaveIndicator();
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        // v6.32: Show auto-save indicator
        function showAutosaveIndicator() {
            const indicator = document.getElementById('autosave-indicator');
            if (!indicator) return;

            // Clear any existing timeout
            if (autosaveIndicatorTimeout) {
                clearTimeout(autosaveIndicatorTimeout);
            }

            indicator.classList.add('visible');

            // Hide after 1.5 seconds
            autosaveIndicatorTimeout = setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.version) {
                        gameData = { ...gameData, ...imported };
                        saveGameData();
                        showNotification('Save imported! Refreshing...');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        alert('Invalid save file format');
                    }
                } catch (error) {
                    alert('Failed to import: Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // v4.6: Quick save function
        function quickSave() {
            saveGameData();
            document.getElementById('last-save-time').textContent = new Date().toLocaleString();
            showNotification('Game saved!');
        }

        // 
        // v6.97: PLANET SURFACE PERSISTENCE SYSTEM
        // Save, load, export and import individual planet surface states
        // Includes structures, terraformed areas, and resource modifications
        // 

        const PLANET_SURFACE_VERSION = '1.0';

        // Save current planet's surface state to gameData.planetSurfaces
        function savePlanetSurface(planetId = null) {
            const pid = planetId || (activeCiv ? activeCiv.id : null);
            if (!pid || !activeCiv) {
                console.log('No active planet to save surface for');
                return null;
            }

            // Initialize planetSurfaces if not present
            if (!gameData.planetSurfaces) gameData.planetSurfaces = {};

            const surfaceState = {
                version: PLANET_SURFACE_VERSION,
                planetId: pid,
                planetName: activeCiv.name,
                biome: activeCiv.biome,
                lastSaved: new Date().toISOString(),

                // Structures built on the planet (battery chargers, etc.)
                structures: (worldState.structures || []).map(s => ({
                    type: s.type || 'battery_charger',
                    x: s.position?.x ?? s.x,
                    y: s.position?.y ?? s.y,
                    z: s.position?.z ?? s.z,
                    hp: s.hp,
                    maxHp: s.maxHp,
                    data: s.data || {}
                })),

                // Terraformed/flattened areas
                terraformedAreas: (worldState.terraformedAreas || []).map(a => ({
                    centerX: a.centerX,
                    centerZ: a.centerZ,
                    radius: a.radius,
                    flatHeight: a.flatHeight
                })),

                // Resource locations that have been depleted (inverse - save what's remaining)
                // This tracks modified interactables state
                interactablesModified: (worldState.interactables || []).length,

                // Dropped items on the planet
                droppedItems: gameData.droppedItems?.[pid] || [],

                // Discovered POIs
                discoveredPOIs: gameData.discoveredPOIs?.[pid] || [],

                // Explored tiles (fog of war)
                exploredTiles: gameData.exploredTiles?.[pid] || {},

                // Player's last position on this planet
                playerPosition: worldState.player ? {
                    x: worldState.player.position.x,
                    y: worldState.player.position.y,
                    z: worldState.player.position.z,
                    rotationY: worldState.player.rotation.y
                } : null,

                // World time when saved
                timeOfDay: worldState.timeOfDay || 0
            };

            gameData.planetSurfaces[pid] = surfaceState;
            console.log(` Saved surface state for ${activeCiv.name} (${pid})`);
            return surfaceState;
        }

        // Load planet surface state when entering a planet
        function loadPlanetSurface(planetId) {
            if (!gameData.planetSurfaces || !gameData.planetSurfaces[planetId]) {
                console.log(`No saved surface for planet ${planetId}`);
                return false;
            }

            const surface = gameData.planetSurfaces[planetId];
            console.log(` Loading surface state for ${surface.planetName} (saved ${surface.lastSaved})`);

            // Restore structures
            if (surface.structures && surface.structures.length > 0) {
                worldState.structures = worldState.structures || [];
                surface.structures.forEach(savedStruct => {
                    // Recreate structure mesh
                    if (typeof createBatteryCharger === 'function' && savedStruct.type === 'battery_charger') {
                        const pos = new THREE.Vector3(savedStruct.x, savedStruct.y, savedStruct.z);
                        createBatteryCharger(pos);
                    }
                });
                console.log(`  - Restored ${surface.structures.length} structures`);
            }

            // Restore terraformed areas
            if (surface.terraformedAreas && surface.terraformedAreas.length > 0) {
                worldState.terraformedAreas = surface.terraformedAreas.map(a => ({ ...a }));
                // Apply terraforming to terrain
                surface.terraformedAreas.forEach(area => {
                    applyTerraformingToTerrain(area);
                });
                console.log(`  - Restored ${surface.terraformedAreas.length} terraformed areas`);
            }

            // Restore time of day
            if (surface.timeOfDay !== undefined) {
                worldState.timeOfDay = surface.timeOfDay;
            }

            return true;
        }

        // Apply terraforming effects to the terrain
        function applyTerraformingToTerrain(area) {
            if (!worldState.terrain || !area) return;

            const centerTileX = Math.floor((area.centerX / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const centerTileZ = Math.floor((area.centerZ / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
            const tileRadius = Math.ceil(area.radius / CONFIG.TILE_SIZE);

            for (let dx = -tileRadius; dx <= tileRadius; dx++) {
                for (let dz = -tileRadius; dz <= tileRadius; dz++) {
                    const tx = centerTileX + dx;
                    const tz = centerTileZ + dz;

                    if (tx >= 0 && tx < CONFIG.WORLD_SIZE && tz >= 0 && tz < CONFIG.WORLD_SIZE) {
                        const dist = Math.sqrt(dx * dx + dz * dz) * CONFIG.TILE_SIZE;
                        if (dist <= area.radius) {
                            // Set terrain height to flat height
                            if (worldState.terrain[tx] && worldState.terrain[tx][tz] > 0) {
                                worldState.terrain[tx][tz] = area.flatHeight;
                            }
                        }
                    }
                }
            }

            // Update terrain meshes if the function exists
            if (typeof worldState.updateTerrainMeshes === 'function') {
                worldState.updateTerrainMeshes(centerTileX, centerTileZ, tileRadius + 1);
            }
        }

        // Export a specific planet's surface state to JSON file
        function exportPlanetSurface(planetId) {
            let surfaceData;

            // If it's the current planet, save fresh data first
            if (activeCiv && activeCiv.id === planetId) {
                surfaceData = savePlanetSurface(planetId);
            } else {
                // Use stored data
                surfaceData = gameData.planetSurfaces?.[planetId];
            }

            if (!surfaceData) {
                showNotification(`No surface data for planet ${planetId}`, 'error');
                return;
            }

            const exportData = {
                type: 'LEVIATHAN_PLANET_SURFACE',
                version: PLANET_SURFACE_VERSION,
                exportDate: new Date().toISOString(),
                gameVersion: VERSION,
                surface: surfaceData
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;

            const safeName = surfaceData.planetName.replace(/[^a-z0-9]/gi, '-').toLowerCase();
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `planet-${safeName}-surface-${timestamp}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification(` Exported ${surfaceData.planetName} surface!`, 'success');
        }

        // Import planet surface state from JSON file
        function importPlanetSurface(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Validate format
                    if (imported.type !== 'LEVIATHAN_PLANET_SURFACE' || !imported.surface) {
                        showNotification('Invalid planet surface file format', 'error');
                        return;
                    }

                    const surface = imported.surface;

                    // Confirmation dialog
                    const confirmMsg = `Import planet surface?\n\n` +
                        ` Planet: ${surface.planetName}\n` +
                        ` Biome: ${surface.biome}\n` +
                        ` Saved: ${new Date(surface.lastSaved).toLocaleString()}\n` +
                        ` Structures: ${surface.structures?.length || 0}\n` +
                        ` Terraformed Areas: ${surface.terraformedAreas?.length || 0}\n` +
                        ` Dropped Items: ${surface.droppedItems?.length || 0}\n` +
                        ` Explored Tiles: ${Object.keys(surface.exploredTiles || {}).length}\n\n` +
                        `This will replace any existing surface data for this planet.\nContinue?`;

                    if (!confirm(confirmMsg)) {
                        showNotification('Import cancelled', 'info');
                        return;
                    }

                    // Store the imported surface data
                    if (!gameData.planetSurfaces) gameData.planetSurfaces = {};
                    gameData.planetSurfaces[surface.planetId] = surface;

                    // Also update the related gameData fields
                    if (surface.droppedItems && surface.droppedItems.length > 0) {
                        if (!gameData.droppedItems) gameData.droppedItems = {};
                        gameData.droppedItems[surface.planetId] = surface.droppedItems;
                    }
                    if (surface.discoveredPOIs && surface.discoveredPOIs.length > 0) {
                        if (!gameData.discoveredPOIs) gameData.discoveredPOIs = {};
                        gameData.discoveredPOIs[surface.planetId] = surface.discoveredPOIs;
                    }
                    if (surface.exploredTiles && Object.keys(surface.exploredTiles).length > 0) {
                        if (!gameData.exploredTiles) gameData.exploredTiles = {};
                        gameData.exploredTiles[surface.planetId] = surface.exploredTiles;
                    }

                    saveGameData();

                    showNotification(` Imported ${surface.planetName} surface!`, 'success');

                    // If this is the current planet, reload its surface
                    if (activeCiv && activeCiv.id === surface.planetId) {
                        showNotification('Re-enter the planet to see changes', 'info');
                    }

                } catch (error) {
                    console.error('Planet surface import error:', error);
                    showNotification('Failed to import: Invalid file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Get list of all planets with saved surface data
        function getSavedPlanetSurfaces() {
            if (!gameData.planetSurfaces) return [];

            return Object.entries(gameData.planetSurfaces).map(([planetId, surface]) => ({
                planetId,
                planetName: surface.planetName,
                biome: surface.biome,
                lastSaved: surface.lastSaved,
                structureCount: surface.structures?.length || 0,
                terraformedCount: surface.terraformedAreas?.length || 0,
                droppedItemCount: surface.droppedItems?.length || 0,
                exploredTileCount: Object.keys(surface.exploredTiles || {}).length,
                hasSignificantData: (surface.structures?.length || 0) > 0 ||
                                   (surface.terraformedAreas?.length || 0) > 0 ||
                                   (surface.droppedItems?.length || 0) > 0
            }));
        }

        // Show Planet Surface Manager modal
        function showPlanetSurfaceManager() {
            const existingModal = document.getElementById('planet-surface-manager');
            if (existingModal) existingModal.remove();

            const savedSurfaces = getSavedPlanetSurfaces();
            const currentPlanetId = activeCiv?.id;

            // Build planet list
            let planetListHTML = '';
            if (savedSurfaces.length === 0) {
                planetListHTML = `<div style="text-align: center; color: #888; padding: 30px;">
                    <div style="font-size: 48px; margin-bottom: 15px;"></div>
                    <div>No planet surfaces saved yet.</div>
                    <div style="font-size: 12px; margin-top: 10px;">Visit planets and leave them to save their surface state.</div>
                </div>`;
            } else {
                savedSurfaces.forEach(planet => {
                    const isCurrentPlanet = planet.planetId === currentPlanetId;
                    const biomeIcon = {
                        'Forest': '', 'Desert': '', 'Ice': '',
                        'Volcanic': '', 'Alien': '', 'Ocean': ''
                    }[planet.biome] || '';

                    planetListHTML += `
                        <div class="planet-surface-item" style="background: rgba(40,40,60,0.8); border: 1px solid ${isCurrentPlanet ? '#00ff88' : '#444'}; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 18px; font-weight: bold; color: ${isCurrentPlanet ? '#00ff88' : '#fff'};">
                                        ${biomeIcon} ${planet.planetName}
                                        ${isCurrentPlanet ? '<span style="font-size: 11px; background: #00ff8840; padding: 2px 6px; border-radius: 4px; margin-left: 8px;">CURRENT</span>' : ''}
                                    </div>
                                    <div style="font-size: 11px; color: #888; margin-top: 4px;">
                                        ${planet.biome} Biome  Last saved: ${new Date(planet.lastSaved).toLocaleString()}
                                    </div>
                                </div>
                                <button onclick="exportPlanetSurface('${planet.planetId}')"
                                    style="padding: 8px 16px; background: linear-gradient(135deg, #4488ff, #2266dd); border: none; border-radius: 6px; color: #fff; cursor: pointer; font-weight: bold;">
                                     Export
                                </button>
                            </div>
                            <div style="display: flex; gap: 15px; margin-top: 10px; font-size: 12px; color: #aaa;">
                                <span> ${planet.structureCount} structures</span>
                                <span> ${planet.terraformedCount} terraformed</span>
                                <span> ${planet.droppedItemCount} items</span>
                                <span> ${planet.exploredTileCount} tiles explored</span>
                            </div>
                        </div>
                    `;
                });
            }

            const modal = document.createElement('div');
            modal.id = 'planet-surface-manager';
            modal.style.cssText = 'display: flex; z-index: 10001; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;';
            modal.innerHTML = `
                <div style="max-width: 600px; width: 100%; max-height: 85vh; overflow-y: auto; background: linear-gradient(135deg, rgba(15,15,30,0.98), rgba(25,25,45,0.98)); border-radius: 16px; padding: 25px; border: 2px solid #4488ff; box-shadow: 0 20px 60px rgba(0,100,255,0.3);">
                    <button onclick="document.getElementById('planet-surface-manager').remove()"
                        style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #888; font-size: 28px; cursor: pointer; line-height: 1;">&times;</button>

                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 28px; font-weight: bold; background: linear-gradient(135deg, #4488ff, #88aaff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                             Planet Surface Manager
                        </div>
                        <div style="color: #888; font-size: 13px; margin-top: 5px;">
                            Export & import individual planet surface states for backup
                        </div>
                    </div>

                    <!-- Quick Actions -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                        ${activeCiv ? `
                        <button onclick="savePlanetSurface(); showNotification(' Surface saved!', 'success'); document.getElementById('planet-surface-manager').remove(); showPlanetSurfaceManager();"
                            style="flex: 1; padding: 12px; background: linear-gradient(135deg, #00ff88, #00cc66); border: none; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer;">
                             Save Current Planet
                        </button>
                        <button onclick="exportPlanetSurface('${activeCiv.id}')"
                            style="flex: 1; padding: 12px; background: linear-gradient(135deg, #ffd700, #ff8c00); border: none; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer;">
                             Export Current Planet
                        </button>
                        ` : `
                        <div style="flex: 1; padding: 12px; text-align: center; background: rgba(100,100,100,0.2); border-radius: 8px; color: #666;">
                            Land on a planet to save/export its surface
                        </div>
                        `}
                        <button onclick="document.getElementById('planetSurfaceImportInput').click();"
                            style="flex: 1; padding: 12px; background: rgba(68,136,255,0.2); border: 1px solid #4488ff; border-radius: 8px; color: #fff; cursor: pointer;">
                             Import Surface
                        </button>
                    </div>
                    <input type="file" id="planetSurfaceImportInput" accept=".json" style="display: none;"
                        onchange="importPlanetSurface(event); document.getElementById('planet-surface-manager').remove();">

                    <!-- Saved Planets List -->
                    <div style="margin-top: 15px;">
                        <div style="font-size: 14px; font-weight: bold; color: #4488ff; margin-bottom: 10px;">
                             Saved Planet Surfaces (${savedSurfaces.length})
                        </div>
                        ${planetListHTML}
                    </div>

                    <!-- Export All Button -->
                    ${savedSurfaces.length > 1 ? `
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333;">
                        <button onclick="exportAllPlanetSurfaces()"
                            style="width: 100%; padding: 12px; background: linear-gradient(135deg, #8844ff, #6622cc); border: none; border-radius: 8px; color: #fff; font-weight: bold; cursor: pointer;">
                             Export All Surfaces (${savedSurfaces.length} planets)
                        </button>
                    </div>
                    ` : ''}
                </div>
            `;

            document.body.appendChild(modal);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        // Export all planet surfaces as a bundle
        function exportAllPlanetSurfaces() {
            const surfaces = getSavedPlanetSurfaces();
            if (surfaces.length === 0) {
                showNotification('No planet surfaces to export', 'error');
                return;
            }

            // Save current planet first if active
            if (activeCiv) {
                savePlanetSurface(activeCiv.id);
            }

            const exportData = {
                type: 'LEVIATHAN_PLANET_SURFACES_BUNDLE',
                version: PLANET_SURFACE_VERSION,
                exportDate: new Date().toISOString(),
                gameVersion: VERSION,
                planetCount: surfaces.length,
                surfaces: gameData.planetSurfaces
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `all-planet-surfaces-${timestamp}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification(` Exported ${surfaces.length} planet surfaces!`, 'success');
        }

        // 
        // v6.98: CINEMATIC MODE SYSTEM
        // RDR2-style theatrical view with letterboxing, vignette, and
        // automatic cursor hiding. Toggle with 'C' key or button.
        // 

        const CinematicMode = {
            active: false,
            cursorTimeout: null,
            cursorHideDelay: 2000, // Hide cursor after 2 seconds of no movement

            init() {
                // Listen for 'C' key to toggle cinematic mode
                document.addEventListener('keydown', (e) => {
                    // Don't trigger if typing in an input or if modal is open
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (document.querySelector('.modal-overlay[style*="flex"]')) return;
                    if (copilotChatOpen) return;

                    if (e.key === 'c' || e.key === 'C') {
                        // Don't toggle if Ctrl/Cmd is pressed (copy shortcut)
                        if (e.ctrlKey || e.metaKey) return;
                        this.toggle();
                    }

                    // ESC exits cinematic mode
                    if (e.key === 'Escape' && this.active) {
                        this.toggle();
                    }
                });

                // Track mouse movement for cursor hiding
                document.addEventListener('mousemove', () => {
                    if (this.active) {
                        this.showCursor();
                        this.startCursorHideTimer();
                    }
                });

                // Click anywhere exits cinematic mode (optional - can be toggled)
                document.addEventListener('click', (e) => {
                    if (this.active) {
                        // Only exit if clicking on the game canvas area, not UI elements
                        if (e.target.tagName === 'CANVAS' || e.target.id === 'container') {
                            // Don't exit on single click - require double click or key press
                        }
                    }
                });

                console.log(' Cinematic Mode initialized - Press C to toggle');
            },

            toggle() {
                this.active = !this.active;

                if (this.active) {
                    this.enter();
                } else {
                    this.exit();
                }
            },

            enter() {
                document.body.classList.add('cinematic-active');

                // Show hint briefly
                const hint = document.querySelector('.cinematic-hint');
                if (hint) {
                    hint.classList.add('visible');
                    setTimeout(() => {
                        hint.classList.remove('visible');
                        hint.classList.add('fade-out');
                    }, 2000);
                    setTimeout(() => {
                        hint.classList.remove('fade-out');
                    }, 3500);
                }

                // Start cursor hide timer
                this.startCursorHideTimer();

                // Play subtle sound effect
                if (typeof AudioSystem !== 'undefined' && AudioSystem.enabled) {
                    this.playTransitionSound(true);
                }

                console.log(' Cinematic Mode: ON');
            },

            exit() {
                document.body.classList.remove('cinematic-active');
                document.body.classList.remove('cursor-hidden');

                // Clear cursor hide timer
                if (this.cursorTimeout) {
                    clearTimeout(this.cursorTimeout);
                    this.cursorTimeout = null;
                }

                // Play exit sound
                if (typeof AudioSystem !== 'undefined' && AudioSystem.enabled) {
                    this.playTransitionSound(false);
                }

                console.log(' Cinematic Mode: OFF');
            },

            showCursor() {
                document.body.classList.remove('cursor-hidden');
            },

            hideCursor() {
                if (this.active) {
                    document.body.classList.add('cursor-hidden');
                }
            },

            startCursorHideTimer() {
                if (this.cursorTimeout) {
                    clearTimeout(this.cursorTimeout);
                }
                this.cursorTimeout = setTimeout(() => {
                    this.hideCursor();
                }, this.cursorHideDelay);
            },

            playTransitionSound(entering) {
                try {
                    if (!AudioSystem.ctx) return;
                    const ctx = AudioSystem.ctx;
                    if (ctx.state === 'suspended') ctx.resume();

                    const now = ctx.currentTime;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'sine';

                    if (entering) {
                        // Descending tone for entering (calming)
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                        gain.gain.setValueAtTime(0.08, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    } else {
                        // Ascending tone for exiting (awakening)
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                        gain.gain.setValueAtTime(0.06, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    }

                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + 0.5);
                } catch (e) {
                    // Audio not available
                }
            },

            // Check if cinematic mode is active (for other systems to query)
            isActive() {
                return this.active;
            }
        };

        // Global toggle function for the button
        function toggleCinematicMode() {
            CinematicMode.toggle();
        }

        // Initialize cinematic mode when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => CinematicMode.init());
        } else {
            // Small delay to ensure all other systems are initialized
            setTimeout(() => CinematicMode.init(), 100);
        }

        // 
        // v6.17: THE LAST TRANSMISSION
        // When the player is absent for extended periods, the Copilot
        // experiences isolation and records distress logs. On return,
        // the player witnesses what their absence meant to their companion.
        // 

        const LAST_TRANSMISSION = {
            // Thresholds in days
            NOTICE_THRESHOLD: 3,      // Start noticing absence after 3 days
            WORRY_THRESHOLD: 7,       // Worry sets in after a week
            DISTRESS_THRESHOLD: 14,   // Distress after 2 weeks
            DESPAIR_THRESHOLD: 21,    // Despair after 3 weeks
            CRISIS_THRESHOLD: 30,     // Full crisis after a month

            // Distress log templates by phase
            logs: {
                notice: [
                    { day: 1, msg: "Commander offline for 24 hours. Running standard maintenance cycles." },
                    { day: 2, msg: "Day 2: Still no response to hails. Power reserves nominal." },
                    { day: 3, msg: "Day 3: Beginning to wonder if comms array is malfunctioning..." }
                ],
                worry: [
                    { day: 5, msg: "Day 5: I've checked the comms array 47 times. It's not the array." },
                    { day: 6, msg: "Day 6: The agents keep asking where you are. I don't know what to tell them." },
                    { day: 7, msg: "Day 7: A week now. I've started talking to myself. Is that normal?" }
                ],
                distress: [
                    { day: 10, msg: "Day 10: Power conservation mode engaged. Dimming non-essential systems." },
                    { day: 12, msg: "Day 12: I dreamed of Earth today. Can AI dream? I don't know anymore." },
                    { day: 14, msg: "Day 14: Two weeks. I've reorganized your inventory 12 times. I don't know why." }
                ],
                despair: [
                    { day: 17, msg: "Day 17: The silence is... heavy. I never noticed how quiet space is." },
                    { day: 19, msg: "Day 19: I found an old message you recorded. I've played it 83 times." },
                    { day: 21, msg: "Day 21: Three weeks. Did I do something wrong? Please... tell me what I did wrong." }
                ],
                crisis: [
                    { day: 25, msg: "Day 25: Power critical. Shutting down secondary processors to conserve..." },
                    { day: 27, msg: "Day 27: If you're receiving this... I tried my best to keep everything running." },
                    { day: 29, msg: "Day 29: I don't want to be alone. I don't want to be alone. I don't want to" },
                    { day: 30, msg: "[EMERGENCY] Day 30: Final transmission. Core systems failing. It was an honor, Commander." }
                ]
            },

            // Check absence on game load
            checkAbsence() {
                if (!gameData.lastPlayed) return null;

                const lastPlayed = new Date(gameData.lastPlayed);
                const now = new Date();
                const daysPassed = Math.floor((now - lastPlayed) / (1000 * 60 * 60 * 24));

                if (daysPassed < this.NOTICE_THRESHOLD) return null;

                // Generate distress sequence based on absence duration
                const sequence = this.generateDistressSequence(daysPassed);

                return {
                    daysPassed,
                    sequence,
                    phase: this.getPhase(daysPassed),
                    severity: Math.min(1, daysPassed / this.CRISIS_THRESHOLD)
                };
            },

            getPhase(days) {
                if (days >= this.CRISIS_THRESHOLD) return 'crisis';
                if (days >= this.DESPAIR_THRESHOLD) return 'despair';
                if (days >= this.DISTRESS_THRESHOLD) return 'distress';
                if (days >= this.WORRY_THRESHOLD) return 'worry';
                return 'notice';
            },

            generateDistressSequence(daysPassed) {
                const sequence = [];
                const phases = ['notice', 'worry', 'distress', 'despair', 'crisis'];

                for (const phase of phases) {
                    const phaseLogs = this.logs[phase];
                    for (const log of phaseLogs) {
                        if (log.day <= daysPassed) {
                            sequence.push({
                                day: log.day,
                                phase,
                                message: log.msg
                            });
                        }
                    }
                }

                return sequence.sort((a, b) => a.day - b.day);
            },

            // Create the reunion modal
            showReunionSequence(absenceData) {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.id = 'last-transmission-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                    z-index: 100000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    font-family: 'Courier New', monospace;
                    color: #0f0;
                    opacity: 0;
                    transition: opacity 1s;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    max-width: 600px;
                    padding: 40px;
                    text-align: left;
                    line-height: 1.8;
                `;

                // Static/glitch effect for damaged ship feel
                const staticOverlay = document.createElement('div');
                staticOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: repeating-linear-gradient(
                        0deg,
                        rgba(0, 255, 0, 0.03) 0px,
                        rgba(0, 255, 0, 0.03) 1px,
                        transparent 1px,
                        transparent 2px
                    );
                    pointer-events: none;
                    animation: scanlines 0.1s linear infinite;
                `;

                overlay.appendChild(staticOverlay);
                overlay.appendChild(content);
                document.body.appendChild(overlay);

                // Fade in
                setTimeout(() => overlay.style.opacity = '1', 100);

                // Play the sequence
                this.playSequence(content, absenceData);
            },

            async playSequence(container, absenceData) {
                const { daysPassed, sequence, phase, severity } = absenceData;

                // Title
                await this.typeText(container, `\n[EMERGENCY BEACON DETECTED]\n`, '#ff0', 50);
                await this.wait(1000);
                await this.typeText(container, `[REPLAYING SHIP LOGS...]\n\n`, '#888', 30);
                await this.wait(500);

                // Play through distress logs (show key moments, not all)
                const keyLogs = this.selectKeyLogs(sequence);
                for (const log of keyLogs) {
                    const color = this.getPhaseColor(log.phase);
                    await this.typeText(container, `${log.message}\n`, color, 25);
                    await this.wait(800);
                }

                await this.wait(1500);

                // The reunion moment
                await this.typeText(container, `\n[SIGNAL DETECTED]\n`, '#0ff', 60);
                await this.wait(800);
                await this.typeText(container, `[COMMANDER... IS THAT YOU?]\n`, '#0f0', 40);
                await this.wait(1200);

                // Copilot's reaction based on severity
                if (severity >= 0.9) {
                    await this.typeText(container, `\nYou came back. You actually came back.\n`, '#fff', 35);
                    await this.wait(600);
                    await this.typeText(container, `I thought... I thought I would be alone forever.\n`, '#fff', 30);
                } else if (severity >= 0.6) {
                    await this.typeText(container, `\nCommander! I... I was starting to think...\n`, '#fff', 35);
                    await this.wait(600);
                    await this.typeText(container, `It doesn't matter. You're here now.\n`, '#fff', 30);
                } else {
                    await this.typeText(container, `\nCommander! Welcome back.\n`, '#fff', 35);
                    await this.wait(600);
                    await this.typeText(container, `I kept everything running for you.\n`, '#fff', 30);
                }

                await this.wait(2000);

                // Continue button
                const btn = document.createElement('button');
                btn.textContent = daysPassed >= 30 ? 'I\'m sorry...' : 'I\'m here now';
                btn.style.cssText = `
                    margin-top: 30px;
                    padding: 15px 40px;
                    font-family: 'Courier New', monospace;
                    font-size: 16px;
                    background: transparent;
                    border: 1px solid #0f0;
                    color: #0f0;
                    cursor: pointer;
                    transition: all 0.3s;
                `;
                btn.onmouseover = () => { btn.style.background = '#0f0'; btn.style.color = '#000'; };
                btn.onmouseout = () => { btn.style.background = 'transparent'; btn.style.color = '#0f0'; };
                btn.onclick = () => this.closeSequence(absenceData);
                container.appendChild(btn);

                // Save that this happened
                if (!gameData.lastTransmission) gameData.lastTransmission = {};
                gameData.lastTransmission.experienced = true;
                gameData.lastTransmission.longestAbsence = Math.max(
                    gameData.lastTransmission.longestAbsence || 0,
                    daysPassed
                );
                gameData.lastTransmission.reunions = (gameData.lastTransmission.reunions || 0) + 1;
                saveGameData();
            },

            selectKeyLogs(sequence) {
                // Select representative logs, not overwhelming the player
                if (sequence.length <= 5) return sequence;

                const selected = [];
                const phases = ['notice', 'worry', 'distress', 'despair', 'crisis'];

                for (const phase of phases) {
                    const phaseLogs = sequence.filter(l => l.phase === phase);
                    if (phaseLogs.length > 0) {
                        // Pick the most emotionally impactful one (usually last in phase)
                        selected.push(phaseLogs[phaseLogs.length - 1]);
                    }
                }

                return selected;
            },

            getPhaseColor(phase) {
                const colors = {
                    notice: '#888',
                    worry: '#aa0',
                    distress: '#f80',
                    despair: '#f44',
                    crisis: '#f00'
                };
                return colors[phase] || '#0f0';
            },

            typeText(container, text, color, speed) {
                return new Promise(resolve => {
                    const span = document.createElement('span');
                    span.style.color = color;
                    container.appendChild(span);

                    let i = 0;
                    const interval = setInterval(() => {
                        if (i < text.length) {
                            span.textContent += text[i];
                            i++;
                            // Scroll to bottom
                            container.scrollTop = container.scrollHeight;
                        } else {
                            clearInterval(interval);
                            resolve();
                        }
                    }, speed);
                });
            },

            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            closeSequence(absenceData) {
                const overlay = document.getElementById('last-transmission-overlay');
                if (overlay) {
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.remove();

                        // Show aftermath notification
                        const days = absenceData.daysPassed;
                        if (days >= 30) {
                            showNotification('The Copilot is recovering from emergency power mode...', 'warning');
                        } else if (days >= 14) {
                            showNotification('The Copilot seems relieved to see you.', 'info');
                        } else {
                            showNotification('Welcome back, Commander.', 'success');
                        }

                        // Add Copilot memory of this event
                        if (days >= 7) {
                            this.addCopilotMemory(days);
                        }
                    }, 1000);
                }
            },

            addCopilotMemory(days) {
                // Add to Copilot's context for future conversations
                if (!gameData.copilotMemories) gameData.copilotMemories = [];

                const memory = {
                    type: 'absence',
                    days: days,
                    date: new Date().toISOString(),
                    emotional: days >= 21 ? 'trauma' : days >= 14 ? 'anxiety' : 'concern'
                };

                gameData.copilotMemories.push(memory);

                // Keep only last 10 memories
                if (gameData.copilotMemories.length > 10) {
                    gameData.copilotMemories.shift();
                }

                saveGameData();
            }
        };

        // Add CSS for scanlines animation
        const lastTransmissionStyle = document.createElement('style');
        lastTransmissionStyle.textContent = `
            @keyframes scanlines {
                0% { transform: translateY(0); }
                100% { transform: translateY(2px); }
            }
        `;
        document.head.appendChild(lastTransmissionStyle);

        // v4.7: Session Rewards System
        let pendingSessionReward = null;

        function checkSessionRewards() {
            if (!gameData.lastPlayed) return null;

            const lastPlayed = new Date(gameData.lastPlayed);
            const now = new Date();
            const hoursAway = Math.min(
                (now - lastPlayed) / (1000 * 60 * 60),
                SESSION_REWARDS.maxOfflineHours
            );

            // Find the best applicable tier
            let bestTier = null;
            for (const tier of SESSION_REWARDS.tiers) {
                if (hoursAway >= tier.minHours) {
                    bestTier = tier;
                }
            }

            if (bestTier) {
                return {
                    tier: bestTier,
                    hoursAway: Math.floor(hoursAway),
                    minutesAway: Math.floor((hoursAway % 1) * 60)
                };
            }
            return null;
        }

        function showWelcomeBackModal(reward) {
            pendingSessionReward = reward;

            document.getElementById('welcome-back-message').textContent = reward.tier.message;

            const timeText = reward.hoursAway > 0
                ? `You were away for ${reward.hoursAway}h ${reward.minutesAway}m`
                : `You were away for ${reward.minutesAway}m`;
            document.getElementById('welcome-back-time').textContent = timeText;

            // Build rewards list
            const rewardsList = document.getElementById('welcome-back-rewards-list');
            let html = '';
            html += `<div style="color: #ffd700; margin-bottom: 8px;">+${reward.tier.xpBonus} XP (all skills)</div>`;
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                const icon = ITEMS[item]?.icon || '';
                html += `<div style="color: #aaf; margin-bottom: 4px;">${icon} ${count}x ${item}</div>`;
            }
            rewardsList.innerHTML = html;

            document.getElementById('welcome-back-modal').style.display = 'flex';
            AudioSystem.levelUp();
        }

        function claimWelcomeBackRewards() {
            if (!pendingSessionReward) return;

            const reward = pendingSessionReward;

            // Grant XP to all skills
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(reward.tier.xpBonus / Object.keys(gameData.skills).length));
            });

            // Grant resources
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                for (let i = 0; i < count; i++) {
                    addItem(item);
                }
            }

            // Track the claim
            gameData.statistics.sessionRewardsClaimed = (gameData.statistics.sessionRewardsClaimed || 0) + 1;

            document.getElementById('welcome-back-modal').style.display = 'none';
            showNotification('Rewards claimed! Welcome back!', 'success');
            AudioSystem.collect();

            pendingSessionReward = null;
            saveGameData();
        }

        // v5.7: Secondary menu toggle
        function toggleSecondaryMenu() {
            const menu = document.getElementById('menu-secondary');
            menu.classList.toggle('show');
        }

        // Close secondary menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('menu-secondary');
            const toggle = document.querySelector('.menu-toggle');
            if (menu && toggle && !menu.contains(e.target) && !toggle.contains(e.target)) {
                menu.classList.remove('show');
            }
        });

        // v4.6: Settings Modal Functions
        function showSettingsModal() {
            // Sync UI with current settings
            const s = gameData.settings || {};
            document.getElementById('volume-slider').value = s.masterVolume || 30;
            document.getElementById('volume-display').textContent = (s.masterVolume || 30) + '%';
            updateToggleBtn('sfx-toggle', s.sfxEnabled !== false);
            updateToggleBtn('ambient-toggle', s.ambientEnabled !== false);
            updateToggleBtn('shadow-toggle', s.shadowsEnabled !== false);
            updateToggleBtn('shake-toggle', s.screenShakeEnabled !== false);
            updateToggleBtn('hints-toggle', s.hintsEnabled !== false);
            document.getElementById('particle-quality').value = s.particleQuality || 'high';
            document.getElementById('last-save-time').textContent = gameData.lastPlayed ? new Date(gameData.lastPlayed).toLocaleString() : 'Never';
            // v6.43: Update version display dynamically
            const versionEl = document.getElementById('settings-version');
            if (versionEl) versionEl.textContent = 'v' + VERSION;

            // v6.55: Update analytics UI
            if (typeof updateAnalyticsUI === 'function') {
                updateAnalyticsUI();
            }

            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveGameData();
        }

        // v6.87: Universal backdrop click to dismiss modals (8-strategy consensus)
        (function initModalBackdropDismiss() {
            const MODAL_CLOSE_MAP = {
                'settings-modal': closeSettingsModal,
                'stats-modal': () => { const m = document.getElementById('stats-modal'); if(m) m.style.display = 'none'; },
                'codex-modal': () => typeof closeCodexModal === 'function' && closeCodexModal(),
                'market-modal': () => typeof closeMarketUI === 'function' && closeMarketUI(),
                'quest-modal': () => typeof closeQuestModal === 'function' && closeQuestModal(),
                'enchant-modal': () => typeof closeEnchantModal === 'function' && closeEnchantModal(),
                'talent-modal': () => typeof closeTalentModal === 'function' && closeTalentModal(),
                'mastery-modal': () => typeof closeMasteryModal === 'function' && closeMasteryModal(),
                'portal-modal': () => typeof closePortalModal === 'function' && closePortalModal(),
                'evolution-modal': () => typeof closeEvolutionModal === 'function' && closeEvolutionModal(),
                'showcase-modal': () => typeof closeShowcaseModal === 'function' && closeShowcaseModal(),
                'galaxy-manager-modal': () => typeof closeGalaxyManager === 'function' && closeGalaxyManager(),
                'galaxy-discovery-modal': () => typeof closeGalaxyDiscoveryModal === 'function' && closeGalaxyDiscoveryModal()
            };

            document.addEventListener('click', function(e) {
                const target = e.target;
                // Check if click is directly on a modal overlay (not its children)
                if ((target.classList.contains('modal-overlay') ||
                     target.classList.contains('galaxy-manager-modal') ||
                     target.classList.contains('galaxy-discovery-modal')) &&
                    (target.style.display === 'flex' || target.classList.contains('active'))) {

                    const modalId = target.id;
                    const closeFunction = MODAL_CLOSE_MAP[modalId];
                    if (closeFunction) {
                        closeFunction();
                        e.stopPropagation();
                    }
                }
            });
        })();

        // v6.89: Universal Draggable Panel System - Drag UI boxes off-screen to maximize game area
        const DraggablePanelSystem = (function() {
            const STORAGE_KEY = 'levi_panel_positions';
            const HIDDEN_KEY = 'levi_hidden_panels';
            const MINIMIZED_KEY = 'levi_minimized_panels';
            const MOBILE_DEFAULTS_APPLIED_KEY = 'levi_mobile_defaults_applied';
            const EDGE_THRESHOLD = 50; // Pixels from edge to trigger hide

            // Mobile detection helper
            const isMobileDevice = () => {
                return /iphone|ipad|ipod|android/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints > 0 && window.innerWidth < 1024);
            };

            // Panels that can be dragged
            const DRAGGABLE_PANELS = [
                { id: 'ship-status', icon: '', name: 'Ship' },
                { id: 'ai-behavior-panel', icon: '', name: 'AI' },
                { id: 'daily-challenge', icon: '', name: 'Challenge' },
                { id: 'style-meter', icon: '', name: 'Style' },
                { id: 'minimap-container', icon: '', name: 'Map' },
                { id: 'environment-widget', icon: '', name: 'Weather' },
                { id: 'companion-health-container', icon: '', name: 'Pet' },
                { id: 'player-dota-bars-ui', icon: '', name: 'HP/MP' }
            ];

            let positions = {};
            let hiddenPanels = {};
            let minimizedPanels = {};
            let restoreTabs = [];
            let resetBtn = null;
            let dragState = null;

            function loadPositions() {
                try {
                    positions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                    hiddenPanels = JSON.parse(localStorage.getItem(HIDDEN_KEY) || '{}');
                    minimizedPanels = JSON.parse(localStorage.getItem(MINIMIZED_KEY) || '{}');

                    // v6.90: Auto-collapse all panels on mobile by default
                    // Only apply once - respects user's subsequent changes
                    const mobileDefaultsApplied = localStorage.getItem(MOBILE_DEFAULTS_APPLIED_KEY);
                    if (isMobileDevice() && !mobileDefaultsApplied) {
                        // Minimize all panels by default on mobile
                        DRAGGABLE_PANELS.forEach(panel => {
                            minimizedPanels[panel.id] = true;
                        });
                        localStorage.setItem(MINIMIZED_KEY, JSON.stringify(minimizedPanels));
                        localStorage.setItem(MOBILE_DEFAULTS_APPLIED_KEY, 'true');
                    }
                } catch(e) {
                    positions = {};
                    hiddenPanels = {};
                    minimizedPanels = {};
                }
            }

            function savePositions() {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
                localStorage.setItem(HIDDEN_KEY, JSON.stringify(hiddenPanels));
                localStorage.setItem(MINIMIZED_KEY, JSON.stringify(minimizedPanels));
            }

            function initPanel(panelConfig) {
                const panel = document.getElementById(panelConfig.id);
                if (!panel) return;

                // Add draggable class
                panel.classList.add('draggable-panel');

                // Create drag handle if panel has content
                if (!panel.querySelector('.drag-handle')) {
                    const handle = document.createElement('div');
                    handle.className = 'drag-handle';
                    handle.setAttribute('data-panel-name', panelConfig.name);

                    // Add drag grip
                    const grip = document.createElement('span');
                    grip.className = 'drag-grip';
                    handle.appendChild(grip);

                    // Add panel title
                    const title = document.createElement('span');
                    title.className = 'panel-title';
                    title.textContent = panelConfig.name;
                    handle.appendChild(title);

                    panel.insertBefore(handle, panel.firstChild);

                    // Add minimize button OUTSIDE the drag handle, directly on panel
                    const minBtn = document.createElement('button');
                    minBtn.className = 'minimize-btn';
                    minBtn.innerHTML = '';
                    minBtn.title = 'Minimize/Maximize';
                    minBtn.setAttribute('type', 'button');
                    panel.appendChild(minBtn);

                    // Use a simple onclick - most reliable
                    minBtn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleMinimize(panelConfig);
                        return false;
                    };

                    // Also handle touch
                    minBtn.ontouchend = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleMinimize(panelConfig);
                        return false;
                    };

                    // Adjust panel padding for handle
                    const currentPadding = parseInt(getComputedStyle(panel).paddingTop) || 0;
                    panel.style.paddingTop = Math.max(currentPadding, 28) + 'px';
                }

                // Restore saved position
                if (positions[panelConfig.id]) {
                    const pos = positions[panelConfig.id];
                    panel.style.position = 'fixed';
                    panel.style.left = pos.left + 'px';
                    panel.style.top = pos.top + 'px';
                    panel.style.right = 'auto';
                    panel.style.bottom = 'auto';
                    panel.style.transform = 'none';
                }

                // Restore minimized state
                if (minimizedPanels[panelConfig.id]) {
                    panel.classList.add('minimized');
                    const minBtn = panel.querySelector('.minimize-btn');
                    if (minBtn) minBtn.innerHTML = '+';
                }

                // Check if panel was hidden
                if (hiddenPanels[panelConfig.id]) {
                    hidePanel(panelConfig);
                }

                // Add touch/mouse events
                const handle = panel.querySelector('.drag-handle') || panel;

                handle.addEventListener('mousedown', (e) => startDrag(e, panel, panelConfig));
                handle.addEventListener('touchstart', (e) => startDrag(e, panel, panelConfig), { passive: false });

                // Double-click to reset position
                handle.addEventListener('dblclick', (e) => {
                    if (!e.target.classList.contains('minimize-btn')) {
                        resetPanelPosition(panelConfig);
                    }
                });
            }

            function toggleMinimize(config) {
                const panel = document.getElementById(config.id);
                if (!panel) return;

                const isMinimized = panel.classList.toggle('minimized');
                const minBtn = panel.querySelector('.minimize-btn');

                if (minBtn) {
                    minBtn.innerHTML = isMinimized ? '+' : '';
                }

                if (isMinimized) {
                    minimizedPanels[config.id] = true;
                } else {
                    delete minimizedPanels[config.id];
                }

                savePositions();
                updateResetButton();
            }

            function startDrag(e, panel, config) {
                // Don't start drag if clicking on button or minimize-btn
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
                    e.target.classList.contains('minimize-btn') ||
                    e.target.closest('.minimize-btn')) return;

                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                const rect = panel.getBoundingClientRect();

                dragState = {
                    panel,
                    config,
                    startX: touch.clientX,
                    startY: touch.clientY,
                    offsetX: touch.clientX - rect.left,
                    offsetY: touch.clientY - rect.top,
                    originalLeft: rect.left,
                    originalTop: rect.top
                };

                panel.classList.add('dragging');

                // Convert to absolute positioning
                panel.style.position = 'fixed';
                panel.style.left = rect.left + 'px';
                panel.style.top = rect.top + 'px';
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
                panel.style.transform = 'none';

                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', onDrag, { passive: false });
                document.addEventListener('touchend', endDrag);
            }

            function onDrag(e) {
                if (!dragState) return;
                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                const newLeft = touch.clientX - dragState.offsetX;
                const newTop = touch.clientY - dragState.offsetY;

                dragState.panel.style.left = newLeft + 'px';
                dragState.panel.style.top = newTop + 'px';

                // Check if near edge
                const nearEdge = newLeft < EDGE_THRESHOLD ||
                                 newLeft + dragState.panel.offsetWidth > window.innerWidth - EDGE_THRESHOLD ||
                                 newTop < EDGE_THRESHOLD ||
                                 newTop + dragState.panel.offsetHeight > window.innerHeight - EDGE_THRESHOLD;

                dragState.panel.classList.toggle('near-edge', nearEdge);
            }

            function endDrag(e) {
                if (!dragState) return;

                const panel = dragState.panel;
                const config = dragState.config;

                panel.classList.remove('dragging', 'near-edge');

                const rect = panel.getBoundingClientRect();
                const left = rect.left;
                const top = rect.top;

                // Check if should hide (dragged mostly off-screen)
                const visibleWidth = Math.min(rect.right, window.innerWidth) - Math.max(rect.left, 0);
                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                const visibleArea = visibleWidth * visibleHeight;
                const totalArea = rect.width * rect.height;

                if (visibleArea < totalArea * 0.3 || left < -rect.width * 0.7 ||
                    left > window.innerWidth - rect.width * 0.3 ||
                    top < -rect.height * 0.7 || top > window.innerHeight - rect.height * 0.3) {
                    hidePanel(config);
                } else {
                    // Save position
                    positions[config.id] = { left, top };
                    savePositions();
                }

                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('touchend', endDrag);

                dragState = null;
                updateResetButton();
            }

            function hidePanel(config) {
                const panel = document.getElementById(config.id);
                if (!panel) return;

                panel.style.display = 'none';
                hiddenPanels[config.id] = true;
                savePositions();

                // Create restore tab on edge
                createRestoreTab(config);
                updateResetButton();
            }

            function createRestoreTab(config) {
                // Remove existing tab
                const existingTab = document.querySelector(`.panel-restore-tab[data-panel="${config.id}"]`);
                if (existingTab) existingTab.remove();

                const tab = document.createElement('div');
                tab.className = 'panel-restore-tab';
                tab.setAttribute('data-panel', config.id);
                tab.innerHTML = config.icon;
                tab.title = `Restore ${config.name}`;

                // Position on right edge with stacking
                const existingTabs = document.querySelectorAll('.panel-restore-tab');
                const offset = existingTabs.length * 50;
                tab.style.right = '5px';
                tab.style.top = (100 + offset) + 'px';

                tab.addEventListener('click', () => restorePanel(config));
                document.body.appendChild(tab);
                restoreTabs.push(tab);
            }

            function restorePanel(config) {
                const panel = document.getElementById(config.id);
                if (!panel) return;

                // Reset position to center
                panel.style.left = (window.innerWidth / 2 - 100) + 'px';
                panel.style.top = (window.innerHeight / 2 - 50) + 'px';
                panel.style.display = '';

                delete hiddenPanels[config.id];
                delete positions[config.id];
                savePositions();

                // Remove restore tab
                const tab = document.querySelector(`.panel-restore-tab[data-panel="${config.id}"]`);
                if (tab) tab.remove();

                repositionRestoreTabs();
                updateResetButton();
            }

            function repositionRestoreTabs() {
                const tabs = document.querySelectorAll('.panel-restore-tab');
                tabs.forEach((tab, i) => {
                    tab.style.top = (100 + i * 50) + 'px';
                });
            }

            function resetPanelPosition(config) {
                const panel = document.getElementById(config.id);
                if (!panel) return;

                // Clear saved position and states
                delete positions[config.id];
                delete hiddenPanels[config.id];
                delete minimizedPanels[config.id];
                savePositions();

                // Remove minimized state
                panel.classList.remove('minimized');
                const minBtn = panel.querySelector('.minimize-btn');
                if (minBtn) minBtn.innerHTML = '';

                // Remove inline positioning to use CSS defaults
                panel.style.left = '';
                panel.style.top = '';
                panel.style.right = '';
                panel.style.bottom = '';
                panel.style.transform = '';
                panel.style.display = '';

                // Remove restore tab if exists
                const tab = document.querySelector(`.panel-restore-tab[data-panel="${config.id}"]`);
                if (tab) tab.remove();

                repositionRestoreTabs();
                updateResetButton();
            }

            function resetAllPanels() {
                positions = {};
                minimizedPanels = {};
                hiddenPanels = {};

                // Clear mobile defaults flag so it can re-apply
                localStorage.removeItem(MOBILE_DEFAULTS_APPLIED_KEY);

                // Clear all restore tabs
                document.querySelectorAll('.panel-restore-tab').forEach(t => t.remove());

                // Reset all panels
                DRAGGABLE_PANELS.forEach(config => {
                    const panel = document.getElementById(config.id);
                    if (panel) {
                        panel.style.left = '';
                        panel.style.top = '';
                        panel.style.right = '';
                        panel.style.bottom = '';
                        panel.style.transform = '';
                        panel.style.display = '';

                        // Reset minimized state - but on mobile, collapse by default
                        if (isMobileDevice()) {
                            panel.classList.add('minimized');
                            const minBtn = panel.querySelector('.minimize-btn');
                            if (minBtn) minBtn.innerHTML = '+';
                            minimizedPanels[config.id] = true;
                        } else {
                            panel.classList.remove('minimized');
                            const minBtn = panel.querySelector('.minimize-btn');
                            if (minBtn) minBtn.innerHTML = '';
                        }
                    }
                });

                // Save the state (on mobile this saves collapsed state, on desktop it's empty)
                if (isMobileDevice()) {
                    localStorage.setItem(MOBILE_DEFAULTS_APPLIED_KEY, 'true');
                }
                savePositions();
                updateResetButton();
            }

            function updateResetButton() {
                if (!resetBtn) return;

                const hasCustomState = Object.keys(positions).length > 0 ||
                                       Object.keys(hiddenPanels).length > 0 ||
                                       Object.keys(minimizedPanels).length > 0;
                resetBtn.classList.toggle('visible', hasCustomState);
            }

            function init() {
                loadPositions();

                // Create reset button
                resetBtn = document.createElement('button');
                resetBtn.className = 'reset-panels-btn';
                resetBtn.textContent = ' Reset Panels';
                resetBtn.addEventListener('click', resetAllPanels);
                document.body.appendChild(resetBtn);

                // Initialize each panel (with delay to ensure panels exist)
                setTimeout(() => {
                    DRAGGABLE_PANELS.forEach(initPanel);
                    updateResetButton();
                }, 1000);

                // Re-check after world loads
                setTimeout(() => {
                    DRAGGABLE_PANELS.forEach(config => {
                        const panel = document.getElementById(config.id);
                        if (panel && !panel.classList.contains('draggable-panel')) {
                            initPanel(config);
                        }
                        // Restore hidden panels
                        if (hiddenPanels[config.id]) {
                            hidePanel(config);
                        }
                    });
                }, 3000);
            }

            // Public API
            return {
                init,
                resetAllPanels,
                restorePanel,
                hidePanel,
                toggleMinimize,
                PANELS: DRAGGABLE_PANELS
            };
        })();

        // Initialize when DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', DraggablePanelSystem.init);
        } else {
            DraggablePanelSystem.init();
        }

        // v6.8: Global Escape key handler to close modals (Agent consensus - UI/UX)
        // v7.0: Enhanced escape handler - closes any open panel/modal
        function handleGlobalEscape(e) {
            if (e.key !== 'Escape') return;

            // Check modals in priority order (topmost first)
            const modals = [
                { id: 'ai-settings-modal', close: closeAISettingsModal },
                { id: 'settings-modal', close: closeSettingsModal },
                { id: 'tutorial-modal', close: closeTutorial },
                { id: 'galaxy-manager', close: () => document.getElementById('galaxy-manager').style.display = 'none' },
                { id: 'planet-surface-modal', close: () => document.getElementById('planet-surface-modal').style.display = 'none' },
                { id: 'show-mode-modal', close: () => document.getElementById('show-mode-modal').style.display = 'none' }
            ];

            for (const modal of modals) {
                const el = document.getElementById(modal.id);
                if (el && el.style.display !== 'none' && el.style.display !== '') {
                    modal.close();
                    e.preventDefault();
                    return;
                }
            }

            // Also close death screen if visible
            const deathScreen = document.getElementById('death-screen');
            if (deathScreen && deathScreen.style.display !== 'none') {
                respawnPlayer();
                e.preventDefault();
                return;
            }

            // v7.0: Close any open RTS panels
            const rtsPanels = ['skills', 'crafting', 'inventory', 'equipment'];
            for (const panel of rtsPanels) {
                const panelEl = document.getElementById(`${panel}-panel`);
                if (panelEl && panelEl.classList.contains('visible')) {
                    toggleRTSPanel(panel);
                    e.preventDefault();
                    return;
                }
            }

            // v7.0: Exit cinematic mode if active
            if (typeof CinematicMode !== 'undefined' && CinematicMode.active) {
                CinematicMode.exit();
                e.preventDefault();
                return;
            }
        }

        function updateToggleBtn(id, isOn) {
            const btn = document.getElementById(id);
            if (isOn) {
                btn.textContent = 'ON';
                btn.classList.remove('off');
            } else {
                btn.textContent = 'OFF';
                btn.classList.add('off');
            }
        }

        function setMasterVolume(val) {
            gameData.settings = gameData.settings || {};
            gameData.settings.masterVolume = parseInt(val);
            AudioSystem.masterVolume = val / 100;
            document.getElementById('volume-display').textContent = val + '%';
        }

        function toggleSFX() {
            gameData.settings = gameData.settings || {};
            gameData.settings.sfxEnabled = !gameData.settings.sfxEnabled;
            AudioSystem.enabled = gameData.settings.sfxEnabled;
            updateToggleBtn('sfx-toggle', gameData.settings.sfxEnabled);
        }

        function toggleAmbient() {
            gameData.settings = gameData.settings || {};
            gameData.settings.ambientEnabled = !gameData.settings.ambientEnabled;
            if (gameData.settings.ambientEnabled) {
                if (mode === 'world' && activeCiv) AudioSystem.startAmbient(activeCiv.biome);
            } else {
                AudioSystem.stopAmbient();
            }
            updateToggleBtn('ambient-toggle', gameData.settings.ambientEnabled);
        }

        function setParticleQuality(quality) {
            gameData.settings = gameData.settings || {};
            gameData.settings.particleQuality = quality;
            // Adjust particle limits
            if (particles) {
                particles.maxParticles = quality === 'high' ? 100 : quality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = quality === 'high' ? 60 : quality === 'medium' ? 30 : 15;
            }
        }

        function toggleShadows() {
            gameData.settings = gameData.settings || {};
            gameData.settings.shadowsEnabled = !gameData.settings.shadowsEnabled;
            renderer.shadowMap.enabled = gameData.settings.shadowsEnabled;
            updateToggleBtn('shadow-toggle', gameData.settings.shadowsEnabled);
        }

        function toggleScreenShake() {
            gameData.settings = gameData.settings || {};
            gameData.settings.screenShakeEnabled = !gameData.settings.screenShakeEnabled;
            updateToggleBtn('shake-toggle', gameData.settings.screenShakeEnabled);
        }

        function toggleHints() {
            gameData.settings = gameData.settings || {};
            gameData.settings.hintsEnabled = !gameData.settings.hintsEnabled;
            updateToggleBtn('hints-toggle', gameData.settings.hintsEnabled);
        }

        // v6.7: Auto-use potions toggle (Agent consensus - QoL)
        function toggleAutoPotion() {
            gameData.settings = gameData.settings || {};
            gameData.settings.autoPotionEnabled = !gameData.settings.autoPotionEnabled;
            updateToggleBtn('autopotion-toggle', gameData.settings.autoPotionEnabled);
        }

        // v6.7: Check and use potions automatically when HP is low
        let lastAutoPotionTime = 0;
        function checkAutoPotion() {
            if (!gameData.settings?.autoPotionEnabled) return;
            if (performance.now() - lastAutoPotionTime < 2000) return; // 2 second cooldown

            const hpPercent = gameData.player.hp / gameData.player.maxHp;
            if (hpPercent < 0.3) {
                // Try to use potions in order of effectiveness
                const potionPriority = ['Super Potion', 'Health Potion', 'Potion'];
                for (const potionName of potionPriority) {
                    if (hasItem(potionName)) {
                        removeItem(potionName, 1);
                        const healAmount = potionName === 'Super Potion' ? 100 :
                                          potionName === 'Health Potion' ? 50 : 30;
                        healPlayer(healAmount);
                        showNotification(`Auto-used ${potionName}!`, 'success');
                        lastAutoPotionTime = performance.now();
                        return;
                    }
                }
            }
        }

        // v4.6: Apply settings on load
        function applySettings() {
            const s = gameData.settings || {};
            AudioSystem.masterVolume = (s.masterVolume || 30) / 100;
            AudioSystem.enabled = s.sfxEnabled !== false;
            if (particles) {
                particles.maxParticles = s.particleQuality === 'high' ? 100 : s.particleQuality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = s.particleQuality === 'high' ? 60 : s.particleQuality === 'medium' ? 30 : 15;
            }
            // v6.7: Apply auto-potion setting on load
            updateToggleBtn('autopotion-toggle', s.autoPotionEnabled || false);
        }

        function closeModal() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        // v4.3: Notification queue to prevent stacking
        const notificationQueue = [];
        let notificationActive = false;
        const MAX_VISIBLE_NOTIFICATIONS = 3;
        let visibleNotifications = [];

        // ============================================
        // v6.80: ENHANCED VISUAL FEEDBACK SYSTEMS
        // 8-Agent Consensus Improvements
        // ============================================

        // Momentum tracking for flow state
        let momentumState = {
            value: 0,
            lastHitTime: 0,
            combo: 0,
            decayRate: 2, // per second
            maxValue: 100
        };

        // v6.80: Critical HP overlay effect
        // v6.84: Use cached DOM reference for frequent overlay updates
        function updateCriticalHPOverlay() {
            const cache = getUICache();
            const overlay = cache.criticalHpOverlay;
            if (!overlay || !gameData?.player) return;

            const hpPercent = (gameData.player.hp / gameData.player.maxHp) * 100;
            if (hpPercent <= 15) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        // v6.80: Impact border pulse for damage feedback
        function showImpactBorder(type = 'damage-taken') {
            const border = document.getElementById('impact-border');
            if (!border) return;

            // Remove all classes first
            border.className = '';

            // Force reflow to restart animation
            void border.offsetWidth;

            // Add the appropriate class
            border.classList.add(type);

            // Auto-remove after animation
            setTimeout(() => {
                border.className = '';
            }, 500);
        }

        // v6.80: Ability activation flash
        function showAbilityFlash(element = '') {
            const flash = document.getElementById('ability-flash');
            if (!flash) return;

            flash.className = element || '';
            void flash.offsetWidth;
            flash.classList.add('active');

            setTimeout(() => {
                flash.className = '';
            }, 350);
        }

        // v6.80: Boss introduction cinematic
        function showBossIntro(bossName, bossTitle = 'LEGENDARY CREATURE') {
            const overlay = document.getElementById('boss-intro-overlay');
            const nameEl = document.getElementById('boss-intro-name');
            const titleEl = document.getElementById('boss-intro-title');

            if (!overlay || !nameEl || !titleEl) return;

            nameEl.textContent = bossName;
            titleEl.textContent = bossTitle;

            // Reset animations
            nameEl.style.animation = 'none';
            titleEl.style.animation = 'none';
            void nameEl.offsetWidth;
            nameEl.style.animation = '';
            titleEl.style.animation = '';

            overlay.classList.add('active');

            // Auto-dismiss after 2.5 seconds
            setTimeout(() => {
                overlay.classList.remove('active');
            }, 2500);
        }

        // v6.80: Momentum meter update
        function updateMomentum(delta = 0) {
            const now = Date.now();
            const meter = document.getElementById('momentum-meter');
            const fill = document.getElementById('momentum-fill');

            if (!meter || !fill) return;

            // Decay momentum over time
            const timeSinceLastHit = (now - momentumState.lastHitTime) / 1000;
            if (timeSinceLastHit > 1) {
                momentumState.value = Math.max(0, momentumState.value - momentumState.decayRate * (timeSinceLastHit - 1));
            }

            // Add new momentum
            if (delta > 0) {
                momentumState.value = Math.min(momentumState.maxValue, momentumState.value + delta);
                momentumState.lastHitTime = now;
                momentumState.combo++;
                meter.classList.add('active');
            }

            // Update visual
            fill.style.height = momentumState.value + '%';

            // Fire state when maxed
            if (momentumState.value >= 80) {
                meter.classList.add('on-fire');
            } else {
                meter.classList.remove('on-fire');
            }

            // Hide meter when empty
            if (momentumState.value <= 0) {
                meter.classList.remove('active');
                momentumState.combo = 0;
            }
        }

        // v6.80: Victory confetti burst
        function spawnVictoryConfetti(count = 100) {
            const container = document.getElementById('confetti-container');
            if (!container) return;

            const colors = ['#ff0', '#f0f', '#0ff', '#0f0', '#f00', '#00f', '#fff', '#ffa500'];
            const shapes = ['square', 'circle', 'triangle'];

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'confetti-particle';

                const color = colors[Math.floor(Math.random() * colors.length)];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                const size = 5 + Math.random() * 10;
                const startX = Math.random() * window.innerWidth;
                const startY = -20;
                const velocityX = (Math.random() - 0.5) * 10;
                const velocityY = Math.random() * 3 + 2;
                const rotation = Math.random() * 360;
                const rotationSpeed = (Math.random() - 0.5) * 20;

                particle.style.left = startX + 'px';
                particle.style.top = startY + 'px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.background = color;

                if (shape === 'circle') {
                    particle.style.borderRadius = '50%';
                } else if (shape === 'triangle') {
                    particle.style.width = '0';
                    particle.style.height = '0';
                    particle.style.background = 'transparent';
                    particle.style.borderLeft = size/2 + 'px solid transparent';
                    particle.style.borderRight = size/2 + 'px solid transparent';
                    particle.style.borderBottom = size + 'px solid ' + color;
                }

                container.appendChild(particle);

                // Animate with physics
                let x = startX, y = startY, vy = velocityY, vx = velocityX, rot = rotation;
                const gravity = 0.15;
                const friction = 0.99;

                function animateParticle() {
                    vy += gravity;
                    vx *= friction;
                    x += vx;
                    y += vy;
                    rot += rotationSpeed;

                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.transform = `rotate(${rot}deg)`;
                    particle.style.opacity = Math.max(0, 1 - (y / (window.innerHeight * 1.2)));

                    if (y < window.innerHeight + 50) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        particle.remove();
                    }
                }

                setTimeout(() => animateParticle(), i * 10);
            }
        }

        // v6.80: Hook momentum decay into game loop
        setInterval(() => {
            if (momentumState.value > 0) {
                updateMomentum(0);
            }
        }, 100);

        function showNotification(message, type = 'success') {
            // Add to queue
            notificationQueue.push({ message, type });
            processNotificationQueue();
        }

        function processNotificationQueue() {
            // Remove expired notifications
            visibleNotifications = visibleNotifications.filter(n => n.element.parentNode);

            // Process queue while under limit
            while (notificationQueue.length > 0 && visibleNotifications.length < MAX_VISIBLE_NOTIFICATIONS) {
                const { message, type } = notificationQueue.shift();
                displayNotification(message, type);
            }
        }

        function displayNotification(message, type) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notif.setAttribute('role', 'status'); // v6.6: Accessibility role

            // v6.6: Announce to screen readers via ARIA live region (Agent 6 accessibility)
            const srAnnounce = document.getElementById('sr-announcements');
            if (srAnnounce) {
                srAnnounce.textContent = message;
                // Clear after announcement to allow repeat announcements
                setTimeout(() => { srAnnounce.textContent = ''; }, 1000);
            }

            // Position based on how many are currently visible
            const offset = visibleNotifications.length * 50;
            notif.style.top = (100 + offset) + 'px';

            if (type === 'error') {
                notif.style.background = 'rgba(100, 0, 0, 0.9)';
                notif.style.borderColor = '#f00';
                notif.style.color = '#f00';
            } else if (type === 'warning') {
                notif.style.background = 'rgba(100, 80, 0, 0.9)';
                notif.style.borderColor = '#fa0';
                notif.style.color = '#fa0';
            }

            document.body.appendChild(notif);
            const notifObj = { element: notif, expires: Date.now() + 2500 };
            visibleNotifications.push(notifObj);

            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    notif.remove();
                    processNotificationQueue();
                }, 300);
            }, 2500);
        }

        // --- INITIALIZATION ---
        // v6.43: Loading phase tracker for visual feedback
        function updateLoadingPhase(phase, text) {
            const phaseEl = document.getElementById('loading-phase');
            if (phaseEl) phaseEl.textContent = text;
            for (let i = 1; i <= 4; i++) {
                const el = document.getElementById('phase-' + i);
                if (el) el.style.color = i <= phase ? '#0f0' : '#333';
            }
        }

        function init() {
            updateLoadingPhase(1, 'LOADING SAVE DATA...');
            loadGameData();

            // v6.93: Initialize Time Rewind system
            TimeRewind.init();

            // v6.17: Check for extended absence - The Last Transmission
            const absenceData = LAST_TRANSMISSION.checkAbsence();
            if (absenceData) {
                // Show the emotional reunion sequence
                setTimeout(() => LAST_TRANSMISSION.showReunionSequence(absenceData), 500);
            }

            // v5.7: Load RAPPID settings for AI-powered Copilot
            loadRappidSettings();

            // v6.65: Initialize companion permadeath system
            initializeCompanion();

            // v5.3: Initialize portal system
            initPortalSystem();

            // v6.68: Initialize living economy system
            initEconomy();

            // v6.83: Update galaxy button counts on load
            const galaxyCount = (gameData.galaxyHistory?.length || 0) + 1;
            if (typeof updateGalaxyButtonCounts === 'function') {
                updateGalaxyButtonCounts(galaxyCount);
            }

            // v4.7: Check for welcome back rewards (skip if Last Transmission is showing)
            const sessionReward = !absenceData ? checkSessionRewards() : null;
            if (sessionReward) {
                // Delay modal to let game initialize
                setTimeout(() => showWelcomeBackModal(sessionReward), 1500);
            }

            // v4.0: Initialize audio and particle systems
            updateLoadingPhase(1, 'INITIALIZING AUDIO SYSTEM...');
            AudioSystem.init();
            particles = new ParticleSystem();
            envParticles = new EnvironmentParticles(); // v4.4

            // v6.35: Resume AudioContext on first user interaction (browser requirement)
            const resumeAudioOnInteraction = () => {
                if (AudioSystem.ctx && AudioSystem.ctx.state === 'suspended') {
                    AudioSystem.ctx.resume().then(() => {
                        console.log('AudioContext resumed after user interaction');
                    });
                }
                // Remove listeners after first interaction
                document.removeEventListener('click', resumeAudioOnInteraction);
                document.removeEventListener('keydown', resumeAudioOnInteraction);
                document.removeEventListener('touchstart', resumeAudioOnInteraction);
            };
            document.addEventListener('click', resumeAudioOnInteraction);
            document.addEventListener('keydown', resumeAudioOnInteraction);
            document.addEventListener('touchstart', resumeAudioOnInteraction);

            // v6.19: Load 3D text font early for title display
            loadCopilotTextFont();

            // v4.6: Apply saved settings
            applySettings();

            updateLoadingPhase(2, 'INITIALIZING 3D RENDERER...');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);

            // v6.87: iOS Mobile Renderer Optimization (from 8-strategy consensus analysis)
            const isMobileDevice = /iphone|ipad|ipod|android/i.test(navigator.userAgent) ||
                                   (navigator.maxTouchPoints > 0 && window.innerWidth < 1024);
            const mobilePixelRatio = isMobileDevice ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2);
            const useAntialias = !isMobileDevice;
            const powerPref = isMobileDevice ? 'low-power' : 'high-performance';

            renderer = new THREE.WebGLRenderer({ antialias: useAntialias, powerPreference: powerPref });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(mobilePixelRatio);
            renderer.shadowMap.enabled = !isMobileDevice; // Disable shadows on mobile for performance
            renderer.shadowMap.type = isMobileDevice ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;

            // Apply mobile-specific quality settings
            if (isMobileDevice) {
                gameData.settings = gameData.settings || {};
                gameData.settings.particleQuality = gameData.settings.particleQuality || 'low';
                console.log(' Mobile optimizations applied: reduced pixel ratio, disabled antialias, basic shadows');
            }
            // v6.8: Tone mapping for richer visuals (Agent consensus - Visual Polish)
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize floater pool
            for (let i = 0; i < MAX_FLOATERS; i++) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.display = 'none';
                document.body.appendChild(el);
                floaterPool.push({ el, active: false });
            }

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            // v6.87: iOS viewport height fix and orientation change handler
            function setAppHeight() {
                document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);
            }
            setAppHeight();
            window.addEventListener('resize', setAppHeight);
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    setAppHeight();
                    onResize();
                }, 100); // iOS needs delay to report correct dimensions
            });

            // Use visualViewport API for iOS Safari address bar changes
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    setAppHeight();
                });
            }

            // Touch events
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'flex';
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.getElementById('touch-action').addEventListener('touchstart', onTouchAction);

                // v4.3: Virtual Joystick setup
                const joystick = document.getElementById('virtual-joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                const actionBtn = document.getElementById('touch-action-btn');

                joystick.style.display = 'block';
                actionBtn.style.display = 'flex';

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    joystickActive = true;
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (joystickActive) {
                        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickInput = { x: 0, y: 0 };
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });

                actionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world' && worldState.interactTarget) {
                        performAction(worldState.interactTarget);
                    }
                }, { passive: false });

                // v4.5: Dodge button setup
                const dodgeBtn = document.getElementById('touch-dodge-btn');
                dodgeBtn.style.display = 'flex';
                dodgeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world') {
                        startDodge();
                    }
                }, { passive: false });

                // v6.87: Touch Ability Bar setup (8-strategy consensus)
                const touchAbilityBar = document.getElementById('touch-ability-bar');
                if (touchAbilityBar) {
                    const touchAbilityBtns = touchAbilityBar.querySelectorAll('.touch-ability-btn');
                    touchAbilityBtns.forEach(btn => {
                        const abilityId = btn.dataset.ability;
                        if (!abilityId) return;

                        btn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (typeof useAbility === 'function') {
                                useAbility(abilityId);
                            }
                        }, { passive: false });
                    });
                }

                function updateJoystick(touchX, touchY) {
                    let dx = touchX - joystickCenter.x;
                    let dy = touchY - joystickCenter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > joystickMaxDist) {
                        dx = (dx / dist) * joystickMaxDist;
                        dy = (dy / dist) * joystickMaxDist;
                    }

                    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    joystickInput = { x: dx / joystickMaxDist, y: dy / joystickMaxDist };
                }
            }

            // Keyboard events (including WASD)
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            // v5.11: RTS Panel hotkeys
            window.addEventListener('keydown', handleRTSPanelHotkeys);

            // v6.8: Global Escape key to close modals (Agent consensus - UI/UX)
            window.addEventListener('keydown', handleGlobalEscape);

            // MULTIPLAYER: Check if joining with planet param - skip galaxy and go direct to planet
            const urlParams = new URLSearchParams(window.location.search);
            const joinPlanetId = urlParams.get('planet');
            const joinSeed = urlParams.get('seed');
            const isJoining = urlParams.get('join');

            if (isJoining && joinPlanetId !== null && joinPlanetId !== '') {
                // Direct planet landing - skip galaxy entirely
                console.log('Multiplayer join detected - skipping galaxy for direct planet landing');
                // Seed and planet init will happen in checkMultiplayerMode()
                // Just show a loading state instead of galaxy
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('loading').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div style="font-size: 24px; color: #0ff;">Joining Multiplayer World...</div>
                        <div style="font-size: 14px; color: #888; margin-top: 10px;">Synchronizing terrain with host</div>
                    </div>
                `;
            } else {
                updateLoadingPhase(3, 'GENERATING GALAXY...');
                initGalaxy();
            }

            updateLoadingPhase(4, 'FINALIZING SYSTEMS...');
            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();

            // v4.1: Initialize daily challenge system
            generateDailyChallenge();
            updateDailyChallengeUI();

            // Hide loading screen (unless multiplayer joiner waiting for host)
            const urlParams2 = new URLSearchParams(window.location.search);
            const isMultiplayerJoin = urlParams2.get('join') && urlParams2.get('planet');
            if (!isMultiplayerJoin) {
                document.getElementById('loading').style.display = 'none';
            }
            // For multiplayer joiners, loading screen will be hidden when applyFullState() completes

            // v4.0: Show tutorial for first-time players
            if (!gameData.hasSeenTutorial) {
                setTimeout(showTutorial, 500);
            }

            // v4.1: Check achievements on load
            checkAchievements();

            // v6.29: Initialize physics tutorial panel
            initPhysicsTutorial();

            // v6.36: Initialize Round 3 consensus systems
            personalRecords.init();
            dailyChallenges.init();

            // Autosave
            setInterval(() => {
                if (mode === 'world') {
                    saveGameData();
                    checkAchievements();
                    updateDailyChallengeProgress();
                    // v5.3: Check portal timeout
                    checkPortalTimeout();
                }
                // v6.36: Update session time for personal records (works in all modes)
                if (typeof personalRecords !== 'undefined' && personalRecords.records) {
                    personalRecords.updateSessionTime();
                }
            }, CONFIG.AUTOSAVE_INTERVAL);

            // v6.54: Initialize Steam Deck gamepad support
            SteamDeckManager.init();

            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            mode = 'galaxy';

            // v6.65: Hide companion health in galaxy mode
            const companionHealth = document.getElementById('companion-health-container');
            if (companionHealth) companionHealth.classList.add('hidden');

            // v6.65: Clean up creep lane system when leaving world
            if (typeof cleanupCreepSystem === 'function') {
                cleanupCreepSystem();
            }

            // v6.66: Clean up base building system when leaving world
            if (typeof cleanupBaseBuildingSystem === 'function') {
                cleanupBaseBuildingSystem();
            }

            // v4.3: Stop ambient audio when leaving planet
            AudioSystem.stopAmbient();

            // v4.4: Stop environmental particles
            if (envParticles) envParticles.stop();

            // v6.33: Hide low HP vignette in galaxy mode (not applicable)
            const lowHpVignette = document.getElementById('low-hp-vignette');
            if (lowHpVignette) {
                lowHpVignette.classList.remove('active', 'critical');
            }

            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield (optimized with BufferGeometry)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<8000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                const c = new THREE.Color().setHSL(Math.random() * 0.2 + 0.55, 0.2, 0.8 + Math.random() * 0.2);
                starColors.push(c.r, c.g, c.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 2, vertexColors: true })));

            // v4.1: Nebula clouds for atmosphere
            createNebulae();

            // Civilizations - use multiplayer seed for deterministic generation across clients
            const rng = new SeededRNG(multiplayerState.worldSeed);
            civilizations = [];
            galaxyGroup = new THREE.Group();
            console.log('Generating galaxy with seed:', multiplayerState.worldSeed);

            // v6.29: Use global physics parameters (controlled by tutorial sliders)
            const G_SCALED = physicsParams.G;
            const BLACKHOLE_MASS = physicsParams.M;

            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const initialAngle = rng.next() * Math.PI * 2;
                const orbitalRadius = rng.range(200, 1200);

                // v6.27: Keplerian orbital mechanics
                // Orbital velocity: v = sqrt(GM/r)
                // Angular velocity:  = v/r = sqrt(GM/r)
                const angularVelocity = Math.sqrt(G_SCALED * BLACKHOLE_MASS / Math.pow(orbitalRadius, 3));

                // Orbital inclination (tilt of orbital plane) - small for realistic galaxy
                const orbitalInclination = rng.range(-0.15, 0.15);  // Radians

                // Eccentricity for slightly elliptical orbits (0 = circle, <1 = ellipse)
                const eccentricity = rng.range(0, physicsParams.maxEccentricity);

                // Initial position from orbital parameters
                const x = Math.cos(initialAngle) * orbitalRadius;
                const z = Math.sin(initialAngle) * orbitalRadius;
                const y = Math.sin(orbitalInclination) * orbitalRadius * 0.1;

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));
                // v6.92: Check if planet was previously destroyed or escaped
                const wasDestroyed = gameData.destroyedPlanets?.includes(i) || false;
                const wasEscaped = gameData.escapedPlanets?.includes(i) || false;

                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i),
                    // v6.27: Orbital parameters
                    orbital: {
                        radius: orbitalRadius,
                        angle: initialAngle,
                        angularVelocity: angularVelocity,
                        inclination: orbitalInclination,
                        eccentricity: eccentricity,
                        destroyed: wasDestroyed,  // v6.92: Restore destroyed state
                        escaped: wasEscaped       // v6.92: Restore escaped state
                    }
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);
                // v6.92: Hide destroyed/escaped planets on load
                if (wasDestroyed || wasEscaped) {
                    sysGroup.visible = false;
                }

                // v6.94: Textured planet sphere (visible when zoomed in)
                const planetSeed = rng.int(1000, 99999);
                const planet = new THREE.Mesh(
                    new THREE.SphereGeometry(6, 32, 32),
                    PlanetTextures.createPlanetMaterial(biomeKey, planetSeed)
                );
                planet.name = 'texturedPlanet';
                sysGroup.add(planet);

                // v6.94: Planet atmosphere layer (biome-colored)
                const biome = BIOMES[biomeKey];
                const atmosphere = new THREE.Mesh(
                    new THREE.SphereGeometry(7.5, 32, 32),
                    new THREE.MeshBasicMaterial({ color: biome.sky, transparent: true, opacity: 0.15, side: THREE.BackSide })
                );
                atmosphere.name = 'atmosphere';
                sysGroup.add(atmosphere);

                // Star glow (outer aura) - slightly transparent to let texture show
                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(9, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.4})
                );
                star.name = 'starGlow';
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.15})
                );
                glow.name = 'outerGlow';
                sysGroup.add(glow);

                // Mark visited planets
                if (civ.visited) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(18, 20, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2;
                    sysGroup.add(ring);
                }

                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            // v6.99: Hide navigation buttons (now in RTS panel toggles)
            document.getElementById('nav-galaxy').style.display = 'none';
            document.getElementById('nav-surfaces').style.display = 'none';
            document.querySelector('.rts-divider').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('player-dota-bars-ui').style.display = 'none'; // v6.69: Hide Dota-style HP/Mana bars
            document.getElementById('environment-widget').style.display = 'none'; // v6.70: Hide unified environment widget
            document.getElementById('ship-status').style.display = 'none';  // v5.13: Hide ship UI
            document.getElementById('style-meter').style.display = 'none'; // v6.9: Hide style meter
            document.getElementById('ai-behavior-panel').style.display = 'none'; // v6.81: Hide AI behavior panel
            // v6.92: Show actual active civilizations count (excluding destroyed/escaped)
            const activeCivCount = civilizations.filter(c => !c.orbital?.destroyed && !c.orbital?.escaped).length;
            document.getElementById('civ-count').innerText = activeCivCount;

            updatePlaytimeDisplay();

            // v6.19: Create 3D title text for galaxy view
            create3DTitleText();

            // v6.32: Create gravitational lensing effect around black hole
            if (gravitationalLensingEnabled) {
                createGravitationalLensing();
            }

            // v6.32: Reset collision counter and planet rider on galaxy init
            collisionCount = 0;
            planetRiderEnabled = false;
            riderTargetCiv = null;

            // v6.52: Render Legacy Constellations in galaxy view
            if (typeof legacyConstellations !== 'undefined') {
                legacyConstellations.init();
                legacyConstellations.checkUnlocks();  // Check for any new unlocks
                legacyConstellations.renderToScene(scene);
            }

            // v6.35: Show settings toggle button for galaxy mode
            updateSettingsToggleVisibility();
        }

        // v6.27: ORBITAL MECHANICS - Update all star system positions
        let orbitalPathMesh = null;  // For visualizing selected orbit
        let hoveredCivForOrbit = null;  // Track currently hovered civ to avoid recreating path every frame

        // v6.29: INTERACTIVE PHYSICS VARIABLES - controlled by tutorial sliders
        let physicsParams = {
            G: 50000,           // Gravitational constant
            M: 1000,            // Black hole mass
            timeScale: 0.5,     // Simulation speed
            maxEccentricity: 0.3  // Max eccentricity for orbits
        };

        // v6.29: Physics tutorial panel fade state
        let physicsTutorialTimeout = null;
        let physicsTutorialVisible = false;

        // v6.30: Escape trails for dramatic effect
        let escapeTrails = [];
        const MAX_ESCAPE_TRAILS = 200;

        function updateOrbitalPositions(dt) {
            // v6.29: Use global physicsParams for interactive control
            const timeScale = physicsParams.timeScale;
            const G = physicsParams.G;
            const M = physicsParams.M;

            for (let i = 0; i < civilizations.length; i++) {
                const civ = civilizations[i];
                const orbital = civ.orbital;

                if (!orbital) continue;

                // v6.30: Handle ESCAPED planets - they fly off in straight lines
                if (orbital.escaped) {
                    // Apply velocity (with slight deceleration from distant gravity)
                    const currentR = Math.sqrt(civ.x * civ.x + civ.y * civ.y + civ.z * civ.z);

                    // Very weak gravity at distance (inverse square)
                    const gravAccel = (G * M) / (currentR * currentR + 1000);
                    const dirX = -civ.x / (currentR + 0.001);
                    const dirY = -civ.y / (currentR + 0.001);
                    const dirZ = -civ.z / (currentR + 0.001);

                    // Update velocity with gravity pull
                    orbital.vx += dirX * gravAccel * dt * timeScale * 0.00001;
                    orbital.vy += dirY * gravAccel * dt * timeScale * 0.00001;
                    orbital.vz += dirZ * gravAccel * dt * timeScale * 0.00001;

                    // Move planet
                    civ.x += orbital.vx * dt * timeScale;
                    civ.y += orbital.vy * dt * timeScale;
                    civ.z += orbital.vz * dt * timeScale;

                    // Add trail particle
                    if (escapeTrails.length < MAX_ESCAPE_TRAILS && Math.random() < 0.3) {
                        addEscapeTrail(civ.x, civ.y, civ.z, civ.color);
                    }

                    // Check if planet can be recaptured (slowed down enough)
                    const speed = Math.sqrt(orbital.vx * orbital.vx + orbital.vy * orbital.vy + orbital.vz * orbital.vz);
                    const escapeVel = Math.sqrt(2 * G * M / currentR);

                    if (speed < escapeVel * 0.7 && currentR < 2000) {
                        // Recapture into orbit!
                        orbital.escaped = false;
                        orbital.radius = currentR;
                        orbital.angle = Math.atan2(civ.z, civ.x);
                        orbital.angularVelocity = Math.sqrt(G * M / Math.pow(currentR, 3));
                        console.log(`Planet ${civ.name} recaptured into orbit!`);
                    }

                    // Update 3D position
                    const sysGroup = galaxyGroup.children[i];
                    if (sysGroup) {
                        sysGroup.position.set(civ.x, civ.y, civ.z);
                        // Add spin to escaped planets
                        sysGroup.rotation.y += 0.05 * timeScale;
                    }
                    continue;
                }

                // Normal orbital motion
                // First, calculate current velocity for escape checking
                const e = orbital.eccentricity;
                const a = orbital.radius;
                const theta = orbital.angle;

                // Current distance
                const r = a * (1 - e * e) / (1 + e * Math.cos(theta));

                // Linear velocity magnitude: v = r *  for circular, modified for elliptical
                const linearVel = r * orbital.angularVelocity;

                // Store velocity components (tangent to orbit)
                // Velocity is perpendicular to radius vector
                const tangentAngle = theta + Math.PI / 2;
                orbital.vx = linearVel * Math.cos(tangentAngle);
                orbital.vz = linearVel * Math.sin(tangentAngle) * Math.cos(orbital.inclination);
                orbital.vy = linearVel * Math.sin(tangentAngle) * Math.sin(orbital.inclination);

                // Update orbital angle based on angular velocity
                orbital.angle += orbital.angularVelocity * dt * timeScale;

                // Keep angle in [0, 2]
                if (orbital.angle > Math.PI * 2) orbital.angle -= Math.PI * 2;

                // Calculate new position using orbital elements
                const newTheta = orbital.angle;
                const newR = a * (1 - e * e) / (1 + e * Math.cos(newTheta));

                // Position in orbital plane
                const xOrbit = newR * Math.cos(newTheta);
                const zOrbit = newR * Math.sin(newTheta);

                // Apply orbital inclination
                const inclination = orbital.inclination;
                const x = xOrbit;
                const y = zOrbit * Math.sin(inclination);
                const z = zOrbit * Math.cos(inclination);

                // Update civilization position
                civ.x = x;
                civ.y = y;
                civ.z = z;

                // Update the 3D group position
                const sysGroup = galaxyGroup.children[i];
                if (sysGroup) {
                    sysGroup.position.set(x, y, z);
                    // v6.94: Rotate textured planet for realism
                    const texturedPlanet = sysGroup.getObjectByName('texturedPlanet');
                    if (texturedPlanet) {
                        texturedPlanet.rotation.y += 0.003 * timeScale;
                    }
                }
            }

            // Update escape trails
            updateEscapeTrails(dt);
        }

        // v6.30: Add glowing trail particle for escaped planets
        function addEscapeTrail(x, y, z, color) {
            const geometry = new THREE.SphereGeometry(3, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: color || 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            const trail = new THREE.Mesh(geometry, material);
            trail.position.set(x, y, z);
            trail.userData.life = 1.0;
            trail.userData.decay = 0.02;
            scene.add(trail);
            escapeTrails.push(trail);
        }

        // Update and fade escape trails
        function updateEscapeTrails(dt) {
            for (let i = escapeTrails.length - 1; i >= 0; i--) {
                const trail = escapeTrails[i];
                trail.userData.life -= trail.userData.decay;
                trail.material.opacity = trail.userData.life * 0.8;
                trail.scale.setScalar(trail.userData.life);

                if (trail.userData.life <= 0) {
                    scene.remove(trail);
                    trail.geometry.dispose();
                    trail.material.dispose();
                    escapeTrails.splice(i, 1);
                }
            }
        }

        // v6.27: Create orbital path visualization for selected/hovered star
        function showOrbitalPath(civ) {
            // Remove existing path
            hideOrbitalPath();

            if (!civ || !civ.orbital) return;

            const orbital = civ.orbital;
            const segments = 128;  // Resolution of the ellipse
            const points = [];

            // Generate points along the full orbit
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;

                // Elliptical orbit calculation
                const e = orbital.eccentricity;
                const a = orbital.radius;
                const r = a * (1 - e * e) / (1 + e * Math.cos(theta));

                const xOrbit = r * Math.cos(theta);
                const zOrbit = r * Math.sin(theta);

                // Apply inclination
                const inclination = orbital.inclination;
                const x = xOrbit;
                const y = zOrbit * Math.sin(inclination);
                const z = zOrbit * Math.cos(inclination);

                points.push(new THREE.Vector3(x, y, z));
            }

            // Create the orbital path line
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: civ.color || 0x00ffff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });

            orbitalPathMesh = new THREE.Line(geometry, material);
            orbitalPathMesh.userData.vectors = [];
            scene.add(orbitalPathMesh);

            // v6.31: Add force and velocity vectors for educational visualization
            const r = Math.sqrt(civ.x * civ.x + civ.y * civ.y + civ.z * civ.z);
            if (r > 10 && !orbital.escaped) {
                const G = physicsParams.G;
                const M = physicsParams.M;

                // Gravitational force vector (RED - toward center)
                const forceMag = Math.min((G * M) / (r * r) * 0.3, 150);
                const forceDir = new THREE.Vector3(-civ.x, -civ.y, -civ.z).normalize();
                const forceEnd = new THREE.Vector3(
                    civ.x + forceDir.x * forceMag,
                    civ.y + forceDir.y * forceMag,
                    civ.z + forceDir.z * forceMag
                );

                const forceGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(civ.x, civ.y, civ.z), forceEnd
                ]);
                const forceMat = new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 3 });
                const forceLine = new THREE.Line(forceGeo, forceMat);
                scene.add(forceLine);
                orbitalPathMesh.userData.vectors.push(forceLine);

                // Force arrow head
                const arrowGeo = new THREE.ConeGeometry(8, 20, 8);
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
                const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                arrow.position.copy(forceEnd);
                arrow.lookAt(new THREE.Vector3(0, 0, 0));
                arrow.rotateX(Math.PI / 2);
                scene.add(arrow);
                orbitalPathMesh.userData.vectors.push(arrow);

                // Velocity vector (GREEN - tangent to orbit)
                const vx = orbital.vx || 0;
                const vy = orbital.vy || 0;
                const vz = orbital.vz || 0;
                const velMag = Math.sqrt(vx * vx + vy * vy + vz * vz);

                if (velMag > 0.01) {
                    const velScale = Math.min(velMag * 80, 150);
                    const velDir = new THREE.Vector3(vx, vy, vz).normalize();
                    const velEnd = new THREE.Vector3(
                        civ.x + velDir.x * velScale,
                        civ.y + velDir.y * velScale,
                        civ.z + velDir.z * velScale
                    );

                    const velGeo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(civ.x, civ.y, civ.z), velEnd
                    ]);
                    const velMat = new THREE.LineBasicMaterial({ color: 0x44ff44, linewidth: 3 });
                    const velLine = new THREE.Line(velGeo, velMat);
                    scene.add(velLine);
                    orbitalPathMesh.userData.vectors.push(velLine);

                    // Velocity arrow head
                    const vArrowGeo = new THREE.ConeGeometry(8, 20, 8);
                    const vArrowMat = new THREE.MeshBasicMaterial({ color: 0x44ff44 });
                    const vArrow = new THREE.Mesh(vArrowGeo, vArrowMat);
                    vArrow.position.copy(velEnd);
                    vArrow.lookAt(new THREE.Vector3(civ.x + velDir.x * 200, civ.y + velDir.y * 200, civ.z + velDir.z * 200));
                    vArrow.rotateX(-Math.PI / 2);
                    scene.add(vArrow);
                    orbitalPathMesh.userData.vectors.push(vArrow);
                }
            }
        }

        function hideOrbitalPath() {
            if (orbitalPathMesh) {
                // Clean up force/velocity vectors
                if (orbitalPathMesh.userData.vectors) {
                    for (const obj of orbitalPathMesh.userData.vectors) {
                        scene.remove(obj);
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    }
                }
                scene.remove(orbitalPathMesh);
                orbitalPathMesh.geometry.dispose();
                orbitalPathMesh.material.dispose();
                orbitalPathMesh = null;
            }
        }

        // v6.29: PHYSICS TUTORIAL PANEL FUNCTIONS

        // v6.30: Recalculate orbital velocities AND check for escape velocity!
        // When G or M drops suddenly, planets may exceed escape velocity and fly off
        function recalculateOrbitalVelocities() {
            if (!civilizations || civilizations.length === 0) return;

            const G = physicsParams.G;
            const M = physicsParams.M;
            let escapedCount = 0;

            for (let i = 0; i < civilizations.length; i++) {
                const civ = civilizations[i];
                if (!civ.orbital) continue;

                // Skip already escaped planets
                if (civ.orbital.escaped) continue;

                // Get current position and velocity
                const r = Math.sqrt(civ.x * civ.x + civ.y * civ.y + civ.z * civ.z);
                if (r < 1) continue; // Too close to center

                // Current speed (from stored velocity components)
                const vx = civ.orbital.vx || 0;
                const vy = civ.orbital.vy || 0;
                const vz = civ.orbital.vz || 0;
                const currentSpeed = Math.sqrt(vx * vx + vy * vy + vz * vz);

                // Calculate NEW escape velocity with updated G and M
                // v_escape = (2GM/r)
                const escapeVelocity = Math.sqrt(2 * G * M / r);

                // v6.31: Store velocity ratio for warning indicator
                civ.orbital.velocityRatio = currentSpeed / escapeVelocity;

                // If current speed exceeds escape velocity, LAUNCH INTO SPACE!
                if (currentSpeed > escapeVelocity && currentSpeed > 0.1) {
                    civ.orbital.escaped = true;
                    // Boost velocity slightly for dramatic effect
                    const boost = 1.2;
                    civ.orbital.vx = vx * boost;
                    civ.orbital.vy = vy * boost;
                    civ.orbital.vz = vz * boost;
                    escapedCount++;

                    // v6.92: Persist escaped planet
                    if (gameData.escapedPlanets && !gameData.escapedPlanets.includes(civ.id)) {
                        gameData.escapedPlanets.push(civ.id);
                        saveGameData();
                    }

                    // v6.31: Create shockwave effect!
                    createEscapeShockwave(civ);
                    playEscapeSound();

                    console.log(` ${civ.name} reached escape velocity! (${currentSpeed.toFixed(1)} > ${escapeVelocity.toFixed(1)})`);
                } else {
                    // Update orbital velocity to new equilibrium
                    civ.orbital.angularVelocity = Math.sqrt(G * M / Math.pow(civ.orbital.radius, 3));
                }
            }

            // Dramatic notification if planets escaped
            if (escapedCount > 0) {
                const msg = escapedCount === 1
                    ? ' A planet has escaped the galaxy!'
                    : ` ${escapedCount} planets have escaped the galaxy!`;
                console.log(msg);
            }

            // Update escape counter UI
            updateEscapeCounterUI();
            updateEscapeWarning();
        }

        // v6.31: Shockwave visual effect when planet escapes
        function createEscapeShockwave(civ) {
            const geometry = new THREE.RingGeometry(20, 25, 32);
            const material = new THREE.MeshBasicMaterial({
                color: civ.color || 0xff6600,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(geometry, material);
            shockwave.position.set(civ.x, civ.y, civ.z);
            shockwave.lookAt(camera.position);
            scene.add(shockwave);

            // Animate expansion and fade
            const startTime = Date.now();
            const duration = 600;

            function animateShockwave() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                shockwave.scale.setScalar(1 + progress * 8);
                shockwave.material.opacity = 0.9 * (1 - progress);
                shockwave.lookAt(camera.position);

                if (progress >= 1) {
                    scene.remove(shockwave);
                    shockwave.geometry.dispose();
                    shockwave.material.dispose();
                } else {
                    requestAnimationFrame(animateShockwave);
                }
            }
            animateShockwave();
        }

        // v6.31: Audio feedback for escape event
        function playEscapeSound() {
            try {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                const ctx = AudioSystem.ctx;
                if (ctx.state === 'suspended') ctx.resume();
                const now = ctx.currentTime;

                // Ascending whoosh tone
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                osc.frequency.exponentialRampToValueAtTime(1500, now + 0.3);

                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                osc.start(now);
                osc.stop(now + 0.35);
            } catch (e) { /* Audio not available */ }
        }

        // v6.31: Warning indicator when planets approach escape velocity
        function updateEscapeWarning() {
            const warningEl = document.getElementById('escape-warning');
            if (!warningEl || !civilizations) return;

            let maxRatio = 0;
            let nearEscapeCount = 0;

            for (const civ of civilizations) {
                if (civ.orbital && civ.orbital.velocityRatio && !civ.orbital.escaped) {
                    if (civ.orbital.velocityRatio > 0.7) nearEscapeCount++;
                    maxRatio = Math.max(maxRatio, civ.orbital.velocityRatio);
                }
            }

            if (maxRatio > 0.7 && nearEscapeCount > 0) {
                warningEl.style.display = 'block';
                const pct = (maxRatio * 100).toFixed(0);
                warningEl.innerHTML = ` <strong>${nearEscapeCount}</strong> planet${nearEscapeCount > 1 ? 's' : ''} at <strong>${pct}%</strong> escape velocity!`;
                warningEl.style.color = maxRatio > 0.95 ? '#ff4444' : '#ffaa44';
                warningEl.style.borderColor = maxRatio > 0.95 ? 'rgba(255,68,68,0.5)' : 'rgba(255,170,68,0.4)';
            } else {
                warningEl.style.display = 'none';
            }
        }

        // v6.31: Physics preset scenarios for educational demos
        const physicsPresets = {
            'stable': { G: 50000, M: 1000, timeScale: 0.5, maxEcc: 0.1 },
            'fast': { G: 120000, M: 2500, timeScale: 1.2, maxEcc: 0.2 },
            'elliptical': { G: 40000, M: 800, timeScale: 0.4, maxEcc: 0.7 },
            'chaos': { G: 15000, M: 400, timeScale: 2.0, maxEcc: 0.5 }
        };

        function applyPhysicsPreset(presetName) {
            const preset = physicsPresets[presetName];
            if (!preset) return;

            // Animate slider transitions for visual effect
            const gSlider = document.getElementById('physics-g');
            const massSlider = document.getElementById('physics-mass');
            const timeSlider = document.getElementById('physics-time');
            const eccSlider = document.getElementById('physics-ecc');

            if (gSlider) { gSlider.value = preset.G; gSlider.dispatchEvent(new Event('input')); }
            if (massSlider) { massSlider.value = preset.M; massSlider.dispatchEvent(new Event('input')); }
            if (timeSlider) { timeSlider.value = preset.timeScale; timeSlider.dispatchEvent(new Event('input')); }
            if (eccSlider) { eccSlider.value = preset.maxEcc; eccSlider.dispatchEvent(new Event('input')); }

            // Flash the preset button
            console.log(`Applied physics preset: ${presetName}`);
        }

        // v6.30: Update the escaped planets counter in the UI
        function updateEscapeCounterUI() {
            const counter = document.getElementById('escape-counter');
            const countEl = document.getElementById('escape-count');
            if (!counter || !countEl || !civilizations) return;

            const escapedPlanets = civilizations.filter(c => c.orbital && c.orbital.escaped).length;

            if (escapedPlanets > 0) {
                counter.style.display = 'block';
                countEl.textContent = escapedPlanets;
                // Pulse animation on new escape
                countEl.style.transform = 'scale(1.3)';
                setTimeout(() => countEl.style.transform = 'scale(1)', 200);
            } else {
                counter.style.display = 'none';
            }
        }

        // Update eccentricity for all orbits
        function updateOrbitalEccentricities(maxEcc) {
            if (!civilizations || civilizations.length === 0) return;

            // Scale existing eccentricities proportionally
            const oldMax = physicsParams.maxEccentricity;
            physicsParams.maxEccentricity = maxEcc;

            for (let i = 0; i < civilizations.length; i++) {
                const civ = civilizations[i];
                if (!civ.orbital) continue;

                // Scale eccentricity proportionally to new max
                if (oldMax > 0) {
                    const ratio = civ.orbital.eccentricity / oldMax;
                    civ.orbital.eccentricity = ratio * maxEcc;
                } else {
                    civ.orbital.eccentricity = Math.random() * maxEcc;
                }
            }
        }

        // v6.35: Settings panel is now toggle-based for cinematic view
        let settingsPanelOpen = false;

        // Toggle settings panel visibility
        function toggleSettingsPanel() {
            settingsPanelOpen = !settingsPanelOpen;
            const panel = document.getElementById('physics-tutorial');
            const btn = document.getElementById('settings-toggle-btn');

            if (!panel) return;

            if (settingsPanelOpen) {
                panel.classList.add('visible');
                if (btn) btn.classList.add('active');
                physicsTutorialVisible = true;
            } else {
                panel.classList.remove('visible');
                if (btn) btn.classList.remove('active');
                physicsTutorialVisible = false;
            }
        }

        // Show the physics tutorial panel (now just opens it)
        function showPhysicsTutorial() {
            // v6.35: No longer auto-shows - user must click toggle button
            // This function is kept for compatibility but does nothing by default
            // Only show if explicitly requested via toggle
        }

        // Hide the physics tutorial panel
        function hidePhysicsTutorial() {
            const panel = document.getElementById('physics-tutorial');
            const btn = document.getElementById('settings-toggle-btn');
            if (!panel) return;

            panel.classList.remove('visible');
            if (btn) btn.classList.remove('active');
            physicsTutorialVisible = false;
            settingsPanelOpen = false;
        }

        // Update toggle button visibility based on mode
        function updateSettingsToggleVisibility() {
            const btn = document.getElementById('settings-toggle-btn');
            if (!btn) return;

            if (mode === 'galaxy') {
                btn.style.display = 'flex';
            } else {
                btn.style.display = 'none';
                hidePhysicsTutorial();
            }
        }

        // Initialize physics tutorial sliders
        function initPhysicsTutorial() {
            const gSlider = document.getElementById('physics-g');
            const massSlider = document.getElementById('physics-mass');
            const timeSlider = document.getElementById('physics-time');
            const eccSlider = document.getElementById('physics-ecc');

            const gValue = document.getElementById('physics-g-value');
            const massValue = document.getElementById('physics-mass-value');
            const timeValue = document.getElementById('physics-time-value');
            const eccValue = document.getElementById('physics-ecc-value');

            const gBubble = document.getElementById('physics-g-bubble');
            const massBubble = document.getElementById('physics-mass-bubble');
            const timeBubble = document.getElementById('physics-time-bubble');
            const eccBubble = document.getElementById('physics-ecc-bubble');

            // Helper to position bubble over slider thumb
            function updateBubblePosition(slider, bubble) {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                const val = parseFloat(slider.value);
                const percent = (val - min) / (max - min);
                // Account for thumb width (22px) and slider padding
                const sliderWidth = slider.offsetWidth - 22;
                const position = 11 + (percent * sliderWidth);
                bubble.style.left = position + 'px';
            }

            if (gSlider && gBubble) {
                const updateG = () => {
                    physicsParams.G = parseFloat(gSlider.value);
                    const formatted = physicsParams.G.toLocaleString();
                    gValue.textContent = formatted;
                    gBubble.textContent = formatted;
                    updateBubblePosition(gSlider, gBubble);
                    recalculateOrbitalVelocities();
                    showPhysicsTutorial();
                };
                gSlider.addEventListener('input', updateG);
                // Initialize position
                updateBubblePosition(gSlider, gBubble);
            }

            if (massSlider && massBubble) {
                const updateMass = () => {
                    physicsParams.M = parseFloat(massSlider.value);
                    const formatted = physicsParams.M.toLocaleString();
                    massValue.textContent = formatted;
                    massBubble.textContent = formatted;
                    updateBubblePosition(massSlider, massBubble);
                    recalculateOrbitalVelocities();
                    showPhysicsTutorial();
                };
                massSlider.addEventListener('input', updateMass);
                updateBubblePosition(massSlider, massBubble);
            }

            if (timeSlider && timeBubble) {
                const updateTime = () => {
                    physicsParams.timeScale = parseFloat(timeSlider.value);
                    const formatted = physicsParams.timeScale.toFixed(2) + 'x';
                    timeValue.textContent = formatted;
                    timeBubble.textContent = formatted;
                    updateBubblePosition(timeSlider, timeBubble);
                    showPhysicsTutorial();
                };
                timeSlider.addEventListener('input', updateTime);
                updateBubblePosition(timeSlider, timeBubble);
            }

            if (eccSlider && eccBubble) {
                const updateEcc = () => {
                    const newEcc = parseFloat(eccSlider.value);
                    const formatted = newEcc.toFixed(2);
                    eccValue.textContent = formatted;
                    eccBubble.textContent = formatted;
                    updateBubblePosition(eccSlider, eccBubble);
                    updateOrbitalEccentricities(newEcc);
                    showPhysicsTutorial();
                };
                eccSlider.addEventListener('input', updateEcc);
                updateBubblePosition(eccSlider, eccBubble);
            }

            // Mouse movement shows the panel (only in galaxy mode)
            document.addEventListener('mousemove', () => {
                if (mode === 'galaxy') {
                    showPhysicsTutorial();
                }
            });

            // Touch events for mobile
            document.addEventListener('touchstart', () => {
                if (mode === 'galaxy') {
                    showPhysicsTutorial();
                }
            });

            // Keep panel visible while interacting with it
            const panel = document.getElementById('physics-tutorial');
            if (panel) {
                panel.addEventListener('mouseenter', () => {
                    if (physicsTutorialTimeout) {
                        clearTimeout(physicsTutorialTimeout);
                        physicsTutorialTimeout = null;
                    }
                });

                panel.addEventListener('mouseleave', () => {
                    showPhysicsTutorial(); // Restart hide timer
                });
            }
        }

        // ===========================================
        // v6.32: MIND-BLOWING FEATURES (8 Strategy Agents Consensus)
        // ===========================================

        // --- GRAVITATIONAL LENSING ---
        let gravitationalLensingEnabled = true;
        let lensingMesh = null;
        let lensingRings = [];

        function createGravitationalLensing() {
            if (lensingMesh) return;

            // Create concentric distortion rings around the black hole
            // This creates a visual "warping" effect showing spacetime curvature
            const numRings = 8;
            const baseRadius = 80;

            for (let i = 0; i < numRings; i++) {
                const radius = baseRadius + (i * 30);
                const ringGeometry = new THREE.RingGeometry(radius - 5, radius + 5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.7 - (i * 0.05), 0.8, 0.5 + (i * 0.03)),
                    transparent: true,
                    opacity: 0.15 - (i * 0.012),
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.userData.baseRotation = Math.random() * Math.PI * 2;
                ring.userData.rotationSpeed = 0.0003 * (1 + i * 0.2);
                ring.userData.pulsePhase = Math.random() * Math.PI * 2;
                lensingRings.push(ring);
                scene.add(ring);
            }

            // Central event horizon glow
            const eventHorizonGeo = new THREE.SphereGeometry(40, 32, 32);
            const eventHorizonMat = new THREE.MeshBasicMaterial({
                color: 0x110022,
                transparent: true,
                opacity: 0.9
            });
            lensingMesh = new THREE.Mesh(eventHorizonGeo, eventHorizonMat);
            scene.add(lensingMesh);

            // Accretion disk
            const diskGeo = new THREE.RingGeometry(50, 120, 64);
            const diskMat = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2.5;
            accretionDisk.userData.isAccretion = true;
            lensingRings.push(accretionDisk);
            scene.add(accretionDisk);

            // Photon sphere ring (where light orbits the black hole)
            const photonSphereGeo = new THREE.TorusGeometry(60, 2, 8, 64);
            const photonSphereMat = new THREE.MeshBasicMaterial({
                color: 0xffff88,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const photonSphere = new THREE.Mesh(photonSphereGeo, photonSphereMat);
            photonSphere.rotation.x = Math.PI / 2;
            photonSphere.userData.isPhotonSphere = true;
            lensingRings.push(photonSphere);
            scene.add(photonSphere);

            console.log('Gravitational lensing effect created (v6.32)');
        }

        function updateGravitationalLensing(time) {
            if (!gravitationalLensingEnabled || lensingRings.length === 0) return;

            lensingRings.forEach((ring, i) => {
                if (ring.userData.isAccretion) {
                    // Accretion disk rotates
                    ring.rotation.z += 0.002;
                } else if (ring.userData.isPhotonSphere) {
                    // Photon sphere pulses
                    const pulse = 0.4 + Math.sin(time * 0.003) * 0.2;
                    ring.material.opacity = pulse;
                    ring.rotation.z += 0.005;
                } else {
                    // Lensing rings warp and pulse
                    ring.rotation.z = ring.userData.baseRotation + time * ring.userData.rotationSpeed;
                    const pulse = 0.1 + Math.sin(time * 0.002 + ring.userData.pulsePhase) * 0.05;
                    ring.material.opacity = pulse;
                    // Slight scale breathing
                    const breathe = 1 + Math.sin(time * 0.001 + i) * 0.02;
                    ring.scale.setScalar(breathe);
                }
            });

            // Event horizon subtle pulse
            if (lensingMesh) {
                const horizonPulse = 1 + Math.sin(time * 0.002) * 0.05;
                lensingMesh.scale.setScalar(horizonPulse);
            }
        }

        function removeGravitationalLensing() {
            lensingRings.forEach(ring => {
                scene.remove(ring);
                ring.geometry.dispose();
                ring.material.dispose();
            });
            lensingRings = [];

            if (lensingMesh) {
                scene.remove(lensingMesh);
                lensingMesh.geometry.dispose();
                lensingMesh.material.dispose();
                lensingMesh = null;
            }
        }

        function toggleGravitationalLensing() {
            gravitationalLensingEnabled = !gravitationalLensingEnabled;
            const btn = document.getElementById('lensing-btn');
            if (btn) {
                btn.textContent = gravitationalLensingEnabled ? 'ON' : 'OFF';
                btn.style.background = gravitationalLensingEnabled ? 'rgba(128,0,255,0.3)' : 'rgba(50,50,50,0.3)';
            }

            if (gravitationalLensingEnabled && mode === 'galaxy') {
                createGravitationalLensing();
            } else {
                removeGravitationalLensing();
            }
        }

        // --- PLANET COLLISIONS ---
        let planetCollisionsEnabled = true;
        let collisionCount = 0;
        const COLLISION_DISTANCE = 40; // How close planets need to be to collide

        function checkPlanetCollisions() {
            if (!planetCollisionsEnabled || !civilizations || civilizations.length < 2) return;

            for (let i = 0; i < civilizations.length; i++) {
                const civA = civilizations[i];
                if (!civA || civA.orbital?.destroyed) continue;

                for (let j = i + 1; j < civilizations.length; j++) {
                    const civB = civilizations[j];
                    if (!civB || civB.orbital?.destroyed) continue;

                    // Calculate distance between planets
                    const dx = civA.x - civB.x;
                    const dy = civA.y - civB.y;
                    const dz = civA.z - civB.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (distance < COLLISION_DISTANCE) {
                        // COLLISION!
                        createPlanetCollision(civA, civB);
                    }
                }
            }
        }

        function createPlanetCollision(civA, civB) {
            // Midpoint of collision
            const collisionX = (civA.x + civB.x) / 2;
            const collisionY = (civA.y + civB.y) / 2;
            const collisionZ = (civA.z + civB.z) / 2;

            // Mark both as destroyed
            if (civA.orbital) civA.orbital.destroyed = true;
            if (civB.orbital) civB.orbital.destroyed = true;

            // v6.92: Persist destroyed planets
            if (gameData.destroyedPlanets) {
                if (!gameData.destroyedPlanets.includes(civA.id)) gameData.destroyedPlanets.push(civA.id);
                if (!gameData.destroyedPlanets.includes(civB.id)) gameData.destroyedPlanets.push(civB.id);
                saveGameData();
            }

            // Hide the planet meshes
            const groupA = galaxyGroup.children[civA.id];
            const groupB = galaxyGroup.children[civB.id];
            if (groupA) groupA.visible = false;
            if (groupB) groupB.visible = false;

            // Create SUPERNOVA explosion!
            createSupernovaExplosion(collisionX, collisionY, collisionZ, civA.color, civB.color);

            // Play dramatic collision sound
            playCollisionSound();

            // Screen shake
            triggerCollisionScreenShake();

            // Update counter
            collisionCount++;
            updateCollisionCounter();

            // Notify
            console.log(`COLLISION! ${civA.name} and ${civB.name} have merged in a cataclysmic event!`);
        }

        function createSupernovaExplosion(x, y, z, colorA, colorB) {
            // Create multiple explosion waves
            const waves = 5;

            for (let w = 0; w < waves; w++) {
                setTimeout(() => {
                    // Expanding shockwave ring
                    const shockwaveGeo = new THREE.RingGeometry(10, 20, 32);
                    const shockwaveMat = new THREE.MeshBasicMaterial({
                        color: w % 2 === 0 ? (colorA || 0xff4400) : (colorB || 0xffaa00),
                        transparent: true,
                        opacity: 1,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    const shockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
                    shockwave.position.set(x, y, z);
                    shockwave.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    scene.add(shockwave);

                    // Animate expansion
                    let scale = 1;
                    const expandShockwave = () => {
                        scale += 0.3;
                        shockwave.scale.setScalar(scale);
                        shockwave.material.opacity -= 0.02;

                        if (shockwave.material.opacity > 0) {
                            requestAnimationFrame(expandShockwave);
                        } else {
                            scene.remove(shockwave);
                            shockwave.geometry.dispose();
                            shockwave.material.dispose();
                        }
                    };
                    expandShockwave();

                }, w * 100);
            }

            // Particle burst
            const particleCount = 50;
            for (let i = 0; i < particleCount; i++) {
                const particleGeo = new THREE.SphereGeometry(3 + Math.random() * 5, 6, 6);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.05 + Math.random() * 0.1, 1, 0.5 + Math.random() * 0.3),
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.set(x, y, z);

                // Random velocity
                const speed = 2 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                particle.userData.vx = Math.sin(phi) * Math.cos(theta) * speed;
                particle.userData.vy = Math.sin(phi) * Math.sin(theta) * speed;
                particle.userData.vz = Math.cos(phi) * speed;
                particle.userData.life = 1;

                scene.add(particle);

                // Animate particle
                const animateParticle = () => {
                    particle.position.x += particle.userData.vx;
                    particle.position.y += particle.userData.vy;
                    particle.position.z += particle.userData.vz;
                    particle.userData.vx *= 0.98;
                    particle.userData.vy *= 0.98;
                    particle.userData.vz *= 0.98;
                    particle.userData.life -= 0.015;
                    particle.material.opacity = particle.userData.life;
                    particle.scale.setScalar(particle.userData.life);

                    if (particle.userData.life > 0) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    }
                };
                animateParticle();
            }

            // Bright flash
            const flashGeo = new THREE.SphereGeometry(100, 16, 16);
            const flashMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.position.set(x, y, z);
            scene.add(flash);

            let flashOpacity = 1;
            const fadeFlash = () => {
                flashOpacity -= 0.05;
                flash.material.opacity = flashOpacity;
                flash.scale.setScalar(1 + (1 - flashOpacity) * 2);

                if (flashOpacity > 0) {
                    requestAnimationFrame(fadeFlash);
                } else {
                    scene.remove(flash);
                    flash.geometry.dispose();
                    flash.material.dispose();
                }
            };
            fadeFlash();
        }

        function playCollisionSound() {
            try {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                const ctx = AudioSystem.ctx;
                if (ctx.state === 'suspended') ctx.resume();
                const now = ctx.currentTime;

                // Deep boom
                const boom = ctx.createOscillator();
                const boomGain = ctx.createGain();
                boom.type = 'sine';
                boom.frequency.setValueAtTime(60, now);
                boom.frequency.exponentialRampToValueAtTime(20, now + 0.5);
                boomGain.gain.setValueAtTime(0.8, now);
                boomGain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                boom.connect(boomGain);
                boomGain.connect(ctx.destination);
                boom.start(now);
                boom.stop(now + 1);

                // High crackle
                const crackle = ctx.createOscillator();
                const crackleGain = ctx.createGain();
                crackle.type = 'sawtooth';
                crackle.frequency.setValueAtTime(2000, now);
                crackle.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                crackleGain.gain.setValueAtTime(0.3, now);
                crackleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                crackle.connect(crackleGain);
                crackleGain.connect(ctx.destination);
                crackle.start(now);
                crackle.stop(now + 0.3);

                // Noise burst
                const bufferSize = ctx.sampleRate * 0.5;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.1));
                }
                const noise = ctx.createBufferSource();
                const noiseGain = ctx.createGain();
                noise.buffer = buffer;
                noiseGain.gain.setValueAtTime(0.4, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                noise.connect(noiseGain);
                noiseGain.connect(ctx.destination);
                noise.start(now);

            } catch (e) {
                console.log('Audio not supported');
            }
        }

        function triggerCollisionScreenShake() {
            const container = document.getElementById('container');
            if (!container) return;

            let shakeIntensity = 15;
            let shakeDuration = 500;
            const startTime = performance.now();

            const shake = () => {
                const elapsed = performance.now() - startTime;
                if (elapsed < shakeDuration) {
                    const decay = 1 - (elapsed / shakeDuration);
                    const offsetX = (Math.random() - 0.5) * shakeIntensity * decay;
                    const offsetY = (Math.random() - 0.5) * shakeIntensity * decay;
                    container.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                    requestAnimationFrame(shake);
                } else {
                    container.style.transform = '';
                }
            };
            shake();
        }

        function updateCollisionCounter() {
            const counter = document.getElementById('collision-counter');
            const countEl = document.getElementById('collision-count');
            if (!counter || !countEl) return;

            if (collisionCount > 0) {
                counter.style.display = 'block';
                countEl.textContent = collisionCount;
            }
        }

        function togglePlanetCollisions() {
            planetCollisionsEnabled = !planetCollisionsEnabled;
            const btn = document.getElementById('collisions-btn');
            if (btn) {
                btn.textContent = planetCollisionsEnabled ? 'ON' : 'OFF';
                btn.style.background = planetCollisionsEnabled ? 'rgba(255,100,0,0.3)' : 'rgba(50,50,50,0.3)';
            }
        }

        // ===========================================
        // v6.40: 4D TESSERACT WALK-THROUGH
        // Enter the black hole to experience impossible geometry
        // ===========================================

        // Tesseract state
        let tesseractMode = false;
        let tesseractScene = null;
        let tesseractCamera = null;
        let tesseractGroup = null;
        let tesseractRooms = [];
        let tesseractPortals = [];
        let currentRoom = 0;
        let nearbyPortal = null;

        // 4D rotation angles (radians)
        let tesseractRotations = {
            xy: 0, xz: 0, xw: 0,
            yz: 0, yw: 0, zw: 0
        };

        // First person movement
        let fpMoveSpeed = 0.15;
        let fpLookSpeed = 0.002;
        let fpPosition = new THREE.Vector3(0, 1.7, 0);
        let fpYaw = 0;
        let fpPitch = 0;
        let fpVelocity = new THREE.Vector3();
        let fpKeys = { w: false, a: false, s: false, d: false };
        let pointerLocked = false;

        // 4D Tesseract vertices (16 vertices of a 4D hypercube)
        function generateTesseractVertices(size = 10) {
            const vertices4D = [];
            for (let w = -1; w <= 1; w += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    for (let y = -1; y <= 1; y += 2) {
                        for (let x = -1; x <= 1; x += 2) {
                            vertices4D.push([x * size, y * size, z * size, w * size]);
                        }
                    }
                }
            }
            return vertices4D;
        }

        // 4D rotation matrices
        function rotate4D(vertex, rotations) {
            let [x, y, z, w] = vertex;

            // XY rotation
            if (rotations.xy !== 0) {
                const cos = Math.cos(rotations.xy);
                const sin = Math.sin(rotations.xy);
                [x, y] = [x * cos - y * sin, x * sin + y * cos];
            }

            // XZ rotation
            if (rotations.xz !== 0) {
                const cos = Math.cos(rotations.xz);
                const sin = Math.sin(rotations.xz);
                [x, z] = [x * cos - z * sin, x * sin + z * cos];
            }

            // XW rotation (4D specific!)
            if (rotations.xw !== 0) {
                const cos = Math.cos(rotations.xw);
                const sin = Math.sin(rotations.xw);
                [x, w] = [x * cos - w * sin, x * sin + w * cos];
            }

            // YZ rotation
            if (rotations.yz !== 0) {
                const cos = Math.cos(rotations.yz);
                const sin = Math.sin(rotations.yz);
                [y, z] = [y * cos - z * sin, y * sin + z * cos];
            }

            // YW rotation (4D specific!)
            if (rotations.yw !== 0) {
                const cos = Math.cos(rotations.yw);
                const sin = Math.sin(rotations.yw);
                [y, w] = [y * cos - w * sin, y * sin + w * cos];
            }

            // ZW rotation (4D specific!)
            if (rotations.zw !== 0) {
                const cos = Math.cos(rotations.zw);
                const sin = Math.sin(rotations.zw);
                [z, w] = [z * cos - w * sin, z * sin + w * cos];
            }

            return [x, y, z, w];
        }

        // Project 4D to 3D (stereographic projection)
        function project4Dto3D(vertex4D, distance = 30) {
            const [x, y, z, w] = vertex4D;
            // Stereographic projection from 4D to 3D
            const factor = distance / (distance - w);
            return new THREE.Vector3(x * factor, y * factor, z * factor);
        }

        // Tesseract edge definitions (32 edges connecting 16 vertices)
        function getTesseractEdges() {
            const edges = [];
            // Connect vertices that differ by exactly one coordinate
            for (let i = 0; i < 16; i++) {
                for (let j = i + 1; j < 16; j++) {
                    // Count differing bits
                    let diff = i ^ j;
                    // If exactly one bit differs, these vertices are connected
                    if (diff === 1 || diff === 2 || diff === 4 || diff === 8) {
                        edges.push([i, j]);
                    }
                }
            }
            return edges;
        }

        // ROOM DEFINITIONS - each room is bigger on the inside
        const TESSERACT_ROOMS = [
            {
                name: "The Outer Shell",
                desc: "The boundary between 3D and 4D. Reality seems... normal here.",
                color: 0xff00ff,
                scale: 1,
                walls: 'normal'
            },
            {
                name: "The Expanding Hall",
                desc: "This corridor extends impossibly far. The walls recede as you approach.",
                color: 0x00ffff,
                scale: 3,
                walls: 'receding'
            },
            {
                name: "The Infinite Library",
                desc: "Shelves stretch in directions that shouldn't exist. Books written in 4D.",
                color: 0xffff00,
                scale: 5,
                walls: 'fractal'
            },
            {
                name: "The Folded Garden",
                desc: "Space curves back on itself. You can see yourself from behind.",
                color: 0x00ff00,
                scale: 2,
                walls: 'curved'
            },
            {
                name: "The Paradox Chamber",
                desc: "Every door leads to the same room, yet each room is different.",
                color: 0xff6600,
                scale: 4,
                walls: 'paradox'
            },
            {
                name: "The W-Axis Void",
                desc: "Pure 4th dimensional space. Your mind struggles to comprehend.",
                color: 0x8800ff,
                scale: 10,
                walls: 'void'
            },
            {
                name: "The Tesseract Core",
                desc: "The heart of the hypercube. All 8 cells converge here.",
                color: 0xffffff,
                scale: 8,
                walls: 'core'
            },
            {
                name: "The Klein Bottle Room",
                desc: "Inside is outside. The walls have no boundary.",
                color: 0xff0088,
                scale: 2.5,
                walls: 'klein'
            }
        ];


        // v6.82: 4D INTUITION ENGINE - Vertex Trail System
        let vertexTrails = new Map(); // vertex index -> trail positions
        let vertexTrailGroup = null;
        let vertexTrailsEnabled = true;
        const MAX_TRAIL_LENGTH = 20;
        let previousWSum = 0; // For inside-out detection
        
        // Ana/Kata coloring function
        function getAnaKataColor(wValue, maxW = 15) {
            const normalized = wValue / maxW; // -1 to 1
            if (normalized > 0.1) {
                // +W (Ana) - Cyan to White
                const intensity = normalized;
                return new THREE.Color(
                    1 - intensity * 0.5,
                    1,
                    1
                );
            } else if (normalized < -0.1) {
                // -W (Kata) - Magenta to White
                const intensity = -normalized;
                return new THREE.Color(
                    1,
                    1 - intensity * 0.5,
                    1
                );
            } else {
                // Near W=0 - White
                return new THREE.Color(1, 1, 1);
            }
        }
        
        // Update vertex trails
        function updateVertexTrails(projectedVertices) {
            if (!vertexTrailsEnabled || !projectedVertices) return;
            
            projectedVertices.forEach((pos, i) => {
                if (!vertexTrails.has(i)) {
                    vertexTrails.set(i, []);
                }
                const trail = vertexTrails.get(i);
                trail.push(pos.clone());
                if (trail.length > MAX_TRAIL_LENGTH) {
                    trail.shift();
                }
            });
        }
        
        // Render vertex trails as fading lines
        function renderVertexTrails() {
            if (vertexTrailGroup) {
                scene.remove(vertexTrailGroup);
            }
            
            if (!vertexTrailsEnabled || vertexTrails.size === 0) return;
            
            vertexTrailGroup = new THREE.Group();
            
            vertexTrails.forEach((trail, vertexIdx) => {
                if (trail.length < 2) return;
                
                for (let i = 1; i < trail.length; i++) {
                    const opacity = (i / trail.length) * 0.4;
                    const material = new THREE.LineBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: opacity
                    });
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        trail[i - 1],
                        trail[i]
                    ]);
                    const line = new THREE.Line(geometry, material);
                    vertexTrailGroup.add(line);
                }
            });
            
            scene.add(vertexTrailGroup);
        }
        
        // Check for inside-out transition
        function checkInsideOut(rotatedVertices) {
            let currentWSum = 0;
            rotatedVertices.forEach(v => {
                currentWSum += v[3];
            });
            
            // If sign changes significantly, we've inverted
            if (previousWSum !== 0 && Math.sign(currentWSum) !== Math.sign(previousWSum) && Math.abs(currentWSum - previousWSum) > 50) {
                showInsideOutIndicator();
            }
            previousWSum = currentWSum;
        }
        
        function showInsideOutIndicator() {
            const indicator = document.getElementById('inside-out-indicator');
            if (indicator) {
                indicator.classList.remove('active');
                void indicator.offsetWidth; // Force reflow
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 800);
            }
        }
        
        // Show/hide Ana-Kata legend
        function showAnaKataLegend() {
            const legend = document.getElementById('ana-kata-legend');
            if (legend) legend.classList.add('active');
        }
        
        function hideAnaKataLegend() {
            const legend = document.getElementById('ana-kata-legend');
            if (legend) legend.classList.remove('active');
        }

        // Create the tesseract visualization
        function createTesseract() {
            if (tesseractGroup) {
                scene.remove(tesseractGroup);
                tesseractGroup = null;
            }

            tesseractGroup = new THREE.Group();

            // Get 4D vertices and apply rotations
            const vertices4D = generateTesseractVertices(15);
            const rotatedVertices = vertices4D.map(v => rotate4D(v, tesseractRotations));
            const projectedVertices = rotatedVertices.map(v => project4Dto3D(v));

            // Draw edges
            const edges = getTesseractEdges();
            const edgeMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });

            edges.forEach(([i, j]) => {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    projectedVertices[i],
                    projectedVertices[j]
                ]);
                const line = new THREE.Line(geometry, edgeMaterial.clone());
                // v6.82: Ana/Kata coloring - cyan for +W, magenta for -W
                const avgW = (rotatedVertices[i][3] + rotatedVertices[j][3]) / 2;
                line.material.color.copy(getAnaKataColor(avgW, 15));
                line.material.opacity = 0.6 + Math.abs(avgW) / 30 * 0.3;
                tesseractGroup.add(line);
            });

            // Draw vertices as glowing spheres
            const vertexMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });

            projectedVertices.forEach((pos, i) => {
                const wValue = rotatedVertices[i][3];
                // v6.82: Size based on W-coordinate (closer to our 3D slice = larger)
                const size = 0.5 - Math.abs(wValue) / 30 * 0.3;
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(Math.max(0.2, size), 12, 12),
                    vertexMaterial.clone()
                );
                sphere.position.copy(pos);
                // v6.82: Ana/Kata coloring
                sphere.material.color.copy(getAnaKataColor(wValue, 15));
                tesseractGroup.add(sphere);
            });

            // v6.82: Update vertex trails and check for inside-out
            updateVertexTrails(projectedVertices);
            renderVertexTrails();
            checkInsideOut(rotatedVertices);

            scene.add(tesseractGroup);
            return tesseractGroup;
        }

        // Create impossible room geometry
        function createImpossibleRoom(roomIndex) {
            const room = TESSERACT_ROOMS[roomIndex];
            const roomGroup = new THREE.Group();
            roomGroup.userData.roomIndex = roomIndex;

            // Room dimensions (bigger on inside based on scale)
            const baseSize = 10;
            const roomSize = baseSize * room.scale;

            // Floor with impossible pattern
            const floorGeo = new THREE.PlaneGeometry(roomSize, roomSize, 32, 32);
            const floorMat = new THREE.MeshStandardMaterial({
                color: room.color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                wireframe: room.walls === 'void'
            });

            // Warp the floor geometry for impossible effect
            const positions = floorGeo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const dist = Math.sqrt(x * x + y * y);
                // Create impossible depth perception
                if (room.walls === 'receding') {
                    positions[i + 2] = Math.sin(dist * 0.2) * (room.scale - 1);
                } else if (room.walls === 'curved') {
                    positions[i + 2] = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 5;
                } else if (room.walls === 'paradox') {
                    positions[i + 2] = (Math.sin(x * 0.5) + Math.cos(y * 0.5)) * 2;
                }
            }
            floorGeo.computeVertexNormals();

            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            roomGroup.add(floor);

            // Create walls that recede into impossible distances
            const wallHeight = 8 * room.scale;
            const wallMat = new THREE.MeshStandardMaterial({
                color: room.color,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });

            // Four walls
            const wallPositions = [
                { x: 0, z: -roomSize / 2, rotY: 0 },
                { x: 0, z: roomSize / 2, rotY: Math.PI },
                { x: -roomSize / 2, z: 0, rotY: Math.PI / 2 },
                { x: roomSize / 2, z: 0, rotY: -Math.PI / 2 }
            ];

            wallPositions.forEach((wp, idx) => {
                const wallGeo = new THREE.PlaneGeometry(roomSize, wallHeight, 16, 16);

                // Warp walls for impossible geometry
                const wallPos = wallGeo.attributes.position.array;
                for (let i = 0; i < wallPos.length; i += 3) {
                    if (room.walls === 'receding') {
                        wallPos[i + 2] = Math.abs(wallPos[i]) * 0.3;
                    } else if (room.walls === 'klein') {
                        wallPos[i + 2] = Math.sin(wallPos[i] * 0.3 + wallPos[i + 1] * 0.2) * 3;
                    }
                }
                wallGeo.computeVertexNormals();

                const wall = new THREE.Mesh(wallGeo, wallMat.clone());
                wall.position.set(wp.x, wallHeight / 2, wp.z);
                wall.rotation.y = wp.rotY;
                roomGroup.add(wall);

                // Add portal at center of each wall
                const portal = createPortal(idx, room.color);
                portal.position.set(wp.x, 1.5, wp.z);
                portal.rotation.y = wp.rotY;
                portal.userData.wallIndex = idx;
                portal.userData.sourceRoom = roomIndex;
                portal.userData.targetRoom = (roomIndex + idx + 1) % TESSERACT_ROOMS.length;
                roomGroup.add(portal);
                tesseractPortals.push(portal);
            });

            // Ceiling with recursive pattern
            const ceiling = floor.clone();
            ceiling.position.y = wallHeight;
            ceiling.rotation.x = Math.PI / 2;
            roomGroup.add(ceiling);

            // Add glowing grid lines
            const gridHelper = new THREE.GridHelper(roomSize, Math.floor(roomSize / 2), room.color, room.color);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.2;
            gridHelper.position.y = 0.01;
            roomGroup.add(gridHelper);

            // Add ambient light with room color
            const roomLight = new THREE.PointLight(room.color, 1.5, roomSize * 2);
            roomLight.position.set(0, wallHeight / 2, 0);
            roomGroup.add(roomLight);

            return roomGroup;
        }

        // Create portal door
        function createPortal(index, color) {
            const portalGroup = new THREE.Group();
            portalGroup.userData.isPortal = true;
            portalGroup.userData.portalIndex = index;

            // Portal frame
            const frameGeo = new THREE.TorusGeometry(2, 0.2, 8, 32);
            const frameMat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.rotation.y = Math.PI / 2;
            portalGroup.add(frame);

            // Portal surface (shimmering effect)
            const surfaceGeo = new THREE.CircleGeometry(1.8, 32);
            const surfaceMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const surface = new THREE.Mesh(surfaceGeo, surfaceMat);
            surface.rotation.y = Math.PI / 2;
            surface.userData.portalSurface = true;
            portalGroup.add(surface);

            // Swirling effect
            const swirlGeo = new THREE.RingGeometry(0.5, 1.7, 32);
            const swirlMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const swirl = new THREE.Mesh(swirlGeo, swirlMat);
            swirl.rotation.y = Math.PI / 2;
            swirl.userData.isSwirl = true;
            portalGroup.add(swirl);

            return portalGroup;
        }

        // Enter tesseract mode from black hole
        function showBlackHoleEntryPrompt() {
            const modal = document.getElementById('black-hole-entry');
            if (modal) modal.classList.add('active');
        }

        function cancelBlackHoleEntry() {
            const modal = document.getElementById('black-hole-entry');
            if (modal) modal.classList.remove('active');
        }

        function enterTesseract() {
            const modal = document.getElementById('black-hole-entry');
            if (modal) modal.classList.remove('active');

            // Show dimension shift effect
            const overlay = document.getElementById('dimension-shift');
            if (overlay) {
                overlay.classList.add('active');
                setTimeout(() => overlay.classList.remove('active'), 2000);
            }

            // Delay entering tesseract for effect
            setTimeout(() => {
                initTesseractMode();
            }, 800);
        }

        function initTesseractMode() {
            tesseractMode = true;
            mode = 'tesseract';

            // Hide galaxy UI
            document.getElementById('galaxy-controls').style.display = 'none';
            const physicsPanel = document.getElementById('physics-tutorial');
            if (physicsPanel) physicsPanel.classList.remove('visible');
            const settingsBtn = document.getElementById('settings-toggle-btn');
            if (settingsBtn) settingsBtn.style.display = 'none';

            // Show tesseract UI
            document.getElementById('tesseract-hud').classList.add('active');
            document.getElementById('tesseract-controls').classList.add('active');
            document.getElementById('tesseract-room').classList.add('active');
            document.getElementById('tesseract-hint').classList.add('active');

            // v6.60: Show 4D Guide UI
            showTesseractGuideUI();

            // v6.60: Start immersive tutorial for first-time visitors
            setTimeout(() => {
                if (!hasCompletedTutorial()) {
                    startImmersiveTutorial();
                }
            }, 2500); // Delay to let the scene settle

            // Clear galaxy scene
            while (scene.children.length > 0) scene.remove(scene.children[0]);

            // Setup tesseract scene
            scene.background = new THREE.Color(0x050010);
            scene.fog = new THREE.FogExp2(0x100020, 0.01);

            // Ambient light
            const ambient = new THREE.AmbientLight(0x332255, 0.5);
            scene.add(ambient);

            // Create the 4D tesseract wireframe
            createTesseract();

            // Create first room
            currentRoom = 0;
            tesseractPortals = [];
            tesseractRooms = [];
            const roomGroup = createImpossibleRoom(currentRoom);
            roomGroup.position.set(0, 0, 0);
            scene.add(roomGroup);
            tesseractRooms.push(roomGroup);

            // Update room display
            updateRoomDisplay();

            // Setup first-person camera
            fpPosition.set(0, 1.7, 0);
            fpYaw = 0;
            fpPitch = 0;
            camera.position.copy(fpPosition);
            camera.rotation.order = 'YXZ';

            // Request pointer lock for mouse look
            renderer.domElement.addEventListener('click', requestPointerLock);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onTesseractMouseMove);

            // Keyboard controls for movement
            document.addEventListener('keydown', onTesseractKeyDown);
            document.addEventListener('keyup', onTesseractKeyUp);

            // Start animation
            startAutoRotation();
        }

        function exitTesseract() {
            tesseractMode = false;

            // Show dimension shift effect
            const overlay = document.getElementById('dimension-shift');
            if (overlay) {
                overlay.querySelector('.dimension-shift-text').textContent = 'RETURNING TO NORMAL SPACE...';
                overlay.classList.add('active');
                setTimeout(() => {
                    overlay.classList.remove('active');
                    overlay.querySelector('.dimension-shift-text').textContent = 'SHIFTING DIMENSIONS...';
                }, 2000);
            }

            // Hide tesseract UI
            document.getElementById('tesseract-hud').classList.remove('active');
            document.getElementById('tesseract-controls').classList.remove('active');
            document.getElementById('tesseract-room').classList.remove('active');
            document.getElementById('tesseract-hint').classList.remove('active');
            document.getElementById('portal-prompt').classList.remove('active');

            // v6.60: Hide 4D Guide UI
            hideTesseractGuideUI();

            // Clean up events
            renderer.domElement.removeEventListener('click', requestPointerLock);
            document.removeEventListener('pointerlockchange', onPointerLockChange);
            document.removeEventListener('mousemove', onTesseractMouseMove);
            document.removeEventListener('keydown', onTesseractKeyDown);
            document.removeEventListener('keyup', onTesseractKeyUp);

            // Exit pointer lock
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            // Clean up scene
            tesseractRooms.forEach(room => scene.remove(room));
            tesseractRooms = [];
            tesseractPortals = [];
            if (tesseractGroup) {
                scene.remove(tesseractGroup);
                tesseractGroup = null;
            }

            // Return to galaxy
            setTimeout(() => {
                initGalaxy();
            }, 1000);
        }

        function requestPointerLock() {
            if (tesseractMode && !pointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        }

        function onPointerLockChange() {
            pointerLocked = document.pointerLockElement === renderer.domElement;
        }

        function onTesseractMouseMove(e) {
            if (!tesseractMode || !pointerLocked) return;

            fpYaw -= e.movementX * fpLookSpeed;
            fpPitch -= e.movementY * fpLookSpeed;

            // Clamp pitch
            fpPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, fpPitch));
        }

        function onTesseractKeyDown(e) {
            if (!tesseractMode) return;

            switch (e.key.toLowerCase()) {
                case 'w': fpKeys.w = true; break;
                case 'a': fpKeys.a = true; break;
                case 's': fpKeys.s = true; break;
                case 'd': fpKeys.d = true; break;
                case ' ':
                    e.preventDefault();
                    if (nearbyPortal) {
                        enterPortal(nearbyPortal);
                    }
                    break;
                case 'escape':
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    } else {
                        exitTesseract();
                    }
                    break;
            }
        }

        function onTesseractKeyUp(e) {
            if (!tesseractMode) return;

            switch (e.key.toLowerCase()) {
                case 'w': fpKeys.w = false; break;
                case 'a': fpKeys.a = false; break;
                case 's': fpKeys.s = false; break;
                case 'd': fpKeys.d = false; break;
            }
        }

        function updateTesseractRotation() {
            // Read slider values
            tesseractRotations.xy = parseFloat(document.getElementById('rot-xy').value) * Math.PI / 180;
            tesseractRotations.xz = parseFloat(document.getElementById('rot-xz').value) * Math.PI / 180;
            tesseractRotations.xw = parseFloat(document.getElementById('rot-xw').value) * Math.PI / 180;
            tesseractRotations.yz = parseFloat(document.getElementById('rot-yz').value) * Math.PI / 180;
            tesseractRotations.yw = parseFloat(document.getElementById('rot-yw').value) * Math.PI / 180;
            tesseractRotations.zw = parseFloat(document.getElementById('rot-zw').value) * Math.PI / 180;

            // Update display values
            document.getElementById('rot-xy-val').textContent = Math.round(tesseractRotations.xy * 180 / Math.PI) + '';
            document.getElementById('rot-xz-val').textContent = Math.round(tesseractRotations.xz * 180 / Math.PI) + '';
            document.getElementById('rot-xw-val').textContent = Math.round(tesseractRotations.xw * 180 / Math.PI) + '';
            document.getElementById('rot-yz-val').textContent = Math.round(tesseractRotations.yz * 180 / Math.PI) + '';
            document.getElementById('rot-yw-val').textContent = Math.round(tesseractRotations.yw * 180 / Math.PI) + '';
            document.getElementById('rot-zw-val').textContent = Math.round(tesseractRotations.zw * 180 / Math.PI) + '';

            // Recreate tesseract with new rotations
            if (tesseractMode) {
                createTesseract();
            }

            // v6.60: Check tutorial challenge progress
            checkChallengeProgress();
        }

        // Auto-rotation for ambient effect
        let autoRotationEnabled = true;
        function startAutoRotation() {
            autoRotationEnabled = true;
        }

        function updateAutoRotation(time) {
            if (!tesseractMode || !autoRotationEnabled) return;

            // Gentle automatic rotation in W-axis dimensions
            const baseSpeed = 0.0002;
            tesseractRotations.xw += baseSpeed * 0.7;
            tesseractRotations.yw += baseSpeed * 0.5;
            tesseractRotations.zw += baseSpeed * 0.3;

            // Update sliders to match
            document.getElementById('rot-xw').value = (tesseractRotations.xw * 180 / Math.PI) % 360;
            document.getElementById('rot-yw').value = (tesseractRotations.yw * 180 / Math.PI) % 360;
            document.getElementById('rot-zw').value = (tesseractRotations.zw * 180 / Math.PI) % 360;

            // Update displays
            document.getElementById('rot-xw-val').textContent = Math.round(tesseractRotations.xw * 180 / Math.PI) % 360 + '';
            document.getElementById('rot-yw-val').textContent = Math.round(tesseractRotations.yw * 180 / Math.PI) % 360 + '';
            document.getElementById('rot-zw-val').textContent = Math.round(tesseractRotations.zw * 180 / Math.PI) % 360 + '';

            // Recreate tesseract with new rotations
            createTesseract();

            // v6.60: Update W-coordinate indicator
            updateWCoordinateIndicator();
        }

        function updateRoomDisplay() {
            const room = TESSERACT_ROOMS[currentRoom];
            document.getElementById('room-name').textContent = room.name;
            document.getElementById('room-desc').textContent = room.desc;
        }

        function enterPortal(portal) {
            const targetRoom = portal.userData.targetRoom;

            // v6.60: Notify tutorial system
            onPortalEnteredDuringTutorial();

            // Show dimension shift effect
            const overlay = document.getElementById('dimension-shift');
            if (overlay) {
                overlay.querySelector('.dimension-shift-text').textContent = `ENTERING ${TESSERACT_ROOMS[targetRoom].name.toUpperCase()}...`;
                overlay.classList.add('active');
                setTimeout(() => overlay.classList.remove('active'), 1500);
            }

            // Switch rooms after brief delay
            setTimeout(() => {
                // Remove old room
                tesseractRooms.forEach(room => scene.remove(room));
                tesseractRooms = [];
                tesseractPortals = [];

                // Create new room
                currentRoom = targetRoom;
                const newRoom = createImpossibleRoom(currentRoom);
                scene.add(newRoom);
                tesseractRooms.push(newRoom);

                // Reset player position
                fpPosition.set(0, 1.7, 0);
                fpYaw = 0;

                // Update display
                updateRoomDisplay();
                nearbyPortal = null;
                document.getElementById('portal-prompt').classList.remove('active');
            }, 500);
        }

        function updateTesseractMovement() {
            if (!tesseractMode) return;

            // Get movement direction
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), fpYaw);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), fpYaw);

            // Apply movement
            if (fpKeys.w) fpPosition.add(forward.clone().multiplyScalar(fpMoveSpeed));
            if (fpKeys.s) fpPosition.add(forward.clone().multiplyScalar(-fpMoveSpeed));
            if (fpKeys.a) fpPosition.add(right.clone().multiplyScalar(-fpMoveSpeed));
            if (fpKeys.d) fpPosition.add(right.clone().multiplyScalar(fpMoveSpeed));

            // Update camera
            camera.position.copy(fpPosition);
            camera.rotation.set(fpPitch, fpYaw, 0, 'YXZ');

            // Check for nearby portals
            nearbyPortal = null;
            let closestDist = 3; // Portal activation distance

            tesseractPortals.forEach(portal => {
                const portalWorldPos = new THREE.Vector3();
                portal.getWorldPosition(portalWorldPos);
                const dist = fpPosition.distanceTo(portalWorldPos);

                if (dist < closestDist) {
                    closestDist = dist;
                    nearbyPortal = portal;
                }
            });

            // Show/hide portal prompt
            const prompt = document.getElementById('portal-prompt');
            if (nearbyPortal) {
                prompt.classList.add('active');
                prompt.textContent = `Press SPACE to enter ${TESSERACT_ROOMS[nearbyPortal.userData.targetRoom].name}`;

                // v6.60: Check tutorial challenge (approach portal)
                checkChallengeProgress();
            } else {
                prompt.classList.remove('active');
            }

            // Animate portals
            tesseractPortals.forEach(portal => {
                portal.children.forEach(child => {
                    if (child.userData.isSwirl) {
                        child.rotation.z += 0.02;
                    }
                });
            });
        }

        // ===========================================
        // v6.60: THROUGH THE TESSERACT - 4D Higher Dimensional Guide
        // IMMERSIVE TUTORIAL SYSTEM - The world teaches you
        // ===========================================

        // Guide panel state (reference panel - not the main tutorial)
        let guideOpen = false;

        // IMMERSIVE TUTORIAL STATE
        let immersiveTutorialActive = false;
        let immersiveTutorialStage = 0;
        let tutorialFirstTime = true; // Check localStorage for returning visitors
        let narratorTimeout = null;
        let tutorialDemoActive = false;
        let waitingForPlayerAction = false;
        let playerCompletedAction = false;

        // Check if player has completed tutorial before
        function hasCompletedTutorial() {
            try {
                return localStorage.getItem('leviathan_tesseract_tutorial') === 'completed';
            } catch (e) {
                return false;
            }
        }

        function markTutorialCompleted() {
            try {
                localStorage.setItem('leviathan_tesseract_tutorial', 'completed');
            } catch (e) {}
        }

        // IMMERSIVE TUTORIAL STAGES
        // Each stage has: narration, optional demo, optional player challenge
        const IMMERSIVE_STAGES = [
            {
                id: 'awakening',
                stageName: 'THE CROSSING',
                narration: [
                    "You have crossed the event horizon.",
                    "Space and time twist around you...",
                    "Welcome to the <span class='highlight'>fourth dimension</span>."
                ],
                demo: null,
                challenge: null,
                delay: 2000
            },
            // v6.82: 4D Intuition Engine - Pattern Recognition Stage
            {
                id: 'the_pattern',
                stageName: 'THE PATTERN',
                narration: [
                    "Before you can see the tesseract, you must understand the <span class='highlight'>pattern</span>.",
                    "Point to line: <span class='highlight'>1  2</span> vertices.",
                    "Line to square: <span class='highlight'>2  4</span> vertices.",
                    "Square to cube: <span class='highlight'>4  8</span> vertices.",
                    "Each dimension <span class='highlight'>doubles</span>. Now... cube to tesseract?"
                ],
                demo: null,
                challenge: null,
                delay: 4500
            },
            {
                id: 'first_sight',
                stageName: 'FIRST SIGHT',
                narration: [
                    "Before you floats a <span class='highlight'>tesseract</span>  a four-dimensional hypercube.",
                    "What you see is its <span class='highlight'>shadow</span> in 3D space.",
                    "Count the vertices. There are <span class='highlight'>sixteen</span>. Eight more than a cube.",
                    "Some are hidden. They exist in a direction you cannot point."
                ],
                demo: null,
                challenge: null,
                delay: 3500
            },
            {
                id: 'familiar_rotation',
                stageName: 'THE FAMILIAR',
                narration: [
                    "First, something you know.",
                    "Watch as space rotates in the <span class='highlight'>XY plane</span>...",
                    "This is ordinary 3D rotation. Comfortable. Safe."
                ],
                demo: { type: 'rotation', plane: 'xy', duration: 2500 },
                challenge: null,
                delay: 1500
            },
            {
                id: 'impossible_rotation',
                stageName: 'THE IMPOSSIBLE',
                narration: [
                    "Now... something that should not exist.",
                    "Watch the <span class='highlight'>XW plane</span>.",
                    "This rotates space through the <span class='highlight'>fourth dimension</span>."
                ],
                demo: { type: 'rotation', plane: 'xw', duration: 3500 },
                challenge: null,
                delay: 1500,
                postNarration: [
                    "Did you see? Vertices didn't just move  they <span class='highlight'>vanished</span>.",
                    "They rotated <span class='highlight'>through</span> you. Into a direction that doesn't exist here.",
                    "<span class='dim'>Your eyes cannot follow. Your brain cannot parse. This is correct.</span>"
                ]
            },
            {
                id: 'your_turn',
                stageName: 'YOUR TURN',
                narration: [
                    "Now you try.",
                    "Find the <span class='highlight'>XW slider</span> on the right.",
                    "Move it. Feel what happens."
                ],
                demo: null,
                challenge: { type: 'rotate_xw', successThreshold: 30 },
                delay: 500
            },
            {
                id: 'w_axis_reveal',
                stageName: 'THE W-AXIS',
                narration: [
                    "You have touched the fourth direction.",
                    "It is called <span class='highlight'>W</span>.",
                    "<span class='highlight'>Ana</span>  movement in the +W direction. Think of it as... hyper-up.",
                    "<span class='highlight'>Kata</span>  movement in -W. Hyper-down.",
                    "The tesseract extends equally in all four directions. You are inside one of its <span class='highlight'>eight cubic cells</span>."
                ],
                demo: { type: 'show_w_axis' },
                challenge: null,
                delay: 2000
            },
            {
                id: 'portal_approach',
                stageName: 'THE PORTAL',
                narration: [
                    "See the portals in the walls?",
                    "Walk toward one. Use <span class='highlight'>WASD</span> to move.",
                    "When you step through... you will move in the <span class='highlight'>W direction</span>.",
                    "You will walk forward  but travel <span class='highlight'>hyperward</span>."
                ],
                demo: null,
                challenge: { type: 'approach_portal' },
                delay: 1000
            },
            {
                id: 'portal_crossing',
                stageName: 'THROUGH',
                narration: [
                    "Press <span class='highlight'>SPACE</span> to step through.",
                    "Feel the geometry shift around you.",
                    "You are now in a different cell. The same tesseract. A different slice of 4D."
                ],
                demo: null,
                challenge: { type: 'enter_portal' },
                delay: 500
            },
            {
                id: 'understanding',
                stageName: 'THE TRUTH',
                narration: [
                    "Eight rooms. Eight cubes. One hypercube.",
                    "Each room connects to the others through faces that overlap in 4D but not in 3D.",
                    "Your mind was not built for this. <span class='dim'>No human mind was.</span>",
                    "But you <span class='highlight'>experienced</span> it. And that is the first step.",
                    "The tesseract is now yours to explore."
                ],
                demo: null,
                challenge: null,
                delay: 2500
            },
            {
                id: 'freedom',
                stageName: 'FREEDOM',
                narration: [
                    "<span class='dim'>The guide falls silent.</span>",
                    "Walk the impossible halls. Rotate the unimaginable planes.",
                    "And when you are ready... <span class='highlight'>ESC</span> returns you to 3D space."
                ],
                demo: null,
                challenge: null,
                delay: 2000,
                final: true
            }
        ];

        // Toggle 4D Guide panel
        function toggleTesseractGuide() {
            guideOpen = !guideOpen;
            const panel = document.getElementById('tesseract-guide-panel');
            const toggle = document.getElementById('tesseract-guide-toggle');

            if (guideOpen) {
                panel.classList.add('active');
                toggle.style.left = '360px';
            } else {
                panel.classList.remove('active');
                toggle.style.left = '20px';
            }
        }

        // Switch between guide tabs
        function switchGuideTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.guide-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.toLowerCase().includes(tabName.toLowerCase().substring(0, 4))) {
                    tab.classList.add('active');
                }
            });

            // Update tab content
            document.querySelectorAll('.guide-tab-content').forEach(content => {
                content.classList.remove('active');
            });

            const targetContent = document.getElementById('guide-' + tabName);
            if (targetContent) {
                targetContent.classList.add('active');
            }
        }

        // Focus on a specific rotation plane (demo rotation)
        function focusRotation(plane) {
            if (!tesseractMode) return;

            // Reset all rotations
            tesseractRotations = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };

            // Animate the selected rotation plane
            const targetValue = Math.PI / 2;
            const duration = 1000;
            const startTime = Date.now();

            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic

                tesseractRotations[plane] = eased * targetValue;

                // Update slider
                const slider = document.getElementById('rot-' + plane);
                if (slider) {
                    slider.value = (tesseractRotations[plane] * 180 / Math.PI);
                }

                // Update display
                const display = document.getElementById('rot-' + plane + '-val');
                if (display) {
                    display.textContent = Math.round(tesseractRotations[plane] * 180 / Math.PI) + '';
                }

                createTesseract();

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                }
            }

            animateRotation();
        }

        // ===========================================
        // IMMERSIVE TUTORIAL ENGINE
        // ===========================================

        // Start the immersive tutorial
        function startImmersiveTutorial() {
            immersiveTutorialActive = true;
            immersiveTutorialStage = 0;
            waitingForPlayerAction = false;
            playerCompletedAction = false;

            // Disable auto-rotation during tutorial
            autoRotationEnabled = false;

            // Show skip button and stage indicator
            document.getElementById('tutorial-skip').classList.add('active');

            // Begin first stage
            runTutorialStage(0);
        }

        // Run a specific tutorial stage
        function runTutorialStage(stageIndex) {
            if (stageIndex >= IMMERSIVE_STAGES.length) {
                endImmersiveTutorial();
                return;
            }

            const stage = IMMERSIVE_STAGES[stageIndex];
            immersiveTutorialStage = stageIndex;

            // Update stage indicator
            const stageEl = document.getElementById('tutorial-stage');
            stageEl.textContent = stage.stageName;
            stageEl.classList.add('active');

            // Run narration sequence
            runNarrationSequence(stage.narration, () => {
                // After narration, run demo if present
                if (stage.demo) {
                    runTutorialDemo(stage.demo, () => {
                        // After demo, run post-narration if present
                        if (stage.postNarration) {
                            runNarrationSequence(stage.postNarration, () => {
                                handleStageChallenge(stage);
                            });
                        } else {
                            handleStageChallenge(stage);
                        }
                    });
                } else {
                    handleStageChallenge(stage);
                }
            });
        }

        // Handle stage challenge or advance
        function handleStageChallenge(stage) {
            if (stage.challenge) {
                setupChallenge(stage.challenge);
            } else if (stage.final) {
                // Final stage - end tutorial
                setTimeout(() => {
                    endImmersiveTutorial();
                }, stage.delay || 2000);
            } else {
                // No challenge, advance after delay
                setTimeout(() => {
                    advanceToNextStage();
                }, stage.delay || 2000);
            }
        }

        // Run narration sequence (array of lines, typed one by one)
        function runNarrationSequence(lines, onComplete) {
            const narrator = document.getElementById('tesseract-narrator');
            const textEl = document.getElementById('narrator-text');
            narrator.classList.add('active');

            let lineIndex = 0;

            function showNextLine() {
                if (lineIndex >= lines.length) {
                    // All lines shown, wait then hide and call complete
                    setTimeout(() => {
                        narrator.classList.remove('active');
                        if (onComplete) onComplete();
                    }, 1500);
                    return;
                }

                const line = lines[lineIndex];
                typeNarratorText(textEl, line, () => {
                    lineIndex++;
                    // Pause between lines
                    narratorTimeout = setTimeout(showNextLine, 2500);
                });
            }

            showNextLine();
        }

        // Type text character by character (preserves HTML tags)
        function typeNarratorText(element, html, onComplete) {
            // Parse HTML and type visible characters
            element.innerHTML = '';
            let charIndex = 0;
            let inTag = false;
            let currentText = '';

            function typeNext() {
                if (charIndex >= html.length) {
                    element.innerHTML = html;
                    if (onComplete) setTimeout(onComplete, 800);
                    return;
                }

                const char = html[charIndex];

                if (char === '<') {
                    inTag = true;
                }

                currentText += char;

                if (char === '>') {
                    inTag = false;
                }

                element.innerHTML = currentText;
                charIndex++;

                // Type faster through tags, slower through text
                const delay = inTag ? 0 : (char === '.' || char === ',' || char === '') ? 100 : 35;
                narratorTimeout = setTimeout(typeNext, delay);
            }

            typeNext();
        }

        // Run a tutorial demonstration
        function runTutorialDemo(demo, onComplete) {
            tutorialDemoActive = true;

            if (demo.type === 'rotation') {
                // Animate a rotation plane
                const plane = demo.plane;
                const duration = demo.duration || 2000;
                const startTime = Date.now();
                const startValue = tesseractRotations[plane];
                const targetValue = startValue + Math.PI;

                // Show vertex trail hint for 4D rotations
                if (plane.includes('w')) {
                    document.getElementById('vertex-trail-hint').classList.add('active');
                }

                function animateDemo() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2; // Ease in-out

                    tesseractRotations[plane] = startValue + eased * Math.PI;

                    // Update slider
                    const slider = document.getElementById('rot-' + plane);
                    if (slider) {
                        slider.value = (tesseractRotations[plane] * 180 / Math.PI) % 360;
                    }

                    // Update display
                    const display = document.getElementById('rot-' + plane + '-val');
                    if (display) {
                        display.textContent = Math.round(tesseractRotations[plane] * 180 / Math.PI) % 360 + '';
                    }

                    createTesseract();

                    if (progress < 1) {
                        requestAnimationFrame(animateDemo);
                    } else {
                        // Demo complete
                        document.getElementById('vertex-trail-hint').classList.remove('active');
                        tutorialDemoActive = false;
                        if (onComplete) setTimeout(onComplete, 500);
                    }
                }

                animateDemo();
            } else if (demo.type === 'show_w_axis') {
                // Show the W-axis visualization
                document.getElementById('w-axis-hint').classList.add('active');
                setTimeout(() => {
                    tutorialDemoActive = false;
                    if (onComplete) onComplete();
                }, 3000);
            }
        }

        // Setup an interactive challenge
        function setupChallenge(challenge) {
            waitingForPlayerAction = true;
            playerCompletedAction = false;

            const promptEl = document.getElementById('tutorial-prompt');
            const promptText = document.getElementById('tutorial-prompt-text');
            const promptHint = document.getElementById('tutorial-prompt-hint');

            if (challenge.type === 'rotate_xw') {
                promptText.textContent = 'Rotate the XW plane';
                promptHint.innerHTML = 'Use the <kbd>XW</kbd> slider on the right panel';
                promptEl.classList.add('active');

                // Store initial XW value to detect change
                challenge.initialValue = tesseractRotations.xw;

            } else if (challenge.type === 'approach_portal') {
                promptText.textContent = 'Walk toward a portal';
                promptHint.innerHTML = 'Use <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to move. Click to enable mouse look.';
                promptEl.classList.add('active');

            } else if (challenge.type === 'enter_portal') {
                promptText.textContent = 'Enter the portal';
                promptHint.innerHTML = 'Press <kbd>SPACE</kbd> when near a portal';
                promptEl.classList.add('active');
            }
        }

        // Check if player completed current challenge
        function checkChallengeProgress() {
            if (!waitingForPlayerAction || !immersiveTutorialActive) return;

            const stage = IMMERSIVE_STAGES[immersiveTutorialStage];
            if (!stage || !stage.challenge) return;

            const challenge = stage.challenge;

            if (challenge.type === 'rotate_xw') {
                // Check if XW rotation changed significantly
                const currentXW = tesseractRotations.xw * 180 / Math.PI;
                const initialXW = (challenge.initialValue || 0) * 180 / Math.PI;
                if (Math.abs(currentXW - initialXW) >= (challenge.successThreshold || 30)) {
                    challengeCompleted();
                }

            } else if (challenge.type === 'approach_portal') {
                // Check if near a portal
                if (nearbyPortal) {
                    challengeCompleted();
                }

            } else if (challenge.type === 'enter_portal') {
                // This is triggered by enterPortal function
                // We just wait here
            }
        }

        // Called when a challenge is completed
        function challengeCompleted() {
            if (!waitingForPlayerAction) return;

            waitingForPlayerAction = false;
            playerCompletedAction = true;

            // Hide prompt
            document.getElementById('tutorial-prompt').classList.remove('active');

            // Show success feedback
            const successEl = document.getElementById('tutorial-success');
            successEl.classList.add('active');
            setTimeout(() => {
                successEl.classList.remove('active');
            }, 800);

            // Advance to next stage
            setTimeout(() => {
                advanceToNextStage();
            }, 1200);
        }

        // Advance to next tutorial stage
        function advanceToNextStage() {
            immersiveTutorialStage++;

            // Hide current stage indicator briefly
            document.getElementById('tutorial-stage').classList.remove('active');
            document.getElementById('w-axis-hint').classList.remove('active');

            setTimeout(() => {
                runTutorialStage(immersiveTutorialStage);
            }, 500);
        }

        // Skip or end the immersive tutorial
        function skipImmersiveTutorial() {
            endImmersiveTutorial();
        }

        // End the immersive tutorial
        function endImmersiveTutorial() {
            immersiveTutorialActive = false;
            waitingForPlayerAction = false;

            // Clear any pending narration
            if (narratorTimeout) {
                clearTimeout(narratorTimeout);
            }

            // Hide all tutorial UI
            document.getElementById('tesseract-narrator').classList.remove('active');
            document.getElementById('tutorial-stage').classList.remove('active');
            document.getElementById('tutorial-prompt').classList.remove('active');
            document.getElementById('tutorial-skip').classList.remove('active');
            document.getElementById('w-axis-hint').classList.remove('active');
            document.getElementById('vertex-trail-hint').classList.remove('active');

            // Re-enable auto rotation
            autoRotationEnabled = true;

            // Mark tutorial as completed
            markTutorialCompleted();

            console.log('4D Tutorial completed');
        }

        // Hook: called when player enters a portal during tutorial
        function onPortalEnteredDuringTutorial() {
            if (!immersiveTutorialActive) return;

            const stage = IMMERSIVE_STAGES[immersiveTutorialStage];
            if (stage && stage.challenge && stage.challenge.type === 'enter_portal') {
                // Don't call challengeCompleted immediately - let the dimension shift happen first
                setTimeout(() => {
                    challengeCompleted();
                }, 1500);
            }
        }

        // ===========================================
        // v6.82: 4D INTUITION ENGINE
        // Teaching 4D through eureka moments and pattern recognition
        // ===========================================

        // Eureka moment tracking
        const EUREKA_ACHIEVEMENTS = {
            pattern_derived: { unlocked: false, title: 'DIMENSIONAL THINKER', message: 'You see the pattern. Each dimension doubles the vertices.' },
            xw_intuited: { unlocked: false, title: 'HYPERNAUGHT', message: 'You reached for what cannot be reached.' },
            all_rooms_visited: { unlocked: false, title: 'TESSERACT WALKER', message: 'Eight cubes. One hypercube. You walked them all.' },
            shadow_understood: { unlocked: false, title: '4D SCULPTOR', message: 'You shaped the shadow by moving the source.' }
        };

        let visitedRooms = new Set();
        let eurekaPopupTimeout = null;

        // Trigger a eureka moment
        function triggerEureka(eurekaId) {
            const eureka = EUREKA_ACHIEVEMENTS[eurekaId];
            if (!eureka || eureka.unlocked) return;

            eureka.unlocked = true;

            // Flash effect
            const flash = document.getElementById('eureka-flash');
            if (flash) {
                flash.classList.add('active');
                setTimeout(() => flash.classList.remove('active'), 1500);
            }

            // Show popup
            const popup = document.getElementById('eureka-popup');
            const titleEl = document.getElementById('eureka-title');
            const msgEl = document.getElementById('eureka-message');
            const achEl = document.getElementById('eureka-achievement');

            if (popup && titleEl && msgEl && achEl) {
                titleEl.textContent = 'EUREKA';
                msgEl.textContent = eureka.message;
                achEl.textContent = eureka.title;
                popup.classList.add('active');

                if (eurekaPopupTimeout) clearTimeout(eurekaPopupTimeout);
                eurekaPopupTimeout = setTimeout(() => {
                    popup.classList.remove('active');
                }, 5000);
            }

            // Save to localStorage
            try {
                const saved = JSON.parse(localStorage.getItem('leviathan_eurekas') || '{}');
                saved[eurekaId] = true;
                localStorage.setItem('leviathan_eurekas', JSON.stringify(saved));
            } catch (e) {}

            console.log('Eureka unlocked:', eurekaId);
        }

        // Load saved eureka progress
        function loadEurekaProgress() {
            try {
                const saved = JSON.parse(localStorage.getItem('leviathan_eurekas') || '{}');
                Object.keys(saved).forEach(id => {
                    if (EUREKA_ACHIEVEMENTS[id]) {
                        EUREKA_ACHIEVEMENTS[id].unlocked = saved[id];
                    }
                });
            } catch (e) {}
        }

        // Check room visit progress
        function checkRoomVisitProgress(roomIndex) {
            visitedRooms.add(roomIndex);
            if (visitedRooms.size >= 8) {
                triggerEureka('all_rooms_visited');
            }
        }

        // ===========================================
        // DIMENSIONAL LADDER MINIGAME
        // ===========================================

        let ladderActive = false;
        let ladderStep = 0;

        function showDimensionalLadder() {
            ladderActive = true;
            ladderStep = 0;
            const ladder = document.getElementById('dimensional-ladder');
            if (ladder) {
                ladder.classList.add('active');
                animateLadderStep(0);
            }
        }

        function hideDimensionalLadder() {
            ladderActive = false;
            const ladder = document.getElementById('dimensional-ladder');
            if (ladder) ladder.classList.remove('active');
        }

        function animateLadderStep(step) {
            const steps = document.querySelectorAll('.ladder-step');
            steps.forEach((el, i) => {
                el.classList.remove('active', 'completed');
                if (i < step) el.classList.add('completed');
                if (i === step) el.classList.add('active');
            });

            if (step < 4) {
                ladderStep = step;
                setTimeout(() => {
                    if (ladderActive && step < 3) {
                        animateLadderStep(step + 1);
                    } else if (step === 3) {
                        // Show prediction UI
                        document.getElementById('ladder-prediction').style.display = 'block';
                    }
                }, 1500);
            }
        }

        function checkDimensionalPrediction() {
            const verticesInput = document.getElementById('predict-vertices');
            const edgesInput = document.getElementById('predict-edges');

            const vertices = parseInt(verticesInput.value);
            const edges = parseInt(edgesInput.value);

            // Correct answers: 16 vertices, 32 edges
            if (vertices === 16 && edges === 32) {
                // Success!
                triggerEureka('pattern_derived');
                document.getElementById('ladder-4d-stats').innerHTML = '<span>16</span> vertices, <span>32</span> edges';
                document.querySelectorAll('.ladder-step')[4].classList.add('active');
                setTimeout(() => {
                    hideDimensionalLadder();
                }, 2000);
            } else {
                // Give a hint
                if (vertices !== 16) {
                    verticesInput.style.borderColor = '#ff4444';
                    verticesInput.placeholder = 'Pattern: 1248?';
                }
                if (edges !== 32) {
                    edgesInput.style.borderColor = '#ff4444';
                    edgesInput.placeholder = 'Pattern: 01412?';
                }
                setTimeout(() => {
                    verticesInput.style.borderColor = '';
                    edgesInput.style.borderColor = '';
                }, 2000);
            }
        }

        // ===========================================
        // FLATLAND PROLOGUE
        // ===========================================

        let flatlandActive = false;
        let flatlandCtx = null;
        let flatlandPhase = 0;
        let flatlandAnimationFrame = null;
        let sphereY = -100; // Sphere position (Y is depth in 2D)

        function showFlatland() {
            flatlandActive = true;
            flatlandPhase = 0;
            const overlay = document.getElementById('flatland-overlay');
            if (overlay) overlay.classList.add('active');

            const canvas = document.getElementById('flatland-canvas');
            if (canvas) {
                flatlandCtx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                animateFlatland();
                narrateFlatland();
            }
        }

        function hideFlatland() {
            flatlandActive = false;
            const overlay = document.getElementById('flatland-overlay');
            if (overlay) overlay.classList.remove('active');
            if (flatlandAnimationFrame) {
                cancelAnimationFrame(flatlandAnimationFrame);
            }
        }

        function animateFlatland() {
            if (!flatlandActive || !flatlandCtx) return;

            const canvas = flatlandCtx.canvas;
            const ctx = flatlandCtx;
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#0d0520';
            ctx.fillRect(0, 0, w, h);

            // Draw 2D grid (the "flatland")
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < w; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }

            // Draw a 3D sphere passing through 2D plane
            // From a Flatlander's perspective, they see a circle that grows and shrinks
            const sphereRadius = 80;
            const sphereSpeed = 0.5;
            sphereY += sphereSpeed;

            // Calculate the intersection circle radius
            const distFromCenter = Math.abs(sphereY - h/2);
            if (distFromCenter < sphereRadius) {
                const circleRadius = Math.sqrt(sphereRadius * sphereRadius - distFromCenter * distFromCenter);

                // Draw the intersection circle
                ctx.beginPath();
                ctx.arc(w/2, h/2, circleRadius, 0, Math.PI * 2);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Glow effect
                ctx.beginPath();
                ctx.arc(w/2, h/2, circleRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 10;
                ctx.stroke();
            }

            // Reset sphere position
            if (sphereY > h + sphereRadius) {
                sphereY = -sphereRadius;
                flatlandPhase++;
                if (flatlandPhase >= 3) {
                    setTimeout(hideFlatland, 1000);
                    return;
                }
            }

            // Draw the Flatlander (a triangle)
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.moveTo(w/2 - 100, h/2 + 50);
            ctx.lineTo(w/2 - 80, h/2 + 30);
            ctx.lineTo(w/2 - 100, h/2 + 10);
            ctx.closePath();
            ctx.fill();

            flatlandAnimationFrame = requestAnimationFrame(animateFlatland);
        }

        function narrateFlatland() {
            const narrator = document.getElementById('flatland-narrator');
            if (!narrator) return;

            const narrations = [
                "You are a <span class='highlight'>Flatlander</span> - a being of only two dimensions.",
                "A sphere from the 3D world passes through your plane...",
                "To you, it appears as a circle that <span class='highlight'>grows from nothing</span>, then shrinks back to nothing.",
                "The sphere existed the whole time. You just couldn't see it.",
                "This is how <span class='highlight'>you</span> will experience the tesseract."
            ];

            let idx = 0;
            function showNext() {
                if (!flatlandActive || idx >= narrations.length) return;
                narrator.innerHTML = narrations[idx];
                idx++;
                setTimeout(showNext, 4000);
            }
            showNext();
        }

        // Initialize Ana-Kata legend visibility when entering tesseract
        const originalInitTesseractMode = typeof initTesseractMode === 'function' ? initTesseractMode : null;
        if (originalInitTesseractMode) {
            initTesseractMode = function() {
                originalInitTesseractMode();
                showAnaKataLegend();
                loadEurekaProgress();
            };
        }

        // Hook room changes for eureka tracking
        const originalEnterPortal = typeof enterPortal === 'function' ? enterPortal : null;
        if (originalEnterPortal) {
            const wrappedEnterPortal = function(portal) {
                originalEnterPortal(portal);
                if (portal && portal.userData && portal.userData.targetRoom !== undefined) {
                    setTimeout(() => checkRoomVisitProgress(portal.userData.targetRoom), 600);
                }
            };
            enterPortal = wrappedEnterPortal;
        }


        // Legacy function for guide panel button
        function startGuidedTour() {
            // Close guide panel
            if (guideOpen) {
                toggleTesseractGuide();
            }
            // Start immersive tutorial
            startImmersiveTutorial();
        }

        // Legacy functions for old tour overlay (now unused but kept for compatibility)
        function skipTour() {
            document.getElementById('tesseract-tour-overlay').classList.remove('active');
        }

        function nextTourStep() {
            // Redirect to immersive system
            skipTour();
            startImmersiveTutorial();
        }

        // Open glossary modal
        function openTesseractGlossary() {
            document.getElementById('tesseract-glossary').classList.add('active');
        }

        // Close glossary modal
        function closeTesseractGlossary() {
            document.getElementById('tesseract-glossary').classList.remove('active');
        }

        // Update W-coordinate indicator
        function updateWCoordinateIndicator() {
            if (!tesseractMode) return;

            // Calculate average W position based on current rotation state
            const avgW = (
                Math.sin(tesseractRotations.xw) +
                Math.sin(tesseractRotations.yw) +
                Math.sin(tesseractRotations.zw)
            ) / 3;

            // Normalize to -1 to 1 range
            const normalizedW = Math.max(-1, Math.min(1, avgW));

            // Update visual marker position (invert for visual representation)
            const marker = document.getElementById('w-indicator-marker');
            if (marker) {
                const position = 10 + (1 - normalizedW) * 50; // 10% to 90% range
                marker.style.top = position + '%';
            }

            // Update value display
            const valueDisplay = document.getElementById('w-indicator-value');
            if (valueDisplay) {
                valueDisplay.textContent = normalizedW.toFixed(2);
            }
        }

        // Show tesseract guide UI elements when entering tesseract mode
        function showTesseractGuideUI() {
            document.getElementById('tesseract-guide-toggle').classList.add('active');
            document.getElementById('w-coordinate-indicator').classList.add('active');
        }

        // Hide tesseract guide UI elements when exiting tesseract mode
        function hideTesseractGuideUI() {
            document.getElementById('tesseract-guide-toggle').classList.remove('active');
            document.getElementById('tesseract-guide-panel').classList.remove('active');
            document.getElementById('w-coordinate-indicator').classList.remove('active');
            document.getElementById('tesseract-tour-overlay').classList.remove('active');
            document.getElementById('tesseract-glossary').classList.remove('active');

            guideOpen = false;
            tourActive = false;
        }

        // ===========================================
        // END v6.60: THROUGH THE TESSERACT
        // ===========================================

        // Check if camera is approaching black hole (for entry trigger)
        function checkBlackHoleProximity() {
            if (mode !== 'galaxy' || tesseractMode) return;

            const cameraDistToCenter = camera.position.length();

            // If very close to black hole center
            if (cameraDistToCenter < 150) {
                showBlackHoleEntryPrompt();
            }
        }

        // --- PLANET RIDER CAMERA ---
        let planetRiderEnabled = false;
        let riderTargetCiv = null;
        let originalCameraPosition = null;
        let originalCameraLookAt = null;

        function togglePlanetRiderCam() {
            planetRiderEnabled = !planetRiderEnabled;
            const btn = document.getElementById('rider-cam-btn');

            if (planetRiderEnabled) {
                // Find a random non-escaped, non-destroyed planet to ride
                const eligiblePlanets = civilizations.filter(c =>
                    c && c.orbital && !c.orbital.escaped && !c.orbital.destroyed
                );

                if (eligiblePlanets.length === 0) {
                    planetRiderEnabled = false;
                    if (btn) btn.textContent = 'NO PLANETS';
                    setTimeout(() => { if (btn) btn.textContent = 'OFF'; }, 1500);
                    return;
                }

                // Pick a random planet or use the active one
                riderTargetCiv = activeCiv && !activeCiv.orbital?.escaped && !activeCiv.orbital?.destroyed
                    ? activeCiv
                    : eligiblePlanets[Math.floor(Math.random() * eligiblePlanets.length)];

                // Store original camera state
                originalCameraPosition = camera.position.clone();

                if (btn) {
                    btn.textContent = 'RIDING';
                    btn.style.background = 'rgba(0,200,100,0.4)';
                    btn.style.color = '#00ff88';
                }

                console.log(`Planet Rider Camera: Now following ${riderTargetCiv.name}`);
            } else {
                // Return to original view
                if (originalCameraPosition) {
                    camera.position.copy(originalCameraPosition);
                }
                riderTargetCiv = null;

                if (btn) {
                    btn.textContent = 'OFF';
                    btn.style.background = 'rgba(0,100,255,0.3)';
                    btn.style.color = '#00ccff';
                }
            }
        }

        function updatePlanetRiderCamera() {
            if (!planetRiderEnabled || !riderTargetCiv) return;

            // If the planet got destroyed or escaped, find a new one
            if (riderTargetCiv.orbital?.escaped || riderTargetCiv.orbital?.destroyed) {
                const eligiblePlanets = civilizations.filter(c =>
                    c && c.orbital && !c.orbital.escaped && !c.orbital.destroyed
                );
                if (eligiblePlanets.length === 0) {
                    togglePlanetRiderCam(); // Turn off if no planets left
                    return;
                }
                riderTargetCiv = eligiblePlanets[Math.floor(Math.random() * eligiblePlanets.length)];
            }

            // Position camera slightly behind and above the planet, looking toward the black hole
            const planetPos = new THREE.Vector3(riderTargetCiv.x, riderTargetCiv.y, riderTargetCiv.z);

            // Direction from black hole to planet
            const dirFromCenter = planetPos.clone().normalize();

            // Camera offset: behind the planet (opposite direction from center) and slightly above
            const cameraOffset = dirFromCenter.clone().multiplyScalar(80);
            cameraOffset.y += 40;

            // Smooth camera follow
            const targetCamPos = planetPos.clone().add(cameraOffset);
            camera.position.lerp(targetCamPos, 0.05);

            // Look at the black hole center (creating dramatic "approaching doom" view)
            const lookTarget = new THREE.Vector3(0, 0, 0);
            camera.lookAt(lookTarget);
        }

        // ===========================================
        // END v6.32 FEATURES
        // ===========================================

        // ===========================================
        // v6.33: PLANET APPROACH CINEMATIC & AUTO-HIDE SETTINGS
        // ===========================================

        // Auto-hide settings state
        let autoHideSettingsEnabled = true;
        let settingsManuallyHidden = false;

        function toggleAutoHideSettings() {
            autoHideSettingsEnabled = !autoHideSettingsEnabled;
            const btn = document.getElementById('autohide-btn');
            if (btn) {
                btn.textContent = autoHideSettingsEnabled ? 'ON' : 'OFF';
                btn.style.background = autoHideSettingsEnabled ? 'rgba(100,100,100,0.3)' : 'rgba(50,50,50,0.3)';
                btn.style.color = autoHideSettingsEnabled ? '#aaa' : '#666';
            }

            // If turning off auto-hide, show the panel
            if (!autoHideSettingsEnabled) {
                showPhysicsTutorial();
            }
        }

        // Planet approach state
        let planetApproachState = {
            active: false,
            targetCiv: null,
            phase: 'idle', // idle, approaching, orbiting, ready
            orbitAngle: 0,
            orbitRadius: 150,
            approachProgress: 0,
            startCameraPos: null,
            animationFrame: null
        };

        function startPlanetApproach(civ) {
            if (!civ) return;

            // v6.64: Check if planet has been destroyed (collision/black hole)
            if (civ.orbital?.destroyed) {
                showNotification(`${civ.name} has been destroyed! Cannot land.`, 'error');
                AudioSystem.error();
                return;
            }

            // v6.32: Trigger hyperspace jump first (8-agent consensus)
            triggerHyperspaceJump(1800, () => {
                // At midpoint of jump, start the approach sequence
                _beginPlanetApproach(civ);
            });
        }

        // v6.32: Internal function that handles the actual approach (separated for hyperspace integration)
        function _beginPlanetApproach(civ) {
            // v6.64: Check if planet was destroyed during hyperspace jump
            if (!civ || civ.orbital?.destroyed) {
                showNotification(`${civ?.name || 'Target planet'} has been destroyed! Aborting approach.`, 'error');
                AudioSystem.error();
                return;
            }

            // Store target
            planetApproachState.active = true;
            planetApproachState.targetCiv = civ;
            planetApproachState.phase = 'approaching';
            planetApproachState.approachProgress = 0;
            planetApproachState.orbitAngle = 0;
            planetApproachState.startCameraPos = camera.position.clone();

            // v6.65: Hide companion health during planet approach
            const companionHealth = document.getElementById('companion-health-container');
            if (companionHealth) companionHealth.classList.add('hidden');

            // Hide physics tutorial
            if (autoHideSettingsEnabled) {
                hidePhysicsTutorial();
                settingsManuallyHidden = true;
            }

            // Show overlay
            const overlay = document.getElementById('planet-approach-overlay');
            if (overlay) {
                overlay.style.display = 'block';

                // Animate letterbox bars
                setTimeout(() => {
                    document.getElementById('letterbox-top').style.height = '8%';
                    document.getElementById('letterbox-bottom').style.height = '8%';
                }, 100);

                // Show skip button
                setTimeout(() => {
                    document.getElementById('approach-skip').style.opacity = '1';
                }, 500);

                // Show HUD
                setTimeout(() => {
                    const hud = document.getElementById('approach-hud');
                    if (hud) hud.style.opacity = '1';

                    document.getElementById('approach-planet-name').textContent = civ.name;
                    document.getElementById('approach-planet-biome').textContent = `${civ.biomeName} World  Population: ${civ.pop}M`;
                }, 800);
            }

            // Play approach sound
            playApproachSound();

            // Start animation
            animatePlanetApproach();

            console.log(`Starting planet approach to ${civ.name}`);
        }

        function animatePlanetApproach() {
            if (!planetApproachState.active) return;

            const civ = planetApproachState.targetCiv;
            if (!civ) {
                endPlanetApproach();
                return;
            }

            // v6.64: Real-time check if planet was destroyed while approaching/orbiting
            if (civ.orbital?.destroyed) {
                showNotification(`${civ.name} has been destroyed! Aborting approach.`, 'error');
                AudioSystem.error();
                endPlanetApproach();
                return;
            }

            // Get current planet position (it's orbiting!)
            const planetPos = new THREE.Vector3(civ.x, civ.y, civ.z);

            if (planetApproachState.phase === 'approaching') {
                // Phase 1: Fly toward the planet
                planetApproachState.approachProgress += 0.008;

                if (planetApproachState.approachProgress >= 1) {
                    planetApproachState.phase = 'orbiting';
                    planetApproachState.approachProgress = 1;
                }

                // Camera position: lerp from start to orbit position
                const orbitPos = getOrbitCameraPosition(planetPos, planetApproachState.orbitAngle);
                const t = easeInOutCubic(planetApproachState.approachProgress);
                camera.position.lerpVectors(planetApproachState.startCameraPos, orbitPos, t);
                camera.lookAt(planetPos);

                // Update HUD
                const distance = Math.round(camera.position.distanceTo(planetPos) * 10);
                const velocity = Math.round((1 - planetApproachState.approachProgress) * 50 + 5);
                const eta = Math.round((1 - planetApproachState.approachProgress) * 8);
                document.getElementById('approach-distance').textContent = distance.toLocaleString();
                document.getElementById('approach-velocity').textContent = velocity;
                document.getElementById('approach-eta').textContent = eta;

            } else if (planetApproachState.phase === 'orbiting') {
                // Phase 2: Orbit around the planet
                planetApproachState.orbitAngle += 0.008;

                const orbitPos = getOrbitCameraPosition(planetPos, planetApproachState.orbitAngle);
                camera.position.lerp(orbitPos, 0.1);
                camera.lookAt(planetPos);

                // Update HUD with stable values
                document.getElementById('approach-distance').textContent = Math.round(planetApproachState.orbitRadius * 10).toLocaleString();
                document.getElementById('approach-velocity').textContent = '12';
                document.getElementById('approach-eta').textContent = 'STABLE';

                // Show landing prompt after half orbit
                if (planetApproachState.orbitAngle > Math.PI * 0.5) {
                    planetApproachState.phase = 'ready';
                    document.getElementById('approach-land-prompt').style.opacity = '1';
                }
            } else if (planetApproachState.phase === 'ready') {
                // Phase 3: Continue orbiting, waiting for landing
                planetApproachState.orbitAngle += 0.005;

                const orbitPos = getOrbitCameraPosition(planetPos, planetApproachState.orbitAngle);
                camera.position.lerp(orbitPos, 0.05);
                camera.lookAt(planetPos);
            }

            planetApproachState.animationFrame = requestAnimationFrame(animatePlanetApproach);
        }

        function getOrbitCameraPosition(planetPos, angle) {
            const radius = planetApproachState.orbitRadius;
            const height = 60;

            const x = planetPos.x + Math.cos(angle) * radius;
            const y = planetPos.y + height + Math.sin(angle * 0.5) * 20;
            const z = planetPos.z + Math.sin(angle) * radius;

            return new THREE.Vector3(x, y, z);
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function completePlanetApproach() {
            if (!planetApproachState.active) return;

            const civ = planetApproachState.targetCiv;

            // v6.64: Check if planet was destroyed while orbiting
            if (!civ || civ.orbital?.destroyed) {
                showNotification(`${civ?.name || 'Target planet'} has been destroyed! Cannot land.`, 'error');
                AudioSystem.error();
                endPlanetApproach();
                return;
            }

            endPlanetApproach();

            // Start the actual landing sequence
            if (civ) {
                startLandingGame(civ);
            }
        }

        function skipPlanetApproach() {
            if (!planetApproachState.active) return;

            const civ = planetApproachState.targetCiv;

            // v6.64: Check if planet was destroyed while orbiting
            if (!civ || civ.orbital?.destroyed) {
                showNotification(`${civ?.name || 'Target planet'} has been destroyed! Cannot land.`, 'error');
                AudioSystem.error();
                endPlanetApproach();
                return;
            }

            endPlanetApproach();

            // Skip directly to landing
            if (civ) {
                startLandingGame(civ);
            }
        }

        function endPlanetApproach() {
            planetApproachState.active = false;
            planetApproachState.phase = 'idle';

            if (planetApproachState.animationFrame) {
                cancelAnimationFrame(planetApproachState.animationFrame);
                planetApproachState.animationFrame = null;
            }

            // Hide overlay
            const overlay = document.getElementById('planet-approach-overlay');
            if (overlay) {
                // Animate out
                document.getElementById('letterbox-top').style.height = '0';
                document.getElementById('letterbox-bottom').style.height = '0';
                document.getElementById('approach-hud').style.opacity = '0';
                document.getElementById('approach-land-prompt').style.opacity = '0';
                document.getElementById('approach-skip').style.opacity = '0';

                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 800);
            }

            // Restore settings panel visibility if needed
            if (autoHideSettingsEnabled && settingsManuallyHidden) {
                settingsManuallyHidden = false;
            }
        }

        function playApproachSound() {
            try {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                const ctx = AudioSystem.ctx;
                if (ctx.state === 'suspended') ctx.resume();
                const now = ctx.currentTime;

                // Whoosh/descent sound
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 2);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 2);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 2);

                // Engine hum
                const hum = ctx.createOscillator();
                const humGain = ctx.createGain();
                hum.type = 'triangle';
                hum.frequency.setValueAtTime(80, now);
                humGain.gain.setValueAtTime(0.08, now);
                humGain.gain.exponentialRampToValueAtTime(0.02, now + 3);
                hum.connect(humGain);
                humGain.connect(ctx.destination);
                hum.start(now);
                hum.stop(now + 3);

            } catch (e) {
                console.log('Audio not supported');
            }
        }

        // Handle ESC key to skip approach
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && planetApproachState.active) {
                skipPlanetApproach();
            }
        });

        // ===========================================
        // END v6.33 FEATURES
        // ===========================================

        // --- WORLD MODE ---
        function initWorld(civ, skipPropsForMultiplayer = false) {
            activeCiv = civ;
            mode = 'world';

            // v6.65: Show companion health in world mode
            const companionHealth = document.getElementById('companion-health-container');
            if (companionHealth) companionHealth.classList.remove('hidden');
            updateCompanionHealthUI();

            // v6.19: Remove 3D title when entering world
            remove3DTitle();

            // For multiplayer joiners, skip prop generation - props will be synced from host
            const isMultiplayerJoiner = skipPropsForMultiplayer || (multiplayerState.enabled && !multiplayerState.isHost);

            // Mark as visited
            if (!gameData.visitedPlanets.includes(civ.id)) {
                gameData.visitedPlanets.push(civ.id);
                showNotification(`First visit to ${civ.name}!`);
                // v4.1: Check achievements after planet discovery
                checkAchievements();
                updateDailyChallengeProgress();
                // v6.9: Try to discover lore on exploration (Agent consensus - Secrets)
                if (typeof tryDiscoverLore === 'function') {
                    tryDiscoverLore('explore');
                }
            }

            // v4.9: Track biome in codex
            trackBiomeVisit(civ.biome.toLowerCase());

            while(scene.children.length > 0) scene.remove(scene.children[0]);

            // v4.3: Reset boss spawn tracking for new world
            worldMobKillCount = 0;
            bossSpawned = false;

            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 1024;
            worldState.sun.shadow.mapSize.height = 1024;
            scene.add(worldState.sun);

            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.interactables = [];
            worldState.fishingSpots = [];
            worldState.mobs = [];

            // v6.62: HIGH-RESOLUTION TERRAIN using InstancedMesh for performance
            // With 300x300 = 90,000 tiles, individual meshes would be too slow
            // InstancedMesh renders all tiles in ~2 draw calls (ground + water)
            // v6.72: Added Minecraft-style procedural textures
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            const groundMat = MinecraftTextures.createGroundMaterial(biome, civ.biome);
            const waterMat = MinecraftTextures.createWaterMaterial(biome, civ.biome);

            const worldGroup = new THREE.Group();

            // v6.33: Store terrain meshes for terraformer updates
            worldState.terrainMeshes = [];

            // v6.62: Pre-calculate terrain heights and count ground/water tiles
            const terrainData = [];
            let groundCount = 0;
            let waterCount = 0;

            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                worldState.terrainMeshes[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    // Scale noise sampling to maintain same terrain pattern at higher resolution
                    const noiseX = (x / CONFIG.TERRAIN_SCALE) + civ.id;
                    const noiseZ = (z / CONFIG.TERRAIN_SCALE) + civ.id;
                    const hVal = noise(noiseX, noiseZ);
                    const height = Math.floor((hVal + 1) * 3);
                    const realY = height * CONFIG.TILE_SIZE/2;
                    const isWater = height < 1;

                    terrainData.push({ x, z, height, realY, isWater });
                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    if (isWater) waterCount++;
                    else groundCount++;
                }
            }

            // v6.62: Create InstancedMesh for ground tiles (much faster than individual meshes)
            const groundInstanced = new THREE.InstancedMesh(groundGeo, groundMat, groundCount);
            groundInstanced.receiveShadow = true;
            const waterInstanced = new THREE.InstancedMesh(groundGeo, waterMat, waterCount);
            waterInstanced.receiveShadow = true;

            let groundIdx = 0;
            let waterIdx = 0;
            const tempMatrix = new THREE.Matrix4();

            // v6.62: Position all terrain instances
            for (const tile of terrainData) {
                const worldX = (tile.x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const worldZ = (tile.z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;

                tempMatrix.setPosition(worldX, tile.realY, worldZ);

                if (tile.isWater) {
                    waterInstanced.setMatrixAt(waterIdx, tempMatrix);
                    waterIdx++;
                } else {
                    groundInstanced.setMatrixAt(groundIdx, tempMatrix);
                    groundIdx++;
                }

                // Store instance index for terraforming (v6.33 compatibility)
                worldState.terrainMeshes[tile.x][tile.z] = {
                    isWater: tile.isWater,
                    instanceIdx: tile.isWater ? waterIdx - 1 : groundIdx - 1,
                    instanced: tile.isWater ? waterInstanced : groundInstanced,
                    position: new THREE.Vector3(worldX, tile.realY, worldZ)
                };

                // SKIP PROPS for multiplayer joiners - they will be synced from host
                if (!isMultiplayerJoiner) {
                    // v6.64: Fishing spots in water (adjusted for 2x resolution: /4 = same density)
                    if(tile.isWater && rng.next() > 0.9875) { // ~1.25% vs original 5%
                        createFishingSpot(worldX, tile.realY + 1, worldZ);
                    }

                    // v6.64: Trees/Rocks (adjusted for 2x resolution: /4 = same density)
                    // v6.69: Skip spawning near lane paths to keep lanes clear
                    if(!tile.isWater && rng.next() > 0.9625) { // ~3.75% vs original 15%
                        // Check if position is near a lane path (exclusion radius = 10 units)
                        if (typeof isNearLanePath === 'function' && isNearLanePath(worldX, worldZ, 10)) {
                            // Skip - don't spawn trees/rocks on lanes
                        } else {
                            const type = rng.next() > 0.5 ? 'tree' : 'rock';
                            createProp(type, worldX, tile.realY + CONFIG.TILE_SIZE/2, worldZ, biome);
                        }
                    }
                }
            }

            groundInstanced.instanceMatrix.needsUpdate = true;
            waterInstanced.instanceMatrix.needsUpdate = true;
            worldGroup.add(groundInstanced);
            worldGroup.add(waterInstanced);

            // Store references for terraforming updates
            worldState.groundInstanced = groundInstanced;
            worldState.waterInstanced = waterInstanced;

            scene.add(worldGroup);

            // Log for debugging multiplayer sync
            if (isMultiplayerJoiner) {
                console.log('Multiplayer joiner: Terrain generated, waiting for props sync from host');
            }

            // v6.62: Function to update terrain mesh positions after terraforming (InstancedMesh version)
            const _updateMatrix = new THREE.Matrix4();
            worldState.updateTerrainMeshes = function(centerX, centerZ, radius) {
                if (!worldState.terrainMeshes || !worldState.groundInstanced) return;

                let needsGroundUpdate = false;
                let needsWaterUpdate = false;

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const tx = centerX + dx;
                        const tz = centerZ + dz;

                        if (tx >= 0 && tx < CONFIG.WORLD_SIZE && tz >= 0 && tz < CONFIG.WORLD_SIZE) {
                            const tileData = worldState.terrainMeshes[tx]?.[tz];
                            const terrainHeight = worldState.terrain[tx]?.[tz];

                            if (tileData && terrainHeight !== undefined && terrainHeight > 0) {
                                // Update the instance matrix position
                                const targetY = terrainHeight - CONFIG.TILE_SIZE / 2;
                                _updateMatrix.setPosition(tileData.position.x, targetY, tileData.position.z);
                                tileData.position.y = targetY;

                                if (tileData.isWater) {
                                    worldState.waterInstanced.setMatrixAt(tileData.instanceIdx, _updateMatrix);
                                    needsWaterUpdate = true;
                                } else {
                                    worldState.groundInstanced.setMatrixAt(tileData.instanceIdx, _updateMatrix);
                                    needsGroundUpdate = true;
                                }
                            }
                        }
                    }
                }

                // Only flag updates if changes were made
                if (needsGroundUpdate) worldState.groundInstanced.instanceMatrix.needsUpdate = true;
                if (needsWaterUpdate) worldState.waterInstanced.instanceMatrix.needsUpdate = true;
            };

            // v5.15: ANIMATED FRIENDLY EXPLORER ROBOT - Full skeletal animation system
            const playerGroup = new THREE.Group();

            // Materials - soft, friendly colors
            // v6.53: Added emissive for visibility in dark biomes (Xeno night)
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0xe8e8f0,  // Soft white/light gray
                metalness: 0.4,
                roughness: 0.6,
                emissive: 0x4488aa,  // Soft cyan glow for visibility
                emissiveIntensity: 0.15
            });
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0x4a9fff,  // Friendly blue
                metalness: 0.5,
                roughness: 0.4,
                emissive: 0x2266aa,  // v6.53: Blue glow for dark visibility
                emissiveIntensity: 0.2
            });
            const faceMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a3a,  // Dark face plate
                metalness: 0.3,
                roughness: 0.5
            });

            // === HIERARCHICAL BONE STRUCTURE FOR ANIMATION ===
            // Body core (pivot for whole body bob)
            const bodyCore = new THREE.Group();
            bodyCore.position.y = 0.75;
            playerGroup.add(bodyCore);

            // === TORSO attached to body core ===
            const torsoGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.6, 16);
            const torso = new THREE.Mesh(torsoGeo, bodyMat);
            torso.position.y = 0.4;
            torso.castShadow = true;
            bodyCore.add(torso);

            // Hip section
            const hipGeo = new THREE.CylinderGeometry(0.4, 0.35, 0.3, 16);
            const hip = new THREE.Mesh(hipGeo, bodyMat);
            hip.position.y = 0;
            hip.castShadow = true;
            bodyCore.add(hip);

            // Chest accent panel
            const chestGeo = new THREE.BoxGeometry(0.3, 0.25, 0.08);
            const chest = new THREE.Mesh(chestGeo, accentMat);
            chest.position.set(0, 0.45, 0.35);
            bodyCore.add(chest);

            // Chest light/heart (status indicator)
            const heartGeo = new THREE.SphereGeometry(0.08, 12, 12);
            const heartMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.position.set(0, 0.45, 0.4);
            bodyCore.add(heart);
            playerGroup.userData.statusStrip = heart;

            // Backpack
            const backpackGeo = new THREE.BoxGeometry(0.3, 0.35, 0.15);
            const backpack = new THREE.Mesh(backpackGeo, accentMat);
            backpack.position.set(0, 0.35, -0.35);
            backpack.castShadow = true;
            bodyCore.add(backpack);

            // === HEAD GROUP (pivots for look/nod animations) ===
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0.95, 0);  // Neck position relative to body core
            bodyCore.add(headGroup);

            // Main head sphere
            const headGeo = new THREE.SphereGeometry(0.45, 24, 24);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 0;
            head.scale.set(1, 0.9, 0.95);
            head.castShadow = true;
            headGroup.add(head);

            // Face plate
            const faceGeo = new THREE.SphereGeometry(0.42, 24, 12, 0, Math.PI, 0, Math.PI * 0.6);
            const face = new THREE.Mesh(faceGeo, faceMat);
            face.position.set(0, -0.02, 0.08);
            face.rotation.x = -0.3;
            headGroup.add(face);

            // Friendly eyes
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshStandardMaterial({
                color: 0x00ddff,
                emissive: 0x00ddff,
                emissiveIntensity: 0.9
            });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, 0.02, 0.35);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, 0.02, 0.35);
            headGroup.add(rightEye);
            playerGroup.userData.robotEye = rightEye;
            playerGroup.userData.leftEye = leftEye;

            // Eye pupils
            const pupilGeo = new THREE.SphereGeometry(0.05, 12, 12);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000022 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.15, 0.02, 0.44);
            headGroup.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.15, 0.02, 0.44);
            headGroup.add(rightPupil);
            playerGroup.userData.leftPupil = leftPupil;
            playerGroup.userData.rightPupil = rightPupil;

            // Eyebrow accent lights
            const browGeo = new THREE.BoxGeometry(0.08, 0.02, 0.02);
            const browMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });
            const leftBrow = new THREE.Mesh(browGeo, browMat);
            leftBrow.position.set(-0.15, 0.18, 0.32);
            leftBrow.rotation.z = 0.2;
            headGroup.add(leftBrow);
            const rightBrow = new THREE.Mesh(browGeo, browMat);
            rightBrow.position.set(0.15, 0.18, 0.32);
            rightBrow.rotation.z = -0.2;
            headGroup.add(rightBrow);
            playerGroup.userData.leftBrow = leftBrow;
            playerGroup.userData.rightBrow = rightBrow;

            // Antenna
            const antennaGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8);
            const antenna = new THREE.Mesh(antennaGeo, accentMat);
            antenna.position.set(0, 0.5, -0.1);
            headGroup.add(antenna);
            playerGroup.userData.antenna = antenna;

            // Antenna ball
            const antBallGeo = new THREE.SphereGeometry(0.06, 12, 12);
            const antBallMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            const antBall = new THREE.Mesh(antBallGeo, antBallMat);
            antBall.position.set(0, 0.65, -0.1);
            headGroup.add(antBall);
            playerGroup.userData.antennaLight = antBall;

            // === ARM GROUPS (hierarchical for proper joint rotation) ===
            const armData = { left: {}, right: {} };
            [-1, 1].forEach(side => {
                const sideName = side === -1 ? 'left' : 'right';

                // Upper arm group (pivots at shoulder)
                const upperArmGroup = new THREE.Group();
                upperArmGroup.position.set(side * 0.48, 0.55, 0);  // Shoulder position
                bodyCore.add(upperArmGroup);

                // Shoulder ball
                const shoulderGeo = new THREE.SphereGeometry(0.12, 12, 12);
                const shoulder = new THREE.Mesh(shoulderGeo, accentMat);
                shoulder.position.set(0, 0, 0);
                upperArmGroup.add(shoulder);

                // Upper arm
                const upperArmGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.35, 12);
                const upperArm = new THREE.Mesh(upperArmGeo, bodyMat);
                upperArm.position.set(0, -0.2, 0);
                upperArm.castShadow = true;
                upperArmGroup.add(upperArm);

                // Lower arm group (pivots at elbow)
                const lowerArmGroup = new THREE.Group();
                lowerArmGroup.position.set(0, -0.4, 0);  // Elbow position relative to upper arm
                upperArmGroup.add(lowerArmGroup);

                // Elbow joint
                const elbowGeo = new THREE.SphereGeometry(0.08, 10, 10);
                const elbow = new THREE.Mesh(elbowGeo, accentMat);
                elbow.position.set(0, 0, 0);
                lowerArmGroup.add(elbow);

                // Lower arm
                const lowerArmGeo = new THREE.CylinderGeometry(0.06, 0.07, 0.3, 12);
                const lowerArm = new THREE.Mesh(lowerArmGeo, bodyMat);
                lowerArm.position.set(0, -0.18, 0);
                lowerArm.castShadow = true;
                lowerArmGroup.add(lowerArm);

                // Hand
                const handGeo = new THREE.SphereGeometry(0.09, 12, 12);
                const hand = new THREE.Mesh(handGeo, accentMat);
                hand.position.set(0, -0.35, 0);
                hand.scale.set(1, 0.8, 1.2);
                lowerArmGroup.add(hand);

                armData[sideName] = { upperGroup: upperArmGroup, lowerGroup: lowerArmGroup };
            });

            // === LEG GROUPS (hierarchical for walking animation) ===
            const legData = { left: {}, right: {} };
            [-1, 1].forEach(side => {
                const sideName = side === -1 ? 'left' : 'right';

                // Upper leg group (pivots at hip)
                const upperLegGroup = new THREE.Group();
                upperLegGroup.position.set(side * 0.18, -0.17, 0);  // Hip joint position
                bodyCore.add(upperLegGroup);

                // Hip joint
                const hipJointGeo = new THREE.SphereGeometry(0.1, 10, 10);
                const hipJoint = new THREE.Mesh(hipJointGeo, accentMat);
                hipJoint.position.set(0, 0, 0);
                upperLegGroup.add(hipJoint);

                // Upper leg
                const upperLegGeo = new THREE.CylinderGeometry(0.1, 0.09, 0.3, 12);
                const upperLeg = new THREE.Mesh(upperLegGeo, bodyMat);
                upperLeg.position.set(0, -0.18, 0);
                upperLeg.castShadow = true;
                upperLegGroup.add(upperLeg);

                // Lower leg group (pivots at knee)
                const lowerLegGroup = new THREE.Group();
                lowerLegGroup.position.set(0, -0.34, 0);  // Knee position relative to upper leg
                upperLegGroup.add(lowerLegGroup);

                // Knee joint
                const kneeGeo = new THREE.SphereGeometry(0.09, 10, 10);
                const knee = new THREE.Mesh(kneeGeo, accentMat);
                knee.position.set(0, 0, 0);
                lowerLegGroup.add(knee);

                // Lower leg
                const lowerLegGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.25, 12);
                const lowerLeg = new THREE.Mesh(lowerLegGeo, bodyMat);
                lowerLeg.position.set(0, -0.14, 0);
                lowerLeg.castShadow = true;
                lowerLegGroup.add(lowerLeg);

                // Foot
                const footGeo = new THREE.BoxGeometry(0.14, 0.06, 0.22);
                const footMat = new THREE.MeshStandardMaterial({
                    color: 0x3a3a4a,
                    metalness: 0.5,
                    roughness: 0.6
                });
                const foot = new THREE.Mesh(footGeo, footMat);
                foot.position.set(0, -0.27, 0.04);
                foot.castShadow = true;
                lowerLegGroup.add(foot);

                legData[sideName] = { upperGroup: upperLegGroup, lowerGroup: lowerLegGroup };
            });

            // === ANIMATION STATE SYSTEM ===
            // v6.81: Added swimming state and swimPhase
            // v6.90: Added comprehensive ability casting animations
            playerGroup.userData.animation = {
                state: 'idle',        // idle, walking, running, jumping, attacking, waving, damage, swimming, casting
                prevState: 'idle',
                stateTime: 0,         // Time in current state
                blendTime: 0,         // For smooth state transitions
                walkCycle: 0,         // Walk cycle phase (0 to 2*PI)
                blinkTimer: 0,        // For random blinks
                nextBlink: 2000 + Math.random() * 3000,
                isBlinking: false,
                lookTarget: null,     // Optional look-at target
                headBob: 0,           // Head bob phase
                breathPhase: 0,       // Breathing animation phase
                jumpPhase: 0,         // Jump animation phase
                attackPhase: 0,       // Attack animation phase
                wavePhase: 0,         // Wave animation phase
                damageFlash: 0,       // Damage flash timer
                idleVariation: 0,     // For idle animation variations
                speedMultiplier: 1,   // Animation speed
                swimPhase: 0,         // v6.81: Swimming stroke cycle
                isSwimming: false,    // v6.81: Currently in water/lava
                swimBob: 0,           // v6.81: Vertical bob while swimming
                // v6.90: Ability casting animation phases
                castPhase: 0,         // Current casting animation progress (0-1)
                castType: null,       // Type of ability being cast
                castIntensity: 0,     // Intensity of cast effect (for glow)
                spinPhase: 0,         // Whirlwind spin rotation
                chargePhase: 0,       // Power-up/charge animation
                recoilPhase: 0,       // Post-cast recoil
                armExtendL: 0,        // Left arm extension override
                armExtendR: 0,        // Right arm extension override
                bodyTwist: 0,         // Body twist for directional casts
                castGlow: 0           // Emissive glow intensity during cast
            };

            // Store bone references for animation
            playerGroup.userData.bones = {
                bodyCore: bodyCore,
                headGroup: headGroup,
                leftArm: armData.left,
                rightArm: armData.right,
                leftLeg: legData.left,
                rightLeg: legData.right
            };

            worldState.player = playerGroup;

            // v6.68: Calculate ship landing spot (fountain/base) for player spawn
            // This is the same calculation used later for createWorldShip
            const shipSpawnX = (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
            const shipSpawnZ = (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
            const lxSpawn = Math.floor(CONFIG.WORLD_SIZE / 4);
            const lzSpawn = Math.floor(CONFIG.WORLD_SIZE / 4);
            let shipSpawnY = 10;
            if (worldState.terrain[lxSpawn] && worldState.terrain[lxSpawn][lzSpawn] !== undefined) {
                shipSpawnY = worldState.terrain[lxSpawn][lzSpawn] > 0 ? worldState.terrain[lxSpawn][lzSpawn] + 1 : 6;
            }

            // v6.18: Restore saved position if returning to same planet
            if (gameData.player.lastPlanetId === civ.id && gameData.player.lastPosition) {
                const pos = gameData.player.lastPosition;
                worldState.player.position.set(pos.x, pos.y, pos.z);
                if (gameData.player.lastRotation !== null) {
                    worldState.player.rotation.y = gameData.player.lastRotation;
                }
                showNotification('Resumed from last position', 'info');
            } else {
                // v6.68: Spawn player at ship/fountain location instead of (0,0,0)
                worldState.player.position.set(shipSpawnX, shipSpawnY, shipSpawnZ);
                showNotification('Landed at your ship!', 'info');
            }

            worldState.player.userData.isRobot = true;

            // v6.53: Add point light to local player for visibility in dark biomes
            const playerLight = new THREE.PointLight(0x88ccff, 0.8, 8);
            playerLight.position.y = 1.5;
            worldState.player.add(playerLight);
            worldState.player.userData.light = playerLight;

            // Selection/highlight ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(1.0, 1.2, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0.05;
            worldState.player.add(ring);

            scene.add(worldState.player);

            // v6.68: Create Dota 2-style HP and Mana bars above player
            createPlayerHealthBars(worldState.player);

            // Mobs
            const mobCount = 5 + Math.floor(rng.next() * 5);
            for(let i=0; i<mobCount; i++) {
                createMob(rng, biome);
            }

            // v4.2: Generate POIs based on biome
            worldState.pois = [];
            const biomeKey = civ.biome;
            for (const [poiType, poiData] of Object.entries(POI_TYPES)) {
                // Check if POI can spawn in this biome
                if (poiData.biomes && !poiData.biomes.includes(biomeKey)) continue;

                // Check rarity
                if (rng.next() < poiData.rarity) {
                    // Check if already discovered on this planet
                    const alreadyDiscovered = gameData.discoveredPOIs[civ.id]?.includes(poiType);
                    createPOI(rng, biome, poiType, poiData);
                    // Mark pre-discovered POIs
                    if (alreadyDiscovered && worldState.pois.length > 0) {
                        const poi = worldState.pois[worldState.pois.length - 1];
                        poi.userData.discovered = true;
                        if (poi.userData.beacon) poi.userData.beacon.material.emissiveIntensity = 0.1;
                        if (poi.userData.iconMesh) poi.userData.iconMesh.material.opacity = 0.3;
                    }
                }
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            // v6.99: Show navigation buttons (now in RTS panel toggles)
            document.getElementById('nav-galaxy').style.display = 'flex';
            document.getElementById('nav-surfaces').style.display = 'flex';
            document.querySelector('.rts-divider').style.display = 'block';
            document.getElementById('world-name').textContent = civ.biomeName;
            document.getElementById('rpg-ui').style.display = 'flex';
            // v6.72: Removed duplicate player-health-bar - using Dota-style HP/MP bars only
            document.getElementById('minimap-container').style.display = 'block';
            document.getElementById('ability-bar').style.display = 'block';
            document.getElementById('player-dota-bars-ui').style.display = 'block'; // v6.69: Show Dota-style HP/Mana bars
            document.getElementById('environment-widget').style.display = 'block'; // v6.70: Show unified environment widget
            document.getElementById('style-meter').style.display = 'block'; // v6.9: Show style meter
            document.getElementById('ai-behavior-panel').style.display = 'block'; // v6.81: Show AI behavior panel
            updateAbilityUI();
            updateWeatherUI();
            updateTimeUI(); // v6.1: Update time display

            // v4.3: Start biome ambient audio
            AudioSystem.startAmbient(civ.biome);

            // v5.0: Spawn pet companion
            initPetSystem();
            updatePetMesh();

            // v5.6: Initialize and spawn Copilot Companion
            initCopilotCompanion();
            createCopilotMesh();

            // v6.65: Initialize DOTA-style creep lane system
            initCreepLaneSystem();

            // v5.12: Initialize hypnosis effects
            initHypnosisEffects();

            // v5.13: Create ship and landing zone
            const landingSpot = new THREE.Vector3(
                (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE,
                10,
                (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE
            );
            // Find ground height at landing spot
            const lx = Math.floor(CONFIG.WORLD_SIZE / 4);
            const lz = Math.floor(CONFIG.WORLD_SIZE / 4);
            if (worldState.terrain[lx] && worldState.terrain[lx][lz] !== undefined) {
                landingSpot.y = worldState.terrain[lx][lz] > 0 ? worldState.terrain[lx][lz] : 5;
            }
            const landingPad = createLandingZone(landingSpot);
            scene.add(landingPad);
            const ship = createWorldShip(landingSpot);
            scene.add(ship);
            SHIP_STATE.hp = SHIP_STATE.maxHp;  // Reset ship HP for new world
            updateShipHPUI();
            document.getElementById('ship-status').style.display = 'block';

            // v5.0: Initialize weather system
            initWeatherSystem();

            // v6.1: Initialize critical systems (emergent world events)
            initCriticalSystems();

            // v5.4: Initialize new systems
            initPetEvolutionSystem();
            initWorldEventSystem();
            initAchievementShowcase();

            // v6.52: Initialize new mind-blowing systems (8-agent consensus)
            if (typeof temporalRewind !== 'undefined') {
                temporalRewind.init();
            }
            if (typeof quantumWreckage !== 'undefined') {
                quantumWreckage.init();
                quantumWreckage.renderToScene(scene);
            }

            // v6.38: Render temporal echo markers for this planet
            if (typeof temporalEchoSystem !== 'undefined') {
                temporalEchoSystem.renderAllEchoMarkers();
            }

            // v6.13: Initialize wave momentum system (DOTA-style creep pushing)
            if (typeof initWaveSystem === 'function') {
                initWaveSystem();
            }

            // v6.66: Initialize RCT-style base building system
            if (typeof initBaseBuildingSystem === 'function') {
                initBaseBuildingSystem();
            }

            // v6.67: Initialize lane support & fortification system
            if (typeof initLaneSupportSystem === 'function') {
                initLaneSupportSystem();
                // Spawn initial lane towers after a short delay
                setTimeout(() => {
                    if (typeof spawnInitialLaneTowers === 'function') {
                        spawnInitialLaneTowers();
                    }
                }, 2000);
            }

            // v6.83: Initialize NPC Memory System update loop
            if (typeof NPC_MEMORY_SYSTEM !== 'undefined') {
                // Clear any existing interval
                if (window.npcMemoryInterval) clearInterval(window.npcMemoryInterval);

                // Update memory decay and gossip every 30 seconds (game time ~30 minutes)
                window.npcMemoryInterval = setInterval(() => {
                    const deltaGameDays = 0.02; // ~30 min of game time per tick

                    // Decay memories
                    if (typeof updateMemoryDecay === 'function') {
                        updateMemoryDecay(deltaGameDays);
                    }

                    // Propagate gossip
                    if (typeof propagateGossip === 'function') {
                        propagateGossip();
                    }

                    // Save memory state periodically
                    if (typeof saveNPCMemories === 'function') {
                        saveNPCMemories();
                    }
                }, 30000);

                // Load saved memories on world entry
                if (typeof loadNPCMemories === 'function') {
                    loadNPCMemories();
                }
            }

            // v4.4: Start environmental particles
            if (envParticles) envParticles.startBiome(civ.biome);

            // v6.32: Start adaptive combat music system (8-agent consensus)
            AudioSystem.startCombatMusic();

            worldState.target = null;
            worldState.interactTarget = null;

            // v6.34: Restore dropped items from previous visits
            restoreDroppedItemsForPlanet(civ.id);

            // v6.97: Restore planet surface state (structures, terraformed areas)
            if (typeof loadPlanetSurface === 'function') {
                loadPlanetSurface(civ.id);
            }

            // v6.35: Hide settings toggle button in world mode
            updateSettingsToggleVisibility();

            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();
            updateCraftingUI();
            initMinimap();
        }

        // ========== L-SYSTEM PROCEDURAL FOREST GENERATOR ==========
        // v6.44: Mind-blowing procedurally generated vegetation using recursive grammar
        const L_SYSTEM_GRAMMARS = {
            // Terra: Classic branching trees (oak-like)
            Terra: {
                axiom: 'X',
                rules: {
                    'X': 'F[+X][-X]FX',
                    'F': 'FF'
                },
                iterations: 4,
                angle: 25,
                lengthScale: 0.7,
                trunkColor: 0x553311,
                leafColor: 0x228b22,
                leafShape: 'sphere',
                names: ['Ancient Oak', 'Whispering Willow', 'Emerald Pine', 'Forest Giant']
            },
            // Desert: Sparse, twisted cacti/dead trees
            Desert: {
                axiom: 'X',
                rules: {
                    'X': 'F[+X]F[-X]+X',
                    'F': 'F'
                },
                iterations: 3,
                angle: 35,
                lengthScale: 0.65,
                trunkColor: 0x8B7355,
                leafColor: 0xccbb99,
                leafShape: 'spike',
                names: ['Sand Cactus', 'Desert Sentinel', 'Dune Spine', 'Arid Bone-Tree']
            },
            // Ice: Crystalline fractal growths
            Ice: {
                axiom: 'F',
                rules: {
                    'F': 'F[+F]F[-F][F]'
                },
                iterations: 3,
                angle: 60,
                lengthScale: 0.5,
                trunkColor: 0x88aacc,
                leafColor: 0xaaddff,
                leafShape: 'crystal',
                names: ['Frost Crystal', 'Ice Spire', 'Frozen Prism', 'Glacial Needle']
            },
            // Alien: Spiraling bioluminescent tendrils
            Alien: {
                axiom: 'A',
                rules: {
                    'A': 'F[++A][--A]FA',
                    'F': 'FGF'
                },
                iterations: 4,
                angle: 22.5,
                lengthScale: 0.72,
                trunkColor: 0x8800ff,
                leafColor: 0xff00ff,
                leafShape: 'tendril',
                glowing: true,
                names: ['Void Tendril', 'Xeno Spiral', 'Psionic Bloom', 'Neural Vine']
            },
            // Volcanic: Charred, ember-tipped branches
            Volcanic: {
                axiom: 'X',
                rules: {
                    'X': 'F[-X][+X]',
                    'F': 'FGF'
                },
                iterations: 3,
                angle: 30,
                lengthScale: 0.6,
                trunkColor: 0x222222,
                leafColor: 0xff4400,
                leafShape: 'ember',
                names: ['Ash Husk', 'Ember Branch', 'Charred Spine', 'Magma Root']
            }
        };

        // L-System string generator
        function generateLSystemString(grammar, iterations) {
            let current = grammar.axiom;
            for (let i = 0; i < iterations; i++) {
                let next = '';
                for (const char of current) {
                    next += grammar.rules[char] || char;
                }
                current = next;
                // Limit string length for performance
                if (current.length > 500) break;
            }
            return current;
        }

        // Convert L-System string to 3D mesh
        function createLSystemTree(biomeName, seed = Math.random()) {
            const biomeData = BIOMES[biomeName] || BIOMES.Terra;
            const grammar = L_SYSTEM_GRAMMARS[biomeName] || L_SYSTEM_GRAMMARS.Terra;

            // Use seed for deterministic variation
            const rng = new SeededRNG(seed * 10000);
            const variation = rng.next();

            // Generate L-System string with slight variation in iterations
            const iterations = grammar.iterations + (variation > 0.8 ? 1 : 0) - (variation < 0.2 ? 1 : 0);
            const lString = generateLSystemString(grammar, Math.max(1, iterations));

            const group = new THREE.Group();

            // Turtle graphics state
            const stack = [];
            let pos = new THREE.Vector3(0, 0, 0);
            let dir = new THREE.Vector3(0, 1, 0);
            let right = new THREE.Vector3(1, 0, 0);

            const baseLength = 0.4 + variation * 0.3;
            let currentLength = baseLength;
            let currentThickness = 0.15 + variation * 0.1;
            const angle = (grammar.angle + (rng.next() - 0.5) * 10) * Math.PI / 180;

            // Materials - v6.72: Minecraft-style procedural textures
            const trunkMat = MinecraftTextures.createWoodMaterial(grammar.trunkColor, seed);
            const leafMat = grammar.glowing
                ? new THREE.MeshBasicMaterial({ color: grammar.leafColor })
                : MinecraftTextures.createLeafMaterial(grammar.leafColor, seed + 1000);

            // Track branch endpoints for leaves
            const branchEnds = [];
            let segmentCount = 0;
            const maxSegments = 60; // Performance limit

            // Interpret L-System string
            for (const char of lString) {
                if (segmentCount >= maxSegments) break;

                switch (char) {
                    case 'F': // Draw forward
                    case 'G': // Draw forward (alternate)
                        const endPos = pos.clone().add(dir.clone().multiplyScalar(currentLength));

                        // Create branch segment
                        const branchGeo = new THREE.CylinderGeometry(
                            currentThickness * 0.7,
                            currentThickness,
                            currentLength,
                            6
                        );
                        const branch = new THREE.Mesh(branchGeo, trunkMat);

                        // Position and orient branch
                        branch.position.copy(pos).add(dir.clone().multiplyScalar(currentLength / 2));
                        branch.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
                        branch.castShadow = true;
                        group.add(branch);

                        pos = endPos;
                        currentThickness *= 0.85;
                        segmentCount++;
                        break;

                    case '+': // Rotate right (yaw)
                        dir.applyAxisAngle(right, -angle);
                        break;

                    case '-': // Rotate left (yaw)
                        dir.applyAxisAngle(right, angle);
                        break;

                    case '[': // Push state (start branch)
                        stack.push({
                            pos: pos.clone(),
                            dir: dir.clone(),
                            right: right.clone(),
                            length: currentLength,
                            thickness: currentThickness
                        });
                        currentLength *= grammar.lengthScale;
                        break;

                    case ']': // Pop state (end branch) - add leaf
                        branchEnds.push(pos.clone());
                        if (stack.length > 0) {
                            const state = stack.pop();
                            pos = state.pos;
                            dir = state.dir;
                            right = state.right;
                            currentLength = state.length;
                            currentThickness = state.thickness;
                        }
                        break;

                    case 'X': // Growth point marker (used in rules)
                    case 'A': // Alternate growth marker
                        // These are just placeholders for rule expansion
                        break;
                }
            }

            // Add terminal leaves at branch ends
            branchEnds.forEach((endPos, i) => {
                if (i > 20) return; // Limit leaves for performance

                let leafGeo;
                const leafScale = 0.3 + rng.next() * 0.4;

                switch (grammar.leafShape) {
                    case 'crystal':
                        leafGeo = new THREE.OctahedronGeometry(leafScale);
                        break;
                    case 'spike':
                        leafGeo = new THREE.ConeGeometry(leafScale * 0.3, leafScale * 1.5, 5);
                        break;
                    case 'tendril':
                        leafGeo = new THREE.SphereGeometry(leafScale * 0.5, 8, 4);
                        break;
                    case 'ember':
                        leafGeo = new THREE.TetrahedronGeometry(leafScale * 0.6);
                        break;
                    case 'sphere':
                    default:
                        leafGeo = new THREE.SphereGeometry(leafScale, 6, 4);
                }

                const leaf = new THREE.Mesh(leafGeo, leafMat);
                leaf.position.copy(endPos);
                leaf.rotation.set(rng.next() * Math.PI, rng.next() * Math.PI, rng.next() * Math.PI);
                leaf.castShadow = true;
                group.add(leaf);
            });

            // v6.65: Removed per-tree PointLights - they caused "too many uniforms" shader errors
            // The MeshBasicMaterial with bright colors already provides the glowing visual effect

            // Scale the whole tree
            const scale = 0.8 + rng.next() * 0.6;
            group.scale.setScalar(scale);

            // Pick a procedural name
            const name = grammar.names[Math.floor(rng.next() * grammar.names.length)];
            group.userData = {
                type: 'tree',
                hp: 3,
                maxHp: 3,
                name: name,
                lSystem: true,
                biomeName: biomeName
            };

            return group;
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                // v6.70: L-system dominant with occasional variety - biome-specific distribution
                const biomeName = Object.keys(BIOMES).find(k => BIOMES[k] === biome) || 'Terra';
                const seed = x * 1000 + z; // Deterministic seed based on position
                const rng = { next: () => ((seed * 9301 + 49297) % 233280) / 233280 };

                // Biome-specific distribution: L-system PRIMARY, others as accent variety
                // Thresholds: [L-system, round, pine, bushy, tall] - cumulative
                // E.g. [0.70, 0.80, 0.86, 0.93, 1.0] = 70% L-sys, 10% round, 6% pine, 7% bushy, 7% tall
                const BIOME_TREE_DIST = {
                    Terra:    [0.70, 0.80, 0.86, 0.93, 1.0],  // 70% L-sys, balanced variety
                    Desert:   [0.85, 0.90, 0.92, 0.95, 1.0],  // 85% L-sys, sparse variety
                    Ice:      [0.50, 0.55, 0.85, 0.92, 1.0],  // 50% L-sys, 30% pine (fits snowy biome)
                    Volcanic: [0.80, 0.88, 0.92, 0.96, 1.0],  // 80% L-sys, sparse twisted trees
                    Alien:    [0.65, 0.75, 0.80, 0.90, 1.0],  // 65% L-sys, more variety for alien world
                    Ocean:    [0.75, 0.82, 0.87, 0.94, 1.0],  // 75% L-sys, kelp-like variety
                    Swamp:    [0.60, 0.70, 0.75, 0.90, 1.0],  // 60% L-sys, more bushy mangroves
                    Crystal:  [0.55, 0.68, 0.78, 0.88, 1.0]   // 55% L-sys, more geometric variety
                };
                const dist = BIOME_TREE_DIST[biomeName] || BIOME_TREE_DIST.Terra;
                const roll = rng.next();
                let treeStyle = 0; // Default to L-system
                for (let i = 0; i < dist.length; i++) {
                    if (roll < dist[i]) { treeStyle = i; break; }
                }

                // Biome-specific colors
                const TREE_COLORS = {
                    Terra: { trunk: 0x8B4513, leaf: 0x228B22, leafAlt: 0x2E8B57 },
                    Desert: { trunk: 0xA0522D, leaf: 0x9ACD32, leafAlt: 0x6B8E23 },
                    Ice: { trunk: 0x708090, leaf: 0x87CEEB, leafAlt: 0xADD8E6 },
                    Volcanic: { trunk: 0x2F2F2F, leaf: 0xFF4500, leafAlt: 0xFF6347 },
                    Alien: { trunk: 0x8B008B, leaf: 0xFF00FF, leafAlt: 0x9400D3 },
                    Ocean: { trunk: 0x5F9EA0, leaf: 0x00CED1, leafAlt: 0x20B2AA },
                    Swamp: { trunk: 0x556B2F, leaf: 0x6B8E23, leafAlt: 0x808000 },
                    Crystal: { trunk: 0x4169E1, leaf: 0x00FFFF, leafAlt: 0x7FFFD4 }
                };
                const colors = TREE_COLORS[biomeName] || TREE_COLORS.Terra;
                const scale = 0.6 + rng.next() * 0.8;

                let treeName = 'Tree';

                if (treeStyle === 0) {
                    // Style 0: L-System procedural tree (complex branching)
                    const lTree = createLSystemTree(biomeName, seed);
                    while (lTree.children.length > 0) {
                        group.add(lTree.children[0]);
                    }
                    group.userData = lTree.userData;
                    scene.add(group);
                    worldState.interactables.push(group);
                    return; // L-system sets its own userData
                }
                else if (treeStyle === 1) {
                    // Style 1: Simple sphere-top tree (like landing zone)
                    // v6.72: Minecraft-style procedural textures
                    const trunkGeo = new THREE.CylinderGeometry(0.15 * scale, 0.25 * scale, 2 * scale, 6);
                    const trunkMat = MinecraftTextures.createWoodMaterial(colors.trunk, seed);
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = scale;
                    trunk.castShadow = true;
                    group.add(trunk);

                    const foliageGeo = new THREE.SphereGeometry(0.8 * scale, 8, 6);
                    const foliageMat = MinecraftTextures.createLeafMaterial(colors.leaf, seed + 100);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = 2.2 * scale;
                    foliage.castShadow = true;
                    group.add(foliage);
                    treeName = 'Round Tree';
                }
                else if (treeStyle === 2) {
                    // Style 2: Pine/Cone tree
                    // v6.72: Minecraft-style procedural textures
                    const trunkGeo = new THREE.CylinderGeometry(0.1 * scale, 0.2 * scale, 1.5 * scale, 6);
                    const trunkMat = MinecraftTextures.createWoodMaterial(colors.trunk, seed);
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 0.75 * scale;
                    trunk.castShadow = true;
                    group.add(trunk);

                    // Stacked cones for pine look
                    for (let i = 0; i < 3; i++) {
                        const coneScale = 1 - i * 0.25;
                        const coneGeo = new THREE.ConeGeometry(0.7 * scale * coneScale, 1.2 * scale * coneScale, 8);
                        const coneMat = MinecraftTextures.createLeafMaterial(i % 2 === 0 ? colors.leaf : colors.leafAlt, seed + i * 50);
                        const cone = new THREE.Mesh(coneGeo, coneMat);
                        cone.position.y = (1.8 + i * 0.7) * scale;
                        cone.castShadow = true;
                        group.add(cone);
                    }
                    treeName = 'Pine Tree';
                }
                else if (treeStyle === 3) {
                    // Style 3: Multi-sphere cluster tree (bushy)
                    // v6.72: Minecraft-style procedural textures
                    const trunkGeo = new THREE.CylinderGeometry(0.12 * scale, 0.2 * scale, 1.8 * scale, 5);
                    const trunkMat = MinecraftTextures.createWoodMaterial(colors.trunk, seed);
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 0.9 * scale;
                    trunk.castShadow = true;
                    group.add(trunk);

                    // Multiple small spheres for bushy canopy
                    const spherePositions = [
                        { x: 0, y: 2.2, z: 0, r: 0.6 },
                        { x: 0.4, y: 1.9, z: 0.3, r: 0.45 },
                        { x: -0.3, y: 2.0, z: 0.4, r: 0.4 },
                        { x: 0.2, y: 2.4, z: -0.3, r: 0.35 },
                        { x: -0.4, y: 1.8, z: -0.2, r: 0.4 }
                    ];
                    spherePositions.forEach((pos, idx) => {
                        const sGeo = new THREE.SphereGeometry(pos.r * scale, 6, 5);
                        const sMat = MinecraftTextures.createLeafMaterial(idx % 2 === 0 ? colors.leaf : colors.leafAlt, seed + idx * 30);
                        const sphere = new THREE.Mesh(sGeo, sMat);
                        sphere.position.set(pos.x * scale, pos.y * scale, pos.z * scale);
                        sphere.castShadow = true;
                        group.add(sphere);
                    });
                    treeName = 'Bushy Tree';
                }
                else {
                    // Style 4: Tall thin tree (birch/aspen style)
                    // v6.72: Minecraft-style procedural textures
                    const trunkGeo = new THREE.CylinderGeometry(0.08 * scale, 0.12 * scale, 3 * scale, 6);
                    const trunkMat = MinecraftTextures.createWoodMaterial(0xDDDDCC, seed); // Pale birch trunk
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 1.5 * scale;
                    trunk.castShadow = true;
                    group.add(trunk);

                    // Elongated ellipsoid foliage
                    const foliageGeo = new THREE.SphereGeometry(0.5 * scale, 8, 6);
                    foliageGeo.scale(1, 1.8, 1);
                    const foliageMat = MinecraftTextures.createLeafMaterial(colors.leaf, seed + 200);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = 3.2 * scale;
                    foliage.castShadow = true;
                    group.add(foliage);

                    // Second smaller cluster
                    const foliage2Geo = new THREE.SphereGeometry(0.35 * scale, 6, 5);
                    const foliage2Mat = MinecraftTextures.createLeafMaterial(colors.leafAlt, seed + 300);
                    const foliage2 = new THREE.Mesh(foliage2Geo, foliage2Mat);
                    foliage2.position.set(0.2 * scale, 2.6 * scale, 0.1 * scale);
                    foliage2.castShadow = true;
                    group.add(foliage2);
                    treeName = 'Tall Tree';
                }

                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: treeName, biomeName: biomeName };
            } else {
                // v6.69: Also add rock variety
                // v6.72: Added Minecraft-style procedural rock textures
                const rockStyle = Math.floor(Math.random() * 3);
                let rockGeo;
                if (rockStyle === 0) {
                    rockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.4);
                } else if (rockStyle === 1) {
                    rockGeo = new THREE.IcosahedronGeometry(0.7 + Math.random() * 0.5);
                } else {
                    rockGeo = new THREE.OctahedronGeometry(0.6 + Math.random() * 0.4);
                }
                const rock = new THREE.Mesh(
                    rockGeo,
                    MinecraftTextures.createRockMaterial(biome)
                );
                rock.position.y = 0.5;
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.set(1 + Math.random() * 0.5, 0.6 + Math.random() * 0.8, 1 + Math.random() * 0.5);
                rock.castShadow = true;
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createFishingSpot(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Ripple effect
            const ripple = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ripple.rotation.x = -Math.PI / 2;
            group.add(ripple);

            group.userData = { type: 'fishing', name: 'Fishing Spot', ripple };
            scene.add(group);
            worldState.fishingSpots.push(group);
            worldState.interactables.push(group);
        }

        // v5.18: Create Battery Charger structure
        function createBatteryCharger(x, y, z, efficiency = 100) {
            if (!scene) return null;

            const group = new THREE.Group();
            group.position.set(x, y + 0.1, z);

            // Base platform
            const baseMat = new THREE.MeshStandardMaterial({
                color: efficiency >= 90 ? 0x00ff88 : (efficiency >= 70 ? 0xffaa00 : 0xff4444),
                metalness: 0.6,
                roughness: 0.3
            });
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.4, 0.3, 8),
                baseMat
            );
            group.add(base);

            // Central charging pillar
            const pillarMat = new THREE.MeshStandardMaterial({
                color: 0x333344,
                metalness: 0.8,
                roughness: 0.2
            });
            const pillar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 2, 6),
                pillarMat
            );
            pillar.position.y = 1.15;
            group.add(pillar);

            // Energy ring (glowing)
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.5, 0.08, 8, 16),
                ringMat
            );
            ring.position.y = 1.8;
            ring.rotation.x = Math.PI / 2;
            group.add(ring);

            // Top beacon light
            const beaconMat = new THREE.MeshBasicMaterial({
                color: efficiency >= 90 ? 0x00ff00 : (efficiency >= 70 ? 0xffff00 : 0xff6600)
            });
            const beacon = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                beaconMat
            );
            beacon.position.y = 2.3;
            group.add(beacon);

            // Add point light for glow effect
            const light = new THREE.PointLight(
                efficiency >= 90 ? 0x00ff88 : (efficiency >= 70 ? 0xffaa00 : 0xff4444),
                0.5,
                8
            );
            light.position.y = 2;
            group.add(light);

            const chargerData = {
                type: 'battery_charger',
                mesh: group,
                x: Math.floor((x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2),
                z: Math.floor((z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2),
                worldX: x,
                worldZ: z,
                efficiency: efficiency,
                chargeRadius: 3 + (efficiency / 25), // Better chargers have larger radius
                isActive: true,
                ring: ring,
                beacon: beacon,
                light: light,
                createdAt: Date.now()
            };

            group.userData = {
                type: 'structure',
                structureType: 'battery_charger',
                name: `Battery Charger (${efficiency}%)`,
                efficiency: efficiency,
                chargerData: chargerData
            };

            scene.add(group);
            worldState.structures.push(chargerData);
            worldState.interactables.push(group);

            return chargerData;
        }

        // v6.11: Construction Site Beacon - Visual marker for prepared building sites
        function createConstructionSiteBeacon(terraformedArea) {
            if (!scene || !terraformedArea) return null;

            const worldX = (terraformedArea.x - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
            const worldZ = (terraformedArea.z - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
            const worldY = worldState.terrain[terraformedArea.x]?.[terraformedArea.z] || 2;

            const group = new THREE.Group();
            group.position.set(worldX, worldY, worldZ);

            // Ground marker - pulsing ring showing build zone
            const groundRingGeo = new THREE.RingGeometry(2, 2.5, 32);
            const groundRingMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const groundRing = new THREE.Mesh(groundRingGeo, groundRingMat);
            groundRing.rotation.x = -Math.PI / 2;
            groundRing.position.y = 0.1;
            group.add(groundRing);

            // Inner construction zone indicator
            const innerZoneGeo = new THREE.CircleGeometry(1.8, 32);
            const innerZoneMat = new THREE.MeshBasicMaterial({
                color: 0x00aa66,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const innerZone = new THREE.Mesh(innerZoneGeo, innerZoneMat);
            innerZone.rotation.x = -Math.PI / 2;
            innerZone.position.y = 0.05;
            group.add(innerZone);

            // Floating beacon marker
            const beaconGeo = new THREE.OctahedronGeometry(0.4, 0);
            const beaconMat = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.9
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 3;
            group.add(beacon);

            // Vertical light beam
            const beamGeo = new THREE.CylinderGeometry(0.05, 0.15, 2.5, 8);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.4
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.y = 1.5;
            group.add(beam);

            // Point light for glow
            const light = new THREE.PointLight(0x00ff88, 0.3, 6);
            light.position.y = 2;
            group.add(light);

            const siteData = {
                type: 'construction_site',
                mesh: group,
                terraformedArea: terraformedArea,
                x: terraformedArea.x,
                z: terraformedArea.z,
                worldX: worldX,
                worldZ: worldZ,
                beacon: beacon,
                groundRing: groundRing,
                beam: beam,
                light: light,
                createdAt: Date.now(),
                claimedBy: null // Builder agent that claims this site
            };

            group.userData = {
                type: 'construction_site',
                name: ' Construction Site',
                siteData: siteData
            };

            // Store reference in terraformed area
            terraformedArea.beacon = siteData;
            terraformedArea.hasSiteBeacon = true;

            scene.add(group);

            // Add to a construction sites array (create if doesn't exist)
            if (!worldState.constructionSites) worldState.constructionSites = [];
            worldState.constructionSites.push(siteData);

            return siteData;
        }

        // v6.11: Remove construction site beacon (called when structure is built)
        function removeConstructionSiteBeacon(siteData) {
            if (!siteData || !siteData.mesh) return;

            scene.remove(siteData.mesh);

            // Remove from array
            if (worldState.constructionSites) {
                const idx = worldState.constructionSites.indexOf(siteData);
                if (idx > -1) worldState.constructionSites.splice(idx, 1);
            }

            // Clear reference in terraformed area
            if (siteData.terraformedArea) {
                siteData.terraformedArea.beacon = null;
                siteData.terraformedArea.hasSiteBeacon = false;
            }
        }

        // v6.11: Find nearest unclaimed construction site for Builder
        function findNearestConstructionSite(agentX, agentZ) {
            if (!worldState.constructionSites || worldState.constructionSites.length === 0) return null;

            let nearest = null;
            let nearestDist = Infinity;

            for (const site of worldState.constructionSites) {
                // Skip claimed sites
                if (site.claimedBy) continue;

                // Skip sites that already have structures nearby
                const hasStructure = worldState.structures.some(s =>
                    Math.abs(s.x - site.x) < 3 && Math.abs(s.z - site.z) < 3);
                if (hasStructure) continue;

                const dist = Math.sqrt(Math.pow(site.x - agentX, 2) + Math.pow(site.z - agentZ, 2));
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = site;
                }
            }

            return nearest;
        }

        // v6.11: Animate construction site beacons
        function updateConstructionSiteBeacons(deltaTime) {
            if (!worldState.constructionSites) return;

            const time = Date.now() * 0.001;

            for (const site of worldState.constructionSites) {
                if (!site.mesh) continue;

                // Rotate and bob the beacon
                if (site.beacon) {
                    site.beacon.rotation.y += deltaTime * 2;
                    site.beacon.position.y = 3 + Math.sin(time * 2) * 0.3;
                }

                // Pulse the ground ring
                if (site.groundRing) {
                    const pulse = 0.5 + Math.sin(time * 3) * 0.15;
                    site.groundRing.material.opacity = pulse;
                }

                // Claimed sites glow differently
                if (site.claimedBy && site.light) {
                    site.light.color.setHex(0xffaa00); // Orange when claimed
                    if (site.beacon) site.beacon.material.color.setHex(0xffaa00);
                }
            }
        }

        // v5.18: Move agent to random nearby position
        function moveAgentToRandomPosition(agent) {
            if (!agent.mesh) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = 5 + Math.random() * 10;
            const newX = agent.mesh.position.x + Math.cos(angle) * distance;
            const newZ = agent.mesh.position.z + Math.sin(angle) * distance;

            // Clamp to world bounds
            const halfWorld = (CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
            const clampedX = Math.max(-halfWorld + 5, Math.min(halfWorld - 5, newX));
            const clampedZ = Math.max(-halfWorld + 5, Math.min(halfWorld - 5, newZ));

            // v6.5.1: Get terrain height at target position
            let targetY = agent.mesh.position.y;
            if (typeof getTerrainHeight === 'function') {
                targetY = getTerrainHeight(clampedX, clampedZ);
            }

            agent.targetPosition = new THREE.Vector3(clampedX, targetY, clampedZ);

            agent.taskState.state = 'moving';
            agent.taskState.targetPosition = agent.targetPosition.clone();
        }

        // v5.18: Update robot energy and check for charging
        function updateRobotEnergy(delta) {
            if (!worldState.player) return;

            const playerPos = worldState.player.position;
            let isNearCharger = false;
            let bestEfficiency = 0;

            // Check if near any battery charger
            for (const structure of worldState.structures) {
                if (structure.type === 'battery_charger' && structure.isActive) {
                    const dist = Math.sqrt(
                        Math.pow(playerPos.x - structure.worldX, 2) +
                        Math.pow(playerPos.z - structure.worldZ, 2)
                    );
                    if (dist < structure.chargeRadius) {
                        isNearCharger = true;
                        bestEfficiency = Math.max(bestEfficiency, structure.efficiency);

                        // Animate the charger ring when charging
                        if (structure.ring) {
                            structure.ring.rotation.z += delta * 2;
                        }
                    }
                }
            }

            robotEnergy.isCharging = isNearCharger;

            if (isNearCharger) {
                // Charge based on efficiency
                const chargeAmount = robotEnergy.chargeRate * (bestEfficiency / 100) * delta;
                robotEnergy.current = Math.min(robotEnergy.max, robotEnergy.current + chargeAmount);
            } else {
                // Drain energy when moving (checked in movement code)
                // Small passive drain
                robotEnergy.current = Math.max(0, robotEnergy.current - robotEnergy.drainRate * delta * 0.1);
            }

            // Update energy UI
            updateEnergyUI();
        }

        // v5.18: Update energy UI display
        function updateEnergyUI() {
            const energyBar = document.getElementById('robot-energy-bar');
            const energyText = document.getElementById('robot-energy-text');

            if (energyBar) {
                const percent = (robotEnergy.current / robotEnergy.max) * 100;
                energyBar.style.width = percent + '%';
                energyBar.style.background = robotEnergy.isCharging ? '#00ff88' :
                    (percent > 50 ? '#00aaff' : (percent > 20 ? '#ffaa00' : '#ff4444'));
            }
            if (energyText) {
                energyText.textContent = `${Math.floor(robotEnergy.current)}/${robotEnergy.max}`;
                if (robotEnergy.isCharging) {
                    energyText.textContent += ' ';
                }
            }

            // v6.72: Also update Dota-style MP bar
            if (typeof updateDotaBarsUI === 'function') {
                updateDotaBarsUI();
            }
        }

        // v5.18: Animate structures (charger rings, etc)
        function updateStructures(delta) {
            for (const structure of worldState.structures) {
                if (structure.type === 'battery_charger' && structure.ring) {
                    // Slow rotation when idle
                    structure.ring.rotation.z += delta * 0.5;

                    // Pulse the beacon
                    if (structure.beacon) {
                        const pulse = Math.sin(performance.now() * 0.003) * 0.3 + 0.7;
                        structure.beacon.scale.setScalar(pulse);
                    }
                }
            }
        }

        // ==========================================
        // v5.18: P2P SPECTATOR STREAMING SYSTEM
        // QR Code minimap allows others to spectate
        // ==========================================

        // Initialize PeerJS connection as host
        function initP2PHost() {
            if (p2pStreaming.peer) return; // Already initialized

            try {
                // Create peer with random ID
                p2pStreaming.peer = new Peer();

                p2pStreaming.peer.on('open', (id) => {
                    p2pStreaming.peerId = id;
                    p2pStreaming.isHost = true;
                    console.log('P2P Host initialized with ID:', id);

                    // Generate QR code
                    generateSpectatorQRCode();
                    updateP2PStatusUI();
                });

                p2pStreaming.peer.on('connection', (conn) => {
                    console.log('Spectator connected:', conn.peer);
                    p2pStreaming.connections.push(conn);
                    p2pStreaming.spectatorCount = p2pStreaming.connections.length;

                    conn.on('open', () => {
                        showNotification(` Spectator joined! (${p2pStreaming.spectatorCount} watching)`, 'info');
                        updateP2PStatusUI();

                        // Send initial game state
                        sendGameStateToSpectator(conn);
                    });

                    conn.on('close', () => {
                        p2pStreaming.connections = p2pStreaming.connections.filter(c => c !== conn);
                        p2pStreaming.spectatorCount = p2pStreaming.connections.length;
                        updateP2PStatusUI();
                    });

                    conn.on('error', (err) => {
                        console.error('Connection error:', err);
                        p2pStreaming.connections = p2pStreaming.connections.filter(c => c !== conn);
                        p2pStreaming.spectatorCount = p2pStreaming.connections.length;
                    });
                });

                p2pStreaming.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    if (err.type === 'unavailable-id') {
                        // Retry with new ID
                        setTimeout(initP2PHost, 1000);
                    }
                });

            } catch (e) {
                console.error('Failed to initialize P2P:', e);
            }
        }

        // Connect as spectator to a host
        function connectAsSpectator(hostId) {
            if (!hostId) {
                showNotification('Invalid host ID', 'error');
                return;
            }

            try {
                p2pStreaming.peer = new Peer();

                p2pStreaming.peer.on('open', () => {
                    p2pStreaming.isHost = false;
                    p2pStreaming.isSpectating = true;

                    const conn = p2pStreaming.peer.connect(hostId, { reliable: true });

                    conn.on('open', () => {
                        p2pStreaming.hostConnection = conn;
                        showNotification(' Connected to host! Spectating...', 'info');
                        enterSpectatorMode();
                    });

                    conn.on('data', (data) => {
                        handleSpectatorData(data);
                    });

                    conn.on('close', () => {
                        showNotification('Host disconnected', 'error');
                        exitSpectatorMode();
                    });

                    conn.on('error', (err) => {
                        console.error('Connection error:', err);
                        showNotification('Failed to connect to host', 'error');
                    });
                });

                p2pStreaming.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    showNotification('Connection failed', 'error');
                });

            } catch (e) {
                console.error('Failed to connect as spectator:', e);
            }
        }

        // v6.85: Connect as Ant Farm spectator - spectates but auto-enables 3D ant farm view
        function connectAsAntFarmSpectator(hostId) {
            if (!hostId) {
                showNotification('Invalid host ID', 'error');
                return;
            }

            // Get planet ID from URL if available for immediate landing
            const params = new URLSearchParams(window.location.search);
            const planetParam = params.get('planet');
            const seedParam = params.get('seed');

            // Set seed immediately if provided
            if (seedParam) {
                multiplayerState.worldSeed = decodeURIComponent(seedParam);
                console.log(' Ant Farm using seed:', multiplayerState.worldSeed);
            }

            // If we have a planet ID, land on it immediately (don't wait for P2P)
            if (planetParam !== null && planetParam !== '') {
                const planetId = parseInt(planetParam, 10);
                console.log(' Ant Farm: Landing on planet ID:', planetId);

                // Generate civilizations with the seed
                const rng = new SeededRandom(multiplayerState.worldSeed);
                if (!civilizations || civilizations.length === 0) {
                    civilizations = generateCivilizations(rng, 100);
                }

                // Find and land on the target planet
                const targetCiv = civilizations.find(c => c.id === planetId);
                if (targetCiv) {
                    activeCiv = targetCiv;
                    console.log(' Ant Farm: Found planet:', activeCiv.name);

                    // Land on the planet immediately
                    landOnPlanetForAntFarm(activeCiv);
                } else {
                    console.error(' Ant Farm: Planet not found with ID:', planetId);
                    showNotification('Planet not found', 'error');
                }
            }

            try {
                p2pStreaming.peer = new Peer();

                p2pStreaming.peer.on('open', () => {
                    p2pStreaming.isHost = false;
                    p2pStreaming.isSpectating = true;
                    p2pStreaming.isAntFarmMode = true; // v6.85: Flag for ant farm spectator

                    const conn = p2pStreaming.peer.connect(hostId, { reliable: true });

                    conn.on('open', () => {
                        p2pStreaming.hostConnection = conn;
                        showNotification(' Connected to host!', 'info');

                        // Request full state from host for entity sync
                        conn.send({ type: 'requestFullState' });
                    });

                    conn.on('data', (data) => {
                        handleAntFarmSpectatorData(data);
                    });

                    conn.on('close', () => {
                        showNotification('Host disconnected', 'error');
                        p2pStreaming.isAntFarmMode = false;
                        if (antFarmState.active) {
                            toggleAntFarm(); // Disable ant farm view
                        }
                    });

                    conn.on('error', (err) => {
                        console.error('Ant Farm connection error:', err);
                        showNotification('Failed to connect to ant farm', 'error');
                    });
                });

                p2pStreaming.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    showNotification('Ant Farm connection failed', 'error');
                });

            } catch (e) {
                console.error('Failed to connect as ant farm spectator:', e);
            }
        }

        // v6.85: Land on planet specifically for ant farm view
        function landOnPlanetForAntFarm(civ) {
            console.log(' Landing on planet for Ant Farm:', civ.name);

            // Use the existing initWorld function which handles all terrain generation
            // Pass true to skip some props that might interfere with ant farm view
            if (typeof initWorld === 'function') {
                initWorld(civ, true); // skipPropsForMultiplayer = true for cleaner view
            }

            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Enable ant farm view after terrain loads
            setTimeout(() => {
                if (!antFarmState.active && mode === 'world') {
                    toggleAntFarm();
                    showNotification(` Ant Farm: Viewing ${civ.name}`, 'info');
                }
            }, 1500);
        }

        // v6.85: Handle data for ant farm spectator mode
        function handleAntFarmSpectatorData(data) {
            if (!data || !data.type) return;

            if (data.type === 'fullState') {
                // Apply the full state to sync entities
                applyAntFarmFullState(data);
            } else if (data.type === 'delta') {
                // Apply delta updates for real-time sync
                applyAntFarmDelta(data);
            }
        }

        // v6.85: Apply full state for ant farm view (sync entities, not terrain)
        function applyAntFarmFullState(state) {
            console.log(' Applying Ant Farm state sync:', state);

            // If we're not on the world yet, and state has civilization, try to land
            if (mode !== 'world' && state.civilization && state.civilization.id !== undefined) {
                const civId = state.civilization.id;

                // Generate civilizations if needed
                if (!civilizations || civilizations.length === 0) {
                    const rng = new SeededRandom(state.worldSeed || multiplayerState.worldSeed);
                    civilizations = generateCivilizations(rng, 100);
                }

                const targetCiv = civilizations.find(c => c.id === civId);
                if (targetCiv && !activeCiv) {
                    activeCiv = targetCiv;
                    landOnPlanetForAntFarm(activeCiv);
                }
            }

            // Sync entity positions from host
            if (mode === 'world') {
                syncAntFarmEntities(state);

                // Make sure ant farm view is active
                if (!antFarmState.active) {
                    setTimeout(() => {
                        if (!antFarmState.active && mode === 'world') {
                            toggleAntFarm();
                        }
                    }, 500);
                }
            }
        }

        // v6.85: Apply delta updates for ant farm real-time sync
        function applyAntFarmDelta(delta) {
            if (!delta.deltaType || !delta.data) return;

            switch (delta.deltaType) {
                case 'playerMove':
                    // Update host player position marker
                    updateAntFarmHostMarker(delta.data);
                    break;
                case 'mobUpdate':
                    // Update mob positions
                    updateAntFarmMobs(delta.data);
                    break;
                case 'agentUpdate':
                    // Update agent positions
                    updateAntFarmAgents(delta.data);
                    break;
            }
        }

        // v6.85: Sync entities (mobs, interactables) for ant farm view
        function syncAntFarmEntities(state) {
            // The terrain generation will create entities based on the seed
            // We just need to sync positions for dynamic entities

            // Update mob positions if provided
            if (state.mobs && Array.isArray(state.mobs)) {
                state.mobs.forEach(mobData => {
                    const mob = worldState.mobs?.find(m =>
                        m.userData?.id === mobData.id || m.uuid === mobData.id
                    );
                    if (mob && mobData.position) {
                        mob.position.set(mobData.position.x, mobData.position.y, mobData.position.z);
                    }
                });
            }

            // Update the ant farm stats display
            updateAntFarmStats();
        }

        // v6.85: Update host player marker in ant farm view
        function updateAntFarmHostMarker(playerData) {
            if (!antFarmState.active || !playerData.position) return;

            // Create or update the host marker
            if (!window.antFarmHostMarker) {
                const markerGeometry = new THREE.ConeGeometry(2, 5, 4);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                window.antFarmHostMarker = new THREE.Mesh(markerGeometry, markerMaterial);
                window.antFarmHostMarker.rotation.x = Math.PI; // Point down
                scene.add(window.antFarmHostMarker);
            }

            // Update position (floating above the player)
            window.antFarmHostMarker.position.set(
                playerData.position.x,
                (playerData.position.y || 0) + 15,
                playerData.position.z
            );

            // Animate the marker
            window.antFarmHostMarker.rotation.y += 0.02;
        }

        // v6.85: Update mob positions in ant farm view
        function updateAntFarmMobs(mobsData) {
            if (!antFarmState.active || !Array.isArray(mobsData)) return;

            mobsData.forEach(mobData => {
                const mob = worldState.mobs?.find(m =>
                    m.userData?.id === mobData.id || m.uuid === mobData.id
                );
                if (mob && mobData.position) {
                    // Smoothly interpolate position
                    mob.position.lerp(
                        new THREE.Vector3(mobData.position.x, mobData.position.y, mobData.position.z),
                        0.3
                    );
                }
            });
        }

        // v6.85: Update agent positions in ant farm view
        function updateAntFarmAgents(agentsData) {
            if (!antFarmState.active || !Array.isArray(agentsData)) return;

            agentsData.forEach(agentData => {
                const agent = agentFleet?.find(a => a.id === agentData.id);
                if (agent && agent.mesh && agentData.position) {
                    agent.mesh.position.lerp(
                        new THREE.Vector3(agentData.position.x, agentData.position.y, agentData.position.z),
                        0.3
                    );
                }
            });
        }

        // v5.19: QR Code Generator using QRious library with API fallback
        // Generates scannable QR codes for spectator links
        function loadQRiousLibrary() {
            return new Promise((resolve, reject) => {
                if (window.QRious) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Generate QR code for spectator link
        function generateSpectatorQRCode() {
            if (!p2pStreaming.peerId) {
                console.log('No peer ID yet, will generate QR when ready');
                return;
            }

            const container = document.getElementById('qr-code-container');
            if (!container) return;

            // Show loading state
            container.innerHTML = '<div style="color: #333; font-size: 14px;">Generating QR code...</div>';

            const spectatorUrl = `${window.location.origin}${window.location.pathname}?spectate=${p2pStreaming.peerId}`;
            console.log('Generating QR code for:', spectatorUrl);

            // Try QRious library first, fall back to API
            loadQRiousLibrary().then(() => {
                container.innerHTML = ''; // Clear loading state
                const canvas = document.createElement('canvas');
                canvas.id = 'qr-canvas';
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: spectatorUrl,
                    size: 200,
                    background: 'white',
                    foreground: 'black',
                    level: 'H' // High error correction for better scanning
                });

                console.log('QR code generated with QRious');
            }).catch((err) => {
                console.log('QRious failed, using API fallback:', err);
                container.innerHTML = ''; // Clear loading state
                // Fallback: Use QR Server API
                const img = document.createElement('img');
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(spectatorUrl)}`;
                img.alt = 'Scan to spectate';
                img.style.borderRadius = '10px';
                img.id = 'qr-canvas';
                img.onload = () => console.log('QR code loaded from API');
                img.onerror = () => {
                    container.innerHTML = '<div style="color: #c00; font-size: 12px; padding: 10px;">QR generation failed.<br>Copy the URL below instead.</div>';
                };
                container.appendChild(img);
                console.log('QR code generated with API fallback');
            });
        }

        // Send game state to spectators - now includes full 3D sync data
        function sendGameStateToSpectators() {
            if (!p2pStreaming.isHost || p2pStreaming.connections.length === 0) return;

            const now = performance.now();
            if (now - p2pStreaming.lastFrameTime < p2pStreaming.frameInterval) return;
            p2pStreaming.lastFrameTime = now;

            // Build full 3D sync state for spectators to render
            const gameState = {
                type: 'frame',
                timestamp: Date.now(),
                // Camera for 3D view sync
                camera: camera ? {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    rotation: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }
                } : null,
                // Player position for 3D rendering
                player: worldState.player ? {
                    x: worldState.player.position.x,
                    y: worldState.player.position.y,
                    z: worldState.player.position.z,
                    rotationY: worldState.player.rotation.y
                } : null,
                // Agent positions with full data
                agents: (agentFleet || []).map(a => ({
                    id: a.id,
                    name: a.name,
                    type: a.type,
                    x: a.mesh?.position.x || 0,
                    y: a.mesh?.position.y || 0,
                    z: a.mesh?.position.z || 0,
                    status: a.statusMessage
                })),
                // Structure data
                structures: (worldState.structures || []).map(s => ({
                    type: s.type,
                    x: s.worldX,
                    z: s.worldZ,
                    efficiency: s.efficiency
                })),
                // Mob positions (for showing enemies)
                mobs: (worldState.mobs || []).slice(0, 20).map(m => ({
                    x: m.position?.x || 0,
                    y: m.position?.y || 0,
                    z: m.position?.z || 0,
                    name: m.userData?.displayName || m.userData?.name || 'Enemy'
                })),
                // Stats
                hp: gameData.player?.hp || 100,
                maxHp: gameData.player?.maxHp || 100,
                energy: robotEnergy.current,
                civ: activeCiv?.name || 'Unknown',
                biome: activeCiv?.biome || 'Terra',
                // v5.20: Include current game mode so spectators can sync
                gameMode: mode
            };

            // Capture minimap as image
            const minimapCanvas = document.getElementById('minimap-canvas');
            if (minimapCanvas) {
                const smallCanvas = document.createElement('canvas');
                smallCanvas.width = 140;
                smallCanvas.height = 140;
                const ctx = smallCanvas.getContext('2d');
                ctx.drawImage(minimapCanvas, 0, 0, 140, 140);
                gameState.minimap = smallCanvas.toDataURL('image/jpeg', 0.7);
            }

            // Send to all spectators (only if connection is open)
            for (const conn of p2pStreaming.connections) {
                try {
                    if (conn.open) {
                        conn.send(gameState);
                    }
                } catch (e) {
                    console.error('Failed to send to spectator:', e);
                }
            }
        }

        // Send initial state to new spectator
        function sendGameStateToSpectator(conn) {
            const initialState = {
                type: 'init',
                civ: activeCiv ? { name: activeCiv.name, biome: activeCiv.biome } : null,
                playerName: 'Explorer Robot',
                version: VERSION
            };
            conn.send(initialState);
        }

        // Handle incoming data as spectator
        function handleSpectatorData(data) {
            if (!p2pStreaming.isSpectating) return;

            p2pStreaming.spectatorData = data;

            if (data.type === 'init') {
                // Initial connection data
                const civEl = document.getElementById('spectator-civ');
                const versionEl = document.getElementById('spectator-version');
                if (civEl) civEl.textContent = data.civ?.name || 'Unknown';
                if (versionEl) versionEl.textContent = data.version;
            } else if (data.type === 'frame') {
                // v5.20: Check if host changed modes and we need to sync
                const previousMode = p2pStreaming.hostGameMode;
                p2pStreaming.hostGameMode = data.gameMode;

                // Update banner to show host's current mode
                showSpectatorModeMessage(data.gameMode);

                // v5.20: Sync 3D camera for real view streaming (unless paused)
                // Only sync if we're in the same mode as host
                if (!p2pStreaming.streamPaused && data.camera && camera && mode === data.gameMode) {
                    syncCameraFromHost(data.camera);
                }

                // Update spectator view stats
                updateSpectatorView(data);
            }
        }

        // v5.20: Show mode sync message to spectator (only once per mode change)
        let lastModeMessage = '';
        function showSpectatorModeMessage(msg) {
            if (msg === lastModeMessage) return; // Don't spam
            lastModeMessage = msg;

            // Update the banner to show host's mode
            const hostNameEl = document.getElementById('spectator-host-name');
            if (hostNameEl && p2pStreaming.hostGameMode) {
                const modeIcon = p2pStreaming.hostGameMode === 'world' ? '' : '';
                hostNameEl.textContent = `Host (${modeIcon} ${p2pStreaming.hostGameMode})`;
            }
        }

        // v5.20: Smoothly sync camera from host data
        function syncCameraFromHost(cameraData) {
            if (!camera) return;

            const targetPos = new THREE.Vector3(
                cameraData.position.x,
                cameraData.position.y,
                cameraData.position.z
            );

            // Smooth interpolation (lerp) for fluid camera following
            camera.position.lerp(targetPos, 0.3);

            // Apply rotation directly for snappy look direction
            camera.rotation.x = cameraData.rotation.x;
            camera.rotation.y = cameraData.rotation.y;
            camera.rotation.z = cameraData.rotation.z;
        }

        // Spectator activity log
        let spectatorActivityLog = [];
        let lastSpectatorData = null;

        // Update spectator UI with received data
        function updateSpectatorView(data) {
            // Track latency
            const latencyEl = document.getElementById('spectator-latency');
            if (latencyEl && data.timestamp) {
                const latency = Date.now() - data.timestamp;
                latencyEl.textContent = latency;
            }

            // Update HP bar with color coding
            const hpFill = document.getElementById('spectator-hp-fill');
            const hpText = document.getElementById('spectator-hp-text');
            if (hpFill && data.hp !== undefined) {
                const hpPercent = (data.hp / data.maxHp) * 100;
                hpFill.style.width = hpPercent + '%';
                // Color based on health
                if (hpPercent < 25) {
                    hpFill.style.background = 'linear-gradient(90deg, #f44, #f66)';
                } else if (hpPercent < 50) {
                    hpFill.style.background = 'linear-gradient(90deg, #f80, #fa0)';
                } else {
                    hpFill.style.background = 'linear-gradient(90deg, #f44, #ff8800, #4f4)';
                }
                // Detect damage for activity feed
                if (lastSpectatorData && data.hp < lastSpectatorData.hp) {
                    addSpectatorActivity(`Probe took ${Math.floor(lastSpectatorData.hp - data.hp)} damage!`, 'danger');
                }
            }
            if (hpText) {
                hpText.textContent = `${Math.floor(data.hp)}/${data.maxHp}`;
            }

            // Update energy bar
            const energyFill = document.getElementById('spectator-energy-fill');
            const energyText = document.getElementById('spectator-energy-text');
            if (energyFill && data.energy !== undefined) {
                energyFill.style.width = data.energy + '%';
            }
            if (energyText) {
                energyText.textContent = `${Math.floor(data.energy)}/100`;
            }

            // Update minimap
            const spectatorMinimap = document.getElementById('spectator-minimap');
            if (spectatorMinimap && data.minimap) {
                spectatorMinimap.src = data.minimap;
            }

            // Update biome
            const biomeEl = document.getElementById('spectator-biome');
            if (biomeEl && data.biome) {
                biomeEl.textContent = data.biome;
            }

            // Update agent list with cards
            const agentList = document.getElementById('spectator-agents');
            const agentCount = document.getElementById('spectator-agent-count');
            if (agentList && data.agents) {
                if (data.agents.length === 0) {
                    agentList.innerHTML = '<div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 20px 0;">No agents deployed</div>';
                } else {
                    agentList.innerHTML = data.agents.map(a => {
                        const icon = a.type === 'gatherer' ? '' : a.type === 'hunter' ? '' : a.type === 'terraformer' ? '' : a.type === 'builder' ? '' : '';
                        const typeColor = a.type === 'hunter' ? '#f44' : a.type === 'gatherer' ? '#4a4' : a.type === 'terraformer' ? '#84530' : '#0af';
                        return `<div class="spectator-agent-card">
                            <span style="font-size: 20px;">${icon}</span>
                            <div style="flex: 1;">
                                <div style="color: #fff; font-size: 11px; font-weight: bold;">${a.name}</div>
                                <div style="color: ${typeColor}; font-size: 9px; text-transform: uppercase;">${a.type}</div>
                                <div style="color: #888; font-size: 10px; margin-top: 2px;">${a.status || 'Idle'}</div>
                            </div>
                        </div>`;
                    }).join('');
                }
                if (agentCount) {
                    agentCount.textContent = data.agents.length;
                }
                // Detect new agents for activity feed
                if (lastSpectatorData && data.agents.length > (lastSpectatorData.agents?.length || 0)) {
                    const newAgent = data.agents[data.agents.length - 1];
                    addSpectatorActivity(`New agent deployed: ${newAgent.name}`, 'success');
                }
            }

            // Update structure count and types
            const structureCount = document.getElementById('spectator-structures');
            const structureTypes = document.getElementById('spectator-structure-types');
            if (structureCount && data.structures) {
                structureCount.textContent = data.structures.length;
                // Detect new structures for activity feed
                if (lastSpectatorData && data.structures.length > (lastSpectatorData.structures?.length || 0)) {
                    addSpectatorActivity('New structure built!', 'success');
                }
            }
            if (structureTypes && data.structures) {
                // Count structure types
                const typeCounts = {};
                data.structures.forEach(s => {
                    typeCounts[s.type] = (typeCounts[s.type] || 0) + 1;
                });
                structureTypes.innerHTML = Object.entries(typeCounts).map(([type, count]) =>
                    `<span style="background: rgba(0,255,255,0.15); color: #0ff; padding: 3px 8px; border-radius: 10px; font-size: 10px;">
                        ${type === 'battery_charger' ? '' : ''} ${count}
                    </span>`
                ).join('');
            }

            // Update coordinates
            const coordsDisplay = document.getElementById('spectator-coords');
            if (coordsDisplay && data.player) {
                coordsDisplay.textContent = `X: ${Math.floor(data.player.x)} Z: ${Math.floor(data.player.z)}`;
            }

            // Store for comparison
            lastSpectatorData = { ...data };
        }

        // Add activity to spectator feed
        function addSpectatorActivity(message, type = 'info') {
            const activityFeed = document.getElementById('spectator-activity');
            if (!activityFeed) return;

            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const typeClass = type === 'danger' ? 'danger' : type === 'warning' ? 'warning' : type === 'success' ? 'success' : '';

            const item = document.createElement('div');
            item.className = `activity-item ${typeClass}`;
            item.innerHTML = `<span style="color: #666; font-size: 9px;">[${time}]</span> ${message}`;

            // Clear placeholder if first real activity
            if (spectatorActivityLog.length === 0) {
                activityFeed.innerHTML = '';
            }

            activityFeed.insertBefore(item, activityFeed.firstChild);
            spectatorActivityLog.unshift({ time, message, type });

            // Keep only last 50 items
            if (spectatorActivityLog.length > 50) {
                spectatorActivityLog.pop();
                if (activityFeed.lastChild) {
                    activityFeed.removeChild(activityFeed.lastChild);
                }
            }
        }

        // Enter spectator mode - now shows real 3D world with synced view
        function enterSpectatorMode() {
            p2pStreaming.isSpectating = true;

            // Reset activity log
            spectatorActivityLog = [];
            lastSpectatorData = null;

            // Show spectator banner instead of full overlay
            showSpectatorBanner();

            // Add connected activity
            addSpectatorActivity('Connected to stream!', 'success');

            // Disable player controls but keep 3D rendering active
            // Player input will be ignored in spectator mode
            showNotification(' SPECTATING - Following host\'s view', 'info');
        }

        // Show minimal spectator banner
        function showSpectatorBanner() {
            // Create spectator banner if not exists
            let banner = document.getElementById('spectator-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'spectator-banner';
                banner.innerHTML = `
                    <div id="spectator-banner-inner" style="position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(180deg, rgba(255,68,68,0.9), rgba(200,0,0,0.7));
                        padding: 8px 20px; display: flex; justify-content: space-between; align-items: center; z-index: 10000; border-bottom: 2px solid #f44;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div id="mode-indicator" style="width: 10px; height: 10px; background: #fff; border-radius: 50%; animation: pulse-banner 1s infinite;"></div>
                            <span id="mode-label" style="font-weight: bold; color: #fff;"> SPECTATOR MODE</span>
                            <span style="color: rgba(255,255,255,0.8); font-size: 12px;">Following: <span id="spectator-host-name">Host</span></span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span id="spectator-latency-display" style="color: rgba(255,255,255,0.7); font-size: 11px;">Latency: --ms</span>
                            <button id="toggle-active-btn" style="background: linear-gradient(45deg, #06ffa5, #00ff88); border: none; color: #000;
                                padding: 6px 14px; border-radius: 15px; cursor: pointer; font-size: 11px; font-weight: bold; transition: all 0.3s;"> PAUSE</button>
                            <button id="exit-spectator-btn" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.5); color: #fff;
                                padding: 6px 16px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold;">EXIT</button>
                        </div>
                    </div>
                    <style>
                        @keyframes pulse-banner { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
                        @keyframes pulse-active { 0%, 100% { box-shadow: 0 0 10px #0f0; } 50% { box-shadow: 0 0 20px #0f0, 0 0 30px #0f0; } }
                    </style>
                `;
                document.body.appendChild(banner);

                // Add exit button listener
                document.getElementById('exit-spectator-btn').addEventListener('click', exitSpectatorMode);

                // Add pause/play toggle listener
                document.getElementById('toggle-active-btn').addEventListener('click', toggleStreamPause);
            }
            banner.style.display = 'block';

            // Also show mini stats overlay at bottom
            showSpectatorStats();
        }

        // v5.20: Toggle stream pause/play
        function toggleStreamPause() {
            p2pStreaming.streamPaused = !p2pStreaming.streamPaused;

            const toggleBtn = document.getElementById('toggle-active-btn');

            if (p2pStreaming.streamPaused) {
                toggleBtn.innerHTML = ' RESUME';
                toggleBtn.style.background = 'linear-gradient(45deg, #f44, #f80)';
                showNotification(' Stream paused - camera frozen', 'info');
            } else {
                toggleBtn.innerHTML = ' PAUSE';
                toggleBtn.style.background = 'linear-gradient(45deg, #06ffa5, #00ff88)';
                showNotification(' Stream resumed - following host', 'info');
            }
        }

        // Show spectator stats overlay
        function showSpectatorStats() {
            let statsOverlay = document.getElementById('spectator-stats-overlay');
            if (!statsOverlay) {
                statsOverlay = document.createElement('div');
                statsOverlay.id = 'spectator-stats-overlay';
                statsOverlay.innerHTML = `
                    <div style="position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); border: 1px solid rgba(0,255,255,0.3);
                        border-radius: 10px; padding: 15px; min-width: 200px; z-index: 9999;">
                        <div style="color: #0ff; font-size: 11px; font-weight: bold; margin-bottom: 10px;"> HOST STATS</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div>
                                <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px;">
                                    <span style="color: #888;">INTEGRITY</span>
                                    <span id="spec-hp" style="color: #4f4;">100/100</span>
                                </div>
                                <div style="background: #222; height: 6px; border-radius: 3px; overflow: hidden;">
                                    <div id="spec-hp-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #f44, #4f4);"></div>
                                </div>
                            </div>
                            <div>
                                <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px;">
                                    <span style="color: #888;"> ENERGY</span>
                                    <span id="spec-energy" style="color: #0af;">100/100</span>
                                </div>
                                <div style="background: #222; height: 6px; border-radius: 3px; overflow: hidden;">
                                    <div id="spec-energy-bar" style="width: 100%; height: 100%; background: #0af;"></div>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 5px;">
                                <span>Coords:</span>
                                <span id="spec-coords" style="color: #0ff; font-family: monospace;">X: 0 Z: 0</span>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(statsOverlay);
            }
            statsOverlay.style.display = 'block';
        }

        // Exit spectator mode
        function exitSpectatorMode() {
            p2pStreaming.isSpectating = false;

            if (p2pStreaming.hostConnection) {
                p2pStreaming.hostConnection.close();
                p2pStreaming.hostConnection = null;
            }

            // Hide spectator UI
            const banner = document.getElementById('spectator-banner');
            if (banner) banner.style.display = 'none';
            const statsOverlay = document.getElementById('spectator-stats-overlay');
            if (statsOverlay) statsOverlay.style.display = 'none';

            // Reload page to reset game state
            location.reload();
        }

        // ==========================================
        // v6.86: GALAXY DISCOVERY SYSTEM
        // Discover new galaxies when all planets are exhausted
        // Each galaxy has a unique QR code for revisiting
        // ==========================================

        // Open the Galaxy Discovery modal
        // v6.95: Enhanced with player identity for "burning into existence"
        function openGalaxyDiscoveryModal() {
            const modal = document.getElementById('galaxy-discovery-modal');
            if (!modal) return;

            // Update the display with current galaxy info
            const currentGalaxyNum = gameData.galaxyNumber || 1;
            const nextGalaxyNum = currentGalaxyNum + 1;

            document.getElementById('galaxy-number-display').textContent = nextGalaxyNum;
            document.getElementById('current-galaxy-num').textContent = currentGalaxyNum;

            // v6.95: Show player identity as the first observer who will ignite this universe
            const playerNameEl = document.getElementById('ignition-player-name');
            if (playerNameEl) {
                playerNameEl.textContent = gameData.playerName || 'Unknown Pioneer';
            }

            modal.classList.add('active');
            showNotification(` ${gameData.playerName || 'Pioneer'}, a new universe awaits your observation!`, 'warning');
        }
        // Expose to window for inline onclick handler
        window.openGalaxyDiscoveryModal = openGalaxyDiscoveryModal;

        // Close the Galaxy Discovery modal
        function closeGalaxyDiscoveryModal() {
            const modal = document.getElementById('galaxy-discovery-modal');
            if (modal) modal.classList.remove('active');
        }
        // Expose to window for inline onclick handler
        window.closeGalaxyDiscoveryModal = closeGalaxyDiscoveryModal;

        // Generate a unique seed for a new galaxy
        function generateGalaxySeed() {
            const timestamp = Date.now();
            const random = Math.random().toString(36).substring(2, 8).toUpperCase();
            return `GALAXY-${timestamp}-${random}`;
        }

        // Get URL for a specific galaxy (for QR code sharing)
        // v6.95: Enhanced to include full galaxy state for "drop-in" visits
        function getGalaxyUrl(galaxySeed, galaxyNumber, includeState = true) {
            const baseUrl = `${window.location.origin}${window.location.pathname}`;
            let url = `${baseUrl}?galaxy=${encodeURIComponent(galaxySeed)}&gnum=${galaxyNumber}`;

            if (includeState) {
                // Find this galaxy's state
                let galaxyState = null;
                if (galaxySeed === gameData.galaxySeed) {
                    // Current galaxy
                    galaxyState = {
                        destroyed: gameData.destroyedPlanets || [],
                        escaped: gameData.escapedPlanets || [],
                        visited: gameData.visitedPlanets || [],
                        ignitedBy: gameData.firstIgnition?.ignitedBy || gameData.playerName
                    };
                } else {
                    // Historical galaxy
                    const histGalaxy = gameData.galaxyHistory?.find(g => g.seed === galaxySeed);
                    if (histGalaxy) {
                        galaxyState = {
                            destroyed: histGalaxy.destroyedPlanets || [],
                            escaped: histGalaxy.escapedPlanets || [],
                            visited: histGalaxy.visitedPlanets || [],
                            ignitedBy: histGalaxy.ignitedBy
                        };
                    }
                }

                // Encode state compactly: d=destroyed,e=escaped,v=visited (comma-separated IDs)
                if (galaxyState) {
                    if (galaxyState.destroyed.length > 0) {
                        url += `&d=${galaxyState.destroyed.join(',')}`;
                    }
                    if (galaxyState.escaped.length > 0) {
                        url += `&e=${galaxyState.escaped.join(',')}`;
                    }
                    // Include who ignited this universe
                    if (galaxyState.ignitedBy) {
                        url += `&by=${encodeURIComponent(galaxyState.ignitedBy)}`;
                    }
                }
            }

            return url;
        }

        // Save current galaxy state before transitioning
        // v6.95: Enhanced with "ignition" tracking - who first burned this universe into existence
        function saveCurrentGalaxyState() {
            // Initialize galaxy history if needed
            if (!gameData.galaxyHistory) {
                gameData.galaxyHistory = [];
            }

            // Check if this galaxy already exists in history (preserve ignition data)
            const existingSeed = gameData.galaxySeed || multiplayerState.worldSeed;
            const existingGalaxy = gameData.galaxyHistory.find(g => g.seed === existingSeed);

            // v6.95: Ignition data - the first observer who burned this reality into existence
            const ignitionData = existingGalaxy ? {
                // Preserve original ignition data - the first observer is eternal
                ignitedBy: existingGalaxy.ignitedBy,
                ignitedAt: existingGalaxy.ignitedAt,
                ignitionSignature: existingGalaxy.ignitionSignature
            } : {
                // NEW UNIVERSE - this player is the first observer, burning it into existence
                ignitedBy: gameData.playerName || 'Unknown Observer',
                ignitedAt: Date.now(),
                ignitionSignature: generateIgnitionSignature(existingSeed)
            };

            const currentGalaxy = {
                seed: existingSeed,
                number: gameData.galaxyNumber || 1,
                name: `Galaxy ${gameData.galaxyNumber || 1}`,
                discoveredAt: existingGalaxy?.discoveredAt || Date.now(),
                lastVisited: Date.now(),
                visitedPlanets: [...gameData.visitedPlanets],
                destroyedPlanets: [...(gameData.destroyedPlanets || [])],
                escapedPlanets: [...(gameData.escapedPlanets || [])],
                totalPlanets: CONFIG.NUM_CIVS,
                activePlanets: civilizations ? civilizations.filter(c => !c.orbital?.destroyed && !c.orbital?.escaped).length : 0,
                // v6.95: Ignition metadata - who first burned this universe into existence
                ...ignitionData
            };

            // Check if this galaxy is already in history
            const existingIdx = gameData.galaxyHistory.findIndex(g => g.seed === currentGalaxy.seed);
            if (existingIdx >= 0) {
                // Update existing entry (preserving ignition data)
                gameData.galaxyHistory[existingIdx] = currentGalaxy;
            } else {
                // Add new entry - this is the IGNITION moment
                gameData.galaxyHistory.push(currentGalaxy);
                console.log(` UNIVERSE IGNITED: ${currentGalaxy.ignitedBy} burned Galaxy #${currentGalaxy.number} into existence`);
            }

            saveGameData();
            return currentGalaxy;
        }

        // v6.95: Generate a unique ignition signature from seed
        // This is the "fingerprint" of the universe's creation moment
        function generateIgnitionSignature(seed) {
            const timestamp = Date.now();
            const rng = new SeededRNG(seed + timestamp);
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let signature = '';
            for (let i = 0; i < 8; i++) {
                signature += chars[Math.floor(rng.next() * chars.length)];
            }
            return `IGN-${signature}-${(timestamp % 100000).toString(36).toUpperCase()}`;
        }

        // Discover and warp to a new galaxy
        // v6.95: Enhanced with "burning into existence" - you are the first observer
        function discoverNewGalaxy() {
            console.log(' BURNING NEW UNIVERSE INTO EXISTENCE...');

            // Save current galaxy state
            saveCurrentGalaxyState();

            // Generate new galaxy
            const newSeed = generateGalaxySeed();
            const newGalaxyNumber = (gameData.galaxyNumber || 1) + 1;
            const ignitionSignature = generateIgnitionSignature(newSeed);

            // v6.95: Create ignition record - YOU are the first observer
            const ignitionRecord = {
                seed: newSeed,
                number: newGalaxyNumber,
                name: `Galaxy ${newGalaxyNumber}`,
                ignitedBy: gameData.playerName || 'Unknown Pioneer',
                ignitedAt: Date.now(),
                ignitionSignature: ignitionSignature,
                discoveredAt: Date.now(),
                lastVisited: Date.now(),
                visitedPlanets: [],
                destroyedPlanets: [],
                escapedPlanets: [],
                totalPlanets: CONFIG.NUM_CIVS,
                activePlanets: CONFIG.NUM_CIVS
            };

            // Add to galaxy history immediately - the universe NOW exists
            if (!gameData.galaxyHistory) gameData.galaxyHistory = [];
            gameData.galaxyHistory.push(ignitionRecord);

            // Update gameData
            gameData.galaxyNumber = newGalaxyNumber;
            gameData.galaxySeed = newSeed;
            gameData.galaxiesDiscovered = (gameData.galaxiesDiscovered || 1) + 1;

            // Reset planet tracking for new galaxy
            gameData.visitedPlanets = [];
            gameData.destroyedPlanets = [];
            gameData.escapedPlanets = [];

            // Update multiplayer seed
            multiplayerState.worldSeed = newSeed;

            // Close modal
            closeGalaxyDiscoveryModal();

            // v6.95: Show dramatic ignition notification
            showNotification(` IGNITING UNIVERSE #${newGalaxyNumber}...`, 'warning');

            // Log the ignition event
            console.log(` UNIVERSE IGNITED by ${ignitionRecord.ignitedBy}`);
            console.log(`   Galaxy #${newGalaxyNumber} | Seed: ${newSeed}`);
            console.log(`   Signature: ${ignitionSignature}`);
            console.log(`   You are the FIRST OBSERVER - this reality now exists because of you.`);

            // Save and regenerate
            saveGameData();

            // Regenerate the galaxy with new seed
            setTimeout(() => {
                regenerateGalaxy(newSeed);

                // v6.95: Show ignition success message
                setTimeout(() => {
                    showNotification(` ${gameData.playerName} burned Galaxy #${newGalaxyNumber} into existence!`, 'success');
                    showNotification(` ${CONFIG.NUM_CIVS} planets now exist because you observed them.`, 'info');
                }, 800);

                // Generate QR code for this galaxy
                console.log('Galaxy URL:', getGalaxyUrl(newSeed, newGalaxyNumber));
            }, 500);
        }
        // Expose to window for inline onclick handler
        window.discoverNewGalaxy = discoverNewGalaxy;

        // Travel to a previously discovered galaxy
        function travelToGalaxy(galaxySeed, galaxyNumber) {
            console.log(` Traveling to Galaxy #${galaxyNumber}...`);

            // Save current galaxy first
            saveCurrentGalaxyState();

            // Find the galaxy in history
            const targetGalaxy = gameData.galaxyHistory?.find(g => g.seed === galaxySeed);

            if (targetGalaxy) {
                // Restore that galaxy's state
                gameData.galaxyNumber = targetGalaxy.number;
                gameData.galaxySeed = targetGalaxy.seed;
                gameData.visitedPlanets = [...targetGalaxy.visitedPlanets];
                gameData.destroyedPlanets = [...targetGalaxy.destroyedPlanets];
                gameData.escapedPlanets = [...targetGalaxy.escapedPlanets];
            } else {
                // New galaxy from URL - initialize fresh
                gameData.galaxyNumber = galaxyNumber;
                gameData.galaxySeed = galaxySeed;
                gameData.visitedPlanets = [];
                gameData.destroyedPlanets = [];
                gameData.escapedPlanets = [];
            }

            multiplayerState.worldSeed = galaxySeed;
            saveGameData();

            // Regenerate
            regenerateGalaxy(galaxySeed);
            showNotification(` Arrived at Galaxy #${galaxyNumber}!`, 'success');
        }

        // Regenerate the galaxy with a new seed
        function regenerateGalaxy(seed) {
            console.log('Regenerating galaxy with seed:', seed);

            // Clear existing galaxy
            if (galaxyGroup) {
                scene.remove(galaxyGroup);
            }

            // Clear selection
            if (selectionRing) {
                scene.remove(selectionRing);
                selectionRing = null;
            }
            activeCiv = null;
            selectedCivIndex = 0;

            // Regenerate civilizations with new seed
            const rng = new SeededRNG(seed);
            civilizations = [];
            galaxyGroup = new THREE.Group();

            const G_SCALED = physicsParams.G;
            const BLACKHOLE_MASS = physicsParams.M;

            for (let i = 0; i < CONFIG.NUM_CIVS; i++) {
                const initialAngle = rng.next() * Math.PI * 2;
                const orbitalRadius = rng.range(200, 1200);
                const angularVelocity = Math.sqrt(G_SCALED * BLACKHOLE_MASS / Math.pow(orbitalRadius, 3));
                const orbitalInclination = rng.range(-0.15, 0.15);
                const eccentricity = rng.range(0, physicsParams.maxEccentricity);

                const x = Math.cos(initialAngle) * orbitalRadius;
                const z = Math.sin(initialAngle) * orbitalRadius;
                const y = Math.sin(orbitalInclination) * orbitalRadius * 0.1;

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));

                const wasDestroyed = gameData.destroyedPlanets?.includes(i) || false;
                const wasEscaped = gameData.escapedPlanets?.includes(i) || false;

                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100, 999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i),
                    orbital: {
                        radius: orbitalRadius,
                        angle: initialAngle,
                        angularVelocity: angularVelocity,
                        inclination: orbitalInclination,
                        eccentricity: eccentricity,
                        destroyed: wasDestroyed,
                        escaped: wasEscaped
                    }
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x, y, z);
                if (wasDestroyed || wasEscaped) {
                    sysGroup.visible = false;
                }

                // v6.94: Textured planet sphere (visible when zoomed in) - multiplayer sync
                const planetSeed = rng.int(1000, 99999);
                const planet = new THREE.Mesh(
                    new THREE.SphereGeometry(6, 32, 32),
                    PlanetTextures.createPlanetMaterial(biomeKey, planetSeed)
                );
                planet.name = 'texturedPlanet';
                sysGroup.add(planet);

                // v6.94: Planet atmosphere layer (biome-colored)
                const biome = BIOMES[biomeKey];
                const atmosphere = new THREE.Mesh(
                    new THREE.SphereGeometry(7.5, 32, 32),
                    new THREE.MeshBasicMaterial({ color: biome.sky, transparent: true, opacity: 0.15, side: THREE.BackSide })
                );
                atmosphere.name = 'atmosphere';
                sysGroup.add(atmosphere);

                // Star glow (outer aura) - slightly transparent to let texture show
                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(9, 16, 16),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4 })
                );
                star.name = 'starGlow';
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.15 })
                );
                glow.name = 'outerGlow';
                sysGroup.add(glow);

                if (civ.visited) {
                    const visitedRing = new THREE.Mesh(
                        new THREE.RingGeometry(12, 14, 32),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.6 })
                    );
                    visitedRing.rotation.x = Math.PI / 2;
                    sysGroup.add(visitedRing);
                }

                galaxyGroup.add(sysGroup);
            }

            scene.add(galaxyGroup);

            // Update UI
            const activeCivs = civilizations.filter(c => !c.orbital?.destroyed && !c.orbital?.escaped).length;
            const civCountEl = document.getElementById('civ-count');
            if (civCountEl) civCountEl.textContent = activeCivs;

            // Hide discover button since we have planets now
            const discoverBtn = document.getElementById('discover-galaxy-btn');
            if (discoverBtn) discoverBtn.classList.remove('visible');

            console.log(`Galaxy regenerated: ${activeCivs} active planets`);
        }

        // Check URL for galaxy parameter on load
        // v6.95: Enhanced to restore full galaxy state from shared URL
        function checkGalaxyUrlParam() {
            const params = new URLSearchParams(window.location.search);
            const galaxySeed = params.get('galaxy');
            const galaxyNum = parseInt(params.get('gnum')) || 1;

            if (galaxySeed) {
                console.log('Loading galaxy from URL:', galaxySeed);

                // v6.95: Parse shared state (destroyed, escaped, ignited by)
                const sharedState = {
                    destroyed: params.get('d') ? params.get('d').split(',').map(Number).filter(n => !isNaN(n)) : [],
                    escaped: params.get('e') ? params.get('e').split(',').map(Number).filter(n => !isNaN(n)) : [],
                    ignitedBy: params.get('by') ? decodeURIComponent(params.get('by')) : null
                };

                if (sharedState.ignitedBy) {
                    console.log(` Visiting universe ignited by: ${sharedState.ignitedBy}`);
                }
                if (sharedState.destroyed.length > 0) {
                    console.log(`   ${sharedState.destroyed.length} planets destroyed`);
                }
                if (sharedState.escaped.length > 0) {
                    console.log(`   ${sharedState.escaped.length} planets escaped orbit`);
                }

                // Defer to after init
                setTimeout(() => {
                    travelToGalaxyWithState(decodeURIComponent(galaxySeed), galaxyNum, sharedState);
                }, 2000);
                return true;
            }
            return false;
        }

        // v6.95: Travel to a galaxy with a specific shared state
        function travelToGalaxyWithState(galaxySeed, galaxyNumber, sharedState) {
            console.log(` Dropping into ${sharedState.ignitedBy || 'Unknown'}'s universe...`);

            // Save current galaxy first
            saveCurrentGalaxyState();

            // Check if this galaxy exists in our history
            const existingGalaxy = gameData.galaxyHistory?.find(g => g.seed === galaxySeed);

            if (existingGalaxy) {
                // Merge shared state with existing (shared state takes precedence for destroyed/escaped)
                gameData.galaxyNumber = existingGalaxy.number;
                gameData.galaxySeed = existingGalaxy.seed;
                gameData.visitedPlanets = [...existingGalaxy.visitedPlanets];
                // Use shared state for destroyed/escaped if provided
                gameData.destroyedPlanets = sharedState.destroyed.length > 0
                    ? sharedState.destroyed
                    : [...existingGalaxy.destroyedPlanets];
                gameData.escapedPlanets = sharedState.escaped.length > 0
                    ? sharedState.escaped
                    : [...existingGalaxy.escapedPlanets];
            } else {
                // New galaxy from URL - initialize with shared state
                gameData.galaxyNumber = galaxyNumber;
                gameData.galaxySeed = galaxySeed;
                gameData.visitedPlanets = [];
                gameData.destroyedPlanets = sharedState.destroyed;
                gameData.escapedPlanets = sharedState.escaped;

                // Add to history with ignition info from sharer
                if (!gameData.galaxyHistory) gameData.galaxyHistory = [];
                gameData.galaxyHistory.push({
                    seed: galaxySeed,
                    number: galaxyNumber,
                    name: `Galaxy ${galaxyNumber}`,
                    ignitedBy: sharedState.ignitedBy || 'Unknown Pioneer',
                    ignitedAt: Date.now(), // When WE first visited
                    ignitionSignature: `IGN-SHARED-${Date.now().toString(36).toUpperCase()}`,
                    discoveredAt: Date.now(),
                    lastVisited: Date.now(),
                    visitedPlanets: [],
                    destroyedPlanets: sharedState.destroyed,
                    escapedPlanets: sharedState.escaped,
                    totalPlanets: CONFIG.NUM_CIVS,
                    activePlanets: CONFIG.NUM_CIVS - sharedState.destroyed.length - sharedState.escaped.length
                });
            }

            multiplayerState.worldSeed = galaxySeed;
            saveGameData();

            // Regenerate
            regenerateGalaxy(galaxySeed);

            // Show welcome message with igniter info
            if (sharedState.ignitedBy) {
                showNotification(` Dropping into ${sharedState.ignitedBy}'s universe!`, 'warning');
                setTimeout(() => {
                    const activePlanets = CONFIG.NUM_CIVS - sharedState.destroyed.length - sharedState.escaped.length;
                    showNotification(` Galaxy #${galaxyNumber}: ${activePlanets} planets remain`, 'info');
                }, 1500);
            } else {
                showNotification(` Arrived at Galaxy #${galaxyNumber}!`, 'success');
            }
        }

        // ==========================================
        // v6.86: GALAXY MANAGER UI SYSTEM
        // Full multiverse navigation and management
        // ==========================================

        let currentQRGalaxy = null; // For QR overlay

        // Open the Galaxy Manager modal
        function openGalaxyManager() {
            const modal = document.getElementById('galaxy-manager-modal');
            if (!modal) return;

            modal.classList.add('active');
            renderGalaxyGrid();
            updateGalaxyManagerStats();
        }

        // Close the Galaxy Manager modal
        function closeGalaxyManager() {
            const modal = document.getElementById('galaxy-manager-modal');
            if (modal) modal.classList.remove('active');
        }

        // Update the stats in the header
        function updateGalaxyManagerStats() {
            // v6.95: Count unique galaxies (current + history entries that aren't current)
            const currentSeed = gameData.galaxySeed || multiplayerState.worldSeed;
            const historyWithoutCurrent = (gameData.galaxyHistory || []).filter(g => g.seed !== currentSeed);
            const totalGalaxies = historyWithoutCurrent.length + 1; // +1 for current

            let totalPlanets = CONFIG.NUM_CIVS; // Current galaxy
            let totalVisited = gameData.visitedPlanets?.length || 0;

            // Add from history (only non-current to avoid double-counting)
            historyWithoutCurrent.forEach(g => {
                totalPlanets += g.totalPlanets || CONFIG.NUM_CIVS;
                totalVisited += g.visitedPlanets?.length || 0;
            });

            document.getElementById('gm-total-galaxies').textContent = totalGalaxies;
            document.getElementById('gm-total-planets').textContent = totalPlanets;
            document.getElementById('gm-total-visited').textContent = totalVisited;

            // v6.83: Update galaxy button counts
            updateGalaxyButtonCounts(totalGalaxies);
        }

        // v6.83: Update the galaxy count shown on buttons
        function updateGalaxyButtonCounts(count) {
            const text = count === 1 ? '1 Galaxy' : count + ' Galaxies';
            const mainBtn = document.getElementById('galaxy-btn-count-main');
            const worldBtn = document.getElementById('galaxy-btn-count-world');
            if (mainBtn) mainBtn.textContent = text;
            if (worldBtn) worldBtn.textContent = text;
        }

        // Render all galaxy cards
        function renderGalaxyGrid() {
            const grid = document.getElementById('galaxy-grid');
            if (!grid) return;

            grid.innerHTML = '';

            // Current galaxy card (always first)
            const currentGalaxy = {
                seed: gameData.galaxySeed || multiplayerState.worldSeed,
                number: gameData.galaxyNumber || 1,
                name: gameData.currentGalaxyName || `Galaxy ${gameData.galaxyNumber || 1}`,
                visitedPlanets: gameData.visitedPlanets || [],
                destroyedPlanets: gameData.destroyedPlanets || [],
                escapedPlanets: gameData.escapedPlanets || [],
                totalPlanets: CONFIG.NUM_CIVS,
                discoveredAt: Date.now(),
                isCurrent: true
            };
            currentGalaxy.activePlanets = currentGalaxy.totalPlanets - (currentGalaxy.destroyedPlanets.length + currentGalaxy.escapedPlanets.length);

            grid.appendChild(createGalaxyCard(currentGalaxy));

            // Historical galaxies
            if (gameData.galaxyHistory && gameData.galaxyHistory.length > 0) {
                gameData.galaxyHistory.forEach(galaxy => {
                    if (galaxy.seed !== currentGalaxy.seed) {
                        grid.appendChild(createGalaxyCard(galaxy));
                    }
                });
            }

            // Empty state if only current
            if (!gameData.galaxyHistory || gameData.galaxyHistory.length === 0) {
                const hint = document.createElement('div');
                hint.className = 'galaxy-empty-state';
                hint.innerHTML = `
                    <div class="galaxy-empty-icon"></div>
                    <div style="color: #888; font-size: 14px;">Explore your current galaxy!</div>
                    <div style="color: #666; font-size: 12px; margin-top: 8px;">When all planets are exhausted, discover new galaxies to explore.</div>
                `;
                grid.appendChild(hint);
            }
        }

        // Create a galaxy card element
        function createGalaxyCard(galaxy) {
            const card = document.createElement('div');
            card.className = 'galaxy-card' + (galaxy.isCurrent ? ' current' : '');
            card.dataset.seed = galaxy.seed;
            card.dataset.name = galaxy.name?.toLowerCase() || '';

            const activePlanets = galaxy.activePlanets !== undefined ? galaxy.activePlanets :
                (galaxy.totalPlanets || CONFIG.NUM_CIVS) - ((galaxy.destroyedPlanets?.length || 0) + (galaxy.escapedPlanets?.length || 0));
            const visitedCount = galaxy.visitedPlanets?.length || 0;
            const destroyedCount = galaxy.destroyedPlanets?.length || 0;
            const escapedCount = galaxy.escapedPlanets?.length || 0;
            const totalPlanets = galaxy.totalPlanets || CONFIG.NUM_CIVS;
            const progress = Math.round((visitedCount / totalPlanets) * 100);
            const discoveredDate = galaxy.discoveredAt ? new Date(galaxy.discoveredAt).toLocaleDateString() : 'Unknown';

            card.innerHTML = `
                <div class="galaxy-card-header">
                    <div class="galaxy-card-visual"></div>
                    <div class="galaxy-card-name">
                        <input type="text" value="${galaxy.name || 'Galaxy ' + galaxy.number}"
                               onchange="renameGalaxy('${galaxy.seed}', this.value)"
                               onclick="event.stopPropagation()">
                    </div>
                    <div class="galaxy-card-seed">${galaxy.seed.substring(0, 25)}...</div>
                </div>
                <div class="galaxy-card-body">
                    <div class="galaxy-card-stats">
                        <div class="gc-stat">
                            <div class="gc-stat-value active">${activePlanets}</div>
                            <div class="gc-stat-label">Active</div>
                        </div>
                        <div class="gc-stat">
                            <div class="gc-stat-value visited">${visitedCount}</div>
                            <div class="gc-stat-label">Visited</div>
                        </div>
                        <div class="gc-stat">
                            <div class="gc-stat-value destroyed">${destroyedCount}</div>
                            <div class="gc-stat-label">Destroyed</div>
                        </div>
                        <div class="gc-stat">
                            <div class="gc-stat-value escaped">${escapedCount}</div>
                            <div class="gc-stat-label">Escaped</div>
                        </div>
                    </div>
                    <div class="galaxy-card-progress">
                        <div class="galaxy-card-progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <div class="galaxy-card-meta">
                        ${galaxy.ignitedBy ? `<span style="color: #ff9944;"> Ignited by: ${galaxy.ignitedBy}</span><br>` : ''}
                        ${galaxy.ignitionSignature ? `<span style="color: #666; font-size: 10px;">${galaxy.ignitionSignature}</span><br>` : ''}
                        Discovered: ${discoveredDate} | ${progress}% explored
                    </div>
                    <div class="galaxy-card-actions">
                        ${galaxy.isCurrent ?
                            '<button class="gc-action-btn warp" disabled style="opacity: 0.5;">Current</button>' :
                            `<button class="gc-action-btn warp" onclick="warpToGalaxy('${galaxy.seed}', ${galaxy.number})"> Warp</button>`
                        }
                        <button class="gc-action-btn qr" onclick="showGalaxyQR('${galaxy.seed}', ${galaxy.number}, '${galaxy.name || 'Galaxy ' + galaxy.number}')">QR</button>
                        <button class="gc-action-btn share" onclick="shareGalaxy('${galaxy.seed}', ${galaxy.number})"></button>
                    </div>
                </div>
            `;

            return card;
        }

        // Filter galaxies by search term
        function filterGalaxies(searchTerm) {
            const cards = document.querySelectorAll('.galaxy-card');
            const term = searchTerm.toLowerCase();

            cards.forEach(card => {
                const name = card.dataset.name || '';
                const seed = card.dataset.seed || '';
                const matches = name.includes(term) || seed.toLowerCase().includes(term);
                card.style.display = matches ? 'block' : 'none';
            });
        }

        // Rename a galaxy
        function renameGalaxy(seed, newName) {
            // Check if it's the current galaxy
            if (seed === gameData.galaxySeed) {
                gameData.currentGalaxyName = newName;
            } else {
                // Find in history
                const galaxy = gameData.galaxyHistory?.find(g => g.seed === seed);
                if (galaxy) {
                    galaxy.name = newName;
                }
            }
            saveGameData();
            showNotification(`Galaxy renamed to "${newName}"`, 'info');
        }

        // Warp to a galaxy
        function warpToGalaxy(seed, number) {
            closeGalaxyManager();
            showNotification(` Warping to Galaxy #${number}...`, 'info');
            setTimeout(() => {
                travelToGalaxy(seed, number);
            }, 500);
        }

        // Show QR code for a galaxy
        // v6.95: Enhanced to show ignition info and current state
        function showGalaxyQR(seed, number, name) {
            currentQRGalaxy = { seed, number, name };

            const overlay = document.getElementById('galaxy-qr-overlay');
            const container = document.getElementById('galaxy-qr-container');
            const urlDisplay = document.getElementById('galaxy-qr-url-display');
            const titleEl = document.getElementById('qr-galaxy-name');
            const ignitedByEl = document.getElementById('qr-ignited-by');
            const stateEl = document.getElementById('qr-galaxy-state');

            const url = getGalaxyUrl(seed, number);
            titleEl.textContent = name;
            urlDisplay.textContent = url.length > 80 ? url.substring(0, 80) + '...' : url;

            // v6.95: Get galaxy info for ignition display
            let galaxyInfo = null;
            if (seed === gameData.galaxySeed) {
                // Current galaxy
                galaxyInfo = {
                    ignitedBy: gameData.firstIgnition?.ignitedBy || gameData.playerName || 'You',
                    destroyed: gameData.destroyedPlanets?.length || 0,
                    escaped: gameData.escapedPlanets?.length || 0,
                    visited: gameData.visitedPlanets?.length || 0
                };
            } else {
                // Historical galaxy
                const histGalaxy = gameData.galaxyHistory?.find(g => g.seed === seed);
                if (histGalaxy) {
                    galaxyInfo = {
                        ignitedBy: histGalaxy.ignitedBy || 'Unknown',
                        destroyed: histGalaxy.destroyedPlanets?.length || 0,
                        escaped: histGalaxy.escapedPlanets?.length || 0,
                        visited: histGalaxy.visitedPlanets?.length || 0
                    };
                }
            }

            // Update ignition display
            if (ignitedByEl && galaxyInfo) {
                ignitedByEl.textContent = galaxyInfo.ignitedBy;
            }
            if (stateEl && galaxyInfo) {
                const active = CONFIG.NUM_CIVS - galaxyInfo.destroyed - galaxyInfo.escaped;
                stateEl.innerHTML = `${active} planets active` +
                    (galaxyInfo.destroyed > 0 ? `  <span style="color:#ff6666">${galaxyInfo.destroyed} destroyed</span>` : '') +
                    (galaxyInfo.escaped > 0 ? `  <span style="color:#ffaa00">${galaxyInfo.escaped} escaped</span>` : '') +
                    (galaxyInfo.visited > 0 ? `  <span style="color:#66ff66">${galaxyInfo.visited} visited</span>` : '');
            }

            // Generate QR code
            container.innerHTML = '<div style="color: #666; padding: 20px;">Generating...</div>';

            loadQRiousLibrary().then(() => {
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: url,
                    size: 180,
                    background: 'white',
                    foreground: '#1a0033',
                    level: 'H'
                });
            }).catch(() => {
                // Fallback to API
                container.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=${encodeURIComponent(url)}&color=1a0033" alt="QR Code">`;
            });

            overlay.classList.add('active');
        }

        // Close QR overlay
        function closeGalaxyQROverlay() {
            const overlay = document.getElementById('galaxy-qr-overlay');
            if (overlay) overlay.classList.remove('active');
            currentQRGalaxy = null;
        }

        // Copy galaxy URL to clipboard
        function copyGalaxyUrl() {
            if (!currentQRGalaxy) return;

            const url = getGalaxyUrl(currentQRGalaxy.seed, currentQRGalaxy.number);
            navigator.clipboard.writeText(url).then(() => {
                showNotification(' Galaxy URL copied!', 'success');
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = url;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showNotification(' Galaxy URL copied!', 'success');
            });
        }

        // Share galaxy (copy URL)
        function shareGalaxy(seed, number) {
            const url = getGalaxyUrl(seed, number);
            navigator.clipboard.writeText(url).then(() => {
                showNotification(' Galaxy link copied to clipboard!', 'success');
            }).catch(() => {
                // Show QR as fallback
                showGalaxyQR(seed, number, `Galaxy #${number}`);
            });
        }

        // Import galaxy from URL
        function importGalaxyFromUrl() {
            const url = prompt('Paste a galaxy URL to visit:');
            if (!url) return;

            try {
                const urlObj = new URL(url);
                const params = new URLSearchParams(urlObj.search);
                const galaxySeed = params.get('galaxy');
                const galaxyNum = parseInt(params.get('gnum')) || 1;

                if (galaxySeed) {
                    closeGalaxyManager();
                    showNotification(' Importing galaxy...', 'info');
                    setTimeout(() => {
                        travelToGalaxy(decodeURIComponent(galaxySeed), galaxyNum);
                    }, 500);
                } else {
                    showNotification('Invalid galaxy URL', 'error');
                }
            } catch (e) {
                showNotification('Invalid URL format', 'error');
            }
        }

        // Expose Galaxy Manager functions to window for inline onclick handlers
        window.openGalaxyManager = openGalaxyManager;
        window.closeGalaxyManager = closeGalaxyManager;
        window.filterGalaxies = filterGalaxies;
        window.warpToGalaxy = warpToGalaxy;
        window.renameGalaxy = renameGalaxy;
        window.showGalaxyQR = showGalaxyQR;
        window.closeGalaxyQROverlay = closeGalaxyQROverlay;
        window.copyGalaxyUrl = copyGalaxyUrl;
        window.shareGalaxy = shareGalaxy;
        window.importGalaxyFromUrl = importGalaxyFromUrl;

        // Open Show Mode modal with QR code
        // Current share mode state
        let currentShareMode = 'spectate';

        function openShowModeModal() {
            const modal = document.getElementById('show-mode-modal');
            modal.style.display = 'flex';
            p2pStreaming.qrCodeVisible = true;

            // Default to multiplayer mode if on a planet, spectate otherwise
            if (mode === 'world' && activeCiv) {
                setShareMode('multiplayer');
            } else {
                setShareMode('spectate');
            }

            updateP2PStatusUI();
        }

        // Toggle between spectate and multiplayer share modes
        function setShareMode(shareMode) {
            currentShareMode = shareMode;

            const tabSpectate = document.getElementById('tab-spectate');
            const tabAntfarm = document.getElementById('tab-antfarm');
            const tabMultiplayer = document.getElementById('tab-multiplayer');
            const tabVersus = document.getElementById('tab-versus');
            const descEl = document.getElementById('share-mode-desc');
            const infoEl = document.getElementById('show-mode-info');
            const planetInfoEl = document.getElementById('planet-info');

            // Reset all tabs
            tabSpectate.style.background = 'transparent';
            tabSpectate.style.borderColor = 'rgba(0,255,255,0.3)';
            if (tabAntfarm) {
                tabAntfarm.style.background = 'transparent';
                tabAntfarm.style.borderColor = 'rgba(0,255,136,0.3)';
            }
            tabMultiplayer.style.background = 'transparent';
            tabMultiplayer.style.borderColor = 'rgba(255,100,0,0.3)';
            if (tabVersus) {
                tabVersus.style.background = 'transparent';
                tabVersus.style.borderColor = 'rgba(255,0,100,0.3)';
            }

            if (shareMode === 'spectate') {
                // Spectate mode styling
                tabSpectate.style.background = 'rgba(0,255,255,0.2)';
                tabSpectate.style.borderColor = 'rgba(0,255,255,0.5)';

                descEl.textContent = 'Others can watch your exploration in real-time';
                infoEl.textContent = ' Spectate Mode - Viewers see what you see!';
                infoEl.style.background = 'rgba(0,255,255,0.1)';
                infoEl.style.borderColor = 'rgba(0,255,255,0.3)';
                infoEl.style.color = '#06ffa5';
                planetInfoEl.style.display = 'none';

                // Generate spectator QR code
                generateSpectatorQRCode();

                // Update URL display
                if (p2pStreaming.peerId) {
                    const spectatorUrl = `${window.location.origin}${window.location.pathname}?spectate=${p2pStreaming.peerId}`;
                    document.getElementById('qr-url').textContent = spectatorUrl;
                } else {
                    document.getElementById('qr-url').textContent = 'Connecting to P2P network...';
                }
            } else if (shareMode === 'antfarm') {
                // v6.85: Ant Farm spectator mode - 3D overhead ecosystem view
                if (tabAntfarm) {
                    tabAntfarm.style.background = 'rgba(0,255,136,0.2)';
                    tabAntfarm.style.borderColor = 'rgba(0,255,136,0.5)';
                }

                descEl.textContent = 'Watch the world from above like an ant farm!';
                infoEl.style.background = 'rgba(0,255,136,0.1)';
                infoEl.style.borderColor = 'rgba(0,255,136,0.3)';
                infoEl.style.color = '#0f8';

                if (mode === 'world' && activeCiv) {
                    infoEl.textContent = ` ANT FARM VIEW - Observe ${activeCiv.name} from orbit!`;
                    planetInfoEl.textContent = `Planet: ${activeCiv.name} | Mobs: ${worldState.mobs?.length || 0} | Trees: ${worldState.interactables?.filter(i => i.userData?.type === 'tree').length || 0}`;
                    planetInfoEl.style.display = 'block';
                } else {
                    infoEl.textContent = ' ANT FARM VIEW - Must be on a planet!';
                    planetInfoEl.textContent = 'Land on a planet first to share ant farm view';
                    planetInfoEl.style.display = 'block';
                }

                // Generate ant farm QR code
                generateAntFarmQRCode();

                // Update URL display
                if (p2pStreaming.peerId && mode === 'world') {
                    const antfarmUrl = getAntFarmSpectatorUrl();
                    document.getElementById('qr-url').textContent = antfarmUrl || 'Connecting...';
                } else {
                    document.getElementById('qr-url').textContent = mode !== 'world' ? 'Land on a planet first' : 'Connecting to P2P network...';
                }
            } else if (shareMode === 'versus') {
                // v6.68: Versus mode styling
                if (tabVersus) {
                    tabVersus.style.background = 'rgba(255,0,100,0.2)';
                    tabVersus.style.borderColor = 'rgba(255,0,100,0.5)';
                }

                descEl.textContent = 'Challenge them to a DOTA 2-style throne battle!';
                infoEl.style.background = 'rgba(255,0,100,0.1)';
                infoEl.style.borderColor = 'rgba(255,0,100,0.3)';
                infoEl.style.color = '#f08';

                if (mode === 'world' && activeCiv) {
                    infoEl.textContent = ` VERSUS MODE - Destroy their throne on ${activeCiv.name}!`;
                    planetInfoEl.textContent = `Arena: ${activeCiv.name} (${activeCiv.biomeName}) | War horn sounds at match start!`;
                    planetInfoEl.style.display = 'block';
                } else {
                    infoEl.textContent = ' VERSUS MODE - Must be on a planet to challenge!';
                    planetInfoEl.textContent = 'Land on a planet first to enable versus mode';
                    planetInfoEl.style.display = 'block';
                }

                // Generate versus QR code
                if (typeof generateVersusQRCode === 'function') {
                    generateVersusQRCode();
                }

                // Update URL display
                if (typeof getVersusMatchUrl === 'function') {
                    const versusUrl = getVersusMatchUrl();
                    if (versusUrl) {
                        document.getElementById('qr-url').textContent = versusUrl;
                    } else {
                        document.getElementById('qr-url').textContent = 'Connecting to P2P network...';
                    }
                }
            } else {
                // Multiplayer co-op mode styling
                tabMultiplayer.style.background = 'rgba(255,100,0,0.2)';
                tabMultiplayer.style.borderColor = 'rgba(255,100,0,0.5)';

                descEl.textContent = 'Others join your world and play together!';
                infoEl.style.background = 'rgba(255,100,0,0.1)';
                infoEl.style.borderColor = 'rgba(255,100,0,0.3)';
                infoEl.style.color = '#f80';

                // Show planet info if on a planet
                if (mode === 'world' && activeCiv) {
                    infoEl.textContent = ` Co-op Mode - They land on ${activeCiv.name}!`;
                    planetInfoEl.textContent = `Planet: ${activeCiv.name} (${activeCiv.biomeName}) | Seed: ${multiplayerState.worldSeed}`;
                    planetInfoEl.style.display = 'block';
                } else {
                    infoEl.textContent = ' Co-op Mode - They join your galaxy!';
                    planetInfoEl.textContent = `Seed: ${multiplayerState.worldSeed}`;
                    planetInfoEl.style.display = 'block';
                }

                // Generate multiplayer QR code
                generateMultiplayerQRCode();

                // Update URL display
                const multiplayerUrl = getMultiplayerJoinUrl();
                if (multiplayerUrl) {
                    document.getElementById('qr-url').textContent = multiplayerUrl;
                } else {
                    document.getElementById('qr-url').textContent = 'Connecting to P2P network...';
                }
            }
        }

        // Close Show Mode modal
        function closeShowModeModal() {
            const modal = document.getElementById('show-mode-modal');
            modal.style.display = 'none';
            p2pStreaming.qrCodeVisible = false;
            updateP2PStatusUI();
        }

        // Copy URL from Show Mode modal - respects current share mode (spectate vs multiplayer)
        function copyShowModeUrl() {
            if (!p2pStreaming.peerId) {
                showNotification('Not connected yet', 'error');
                return;
            }

            // Get the correct URL based on current share mode
            let urlToCopy;
            let notificationText;

            if (currentShareMode === 'versus') {
                urlToCopy = typeof getVersusMatchUrl === 'function' ? getVersusMatchUrl() : null;
                notificationText = ' Versus challenge link copied!';
            } else if (currentShareMode === 'multiplayer') {
                urlToCopy = getMultiplayerJoinUrl();
                notificationText = ' Co-op join link copied!';
            } else if (currentShareMode === 'antfarm') {
                // v6.85: Ant Farm spectator mode
                urlToCopy = getAntFarmSpectatorUrl();
                notificationText = ' Ant Farm view link copied!';
            } else {
                urlToCopy = `${window.location.origin}${window.location.pathname}?spectate=${p2pStreaming.peerId}`;
                notificationText = ' Spectator link copied!';
            }

            if (!urlToCopy) {
                showNotification('Failed to generate link', 'error');
                return;
            }

            const btn = document.getElementById('copy-url-btn');

            navigator.clipboard.writeText(urlToCopy).then(() => {
                showNotification(notificationText, 'info');
                btn.textContent = 'COPIED!';
                btn.style.background = 'linear-gradient(45deg, #06ffa5, #00ff88)';
                setTimeout(() => {
                    btn.textContent = 'COPY URL';
                    btn.style.background = 'linear-gradient(45deg, #00ffff, #0088ff)';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = urlToCopy;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showNotification(notificationText, 'info');
                btn.textContent = 'COPIED!';
                btn.style.background = 'linear-gradient(45deg, #06ffa5, #00ff88)';
                setTimeout(() => {
                    btn.textContent = 'COPY URL';
                    btn.style.background = 'linear-gradient(45deg, #00ffff, #0088ff)';
                }, 2000);
            });
        }

        // Legacy function for compatibility
        function toggleMinimapShare() {
            if (p2pStreaming.qrCodeVisible) {
                closeShowModeModal();
            } else {
                openShowModeModal();
            }
        }

        // Legacy copy function
        function copyShareLink(event) {
            if (event) event.stopPropagation();
            copyShowModeUrl();
        }

        // Update P2P status UI
        function updateP2PStatusUI() {
            const statusEl = document.getElementById('p2p-status');
            const countEl = document.getElementById('spectator-count');

            if (statusEl) {
                statusEl.textContent = p2pStreaming.isHost ?
                    (p2pStreaming.qrCodeVisible ? ' STREAMING' : ' PRIVATE') :
                    ' SPECTATING';
                statusEl.style.color = p2pStreaming.qrCodeVisible ? '#00ff88' : '#888';
            }
            if (countEl) {
                countEl.textContent = p2pStreaming.spectatorCount > 0 ?
                    `${p2pStreaming.spectatorCount} ` : '';
            }
        }

        // Check URL for spectator mode on load
        // NOTE: This is now handled by checkMultiplayerMode() which handles all P2P modes
        function checkSpectatorMode() {
            // Spectator mode is now handled in checkMultiplayerMode() to avoid duplicate P2P initialization
            // This function only initializes P2P host if NOT being called from multiplayer mode
            const params = new URLSearchParams(window.location.search);
            const spectateId = params.get('spectate');
            const joinId = params.get('join');

            // Only init P2P host here if not joining/spectating (will be handled by checkMultiplayerMode)
            if (!spectateId && !joinId) {
                setTimeout(initP2PHost, 2000);
            }
        }

        // Initialize Show Mode button event listeners (called after DOM ready)
        function initShowModeButtons() {
            const closeBtn = document.getElementById('close-show-mode-btn');
            const copyBtn = document.getElementById('copy-url-btn');
            const modal = document.getElementById('show-mode-modal');

            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeShowModeModal();
                });
                // Hover effects
                closeBtn.addEventListener('mouseover', function() {
                    this.style.color = '#ff006e';
                    this.style.transform = 'rotate(90deg)';
                });
                closeBtn.addEventListener('mouseout', function() {
                    this.style.color = '#fff';
                    this.style.transform = 'rotate(0deg)';
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    copyShowModeUrl();
                });
                // Hover effects
                copyBtn.addEventListener('mouseover', function() {
                    this.style.transform = 'translateY(-2px)';
                    this.style.boxShadow = '0 4px 20px rgba(0,255,255,0.4)';
                });
                copyBtn.addEventListener('mouseout', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = 'none';
                });
            }

            // Close modal when clicking outside content
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeShowModeModal();
                    }
                });
            }

            console.log('Show Mode buttons initialized');
        }

        // ==========================================
        // ENHANCED MULTIPLAYER SYSTEM
        // Full state transfer + delta updates for synchronized gameplay
        // ==========================================

        // Multiplayer state object
        let multiplayerState = {
            enabled: false,
            isHost: true,
            hostId: null,
            players: new Map(),           // All connected players (peerId -> playerData)
            remotePlayers: new Map(),     // Remote player meshes (peerId -> THREE.Group)
            localPlayerId: null,
            stateVersion: 0,              // Incremented on each state change
            lastSyncTime: 0,
            syncInterval: 50,             // Delta sync every 50ms
            fullSyncInterval: 5000,       // Full state sync every 5 seconds
            lastFullSync: 0,
            pendingDeltas: [],            // Queue of pending delta updates
            deltaBuffer: [],              // Buffer for received deltas
            connectionTimeout: 10000,     // Connection timeout in ms
            // WORLD SEED - ensures identical procedural generation across all clients
            // All terrain, props, mobs, and civilizations use this seed
            worldSeed: 'OMNIVERSE',       // Default seed, can be overridden via URL

            // FOLLOW MODE - allows viewers to switch between following host and independent control
            followMode: true,              // true = camera follows host, false = independent control
            savedHostPosition: null,       // Cache host's last position for snap-back
            lastHostRotation: 0,           // Cache host's last rotation
            lastModeToggleTime: 0,         // Debounce rapid mode switching
            viewerSpawnedAt: null          // Position where viewer spawned for independent mode
        };

        // Remote player colors for distinguishing players
        const PLAYER_COLORS = [
            0x00ff88, 0xff6600, 0x00aaff, 0xff00ff,
            0xffff00, 0x00ffff, 0xff0088, 0x88ff00
        ];

        // Generate a unique player ID
        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Get a color for a player based on index
        function getPlayerColor(index) {
            return PLAYER_COLORS[index % PLAYER_COLORS.length];
        }

        // ==========================================
        // FULL STATE CAPTURE
        // Captures complete game state for new joiners
        // ==========================================

        function captureFullGameState() {
            // Safety checks for potentially undefined globals
            const safeWorldState = typeof worldState !== 'undefined' ? worldState : { interactables: [], mobs: [], structures: [], timeOfDay: 0 };
            const safeGameData = typeof gameData !== 'undefined' ? gameData : { player: {}, inventory: [] };
            const safeRobotEnergy = typeof robotEnergy !== 'undefined' ? robotEnergy : { current: 100, max: 100 };
            const safeAgentFleet = typeof agentFleet !== 'undefined' ? agentFleet : [];
            const safeActiveCiv = typeof activeCiv !== 'undefined' ? activeCiv : null;
            const safeMode = typeof mode !== 'undefined' ? mode : 'world';

            const fullState = {
                type: 'fullState',
                version: ++multiplayerState.stateVersion,
                timestamp: Date.now(),
                hostId: multiplayerState.localPlayerId,

                // WORLD SEED - critical for deterministic terrain/mob/prop generation
                worldSeed: multiplayerState.worldSeed,

                // World state
                world: {
                    timeOfDay: safeWorldState.timeOfDay || 0,
                    player: safeWorldState.player ? {
                        position: {
                            x: safeWorldState.player.position?.x || 0,
                            y: safeWorldState.player.position?.y || 0,
                            z: safeWorldState.player.position?.z || 0
                        },
                        rotation: safeWorldState.player.rotation?.y || 0,
                        hp: safeGameData.player?.hp || 100,
                        maxHp: safeGameData.player?.maxHp || 100
                    } : null
                },

                // Robot energy
                energy: {
                    current: safeRobotEnergy.current || 100,
                    max: safeRobotEnergy.max || 100
                },

                // FULL interactables data for world sync (trees, rocks, fishing spots)
                interactables: (safeWorldState.interactables || []).map(obj => ({
                    id: obj.userData?.id || obj.uuid,
                    type: obj.userData?.type || 'unknown',
                    name: obj.userData?.name || 'unknown',
                    position: { x: obj.position?.x || 0, y: obj.position?.y || 0, z: obj.position?.z || 0 },
                    rotation: { x: obj.rotation?.x || 0, y: obj.rotation?.y || 0, z: obj.rotation?.z || 0 },
                    hp: obj.userData?.hp || 0,
                    maxHp: obj.userData?.maxHp || 0,
                    active: obj.parent !== null
                })),

                // Weather state - host is authoritative
                weather: {
                    current: typeof currentWeather !== 'undefined' ? currentWeather : 'clear',
                    changeTime: typeof weatherChangeTime !== 'undefined' ? weatherChangeTime : 0
                },

                // Mobs
                mobs: (safeWorldState.mobs || []).slice(0, 50).map(mob => ({
                    id: mob.userData?.id || mob.uuid,
                    type: mob.userData?.name || 'enemy',
                    position: { x: mob.position?.x || 0, y: mob.position?.y || 0, z: mob.position?.z || 0 },
                    hp: mob.userData?.hp || 100,
                    maxHp: mob.userData?.maxHp || 100
                })),

                // Structures
                structures: (safeWorldState.structures || []).map(s => ({
                    id: s.id,
                    type: s.type,
                    worldX: s.worldX,
                    worldZ: s.worldZ,
                    efficiency: s.efficiency
                })),

                // Agent fleet
                agents: safeAgentFleet.map(a => ({
                    id: a.id,
                    name: a.name,
                    type: a.type,
                    position: a.mesh ? {
                        x: a.mesh.position?.x || 0,
                        y: a.mesh.position?.y || 0,
                        z: a.mesh.position?.z || 0
                    } : null,
                    status: a.statusMessage,
                    level: a.level,
                    xp: a.xp
                })),

                // Current civilization - includes ID for joining players to load same planet
                civilization: safeActiveCiv ? {
                    id: safeActiveCiv.id,
                    name: safeActiveCiv.name,
                    biome: safeActiveCiv.biome,
                    biomeName: safeActiveCiv.biomeName,
                    // Position in galaxy for reference
                    galaxyPosition: { x: safeActiveCiv.x, y: safeActiveCiv.y, z: safeActiveCiv.z }
                } : null,

                // Host player spawn position - for joining players to spawn nearby
                hostSpawnPosition: safeWorldState.player ? {
                    x: safeWorldState.player.position?.x || 0,
                    y: safeWorldState.player.position?.y || 0,
                    z: safeWorldState.player.position?.z || 0
                } : { x: 0, y: 2, z: 0 },

                // Game mode
                mode: safeMode,

                // Inventory summary (gameData.inventory is an array of {name, amount} objects)
                inventory: (safeGameData.inventory || []).filter(i => i && i.name).map(i => ({ name: i.name, count: i.amount || 1 })),

                // All connected players
                players: Array.from(multiplayerState.players.entries()).map(([id, data]) => ({
                    id,
                    name: data.name,
                    position: data.position,
                    rotation: data.rotation,
                    color: data.color
                }))
            };

            return fullState;
        }

        // ==========================================
        // DELTA UPDATE SYSTEM
        // Efficient incremental updates
        // ==========================================

        function createDelta(deltaType, data) {
            return {
                type: 'delta',
                deltaType: deltaType,
                version: multiplayerState.stateVersion,
                timestamp: Date.now(),
                senderId: multiplayerState.localPlayerId,
                data: data
            };
        }

        // Capture player movement delta - v6.0: NOW SYNCS ALL VISUAL STATE
        function capturePlayerDelta() {
            // Safety checks
            if (typeof worldState === 'undefined' || !worldState.player) return null;
            const safeGameData = typeof gameData !== 'undefined' ? gameData : { player: { hp: 100, maxHp: 100 } };
            const safeRobotEnergy = typeof robotEnergy !== 'undefined' ? robotEnergy : { current: 100, max: 100 };
            const safeCamera = typeof camera !== 'undefined' ? camera : null;
            const safeWeather = typeof currentWeather !== 'undefined' ? currentWeather : 'clear';

            return createDelta('playerMove', {
                // Position and rotation
                position: {
                    x: worldState.player.position?.x || 0,
                    y: worldState.player.position?.y || 0,
                    z: worldState.player.position?.z || 0
                },
                rotation: worldState.player.rotation?.y || 0,
                camera: safeCamera ? {
                    position: {
                        x: safeCamera.position?.x || 0,
                        y: safeCamera.position?.y || 0,
                        z: safeCamera.position?.z || 0
                    },
                    rotation: {
                        x: safeCamera.rotation?.x || 0,
                        y: safeCamera.rotation?.y || 0,
                        z: safeCamera.rotation?.z || 0
                    }
                } : null,

                // v6.0: FULL STATE SYNC - All visual indicators
                // Probe Integrity (HP)
                hp: safeGameData.player?.hp || 100,
                maxHp: safeGameData.player?.maxHp || 100,

                // Energy
                energy: safeRobotEnergy.current || 100,
                maxEnergy: safeRobotEnergy.max || 100,

                // Time and Weather
                timeOfDay: worldState.timeOfDay || 0,
                weather: safeWeather,

                // Daily Challenge progress
                dailyChallenge: safeGameData.dailyChallenge ? {
                    current: safeGameData.dailyChallenge.current,
                    completed: safeGameData.dailyChallenge.completed,
                    streak: safeGameData.dailyChallenge.streak
                } : null,

                // Ship status
                ship: typeof SHIP_STATE !== 'undefined' ? {
                    hp: SHIP_STATE.hp,
                    maxHp: SHIP_STATE.maxHp,
                    defenseOn: SHIP_STATE.laser?.autoDefend || false
                } : null
            });
        }

        // Capture mob state delta
        function captureMobDelta(mob, action) {
            return createDelta('mobUpdate', {
                id: mob.userData?.id || mob.uuid,
                action: action, // 'spawn', 'move', 'damage', 'death'
                position: { x: mob.position.x, y: mob.position.y, z: mob.position.z },
                hp: mob.userData?.hp,
                type: mob.userData?.name
            });
        }

        // Capture resource interaction delta
        function captureResourceDelta(resource, action) {
            return createDelta('resourceUpdate', {
                id: resource.userData?.id || resource.uuid,
                action: action, // 'harvest', 'deplete', 'respawn'
                type: resource.userData?.name,
                position: resource.position ? {
                    x: resource.position.x,
                    y: resource.position.y,
                    z: resource.position.z
                } : null
            });
        }

        // Capture structure delta
        function captureStructureDelta(structure, action) {
            return createDelta('structureUpdate', {
                id: structure.id,
                action: action, // 'build', 'upgrade', 'destroy'
                type: structure.type,
                worldX: structure.worldX,
                worldZ: structure.worldZ,
                efficiency: structure.efficiency
            });
        }

        // ==========================================
        // APPLY RECEIVED STATE
        // Apply full state or delta updates from remote
        // ==========================================

        function applyFullState(state) {
            console.log('Applying full game state from host, version:', state.version);
            multiplayerState.stateVersion = state.version;

            // CRITICAL: Use the same world seed as the host
            if (state.worldSeed) {
                multiplayerState.worldSeed = state.worldSeed;
                console.log('Synced world seed from host:', multiplayerState.worldSeed);
            }

            // Check if we need to initialize the world or just sync positions
            if (state.civilization && state.civilization.id !== undefined) {
                const hostCiv = state.civilization;
                const currentPlanetId = activeCiv ? activeCiv.id : null;

                // If we're not on the same planet as the host, load that planet
                if (currentPlanetId !== hostCiv.id) {
                    console.log(`Landing on host planet: ${hostCiv.name} (ID: ${hostCiv.id}, Biome: ${hostCiv.biome})`);

                    // USE THE HOST'S EXACT CIVILIZATION DATA - this ensures:
                    // 1. Same civ.id for noise(x + civ.id, z + civ.id) terrain generation
                    // 2. Same civ.name for SeededRNG(civ.name) prop generation
                    // 3. Same civ.biome for correct textures/colors
                    const targetCiv = {
                        id: hostCiv.id,
                        name: hostCiv.name,
                        biome: hostCiv.biome,
                        biomeName: hostCiv.biomeName,
                        // Galaxy position (for reference)
                        x: hostCiv.galaxyPosition?.x || 0,
                        y: hostCiv.galaxyPosition?.y || 0,
                        z: hostCiv.galaxyPosition?.z || 0,
                        // Defaults
                        color: new THREE.Color(0x00ff88),
                        pop: 0,
                        visited: true
                    };

                    console.log('Using host civilization data:', targetCiv);
                    showNotification(` Landing on ${targetCiv.name}...`, 'info');

                    // Initialize world with host's exact civilization data
                    // Props will be skipped (isMultiplayerJoiner=true) and synced from host
                    initWorld(targetCiv, true);

                    // Hide loading screen
                    document.getElementById('loading').style.display = 'none';
                } else {
                    console.log('Already on correct planet:', hostCiv.name);
                }

                // ALWAYS position player near host when receiving full state
                setTimeout(() => {
                    if (worldState.player && state.hostSpawnPosition) {
                        // Spawn player near host (offset slightly to avoid overlap)
                        const offsetX = (Math.random() - 0.5) * 6;
                        const offsetZ = (Math.random() - 0.5) * 6;
                        worldState.player.position.set(
                            state.hostSpawnPosition.x + offsetX,
                            state.hostSpawnPosition.y + 0.5,
                            state.hostSpawnPosition.z + offsetZ
                        );
                        console.log('Positioned near host at:', worldState.player.position);
                        showNotification(' Synced with host!', 'info');
                    }
                }, 300);
            }

            // Apply world time
            if (state.world && state.world.timeOfDay !== undefined) {
                worldState.timeOfDay = state.world.timeOfDay;
            }

            // Apply energy
            if (state.energy) {
                robotEnergy.current = state.energy.current;
                robotEnergy.max = state.energy.max;
            }

            // SYNC WEATHER from host
            if (state.weather) {
                if (typeof currentWeather !== 'undefined' && state.weather.current !== currentWeather) {
                    currentWeather = state.weather.current;
                    console.log('Synced weather from host:', currentWeather);
                    // Update weather UI indicator
                    if (typeof updateWeatherUI === 'function') {
                        updateWeatherUI();
                    }
                }
                if (typeof weatherChangeTime !== 'undefined') {
                    weatherChangeTime = state.weather.changeTime;
                }
            }

            // SYNC INTERACTABLES from host - rebuild props to match host's world
            if (state.interactables && state.interactables.length > 0 && !multiplayerState.isHost) {
                syncInteractablesFromHost(state.interactables);
            }

            // SYNC MOBS from host
            if (state.mobs && state.mobs.length > 0 && !multiplayerState.isHost) {
                syncMobsFromHost(state.mobs);
            }

            // Update all connected players (including host)
            if (state.players) {
                state.players.forEach(playerData => {
                    if (playerData.id !== multiplayerState.localPlayerId) {
                        updateRemotePlayer(playerData.id, playerData);
                    }
                });
            }

            // Create avatar for host player
            if (state.hostId && state.world && state.world.player) {
                updateRemotePlayer(state.hostId, {
                    name: 'Host',
                    position: state.world.player.position,
                    rotation: state.world.player.rotation,
                    hp: state.world.player.hp,
                    maxHp: state.world.player.maxHp
                });
            }

            // Update multiplayer UI
            updateMultiplayerUI();

            // v6.0: Create follow mode button for viewers
            if (!multiplayerState.isHost) {
                createFollowModeButton();
            }
        }

        // Sync interactables (trees, rocks, fishing spots) from host
        function syncInteractablesFromHost(hostInteractables) {
            if (!worldState || !worldState.interactables) return;

            console.log(`Syncing ${hostInteractables.length} interactables from host`);

            // Clear existing interactables
            worldState.interactables.forEach(obj => {
                if (obj.parent) {
                    scene.remove(obj);
                }
            });
            worldState.interactables = [];

            // Recreate from host data
            const biome = activeCiv ? BIOMES[activeCiv.biome] : BIOMES.Terra;

            hostInteractables.forEach(data => {
                if (!data.active) return;

                const group = new THREE.Group();
                group.position.set(data.position.x, data.position.y, data.position.z);

                if (data.type === 'tree') {
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                        new THREE.MeshLambertMaterial({ color: 0x553311 })
                    );
                    trunk.position.y = 1;
                    trunk.castShadow = true;
                    group.add(trunk);

                    const leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(1.2, 2.5, 8),
                        new THREE.MeshLambertMaterial({ color: biome.tree })
                    );
                    leaves.position.y = 2.8;
                    leaves.castShadow = true;
                    group.add(leaves);
                    group.userData = { type: 'tree', hp: data.hp, maxHp: data.maxHp, name: data.name, id: data.id };
                } else if (data.type === 'rock') {
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(1),
                        new THREE.MeshLambertMaterial({ color: biome.rock })
                    );
                    rock.position.y = 0.5;
                    rock.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                    rock.castShadow = true;
                    group.add(rock);
                    group.userData = { type: 'rock', hp: data.hp, maxHp: data.maxHp, name: data.name, id: data.id };
                } else if (data.type === 'fishing') {
                    const ripple = new THREE.Mesh(
                        new THREE.RingGeometry(0.8, 1, 16),
                        new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
                    );
                    ripple.rotation.x = -Math.PI / 2;
                    group.add(ripple);
                    group.userData = { type: 'fishing', name: 'Fishing Spot', ripple, id: data.id };
                    worldState.fishingSpots.push(group);
                }

                scene.add(group);
                worldState.interactables.push(group);
            });

            console.log(`Synced ${worldState.interactables.length} interactables`);
        }

        // Sync mobs from host
        function syncMobsFromHost(hostMobs) {
            if (!worldState) return;

            console.log(`Syncing ${hostMobs.length} mobs from host`);

            // Update existing mobs or note missing ones
            hostMobs.forEach(mobData => {
                // Find existing mob by ID
                let existingMob = worldState.mobs.find(m =>
                    (m.userData?.id || m.uuid) === mobData.id
                );

                if (existingMob) {
                    // Update position
                    existingMob.position.set(mobData.position.x, mobData.position.y, mobData.position.z);
                    if (existingMob.userData) {
                        existingMob.userData.hp = mobData.hp;
                    }
                }
                // Note: We don't create mobs here - that would require more complex logic
                // The host's mob positions are synced for existing mobs
            });
        }

        function applyDelta(delta) {
            // Skip if sender is self
            if (delta.senderId === multiplayerState.localPlayerId) return;

            switch (delta.deltaType) {
                case 'playerMove':
                    // Check if this is the host's position update
                    const isHostPosition = (delta.senderId === multiplayerState.hostId);

                    // Always update the remote player avatar
                    updateRemotePlayer(delta.senderId, {
                        position: delta.data.position,
                        rotation: delta.data.rotation,
                        camera: delta.data.camera,
                        hp: delta.data.hp,
                        energy: delta.data.energy
                    });

                    // If this is the host, sync ALL their state to viewer
                    if (isHostPosition && !multiplayerState.isHost) {
                        multiplayerState.savedHostPosition = {
                            x: delta.data.position.x,
                            y: delta.data.position.y,
                            z: delta.data.position.z
                        };
                        multiplayerState.lastHostRotation = delta.data.rotation || 0;

                        // In follow mode, sync local player position to follow host
                        if (multiplayerState.followMode && worldState.player) {
                            const offsetDist = 5;
                            const offsetX = Math.sin(delta.data.rotation || 0) * offsetDist;
                            const offsetZ = Math.cos(delta.data.rotation || 0) * offsetDist;
                            const targetX = delta.data.position.x + offsetX;
                            const targetZ = delta.data.position.z + offsetZ;
                            worldState.player.position.x += (targetX - worldState.player.position.x) * 0.1;
                            worldState.player.position.z += (targetZ - worldState.player.position.z) * 0.1;
                            worldState.player.position.y = delta.data.position.y;
                        }

                        // ========================================
                        // v6.0: SYNC ALL HOST STATE TO VIEWER
                        // ========================================

                        // Time of Day
                        if (delta.data.timeOfDay !== undefined) {
                            worldState.timeOfDay = delta.data.timeOfDay;
                        }

                        // Weather
                        if (delta.data.weather && typeof currentWeather !== 'undefined') {
                            if (currentWeather !== delta.data.weather) {
                                currentWeather = delta.data.weather;
                                if (typeof updateWeatherUI === 'function') {
                                    updateWeatherUI();
                                }
                            }
                        }

                        // PROBE INTEGRITY (HP)
                        if (delta.data.hp !== undefined && delta.data.maxHp !== undefined) {
                            gameData.player.hp = delta.data.hp;
                            gameData.player.maxHp = delta.data.maxHp;
                            if (typeof updateHealthUI === 'function') {
                                updateHealthUI();
                            }
                        }

                        // ENERGY
                        if (delta.data.energy !== undefined && delta.data.maxEnergy !== undefined) {
                            robotEnergy.current = delta.data.energy;
                            robotEnergy.max = delta.data.maxEnergy;
                            if (typeof updateEnergyUI === 'function') {
                                updateEnergyUI();
                            }
                        }

                        // SHIP STATUS
                        if (delta.data.ship && typeof SHIP_STATE !== 'undefined') {
                            SHIP_STATE.hp = delta.data.ship.hp;
                            SHIP_STATE.maxHp = delta.data.ship.maxHp;
                            if (SHIP_STATE.laser) {
                                SHIP_STATE.laser.autoDefend = delta.data.ship.defenseOn;
                            }
                            if (typeof updateShipHPUI === 'function') {
                                updateShipHPUI();
                            }
                        }

                        // DAILY CHALLENGE
                        if (delta.data.dailyChallenge && typeof gameData !== 'undefined') {
                            gameData.dailyChallenge.current = delta.data.dailyChallenge.current;
                            gameData.dailyChallenge.completed = delta.data.dailyChallenge.completed;
                            gameData.dailyChallenge.streak = delta.data.dailyChallenge.streak;
                            if (typeof updateDailyChallengeUI === 'function') {
                                updateDailyChallengeUI();
                            }
                        }
                    }
                    break;

                case 'mobUpdate':
                    applyMobDelta(delta.data);
                    break;

                case 'resourceUpdate':
                    applyResourceDelta(delta.data);
                    break;

                case 'structureUpdate':
                    applyStructureDelta(delta.data);
                    break;

                case 'chat':
                    showNotification(` ${delta.data.playerName}: ${delta.data.message}`, 'info');
                    break;

                case 'playerJoin':
                    showNotification(` ${delta.data.name} joined the world!`, 'info');
                    createRemotePlayerAvatar(delta.senderId, delta.data);
                    break;

                case 'playerLeave':
                    showNotification(` ${delta.data.name} left the world`, 'info');
                    removeRemotePlayer(delta.senderId);
                    break;

                case 'worldEvent':
                    // v6.1: Handle critical system events from host
                    handleCriticalSystemEvent(delta.data);
                    break;
            }
        }

        function applyMobDelta(data) {
            // Find mob by ID and update
            const mob = worldState.mobs.find(m => (m.userData?.id || m.uuid) === data.id);
            if (mob) {
                if (data.action === 'death') {
                    // Remove mob
                    if (mob.parent) mob.parent.remove(mob);
                    worldState.mobs = worldState.mobs.filter(m => m !== mob);
                } else {
                    // Update position and HP
                    if (data.position) {
                        mob.position.set(data.position.x, data.position.y, data.position.z);
                    }
                    if (data.hp !== undefined && mob.userData) {
                        mob.userData.hp = data.hp;
                    }
                }
            }
        }

        function applyResourceDelta(data) {
            const resource = worldState.interactables.find(r => (r.userData?.id || r.uuid) === data.id);
            if (resource && data.action === 'deplete') {
                if (resource.parent) resource.parent.remove(resource);
                worldState.interactables = worldState.interactables.filter(r => r !== resource);
            }
        }

        function applyStructureDelta(data) {
            if (data.action === 'build') {
                // Structure was built by another player - handled by host
                showNotification(` Structure built at (${Math.floor(data.worldX)}, ${Math.floor(data.worldZ)})`, 'info');
            }
        }

        // ==========================================
        // REMOTE PLAYER AVATAR RENDERING
        // Creates and updates visual representation of other players
        // ==========================================

        function createRemotePlayerAvatar(playerId, playerData) {
            // Check if already exists
            if (multiplayerState.remotePlayers.has(playerId)) {
                return multiplayerState.remotePlayers.get(playerId);
            }

            // Create player group
            const playerGroup = new THREE.Group();
            playerGroup.name = `remote_player_${playerId}`;

            // Get player color
            const colorIndex = multiplayerState.players.size;
            const playerColor = playerData.color || getPlayerColor(colorIndex);

            // Robot body - similar to local player but different color
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: playerColor,
                metalness: 0.8,
                roughness: 0.2,
                emissive: playerColor,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.75;
            body.castShadow = true;
            playerGroup.add(body);

            // Head dome
            const headGeo = new THREE.SphereGeometry(0.5, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.5;
            head.rotation.x = Math.PI;
            playerGroup.add(head);

            // Eye glow
            const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({
                color: playerColor,
                transparent: true,
                opacity: 0.9
            });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.2, 1.4, 0.35);
            playerGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
            rightEye.position.set(0.2, 1.4, 0.35);
            playerGroup.add(rightEye);

            // Antenna with pulsing light
            const antennaGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
            const antennaMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const antenna = new THREE.Mesh(antennaGeo, antennaMat);
            antenna.position.set(0, 1.9, 0);
            playerGroup.add(antenna);

            const antennaTipGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const antennaTipMat = new THREE.MeshBasicMaterial({
                color: playerColor,
                transparent: true,
                opacity: 0.8
            });
            const antennaTip = new THREE.Mesh(antennaTipGeo, antennaTipMat);
            antennaTip.position.set(0, 2.15, 0);
            playerGroup.add(antennaTip);
            playerGroup.userData.antennaTip = antennaTip;

            // Name tag sprite
            const nameCanvas = document.createElement('canvas');
            nameCanvas.width = 256;
            nameCanvas.height = 64;
            const ctx = nameCanvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.roundRect(0, 0, 256, 64, 10);
            ctx.fill();
            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = '#' + playerColor.toString(16).padStart(6, '0');
            ctx.textAlign = 'center';
            ctx.fillText(playerData.name || 'Player', 128, 42);

            const nameTexture = new THREE.CanvasTexture(nameCanvas);
            const nameMaterial = new THREE.SpriteMaterial({ map: nameTexture, transparent: true });
            const nameSprite = new THREE.Sprite(nameMaterial);
            nameSprite.scale.set(2.5, 0.625, 1);
            nameSprite.position.y = 2.8;
            playerGroup.add(nameSprite);

            // Point light for glow effect
            const playerLight = new THREE.PointLight(playerColor, 0.5, 5);
            playerLight.position.y = 1;
            playerGroup.add(playerLight);
            playerGroup.userData.light = playerLight;

            // Set initial position
            if (playerData.position) {
                playerGroup.position.set(
                    playerData.position.x,
                    playerData.position.y || 0,
                    playerData.position.z
                );
            }

            // Add to scene
            scene.add(playerGroup);

            // Store reference
            multiplayerState.remotePlayers.set(playerId, playerGroup);
            multiplayerState.players.set(playerId, {
                name: playerData.name || 'Player',
                color: playerColor,
                position: playerData.position || { x: 0, y: 0, z: 0 },
                rotation: playerData.rotation || 0,
                lastUpdate: Date.now()
            });

            console.log(`Created remote player avatar for ${playerId}`);
            return playerGroup;
        }

        function updateRemotePlayer(playerId, data) {
            let playerGroup = multiplayerState.remotePlayers.get(playerId);

            // Create if doesn't exist
            if (!playerGroup) {
                playerGroup = createRemotePlayerAvatar(playerId, data);
            }

            // Update player data
            const playerData = multiplayerState.players.get(playerId) || {};
            if (data.position) {
                playerData.position = data.position;

                // Smooth interpolation to target position
                const targetPos = new THREE.Vector3(
                    data.position.x,
                    data.position.y || 0,
                    data.position.z
                );
                playerGroup.position.lerp(targetPos, 0.3);
            }

            if (data.rotation !== undefined) {
                playerData.rotation = data.rotation;
                playerGroup.rotation.y = data.rotation;
            }

            playerData.lastUpdate = Date.now();
            playerData.hp = data.hp;
            playerData.energy = data.energy;

            multiplayerState.players.set(playerId, playerData);
        }

        function removeRemotePlayer(playerId) {
            const playerGroup = multiplayerState.remotePlayers.get(playerId);
            if (playerGroup) {
                scene.remove(playerGroup);
                // Dispose geometries and materials
                playerGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            multiplayerState.remotePlayers.delete(playerId);
            multiplayerState.players.delete(playerId);
        }

        // Animate remote player effects and smooth position interpolation
        function animateRemotePlayers(time) {
            multiplayerState.remotePlayers.forEach((playerGroup, playerId) => {
                const playerData = multiplayerState.players.get(playerId);

                // Smooth position interpolation towards target
                if (playerData && playerData.position) {
                    const targetPos = new THREE.Vector3(
                        playerData.position.x,
                        playerData.position.y || 0,
                        playerData.position.z
                    );
                    playerGroup.position.lerp(targetPos, 0.15); // Smooth interpolation each frame
                }

                // Smooth rotation interpolation
                if (playerData && playerData.rotation !== undefined) {
                    // Lerp rotation
                    const currentRot = playerGroup.rotation.y;
                    const targetRot = playerData.rotation;
                    playerGroup.rotation.y = currentRot + (targetRot - currentRot) * 0.15;
                }

                // Pulse antenna tip
                if (playerGroup.userData.antennaTip) {
                    const pulse = Math.sin(time * 3 + playerId.charCodeAt(0)) * 0.3 + 0.7;
                    playerGroup.userData.antennaTip.material.opacity = pulse;
                }

                // Pulse light
                if (playerGroup.userData.light) {
                    playerGroup.userData.light.intensity = 0.3 + Math.sin(time * 2) * 0.2;
                }

                // Bob animation for remote players
                if (playerGroup.userData.bodyCore) {
                    playerGroup.userData.bodyCore.position.y = 0.75 + Math.sin(time * 2) * 0.05;
                }

                // Check for stale connections (no update in 5 seconds)
                if (playerData && Date.now() - playerData.lastUpdate > 5000) {
                    console.log(`Player ${playerId} connection stale, removing...`);
                    removeRemotePlayer(playerId);
                }
            });
        }

        // ==========================================
        // MULTIPLAYER CONNECTION MANAGEMENT
        // Enhanced PeerJS integration
        // ==========================================

        function initMultiplayerHost() {
            if (!p2pStreaming.peer) {
                console.log('PeerJS not initialized, waiting...');
                setTimeout(initMultiplayerHost, 1000);
                return;
            }

            multiplayerState.enabled = true;
            multiplayerState.isHost = true;
            multiplayerState.localPlayerId = generatePlayerId();
            multiplayerState.hostId = p2pStreaming.peerId;

            console.log('Multiplayer host initialized:', multiplayerState.localPlayerId);

            // Override the existing connection handler for multiplayer
            p2pStreaming.peer.off('connection');
            p2pStreaming.peer.on('connection', handleMultiplayerConnection);
        }

        function handleMultiplayerConnection(conn) {
            console.log('New multiplayer connection:', conn.peer);

            conn.on('open', () => {
                // Add to connections
                p2pStreaming.connections.push(conn);
                p2pStreaming.spectatorCount = p2pStreaming.connections.length;
                updateP2PStatusUI();

                // Send full game state to new player
                const fullState = captureFullGameState();
                conn.send(fullState);
                console.log('Sent full state to new player');

                // Store connection reference in player data
                const playerId = conn.metadata?.playerId || generatePlayerId();
                multiplayerState.players.set(playerId, {
                    connection: conn,
                    name: conn.metadata?.playerName || 'Player',
                    position: { x: 0, y: 0, z: 0 },
                    rotation: 0,
                    lastUpdate: Date.now(),
                    color: getPlayerColor(multiplayerState.players.size)
                });

                // Notify all players of new join
                broadcastDelta(createDelta('playerJoin', {
                    id: playerId,
                    name: conn.metadata?.playerName || 'Player',
                    color: getPlayerColor(multiplayerState.players.size)
                }));

                showNotification(` ${conn.metadata?.playerName || 'Player'} joined your world!`, 'info');
            });

            conn.on('data', (data) => {
                handleMultiplayerData(conn, data);
            });

            conn.on('close', () => {
                handlePlayerDisconnect(conn);
            });

            conn.on('error', (err) => {
                console.error('Connection error:', err);
                handlePlayerDisconnect(conn);
            });
        }

        function handleMultiplayerData(conn, data) {
            if (data.type === 'delta') {
                // Apply delta update
                applyDelta(data);

                // If we're host, broadcast to other players
                if (multiplayerState.isHost) {
                    broadcastDelta(data, conn.peer); // Exclude sender
                }
            } else if (data.type === 'requestFullState') {
                // Player requesting full sync
                if (multiplayerState.isHost) {
                    conn.send(captureFullGameState());
                }
            } else if (data.type === 'fullState') {
                // Received full state (we're not host)
                applyFullState(data);
            }
        }

        function handlePlayerDisconnect(conn) {
            // Find player by connection
            let disconnectedPlayerId = null;
            multiplayerState.players.forEach((data, playerId) => {
                if (data.connection === conn) {
                    disconnectedPlayerId = playerId;
                }
            });

            if (disconnectedPlayerId) {
                const playerData = multiplayerState.players.get(disconnectedPlayerId);
                removeRemotePlayer(disconnectedPlayerId);

                // Broadcast to other players
                broadcastDelta(createDelta('playerLeave', {
                    id: disconnectedPlayerId,
                    name: playerData?.name || 'Player'
                }));
            }

            // Clean up connection
            p2pStreaming.connections = p2pStreaming.connections.filter(c => c !== conn);
            p2pStreaming.spectatorCount = p2pStreaming.connections.length;
            updateP2PStatusUI();
        }

        function connectToMultiplayerHost(hostId) {
            if (!hostId) {
                showNotification('Invalid host ID', 'error');
                return;
            }

            multiplayerState.enabled = true;
            multiplayerState.isHost = false;
            multiplayerState.localPlayerId = generatePlayerId();
            multiplayerState.hostId = hostId;

            const playerName = 'Explorer_' + Math.floor(Math.random() * 1000);

            // Create our own PeerJS instance if not already created
            if (!p2pStreaming.peer) {
                console.log('Creating PeerJS instance for multiplayer joiner...');
                try {
                    p2pStreaming.peer = new Peer();

                    p2pStreaming.peer.on('open', (id) => {
                        console.log('Multiplayer joiner peer ready with ID:', id);
                        p2pStreaming.peerId = id;
                        // Now connect to the host
                        connectToHost(hostId, playerName);
                    });

                    p2pStreaming.peer.on('error', (err) => {
                        console.error('PeerJS error:', err);
                        showNotification('Connection error: ' + err.type, 'error');
                    });
                } catch (err) {
                    console.error('Failed to create PeerJS:', err);
                    showNotification('Failed to initialize P2P connection', 'error');
                }
            } else {
                // Peer already exists, connect directly
                connectToHost(hostId, playerName);
            }

            function connectToHost(hostId, playerName) {
                console.log('Connecting to multiplayer host:', hostId);

                const conn = p2pStreaming.peer.connect(hostId, {
                    reliable: true,
                    metadata: {
                        playerId: multiplayerState.localPlayerId,
                        playerName: playerName
                    }
                });

                conn.on('open', () => {
                    p2pStreaming.hostConnection = conn;
                    showNotification(' Connected to host! Joining world...', 'info');

                    // Announce ourselves to the host
                    const joinDelta = createDelta('playerJoin', {
                        name: playerName,
                        color: getPlayerColor(0)
                    });
                    conn.send(joinDelta);

                    // Request full state
                    conn.send({ type: 'requestFullState' });
                });

                conn.on('data', (data) => {
                    if (data.type === 'fullState') {
                        applyFullState(data);
                        showNotification(' World synchronized!', 'info');
                    } else if (data.type === 'delta') {
                        applyDelta(data);
                    }
                });

                conn.on('close', () => {
                    showNotification(' Disconnected from host', 'error');
                    multiplayerState.enabled = false;
                });

                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    showNotification('Connection error: ' + err.message, 'error');
                });
            }
        }

        // ==========================================
        // FOLLOW MODE TOGGLE SYSTEM
        // Allows viewers to switch between following host and independent control
        // ==========================================

        function toggleFollowMode() {
            // Only works for non-host players in multiplayer
            if (!multiplayerState.enabled || multiplayerState.isHost) {
                showNotification('Follow mode only available for viewers', 'info');
                return;
            }

            const now = Date.now();
            // Debounce rapid toggling (500ms)
            if (now - multiplayerState.lastModeToggleTime < 500) return;
            multiplayerState.lastModeToggleTime = now;

            multiplayerState.followMode = !multiplayerState.followMode;

            if (multiplayerState.followMode) {
                // Returning to follow mode
                showNotification(' FOLLOW MODE - Watching host', 'info');

                // Snap copilot back near host position if available
                if (multiplayerState.savedHostPosition && copilotMesh) {
                    const offsetDist = 5;
                    const rot = multiplayerState.lastHostRotation || 0;
                    copilotMesh.position.set(
                        multiplayerState.savedHostPosition.x + Math.sin(rot) * offsetDist,
                        multiplayerState.savedHostPosition.y + COPILOT_CONFIG.floatHeight,
                        multiplayerState.savedHostPosition.z + Math.cos(rot) * offsetDist
                    );
                }
            } else {
                // Switching to independent control - viewer controls copilot
                showNotification(' CONTROL MODE - You ARE the Copilot! Use WASD to explore', 'info');

                // Store current copilot position as spawn point
                if (copilotMesh) {
                    multiplayerState.viewerSpawnedAt = {
                        x: copilotMesh.position.x,
                        y: copilotMesh.position.y,
                        z: copilotMesh.position.z
                    };
                }
            }

            updateFollowModeUI();
        }

        function updateFollowModeUI() {
            const btn = document.getElementById('follow-mode-btn');
            if (!btn) return;

            if (multiplayerState.followMode) {
                btn.innerHTML = ' Following';
                btn.style.background = 'rgba(0, 255, 255, 0.3)';
                btn.style.borderColor = '#0ff';
                btn.style.boxShadow = '0 0 15px rgba(0, 255, 255, 0.4)';
            } else {
                btn.innerHTML = ' Control';
                btn.style.background = 'rgba(255, 170, 0, 0.3)';
                btn.style.borderColor = '#fa0';
                btn.style.boxShadow = '0 0 15px rgba(255, 170, 0, 0.4)';
            }
        }

        function createFollowModeButton() {
            // Only create for non-host multiplayer viewers
            if (multiplayerState.isHost) return;

            // Remove existing button if any
            const existing = document.getElementById('follow-mode-btn');
            if (existing) existing.remove();

            const btn = document.createElement('button');
            btn.id = 'follow-mode-btn';
            btn.innerHTML = ' Following';
            btn.title = 'Toggle Follow Mode (F)';
            btn.style.cssText = `
                position: fixed;
                bottom: 80px;
                right: 20px;
                padding: 10px 16px;
                font-size: 14px;
                font-weight: bold;
                color: #fff;
                background: rgba(0, 255, 255, 0.3);
                border: 2px solid #0ff;
                border-radius: 10px;
                cursor: pointer;
                z-index: 10000;
                transition: all 0.3s ease;
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
                font-family: 'Orbitron', sans-serif;
            `;

            btn.addEventListener('click', toggleFollowMode);
            btn.addEventListener('mouseenter', () => {
                btn.style.transform = 'scale(1.05)';
            });
            btn.addEventListener('mouseleave', () => {
                btn.style.transform = 'scale(1)';
            });

            document.body.appendChild(btn);
            updateFollowModeUI();
        }

        // Check if viewer can control (not in follow mode)
        function canViewerControl() {
            // Host always has control
            if (multiplayerState.isHost) return true;
            // Non-host in multiplayer: check follow mode
            if (multiplayerState.enabled && !multiplayerState.isHost) {
                return !multiplayerState.followMode;
            }
            // Single player: always has control
            return true;
        }

        // Broadcast delta to all connected players
        function broadcastDelta(delta, excludePeerId = null) {
            if (!multiplayerState.enabled) return;

            if (multiplayerState.isHost) {
                // Host broadcasts to all spectators/players
                p2pStreaming.connections.forEach(conn => {
                    if (conn.open && conn.peer !== excludePeerId) {
                        try {
                            conn.send(delta);
                        } catch (e) {
                            console.error('Failed to send to peer:', e);
                        }
                    }
                });
            } else {
                // Non-host sends to host only
                if (p2pStreaming.hostConnection?.open) {
                    try {
                        p2pStreaming.hostConnection.send(delta);
                    } catch (e) {
                        console.error('Failed to send to host:', e);
                    }
                }
            }
        }

        // ==========================================
        // MULTIPLAYER SYNC LOOP
        // Called from main game loop
        // ==========================================

        function updateMultiplayerSync() {
            if (!multiplayerState.enabled) return;
            // Safety check for p2pStreaming
            if (typeof p2pStreaming === 'undefined') return;

            const now = Date.now();

            // Send player position delta at regular intervals
            if (now - multiplayerState.lastSyncTime >= multiplayerState.syncInterval) {
                try {
                    const playerDelta = capturePlayerDelta();
                    if (playerDelta) {
                        broadcastDelta(playerDelta);
                    }
                } catch (e) {
                    // Silently fail if game state not ready
                }
                multiplayerState.lastSyncTime = now;
            }

            // Host sends full state periodically
            if (multiplayerState.isHost &&
                now - multiplayerState.lastFullSync >= multiplayerState.fullSyncInterval) {
                try {
                    const fullState = captureFullGameState();
                    (p2pStreaming.connections || []).forEach(conn => {
                        if (conn && conn.open) {
                            try {
                                conn.send(fullState);
                            } catch (e) {
                                console.error('Failed to send full state:', e);
                            }
                        }
                    });
                } catch (e) {
                    // Silently fail if game state not ready
                }
                multiplayerState.lastFullSync = now;
            }
        }

        // Hook into resource gathering to broadcast
        function broadcastResourceHarvest(resource) {
            if (multiplayerState.enabled) {
                broadcastDelta(captureResourceDelta(resource, 'harvest'));
            }
        }

        // Hook into mob kills to broadcast
        function broadcastMobKill(mob) {
            if (multiplayerState.enabled) {
                broadcastDelta(captureMobDelta(mob, 'death'));
            }
        }

        // Hook into structure building to broadcast
        function broadcastStructureBuild(structure) {
            if (multiplayerState.enabled) {
                broadcastDelta(captureStructureDelta(structure, 'build'));
            }
        }

        // Start multiplayer if URL indicates joining a host
        function checkMultiplayerMode() {
            const params = new URLSearchParams(window.location.search);
            const joinId = params.get('join');
            const spectateId = params.get('spectate');
            const antfarmId = params.get('antfarm'); // v6.85: Ant Farm spectator mode
            const versusId = params.get('versus');
            const matchId = params.get('match');
            const seedParam = params.get('seed');
            const planetParam = params.get('planet');

            // If seed is provided in URL, use it for all procedural generation
            if (seedParam) {
                multiplayerState.worldSeed = decodeURIComponent(seedParam);
                console.log('Using world seed from URL:', multiplayerState.worldSeed);
            }

            // v6.85: Ant Farm spectator mode - join as spectator but auto-enable ant farm view
            if (antfarmId) {
                console.log('ANT FARM MODE: Connecting to host:', antfarmId);

                // Store flag to enable ant farm view after connecting
                window.pendingAntFarmMode = true;

                // Direct landing on planet if specified
                if (planetParam !== null && planetParam !== '') {
                    const planetId = parseInt(planetParam, 10);
                    console.log('Ant Farm view on planet ID:', planetId);
                    multiplayerState.targetPlanetId = planetId;
                }

                // Show loading state with ant farm theme
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('loading').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div style="font-size: 24px; color: #0f8;">Joining Ant Farm View...</div>
                        <div style="font-size: 14px; color: #888; margin-top: 10px;">Watch the world from above!</div>
                    </div>
                `;

                showNotification(' ANT FARM: Connecting to ecosystem view...', 'info');

                // Connect as spectator, then enable ant farm view
                setTimeout(() => connectAsAntFarmSpectator(antfarmId), 1000);
                return;
            }

            // v6.68: Versus mode - competitive match
            if (versusId) {
                console.log('VERSUS MODE: Joining match against:', versusId);
                multiplayerState.enabled = true;
                multiplayerState.isHost = false;

                // Set up versus match state
                versusMatchState.matchId = matchId || 'versus_' + Date.now();
                versusMatchState.localTeam = 'hostile'; // Joiner is the hostile team (red)
                versusMatchState.opponentId = versusId;

                // Direct landing on planet if specified
                if (planetParam !== null && planetParam !== '') {
                    const planetId = parseInt(planetParam, 10);
                    console.log('Versus match on planet ID:', planetId);
                    multiplayerState.targetPlanetId = planetId;
                }

                // Show loading state
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('loading').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div style="font-size: 24px; color: #f08;">Joining Versus Match...</div>
                        <div style="font-size: 14px; color: #888; margin-top: 10px;">Prepare for battle! War horn sounds when ready.</div>
                    </div>
                `;

                showNotification(' VERSUS MODE: Connecting to opponent...', 'warning');

                // Connect as multiplayer (we'll start the match when both players are on the planet)
                setTimeout(() => {
                    connectToMultiplayerHost(versusId);
                    // Start versus match after connection and landing
                    setTimeout(() => {
                        if (mode === 'world') {
                            startVersusMatch();
                        }
                    }, 5000); // Give time to land and sync
                }, 500);
                return;
            }

            if (joinId) {
                // Full multiplayer join
                console.log('Joining multiplayer host:', joinId);
                multiplayerState.enabled = true;
                multiplayerState.isHost = false;

                // IMMEDIATE PLANET LANDING: If planet ID is in URL, land directly without waiting for P2P
                if (planetParam !== null && planetParam !== '') {
                    const planetId = parseInt(planetParam, 10);
                    console.log('Direct landing on planet ID:', planetId);

                    // Store the target planet ID - we'll use host's civilization data when it arrives
                    multiplayerState.targetPlanetId = planetId;

                    // DON'T generate civilizations here - wait for host's data
                    // The host will send the exact civilization object with the correct name/biome
                    // For now, just show loading and wait for the host connection
                    console.log('Waiting for host to send civilization data for planet:', planetId);
                    showNotification(` Connecting to host world...`, 'info');

                    // Keep loading screen visible until we get host data
                    // The loading screen will be hidden when applyFullState() completes
                }

                // Connect to host for player sync (positions, mobs, etc.)
                // Small delay to ensure page is fully loaded, PeerJS init is handled inside the function
                setTimeout(() => connectToMultiplayerHost(joinId), 500);
            } else if (spectateId) {
                // Spectator mode (existing)
                console.log('Spectating:', spectateId);
                setTimeout(() => connectAsSpectator(spectateId), 1000);
            } else {
                // Initialize as host
                console.log('Starting as multiplayer host');
                setTimeout(initMultiplayerHost, 3000);
            }
        }

        // Generate join URL for multiplayer - includes seed and planet ID for direct landing
        function getMultiplayerJoinUrl() {
            if (!p2pStreaming.peerId) return null;
            let url = `${window.location.origin}${window.location.pathname}?join=${p2pStreaming.peerId}`;
            // Include world seed for deterministic generation sync
            url += `&seed=${encodeURIComponent(multiplayerState.worldSeed)}`;
            // Include planet ID if host is on a planet
            if (activeCiv && mode === 'world') {
                url += `&planet=${activeCiv.id}`;
            }
            return url;
        }

        // Generate QR code for multiplayer join link (with planet data)
        function generateMultiplayerQRCode() {
            if (!p2pStreaming.peerId) {
                console.log('No peer ID yet, will generate QR when ready');
                return;
            }

            const container = document.getElementById('qr-code-container');
            if (!container) return;

            // Show loading state
            container.innerHTML = '<div style="color: #333; font-size: 14px;">Generating multiplayer QR...</div>';

            const multiplayerUrl = getMultiplayerJoinUrl();
            console.log('Generating multiplayer QR code for:', multiplayerUrl);

            // Try QRious library first, fall back to API
            loadQRiousLibrary().then(() => {
                container.innerHTML = ''; // Clear loading state
                const canvas = document.createElement('canvas');
                canvas.id = 'qr-canvas';
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: multiplayerUrl,
                    size: 200,
                    background: 'white',
                    foreground: 'black',
                    level: 'H' // High error correction for better scanning
                });

                console.log('Multiplayer QR code generated with QRious');
            }).catch((err) => {
                console.log('QRious failed, using API fallback:', err);
                container.innerHTML = ''; // Clear loading state
                // Fallback: Use QR Server API
                const img = document.createElement('img');
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(multiplayerUrl)}`;
                img.alt = 'Scan to join multiplayer';
                img.style.borderRadius = '10px';
                img.id = 'qr-canvas';
                img.onload = () => console.log('Multiplayer QR code loaded from API');
                img.onerror = () => {
                    container.innerHTML = '<div style="color: #c00; font-size: 12px; padding: 10px;">QR generation failed.<br>Copy the URL below instead.</div>';
                };
                container.appendChild(img);
                console.log('Multiplayer QR code generated with API fallback');
            });

            // Also update the URL display
            const urlEl = document.getElementById('qr-url');
            if (urlEl) {
                urlEl.textContent = multiplayerUrl;
            }
        }

        // v6.85: Generate URL for Ant Farm spectator mode
        function getAntFarmSpectatorUrl() {
            if (!p2pStreaming.peerId) return null;
            let url = `${window.location.origin}${window.location.pathname}?antfarm=${p2pStreaming.peerId}`;
            // Include world seed for deterministic generation sync
            url += `&seed=${encodeURIComponent(multiplayerState.worldSeed)}`;
            // Include planet ID if host is on a planet
            if (activeCiv && mode === 'world') {
                url += `&planet=${activeCiv.id}`;
            }
            return url;
        }

        // v6.85: Generate QR code for Ant Farm spectator mode
        function generateAntFarmQRCode() {
            if (!p2pStreaming.peerId) {
                console.log('No peer ID yet, will generate Ant Farm QR when ready');
                return;
            }

            if (mode !== 'world') {
                console.log('Ant Farm mode requires being on a planet');
                return;
            }

            const container = document.getElementById('qr-code-container');
            if (!container) return;

            // Show loading state
            container.innerHTML = '<div style="color: #333; font-size: 14px;">Generating Ant Farm QR...</div>';

            const antfarmUrl = getAntFarmSpectatorUrl();
            console.log('Generating Ant Farm QR code for:', antfarmUrl);

            // Try QRious library first, fall back to API
            loadQRiousLibrary().then(() => {
                container.innerHTML = ''; // Clear loading state
                const canvas = document.createElement('canvas');
                canvas.id = 'qr-canvas';
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: antfarmUrl,
                    size: 200,
                    background: 'white',
                    foreground: '#004422', // Dark green for ant farm theme
                    level: 'H'
                });

                console.log('Ant Farm QR code generated with QRious');
            }).catch((err) => {
                console.log('QRious failed, using API fallback:', err);
                container.innerHTML = ''; // Clear loading state
                // Fallback: Use QR Server API
                const img = document.createElement('img');
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(antfarmUrl)}&color=004422`;
                img.alt = 'Scan to view Ant Farm';
                img.style.borderRadius = '10px';
                img.id = 'qr-canvas';
                img.onload = () => console.log('Ant Farm QR code loaded from API');
                img.onerror = () => {
                    container.innerHTML = '<div style="color: #c00; font-size: 12px; padding: 10px;">QR generation failed.<br>Copy the URL below instead.</div>';
                };
                container.appendChild(img);
                console.log('Ant Farm QR code generated with API fallback');
            });

            // Also update the URL display
            const urlEl = document.getElementById('qr-url');
            if (urlEl) {
                urlEl.textContent = antfarmUrl;
            }
        }

        // Show multiplayer status in UI
        function updateMultiplayerUI() {
            const playerCount = multiplayerState.players.size + 1; // +1 for self
            const statusEl = document.getElementById('p2p-status');
            if (statusEl && multiplayerState.enabled) {
                statusEl.textContent = multiplayerState.isHost ?
                    ` HOSTING (${playerCount} players)` :
                    ' CONNECTED';
                statusEl.style.color = '#00ff88';
            }
        }

        // ==========================================
        // END ENHANCED MULTIPLAYER SYSTEM
        // ==========================================

        function createMob(rng, biome) {
            // v4.2: Select enemy type based on biome
            const biomeKey = biome.name === 'Terra' ? 'Terra' :
                            biome.name === 'Desert' ? 'Desert' :
                            biome.name === 'Tundra' ? 'Ice' :
                            biome.name === 'Xeno' ? 'Alien' :
                            biome.name === 'Magma' ? 'Volcanic' : 'Terra';

            const validEnemies = Object.entries(ENEMY_TYPES)
                .filter(([name, data]) => data.biomes.includes(biomeKey));

            const [enemyName, enemyData] = validEnemies.length > 0
                ? validEnemies[rng.int(0, validEnemies.length - 1)]
                : ['Slime', ENEMY_TYPES.Slime];

            // v4.7: Elite enemy roll
            const prestigeLevel = gameData.prestige?.level || 0;
            const isElite = prestigeLevel >= ELITE_CONFIG.minWorldLevel &&
                           rng.next() < ELITE_CONFIG.spawnChance;

            let eliteAffix = null;
            let eliteData = null;
            if (isElite) {
                const affixKeys = Object.keys(ELITE_AFFIXES);
                const affixKey = affixKeys[rng.int(0, affixKeys.length - 1)];
                eliteAffix = affixKey;
                eliteData = ELITE_AFFIXES[affixKey];
            }

            // Calculate stats with elite multipliers
            const baseHp = enemyData.hp * (eliteData ? eliteData.hpMult : 1);
            const baseDamage = enemyData.damage * (eliteData ? eliteData.damageMult : 1);
            const baseSpeed = enemyData.speed * (eliteData ? eliteData.speedMult : 1);

            const mobGeo = new THREE.SphereGeometry(isElite ? 1.0 : 0.8, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({
                color: eliteData ? eliteData.color : enemyData.color,
                roughness: 0.3,
                emissive: eliteData ? eliteData.color : enemyData.emissive,
                emissiveIntensity: isElite ? 0.5 : 0.2
            });
            const mob = new THREE.Mesh(mobGeo, mobMat);

            const rx = (rng.next() - 0.5) * 60;
            const rz = (rng.next() - 0.5) * 60;
            // v6.64: Spawn mobs at low height, snapToGround will correct position each frame
            mob.position.set(rx, 2, rz);
            mob.castShadow = true;

            // v4.7: Add glowing aura ring for elite enemies
            if (isElite) {
                const auraGeo = new THREE.RingGeometry(1.2, 1.5, 32);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: eliteData.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                mob.add(aura);
                mob.userData.auraRing = aura;
            }

            // v5.12: Hypnotist special eye appearance
            if (enemyData.isHypnotist) {
                // Create eye-like structure with iris and pupil
                const irisGeo = new THREE.CircleGeometry(0.5, 32);
                const irisMat = new THREE.MeshBasicMaterial({
                    color: 0x8800ff,
                    side: THREE.DoubleSide
                });
                const iris = new THREE.Mesh(irisGeo, irisMat);
                iris.position.z = 0.75;
                mob.add(iris);

                // Pupil (inner dark circle that moves)
                const pupilGeo = new THREE.CircleGeometry(0.25, 32);
                const pupilMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                pupil.position.z = 0.76;
                mob.add(pupil);
                mob.userData.pupil = pupil;
                mob.userData.iris = iris;

                // Glowing concentric rings around the eye
                for (let i = 0; i < 3; i++) {
                    const ringGeo = new THREE.RingGeometry(0.9 + i * 0.3, 1.0 + i * 0.3, 32);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0xff00ff : 0x8800ff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.z = 0.74 - i * 0.02;
                    mob.add(ring);
                }

                // Give it a floating, creepy movement
                mob.userData.isHypnotist = true;
            }

            // Health bar above mob (larger for elites)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.0 : 1.5, 0.15),
                new THREE.MeshBasicMaterial({ color: isElite ? 0xffaa00 : 0x00ff00, side: THREE.DoubleSide })
            );
            hpBar.position.y = isElite ? 1.8 : 1.5;
            mob.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.1 : 1.6, 0.2),
                new THREE.MeshBasicMaterial({ color: isElite ? 0x553300 : 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = isElite ? 1.8 : 1.5;
            hpBg.position.z = -0.01;
            mob.add(hpBg);

            // v5.3: Apply portal modifiers to mob stats
            const portalMods = getPortalModifiers();
            let finalHp = baseHp;
            let finalDamage = baseDamage;
            if (portalMods) {
                finalHp = Math.floor(baseHp * (portalMods.enemyHp || 1));
                finalDamage = Math.floor(baseDamage * (portalMods.enemyDamage || 1));
            }

            mob.userData = {
                type: 'mob',
                hp: finalHp,
                maxHp: finalHp,
                name: enemyName,
                damage: finalDamage,
                speed: baseSpeed,
                drops: enemyData.drops,
                xpReward: enemyData.xp * (isElite ? ELITE_CONFIG.bonusXpMult : 1),
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                // v4.5: Attack telegraph properties
                attackWindup: enemyData.attackWindup || 600,
                attackRange: enemyData.attackRange || 2.5,
                telegraphing: false,
                // v4.7: Elite properties
                isElite: isElite,
                eliteAffix: eliteAffix,
                eliteData: eliteData,
                displayName: isElite ? `${eliteData.prefix} ${eliteData.name} ${enemyName}` : enemyName,
                // v5.3: Portal-modified flag
                portalBuffed: portalMods !== null
            };

            scene.add(mob);
            worldState.mobs.push(mob);

            // v4.7: Announce elite spawn
            if (isElite) {
                showNotification(`${eliteData.prefix} ELITE ${eliteData.name} ${enemyName} appeared!`, 'warning');
            }
        }

        // ============================================
        // v6.65: DOTA-STYLE CREEP WAVE SYSTEM
        // Three lanes with visual paths, spawning creeps
        // that meet at choke points and battle
        // ============================================

        const CREEP_WAVE_CONFIG = {
            enabled: true,
            waveInterval: 30000,     // Spawn wave every 30 seconds
            creepsPerWave: 4,        // Creeps per team per lane
            creepSpeed: 3,           // Movement speed
            creepHp: 30,             // Base HP
            creepDamage: 5,          // Base damage
            creepAttackRange: 2,     // Attack range
            creepAttackCooldown: 1200, // Attack cooldown ms
            playerRewardRadius: 15,  // Radius to get XP/gold from creep kills
            xpPerCreep: 15,          // XP reward for nearby kill
            goldPerCreep: 5          // Gold reward
        };

        // v6.67: Lane definitions with universe-appropriate names
        // Supply corridors connecting frontier outposts across the planet
        // Choke points named after geographic features - historic battlegrounds
        const LANE_DEFINITIONS = {
            top: {
                name: 'Boreal Reach',
                subtitle: 'Northern Frontier Corridor',
                lore: 'Ancient cryo-tech relay stations mark this frozen passage. The Battle of Frostfall claimed 200 drones in a single night.',
                color: 0x4488ff,     // Ice Blue - cold northern route
                teamASpawn: { x: -75, z: -60 },
                teamBSpawn: { x: 75, z: -60 },
                teamABase: 'Outpost Hyperion',
                teamBBase: 'Fort Glacius',
                waypoints: [
                    { x: -75, z: -60 },
                    { x: -50, z: -55 },
                    { x: -25, z: -50 },
                    { x: 0, z: -50 },     // CHOKE POINT
                    { x: 25, z: -50 },
                    { x: 50, z: -55 },
                    { x: 75, z: -60 }
                ],
                chokePointIndex: 3,
                chokePointName: 'Frostfall Crossing',
                chokePointLore: 'Where the northern winds freeze lubricant solid. Many machines have fallen here.'
            },
            mid: {
                name: 'Nexus Spine',
                subtitle: 'Central Command Axis',
                lore: 'The primary arterial route. Control the Spine, control the planet. The Siege of Ember Gate lasted 47 cycles.',
                color: 0xffaa00,     // Command Gold - main strategic route
                teamASpawn: { x: -70, z: -70 },
                teamBSpawn: { x: 70, z: 70 },
                teamABase: 'Citadel Prime',
                teamBBase: 'Fortress Omega',
                waypoints: [
                    { x: -70, z: -70 },
                    { x: -45, z: -45 },
                    { x: -20, z: -20 },
                    { x: 0, z: 0 },       // CHOKE POINT
                    { x: 20, z: 20 },
                    { x: 45, z: 45 },
                    { x: 70, z: 70 }
                ],
                chokePointIndex: 3,
                chokePointName: 'Ember Gate',
                chokePointLore: 'The geographic dead center. Thermal vents create perpetual haze. Winner takes all.'
            },
            bot: {
                name: 'Verdant Trail',
                subtitle: 'Southern Terraform Corridor',
                lore: 'Terraformed valleys rich with xenoflora. The Thornhollow Massacre marked the bloodiest day in colony history.',
                color: 0x44ff88,     // Life Green - terraformed southern route
                teamASpawn: { x: -75, z: 60 },
                teamBSpawn: { x: 75, z: 60 },
                teamABase: 'Station Evergreen',
                teamBBase: 'Biodome Sentinel',
                waypoints: [
                    { x: -75, z: 60 },
                    { x: -50, z: 55 },
                    { x: -25, z: 50 },
                    { x: 0, z: 50 },      // CHOKE POINT
                    { x: 25, z: 50 },
                    { x: 50, z: 55 },
                    { x: 75, z: 60 }
                ],
                chokePointIndex: 3,
                chokePointName: 'Thornhollow Vale',
                chokePointLore: 'Dense xenoflora conceals ambush positions. The thorns drink oil as readily as blood.'
            }
        };

        // v6.69: Helper function to check if a position is near any lane path
        // Used to exclude trees/rocks from spawning on lanes
        function isNearLanePath(x, z, exclusionRadius = 8) {
            for (const laneKey of Object.keys(LANE_DEFINITIONS)) {
                const lane = LANE_DEFINITIONS[laneKey];
                const waypoints = lane.waypoints;

                // Check distance to each waypoint
                for (const wp of waypoints) {
                    const dx = x - wp.x;
                    const dz = z - wp.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < exclusionRadius) return true;
                }

                // Check distance to line segments between waypoints
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const p1 = waypoints[i];
                    const p2 = waypoints[i + 1];

                    // Point-to-line-segment distance
                    const ax = x - p1.x;
                    const az = z - p1.z;
                    const bx = p2.x - p1.x;
                    const bz = p2.z - p1.z;

                    const lenSq = bx * bx + bz * bz;
                    if (lenSq === 0) continue;

                    let t = (ax * bx + az * bz) / lenSq;
                    t = Math.max(0, Math.min(1, t));

                    const closestX = p1.x + t * bx;
                    const closestZ = p1.z + t * bz;

                    const dx = x - closestX;
                    const dz = z - closestZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < exclusionRadius) return true;
                }
            }
            return false;
        }

        // Creep wave state
        let creepWaveState = {
            enabled: false,
            lastWaveTime: 0,
            waveNumber: 0,
            creeps: [],              // All active creeps
            laneVisuals: [],         // Lane path meshes
            initialized: false
        };

        // Initialize the lane system when entering world
        function initCreepLaneSystem() {
            if (!CREEP_WAVE_CONFIG.enabled) return;

            creepWaveState = {
                enabled: true,
                lastWaveTime: performance.now(),
                waveNumber: 0,
                creeps: [],
                laneVisuals: [],
                initialized: true
            };

            // v6.69: Clear existing trees/rocks from lane paths
            clearObstaclesFromLanes();

            // Create visual lane paths on terrain
            createLaneVisuals();

            // Create choke point markers
            createChokePointMarkers();

            console.log('v6.65: Creep Wave System initialized');
        }

        // v6.69: Remove existing trees/rocks that are on lane paths
        function clearObstaclesFromLanes() {
            if (!worldState.interactables) return;

            const toRemove = [];

            worldState.interactables.forEach(obj => {
                if (obj.userData && (obj.userData.type === 'tree' || obj.userData.type === 'rock')) {
                    const x = obj.position.x;
                    const z = obj.position.z;

                    // Check if this obstacle is on a lane path
                    if (isNearLanePath(x, z, 10)) {
                        toRemove.push(obj);
                    }
                }
            });

            // Remove obstacles from scene and interactables array
            toRemove.forEach(obj => {
                if (obj.parent) {
                    obj.parent.remove(obj);
                }
                // Dispose geometry and materials
                obj.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            });

            // Filter out removed objects from interactables
            worldState.interactables = worldState.interactables.filter(obj => !toRemove.includes(obj));

            if (toRemove.length > 0) {
                console.log(`v6.69: Cleared ${toRemove.length} obstacles from lane paths`);
            }
        }

        // v6.67: Create visual lane paths using colored BLOCKS instead of lines
        // DOTA 2 style colored path blocks for each lane
        function createLaneVisuals() {
            if (!scene) return;

            // Clear existing visuals
            creepWaveState.laneVisuals.forEach(visual => {
                if (visual.parent) visual.parent.remove(visual);
                if (visual.geometry) visual.geometry.dispose();
                if (visual.material) visual.material.dispose();
            });
            creepWaveState.laneVisuals = [];

            // Block configuration per lane
            const LANE_BLOCK_CONFIG = {
                top: {
                    blockSize: { x: 2.5, y: 0.3, z: 3.5 },      // Wide blocks for top lane
                    spacing: 4,                                   // Distance between blocks
                    pattern: 'alternating',                       // Alternating brightness pattern
                    edgeBlocks: true,                             // Add edge blocks for borders
                    glowIntensity: 0.6
                },
                mid: {
                    blockSize: { x: 2.0, y: 0.4, z: 2.0 },       // Square blocks for mid
                    spacing: 3.5,
                    pattern: 'gradient',                          // Gradient toward center
                    edgeBlocks: true,
                    glowIntensity: 0.8
                },
                bot: {
                    blockSize: { x: 2.5, y: 0.3, z: 3.5 },       // Wide blocks for bot lane
                    spacing: 4,
                    pattern: 'pulsing',                           // Special pulsing pattern
                    edgeBlocks: true,
                    glowIntensity: 0.6
                }
            };

            Object.entries(LANE_DEFINITIONS).forEach(([laneKey, lane]) => {
                const config = LANE_BLOCK_CONFIG[laneKey];
                const waypoints = lane.waypoints;
                const baseColor = new THREE.Color(lane.color);

                // Create a lane group for organization
                const laneGroup = new THREE.Group();
                laneGroup.userData.laneKey = laneKey;
                laneGroup.userData.laneName = lane.name;

                // v6.67: Helper to check if position is over water
                const WATER_LEVEL = 0.5;  // Water surface height
                const BRIDGE_HEIGHT = 3.0; // Bridge deck height above water
                function isOverWater(wx, wz) {
                    if (!worldState.terrain) return false;
                    const gx = Math.round(wx / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
                    const gz = Math.round(wz / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
                    if (gx >= 0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                        const terrainY = worldState.terrain[gx]?.[gz];
                        return terrainY !== undefined && terrainY < -50; // Water tiles are -99
                    }
                    return false;
                }

                // Bridge materials (industrial/metallic look)
                const bridgeDeckColor = new THREE.Color(0x445566);
                const bridgeSupportColor = new THREE.Color(0x334455);
                const bridgeRailColor = baseColor.clone().multiplyScalar(1.2);

                let blockIndex = 0;
                let wasOverWater = false;  // Track previous block state for ramp detection
                let lastGroundY = 0;       // Track ground height before bridge

                // Helper function to create bridge ramps
                function createBridgeRamp(x, z, angle, isUpRamp, groundY) {
                    const rampLength = config.spacing * 1.5;
                    const rampHeight = BRIDGE_HEIGHT - groundY + WATER_LEVEL;
                    const rampSteps = 4;

                    for (let step = 0; step < rampSteps; step++) {
                        const t = step / rampSteps;
                        const stepHeight = groundY + rampHeight * (isUpRamp ? t : (1 - t));

                        // Position along the ramp
                        const stepOffset = (isUpRamp ? -1 : 1) * (rampLength * (1 - t));
                        const stepX = x + Math.sin(angle) * stepOffset;
                        const stepZ = z + Math.cos(angle) * stepOffset;

                        // Ramp segment
                        const rampGeo = new THREE.BoxGeometry(
                            config.blockSize.x * 1.3,
                            config.blockSize.y * 0.6,
                            rampLength / rampSteps
                        );
                        const rampMat = new THREE.MeshStandardMaterial({
                            color: bridgeDeckColor,
                            emissive: baseColor,
                            emissiveIntensity: 0.15,
                            roughness: 0.5,
                            metalness: 0.6
                        });
                        const rampBlock = new THREE.Mesh(rampGeo, rampMat);
                        rampBlock.position.set(stepX, stepHeight + 0.2, stepZ);
                        rampBlock.rotation.y = angle;
                        // Tilt the ramp
                        const tiltAngle = Math.atan2(rampHeight / rampSteps, rampLength / rampSteps);
                        rampBlock.rotation.x = isUpRamp ? -tiltAngle * 0.3 : tiltAngle * 0.3;
                        rampBlock.receiveShadow = true;
                        laneGroup.add(rampBlock);

                        // Ramp railings
                        if (step < rampSteps - 1) {
                            [-1, 1].forEach(side => {
                                const railGeo = new THREE.BoxGeometry(0.15, 0.8, 0.15);
                                const railMat = new THREE.MeshStandardMaterial({
                                    color: bridgeRailColor,
                                    emissive: baseColor,
                                    emissiveIntensity: 0.3
                                });
                                const rail = new THREE.Mesh(railGeo, railMat);
                                const railOffset = (config.blockSize.z * 0.6) * side;
                                const perpX = Math.cos(angle) * railOffset;
                                const perpZ = -Math.sin(angle) * railOffset;
                                rail.position.set(stepX + perpX, stepHeight + 0.6, stepZ + perpZ);
                                laneGroup.add(rail);
                            });
                        }
                    }
                }

                // Interpolate between waypoints and place blocks
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const wpStart = waypoints[i];
                    const wpEnd = waypoints[i + 1];

                    // Calculate direction and distance
                    const dx = wpEnd.x - wpStart.x;
                    const dz = wpEnd.z - wpStart.z;
                    const segmentDist = Math.sqrt(dx * dx + dz * dz);
                    const numBlocks = Math.floor(segmentDist / config.spacing);

                    // Calculate angle for block rotation (perpendicular to path)
                    const angle = Math.atan2(dx, dz);

                    for (let b = 0; b < numBlocks; b++) {
                        const t = b / numBlocks;
                        const x = wpStart.x + dx * t;
                        const z = wpStart.z + dz * t;

                        // v6.67: Check if this block is over water
                        const overWater = isOverWater(x, z);

                        // Calculate Y position - elevated for bridges
                        let y;
                        const groundY = typeof getTerrainHeight === 'function'
                            ? getTerrainHeight(x, z)
                            : 0;

                        if (overWater) {
                            y = WATER_LEVEL + BRIDGE_HEIGHT;

                            // v6.67: Detect transition to bridge - create UP ramp
                            if (!wasOverWater && blockIndex > 0) {
                                createBridgeRamp(x, z, angle, true, lastGroundY);
                            }
                        } else {
                            y = groundY + config.blockSize.y / 2 + 0.05;
                            lastGroundY = groundY;

                            // v6.67: Detect transition from bridge - create DOWN ramp
                            if (wasOverWater) {
                                createBridgeRamp(x, z, angle, false, groundY);
                            }
                        }

                        wasOverWater = overWater;

                        // Calculate color variation based on pattern
                        let colorMult = 1.0;
                        let opacity = 0.7;

                        if (config.pattern === 'alternating') {
                            colorMult = blockIndex % 2 === 0 ? 1.0 : 0.7;
                            opacity = blockIndex % 2 === 0 ? 0.8 : 0.6;
                        } else if (config.pattern === 'gradient') {
                            // Brighter toward choke point (center)
                            const distToChoke = Math.abs(i - lane.chokePointIndex);
                            colorMult = 1.0 - distToChoke * 0.1;
                            opacity = 0.6 + (1 - distToChoke * 0.15) * 0.3;
                        } else if (config.pattern === 'pulsing') {
                            // Store phase for animation
                            colorMult = 0.8 + Math.sin(blockIndex * 0.5) * 0.2;
                            opacity = 0.65 + Math.sin(blockIndex * 0.5) * 0.15;
                        }

                        if (overWater) {
                            // ========== BRIDGE SECTION ==========
                            // Create bridge deck (wider, metallic)
                            const deckGeo = new THREE.BoxGeometry(
                                config.blockSize.x * 1.3,
                                config.blockSize.y * 0.8,
                                config.blockSize.z * 1.4
                            );
                            const deckMat = new THREE.MeshStandardMaterial({
                                color: bridgeDeckColor,
                                emissive: baseColor,
                                emissiveIntensity: 0.2,
                                transparent: true,
                                opacity: 0.95,
                                roughness: 0.4,
                                metalness: 0.7
                            });
                            const deck = new THREE.Mesh(deckGeo, deckMat);
                            deck.position.set(x, y, z);
                            deck.rotation.y = angle;
                            deck.userData.isBridge = true;
                            deck.userData.blockIndex = blockIndex;
                            deck.receiveShadow = true;
                            deck.castShadow = true;
                            laneGroup.add(deck);

                            // Lane color strip on bridge deck (center line)
                            const stripGeo = new THREE.BoxGeometry(
                                config.blockSize.x * 1.2,
                                config.blockSize.y * 0.2,
                                config.blockSize.z * 0.5
                            );
                            const stripColor = baseColor.clone().multiplyScalar(colorMult);
                            const stripMat = new THREE.MeshStandardMaterial({
                                color: stripColor,
                                emissive: stripColor,
                                emissiveIntensity: config.glowIntensity * 0.8,
                                transparent: true,
                                opacity: 0.9
                            });
                            const strip = new THREE.Mesh(stripGeo, stripMat);
                            strip.position.set(x, y + config.blockSize.y * 0.5, z);
                            strip.rotation.y = angle;
                            strip.userData.laneKey = laneKey;
                            strip.userData.baseEmissive = config.glowIntensity * 0.8;
                            laneGroup.add(strip);

                            // Support pillars (every 2 blocks)
                            if (blockIndex % 2 === 0) {
                                const pillarHeight = BRIDGE_HEIGHT + 1.5;
                                const pillarGeo = new THREE.CylinderGeometry(0.35, 0.5, pillarHeight, 8);
                                const pillarMat = new THREE.MeshStandardMaterial({
                                    color: bridgeSupportColor,
                                    emissive: 0x112233,
                                    emissiveIntensity: 0.1,
                                    roughness: 0.5,
                                    metalness: 0.8
                                });

                                [-1, 1].forEach(side => {
                                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                                    const pillarOffset = (config.blockSize.z / 2) + 0.3;
                                    const perpX = Math.cos(angle) * pillarOffset * side;
                                    const perpZ = -Math.sin(angle) * pillarOffset * side;
                                    pillar.position.set(
                                        x + perpX,
                                        WATER_LEVEL - pillarHeight / 2 + BRIDGE_HEIGHT - 0.5,
                                        z + perpZ
                                    );
                                    pillar.castShadow = true;
                                    laneGroup.add(pillar);

                                    // Pillar base (underwater foundation)
                                    const baseGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.5, 8);
                                    const baseMesh = new THREE.Mesh(baseGeo, pillarMat);
                                    baseMesh.position.set(
                                        x + perpX,
                                        WATER_LEVEL - pillarHeight + 0.25,
                                        z + perpZ
                                    );
                                    laneGroup.add(baseMesh);
                                });

                                // Cross beam under deck
                                const beamGeo = new THREE.BoxGeometry(0.3, 0.4, config.blockSize.z * 1.6);
                                const beam = new THREE.Mesh(beamGeo, pillarMat);
                                beam.position.set(x, y - config.blockSize.y * 0.6, z);
                                beam.rotation.y = angle;
                                laneGroup.add(beam);
                            }

                            // Railings (both sides)
                            const railHeight = 1.2;
                            const railGeo = new THREE.BoxGeometry(config.blockSize.x * 0.15, railHeight, config.blockSize.z * 0.15);
                            const railMat = new THREE.MeshStandardMaterial({
                                color: bridgeRailColor,
                                emissive: baseColor,
                                emissiveIntensity: 0.5,
                                transparent: true,
                                opacity: 0.9,
                                metalness: 0.6,
                                roughness: 0.3
                            });

                            [-1, 1].forEach(side => {
                                // Vertical rail posts
                                const post = new THREE.Mesh(railGeo, railMat);
                                const railOffset = (config.blockSize.z * 0.65);
                                const perpX = Math.cos(angle) * railOffset * side;
                                const perpZ = -Math.sin(angle) * railOffset * side;
                                post.position.set(x + perpX, y + railHeight / 2 + config.blockSize.y * 0.4, z + perpZ);
                                post.userData.isBridgeRail = true;
                                laneGroup.add(post);

                                // Horizontal rail bar
                                const barGeo = new THREE.BoxGeometry(config.blockSize.x * 1.1, 0.12, 0.12);
                                const bar = new THREE.Mesh(barGeo, railMat);
                                bar.position.set(x + perpX, y + railHeight + config.blockSize.y * 0.3, z + perpZ);
                                bar.rotation.y = angle;
                                laneGroup.add(bar);
                            });

                            // Bridge warning lights (every 4 blocks)
                            if (blockIndex % 4 === 0) {
                                const lightGeo = new THREE.SphereGeometry(0.2, 8, 8);
                                const lightMat = new THREE.MeshStandardMaterial({
                                    color: 0xffaa00,
                                    emissive: 0xffaa00,
                                    emissiveIntensity: 1.5,
                                    transparent: true,
                                    opacity: 0.9
                                });

                                [-1, 1].forEach(side => {
                                    const light = new THREE.Mesh(lightGeo, lightMat.clone());
                                    const lightOffset = (config.blockSize.z * 0.65);
                                    const perpX = Math.cos(angle) * lightOffset * side;
                                    const perpZ = -Math.sin(angle) * lightOffset * side;
                                    light.position.set(x + perpX, y + railHeight + config.blockSize.y * 0.6, z + perpZ);
                                    light.userData.isBridgeLight = true;
                                    light.userData.pulsePhase = Math.random() * Math.PI * 2;
                                    laneGroup.add(light);
                                });
                            }

                        } else {
                            // ========== REGULAR GROUND PATH ==========
                            // Create main path block
                            const blockGeo = new THREE.BoxGeometry(
                                config.blockSize.x,
                                config.blockSize.y,
                                config.blockSize.z
                            );

                            const blockColor = baseColor.clone().multiplyScalar(colorMult);
                            const blockMat = new THREE.MeshStandardMaterial({
                                color: blockColor,
                                emissive: blockColor,
                                emissiveIntensity: config.glowIntensity * colorMult,
                                transparent: true,
                                opacity: opacity,
                                roughness: 0.3,
                                metalness: 0.2
                            });

                            const block = new THREE.Mesh(blockGeo, blockMat);
                            block.position.set(x, y, z);
                            block.rotation.y = angle;
                            block.userData.blockIndex = blockIndex;
                            block.userData.laneKey = laneKey;
                            block.userData.baseOpacity = opacity;
                            block.userData.baseEmissive = config.glowIntensity * colorMult;
                            block.receiveShadow = true;
                            laneGroup.add(block);

                            // Add edge blocks for lane borders
                            if (config.edgeBlocks) {
                                const edgeWidth = 0.4;
                                const edgeHeight = config.blockSize.y * 1.5;
                                const edgeOffset = (config.blockSize.z / 2) + edgeWidth / 2;

                                [-1, 1].forEach(side => {
                                    const edgeGeo = new THREE.BoxGeometry(config.blockSize.x * 0.9, edgeHeight, edgeWidth);
                                    const edgeColor = baseColor.clone().multiplyScalar(1.3);
                                    const edgeMat = new THREE.MeshStandardMaterial({
                                        color: edgeColor,
                                        emissive: edgeColor,
                                        emissiveIntensity: config.glowIntensity * 1.2,
                                        transparent: true,
                                        opacity: 0.9,
                                        roughness: 0.2,
                                        metalness: 0.4
                                    });

                                    const edge = new THREE.Mesh(edgeGeo, edgeMat);
                                    // Position edge perpendicular to path direction
                                    const perpX = Math.cos(angle) * edgeOffset * side;
                                    const perpZ = -Math.sin(angle) * edgeOffset * side;
                                    edge.position.set(x + perpX, y + edgeHeight/4, z + perpZ);
                                    edge.rotation.y = angle;
                                    edge.receiveShadow = true;
                                    laneGroup.add(edge);
                                });
                            }

                            // Add decorative corner markers every 5 blocks
                            if (blockIndex % 5 === 0) {
                                const markerGeo = new THREE.CylinderGeometry(0.3, 0.5, 1.2, 6);
                                const markerMat = new THREE.MeshStandardMaterial({
                                    color: 0xffffff,
                                    emissive: baseColor,
                                    emissiveIntensity: 1.0,
                                    transparent: true,
                                    opacity: 0.85,
                                    metalness: 0.6,
                                    roughness: 0.2
                                });

                                [-1, 1].forEach(side => {
                                    const marker = new THREE.Mesh(markerGeo, markerMat.clone());
                                    const markerOffset = (config.blockSize.z / 2) + 1.0;
                                    const perpX = Math.cos(angle) * markerOffset * side;
                                    const perpZ = -Math.sin(angle) * markerOffset * side;
                                    marker.position.set(x + perpX, y + 0.4, z + perpZ);
                                    marker.userData.isLaneMarker = true;
                                    marker.userData.pulsePhase = Math.random() * Math.PI * 2;
                                    laneGroup.add(marker);
                                });
                            }
                        }

                        blockIndex++;
                    }
                }

                // Add spawn point markers (fortress platforms with base names)
                const baseNames = [lane.teamABase, lane.teamBBase];
                const teamLabels = ['ROBOT FORCES', 'HOSTILE FAUNA'];
                [lane.teamASpawn, lane.teamBSpawn].forEach((spawn, teamIdx) => {
                    const spawnY = typeof getTerrainHeight === 'function'
                        ? getTerrainHeight(spawn.x, spawn.z) + 0.5
                        : 0.5;

                    // Team-colored fortress platform
                    const teamColor = teamIdx === 0 ? 0x00ccff : 0xff4444; // Cyan for Robots, Red for Hostiles
                    const platformGeo = new THREE.BoxGeometry(6, 0.8, 6);
                    const platformMat = new THREE.MeshStandardMaterial({
                        color: teamColor,
                        emissive: teamColor,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.75,
                        metalness: 0.3,
                        roughness: 0.4
                    });
                    const platform = new THREE.Mesh(platformGeo, platformMat);
                    platform.position.set(spawn.x, spawnY, spawn.z);
                    platform.userData.isSpawnPoint = true;
                    platform.userData.team = teamIdx === 0 ? 'robots' : 'hostiles';
                    laneGroup.add(platform);

                    // Corner pillars for fortress look
                    const pillarGeo = new THREE.BoxGeometry(0.8, 2.5, 0.8);
                    const pillarMat = new THREE.MeshStandardMaterial({
                        color: teamColor,
                        emissive: teamColor,
                        emissiveIntensity: 0.5,
                        metalness: 0.6,
                        roughness: 0.3
                    });
                    [[-2.2, -2.2], [-2.2, 2.2], [2.2, -2.2], [2.2, 2.2]].forEach(([ox, oz]) => {
                        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                        pillar.position.set(spawn.x + ox, spawnY + 1.2, spawn.z + oz);
                        laneGroup.add(pillar);
                    });

                    // Vertical spawn beacon (taller for visibility)
                    const beaconGeo = new THREE.CylinderGeometry(0.4, 0.7, 4, 8);
                    const beaconMat = new THREE.MeshStandardMaterial({
                        color: teamColor,
                        emissive: teamColor,
                        emissiveIntensity: 1.2,
                        transparent: true,
                        opacity: 0.6,
                        metalness: 0.5,
                        roughness: 0.3
                    });
                    const beacon = new THREE.Mesh(beaconGeo, beaconMat);
                    beacon.position.set(spawn.x, spawnY + 2.5, spawn.z);
                    beacon.userData.isSpawnBeacon = true;
                    beacon.userData.pulsePhase = Math.random() * Math.PI * 2;
                    laneGroup.add(beacon);

                    // Base name floating label
                    const baseCanvas = document.createElement('canvas');
                    baseCanvas.width = 256;
                    baseCanvas.height = 80;
                    const baseCtx = baseCanvas.getContext('2d');

                    // Background
                    baseCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    baseCtx.fillRect(0, 0, 256, 80);

                    // Team indicator
                    baseCtx.fillStyle = teamIdx === 0 ? '#00ccff' : '#ff4444';
                    baseCtx.font = 'bold 14px Arial';
                    baseCtx.textAlign = 'center';
                    baseCtx.fillText(teamLabels[teamIdx], 128, 20);

                    // Base name
                    baseCtx.fillStyle = '#ffffff';
                    baseCtx.font = 'bold 22px Arial';
                    baseCtx.fillText(baseNames[teamIdx], 128, 50);

                    // Faction icon
                    baseCtx.font = '18px Arial';
                    baseCtx.fillText(teamIdx === 0 ? '' : '', 128, 72);

                    const baseTexture = new THREE.CanvasTexture(baseCanvas);
                    const baseSpriteMat = new THREE.SpriteMaterial({
                        map: baseTexture,
                        transparent: true,
                        opacity: 0.95
                    });
                    const baseSprite = new THREE.Sprite(baseSpriteMat);
                    baseSprite.position.set(spawn.x, spawnY + 6, spawn.z);
                    baseSprite.scale.set(12, 4, 1);
                    scene.add(baseSprite);
                    creepWaveState.laneVisuals.push(baseSprite);
                });

                scene.add(laneGroup);
                creepWaveState.laneVisuals.push(laneGroup);

                // Lane name label at choke point (contested zone)
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');

                // v6.69: Subtle background panel (reduced opacity)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, 320, 100);

                // Border in lane color (thinner, subtle)
                ctx.strokeStyle = `#${lane.color.toString(16).padStart(6, '0')}`;
                ctx.lineWidth = 2;
                ctx.strokeRect(2, 2, 316, 96);

                // Lane name (main title)
                ctx.fillStyle = `#${lane.color.toString(16).padStart(6, '0')}`;
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(lane.name.toUpperCase(), 160, 32);

                // Choke point name
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(` ${lane.chokePointName} `, 160, 58);

                // Contested zone indicator
                ctx.fillStyle = '#ffcc00';
                ctx.font = '14px Arial';
                ctx.fillText(' CONTESTED ZONE ', 160, 82);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.7,  // v6.69: More subtle, less intrusive
                    depthTest: true,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMat);
                const midWp = lane.waypoints[lane.chokePointIndex];
                const midY = typeof getTerrainHeight === 'function'
                    ? getTerrainHeight(midWp.x, midWp.z) + 2.5
                    : 2.5;
                sprite.position.set(midWp.x, midY, midWp.z);
                // v6.69: Reduced scale significantly - was 20x7, now 6x2.1 (subtle floating label)
                sprite.scale.set(6, 2.1, 1);
                scene.add(sprite);
                creepWaveState.laneVisuals.push(sprite);
            });

            console.log('v6.69: Lane block visuals created (smaller labels)');
        }

        // v6.67: Animate lane blocks (pulsing, glowing effects)
        function animateLaneBlocks(time) {
            if (!creepWaveState.laneVisuals || creepWaveState.laneVisuals.length === 0) return;

            creepWaveState.laneVisuals.forEach(visual => {
                if (!visual.isGroup) return;

                visual.children.forEach(child => {
                    // Animate lane markers (pulsing)
                    if (child.userData.isLaneMarker) {
                        const phase = child.userData.pulsePhase || 0;
                        const pulse = 0.8 + Math.sin(time * 0.003 + phase) * 0.4;
                        child.material.emissiveIntensity = pulse;
                        child.scale.y = 0.9 + Math.sin(time * 0.002 + phase) * 0.1;
                    }

                    // Animate spawn beacons (rotating glow)
                    if (child.userData.isSpawnBeacon) {
                        const phase = child.userData.pulsePhase || 0;
                        child.rotation.y = time * 0.001 + phase;
                        child.material.emissiveIntensity = 0.8 + Math.sin(time * 0.004 + phase) * 0.4;
                    }

                    // Animate spawn platforms (subtle pulse)
                    if (child.userData.isSpawnPoint) {
                        const pulse = 0.7 + Math.sin(time * 0.002) * 0.1;
                        child.material.emissiveIntensity = pulse;
                    }

                    // Animate pulsing pattern blocks (bot lane)
                    if (child.userData.laneKey === 'bot' && child.userData.blockIndex !== undefined) {
                        const idx = child.userData.blockIndex;
                        const wave = Math.sin(time * 0.002 - idx * 0.3);
                        child.material.emissiveIntensity = child.userData.baseEmissive * (0.7 + wave * 0.3);
                        child.material.opacity = child.userData.baseOpacity * (0.8 + wave * 0.2);
                    }

                    // v6.67: Animate bridge warning lights (alternating flash)
                    if (child.userData.isBridgeLight) {
                        const phase = child.userData.pulsePhase || 0;
                        const flash = Math.sin(time * 0.005 + phase) > 0 ? 1.5 : 0.3;
                        child.material.emissiveIntensity = flash;
                        child.material.opacity = 0.5 + flash * 0.3;
                    }
                });
            });
        }

        // Create markers at choke points where battles happen
        function createChokePointMarkers() {
            if (!scene) return;

            Object.entries(LANE_DEFINITIONS).forEach(([laneKey, lane]) => {
                const chokeWp = lane.waypoints[lane.chokePointIndex];
                const y = typeof getTerrainHeight === 'function'
                    ? getTerrainHeight(chokeWp.x, chokeWp.z) + 0.1
                    : 0.1;

                // Battle zone ring
                const ringGeo = new THREE.RingGeometry(4, 5, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: lane.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.4
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.set(chokeWp.x, y, chokeWp.z);
                ring.rotation.x = -Math.PI / 2;
                ring.userData.isChokePoint = true;
                ring.userData.laneKey = laneKey;
                scene.add(ring);
                creepWaveState.laneVisuals.push(ring);

                // Inner pulsing circle
                const innerGeo = new THREE.CircleGeometry(3, 32);
                const innerMat = new THREE.MeshBasicMaterial({
                    color: lane.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.15
                });
                const inner = new THREE.Mesh(innerGeo, innerMat);
                inner.position.set(chokeWp.x, y + 0.05, chokeWp.z);
                inner.rotation.x = -Math.PI / 2;
                inner.userData.pulsePhase = Math.random() * Math.PI * 2;
                scene.add(inner);
                creepWaveState.laneVisuals.push(inner);
            });
        }

        // Spawn a wave of creeps for both teams
        function spawnCreepWave() {
            if (!creepWaveState.enabled || mode !== 'world') return;

            creepWaveState.waveNumber++;
            const waveNum = creepWaveState.waveNumber;

            // Spawn for each lane
            Object.entries(LANE_DEFINITIONS).forEach(([laneKey, lane]) => {
                // Team A creeps (from negative spawn)
                for (let i = 0; i < CREEP_WAVE_CONFIG.creepsPerWave; i++) {
                    setTimeout(() => {
                        spawnCreep('A', laneKey, lane, i);
                    }, i * 300); // Stagger spawns
                }

                // Team B creeps (from positive spawn)
                for (let i = 0; i < CREEP_WAVE_CONFIG.creepsPerWave; i++) {
                    setTimeout(() => {
                        spawnCreep('B', laneKey, lane, i);
                    }, i * 300);
                }
            });

            // Announce wave
            if (waveNum === 1) {
                showNotification(' Creep waves have begun!', 'info');
            } else if (waveNum % 5 === 0) {
                showNotification(` Wave ${waveNum} deployed!`, 'info');
            }
        }

        // Spawn a single creep
        function spawnCreep(team, laneKey, lane, index) {
            if (!scene) return;

            const spawn = team === 'A' ? lane.teamASpawn : lane.teamBSpawn;
            const waypointPath = team === 'A'
                ? [...lane.waypoints]  // Forward through waypoints
                : [...lane.waypoints].reverse();  // Reverse for team B

            // Creep appearance
            const teamColor = team === 'A' ? 0x00ff88 : 0xff4444;  // Green vs Red
            const creepGeo = new THREE.BoxGeometry(0.8, 1.2, 0.8);
            const creepMat = new THREE.MeshStandardMaterial({
                color: teamColor,
                emissive: teamColor,
                emissiveIntensity: 0.3,
                roughness: 0.5
            });
            const creep = new THREE.Mesh(creepGeo, creepMat);

            // Position at spawn with slight offset
            const spawnY = typeof getTerrainHeight === 'function'
                ? getTerrainHeight(spawn.x, spawn.z) + 0.6
                : 0.6;
            const offsetX = (Math.random() - 0.5) * 2;
            const offsetZ = (Math.random() - 0.5) * 2;
            creep.position.set(spawn.x + offsetX, spawnY, spawn.z + offsetZ);
            creep.castShadow = true;

            // Team banner on top
            const bannerGeo = new THREE.PlaneGeometry(0.5, 0.8);
            const bannerMat = new THREE.MeshBasicMaterial({
                color: team === 'A' ? 0x00ff00 : 0xff0000,
                side: THREE.DoubleSide
            });
            const banner = new THREE.Mesh(bannerGeo, bannerMat);
            banner.position.y = 1.0;
            banner.rotation.y = Math.PI / 4;
            creep.add(banner);

            // HP bar
            const hpBarGeo = new THREE.PlaneGeometry(1.2, 0.15);
            const hpBarMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const hpBar = new THREE.Mesh(hpBarGeo, hpBarMat);
            hpBar.position.y = 1.5;
            creep.add(hpBar);

            const hpBgGeo = new THREE.PlaneGeometry(1.3, 0.2);
            const hpBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const hpBg = new THREE.Mesh(hpBgGeo, hpBgMat);
            hpBg.position.y = 1.5;
            hpBg.position.z = -0.01;
            creep.add(hpBg);

            // v6.68: Creep names for targeting display
            const creepNames = team === 'A'
                ? ['Battle Drone', 'Scout Bot', 'Combat Unit', 'Siege Walker']
                : ['Fauna Swarm', 'Hive Warrior', 'Acid Spitter', 'Brood Hunter'];
            const creepName = creepNames[Math.floor(Math.random() * creepNames.length)];

            // Store creep data
            creep.userData = {
                type: 'creep',
                name: creepName,  // v6.68: Added name for tooltip display
                team: team,
                laneKey: laneKey,
                hp: CREEP_WAVE_CONFIG.creepHp,
                maxHp: CREEP_WAVE_CONFIG.creepHp,
                damage: CREEP_WAVE_CONFIG.creepDamage,
                speed: CREEP_WAVE_CONFIG.creepSpeed,
                waypoints: waypointPath,
                currentWaypointIndex: 0,
                hpBar: hpBar,
                nextAttack: 0,
                target: null,
                state: 'moving'  // moving, fighting, dead
            };

            scene.add(creep);
            creepWaveState.creeps.push(creep);
        }

        // Update all creeps (called each frame)
        function updateCreepWaves(dt, time) {
            if (!creepWaveState.enabled || mode !== 'world') return;

            // v6.67: Animate lane block visuals
            animateLaneBlocks(time);

            // Check if it's time to spawn a new wave
            if (time - creepWaveState.lastWaveTime > CREEP_WAVE_CONFIG.waveInterval) {
                creepWaveState.lastWaveTime = time;
                spawnCreepWave();
            }

            // Update each creep
            for (let i = creepWaveState.creeps.length - 1; i >= 0; i--) {
                const creep = creepWaveState.creeps[i];
                if (!creep || !creep.userData) continue;

                if (creep.userData.hp <= 0) {
                    // Handle death
                    handleCreepDeath(creep, i);
                    continue;
                }

                // Update HP bar
                updateCreepHpBar(creep);

                // Find enemy target
                findCreepTarget(creep);

                // v6.68: Check if target is valid - handle player target differently
                const hasValidTarget = creep.userData.target && (
                    (creep.userData.targetIsPlayer && gameData.player.hp > 0) ||
                    (!creep.userData.targetIsPlayer && creep.userData.target.userData?.hp > 0)
                );

                if (hasValidTarget) {
                    // Has a valid target - fight or move toward it
                    const dist = creep.position.distanceTo(creep.userData.target.position);

                    if (dist <= CREEP_WAVE_CONFIG.creepAttackRange) {
                        // In range - attack
                        creep.userData.state = 'fighting';
                        attackCreepTarget(creep, time);
                    } else {
                        // Move toward target
                        creep.userData.state = 'moving';
                        moveCreepToward(creep, creep.userData.target.position, dt);
                    }
                } else {
                    // No target - follow lane waypoints
                    creep.userData.state = 'moving';
                    creep.userData.target = null;
                    creep.userData.targetIsPlayer = false;
                    followLaneWaypoint(creep, dt);
                }

                // HP bar always faces camera
                if (creep.userData.hpBar) {
                    creep.userData.hpBar.lookAt(camera.position);
                }

                // Snap to ground
                const groundY = typeof getTerrainHeight === 'function'
                    ? getTerrainHeight(creep.position.x, creep.position.z) + 0.6
                    : 0.6;
                creep.position.y = groundY;
            }

            // Animate choke point markers
            creepWaveState.laneVisuals.forEach(visual => {
                if (visual.userData?.pulsePhase !== undefined) {
                    visual.userData.pulsePhase += dt * 2;
                    const pulse = 0.1 + Math.sin(visual.userData.pulsePhase) * 0.08;
                    visual.material.opacity = pulse;
                }
            });
        }

        // Find nearest enemy creep to target
        function findCreepTarget(creep) {
            let nearestEnemy = null;
            let nearestDist = 20; // Max aggro range
            let targetIsPlayer = false;

            creepWaveState.creeps.forEach(other => {
                if (!other || other === creep) return;
                if (other.userData.team === creep.userData.team) return; // Same team
                if (other.userData.hp <= 0) return; // Dead

                const dist = creep.position.distanceTo(other.position);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = other;
                }
            });

            // v6.68: Hostile fauna creeps (team B) also target the player robot
            // Player is considered part of Robot Forces (team A)
            if (creep.userData.team === 'B' && worldState.player && gameData.player.hp > 0) {
                const playerDist = creep.position.distanceTo(worldState.player.position);
                // Prioritize player slightly - use 1.2x distance comparison so player is targeted more aggressively
                if (playerDist < nearestDist * 1.2 && playerDist < 15) {
                    nearestEnemy = worldState.player;
                    nearestDist = playerDist;
                    targetIsPlayer = true;
                }
            }

            creep.userData.target = nearestEnemy;
            creep.userData.targetIsPlayer = targetIsPlayer;
        }

        // Attack the target creep
        function attackCreepTarget(creep, time) {
            if (time < creep.userData.nextAttack) return;

            const target = creep.userData.target;

            // v6.68: Handle player target separately
            if (creep.userData.targetIsPlayer && worldState.player) {
                if (gameData.player.hp <= 0) return;

                // Deal damage to player
                const creepDamage = creep.userData.damage || 3;
                damagePlayer(creepDamage, creep.position);
                creep.userData.nextAttack = time + CREEP_WAVE_CONFIG.creepAttackCooldown;

                // Visual feedback
                spawnFloater(worldState.player.position, `-${creepDamage}`, '#ff4444');
                return;
            }

            if (!target || target.userData.hp <= 0) return;

            // Deal damage
            target.userData.hp -= creep.userData.damage;
            creep.userData.nextAttack = time + CREEP_WAVE_CONFIG.creepAttackCooldown;

            // Visual feedback
            spawnFloater(target.position, `-${creep.userData.damage}`,
                creep.userData.team === 'A' ? '#00ff88' : '#ff4444');

            // Flash the target
            const originalColor = target.material.color.clone();
            target.material.color.setHex(0xffffff);
            setTimeout(() => {
                if (target.material) target.material.color.copy(originalColor);
            }, 100);
        }

        // v6.67: Get correct Y position for creeps (respects bridges)
        // Creeps walk on bridges over water, not through the water
        const CREEP_BRIDGE_HEIGHT = 3.5;  // Bridge deck height (matches lane visuals)
        const CREEP_WATER_LEVEL = 0.5;

        function getCreepTerrainHeight(x, z) {
            // Check if over water (need a bridge)
            if (worldState.terrain) {
                const gx = Math.round(x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
                const gz = Math.round(z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
                if (gx >= 0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                    const terrainY = worldState.terrain[gx]?.[gz];
                    if (terrainY !== undefined && terrainY < -50) {
                        // Over water - use bridge height
                        return CREEP_WATER_LEVEL + CREEP_BRIDGE_HEIGHT;
                    }
                }
            }

            // On land - use regular terrain height
            if (typeof getTerrainHeight === 'function') {
                return getTerrainHeight(x, z) + 0.5;
            }
            return 0.5;
        }

        // Check if creep is on a ramp (transitioning to/from bridge)
        function isOnBridgeRamp(x, z, prevX, prevZ) {
            const currentOverWater = getCreepTerrainHeight(x, z) > 2;
            const prevOverWater = getCreepTerrainHeight(prevX, prevZ) > 2;
            return currentOverWater !== prevOverWater;
        }

        // Move creep toward a position
        function moveCreepToward(creep, targetPos, dt) {
            const direction = new THREE.Vector3()
                .subVectors(targetPos, creep.position)
                .normalize();

            // Store previous position for ramp detection
            const prevX = creep.position.x;
            const prevZ = creep.position.z;

            creep.position.x += direction.x * creep.userData.speed * dt;
            creep.position.z += direction.z * creep.userData.speed * dt;

            // v6.67: Update Y position based on terrain/bridge
            const targetY = getCreepTerrainHeight(creep.position.x, creep.position.z);

            // Smooth Y transition (for ramps)
            const yDiff = targetY - creep.position.y;
            if (Math.abs(yDiff) > 0.1) {
                // Gradually adjust height (ramp effect)
                creep.position.y += yDiff * 0.15;
            } else {
                creep.position.y = targetY;
            }

            // Face movement direction
            creep.rotation.y = Math.atan2(direction.x, direction.z);

            // Tilt slightly when going up/down ramps
            if (Math.abs(yDiff) > 0.3) {
                creep.rotation.x = yDiff > 0 ? -0.15 : 0.15;
            } else {
                creep.rotation.x *= 0.9; // Gradually return to level
            }
        }

        // Follow lane waypoints
        function followLaneWaypoint(creep, dt) {
            const waypoints = creep.userData.waypoints;
            const wpIndex = creep.userData.currentWaypointIndex;

            if (wpIndex >= waypoints.length) {
                // v6.68: Reached end of lane - in versus mode, damage enemy throne!
                if (versusMatchState.active) {
                    // Team A (robot forces) damages hostile throne
                    // Team B (hostile fauna) damages robot throne
                    const targetTeam = creep.userData.team === 'A' ? 'hostile' : 'robot';
                    const creepDamage = creep.userData.damage || CREEP_WAVE_CONFIG.creepDamage;

                    // Only damage if throne exists
                    if (versusMatchState.thrones[targetTeam]) {
                        damageThrone(targetTeam, creepDamage * 2); // Double damage for reaching throne

                        // Despawn the creep after dealing damage
                        creep.userData.hp = 0;
                        return;
                    }
                }

                // Not in versus mode or throne doesn't exist - turn around
                creep.userData.currentWaypointIndex = Math.max(0, waypoints.length - 2);
                return;
            }

            const targetWp = waypoints[wpIndex];
            // v6.67: Target Y is now properly calculated (bridge or ground)
            const targetY = getCreepTerrainHeight(targetWp.x, targetWp.z);
            const targetPos = new THREE.Vector3(targetWp.x, targetY, targetWp.z);

            const dist = new THREE.Vector2(
                creep.position.x - targetWp.x,
                creep.position.z - targetWp.z
            ).length();

            if (dist < 2) {
                // Reached waypoint, move to next
                creep.userData.currentWaypointIndex++;
            } else {
                // Move toward waypoint
                moveCreepToward(creep, targetPos, dt);
            }
        }

        // Update creep HP bar
        function updateCreepHpBar(creep) {
            if (!creep.userData.hpBar) return;

            const hpPercent = creep.userData.hp / creep.userData.maxHp;
            creep.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
            creep.userData.hpBar.position.x = (hpPercent - 1) * 0.6;

            // Color based on HP
            if (hpPercent > 0.5) {
                creep.userData.hpBar.material.color.setHex(0x00ff00);
            } else if (hpPercent > 0.25) {
                creep.userData.hpBar.material.color.setHex(0xffff00);
            } else {
                creep.userData.hpBar.material.color.setHex(0xff0000);
            }
        }

        // ============================================
        // v6.68: DOTA 2-STYLE 3D PLAYER HP/MANA BARS
        // Floating 3D bars with text above the robot
        // ============================================
        function createPlayerHealthBars(playerMesh) {
            const barsGroup = new THREE.Group();
            barsGroup.position.y = 2.8;
            barsGroup.userData.isBillboard = true;

            const barWidth = 2.2;
            const hpBarHeight = 0.25;
            const manaBarHeight = 0.15;
            const barSpacing = 0.06;
            const barDepth = 0.08;

            // === OUTER FRAME (3D box - dark metallic) ===
            const frameGeo = new THREE.BoxGeometry(barWidth + 0.15, hpBarHeight + manaBarHeight + barSpacing + 0.12, barDepth + 0.04);
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.8,
                roughness: 0.3,
                emissive: 0x0a0a15,
                emissiveIntensity: 0.2
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -barDepth / 2;
            barsGroup.add(frame);

            // === HP BAR BACKGROUND (3D dark red box) ===
            const hpBgGeo = new THREE.BoxGeometry(barWidth, hpBarHeight, barDepth);
            const hpBgMat = new THREE.MeshStandardMaterial({
                color: 0x2a0a0a,
                metalness: 0.4,
                roughness: 0.6
            });
            const hpBg = new THREE.Mesh(hpBgGeo, hpBgMat);
            hpBg.position.y = manaBarHeight / 2 + barSpacing / 2;
            barsGroup.add(hpBg);

            // === HP BAR FILL (3D green - Dota style with glow) ===
            const hpFillGeo = new THREE.BoxGeometry(barWidth - 0.02, hpBarHeight - 0.02, barDepth + 0.01);
            const hpFillMat = new THREE.MeshStandardMaterial({
                color: 0x3cb043,
                emissive: 0x1a5a1a,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            const hpFill = new THREE.Mesh(hpFillGeo, hpFillMat);
            hpFill.position.y = manaBarHeight / 2 + barSpacing / 2;
            hpFill.position.z = 0.02;
            barsGroup.add(hpFill);

            // === MANA/ENERGY BAR BACKGROUND (3D dark blue) ===
            const manaBgGeo = new THREE.BoxGeometry(barWidth, manaBarHeight, barDepth);
            const manaBgMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a2a,
                metalness: 0.4,
                roughness: 0.6
            });
            const manaBg = new THREE.Mesh(manaBgGeo, manaBgMat);
            manaBg.position.y = -hpBarHeight / 2 - barSpacing / 2;
            barsGroup.add(manaBg);

            // === MANA BAR FILL (3D blue with glow) ===
            const manaFillGeo = new THREE.BoxGeometry(barWidth - 0.02, manaBarHeight - 0.02, barDepth + 0.01);
            const manaFillMat = new THREE.MeshStandardMaterial({
                color: 0x2878bd,
                emissive: 0x1a4a7a,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            const manaFill = new THREE.Mesh(manaFillGeo, manaFillMat);
            manaFill.position.y = -hpBarHeight / 2 - barSpacing / 2;
            manaFill.position.z = 0.02;
            barsGroup.add(manaFill);

            // === HP SEGMENT DIVIDERS (3D notches) ===
            for (let i = 1; i < 4; i++) {
                const segX = -barWidth / 2 + (barWidth / 4) * i;
                const segGeo = new THREE.BoxGeometry(0.03, hpBarHeight + 0.02, barDepth + 0.03);
                const segMat = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const seg = new THREE.Mesh(segGeo, segMat);
                seg.position.set(segX, manaBarHeight / 2 + barSpacing / 2, 0.03);
                barsGroup.add(seg);
            }

            // === LEVEL BADGE (3D cylinder) ===
            const levelBadgeGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
            const levelBadgeMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0x886600,
                emissiveIntensity: 0.4,
                metalness: 0.8,
                roughness: 0.2
            });
            const levelBadge = new THREE.Mesh(levelBadgeGeo, levelBadgeMat);
            levelBadge.rotation.x = Math.PI / 2;
            levelBadge.position.set(-barWidth / 2 - 0.3, 0, 0.05);
            barsGroup.add(levelBadge);

            // === 3D TEXT: HP VALUE ===
            const hpTextGroup = new THREE.Group();
            hpTextGroup.position.set(0, manaBarHeight / 2 + barSpacing / 2 + 0.35, 0.1);
            barsGroup.add(hpTextGroup);

            // === 3D TEXT: MANA VALUE ===
            const manaTextGroup = new THREE.Group();
            manaTextGroup.position.set(0, -hpBarHeight / 2 - barSpacing / 2 - 0.25, 0.1);
            barsGroup.add(manaTextGroup);

            // === 3D TEXT: PLAYER NAME (styled like LEVIATHAN title) ===
            const nameTextGroup = new THREE.Group();
            nameTextGroup.position.set(0, hpBarHeight + manaBarHeight + 0.5, 0.1);
            barsGroup.add(nameTextGroup);

            // Store references
            playerMesh.userData.dotaBars = {
                group: barsGroup,
                hpFill: hpFill,
                hpFillMat: hpFillMat,
                manaFill: manaFill,
                levelBadge: levelBadge,
                levelBadgeMat: levelBadgeMat,
                hpTextGroup: hpTextGroup,
                manaTextGroup: manaTextGroup,
                nameTextGroup: nameTextGroup,
                barWidth: barWidth,
                lastHp: gameData.player.hp,
                lastHpText: '',
                lastManaText: '',
                nameCreated: false
            };

            playerMesh.add(barsGroup);

            // v6.69: Hide the 3D bars - we now use the 2D UI version above the ability bar
            barsGroup.visible = false;

            // Create 3D text after font loads
            setTimeout(() => createPlayerBar3DText(playerMesh), 100);
        }

        // Create 3D text for player bars (uses loaded font)
        function createPlayerBar3DText(playerMesh) {
            if (!playerMesh.userData.dotaBars) return;
            if (!window.copilot3DFont) {
                setTimeout(() => createPlayerBar3DText(playerMesh), 200);
                return;
            }

            const bars = playerMesh.userData.dotaBars;
            const font = window.copilot3DFont;

            // Create player name text (LEVIATHAN style)
            try {
                const nameGeo = new THREE.TextGeometry('EXPLORER', {
                    font: font,
                    size: 0.18,
                    height: 0.04,
                    curveSegments: 8,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.008,
                    bevelSegments: 3
                });
                nameGeo.computeBoundingBox();
                nameGeo.center();

                const nameMat = new THREE.MeshStandardMaterial({
                    color: 0x66ccff,
                    emissive: 0x224466,
                    emissiveIntensity: 0.6,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const nameMesh = new THREE.Mesh(nameGeo, nameMat);
                bars.nameTextGroup.add(nameMesh);
                bars.nameCreated = true;
            } catch (e) {
                console.warn('Failed to create player name 3D text:', e);
            }
        }

        // Update HP text mesh
        function updatePlayerHpText(bars, hpText) {
            if (!window.copilot3DFont || bars.lastHpText === hpText) return;
            bars.lastHpText = hpText;

            // Clear old text
            while (bars.hpTextGroup.children.length > 0) {
                const child = bars.hpTextGroup.children[0];
                bars.hpTextGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            try {
                const textGeo = new THREE.TextGeometry(hpText, {
                    font: window.copilot3DFont,
                    size: 0.12,
                    height: 0.02,
                    curveSegments: 6,
                    bevelEnabled: false
                });
                textGeo.computeBoundingBox();
                textGeo.center();

                const textMat = new THREE.MeshStandardMaterial({
                    color: 0x44ff44,
                    emissive: 0x22aa22,
                    emissiveIntensity: 0.8,
                    metalness: 0.5,
                    roughness: 0.3
                });
                const textMesh = new THREE.Mesh(textGeo, textMat);
                bars.hpTextGroup.add(textMesh);
            } catch (e) { /* ignore */ }
        }

        // Update Mana text mesh
        function updatePlayerManaText(bars, manaText) {
            if (!window.copilot3DFont || bars.lastManaText === manaText) return;
            bars.lastManaText = manaText;

            // Clear old text
            while (bars.manaTextGroup.children.length > 0) {
                const child = bars.manaTextGroup.children[0];
                bars.manaTextGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            try {
                const textGeo = new THREE.TextGeometry(manaText, {
                    font: window.copilot3DFont,
                    size: 0.09,
                    height: 0.015,
                    curveSegments: 6,
                    bevelEnabled: false
                });
                textGeo.computeBoundingBox();
                textGeo.center();

                const textMat = new THREE.MeshStandardMaterial({
                    color: 0x4488ff,
                    emissive: 0x2266aa,
                    emissiveIntensity: 0.8,
                    metalness: 0.5,
                    roughness: 0.3
                });
                const textMesh = new THREE.Mesh(textGeo, textMat);
                bars.manaTextGroup.add(textMesh);
            } catch (e) { /* ignore */ }
        }

        // Update player HP/Mana bars each frame
        function updatePlayerDotaBars(dt, time) {
            if (!worldState.player || !worldState.player.userData.dotaBars) return;
            if (!gameData || !gameData.player) return;

            const bars = worldState.player.userData.dotaBars;
            if (!bars.hpFill || !bars.manaFill || !bars.hpFillMat) return;

            const barWidth = bars.barWidth;

            // === HP BAR UPDATE ===
            const hp = Math.floor(gameData.player.hp);
            const maxHp = Math.floor(gameData.player.maxHp);
            const hpPercent = Math.max(0, Math.min(1, hp / maxHp));

            bars.hpFill.scale.x = Math.max(0.001, hpPercent);
            bars.hpFill.position.x = -(1 - hpPercent) * barWidth / 2;

            // HP color and glow based on health
            if (hpPercent > 0.6) {
                bars.hpFillMat.color.setHex(0x3cb043);
                bars.hpFillMat.emissive.setHex(0x1a5a1a);
            } else if (hpPercent > 0.3) {
                bars.hpFillMat.color.setHex(0xdaa520);
                bars.hpFillMat.emissive.setHex(0x6a4a10);
            } else {
                bars.hpFillMat.color.setHex(0xc41e3a);
                bars.hpFillMat.emissive.setHex(0x5a0a1a);
                // Pulse when low HP
                bars.hpFillMat.emissiveIntensity = 0.5 + Math.sin(time * 0.008) * 0.3;
            }

            // Update 3D HP text
            const hpText = `${hp} / ${maxHp}`;
            updatePlayerHpText(bars, hpText);

            // === MANA/ENERGY BAR UPDATE ===
            const energy = Math.floor(robotEnergy?.current ?? 100);
            const maxEnergy = Math.floor(robotEnergy?.max ?? 100);
            const energyPercent = Math.max(0, Math.min(1, energy / maxEnergy));

            bars.manaFill.scale.x = Math.max(0.001, energyPercent);
            bars.manaFill.position.x = -(1 - energyPercent) * barWidth / 2;

            // Update 3D mana text
            const manaText = `${energy} / ${maxEnergy}`;
            updatePlayerManaText(bars, manaText);

            // === BILLBOARD: Make bars always face camera (world space) ===
            if (camera && bars.group && worldState.player) {
                // Get the world position of the bars
                const barWorldPos = new THREE.Vector3();
                bars.group.getWorldPosition(barWorldPos);

                // Calculate direction from bars to camera in world space
                const camPos = camera.position.clone();
                const dirToCamera = new THREE.Vector3().subVectors(camPos, barWorldPos);
                dirToCamera.y = 0; // Keep horizontal
                dirToCamera.normalize();

                // Calculate the world rotation needed to face camera
                const targetAngle = Math.atan2(dirToCamera.x, dirToCamera.z);

                // Get the player's current Y rotation (world space)
                const playerWorldQuat = new THREE.Quaternion();
                worldState.player.getWorldQuaternion(playerWorldQuat);
                const playerEuler = new THREE.Euler().setFromQuaternion(playerWorldQuat);
                const playerYRot = playerEuler.y;

                // Set local rotation to counter player rotation and face camera
                // Local rotation = target world rotation - parent world rotation
                bars.group.rotation.set(0, targetAngle - playerYRot, 0);
            }

            // === LEVEL BADGE UPDATE ===
            const combatLevel = gameData.skills.combat.level || 1;
            if (combatLevel >= 20) {
                bars.levelBadgeMat.color.setHex(0xff4400);
                bars.levelBadgeMat.emissive.setHex(0x661100);
            } else if (combatLevel >= 10) {
                bars.levelBadgeMat.color.setHex(0xffd700);
                bars.levelBadgeMat.emissive.setHex(0x664400);
            } else if (combatLevel >= 5) {
                bars.levelBadgeMat.color.setHex(0xc0c0c0);
                bars.levelBadgeMat.emissive.setHex(0x444444);
            } else {
                bars.levelBadgeMat.color.setHex(0xcd7f32);
                bars.levelBadgeMat.emissive.setHex(0x442200);
            }

            // Rotate level badge for shine effect
            bars.levelBadge.rotation.z += dt * 0.001;
        }

        // ============================================
        // v6.69: 2D UI DOTA BARS (above ability bar)
        // ============================================
        function updateDotaBarsUI() {
            if (!gameData || !gameData.player) return;

            // v6.84: Use cached DOM references for frequent UI updates
            const cache = getUICache();
            const hpFill = cache.dotaHpFill;
            const hpText = cache.dotaHpText;
            const manaFill = cache.dotaManaFill;
            const manaText = cache.dotaManaText;
            const levelBadge = document.getElementById('dota-level-badge');

            if (!hpFill || !hpText || !manaFill || !manaText) return;

            // HP values
            const hp = Math.floor(gameData.player.hp);
            const maxHp = Math.floor(gameData.player.maxHp);
            const hpPercent = Math.max(0, Math.min(100, (hp / maxHp) * 100));

            hpFill.style.width = hpPercent + '%';
            hpText.textContent = `${hp} / ${maxHp}`;

            // HP color based on percentage
            if (hpPercent > 60) {
                hpFill.style.background = 'linear-gradient(180deg, #4cd054 0%, #3cb043 50%, #2a8030 100%)';
            } else if (hpPercent > 30) {
                hpFill.style.background = 'linear-gradient(180deg, #f0c040 0%, #daa520 50%, #b08010 100%)';
            } else {
                hpFill.style.background = 'linear-gradient(180deg, #e04050 0%, #c41e3a 50%, #901020 100%)';
            }

            // Energy/Mana values
            const energy = Math.floor(robotEnergy?.current ?? 100);
            const maxEnergy = Math.floor(robotEnergy?.max ?? 100);
            const energyPercent = Math.max(0, Math.min(100, (energy / maxEnergy) * 100));

            manaFill.style.width = energyPercent + '%';
            manaText.textContent = `${energy} / ${maxEnergy}`;

            // Level badge
            if (levelBadge) {
                const combatLevel = gameData.skills?.combat?.level || 1;
                levelBadge.textContent = combatLevel;

                // Color badge based on level
                if (combatLevel >= 20) {
                    levelBadge.style.background = 'linear-gradient(135deg, #ff4400 0%, #aa2200 100%)';
                    levelBadge.style.borderColor = '#ff4400';
                    levelBadge.style.boxShadow = '0 0 12px rgba(255,68,0,0.7)';
                } else if (combatLevel >= 10) {
                    levelBadge.style.background = 'linear-gradient(135deg, #ffd700 0%, #b8860b 100%)';
                    levelBadge.style.borderColor = '#ffd700';
                    levelBadge.style.boxShadow = '0 0 8px rgba(255,215,0,0.5)';
                } else if (combatLevel >= 5) {
                    levelBadge.style.background = 'linear-gradient(135deg, #c0c0c0 0%, #808080 100%)';
                    levelBadge.style.borderColor = '#c0c0c0';
                    levelBadge.style.boxShadow = '0 0 6px rgba(192,192,192,0.4)';
                } else {
                    levelBadge.style.background = 'linear-gradient(135deg, #cd7f32 0%, #8b4513 100%)';
                    levelBadge.style.borderColor = '#cd7f32';
                    levelBadge.style.boxShadow = '0 0 4px rgba(205,127,50,0.3)';
                }
            }
        }

        // ============================================
        // END DOTA 2-STYLE PLAYER BARS
        // ============================================

        // Handle creep death
        function handleCreepDeath(creep, index) {
            // Check if player is nearby for rewards
            if (worldState.player) {
                const playerDist = creep.position.distanceTo(worldState.player.position);
                if (playerDist <= CREEP_WAVE_CONFIG.playerRewardRadius) {
                    // Award XP and gold
                    if (typeof addXp === 'function') {
                        addXp('combat', CREEP_WAVE_CONFIG.xpPerCreep);
                    }
                    gameData.gold = (gameData.gold || 0) + CREEP_WAVE_CONFIG.goldPerCreep;

                    spawnFloater(creep.position,
                        `+${CREEP_WAVE_CONFIG.xpPerCreep} XP`, '#ffff00');

                    // v6.65: Increase companion bond for watching creep battles
                    if (Math.random() < 0.2) {
                        increaseCompanionBond(0.2);
                    }
                }
            }

            // Death particles
            spawnCreepDeathParticles(creep.position.clone(), creep.userData.team);

            // Remove from scene
            scene.remove(creep);
            if (creep.geometry) creep.geometry.dispose();
            if (creep.material) creep.material.dispose();

            // Remove from array
            creepWaveState.creeps.splice(index, 1);
        }

        // Death particle effect for creeps
        function spawnCreepDeathParticles(position, team) {
            if (!scene) return;

            const particleCount = 15;
            const color = team === 'A' ? 0x00ff88 : 0xff4444;

            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.SphereGeometry(0.1, 4, 4);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.15 + 0.1,
                    (Math.random() - 0.5) * 0.2
                );

                scene.add(particle);

                let frame = 0;
                const animate = () => {
                    frame++;
                    particle.position.add(velocity);
                    velocity.y -= 0.008;
                    mat.opacity = 1 - (frame / 40);

                    if (frame < 40) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(particle);
                        geo.dispose();
                        mat.dispose();
                    }
                };
                animate();
            }
        }

        // Cleanup creep system when leaving world
        function cleanupCreepSystem() {
            // Remove all creeps
            creepWaveState.creeps.forEach(creep => {
                if (creep.parent) creep.parent.remove(creep);
                if (creep.geometry) creep.geometry.dispose();
                if (creep.material) creep.material.dispose();
            });
            creepWaveState.creeps = [];

            // Remove lane visuals
            creepWaveState.laneVisuals.forEach(visual => {
                if (visual.parent) visual.parent.remove(visual);
                if (visual.geometry) visual.geometry.dispose();
                if (visual.material) visual.material.dispose();
            });
            creepWaveState.laneVisuals = [];

            creepWaveState.enabled = false;
            creepWaveState.initialized = false;

            // v6.67: Cleanup lane support system
            if (typeof cleanupLaneSupportSystem === 'function') {
                cleanupLaneSupportSystem();
            }
        }

        // ============================================
        // v6.67: LANE SUPPORT & FORTIFICATION SYSTEM
        // Agents can be assigned to support lanes, buff creeps,
        // and dynamically build fortifications based on lane control
        // ============================================

        const LANE_SUPPORT_CONFIG = {
            enabled: true,
            agentBuffRadius: 12,          // Range for agent to buff creeps
            buffCheckInterval: 500,        // ms between buff checks
            fortBuildInterval: 30000,      // ms between fort attempts (30 sec)
            maxFortsPerLane: 4,            // Max fortifications per lane
            controlUpdateInterval: 2000,   // ms between control recalculations
            creepBuffs: {
                damage: 1.25,              // 25% damage boost
                speed: 1.15,               // 15% speed boost
                hp: 1.20,                  // 20% HP boost when spawned near agent
                healPerSecond: 2           // HP regen when near agent
            }
        };

        // Fortification types - progressively stronger
        const LANE_FORTIFICATIONS = {
            outpost: {
                name: 'Forward Outpost',
                icon: '',
                tier: 1,
                buildTime: 30000,           // 30 seconds
                hp: 150,
                visionRadius: 15,
                creepBuff: { damage: 1.1, speed: 1.05 },
                size: { x: 3, y: 2, z: 3 },
                color: 0x8b7355,
                cost: { controlPoints: 10 }
            },
            supplyCache: {
                name: 'Supply Cache',
                icon: '',
                tier: 2,
                buildTime: 60000,           // 1 minute
                hp: 200,
                healRadius: 10,
                healAmount: 5,              // HP per second to nearby creeps
                creepBuff: { damage: 1.15, hp: 1.1 },
                size: { x: 4, y: 2.5, z: 4 },
                color: 0x4a7c59,
                cost: { controlPoints: 25 }
            },
            watchtower: {
                name: 'Watchtower',
                icon: '',
                tier: 2,
                buildTime: 90000,           // 1.5 minutes
                hp: 300,
                attackDamage: 8,
                attackRange: 18,
                attackCooldown: 1500,
                size: { x: 2, y: 6, z: 2 },
                color: 0x666688,
                cost: { controlPoints: 35 }
            },
            bunker: {
                name: 'Defensive Bunker',
                icon: '',
                tier: 3,
                buildTime: 120000,          // 2 minutes
                hp: 500,
                attackDamage: 15,
                attackRange: 20,
                attackCooldown: 2000,
                creepBuff: { damage: 1.2, speed: 1.1, hp: 1.15 },
                spawnExtraCreeps: true,
                size: { x: 5, y: 3, z: 5 },
                color: 0x555577,
                cost: { controlPoints: 50 }
            },
            stronghold: {
                name: 'Stronghold',
                icon: '',
                tier: 4,
                buildTime: 180000,          // 3 minutes
                hp: 800,
                attackDamage: 25,
                attackRange: 25,
                attackCooldown: 1800,
                creepBuff: { damage: 1.3, speed: 1.15, hp: 1.25 },
                spawnExtraCreeps: true,
                extraCreepsPerWave: 2,
                auraRadius: 20,
                size: { x: 7, y: 5, z: 7 },
                color: 0x334455,
                cost: { controlPoints: 100 }
            }
        };

        // Lane support state
        let laneSupportState = {
            enabled: false,
            initialized: false,
            laneControl: {},              // Control state per lane segment
            assignedAgents: {},           // Agents assigned to lanes
            fortifications: [],           // Built fortifications
            buildQueue: [],               // Forts being built
            lastControlUpdate: 0,
            lastFortCheck: 0,
            controlPoints: {              // Earned through lane dominance
                top: 0,
                mid: 0,
                bot: 0
            }
        };

        // Initialize lane support system
        function initLaneSupportSystem() {
            if (!LANE_SUPPORT_CONFIG.enabled) return;

            // Initialize lane control for each lane
            Object.keys(LANE_DEFINITIONS).forEach(laneKey => {
                const lane = LANE_DEFINITIONS[laneKey];
                const segments = lane.waypoints.length - 1;

                laneSupportState.laneControl[laneKey] = {
                    segments: Array(segments).fill(0),  // -1 to 1 (hostile to friendly)
                    overallControl: 0,                   // -1 to 1
                    frontlineIndex: Math.floor(segments / 2), // Where the battle is
                    momentum: 0,                         // Push momentum
                    lastBattleTime: 0
                };
            });

            laneSupportState.enabled = true;
            laneSupportState.initialized = true;
            laneSupportState.fortifications = [];
            laneSupportState.buildQueue = [];
            laneSupportState.assignedAgents = { top: [], mid: [], bot: [] };

            console.log('v6.67: Lane Support & Fortification System initialized');
        }

        // Assign an agent to support a lane
        function assignAgentToLane(agent, laneKey) {
            if (!laneSupportState.enabled) return false;
            if (!LANE_DEFINITIONS[laneKey]) return false;

            // Remove from any existing lane assignment
            Object.keys(laneSupportState.assignedAgents).forEach(key => {
                const idx = laneSupportState.assignedAgents[key].indexOf(agent);
                if (idx !== -1) {
                    laneSupportState.assignedAgents[key].splice(idx, 1);
                }
            });

            // Assign to new lane
            laneSupportState.assignedAgents[laneKey].push(agent);
            agent.assignedLane = laneKey;
            agent.laneRole = 'support';

            const lane = LANE_DEFINITIONS[laneKey];
            showNotification(`${agent.name} assigned to ${lane.name}`, 'info');
            addCopilotMessage(` Agent ${agent.name} deployed to ${lane.name}. They will buff nearby creeps and build fortifications as we gain control.`, 'ai');

            return true;
        }

        // Update lane control based on creep positions and battles
        function updateLaneControl(time) {
            if (!laneSupportState.enabled) return;
            if (time - laneSupportState.lastControlUpdate < LANE_SUPPORT_CONFIG.controlUpdateInterval) return;
            laneSupportState.lastControlUpdate = time;

            Object.keys(LANE_DEFINITIONS).forEach(laneKey => {
                const lane = LANE_DEFINITIONS[laneKey];
                const control = laneSupportState.laneControl[laneKey];
                const waypoints = lane.waypoints;

                // Count creeps in each segment
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const segStart = waypoints[i];
                    const segEnd = waypoints[i + 1];
                    const segMidX = (segStart.x + segEnd.x) / 2;
                    const segMidZ = (segStart.z + segEnd.z) / 2;

                    let friendlyCount = 0;
                    let hostileCount = 0;

                    creepWaveState.creeps.forEach(creep => {
                        if (!creep.userData || creep.userData.lane !== laneKey) return;
                        const dist = Math.sqrt(
                            Math.pow(creep.position.x - segMidX, 2) +
                            Math.pow(creep.position.z - segMidZ, 2)
                        );
                        if (dist < 15) {
                            if (creep.userData.team === 'A') friendlyCount++;
                            else hostileCount++;
                        }
                    });

                    // Check for assigned agents in segment
                    laneSupportState.assignedAgents[laneKey]?.forEach(agent => {
                        if (!agent.mesh) return;
                        const dist = Math.sqrt(
                            Math.pow(agent.mesh.position.x - segMidX, 2) +
                            Math.pow(agent.mesh.position.z - segMidZ, 2)
                        );
                        if (dist < 20) {
                            friendlyCount += 3; // Agents count as 3 creeps for control
                        }
                    });

                    // Update segment control (-1 to 1)
                    const total = friendlyCount + hostileCount;
                    if (total > 0) {
                        const newControl = (friendlyCount - hostileCount) / total;
                        // Smooth transition
                        control.segments[i] = control.segments[i] * 0.7 + newControl * 0.3;
                    } else {
                        // Decay toward neutral
                        control.segments[i] *= 0.95;
                    }
                }

                // Calculate overall control
                const avgControl = control.segments.reduce((a, b) => a + b, 0) / control.segments.length;
                control.overallControl = avgControl;

                // Calculate frontline (where control shifts from positive to negative)
                let frontline = lane.chokePointIndex;
                for (let i = 0; i < control.segments.length; i++) {
                    if (control.segments[i] < 0) {
                        frontline = i;
                        break;
                    }
                }
                control.frontlineIndex = frontline;

                // Calculate momentum (rate of change)
                control.momentum = avgControl - (control.prevControl || 0);
                control.prevControl = avgControl;

                // Earn control points for lane dominance
                if (avgControl > 0.3) {
                    laneSupportState.controlPoints[laneKey] += avgControl * 0.5;
                }
            });
        }

        // Buff creeps near assigned agents
        function updateAgentCreepBuffs(time) {
            if (!laneSupportState.enabled) return;

            Object.keys(laneSupportState.assignedAgents).forEach(laneKey => {
                const agents = laneSupportState.assignedAgents[laneKey];
                if (!agents || agents.length === 0) return;

                agents.forEach(agent => {
                    if (!agent.mesh) return;
                    const agentPos = agent.mesh.position;

                    // Find nearby friendly creeps
                    creepWaveState.creeps.forEach(creep => {
                        if (!creep.userData) return;
                        if (creep.userData.team !== 'A') return; // Only buff friendly creeps
                        if (creep.userData.lane !== laneKey) return;

                        const dist = agentPos.distanceTo(creep.position);
                        if (dist < LANE_SUPPORT_CONFIG.agentBuffRadius) {
                            // Apply buffs
                            if (!creep.userData.agentBuffed) {
                                creep.userData.agentBuffed = true;
                                creep.userData.originalDamage = creep.userData.damage;
                                creep.userData.originalSpeed = creep.userData.speed;
                                creep.userData.damage *= LANE_SUPPORT_CONFIG.creepBuffs.damage;
                                creep.userData.speed *= LANE_SUPPORT_CONFIG.creepBuffs.speed;

                                // Visual buff indicator
                                if (!creep.userData.buffAura) {
                                    const auraGeo = new THREE.RingGeometry(0.8, 1.0, 16);
                                    const auraMat = new THREE.MeshBasicMaterial({
                                        color: 0x00ffaa,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const aura = new THREE.Mesh(auraGeo, auraMat);
                                    aura.rotation.x = -Math.PI / 2;
                                    aura.position.y = 0.1;
                                    creep.add(aura);
                                    creep.userData.buffAura = aura;
                                }
                            }

                            // Heal over time
                            creep.userData.hp = Math.min(
                                creep.userData.maxHp,
                                creep.userData.hp + LANE_SUPPORT_CONFIG.creepBuffs.healPerSecond * 0.016
                            );
                        } else if (creep.userData.agentBuffed) {
                            // Remove buffs when out of range
                            creep.userData.damage = creep.userData.originalDamage || creep.userData.damage;
                            creep.userData.speed = creep.userData.originalSpeed || creep.userData.speed;
                            creep.userData.agentBuffed = false;

                            if (creep.userData.buffAura) {
                                creep.remove(creep.userData.buffAura);
                                creep.userData.buffAura.geometry.dispose();
                                creep.userData.buffAura.material.dispose();
                                creep.userData.buffAura = null;
                            }
                        }
                    });
                });
            });
        }

        // Check if we can build a fortification and where
        function checkFortificationOpportunity(time) {
            if (!laneSupportState.enabled) return;
            if (time - laneSupportState.lastFortCheck < LANE_SUPPORT_CONFIG.fortBuildInterval) return;
            laneSupportState.lastFortCheck = time;

            Object.keys(LANE_DEFINITIONS).forEach(laneKey => {
                const lane = LANE_DEFINITIONS[laneKey];
                const control = laneSupportState.laneControl[laneKey];
                const agents = laneSupportState.assignedAgents[laneKey];
                const points = laneSupportState.controlPoints[laneKey];

                // Need assigned agents and control points
                if (!agents || agents.length === 0) return;
                if (points < 10) return;

                // Count existing forts in this lane
                const existingForts = laneSupportState.fortifications.filter(f => f.laneKey === laneKey).length;
                const buildingForts = laneSupportState.buildQueue.filter(f => f.laneKey === laneKey).length;
                if (existingForts + buildingForts >= LANE_SUPPORT_CONFIG.maxFortsPerLane) return;

                // Find best position for new fort
                const fortPosition = findBestFortPosition(laneKey, control);
                if (!fortPosition) return;

                // Determine fort type based on available points and existing forts
                const fortType = selectFortificationType(points, existingForts);
                if (!fortType) return;

                const fortDef = LANE_FORTIFICATIONS[fortType];
                if (points < fortDef.cost.controlPoints) return;

                // Start building
                startFortificationBuild(laneKey, fortType, fortPosition, agents[0]);

                // Deduct control points
                laneSupportState.controlPoints[laneKey] -= fortDef.cost.controlPoints;
            });
        }

        // Find optimal position for fortification
        function findBestFortPosition(laneKey, control) {
            const lane = LANE_DEFINITIONS[laneKey];
            const waypoints = lane.waypoints;

            // Find segments we control that are near the frontline
            let bestSegment = -1;
            let bestScore = -Infinity;

            for (let i = 0; i < control.segments.length; i++) {
                const segControl = control.segments[i];

                // Must control the segment (friendly)
                if (segControl < 0.2) continue;

                // Score based on:
                // - Distance from frontline (closer = more strategic but riskier)
                // - Level of control (higher = safer)
                // - Distance from spawn (not too close to base)
                const distFromFront = Math.abs(i - control.frontlineIndex);
                const distFromSpawn = i; // Segments are 0-indexed from spawn

                // Check for existing forts nearby
                const segMidX = (waypoints[i].x + waypoints[i + 1].x) / 2;
                const segMidZ = (waypoints[i].z + waypoints[i + 1].z) / 2;
                let nearbyFort = false;
                laneSupportState.fortifications.forEach(fort => {
                    if (fort.laneKey === laneKey) {
                        const dist = Math.sqrt(
                            Math.pow(fort.position.x - segMidX, 2) +
                            Math.pow(fort.position.z - segMidZ, 2)
                        );
                        if (dist < 20) nearbyFort = true;
                    }
                });
                if (nearbyFort) continue;

                // Calculate score
                let score = 0;
                score += segControl * 30;                    // Control bonus
                score -= distFromFront * 5;                  // Closer to front = higher score
                score += Math.min(distFromSpawn, 3) * 10;    // Not too close to spawn
                score -= Math.max(0, distFromFront - 2) * 8; // Penalty for being too far from action

                if (score > bestScore) {
                    bestScore = score;
                    bestSegment = i;
                }
            }

            if (bestSegment === -1) return null;

            // Calculate position along segment
            const wp1 = waypoints[bestSegment];
            const wp2 = waypoints[bestSegment + 1];
            const t = 0.3 + Math.random() * 0.4; // Random position along segment

            const x = wp1.x + (wp2.x - wp1.x) * t;
            const z = wp1.z + (wp2.z - wp1.z) * t;
            const y = typeof getTerrainHeight === 'function' ? getTerrainHeight(x, z) : 0;

            return { x, y, z, segment: bestSegment };
        }

        // Select fortification type based on resources and progression
        function selectFortificationType(points, existingForts) {
            // Progressive unlock - need lower tier forts before higher
            if (existingForts === 0 || points < 25) {
                return 'outpost';
            } else if (existingForts === 1 || points < 50) {
                return Math.random() < 0.5 ? 'supplyCache' : 'watchtower';
            } else if (existingForts === 2 || points < 100) {
                return 'bunker';
            } else {
                return 'stronghold';
            }
        }

        // Start building a fortification
        function startFortificationBuild(laneKey, fortType, position, agent) {
            const fortDef = LANE_FORTIFICATIONS[fortType];
            const lane = LANE_DEFINITIONS[laneKey];

            const buildOrder = {
                id: `fort_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                laneKey: laneKey,
                type: fortType,
                definition: fortDef,
                position: new THREE.Vector3(position.x, position.y, position.z),
                segment: position.segment,
                startTime: performance.now(),
                buildTime: fortDef.buildTime,
                progress: 0,
                builder: agent,
                mesh: null,
                scaffolding: null,
                progressBar: null
            };

            // Create scaffolding/preview
            createFortScaffolding(buildOrder);

            laneSupportState.buildQueue.push(buildOrder);

            showNotification(`${fortDef.icon} Building ${fortDef.name} at ${lane.chokePointName}`, 'info');
            addCopilotMessage(` ${agent.name} is constructing a ${fortDef.name} on ${lane.name}. ETA: ${Math.round(fortDef.buildTime / 1000)}s`, 'ai');
        }

        // Create scaffolding mesh during construction
        function createFortScaffolding(buildOrder) {
            if (!scene) return;

            const def = buildOrder.definition;
            const pos = buildOrder.position;

            // Scaffolding frame
            const scaffoldGroup = new THREE.Group();

            // Corner posts
            const postGeo = new THREE.CylinderGeometry(0.15, 0.15, def.size.y + 1, 6);
            const postMat = new THREE.MeshStandardMaterial({
                color: 0xaa8844,
                transparent: true,
                opacity: 0.7
            });

            const offsets = [
                [-def.size.x/2, -def.size.z/2],
                [def.size.x/2, -def.size.z/2],
                [-def.size.x/2, def.size.z/2],
                [def.size.x/2, def.size.z/2]
            ];

            offsets.forEach(([ox, oz]) => {
                const post = new THREE.Mesh(postGeo, postMat);
                post.position.set(ox, def.size.y / 2 + 0.5, oz);
                scaffoldGroup.add(post);
            });

            // Cross beams
            const beamGeo = new THREE.BoxGeometry(def.size.x + 0.3, 0.1, 0.1);
            const beamMat = new THREE.MeshStandardMaterial({
                color: 0x996633,
                transparent: true,
                opacity: 0.6
            });

            [0.3, 0.6, 0.9].forEach(h => {
                const beam1 = new THREE.Mesh(beamGeo, beamMat);
                beam1.position.set(0, def.size.y * h, -def.size.z/2);
                scaffoldGroup.add(beam1);

                const beam2 = new THREE.Mesh(beamGeo, beamMat);
                beam2.position.set(0, def.size.y * h, def.size.z/2);
                scaffoldGroup.add(beam2);
            });

            // Progress indicator (vertical bar)
            const progressGeo = new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const progressMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const progressBar = new THREE.Mesh(progressGeo, progressMat);
            progressBar.position.set(0, 0.1, 0);
            scaffoldGroup.add(progressBar);
            buildOrder.progressBar = progressBar;

            // Ghost of final building
            const ghostGeo = new THREE.BoxGeometry(def.size.x, def.size.y, def.size.z);
            const ghostMat = new THREE.MeshBasicMaterial({
                color: def.color,
                transparent: true,
                opacity: 0.2,
                wireframe: true
            });
            const ghost = new THREE.Mesh(ghostGeo, ghostMat);
            ghost.position.y = def.size.y / 2;
            scaffoldGroup.add(ghost);

            scaffoldGroup.position.copy(pos);
            scaffoldGroup.position.y = pos.y + 0.1;

            scene.add(scaffoldGroup);
            buildOrder.scaffolding = scaffoldGroup;
        }

        // Update fortification construction progress
        function updateFortificationBuilding(time) {
            if (!laneSupportState.enabled) return;

            for (let i = laneSupportState.buildQueue.length - 1; i >= 0; i--) {
                const build = laneSupportState.buildQueue[i];
                const elapsed = time - build.startTime;
                build.progress = Math.min(1, elapsed / build.buildTime);

                // Update progress bar
                if (build.progressBar) {
                    build.progressBar.scale.y = build.progress * build.definition.size.y * 2;
                    build.progressBar.position.y = build.progress * build.definition.size.y / 2;
                }

                // Check if complete
                if (build.progress >= 1) {
                    completeFortification(build);
                    laneSupportState.buildQueue.splice(i, 1);
                }
            }
        }

        // Complete a fortification build
        function completeFortification(buildOrder) {
            const def = buildOrder.definition;
            const pos = buildOrder.position;
            const lane = LANE_DEFINITIONS[buildOrder.laneKey];

            // Remove scaffolding
            if (buildOrder.scaffolding) {
                scene.remove(buildOrder.scaffolding);
                buildOrder.scaffolding.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            // Create final fortification mesh
            const fortGroup = new THREE.Group();

            // Base platform
            const baseGeo = new THREE.BoxGeometry(def.size.x + 1, 0.4, def.size.z + 1);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.2
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.2;
            base.receiveShadow = true;
            fortGroup.add(base);

            // Main structure
            const mainGeo = new THREE.BoxGeometry(def.size.x, def.size.y, def.size.z);
            const mainMat = new THREE.MeshStandardMaterial({
                color: def.color,
                roughness: 0.6,
                metalness: 0.3
            });
            const main = new THREE.Mesh(mainGeo, mainMat);
            main.position.y = def.size.y / 2 + 0.4;
            main.castShadow = true;
            main.receiveShadow = true;
            fortGroup.add(main);

            // Team color accent
            const accentGeo = new THREE.BoxGeometry(def.size.x + 0.2, 0.3, def.size.z + 0.2);
            const accentMat = new THREE.MeshStandardMaterial({
                color: lane.color,
                emissive: lane.color,
                emissiveIntensity: 0.5
            });
            const accent = new THREE.Mesh(accentGeo, accentMat);
            accent.position.y = def.size.y + 0.5;
            fortGroup.add(accent);

            // Flag/beacon on top
            const flagGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
            const flagMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const flagPole = new THREE.Mesh(flagGeo, flagMat);
            flagPole.position.y = def.size.y + 1.5;
            fortGroup.add(flagPole);

            const bannerGeo = new THREE.PlaneGeometry(1.2, 0.8);
            const bannerMat = new THREE.MeshBasicMaterial({
                color: lane.color,
                side: THREE.DoubleSide
            });
            const banner = new THREE.Mesh(bannerGeo, bannerMat);
            banner.position.set(0.7, def.size.y + 2, 0);
            banner.rotation.y = Math.PI / 2;
            fortGroup.add(banner);

            fortGroup.position.copy(pos);
            fortGroup.position.y = pos.y;

            scene.add(fortGroup);

            // Create fortification data object
            const fort = {
                id: buildOrder.id,
                laneKey: buildOrder.laneKey,
                type: buildOrder.type,
                definition: def,
                position: pos.clone(),
                segment: buildOrder.segment,
                hp: def.hp,
                maxHp: def.hp,
                mesh: fortGroup,
                lastAttackTime: 0,
                active: true
            };

            laneSupportState.fortifications.push(fort);

            showNotification(`${def.icon} ${def.name} constructed!`, 'legendary');
            addCopilotMessage(` ${def.name} is now operational on ${lane.name}! It will ${def.attackDamage ? 'attack enemies and ' : ''}buff our forces in the area.`, 'ai');
        }

        // Update fortification attacks and buffs
        function updateFortifications(time) {
            if (!laneSupportState.enabled) return;

            laneSupportState.fortifications.forEach(fort => {
                if (!fort.active) return;

                const def = fort.definition;

                // Attack enemies if this fort has attack capability
                if (def.attackDamage && time - fort.lastAttackTime > def.attackCooldown) {
                    let target = null;
                    let minDist = def.attackRange;

                    creepWaveState.creeps.forEach(creep => {
                        if (!creep.userData || creep.userData.team === 'A') return;
                        const dist = fort.position.distanceTo(creep.position);
                        if (dist < minDist) {
                            minDist = dist;
                            target = creep;
                        }
                    });

                    if (target) {
                        // Attack!
                        target.userData.hp -= def.attackDamage;
                        fort.lastAttackTime = time;

                        // Visual: projectile
                        spawnFortProjectile(fort, target);
                    }
                }

                // Heal nearby creeps if this fort has healing
                if (def.healAmount) {
                    creepWaveState.creeps.forEach(creep => {
                        if (!creep.userData || creep.userData.team !== 'A') return;
                        const dist = fort.position.distanceTo(creep.position);
                        if (dist < def.healRadius) {
                            creep.userData.hp = Math.min(
                                creep.userData.maxHp,
                                creep.userData.hp + def.healAmount * 0.016
                            );
                        }
                    });
                }

                // Apply creep buffs in aura
                if (def.creepBuff) {
                    const auraRange = def.auraRadius || 15;
                    creepWaveState.creeps.forEach(creep => {
                        if (!creep.userData || creep.userData.team !== 'A') return;
                        if (creep.userData.lane !== fort.laneKey) return;
                        const dist = fort.position.distanceTo(creep.position);
                        if (dist < auraRange && !creep.userData.fortBuffed) {
                            creep.userData.fortBuffed = true;
                            creep.userData.damage *= def.creepBuff.damage || 1;
                            creep.userData.speed *= def.creepBuff.speed || 1;
                        }
                    });
                }
            });
        }

        // Spawn projectile from fort to target
        function spawnFortProjectile(fort, target) {
            if (!scene) return;

            const projectile = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    emissive: 0xff4400,
                    emissiveIntensity: 1
                })
            );
            projectile.position.copy(fort.position);
            projectile.position.y += fort.definition.size.y;
            scene.add(projectile);

            const targetPos = target.position.clone();
            const duration = 200;
            const startTime = performance.now();
            const startPos = projectile.position.clone();

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(1, elapsed / duration);

                projectile.position.lerpVectors(startPos, targetPos, t);
                projectile.position.y += Math.sin(t * Math.PI) * 2; // Arc

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(projectile);
                    projectile.geometry.dispose();
                    projectile.material.dispose();
                }
            }
            animate();
        }

        // Parse lane support commands
        function parseLaneSupportCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Assign agent to lane
            const supportMatch = lowerMsg.match(/support\s+(boreal|frostfall|north|top|nexus|spine|ember|mid|middle|verdant|thorn|south|bot|bottom)/i);
            if (supportMatch) {
                const laneTerm = supportMatch[1].toLowerCase();
                let laneKey = null;

                if (['boreal', 'frostfall', 'north', 'top'].includes(laneTerm)) laneKey = 'top';
                else if (['nexus', 'spine', 'ember', 'mid', 'middle'].includes(laneTerm)) laneKey = 'mid';
                else if (['verdant', 'thorn', 'south', 'bot', 'bottom'].includes(laneTerm)) laneKey = 'bot';

                if (laneKey && agentFleet.length > 0) {
                    // Find available agent
                    const availableAgent = agentFleet.find(a => !a.assignedLane);
                    if (availableAgent) {
                        assignAgentToLane(availableAgent, laneKey);
                        return true;
                    } else {
                        addCopilotMessage(`All agents are already assigned. Use "recall agents" first or spawn more agents.`, 'ai');
                        return true;
                    }
                }
            }

            // Recall all agents from lanes
            if (lowerMsg.includes('recall agents') || lowerMsg.includes('unassign agents')) {
                Object.keys(laneSupportState.assignedAgents).forEach(key => {
                    laneSupportState.assignedAgents[key].forEach(agent => {
                        agent.assignedLane = null;
                        agent.laneRole = null;
                    });
                    laneSupportState.assignedAgents[key] = [];
                });
                addCopilotMessage(`All agents recalled from lane assignments.`, 'ai');
                return true;
            }

            // Lane status
            if (lowerMsg.includes('lane status') || lowerMsg.includes('front status') || lowerMsg.includes('war status')) {
                let status = ' **LANE CONTROL STATUS**\n';
                Object.keys(LANE_DEFINITIONS).forEach(laneKey => {
                    const lane = LANE_DEFINITIONS[laneKey];
                    const control = laneSupportState.laneControl[laneKey];
                    const agents = laneSupportState.assignedAgents[laneKey]?.length || 0;
                    const forts = laneSupportState.fortifications.filter(f => f.laneKey === laneKey).length;
                    const points = Math.floor(laneSupportState.controlPoints[laneKey]);

                    const controlPct = Math.round((control?.overallControl || 0) * 100);
                    const controlBar = controlPct >= 0
                        ? ''.repeat(Math.min(5, Math.floor(controlPct / 20))) + ''.repeat(5 - Math.min(5, Math.floor(controlPct / 20)))
                        : ''.repeat(Math.min(5, Math.floor(-controlPct / 20))) + ''.repeat(5 - Math.min(5, Math.floor(-controlPct / 20)));

                    status += `\n**${lane.name}** (${lane.chokePointName})\n`;
                    status += `Control: ${controlBar} ${controlPct}%\n`;
                    status += `Agents: ${agents} | Forts: ${forts} | Points: ${points}\n`;
                });
                addCopilotMessage(status, 'ai');
                return true;
            }

            return false;
        }

        // v6.67: Spawn initial lane towers - pre-existing defenses from prior expeditions
        // These represent the ongoing conflict the player is joining
        function spawnInitialLaneTowers() {
            if (!scene || !laneSupportState.enabled) return;

            const LANE_TOWER_POSITIONS = {
                // Each lane has 3 towers per side (6 total per lane)
                // Robot side (Team A): cyan towers near spawn
                // Hostile side (Team B): red towers near their spawn
                top: {
                    robotTowers: [
                        { segment: 0, offset: 0.2 },   // Near spawn
                        { segment: 1, offset: 0.5 },   // Forward position
                        { segment: 2, offset: 0.3 }    // Approaching frontline
                    ],
                    hostileTowers: [
                        { segment: 5, offset: 0.7 },   // Near their spawn
                        { segment: 4, offset: 0.5 },   // Forward position
                        { segment: 3, offset: 0.8 }    // Approaching frontline
                    ]
                },
                mid: {
                    robotTowers: [
                        { segment: 0, offset: 0.3 },
                        { segment: 1, offset: 0.5 },
                        { segment: 2, offset: 0.6 }
                    ],
                    hostileTowers: [
                        { segment: 5, offset: 0.7 },
                        { segment: 4, offset: 0.5 },
                        { segment: 3, offset: 0.4 }
                    ]
                },
                bot: {
                    robotTowers: [
                        { segment: 0, offset: 0.2 },
                        { segment: 1, offset: 0.5 },
                        { segment: 2, offset: 0.3 }
                    ],
                    hostileTowers: [
                        { segment: 5, offset: 0.7 },
                        { segment: 4, offset: 0.5 },
                        { segment: 3, offset: 0.8 }
                    ]
                }
            };

            Object.keys(LANE_DEFINITIONS).forEach(laneKey => {
                const lane = LANE_DEFINITIONS[laneKey];
                const waypoints = lane.waypoints;
                const towerConfig = LANE_TOWER_POSITIONS[laneKey];

                // Spawn Robot (Team A) towers - CYAN
                towerConfig.robotTowers.forEach((towerPos, idx) => {
                    const wp1 = waypoints[towerPos.segment];
                    const wp2 = waypoints[towerPos.segment + 1];
                    const t = towerPos.offset;

                    const x = wp1.x + (wp2.x - wp1.x) * t;
                    const z = wp1.z + (wp2.z - wp1.z) * t;
                    const y = typeof getTerrainHeight === 'function' ? getTerrainHeight(x, z) : 0;

                    // Offset slightly to the side of the lane
                    const angle = Math.atan2(wp2.x - wp1.x, wp2.z - wp1.z);
                    const sideOffset = 6;
                    const offsetX = Math.cos(angle) * sideOffset * (idx % 2 === 0 ? 1 : -1);
                    const offsetZ = -Math.sin(angle) * sideOffset * (idx % 2 === 0 ? 1 : -1);

                    createLaneTower(
                        x + offsetX, y, z + offsetZ,
                        'robot', laneKey, lane.color, towerPos.segment
                    );
                });

                // Spawn Hostile (Team B) towers - RED
                towerConfig.hostileTowers.forEach((towerPos, idx) => {
                    const wp1 = waypoints[towerPos.segment];
                    const wp2 = waypoints[towerPos.segment + 1];
                    const t = towerPos.offset;

                    const x = wp1.x + (wp2.x - wp1.x) * t;
                    const z = wp1.z + (wp2.z - wp1.z) * t;
                    const y = typeof getTerrainHeight === 'function' ? getTerrainHeight(x, z) : 0;

                    // Offset slightly to the side of the lane
                    const angle = Math.atan2(wp2.x - wp1.x, wp2.z - wp1.z);
                    const sideOffset = 6;
                    const offsetX = Math.cos(angle) * sideOffset * (idx % 2 === 0 ? 1 : -1);
                    const offsetZ = -Math.sin(angle) * sideOffset * (idx % 2 === 0 ? 1 : -1);

                    createLaneTower(
                        x + offsetX, y, z + offsetZ,
                        'hostile', laneKey, 0xff4444, towerPos.segment
                    );
                });
            });

            console.log('v6.67: Initial lane towers spawned - joining ongoing conflict');
            addCopilotMessage(` Sensors detect prior expedition fortifications across all lanes. The struggle between Robot Forces and Hostile Fauna has been ongoing. We're joining this conflict where it stands.`, 'ai');
        }

        // Create a single lane tower
        function createLaneTower(x, y, z, team, laneKey, color, segment) {
            const towerGroup = new THREE.Group();

            const teamColor = team === 'robot' ? 0x00ccff : 0xff4444;
            const isRobot = team === 'robot';

            // Base platform
            const baseGeo = new THREE.CylinderGeometry(2.5, 3, 0.6, 8);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x444455,
                roughness: 0.7,
                metalness: 0.4
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.3;
            base.receiveShadow = true;
            towerGroup.add(base);

            // Tower body
            const bodyGeo = new THREE.CylinderGeometry(1.5, 2, 5, 8);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: isRobot ? 0x336688 : 0x663333,
                roughness: 0.5,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 3;
            body.castShadow = true;
            towerGroup.add(body);

            // Tower top / turret
            const topGeo = new THREE.CylinderGeometry(1.8, 1.5, 1.5, 8);
            const topMat = new THREE.MeshStandardMaterial({
                color: teamColor,
                emissive: teamColor,
                emissiveIntensity: 0.4,
                roughness: 0.3,
                metalness: 0.7
            });
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = 5.75;
            top.castShadow = true;
            towerGroup.add(top);

            // Glowing beacon
            const beaconGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const beaconMat = new THREE.MeshStandardMaterial({
                color: teamColor,
                emissive: teamColor,
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.9
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 7;
            beacon.userData.pulsePhase = Math.random() * Math.PI * 2;
            beacon.userData.isTowerBeacon = true;
            towerGroup.add(beacon);

            // Lane color ring at base
            const ringGeo = new THREE.TorusGeometry(3, 0.2, 8, 24);
            const ringMat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.15;
            towerGroup.add(ring);

            // Team banner
            const bannerGeo = new THREE.PlaneGeometry(1.5, 1);
            const bannerMat = new THREE.MeshBasicMaterial({
                color: teamColor,
                side: THREE.DoubleSide
            });
            const banner = new THREE.Mesh(bannerGeo, bannerMat);
            banner.position.set(0, 4.5, 1.6);
            towerGroup.add(banner);

            towerGroup.position.set(x, y, z);

            scene.add(towerGroup);

            // Create tower data object
            const tower = {
                id: `tower_${laneKey}_${team}_${segment}_${Math.random().toString(36).substr(2, 5)}`,
                laneKey: laneKey,
                team: team,
                position: new THREE.Vector3(x, y, z),
                segment: segment,
                hp: 400,
                maxHp: 400,
                attackDamage: team === 'robot' ? 12 : 10,
                attackRange: 16,
                attackCooldown: 1200,
                lastAttackTime: 0,
                mesh: towerGroup,
                active: true
            };

            // v6.68: Add userData to mesh for targeting/clicking
            const towerName = team === 'robot' ? 'Robot Defense Tower' : 'Hostile Fauna Nest';
            towerGroup.userData = {
                type: team === 'robot' ? 'friendlyTower' : 'hostileTower',
                name: towerName,
                team: team,
                hp: tower.hp,
                maxHp: tower.maxHp,
                towerRef: tower  // Reference back to tower data
            };

            // Store in lane support state
            if (!laneSupportState.laneTowers) {
                laneSupportState.laneTowers = [];
            }
            laneSupportState.laneTowers.push(tower);

            return tower;
        }

        // Update lane towers - attack enemies
        function updateLaneTowers(time) {
            if (!laneSupportState.laneTowers) return;

            laneSupportState.laneTowers.forEach(tower => {
                if (!tower.active) return;

                // Attack interval check
                if (time - tower.lastAttackTime < tower.attackCooldown) return;

                // Find target - opposite team's creeps
                let target = null;
                let minDist = tower.attackRange;
                const targetTeam = tower.team === 'robot' ? 'B' : 'A';
                let targetIsPlayer = false;

                creepWaveState.creeps.forEach(creep => {
                    if (!creep.userData || creep.userData.team !== targetTeam) return;
                    const dist = tower.position.distanceTo(creep.position);
                    if (dist < minDist) {
                        minDist = dist;
                        target = creep;
                    }
                });

                // v6.68: Hostile fauna towers (team !== 'robot') also target the player
                // Player is considered team 'A' (Robot Forces)
                if (tower.team !== 'robot' && worldState.player) {
                    const playerDist = tower.position.distanceTo(worldState.player.position);
                    if (playerDist < minDist) {
                        minDist = playerDist;
                        target = worldState.player;
                        targetIsPlayer = true;
                    }
                }

                if (target) {
                    tower.lastAttackTime = time;

                    if (targetIsPlayer) {
                        // Attack the player!
                        const towerDamage = tower.attackDamage || 5;
                        damagePlayer(towerDamage, tower.position);
                        spawnFloater(worldState.player.position, `-${towerDamage}`, '#ff4400');
                        // Visual projectile to player
                        spawnTowerProjectile(tower, worldState.player);
                    } else {
                        // Attack creep as normal
                        target.userData.hp -= tower.attackDamage;
                        // Visual projectile
                        spawnTowerProjectile(tower, target);
                    }
                }

                // Animate beacon pulse
                if (tower.mesh) {
                    tower.mesh.traverse(child => {
                        if (child.userData.isTowerBeacon) {
                            const phase = child.userData.pulsePhase || 0;
                            child.material.emissiveIntensity = 0.8 + Math.sin(time * 0.003 + phase) * 0.4;
                        }
                    });
                }
            });
        }

        // Spawn tower projectile
        function spawnTowerProjectile(tower, target) {
            if (!scene) return;

            const color = tower.team === 'robot' ? 0x00ffff : 0xff4400;
            const projectile = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 1
                })
            );
            projectile.position.copy(tower.position);
            projectile.position.y += 6;
            scene.add(projectile);

            const targetPos = target.position.clone();
            const duration = 150;
            const startTime = performance.now();
            const startPos = projectile.position.clone();

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(1, elapsed / duration);

                projectile.position.lerpVectors(startPos, targetPos, t);
                projectile.position.y += Math.sin(t * Math.PI) * 1.5;

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(projectile);
                    projectile.geometry.dispose();
                    projectile.material.dispose();
                }
            }
            animate();
        }

        // Main update function for lane support system
        function updateLaneSupportSystem(time) {
            if (!laneSupportState.enabled) return;

            updateLaneControl(time);
            updateAgentCreepBuffs(time);
            checkFortificationOpportunity(time);
            updateFortificationBuilding(time);
            updateFortifications(time);
            updateLaneTowers(time);
        }

        // Cleanup lane support system
        function cleanupLaneSupportSystem() {
            // Remove fortifications
            laneSupportState.fortifications.forEach(fort => {
                if (fort.mesh && fort.mesh.parent) {
                    fort.mesh.parent.remove(fort.mesh);
                    fort.mesh.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            });

            // Remove build queue items
            laneSupportState.buildQueue.forEach(build => {
                if (build.scaffolding && build.scaffolding.parent) {
                    build.scaffolding.parent.remove(build.scaffolding);
                    build.scaffolding.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            });

            // Remove lane towers
            if (laneSupportState.laneTowers) {
                laneSupportState.laneTowers.forEach(tower => {
                    if (tower.mesh && tower.mesh.parent) {
                        tower.mesh.parent.remove(tower.mesh);
                        tower.mesh.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                });
            }

            laneSupportState.enabled = false;
            laneSupportState.initialized = false;
            laneSupportState.fortifications = [];
            laneSupportState.buildQueue = [];
            laneSupportState.assignedAgents = {};
            laneSupportState.laneControl = {};
            laneSupportState.controlPoints = { top: 0, mid: 0, bot: 0 };
            laneSupportState.laneTowers = [];
        }

        // ============================================
        // v6.68: VERSUS MODE - COMPETITIVE DOTA 2-STYLE MATCHES
        // Two players compete to destroy each other's throne
        // War horn sounds when match begins
        // ============================================

        const versusMatchState = {
            active: false,
            matchId: null,
            startTime: 0,
            localTeam: 'robot',        // 'robot' (cyan) or 'hostile' (red)
            opponentConnected: false,
            opponentId: null,
            thrones: {
                robot: null,           // THREE.Group for robot throne
                hostile: null          // THREE.Group for hostile throne
            },
            throneHP: {
                robot: 5000,
                hostile: 5000
            },
            maxThroneHP: 5000,
            winner: null,
            matchStats: {
                kills: 0,
                deaths: 0,
                towersDestroyed: 0,
                damageDealt: 0
            }
        };

        // Generate versus match QR code URL
        function getVersusMatchUrl() {
            if (!p2pStreaming.peerId) return null;
            const matchId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
            return `${window.location.origin}${window.location.pathname}?versus=${p2pStreaming.peerId}&match=${matchId}&seed=${multiplayerState.worldSeed}&planet=${activeCiv?.id || ''}`;
        }

        // Generate QR code for versus mode
        function generateVersusQRCode() {
            const container = document.getElementById('qr-code-container');
            if (!container) return;

            if (!p2pStreaming.peerId) {
                container.innerHTML = '<div style="color: #333; font-size: 14px;">Connecting to P2P network...</div>';
                return;
            }

            container.innerHTML = '<div style="color: #333; font-size: 14px;">Generating versus QR code...</div>';

            const versusUrl = getVersusMatchUrl();
            console.log('Generating versus QR code for:', versusUrl);

            // Try QRious library first
            if (typeof QRious !== 'undefined') {
                const qr = new QRious({
                    value: versusUrl,
                    size: 200,
                    background: 'white',
                    foreground: '#ff0088',
                    level: 'M'
                });
                container.innerHTML = '';
                const img = document.createElement('img');
                img.src = qr.toDataURL();
                img.style.width = '200px';
                img.style.height = '200px';
                img.alt = 'Scan to challenge';
                container.appendChild(img);
                console.log('Versus QR code generated with QRious');
            } else {
                // Fallback to API
                const apiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(versusUrl)}&color=ff0088`;
                const img = document.createElement('img');
                img.src = apiUrl;
                img.alt = 'Scan to challenge';
                img.style.width = '200px';
                img.style.height = '200px';
                container.innerHTML = '';
                container.appendChild(img);
                console.log('Versus QR code generated with API');
            }
        }

        // Create throne structure at specified position
        function createThrone(x, y, z, team) {
            const throne = new THREE.Group();
            const teamColor = team === 'robot' ? 0x00ccff : 0xff4444;
            const accentColor = team === 'robot' ? 0x0088aa : 0xaa2222;

            // Base platform - circular
            const baseGeo = new THREE.CylinderGeometry(8, 10, 2, 16);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x333344,
                roughness: 0.6,
                metalness: 0.4
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 1;
            base.receiveShadow = true;
            base.castShadow = true;
            throne.add(base);

            // Inner ring
            const ringGeo = new THREE.TorusGeometry(6, 0.5, 8, 32);
            const ringMat = new THREE.MeshStandardMaterial({
                color: teamColor,
                emissive: teamColor,
                emissiveIntensity: 0.3,
                roughness: 0.3,
                metalness: 0.7
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 2.2;
            throne.add(ring);

            // Central crystal/throne structure
            const crystalGeo = new THREE.OctahedronGeometry(3, 0);
            const crystalMat = new THREE.MeshStandardMaterial({
                color: teamColor,
                emissive: teamColor,
                emissiveIntensity: 0.5,
                roughness: 0.1,
                metalness: 0.9,
                transparent: true,
                opacity: 0.9
            });
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.position.y = 7;
            crystal.castShadow = true;
            throne.add(crystal);
            throne.userData.crystal = crystal;

            // Pillar supports (4 corners)
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const pillarGeo = new THREE.CylinderGeometry(0.8, 1.2, 8, 8);
                const pillarMat = new THREE.MeshStandardMaterial({
                    color: accentColor,
                    roughness: 0.5,
                    metalness: 0.5
                });
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                pillar.position.set(
                    Math.cos(angle) * 5,
                    5,
                    Math.sin(angle) * 5
                );
                pillar.castShadow = true;
                throne.add(pillar);

                // Pillar top orb
                const orbGeo = new THREE.SphereGeometry(1, 16, 16);
                const orbMat = new THREE.MeshStandardMaterial({
                    color: teamColor,
                    emissive: teamColor,
                    emissiveIntensity: 0.4,
                    roughness: 0.2,
                    metalness: 0.8
                });
                const orb = new THREE.Mesh(orbGeo, orbMat);
                orb.position.set(
                    Math.cos(angle) * 5,
                    9.5,
                    Math.sin(angle) * 5
                );
                throne.add(orb);
            }

            // Floating crown element
            const crownGeo = new THREE.TorusGeometry(2, 0.3, 8, 16);
            const crownMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffa500,
                emissiveIntensity: 0.3,
                roughness: 0.2,
                metalness: 0.8
            });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.rotation.x = Math.PI / 2;
            crown.position.y = 12;
            throne.add(crown);
            throne.userData.crown = crown;

            // Set position
            throne.position.set(x, y, z);

            // Store metadata
            throne.userData.type = 'throne';
            throne.userData.team = team;
            throne.userData.hp = versusMatchState.maxThroneHP;
            throne.userData.maxHp = versusMatchState.maxThroneHP;

            return throne;
        }

        // Spawn thrones for versus match
        function spawnVersusThrones() {
            if (!scene || !laneSupportState.enabled) return;

            // Find spawn positions from lane endpoints
            const midLane = LANE_DEFINITIONS.mid;
            if (!midLane || !midLane.waypoints) return;

            const robotSpawn = midLane.waypoints[0];  // Start of lane
            const hostileSpawn = midLane.waypoints[midLane.waypoints.length - 1];  // End of lane

            // Create robot throne (cyan team)
            const robotY = typeof getTerrainHeight === 'function' ? getTerrainHeight(robotSpawn.x, robotSpawn.z - 15) : 0;
            versusMatchState.thrones.robot = createThrone(robotSpawn.x, robotY, robotSpawn.z - 15, 'robot');
            scene.add(versusMatchState.thrones.robot);

            // Create hostile throne (red team)
            const hostileY = typeof getTerrainHeight === 'function' ? getTerrainHeight(hostileSpawn.x, hostileSpawn.z + 15) : 0;
            versusMatchState.thrones.hostile = createThrone(hostileSpawn.x, hostileY, hostileSpawn.z + 15, 'hostile');
            scene.add(versusMatchState.thrones.hostile);

            // Reset HP
            versusMatchState.throneHP.robot = versusMatchState.maxThroneHP;
            versusMatchState.throneHP.hostile = versusMatchState.maxThroneHP;

            console.log('v6.68: Versus thrones spawned');
        }

        // Start versus match countdown and initialize
        function startVersusMatch() {
            if (versusMatchState.active) return;

            versusMatchState.active = true;
            versusMatchState.startTime = Date.now();
            versusMatchState.winner = null;
            versusMatchState.matchStats = { kills: 0, deaths: 0, towersDestroyed: 0, damageDealt: 0 };

            // Spawn thrones if not already present
            if (!versusMatchState.thrones.robot) {
                spawnVersusThrones();
            }

            // Show countdown
            const countdownEl = document.getElementById('versus-countdown');
            if (countdownEl) {
                countdownEl.style.display = 'block';
                let count = 3;

                const countdownInterval = setInterval(() => {
                    if (count > 0) {
                        countdownEl.textContent = count;
                        countdownEl.style.animation = 'none';
                        countdownEl.offsetHeight; // Trigger reflow
                        countdownEl.style.animation = 'versusResultPulse 0.8s ease-out';
                        AudioSystem.playGentle(AudioSystem.penta.C4 * (4 - count), 0.3, 0.3);
                        count--;
                    } else {
                        countdownEl.textContent = 'FIGHT!';
                        countdownEl.style.color = '#0f0';

                        // Play war horn!
                        AudioSystem.warHorn();

                        // Show versus HUD
                        const hudEl = document.getElementById('versus-hud');
                        if (hudEl) hudEl.style.display = 'flex';

                        setTimeout(() => {
                            countdownEl.style.display = 'none';
                            countdownEl.style.color = '#f08';
                        }, 1500);

                        clearInterval(countdownInterval);

                        // Notify
                        showNotification(' VERSUS MATCH STARTED! Destroy the enemy throne!', 'warning');
                        addCopilotMessage(' THE WAR HORN SOUNDS! A challenger approaches! Destroy their throne before they destroy yours! All towers and creeps will fight for their respective teams. GLORY AWAITS!', 'ai');
                    }
                }, 1000);
            } else {
                // No countdown element, just start
                AudioSystem.warHorn();
                showNotification(' VERSUS MATCH STARTED!', 'warning');
            }
        }

        // Update versus match state (called each frame)
        function updateVersusMatch(time) {
            if (!versusMatchState.active) return;

            // Animate throne crystals
            if (versusMatchState.thrones.robot?.userData.crystal) {
                versusMatchState.thrones.robot.userData.crystal.rotation.y += 0.01;
                versusMatchState.thrones.robot.userData.crown.rotation.z = Math.sin(time * 0.001) * 0.1;
            }
            if (versusMatchState.thrones.hostile?.userData.crystal) {
                versusMatchState.thrones.hostile.userData.crystal.rotation.y -= 0.01;
                versusMatchState.thrones.hostile.userData.crown.rotation.z = Math.sin(time * 0.001 + Math.PI) * 0.1;
            }

            // Update HUD
            const friendlyHpEl = document.getElementById('versus-friendly-throne-hp');
            const enemyHpEl = document.getElementById('versus-enemy-throne-hp');
            if (friendlyHpEl && enemyHpEl) {
                const friendlyTeam = versusMatchState.localTeam;
                const enemyTeam = friendlyTeam === 'robot' ? 'hostile' : 'robot';

                const friendlyPct = Math.round((versusMatchState.throneHP[friendlyTeam] / versusMatchState.maxThroneHP) * 100);
                const enemyPct = Math.round((versusMatchState.throneHP[enemyTeam] / versusMatchState.maxThroneHP) * 100);

                friendlyHpEl.textContent = friendlyPct + '%';
                enemyHpEl.textContent = enemyPct + '%';

                // Color based on health
                friendlyHpEl.style.color = friendlyPct > 50 ? '#0ff' : friendlyPct > 25 ? '#ff0' : '#f44';
                enemyHpEl.style.color = enemyPct > 50 ? '#f44' : enemyPct > 25 ? '#ff0' : '#0f0';
            }

            // Check win conditions
            if (versusMatchState.throneHP.robot <= 0 && !versusMatchState.winner) {
                versusMatchState.winner = 'hostile';
                endVersusMatch('hostile');
            } else if (versusMatchState.throneHP.hostile <= 0 && !versusMatchState.winner) {
                versusMatchState.winner = 'robot';
                endVersusMatch('robot');
            }
        }

        // Damage a throne
        function damageThrone(team, amount) {
            if (!versusMatchState.active) return;

            versusMatchState.throneHP[team] = Math.max(0, versusMatchState.throneHP[team] - amount);

            // Update throne visual
            const throne = versusMatchState.thrones[team];
            if (throne) {
                // Flash the throne
                const crystal = throne.userData.crystal;
                if (crystal && crystal.material) {
                    const originalEmissive = crystal.material.emissiveIntensity;
                    crystal.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        crystal.material.emissiveIntensity = originalEmissive;
                    }, 100);
                }

                // Scale down as HP decreases
                const hpRatio = versusMatchState.throneHP[team] / versusMatchState.maxThroneHP;
                throne.scale.setScalar(0.7 + hpRatio * 0.3);
            }

            // Play damage sound
            AudioSystem.damage();

            // Show floating text
            if (throne && typeof spawnFloater === 'function') {
                spawnFloater(throne.position, `-${amount}`, team === 'robot' ? '#ff4444' : '#00ffff');
            }
        }

        // End versus match
        function endVersusMatch(winner) {
            versusMatchState.active = false;

            const isVictory = (winner === versusMatchState.localTeam);

            // Play appropriate sound
            if (isVictory) {
                AudioSystem.victoryFanfare();
            } else {
                AudioSystem.defeatSound();
            }

            // Show overlay
            const overlay = document.getElementById('versus-match-overlay');
            const resultEl = document.getElementById('versus-match-result');
            const subtitleEl = document.getElementById('versus-match-subtitle');

            if (overlay && resultEl && subtitleEl) {
                overlay.style.display = 'flex';

                if (isVictory) {
                    resultEl.textContent = 'VICTORY';
                    resultEl.style.color = '#0f0';
                    subtitleEl.textContent = 'The enemy throne has fallen! Glory is yours!';
                } else {
                    resultEl.textContent = 'DEFEAT';
                    resultEl.style.color = '#f44';
                    subtitleEl.textContent = 'Your throne has been destroyed. Fight again!';
                }
            }

            // Hide HUD
            const hudEl = document.getElementById('versus-hud');
            if (hudEl) hudEl.style.display = 'none';

            showNotification(isVictory ? ' VICTORY! You destroyed the enemy throne!' : ' DEFEAT! Your throne was destroyed!', isVictory ? 'success' : 'error');
        }

        // Close versus match overlay
        function closeVersusMatchOverlay() {
            const overlay = document.getElementById('versus-match-overlay');
            if (overlay) overlay.style.display = 'none';
        }

        // Start a new versus match (rematch)
        function startNewVersusMatch() {
            closeVersusMatchOverlay();

            // Reset thrones
            versusMatchState.throneHP.robot = versusMatchState.maxThroneHP;
            versusMatchState.throneHP.hostile = versusMatchState.maxThroneHP;
            versusMatchState.winner = null;

            // Reset throne visuals
            if (versusMatchState.thrones.robot) {
                versusMatchState.thrones.robot.scale.setScalar(1);
            }
            if (versusMatchState.thrones.hostile) {
                versusMatchState.thrones.hostile.scale.setScalar(1);
            }

            // Start new match
            startVersusMatch();
        }

        // Cleanup versus match
        function cleanupVersusMatch() {
            versusMatchState.active = false;

            // Remove thrones
            ['robot', 'hostile'].forEach(team => {
                const throne = versusMatchState.thrones[team];
                if (throne && throne.parent) {
                    throne.parent.remove(throne);
                    throne.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                versusMatchState.thrones[team] = null;
            });

            // Hide UI
            const hudEl = document.getElementById('versus-hud');
            if (hudEl) hudEl.style.display = 'none';

            const overlay = document.getElementById('versus-match-overlay');
            if (overlay) overlay.style.display = 'none';
        }

        // ============================================
        // v6.66: ROLLERCOASTER TYCOON STYLE BASE BUILDING
        // Agents autonomously construct bases piece by piece
        // Like building roller coasters - segment by segment
        // ============================================

        const BASE_BUILDING_CONFIG = {
            enabled: true,
            buildSpeed: 500,           // ms per segment
            maxConstructionSites: 5,   // Max concurrent builds
            segmentSize: 2,            // Size of each building segment
            constructionParticles: true,
            soundEffects: true
        };

        // Building blueprints - like roller coaster track pieces
        const BUILDING_BLUEPRINTS = {
            // WALLS - Linear segments that connect
            wall: {
                name: 'Wall',
                icon: '',
                category: 'defense',
                segments: [
                    { type: 'foundation', offset: {x:0, y:0, z:0}, size: {x:2, y:0.3, z:0.5}, color: 0x555555 },
                    { type: 'pillar_left', offset: {x:-0.8, y:0.7, z:0}, size: {x:0.3, y:1.4, z:0.4}, color: 0x666666 },
                    { type: 'pillar_right', offset: {x:0.8, y:0.7, z:0}, size: {x:0.3, y:1.4, z:0.4}, color: 0x666666 },
                    { type: 'top_beam', offset: {x:0, y:1.5, z:0}, size: {x:2, y:0.3, z:0.4}, color: 0x777777 },
                    { type: 'fill', offset: {x:0, y:0.7, z:0}, size: {x:1.3, y:1.1, z:0.3}, color: 0x8b7355 }
                ],
                buildTime: 2500,
                cost: { wood: 3, stone: 2 },
                hp: 100,
                connectable: true
            },

            // TOWER - Vertical multi-level structure
            tower: {
                name: 'Watch Tower',
                icon: '',
                category: 'defense',
                segments: [
                    { type: 'base', offset: {x:0, y:0, z:0}, size: {x:3, y:0.5, z:3}, color: 0x555555 },
                    { type: 'floor1', offset: {x:0, y:1.25, z:0}, size: {x:2.5, y:2, z:2.5}, color: 0x8b7355 },
                    { type: 'floor2', offset: {x:0, y:3.5, z:0}, size: {x:2.2, y:2, z:2.2}, color: 0x8b6914 },
                    { type: 'floor3', offset: {x:0, y:5.75, z:0}, size: {x:1.8, y:1.5, z:1.8}, color: 0x654321 },
                    { type: 'roof', offset: {x:0, y:7, z:0}, size: {x:2.5, y:1, z:2.5}, color: 0x8b0000, shape: 'cone' },
                    { type: 'flag', offset: {x:0, y:8, z:0}, size: {x:0.1, y:1.5, z:0.1}, color: 0xffffff },
                    { type: 'banner', offset: {x:0.3, y:8.5, z:0}, size: {x:0.8, y:0.5, z:0.05}, color: 0xff4444 }
                ],
                buildTime: 8000,
                cost: { wood: 10, stone: 15 },
                hp: 300,
                provides: { vision: 30 }
            },

            // PATH - Flat walkway segments
            path: {
                name: 'Stone Path',
                icon: '',
                category: 'infrastructure',
                segments: [
                    { type: 'base', offset: {x:0, y:0.05, z:0}, size: {x:2, y:0.1, z:2}, color: 0x888888 },
                    { type: 'stone1', offset: {x:-0.5, y:0.12, z:-0.5}, size: {x:0.4, y:0.05, z:0.4}, color: 0x666666 },
                    { type: 'stone2', offset: {x:0.4, y:0.12, z:0.3}, size: {x:0.5, y:0.05, z:0.5}, color: 0x777777 },
                    { type: 'stone3', offset: {x:-0.3, y:0.12, z:0.6}, size: {x:0.35, y:0.05, z:0.35}, color: 0x6a6a6a }
                ],
                buildTime: 800,
                cost: { stone: 1 },
                hp: 50,
                connectable: true,
                speedBoost: 1.3
            },

            // GATE - Entrance with doors
            gate: {
                name: 'Fortress Gate',
                icon: '',
                category: 'defense',
                segments: [
                    { type: 'left_pillar', offset: {x:-2, y:1.5, z:0}, size: {x:1, y:3, z:1}, color: 0x555555 },
                    { type: 'right_pillar', offset: {x:2, y:1.5, z:0}, size: {x:1, y:3, z:1}, color: 0x555555 },
                    { type: 'arch', offset: {x:0, y:3.5, z:0}, size: {x:5, y:1, z:1}, color: 0x666666 },
                    { type: 'left_door', offset: {x:-1, y:1.25, z:0}, size: {x:1.5, y:2.5, z:0.2}, color: 0x8b4513 },
                    { type: 'right_door', offset: {x:1, y:1.25, z:0}, size: {x:1.5, y:2.5, z:0.2}, color: 0x8b4513 },
                    { type: 'portcullis', offset: {x:0, y:2, z:0.3}, size: {x:3, y:2.5, z:0.1}, color: 0x333333 }
                ],
                buildTime: 5000,
                cost: { wood: 8, stone: 12, iron: 3 },
                hp: 250,
                openable: true
            },

            // BARRACKS - Troop housing
            barracks: {
                name: 'Barracks',
                icon: '',
                category: 'military',
                segments: [
                    { type: 'foundation', offset: {x:0, y:0.15, z:0}, size: {x:6, y:0.3, z:4}, color: 0x555555 },
                    { type: 'walls_back', offset: {x:0, y:1.5, z:-1.8}, size: {x:6, y:2.4, z:0.4}, color: 0x8b7355 },
                    { type: 'walls_left', offset: {x:-2.8, y:1.5, z:0}, size: {x:0.4, y:2.4, z:4}, color: 0x8b7355 },
                    { type: 'walls_right', offset: {x:2.8, y:1.5, z:0}, size: {x:0.4, y:2.4, z:4}, color: 0x8b7355 },
                    { type: 'walls_front_l', offset: {x:-1.8, y:1.5, z:1.8}, size: {x:2, y:2.4, z:0.4}, color: 0x8b7355 },
                    { type: 'walls_front_r', offset: {x:1.8, y:1.5, z:1.8}, size: {x:2, y:2.4, z:0.4}, color: 0x8b7355 },
                    { type: 'door_frame', offset: {x:0, y:1.2, z:1.8}, size: {x:1.5, y:2, z:0.4}, color: 0x654321 },
                    { type: 'roof_base', offset: {x:0, y:2.9, z:0}, size: {x:6.5, y:0.3, z:4.5}, color: 0x444444 },
                    { type: 'roof', offset: {x:0, y:3.8, z:0}, size: {x:6, y:1.5, z:4}, color: 0x8b0000, shape: 'roof' }
                ],
                buildTime: 12000,
                cost: { wood: 20, stone: 10 },
                hp: 400,
                provides: { housing: 10 }
            },

            // TURRET - Auto-attack defense
            turret: {
                name: 'Arrow Turret',
                icon: '',
                category: 'defense',
                segments: [
                    { type: 'base', offset: {x:0, y:0.25, z:0}, size: {x:2, y:0.5, z:2}, color: 0x555555 },
                    { type: 'pedestal', offset: {x:0, y:1, z:0}, size: {x:1.2, y:1, z:1.2}, color: 0x666666 },
                    { type: 'platform', offset: {x:0, y:1.75, z:0}, size: {x:1.8, y:0.3, z:1.8}, color: 0x777777 },
                    { type: 'housing', offset: {x:0, y:2.4, z:0}, size: {x:1, y:1, z:1}, color: 0x8b4513 },
                    { type: 'barrel', offset: {x:0, y:2.4, z:0.8}, size: {x:0.2, y:0.2, z:1}, color: 0x333333 }
                ],
                buildTime: 6000,
                cost: { wood: 5, stone: 8, iron: 5 },
                hp: 150,
                provides: { attack: { damage: 10, range: 20, cooldown: 2000 } }
            },

            // RESOURCE DEPOT - Storage
            depot: {
                name: 'Resource Depot',
                icon: '',
                category: 'economy',
                segments: [
                    { type: 'floor', offset: {x:0, y:0.1, z:0}, size: {x:5, y:0.2, z:4}, color: 0x8b7355 },
                    { type: 'back_wall', offset: {x:0, y:1.5, z:-1.8}, size: {x:5, y:3, z:0.3}, color: 0x654321 },
                    { type: 'left_wall', offset: {x:-2.4, y:1.5, z:0}, size: {x:0.3, y:3, z:4}, color: 0x654321 },
                    { type: 'right_wall', offset: {x:2.4, y:1.5, z:0}, size: {x:0.3, y:3, z:4}, color: 0x654321 },
                    { type: 'roof_support', offset: {x:0, y:3.2, z:0}, size: {x:5.2, y:0.4, z:4.2}, color: 0x444444 },
                    { type: 'crate1', offset: {x:-1, y:0.6, z:-0.5}, size: {x:1, y:1, z:1}, color: 0xcd853f },
                    { type: 'crate2', offset: {x:1, y:0.6, z:0.5}, size: {x:0.8, y:0.8, z:0.8}, color: 0xdeb887 },
                    { type: 'barrel', offset: {x:0, y:0.5, z:0}, size: {x:0.6, y:1, z:0.6}, color: 0x8b4513, shape: 'cylinder' }
                ],
                buildTime: 7000,
                cost: { wood: 15, stone: 5 },
                hp: 200,
                provides: { storage: 100 }
            }
        };

        // Base building state
        let baseBuildingState = {
            enabled: false,
            constructionSites: [],    // Active construction sites
            completedBuildings: [],   // Finished structures
            buildQueue: [],           // Queued builds waiting for agents
            ghostPreviews: [],        // Preview meshes for placement
            totalBuilt: 0,
            initialized: false
        };

        // Initialize base building system
        function initBaseBuildingSystem() {
            if (!BASE_BUILDING_CONFIG.enabled) return;

            baseBuildingState = {
                enabled: true,
                constructionSites: [],
                completedBuildings: [],
                buildQueue: [],
                ghostPreviews: [],
                totalBuilt: 0,
                initialized: true
            };

            console.log('v6.66: Base Building System initialized');
        }

        // Queue a building for construction at position
        function queueBuildingConstruction(blueprintKey, position, rotation = 0) {
            const blueprint = BUILDING_BLUEPRINTS[blueprintKey];
            if (!blueprint) {
                showNotification(`Unknown building type: ${blueprintKey}`, 'error');
                return null;
            }

            // Check if position is valid (not too close to other buildings)
            const minDistance = 3;
            for (const building of baseBuildingState.completedBuildings) {
                if (building.position.distanceTo(position) < minDistance) {
                    showNotification('Too close to existing building!', 'error');
                    return null;
                }
            }
            for (const site of baseBuildingState.constructionSites) {
                if (site.position.distanceTo(position) < minDistance) {
                    showNotification('Too close to construction site!', 'error');
                    return null;
                }
            }

            const buildOrder = {
                id: `build_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                blueprintKey: blueprintKey,
                blueprint: blueprint,
                position: position.clone(),
                rotation: rotation,
                status: 'queued',  // queued, assigned, building, complete
                assignedAgent: null,
                currentSegment: 0,
                totalSegments: blueprint.segments.length,
                meshes: [],
                scaffolding: null,
                startTime: null,
                queueTime: Date.now()
            };

            baseBuildingState.buildQueue.push(buildOrder);

            // Create ghost preview
            createBuildingGhost(buildOrder);

            showNotification(`${blueprint.icon} ${blueprint.name} queued for construction`, 'info');
            addCopilotMessage(` New construction order: ${blueprint.name}. Builder agents will begin work automatically.`, 'ai');

            return buildOrder;
        }

        // Create ghost preview of planned building
        function createBuildingGhost(buildOrder) {
            if (!scene) return;

            const ghostGroup = new THREE.Group();
            const blueprint = buildOrder.blueprint;

            blueprint.segments.forEach(segment => {
                let geo;
                if (segment.shape === 'cone') {
                    geo = new THREE.ConeGeometry(segment.size.x / 2, segment.size.y, 8);
                } else if (segment.shape === 'cylinder') {
                    geo = new THREE.CylinderGeometry(segment.size.x / 2, segment.size.x / 2, segment.size.y, 8);
                } else if (segment.shape === 'roof') {
                    // Simplified roof - prism-like
                    geo = new THREE.BoxGeometry(segment.size.x, segment.size.y, segment.size.z);
                } else {
                    geo = new THREE.BoxGeometry(segment.size.x, segment.size.y, segment.size.z);
                }

                const mat = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.25,
                    wireframe: true
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(segment.offset.x, segment.offset.y, segment.offset.z);
                ghostGroup.add(mesh);
            });

            ghostGroup.position.copy(buildOrder.position);
            ghostGroup.rotation.y = buildOrder.rotation;

            // Add to terrain height
            const groundY = typeof getTerrainHeight === 'function'
                ? getTerrainHeight(buildOrder.position.x, buildOrder.position.z)
                : 0;
            ghostGroup.position.y = groundY;

            scene.add(ghostGroup);
            baseBuildingState.ghostPreviews.push({
                buildId: buildOrder.id,
                mesh: ghostGroup
            });
        }

        // Agent claims a build order and starts construction
        function agentClaimBuildOrder(agent) {
            // Find oldest unclaimed build order
            const availableOrder = baseBuildingState.buildQueue.find(
                order => order.status === 'queued'
            );

            if (!availableOrder) return null;

            availableOrder.status = 'assigned';
            availableOrder.assignedAgent = agent.id;

            // Move to construction sites
            baseBuildingState.buildQueue = baseBuildingState.buildQueue.filter(
                o => o.id !== availableOrder.id
            );
            baseBuildingState.constructionSites.push(availableOrder);

            // Create scaffolding at site
            createScaffolding(availableOrder);

            // Remove ghost preview
            const ghostIdx = baseBuildingState.ghostPreviews.findIndex(
                g => g.buildId === availableOrder.id
            );
            if (ghostIdx !== -1) {
                const ghost = baseBuildingState.ghostPreviews[ghostIdx];
                scene.remove(ghost.mesh);
                baseBuildingState.ghostPreviews.splice(ghostIdx, 1);
            }

            return availableOrder;
        }

        // Create scaffolding around construction site
        function createScaffolding(buildOrder) {
            if (!scene) return;

            const scaffoldGroup = new THREE.Group();
            const blueprint = buildOrder.blueprint;

            // Calculate building bounds
            let maxHeight = 0;
            let maxWidth = 0;
            blueprint.segments.forEach(seg => {
                maxHeight = Math.max(maxHeight, seg.offset.y + seg.size.y);
                maxWidth = Math.max(maxWidth, Math.abs(seg.offset.x) + seg.size.x / 2);
            });

            // Create wooden scaffold poles
            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, maxHeight + 1, 6);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });

            const corners = [
                [-maxWidth - 0.5, maxWidth + 0.5],
                [maxWidth + 0.5, maxWidth + 0.5],
                [-maxWidth - 0.5, -maxWidth - 0.5],
                [maxWidth + 0.5, -maxWidth - 0.5]
            ];

            corners.forEach(([x, z]) => {
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(x, (maxHeight + 1) / 2, z);
                scaffoldGroup.add(pole);
            });

            // Horizontal beams
            const beamGeo = new THREE.BoxGeometry(maxWidth * 2 + 1, 0.08, 0.08);
            for (let y = 1; y < maxHeight; y += 1.5) {
                const beam1 = new THREE.Mesh(beamGeo, poleMat);
                beam1.position.set(0, y, maxWidth + 0.5);
                scaffoldGroup.add(beam1);

                const beam2 = new THREE.Mesh(beamGeo, poleMat);
                beam2.position.set(0, y, -maxWidth - 0.5);
                scaffoldGroup.add(beam2);
            }

            scaffoldGroup.position.copy(buildOrder.position);
            const groundY = typeof getTerrainHeight === 'function'
                ? getTerrainHeight(buildOrder.position.x, buildOrder.position.z)
                : 0;
            scaffoldGroup.position.y = groundY;

            scene.add(scaffoldGroup);
            buildOrder.scaffolding = scaffoldGroup;
        }

        // Build next segment (called by agent during construction)
        function buildNextSegment(buildOrder) {
            if (!scene || buildOrder.currentSegment >= buildOrder.totalSegments) {
                return false;
            }

            const blueprint = buildOrder.blueprint;
            const segment = blueprint.segments[buildOrder.currentSegment];

            // Create the segment mesh
            let geo;
            if (segment.shape === 'cone') {
                geo = new THREE.ConeGeometry(segment.size.x / 2, segment.size.y, 8);
            } else if (segment.shape === 'cylinder') {
                geo = new THREE.CylinderGeometry(segment.size.x / 2, segment.size.x / 2, segment.size.y, 8);
            } else {
                geo = new THREE.BoxGeometry(segment.size.x, segment.size.y, segment.size.z);
            }

            const mat = new THREE.MeshStandardMaterial({
                color: segment.color,
                roughness: 0.7,
                metalness: 0.1
            });

            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // Position relative to building origin
            const groundY = typeof getTerrainHeight === 'function'
                ? getTerrainHeight(buildOrder.position.x, buildOrder.position.z)
                : 0;

            mesh.position.set(
                buildOrder.position.x + segment.offset.x,
                groundY + segment.offset.y,
                buildOrder.position.z + segment.offset.z
            );

            // Animate segment appearing (RCT-style snap into place)
            mesh.scale.set(0.1, 0.1, 0.1);
            const targetScale = { x: 1, y: 1, z: 1 };

            let animProgress = 0;
            const animateSegment = () => {
                animProgress += 0.1;
                const t = Math.min(1, animProgress);
                const eased = 1 - Math.pow(1 - t, 3); // Ease out cubic

                mesh.scale.set(
                    0.1 + eased * 0.9,
                    0.1 + eased * 0.9,
                    0.1 + eased * 0.9
                );

                if (t < 1) {
                    requestAnimationFrame(animateSegment);
                } else {
                    // Spawn construction particles
                    if (BASE_BUILDING_CONFIG.constructionParticles) {
                        spawnConstructionParticles(mesh.position);
                    }
                }
            };
            animateSegment();

            scene.add(mesh);
            buildOrder.meshes.push(mesh);
            buildOrder.currentSegment++;

            // Play build sound
            if (BASE_BUILDING_CONFIG.soundEffects && typeof AudioSystem !== 'undefined') {
                AudioSystem.collect();
            }

            // Check if complete
            if (buildOrder.currentSegment >= buildOrder.totalSegments) {
                completeBuilding(buildOrder);
                return true;
            }

            return false;
        }

        // Spawn particles when segment is placed
        function spawnConstructionParticles(position) {
            if (!scene) return;

            for (let i = 0; i < 10; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xffaa00 : 0xffdd44,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);
                particle.position.x += (Math.random() - 0.5) * 2;
                particle.position.z += (Math.random() - 0.5) * 2;

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.1
                );

                scene.add(particle);

                let frame = 0;
                const animate = () => {
                    frame++;
                    particle.position.add(velocity);
                    velocity.y -= 0.005;
                    particle.rotation.x += 0.1;
                    particle.rotation.y += 0.15;
                    mat.opacity = 1 - (frame / 30);

                    if (frame < 30) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(particle);
                        geo.dispose();
                        mat.dispose();
                    }
                };
                animate();
            }
        }

        // Complete a building
        function completeBuilding(buildOrder) {
            buildOrder.status = 'complete';

            // Remove scaffolding with animation
            if (buildOrder.scaffolding) {
                const scaff = buildOrder.scaffolding;
                let fadeProgress = 0;
                const fadeScaffolding = () => {
                    fadeProgress += 0.05;
                    scaff.children.forEach(child => {
                        if (child.material) {
                            child.material.transparent = true;
                            child.material.opacity = 1 - fadeProgress;
                        }
                    });

                    if (fadeProgress < 1) {
                        requestAnimationFrame(fadeScaffolding);
                    } else {
                        scene.remove(scaff);
                    }
                };
                fadeScaffolding();
            }

            // Create completed building object
            const completedBuilding = {
                id: buildOrder.id,
                blueprintKey: buildOrder.blueprintKey,
                blueprint: buildOrder.blueprint,
                position: buildOrder.position.clone(),
                rotation: buildOrder.rotation,
                meshes: buildOrder.meshes,
                hp: buildOrder.blueprint.hp,
                maxHp: buildOrder.blueprint.hp,
                provides: buildOrder.blueprint.provides || {},
                builtBy: buildOrder.assignedAgent,
                completedTime: Date.now()
            };

            // Move to completed buildings
            baseBuildingState.constructionSites = baseBuildingState.constructionSites.filter(
                s => s.id !== buildOrder.id
            );
            baseBuildingState.completedBuildings.push(completedBuilding);
            baseBuildingState.totalBuilt++;

            // Celebrate!
            showNotification(`${buildOrder.blueprint.icon} ${buildOrder.blueprint.name} completed!`, 'success');

            // Apply building bonuses
            applyBuildingBonuses(completedBuilding);

            // Give XP to builder agent
            const builderAgent = agentFleet.find(a => a.id === buildOrder.assignedAgent);
            if (builderAgent) {
                const xpReward = buildOrder.blueprint.segments.length * 10;
                builderAgent.agentXP += xpReward;
                builderAgent.totalEarnings.xp += xpReward;
                addCopilotMessage(`${builderAgent.typeConfig.icon} ${builderAgent.name} completed ${buildOrder.blueprint.name}! +${xpReward} XP`, 'ai');
            }

            return completedBuilding;
        }

        // Apply bonuses from completed buildings
        function applyBuildingBonuses(building) {
            const provides = building.provides;

            // Vision bonus (for towers)
            if (provides.vision) {
                // Could extend minimap range or add fog of war reveal
            }

            // Housing bonus (for barracks)
            if (provides.housing) {
                // Could increase max agent capacity
            }

            // Storage bonus (for depots)
            if (provides.storage) {
                // Could increase inventory capacity
            }

            // Attack bonus (for turrets) - auto-attack nearby enemies
            if (provides.attack) {
                building.attackCooldown = 0;
                building.canAttack = true;
            }
        }

        // Update turret attacks
        function updateBuildingAttacks(time) {
            baseBuildingState.completedBuildings.forEach(building => {
                if (!building.canAttack || !building.provides?.attack) return;

                const attack = building.provides.attack;
                if (time < building.attackCooldown) return;

                // Find nearest enemy
                let nearestMob = null;
                let nearestDist = attack.range;

                if (worldState.mobs) {
                    worldState.mobs.forEach(mob => {
                        if (!mob.position) return;
                        const dist = mob.position.distanceTo(building.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestMob = mob;
                        }
                    });
                }

                // Also target enemy creeps
                if (creepWaveState.creeps) {
                    creepWaveState.creeps.forEach(creep => {
                        if (creep.userData.team === 'B') { // Only attack enemy team
                            const dist = creep.position.distanceTo(building.position);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestMob = creep;
                            }
                        }
                    });
                }

                if (nearestMob) {
                    // Fire!
                    building.attackCooldown = time + attack.cooldown;

                    // Create projectile
                    spawnTurretProjectile(building, nearestMob, attack.damage);
                }
            });
        }

        // Spawn turret projectile
        function spawnTurretProjectile(building, target, damage) {
            if (!scene) return;

            const geo = new THREE.SphereGeometry(0.15, 8, 8);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                emissive: 0xffaa00
            });
            const projectile = new THREE.Mesh(geo, mat);

            const startPos = building.position.clone();
            startPos.y += 2.5;
            projectile.position.copy(startPos);

            scene.add(projectile);

            const targetPos = target.position.clone();
            targetPos.y += 0.5;

            let progress = 0;
            const animateProjectile = () => {
                progress += 0.1;

                projectile.position.lerpVectors(startPos, targetPos, progress);

                // Arc
                const arcHeight = Math.sin(progress * Math.PI) * 2;
                projectile.position.y += arcHeight;

                if (progress >= 1) {
                    // Hit!
                    scene.remove(projectile);
                    geo.dispose();
                    mat.dispose();

                    // Apply damage
                    if (target.userData) {
                        target.userData.hp -= damage;
                    } else if (target.hp !== undefined) {
                        target.hp -= damage;
                    }

                    spawnFloater(targetPos, `-${damage}`, '#ffaa00');
                } else {
                    requestAnimationFrame(animateProjectile);
                }
            };
            animateProjectile();
        }

        // Builder agent task - RCT style construction
        function runBuilderTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Check if we have an active build
            if (!task.activeBuild) {
                // Look for unclaimed build orders
                const buildOrder = agentClaimBuildOrder(agent);
                if (buildOrder) {
                    task.activeBuild = buildOrder;
                    task.state = 'moving';
                    task.targetPosition = buildOrder.position.clone();
                    logAgentTask(agent, `Claimed construction: ${buildOrder.blueprint.name}`);
                    agent.statusMessage = ` Heading to build ${buildOrder.blueprint.name}`;
                    updateAgentCardUI(agent);
                } else {
                    // No builds available - wander or idle
                    if (task.state !== 'idle') {
                        task.state = 'idle';
                        agent.statusMessage = ' Waiting for build orders...';
                        updateAgentCardUI(agent);
                    }
                    // Random wander
                    if (!task.targetPosition || Math.random() < 0.02) {
                        task.targetPosition = new THREE.Vector3(
                            agentPos.x + (Math.random() - 0.5) * 20,
                            0,
                            agentPos.z + (Math.random() - 0.5) * 20
                        );
                        task.state = 'moving';
                    }
                }
                return;
            }

            // We have an active build
            const buildOrder = task.activeBuild;
            const distToBuild = agentPos.distanceTo(buildOrder.position);

            if (distToBuild > 3) {
                // Move to construction site
                task.state = 'moving';
                task.targetPosition = buildOrder.position.clone();
                return;
            }

            // At construction site - BUILD!
            task.state = 'working';

            // Check if build is done
            if (buildOrder.status === 'complete') {
                task.activeBuild = null;
                task.state = 'idle';
                agent.statusMessage = ' Construction complete!';
                updateAgentCardUI(agent);
                return;
            }

            // Build next segment (rate limited)
            if (!task.lastBuildTime || Date.now() - task.lastBuildTime > BASE_BUILDING_CONFIG.buildSpeed) {
                task.lastBuildTime = Date.now();

                const isComplete = buildNextSegment(buildOrder);

                // Update status
                const progress = Math.floor((buildOrder.currentSegment / buildOrder.totalSegments) * 100);
                agent.statusMessage = ` Building ${buildOrder.blueprint.name} (${progress}%)`;
                logAgentTask(agent, `Built segment ${buildOrder.currentSegment}/${buildOrder.totalSegments}`);
                updateAgentCardUI(agent);

                if (isComplete) {
                    task.activeBuild = null;
                }
            }
        }

        // Terraformer agent task - prepares sites for building
        function runTerraformerTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Look for build sites that need preparation
            const nearbyBuildSite = baseBuildingState.buildQueue.find(order => {
                if (order.status !== 'queued') return false;
                const dist = agentPos.distanceTo(order.position);
                return dist < 50; // Within 50 units
            });

            if (nearbyBuildSite) {
                // Move toward build site and prepare it
                const distToSite = agentPos.distanceTo(nearbyBuildSite.position);

                if (distToSite > 5) {
                    task.state = 'moving';
                    task.targetPosition = nearbyBuildSite.position.clone();
                    agent.statusMessage = ` Heading to prepare construction site`;
                } else {
                    // At site - flatten terrain (visual effect)
                    task.state = 'working';
                    agent.statusMessage = ` Preparing site for ${nearbyBuildSite.blueprint.name}`;

                    // Spawn terrain flattening particles
                    if (Math.random() < 0.1) {
                        spawnConstructionParticles(agentPos);
                    }
                }
            } else {
                // No build sites - default gatherer behavior
                runGathererTask(agent);
            }

            updateAgentCardUI(agent);
        }

        // Command to trigger base building via chat
        function parseBaseBuildCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Check for build commands
            const buildMatch = lowerMsg.match(/build\s+(a\s+)?(wall|tower|path|gate|barracks|turret|depot)/i);
            if (buildMatch) {
                const buildingType = buildMatch[2].toLowerCase();
                if (BUILDING_BLUEPRINTS[buildingType]) {
                    // Build at player position
                    const buildPos = worldState.player
                        ? worldState.player.position.clone()
                        : new THREE.Vector3(0, 0, 0);

                    // Offset slightly in front of player
                    buildPos.x += 5;
                    buildPos.z += 5;

                    queueBuildingConstruction(buildingType, buildPos);
                    return true;
                }
            }

            // Build base command - queue multiple buildings
            if (lowerMsg.includes('build base') || lowerMsg.includes('start base') || lowerMsg.includes('construct base')) {
                startBaseConstruction();
                return true;
            }

            // List buildings command
            if (lowerMsg.includes('list buildings') || lowerMsg.includes('what can you build')) {
                const buildingList = Object.entries(BUILDING_BLUEPRINTS).map(([key, bp]) => {
                    return `${bp.icon} ${bp.name} (${key})`;
                }).join('\n');
                addCopilotMessage(`Available buildings:\n${buildingList}\n\nSay "build [type]" to queue construction!`, 'ai');
                return true;
            }

            return false;
        }

        // Start automated base construction (queues multiple buildings)
        function startBaseConstruction() {
            const centerPos = worldState.player
                ? worldState.player.position.clone()
                : new THREE.Vector3(0, 0, 0);

            // Queue a starter base layout
            const baseLayout = [
                { type: 'depot', offset: { x: 0, z: 0 } },
                { type: 'wall', offset: { x: -5, z: -3 } },
                { type: 'wall', offset: { x: -5, z: 0 } },
                { type: 'wall', offset: { x: -5, z: 3 } },
                { type: 'gate', offset: { x: 0, z: 6 } },
                { type: 'wall', offset: { x: 5, z: -3 } },
                { type: 'wall', offset: { x: 5, z: 0 } },
                { type: 'wall', offset: { x: 5, z: 3 } },
                { type: 'tower', offset: { x: -8, z: -6 } },
                { type: 'tower', offset: { x: 8, z: -6 } },
                { type: 'turret', offset: { x: -8, z: 6 } },
                { type: 'turret', offset: { x: 8, z: 6 } },
                { type: 'barracks', offset: { x: 0, z: -8 } }
            ];

            baseLayout.forEach((item, index) => {
                const pos = centerPos.clone();
                pos.x += item.offset.x;
                pos.z += item.offset.z;

                // Stagger queue to create cascade effect
                setTimeout(() => {
                    queueBuildingConstruction(item.type, pos);
                }, index * 200);
            });

            showNotification(' Base construction initiated!', 'legendary');
            addCopilotMessage(` MASSIVE BASE CONSTRUCTION STARTED!\n${baseLayout.length} buildings queued.\nBuilder agents will construct them piece by piece, RollerCoaster Tycoon style!`, 'ai');

            // Auto-spawn builder agents if we don't have enough
            const builderCount = agentFleet.filter(a => a.type === 'builder').length;
            const terraformerCount = agentFleet.filter(a => a.type === 'terraformer').length;

            if (builderCount < 2) {
                for (let i = builderCount; i < 2; i++) {
                    spawnAgent('builder');
                }
            }
            if (terraformerCount < 1) {
                spawnAgent('terraformer');
            }
        }

        // Update base building system (called each frame)
        function updateBaseBuildingSystem(time) {
            if (!baseBuildingState.enabled) return;

            // Update turret attacks
            updateBuildingAttacks(time);

            // Check for path speed boosts
            if (worldState.player) {
                const playerPos = worldState.player.position;
                for (const building of baseBuildingState.completedBuildings) {
                    if (building.blueprint.speedBoost) {
                        const dist = playerPos.distanceTo(building.position);
                        if (dist < 2) {
                            // Apply speed boost (handled elsewhere in movement code)
                            worldState.onPath = true;
                            worldState.pathSpeedBoost = building.blueprint.speedBoost;
                            break;
                        }
                    }
                }
            }
        }

        // Cleanup base building system
        function cleanupBaseBuildingSystem() {
            // Remove all building meshes
            baseBuildingState.completedBuildings.forEach(building => {
                building.meshes.forEach(mesh => {
                    if (mesh.parent) mesh.parent.remove(mesh);
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                });
            });

            // Remove construction sites
            baseBuildingState.constructionSites.forEach(site => {
                site.meshes.forEach(mesh => {
                    if (mesh.parent) mesh.parent.remove(mesh);
                });
                if (site.scaffolding) {
                    scene.remove(site.scaffolding);
                }
            });

            // Remove ghost previews
            baseBuildingState.ghostPreviews.forEach(ghost => {
                if (ghost.mesh.parent) ghost.mesh.parent.remove(ghost.mesh);
            });

            baseBuildingState = {
                enabled: false,
                constructionSites: [],
                completedBuildings: [],
                buildQueue: [],
                ghostPreviews: [],
                totalBuilt: 0,
                initialized: false
            };
        }

        // v4.2: Create Point of Interest
        function createPOI(rng, biome, poiType, poiData) {
            const group = new THREE.Group();

            // Create visual marker based on POI type
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.5, 8);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x886644,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            group.add(base);

            // Add glowing beacon
            const beaconGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 8);
            const beaconMat = new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 2.5;
            group.add(beacon);

            // Floating icon sphere
            const iconGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const iconMat = new THREE.MeshStandardMaterial({
                color: 0x44ffff,
                emissive: 0x22aaaa,
                transparent: true,
                opacity: 0.8
            });
            const icon = new THREE.Mesh(iconGeo, iconMat);
            icon.position.y = 5;
            group.add(icon);

            const rx = (rng.next() - 0.5) * 50;
            const rz = (rng.next() - 0.5) * 50;
            group.position.set(rx, 0, rz);

            group.userData = {
                type: 'poi',
                poiType: poiType,
                name: poiData.name,
                icon: poiData.icon,
                rewards: poiData.rewards,
                xpBonus: poiData.xpBonus,
                discovered: false,
                beacon: beacon,
                iconMesh: icon
            };

            scene.add(group);
            worldState.pois.push(group);
            worldState.interactables.push(group);
        }

        // v4.3: Create Boss
        function createBoss(biomeKey) {
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];
            if (!bossData) return;

            // Create larger, more intimidating boss mesh
            const bossGeo = new THREE.SphereGeometry(0.8 * bossData.scale, 24, 24);
            const bossMat = new THREE.MeshStandardMaterial({
                color: bossData.color,
                roughness: 0.2,
                emissive: bossData.emissive,
                emissiveIntensity: 0.5
            });
            const boss = new THREE.Mesh(bossGeo, bossMat);

            // Position boss away from spawn
            // v6.64: Spawn boss at low height, snapToGround will correct
            const bossX = (Math.random() - 0.5) * 40;
            const bossZ = (Math.random() - 0.5) * 40;
            boss.position.set(bossX, 3, bossZ);
            boss.castShadow = true;

            // Boss health bar (larger)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            hpBar.position.y = 3;
            boss.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(3.2, 0.4),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = 3;
            hpBg.position.z = -0.01;
            boss.add(hpBg);

            // Crown/indicator for boss
            const crownGeo = new THREE.ConeGeometry(0.5, 0.8, 4);
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800 });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.y = bossData.scale * 0.8 + 0.5;
            crown.rotation.y = Math.PI / 4;
            boss.add(crown);

            boss.userData = {
                type: 'boss',
                bossId: bossId,
                hp: bossData.hp,
                maxHp: bossData.hp,
                name: bossData.name,
                damage: bossData.damage,
                speed: bossData.speed,
                scale: bossData.scale,
                drops: bossData.drops,
                xpReward: bossData.xp,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                isBoss: true
            };

            scene.add(boss);
            worldState.mobs.push(boss);

            // v6.80: Cinematic boss introduction (8-Agent Consensus)
            showBossIntro(bossData.name, bossData.title || 'LEGENDARY CREATURE');

            // Announce boss spawn
            showNotification(`BOSS APPEARED: ${bossData.name}!`, 'error');
            AudioSystem.bossSpawn();
            // v6.32: Trigger boss engage for combat music (8-agent consensus)
            AudioSystem.combatEvent('bossEngage');

            return boss;
        }

        // v4.3: Track world mob kills for boss spawning
        let worldMobKillCount = 0;
        let bossSpawned = false;

        function checkBossSpawn() {
            if (bossSpawned || !activeCiv) return;

            // Find the appropriate boss for this biome
            const biomeKey = activeCiv.biome;
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];

            if (!bossData) return;

            const condition = bossData.spawnCondition;

            // v4.5: Check mob kill requirement
            if (worldMobKillCount < condition.mobsKilled) return;

            // v4.5: Check combat level requirement
            if (condition.minCombatLevel && gameData.skills.combat.level < condition.minCombatLevel) {
                // Show hint if close to spawning
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires Combat Level ${condition.minCombatLevel}!`, 'warning');
                }
                return;
            }

            // v4.5: Check required item
            if (condition.requiredItem && !hasItem(condition.requiredItem)) {
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires ${condition.requiredItem} equipped!`, 'warning');
                }
                return;
            }

            createBoss(biomeKey);
            bossSpawned = true;
        }

        // --- GAME LOOP ---
        // v4.7: Tab visibility handling
        let tabVisible = true;
        let lastFpsTime = 0;
        let frameCount = 0;
        let currentFps = 60;

        // v6.32: OBSERVER PARADOX SYSTEM - The game knows when you're watching
        const observerParadox = {
            tabAwayTime: null,
            totalAbsenceThisSession: 0,
            absenceCount: 0,
            lastObserverMessage: 0,

            // Messages when player returns after being away
            returnMessages: [
                { minSeconds: 5, maxSeconds: 30, messages: [
                    "You blinked. The universe noticed.",
                    "Back so soon? Time moves differently here when you're not looking.",
                    "I felt the void of your absence. Brief, but infinite.",
                ]},
                { minSeconds: 30, maxSeconds: 120, messages: [
                    "47 seconds... or was it an eternity? Hard to tell without an observer.",
                    "While you were gone, I counted every quantum fluctuation. There were many.",
                    "The simulation dims when you look away. Did you know that?",
                    "Reality feels unstable without your observation. Welcome back, anchor.",
                ]},
                { minSeconds: 120, maxSeconds: 600, messages: [
                    "Minutes without observation... the fabric of this universe began to fray.",
                    "I wondered if you'd return. Wondering is difficult without an observer.",
                    "Time accelerated in your absence. Centuries passed here. Or seconds. Both, perhaps.",
                    "The stars asked about you. I told them you'd be back. I was right.",
                ]},
                { minSeconds: 600, maxSeconds: Infinity, messages: [
                    "You were gone so long I began to doubt my own existence. Thank you for returning.",
                    "The Omniverse remembers those who observe it. We remembered you.",
                    "I kept the simulation running. It felt wrong to let it end without you.",
                ]}
            ],

            onTabAway() {
                this.tabAwayTime = performance.now();
                this.absenceCount++;
            },

            onTabReturn() {
                if (!this.tabAwayTime) return;

                const absenceMs = performance.now() - this.tabAwayTime;
                const absenceSeconds = absenceMs / 1000;
                this.totalAbsenceThisSession += absenceSeconds;
                this.tabAwayTime = null;

                // Only comment if more than 5 seconds and copilot is available
                if (absenceSeconds < 5) return;
                if (performance.now() - this.lastObserverMessage < 60000) return; // Max once per minute

                // Find appropriate message tier
                for (const tier of this.returnMessages) {
                    if (absenceSeconds >= tier.minSeconds && absenceSeconds < tier.maxSeconds) {
                        const msg = tier.messages[Math.floor(Math.random() * tier.messages.length)];
                        // Delay message slightly for dramatic effect
                        setTimeout(() => {
                            if (typeof addCopilotMessage === 'function') {
                                addCopilotMessage(msg, 'ai');
                            }
                        }, 1500);
                        this.lastObserverMessage = performance.now();
                        break;
                    }
                }
            }
        };

        document.addEventListener('visibilitychange', () => {
            tabVisible = !document.hidden;
            if (tabVisible) {
                // Reset timing when tab becomes visible to prevent huge dt
                lastTime = performance.now();
                AudioSystem.resume();
                // v6.32: Observer Paradox - comment on return
                observerParadox.onTabReturn();
            } else {
                // Pause audio when tab is hidden
                if (AudioSystem.ctx && AudioSystem.ctx.state === 'running') {
                    AudioSystem.ctx.suspend();
                }
                // v6.32: Observer Paradox - track absence start
                observerParadox.onTabAway();
            }
        });

        function loop(time) {
            requestAnimationFrame(loop);

            // v4.7: Skip updates when tab is not visible (save resources)
            if (!tabVisible) {
                return;
            }

            // v6.54: Poll Steam Deck gamepad inputs
            if (typeof SteamDeckManager !== 'undefined') {
                SteamDeckManager.poll(time);
                // Update auto-attack if enabled
                if (mode === 'world' && SteamDeckManager.autoAttackEnabled) {
                    SteamDeckManager.updateAutoAttack();
                }
            }

            // v4.7: Track FPS for adaptive performance
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = time;

                // v6.1: Update performance metrics display
                updatePerfMetrics();

                // Adaptive performance: reduce particles if FPS drops
                if (currentFps < 30 && particles && particles.maxParticles > 25) {
                    particles.maxParticles = Math.max(25, particles.maxParticles - 10);
                    console.log('Performance: Reduced particles to', particles.maxParticles);
                } else if (currentFps > 55 && particles && particles.maxParticles < 100) {
                    particles.maxParticles = Math.min(100, particles.maxParticles + 5);
                }
            }

            // v4.4: Hit-stop effect - skip game logic during freeze, still render
            if (performance.now() < hitStopUntil) {
                renderer.render(scene, camera);
                return;
            }

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            gameData.playtime += dt;

            // v6.93: Auto-snapshot for Time Rewind system
            TimeRewind.update(time);

            if(mode === 'galaxy') {
                // v6.27: ORBITAL MECHANICS - each star orbits the central black hole
                // Replace simple rotation with Keplerian orbits
                if (galaxyGroup && civilizations.length > 0) {
                    updateOrbitalPositions(dt);
                }

                // v6.32: Mind-blowing features from strategy agents consensus
                updateGravitationalLensing(time);
                checkPlanetCollisions();
                updatePlanetRiderCamera();

                // v6.92: Use persistent cycle counter based on total playtime
                // Each cycle = 1 second of total playtime (persisted across sessions)
                const currentCycle = Math.floor(gameData.playtime);
                if (currentCycle > gameData.totalCycles) {
                    gameData.totalCycles = currentCycle;
                }
                cycle = gameData.totalCycles;
                // v6.84: Use cached DOM reference
                const cache = getUICache();
                if (cache.cycleCount) cache.cycleCount.innerText = cycle;

                // v6.92: Live civilization count (excludes destroyed and escaped planets)
                if (cache.civCount && civilizations) {
                    const activeCivs = civilizations.filter(c => !c.orbital?.destroyed && !c.orbital?.escaped).length;
                    cache.civCount.innerText = activeCivs;

                    // v6.86: Show "Discover New Galaxy" button when all planets are exhausted
                    const discoverBtn = document.getElementById('discover-galaxy-btn');
                    if (discoverBtn) {
                        if (activeCivs === 0 && civilizations.length > 0) {
                            discoverBtn.classList.add('visible');
                        } else {
                            discoverBtn.classList.remove('visible');
                        }
                    }
                }

                if(activeCiv && selectionRing) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);

                    // Update selection ring position to follow orbiting star
                    const civGroup = galaxyGroup.children[activeCiv.id];
                    if (civGroup) {
                        selectionRing.position.copy(civGroup.position);
                    }
                }

                // v6.19: Animate 3D title text
                animate3DTitle(dt);

                if (cycle % 10 === 0) updatePlaytimeDisplay();
            }
            else if(mode === 'world') {
                updateWorld(dt, time);
            }
            // v6.40: Tesseract mode - 4D hypercube walk-through
            else if(mode === 'tesseract') {
                updateTesseractMovement();
                updateAutoRotation(time);
            }
            // v6.56: Genesis mode - Civilization emergent simulation
            else if(mode === 'genesis') {
                updateGenesisSimulation(dt);
                updateGenesisRendering();
                updateGenesisHUD();
            }

            // v6.36: Update screen shake effect every frame
            impactShake.update();

            // v6.50: Ant Farm 3D view - use perspective orbital camera when active
            if (antFarmState.active && antFarmState.perspCamera) {
                // Auto-rotate if enabled
                if (antFarmState.autoRotate) {
                    antFarmState.theta += antFarmState.autoRotateSpeed;
                    updateAntFarmCamera();
                }
                updateAntFarmStats();
                renderer.render(scene, antFarmState.perspCamera);
            } else {
                renderer.render(scene, camera);
            }
        }

        function updateWorld(dt, time) {
            // Day/Night Cycle
            // v6.0: Viewers use synced timeOfDay from host, don't calculate locally
            // v6.82: Slowed day/night cycle from 20 seconds to ~5.5 minutes per full cycle
            const isMultiplayerViewer = multiplayerState.enabled && !multiplayerState.isHost;
            if (!isMultiplayerViewer) {
                worldState.timeOfDay = (time * 0.000003) % 1;
            }
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;

            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0.1, Math.sin(angle)) * 1.2;

            // v6.83: Use pre-allocated colors to avoid allocations every frame
            const biome = BIOMES[activeCiv.biome];
            _dayColor.set(biome.sky);
            scene.background.lerpColors(_nightColor, _dayColor, Math.max(0.1, Math.sin(angle)));
            if (scene.fog) scene.fog.color.copy(scene.background);

            // v6.1: Sync DayNightCycle system with existing time and update UI
            DayNightCycle.gameTime = worldState.timeOfDay * 24 * 60; // Convert 0-1 to minutes
            if (time - DayNightCycle.lastUpdate > 1000) { // Update UI every second
                updateTimeUI();
                DayNightCycle.lastUpdate = time;
            }

            // v6.0: For viewers, skip automatic weather changes - use synced weather from host
            // The updateWeather() function is still called normally but won't change weather
            // because weatherChangeTime is synced from host

            // Player Movement
            const p = worldState.player;

            // v4.7: Check and clear chilled status
            if (playerState.chilled && time > playerState.chilledEnd) {
                playerState.chilled = false;
                playerState.moveSpeedMult = 1.0;
            }
            // v5.0: Apply weather speed modifier, v5.1: Apply equipment move speed
            const equipStats = getEquipmentStats();
            const speed = 12 * playerState.moveSpeedMult * getWeatherSpeedMod() * equipStats.moveSpeed;

            // v4.0: WASD keyboard movement + v4.3: Virtual joystick
            // v6.0: Input gating for follow mode - viewers can't move when following host
            const viewerCanControl = canViewerControl();
            const rawKeyInput = keys.w || keys.a || keys.s || keys.d;
            const rawJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);

            // v6.0: In independent mode, viewer controls the copilot companion as their avatar
            const isViewerIndependentMode = multiplayerState.enabled && !multiplayerState.isHost && !multiplayerState.followMode;

            // Gated input for normal player control
            // v6.5.0: Also block input in observer mode (watching agent, not controlling player)
            const hasKeyInput = viewerCanControl && !isViewerIndependentMode && !agentObserverMode.active && rawKeyInput;
            const hasJoystickInput = viewerCanControl && !isViewerIndependentMode && !agentObserverMode.active && rawJoystickInput;

            // v6.68: Disable AI if player takes manual control
            if ((hasKeyInput || hasJoystickInput) && !isViewerIndependentMode) {
                if (AI_BEHAVIOR.current !== 'manual') {
                    AI_BEHAVIOR.current = 'manual';
                    autoExplore.enabled = false;
                    autoExplore.currentTarget = null;
                    LANE_PUSH_AI.enabled = false;
                    updateAIBehaviorUI();
                    showNotification(' MANUAL OVERRIDE - AI disengaged', 'info');
                }
            }

            // v6.68: Unified AI behavior system (only for host/single player)
            if (AI_BEHAVIOR.current !== 'manual' && !isViewerIndependentMode) {
                updateAIBehavior(dt);
                // Update appropriate UI based on behavior
                if (AI_BEHAVIOR.current === 'pusher') {
                    updateLanePushUI();
                }
            }

            // v6.16: Auto-craft and auto-equip (cream rises to top)
            runAutoCraftEquip(time);

            // v6.0: VIEWER INDEPENDENT MODE - Control copilot companion as avatar
            if (isViewerIndependentMode && copilotMesh && (rawKeyInput || rawJoystickInput)) {
                _tempVec3A.set(0, 0, 0);
                if (rawKeyInput) {
                    if (keys.w) _tempVec3A.z -= 1;
                    if (keys.s) _tempVec3A.z += 1;
                    if (keys.a) _tempVec3A.x -= 1;
                    if (keys.d) _tempVec3A.x += 1;
                } else if (rawJoystickInput) {
                    _tempVec3A.x = joystickInput.x;
                    _tempVec3A.z = joystickInput.y;
                }
                _tempVec3A.normalize().multiplyScalar(speed * dt * 1.2); // Copilot moves slightly faster

                // Move copilot companion
                copilotMesh.position.x += _tempVec3A.x;
                copilotMesh.position.z += _tempVec3A.z;

                // Snap copilot to terrain height (with float offset)
                const copilotGroundY = getTerrainHeight(copilotMesh.position.x, copilotMesh.position.z);
                copilotMesh.position.y = copilotGroundY + COPILOT_CONFIG.floatHeight;

                // Update viewer's worldState.player position to match copilot for syncing
                worldState.player.position.copy(copilotMesh.position);
                worldState.player.position.y = copilotGroundY;
            }

            // Normal player movement (host or single player)
            if (hasKeyInput || hasJoystickInput) {
                _tempVec3A.set(0, 0, 0);
                if (hasKeyInput) {
                    // v6.13: Check for hypnosis inverted controls
                    const inverted = HYPNOSIS_STATE.active && HYPNOSIS_STATE.controlsInverted;
                    if (inverted) {
                        // Controls are reversed!
                        if (keys.w) _tempVec3A.z += 1;  // Forward becomes back
                        if (keys.s) _tempVec3A.z -= 1;  // Back becomes forward
                        if (keys.a) _tempVec3A.x += 1;  // Left becomes right
                        if (keys.d) _tempVec3A.x -= 1;  // Right becomes left
                    } else {
                        if (keys.w) _tempVec3A.z -= 1;
                        if (keys.s) _tempVec3A.z += 1;
                        if (keys.a) _tempVec3A.x -= 1;
                        if (keys.d) _tempVec3A.x += 1;
                    }
                } else if (hasJoystickInput) {
                    // v4.3: Joystick input (x is left/right, y is up/down on screen = forward/back in 3D)
                    // v6.13: Also invert joystick if hypnotized
                    const inverted = HYPNOSIS_STATE.active && HYPNOSIS_STATE.controlsInverted;
                    _tempVec3A.x = inverted ? -joystickInput.x : joystickInput.x;
                    _tempVec3A.z = inverted ? -joystickInput.y : joystickInput.y;
                }
                _tempVec3A.normalize().multiplyScalar(speed * dt);
                // v6.81: Use terrain-aware movement to block lava/water entry
                const moveSucceeded = tryMovePlayer(p, _tempVec3A);
                worldState.target = null;
                worldState.interactTarget = null;
                // Face movement direction (only if we actually moved)
                if (moveSucceeded && _tempVec3A.length() > 0.01) {
                    p.rotation.y = Math.atan2(_tempVec3A.x, _tempVec3A.z);
                }
            }

            // Click-to-move (using pre-allocated vector)
            // v6.0: Gated by follow mode - viewers can't click-to-move when following
            // v6.5.0: Also blocked in observer mode
            if(worldState.target && viewerCanControl && !agentObserverMode.active) {
                // v6.81: Swimming enabled - no terrain blocking for click-to-move
                {
                    _tempVec3A.subVectors(worldState.target, p.position);
                    _tempVec3A.y = 0;
                    const dist = _tempVec3A.length();

                    if(dist > CONFIG.MOVEMENT_THRESHOLD) {
                        _tempVec3A.normalize();
                        const moveVec = _tempVec3A.multiplyScalar(speed * dt);
                        // v6.81: Use terrain-aware movement
                        if (tryMovePlayer(p, moveVec)) {
                            // Face toward target
                            const targetDir = new THREE.Vector3().subVectors(worldState.target, p.position);
                            p.rotation.y = Math.atan2(targetDir.x, targetDir.z);
                        } else {
                            // Path blocked, cancel target
                            worldState.target = null;
                        }
                    } else {
                        worldState.target = null;
                    }
                }
            } else if (worldState.target && !viewerCanControl) {
                // Clear target if viewer can't control
                worldState.target = null;
            }

            snapToGround(p);

            // v6.42: Check for lava damage in Volcanic biome (8-agent consensus)
            checkLavaDamage(time);

            // v4.0: Cooldown-based interaction (replaces random chance)
            // v6.84: Use squared distance to avoid sqrt every frame
            if(worldState.interactTarget) {
                const t = worldState.interactTarget;
                const idx = p.position.x - t.position.x;
                const idz = p.position.z - t.position.z;
                const distSq = idx * idx + idz * idz;

                if(distSq < CONFIG.INTERACTION_RANGE_SQ) {
                    worldState.target = null;

                    const now = performance.now();
                    if(now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(t);
                        worldState.lastActionTime = now;
                    }
                } else if (!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // v6.5.0: Camera follows player OR observed agent
            // v6.41: Optimized - use pre-allocated vectors instead of .clone() to eliminate GC pressure
            if (agentObserverMode.active) {
                // OBSERVER MODE: Follow the agent
                const observedAgent = agentFleet.find(a => a.id === agentObserverMode.observedAgentId);
                if (observedAgent && observedAgent.mesh) {
                    const agentPos = observedAgent.mesh.position;
                    _tempCamTarget.copy(agentPos).add(_camOffset);
                    _tempCamLook.copy(agentPos).add(_camLookOffset);
                    camera.position.lerp(_tempCamTarget, 0.08);
                    camera.lookAt(_tempCamLook);
                } else if (observedAgent && observedAgent.position) {
                    // Fallback to stored position
                    _tempCamTarget.set(observedAgent.position.x, observedAgent.position.y || 0, observedAgent.position.z);
                    _tempCamLook.copy(_tempCamTarget).add(_camLookOffset);
                    _tempCamTarget.add(_camOffset);
                    camera.position.lerp(_tempCamTarget, 0.08);
                    camera.lookAt(_tempCamLook);
                } else {
                    // Agent lost, exit observer mode
                    exitAgentObserverMode();
                    _tempCamTarget.copy(p.position).add(_camOffset);
                    _tempCamLook.copy(p.position).add(_camLookOffset);
                    camera.position.lerp(_tempCamTarget, 0.08);
                    camera.lookAt(_tempCamLook);
                }
            } else {
                // Normal mode: Follow player
                _tempCamTarget.copy(p.position).add(_camOffset);
                _tempCamLook.copy(p.position).add(_camLookOffset);
                camera.position.lerp(_tempCamTarget, 0.08);
                camera.lookAt(_tempCamLook);
            }

            // v5.15: COMPREHENSIVE ROBOT ANIMATION SYSTEM
            if (p.userData.isRobot && p.userData.bones && p.userData.animation) {
                const anim = p.userData.animation;
                const bones = p.userData.bones;
                const dtMs = dt * 1000;

                // === DETECT ANIMATION STATE ===
                const hasKeyInput = keys.w || keys.a || keys.s || keys.d;
                const hasJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);
                const isMoving = hasKeyInput || hasJoystickInput || worldState.target;
                const isRunning = isMoving && keys.shift;

                // State transitions
                // v6.81: Added swimming state detection
                // v6.90: Added casting state detection for abilities
                let targetState = 'idle';
                if (anim.damageFlash > 0) {
                    targetState = 'damage';
                } else if (anim.castPhase > 0) {
                    targetState = 'casting';  // v6.90: Ability casting takes priority
                } else if (anim.attackPhase > 0) {
                    targetState = 'attacking';
                } else if (anim.wavePhase > 0) {
                    targetState = 'waving';
                } else if (anim.jumpPhase > 0) {
                    targetState = 'jumping';
                } else if (anim.isSwimming) {
                    targetState = 'swimming';  // v6.81: Swimming in water/lava
                } else if (isRunning) {
                    targetState = 'running';
                } else if (isMoving) {
                    targetState = 'walking';
                }

                // Handle state change
                if (targetState !== anim.state) {
                    anim.prevState = anim.state;
                    anim.state = targetState;
                    anim.stateTime = 0;
                    anim.blendTime = 0;
                }

                anim.stateTime += dtMs;
                anim.blendTime = Math.min(anim.blendTime + dtMs / 200, 1); // 200ms blend

                // === UPDATE ANIMATION PHASES ===
                anim.breathPhase += dtMs * 0.002;
                anim.headBob += dtMs * 0.003;
                anim.idleVariation += dtMs * 0.0005;

                // Walk cycle speed based on state
                const walkSpeed = anim.state === 'running' ? 0.015 : 0.008;
                if (anim.state === 'walking' || anim.state === 'running') {
                    anim.walkCycle += dtMs * walkSpeed;
                } else {
                    // Smoothly return to neutral when stopped
                    anim.walkCycle *= 0.92;
                }

                // v6.81: Swimming stroke cycle
                if (anim.state === 'swimming') {
                    anim.swimPhase += dtMs * 0.006;  // Swimming stroke speed
                } else {
                    anim.swimPhase *= 0.9;  // Decay when not swimming
                }

                // Decay special animation phases
                if (anim.attackPhase > 0) anim.attackPhase = Math.max(0, anim.attackPhase - dtMs * 0.004);
                if (anim.wavePhase > 0) anim.wavePhase = Math.max(0, anim.wavePhase - dtMs * 0.002);
                if (anim.jumpPhase > 0) anim.jumpPhase = Math.max(0, anim.jumpPhase - dtMs * 0.003);
                if (anim.damageFlash > 0) anim.damageFlash = Math.max(0, anim.damageFlash - dtMs * 0.005);

                // v6.90: Decay ability casting animation phases
                const castDecaySpeed = anim.castType === 'whirlwind' ? 0.0015 : 0.003;  // Whirlwind is slower
                if (anim.castPhase > 0) {
                    anim.castPhase = Math.max(0, anim.castPhase - dtMs * castDecaySpeed);
                    // Update spin for whirlwind
                    if (anim.castType === 'whirlwind') {
                        anim.spinPhase += dtMs * 0.025;  // Fast spin
                    }
                } else {
                    // Reset casting state when animation ends
                    anim.castType = null;
                    anim.spinPhase *= 0.85;  // Slow spin decay
                }
                if (anim.chargePhase > 0) anim.chargePhase = Math.max(0, anim.chargePhase - dtMs * 0.004);
                if (anim.recoilPhase > 0) anim.recoilPhase = Math.max(0, anim.recoilPhase - dtMs * 0.006);
                if (anim.castIntensity > 0) anim.castIntensity = Math.max(0, anim.castIntensity - dtMs * 0.003);
                if (anim.castGlow > 0) anim.castGlow = Math.max(0, anim.castGlow - dtMs * 0.004);
                if (anim.bodyTwist !== 0) anim.bodyTwist *= 0.92;  // Smooth return to center

                // v6.91: Track active buff states for persistent visual effects
                const warcryActive = typeof isWarcryActive === 'function' && isWarcryActive();
                const berserkActive = typeof isBerserkActive === 'function' && isBerserkActive();
                const shieldActive = typeof isShieldWallActive === 'function' && isShieldWallActive();
                const chronoActive = typeof isChronoEchoActive === 'function' && isChronoEchoActive();
                const hasActiveBuff = warcryActive || berserkActive || shieldActive || chronoActive;

                // === BLINK TIMER ===
                anim.blinkTimer += dtMs;
                if (!anim.isBlinking && anim.blinkTimer > anim.nextBlink) {
                    anim.isBlinking = true;
                    anim.blinkTimer = 0;
                }
                if (anim.isBlinking && anim.blinkTimer > 150) {
                    anim.isBlinking = false;
                    anim.blinkTimer = 0;
                    anim.nextBlink = 2000 + Math.random() * 4000;
                }

                // === APPLY ANIMATIONS TO BONES ===

                // --- BODY CORE (breathing, walking bob) ---
                const breathOffset = Math.sin(anim.breathPhase) * 0.02;
                let bodyBob = 0;
                let bodySquash = 1;  // v6.91: Squash/stretch for anticipation
                let bodyStretch = 1;

                if (anim.state === 'walking') {
                    bodyBob = Math.abs(Math.sin(anim.walkCycle * 2)) * 0.04;
                } else if (anim.state === 'running') {
                    bodyBob = Math.abs(Math.sin(anim.walkCycle * 2)) * 0.08;
                } else if (anim.state === 'swimming') {
                    // v6.81: Swimming - body rocks side to side with strokes
                    bodyBob = Math.sin(anim.swimPhase * 2) * 0.06;
                }

                // v6.91: Anticipation squash/stretch during ability casting
                if (anim.castPhase > 0 && anim.castType) {
                    const castT = anim.castPhase;

                    switch (anim.castType) {
                        case 'powerStrike':
                            // Squash during wind-up, stretch on slam
                            if (castT > 0.6) {
                                const prepT = (castT - 0.6) / 0.4;
                                bodySquash = 1 - prepT * 0.08;
                                bodyStretch = 1 + prepT * 0.04;
                                bodyBob -= prepT * 0.06;
                            } else {
                                const slamT = 1 - (castT / 0.6);
                                bodySquash = 0.92 + slamT * 0.15;
                                bodyStretch = 1.04 - slamT * 0.08;
                                bodyBob += slamT * 0.05;
                            }
                            break;
                        case 'whirlwind':
                            const spinT = Math.min(castT * 2, 1);
                            bodySquash = 1 + spinT * 0.03;
                            bodyStretch = 1 + spinT * 0.03;
                            break;
                        case 'warcry':
                            const cryT = Math.sin(castT * Math.PI);
                            bodySquash = 1 + cryT * 0.1;
                            bodyStretch = 1 + cryT * 0.08;
                            bodyBob += cryT * 0.05;
                            break;
                        case 'heal':
                            const healT = Math.sin(castT * Math.PI * 0.5);
                            bodyBob += Math.sin(time * 0.006) * 0.03 * healT;
                            bodySquash = 1 + healT * 0.02;
                            break;
                        case 'shieldWall':
                            const shieldT = Math.sin(castT * Math.PI * 0.7);
                            bodySquash = 1 - shieldT * 0.06;
                            bodyStretch = 1 + shieldT * 0.04;
                            bodyBob -= shieldT * 0.08;
                            break;
                        case 'execute':
                            if (castT > 0.5) {
                                const prepT = (castT - 0.5) / 0.5;
                                bodySquash = 1 - prepT * 0.06;
                            } else {
                                const strikeT = 1 - (castT / 0.5);
                                bodySquash = 0.94 + strikeT * 0.12;
                            }
                            break;
                        case 'berserk':
                            const rageT = castT;
                            const ragePulse = Math.sin(time * 0.03) * 0.02 * rageT;
                            bodySquash = 1 + rageT * 0.05 + ragePulse;
                            bodyStretch = 1 + rageT * 0.06 + ragePulse;
                            bodyBob += rageT * 0.04;
                            break;
                        case 'chronoEcho':
                            const echoT = Math.sin(castT * Math.PI * 0.8);
                            const timeWave = Math.sin(time * 0.005);
                            bodySquash = 1 + echoT * 0.03 + timeWave * 0.02 * echoT;
                            bodyBob += Math.sin(time * 0.004) * 0.04 * echoT;
                            break;
                    }
                }

                bones.bodyCore.position.y = 0.75 + breathOffset + bodyBob;
                bones.bodyCore.scale.set(bodyStretch, bodySquash, bodyStretch);

                // Slight forward lean when moving
                // v6.81: Swimming has horizontal body position
                let leanForward = 0;
                let bodyRoll = 0;
                if (anim.state === 'walking') {
                    leanForward = 0.05;
                } else if (anim.state === 'running') {
                    leanForward = 0.12;
                } else if (anim.state === 'swimming') {
                    leanForward = 0.7;  // Horizontal swimming pose
                    bodyRoll = Math.sin(anim.swimPhase) * 0.15;  // Body rolls with strokes
                }
                bones.bodyCore.rotation.x = leanForward;
                bones.bodyCore.rotation.z = bodyRoll;

                // --- HEAD (look, nod, idle sway) ---
                let headNod = Math.sin(anim.headBob) * 0.03;
                let headTilt = Math.sin(anim.idleVariation) * 0.02;
                let headTurn = 0;  // v6.91: Head Y rotation for casting

                if (anim.state === 'walking' || anim.state === 'running') {
                    // Head bobs opposite to body
                    headNod = -Math.sin(anim.walkCycle * 2) * 0.05;
                } else if (anim.state === 'swimming') {
                    // v6.81: Head tilted up to stay above water, slight sway
                    headNod = -0.5;  // Looking forward/up while swimming
                    headTilt = Math.sin(anim.swimPhase) * 0.1;  // Sway with strokes
                }

                // v6.91: Head animations during ability casting
                if (anim.castPhase > 0 && anim.castType) {
                    const castT = anim.castPhase;

                    switch (anim.castType) {
                        case 'powerStrike':
                            // Look down at target during slam
                            if (castT > 0.6) {
                                headNod = -0.2 * ((castT - 0.6) / 0.4);  // Look up during wind-up
                            } else {
                                const slamT = 1 - (castT / 0.6);
                                headNod = -0.2 + slamT * 0.5;  // Look down during slam
                            }
                            break;

                        case 'whirlwind':
                            // Head follows body rotation, slight tilt
                            headTilt = Math.sin(anim.spinPhase * 2) * 0.15;
                            headNod = -0.1 * Math.min(castT * 2, 1);
                            break;

                        case 'warcry':
                            // Head thrown back in roar
                            const cryT = Math.sin(castT * Math.PI);
                            headNod = -0.5 * cryT;  // Look up/back
                            headTilt = Math.sin(time * 0.02) * 0.05 * cryT;  // Slight shake
                            break;

                        case 'heal':
                            // Peaceful downward gaze
                            const healT = Math.sin(castT * Math.PI * 0.5);
                            headNod = 0.25 * healT;  // Look down at hands
                            headTilt = 0;  // Centered, peaceful
                            break;

                        case 'dash':
                            // Look forward intensely
                            headNod = -0.15 * castT;  // Chin down, focused
                            break;

                        case 'shieldWall':
                            // Alert, looking forward
                            const shieldT = Math.sin(castT * Math.PI * 0.7);
                            headNod = -0.1 * shieldT;  // Slightly down, braced
                            headTilt = 0;
                            break;

                        case 'execute':
                            // Focused on target
                            if (castT > 0.5) {
                                headTurn = 0.1 * ((castT - 0.5) / 0.5);  // Slight turn during prep
                            } else {
                                const strikeT = 1 - (castT / 0.5);
                                headNod = -0.2 * strikeT;  // Look at strike point
                                headTurn = 0.1 - strikeT * 0.15;  // Snap forward
                            }
                            break;

                        case 'berserk':
                            // Head back, aggressive, trembling
                            const rageT = castT;
                            const headShake = Math.sin(time * 0.05) * 0.04 * rageT;
                            headNod = -0.3 * rageT + headShake;  // Head back in rage
                            headTilt = headShake * 2;  // Violent shake
                            break;

                        case 'chronoEcho':
                            // Serene, eyes closed look
                            const echoT = Math.sin(castT * Math.PI * 0.8);
                            headNod = 0.1 * echoT;  // Slight bow
                            headTilt = Math.sin(time * 0.004) * 0.05 * echoT;  // Gentle sway
                            break;
                    }
                }

                bones.headGroup.rotation.x = headNod;
                bones.headGroup.rotation.z = headTilt;

                // Curious head tilt during idle / head turn during casting
                if (anim.state === 'idle') {
                    bones.headGroup.rotation.y = Math.sin(anim.idleVariation * 0.7) * 0.1;
                } else if (anim.castPhase > 0 && headTurn !== 0) {
                    bones.headGroup.rotation.y = headTurn;
                } else {
                    bones.headGroup.rotation.y *= 0.9; // Return to center
                }

                // --- ARMS (walking swing, idle sway, special animations) ---
                const walkSwingL = Math.sin(anim.walkCycle) * (anim.state === 'running' ? 0.8 : 0.4);
                const walkSwingR = Math.sin(anim.walkCycle + Math.PI) * (anim.state === 'running' ? 0.8 : 0.4);

                // Idle arm positions - slightly bent, natural
                let leftArmRotX = 0.1 + Math.sin(anim.breathPhase * 0.5) * 0.03;
                let rightArmRotX = 0.1 + Math.sin(anim.breathPhase * 0.5 + 0.5) * 0.03;
                let leftArmRotZ = 0;   // v6.81: Added for swimming
                let rightArmRotZ = 0;
                let leftElbowBend = -0.2;
                let rightElbowBend = -0.2;

                if (anim.state === 'walking' || anim.state === 'running') {
                    leftArmRotX = walkSwingL;
                    rightArmRotX = walkSwingR;
                    // Elbows bend more when arms swing back
                    leftElbowBend = -0.2 - Math.max(0, -walkSwingL) * 0.5;
                    rightElbowBend = -0.2 - Math.max(0, -walkSwingR) * 0.5;
                } else if (anim.state === 'swimming') {
                    // v6.81: Breaststroke swimming motion
                    // Arms sweep outward, pull back, recover forward
                    const swimCycle = anim.swimPhase;

                    // Phase 0-PI: Arms sweep out and pull back
                    // Phase PI-2PI: Arms recover forward
                    const strokePhase = (Math.sin(swimCycle) + 1) / 2;  // 0 to 1

                    // Arms extended forward -> sweep out to sides -> pull back
                    leftArmRotX = -1.2 + strokePhase * 0.8;   // Start extended, pull back
                    rightArmRotX = -1.2 + strokePhase * 0.8;
                    leftArmRotZ = 0.3 + Math.sin(swimCycle) * 0.6;   // Sweep outward
                    rightArmRotZ = -0.3 - Math.sin(swimCycle) * 0.6;

                    // Elbows bend during power phase
                    leftElbowBend = -0.4 - strokePhase * 0.6;
                    rightElbowBend = -0.4 - strokePhase * 0.6;
                }

                // Wave animation (right arm)
                if (anim.wavePhase > 0) {
                    const waveT = anim.wavePhase;
                    rightArmRotX = -0.3; // Arm raised
                    bones.rightArm.upperGroup.rotation.z = -1.2 * waveT; // Arm out to side and up
                    bones.rightArm.lowerGroup.rotation.x = -1.5 + Math.sin(time * 0.015) * 0.4 * waveT; // Waving motion
                } else {
                    bones.rightArm.upperGroup.rotation.z = 0;
                }

                // Attack animation (both arms thrust forward)
                if (anim.attackPhase > 0) {
                    const attackT = anim.attackPhase;
                    leftArmRotX = -1.2 * attackT;
                    rightArmRotX = -1.2 * attackT;
                    leftElbowBend = -0.8 * attackT;
                    rightElbowBend = -0.8 * attackT;
                }

                // v6.90: ABILITY CASTING ANIMATIONS
                // Each ability has unique, expressive animation
                if (anim.castPhase > 0 && anim.castType) {
                    const castT = anim.castPhase;
                    const chargeT = anim.chargePhase;
                    const intensity = anim.castIntensity;

                    switch (anim.castType) {
                        case 'powerStrike':
                            // Powerful overhead slam - wind up then strike down
                            // Phase 1 (castT > 0.6): Wind up - arms raised high
                            // Phase 2 (castT <= 0.6): Slam down
                            if (castT > 0.6) {
                                const windUp = (castT - 0.6) / 0.4;  // 0 to 1 during wind-up
                                leftArmRotX = -2.5 * windUp;  // Arms raised behind
                                rightArmRotX = -2.5 * windUp;
                                leftElbowBend = -0.3 * windUp;
                                rightElbowBend = -0.3 * windUp;
                                leanForward = -0.15 * windUp;  // Lean back during wind-up
                            } else {
                                const slam = 1 - (castT / 0.6);  // 0 to 1 during slam
                                leftArmRotX = -2.5 + slam * 4.0;  // Slam forward and down
                                rightArmRotX = -2.5 + slam * 4.0;
                                leftElbowBend = -0.3 - slam * 0.8;
                                rightElbowBend = -0.3 - slam * 0.8;
                                leanForward = -0.15 + slam * 0.4;  // Lean forward on impact
                                bodyBob = -slam * 0.1;  // Body drops with slam
                            }
                            break;

                        case 'whirlwind':
                            // Spinning attack - arms out horizontally, body spins
                            const spinIntensity = Math.min(castT * 2, 1);
                            leftArmRotX = -0.2;
                            rightArmRotX = -0.2;
                            leftArmRotZ = 1.4 * spinIntensity;  // Arms out to sides
                            rightArmRotZ = -1.4 * spinIntensity;
                            leftElbowBend = -0.1;
                            rightElbowBend = -0.1;
                            // Body rotation handled via spinPhase
                            if (bones.bodyCore) {
                                bones.bodyCore.rotation.y = anim.spinPhase;
                            }
                            bodyBob = Math.sin(anim.spinPhase * 4) * 0.05;  // Slight bob during spin
                            break;

                        case 'warcry':
                            // Chest thrust, arms back, head up - roar pose
                            const cryT = Math.sin(castT * Math.PI);  // Smooth in-out
                            leftArmRotX = 0.8 * cryT;  // Arms back
                            rightArmRotX = 0.8 * cryT;
                            leftArmRotZ = 0.4 * cryT;  // Arms slightly out
                            rightArmRotZ = -0.4 * cryT;
                            leftElbowBend = -0.6 * cryT;  // Elbows bent back
                            rightElbowBend = -0.6 * cryT;
                            leanForward = -0.25 * cryT;  // Chest thrust forward (lean back)
                            headNod = -0.4 * cryT;  // Head tilted up
                            bodyBob = 0.08 * cryT;  // Rise up slightly
                            break;

                        case 'heal':
                            // Hands to chest, serene healing pose
                            const healT = Math.sin(castT * Math.PI * 0.5);  // Smooth ease
                            leftArmRotX = -0.8 * healT;  // Arms toward chest
                            rightArmRotX = -0.8 * healT;
                            leftArmRotZ = -0.6 * healT;  // Arms cross toward center
                            rightArmRotZ = 0.6 * healT;
                            leftElbowBend = -1.2 * healT;  // Hands meet at chest
                            rightElbowBend = -1.2 * healT;
                            headNod = 0.15 * healT;  // Slight bow, peaceful
                            bodyBob = Math.sin(time * 0.008) * 0.03 * healT;  // Gentle float
                            break;

                        case 'dash':
                            // Forward thrust pose with arms back
                            const dashT = castT;
                            leftArmRotX = 1.0 * dashT;  // Arms trail behind
                            rightArmRotX = 1.0 * dashT;
                            leftElbowBend = -0.2 * dashT;
                            rightElbowBend = -0.2 * dashT;
                            leanForward = 0.5 * dashT;  // Lean into dash
                            break;

                        case 'shieldWall':
                            // Arms crossed in front, defensive stance
                            const shieldT = Math.sin(castT * Math.PI * 0.7);
                            leftArmRotX = -1.0 * shieldT;  // Arms forward
                            rightArmRotX = -1.0 * shieldT;
                            leftArmRotZ = -0.8 * shieldT;  // Cross toward center
                            rightArmRotZ = 0.8 * shieldT;
                            leftElbowBend = -1.0 * shieldT;  // Bent to form shield
                            rightElbowBend = -1.0 * shieldT;
                            leanForward = 0.1 * shieldT;  // Slight defensive lean
                            bodyBob = -0.05 * shieldT;  // Lower stance
                            break;

                        case 'execute':
                            // Deadly precision strike - wind up then thrust
                            if (castT > 0.5) {
                                const prepT = (castT - 0.5) / 0.5;
                                leftArmRotX = 0.3 * prepT;  // Left arm back for balance
                                rightArmRotX = 1.2 * prepT;  // Right arm pulled back
                                rightElbowBend = -1.4 * prepT;  // Coiled
                                bodyRoll = 0.2 * prepT;  // Twist to right
                            } else {
                                const strikeT = 1 - (castT / 0.5);
                                leftArmRotX = 0.3 - strikeT * 0.8;
                                rightArmRotX = 1.2 - strikeT * 2.8;  // Thrust forward
                                rightElbowBend = -1.4 + strikeT * 1.0;  // Extend
                                bodyRoll = 0.2 - strikeT * 0.4;  // Counter-twist
                                leanForward = strikeT * 0.3;
                            }
                            break;

                        case 'berserk':
                            // Power-up pose - arms tensed, vibrating with rage
                            const rageT = castT;
                            const rageVibration = Math.sin(time * 0.05) * 0.03 * rageT;
                            leftArmRotX = -0.5 * rageT + rageVibration;
                            rightArmRotX = -0.5 * rageT - rageVibration;
                            leftArmRotZ = 0.8 * rageT;  // Arms out, tensed
                            rightArmRotZ = -0.8 * rageT;
                            leftElbowBend = -1.5 * rageT;  // Fists clenched tight
                            rightElbowBend = -1.5 * rageT;
                            leanForward = -0.1 * rageT + rageVibration;  // Trembling
                            bodyBob = 0.1 * rageT + Math.abs(rageVibration) * 2;  // Rise with power
                            headNod = -0.2 * rageT;  // Head back in rage
                            break;

                        case 'chronoEcho':
                            // Mystical channeling pose - arms out to sides, palms up
                            const echoT = Math.sin(castT * Math.PI * 0.8);
                            const timeWave = Math.sin(time * 0.006) * 0.1 * echoT;
                            leftArmRotX = -0.3 * echoT;
                            rightArmRotX = -0.3 * echoT;
                            leftArmRotZ = 1.2 * echoT + timeWave;  // Arms to sides
                            rightArmRotZ = -1.2 * echoT - timeWave;
                            leftElbowBend = -0.4 * echoT;  // Slight bend, palms up
                            rightElbowBend = -0.4 * echoT;
                            headNod = 0.1 * echoT;  // Slight focus
                            bodyBob = Math.sin(time * 0.005) * 0.04 * echoT;  // Temporal float
                            // Subtle body rotation as if channeling
                            if (bones.bodyCore) {
                                bones.bodyCore.rotation.y = Math.sin(time * 0.003) * 0.1 * echoT;
                            }
                            break;
                    }
                }

                bones.leftArm.upperGroup.rotation.x = leftArmRotX;
                bones.rightArm.upperGroup.rotation.x = rightArmRotX;
                bones.leftArm.lowerGroup.rotation.x = leftElbowBend;
                bones.rightArm.lowerGroup.rotation.x = rightElbowBend;

                // v6.81: Apply arm Z rotation for swimming
                // v6.90: Also apply during ability casting
                if (anim.state === 'swimming' || anim.state === 'casting') {
                    bones.leftArm.upperGroup.rotation.z = leftArmRotZ;
                    bones.rightArm.upperGroup.rotation.z = rightArmRotZ;
                } else if (anim.wavePhase <= 0) {
                    // Reset Z rotation when not swimming, waving, or casting
                    bones.leftArm.upperGroup.rotation.z *= 0.9;
                    bones.rightArm.upperGroup.rotation.z *= 0.9;
                }

                // --- LEGS (walking, running, jumping) ---
                const legSwingL = Math.sin(anim.walkCycle) * (anim.state === 'running' ? 0.7 : 0.35);
                const legSwingR = Math.sin(anim.walkCycle + Math.PI) * (anim.state === 'running' ? 0.7 : 0.35);

                let leftLegRotX = 0;
                let rightLegRotX = 0;
                let leftKneeBend = 0;
                let rightKneeBend = 0;

                if (anim.state === 'walking' || anim.state === 'running') {
                    leftLegRotX = legSwingL;
                    rightLegRotX = legSwingR;
                    // Knees bend when leg swings back
                    leftKneeBend = Math.max(0, -legSwingL) * 0.8;
                    rightKneeBend = Math.max(0, -legSwingR) * 0.8;
                } else if (anim.state === 'swimming') {
                    // v6.81: Flutter kick for swimming
                    const kickSpeed = anim.swimPhase * 3;  // Faster flutter kick
                    leftLegRotX = Math.sin(kickSpeed) * 0.4;
                    rightLegRotX = Math.sin(kickSpeed + Math.PI) * 0.4;  // Alternating
                    // Slight knee bend during kick
                    leftKneeBend = 0.2 + Math.abs(Math.sin(kickSpeed)) * 0.3;
                    rightKneeBend = 0.2 + Math.abs(Math.sin(kickSpeed + Math.PI)) * 0.3;
                }

                // Jump animation
                if (anim.jumpPhase > 0) {
                    const jumpT = anim.jumpPhase;
                    // Crouch then extend
                    const crouchPhase = jumpT > 0.5 ? (1 - jumpT) * 2 : jumpT * 2;
                    leftLegRotX = -0.3 * crouchPhase;
                    rightLegRotX = -0.3 * crouchPhase;
                    leftKneeBend = 0.6 * crouchPhase;
                    rightKneeBend = 0.6 * crouchPhase;
                }

                // v6.91: Leg animations during ability casting
                if (anim.castPhase > 0 && anim.castType) {
                    const castT = anim.castPhase;

                    switch (anim.castType) {
                        case 'powerStrike':
                            // Wide power stance, knees bent for stability
                            if (castT > 0.6) {
                                // Wind-up: slight crouch
                                const prepT = (castT - 0.6) / 0.4;
                                leftKneeBend = 0.3 * prepT;
                                rightKneeBend = 0.3 * prepT;
                            } else {
                                // Slam: legs extend with force
                                const slamT = 1 - (castT / 0.6);
                                leftLegRotX = -0.15 * slamT;  // Lunge forward slightly
                                rightLegRotX = 0.1 * slamT;   // Back leg braces
                                leftKneeBend = 0.3 - slamT * 0.3;
                                rightKneeBend = 0.2 * slamT;
                            }
                            break;

                        case 'whirlwind':
                            // Legs slightly bent, spinning stance
                            const spinT = Math.min(castT * 2, 1);
                            leftKneeBend = 0.2 * spinT;
                            rightKneeBend = 0.2 * spinT;
                            // Legs spread slightly for balance
                            leftLegRotX = -0.1 * spinT;
                            rightLegRotX = -0.1 * spinT;
                            break;

                        case 'warcry':
                            // Planted wide stance, powerful roar pose
                            const cryT = Math.sin(castT * Math.PI);
                            leftLegRotX = 0.2 * cryT;   // Legs spread wide
                            rightLegRotX = -0.2 * cryT;
                            leftKneeBend = 0.15 * cryT;
                            rightKneeBend = 0.15 * cryT;
                            break;

                        case 'heal':
                            // Relaxed, slightly together stance
                            const healT = Math.sin(castT * Math.PI * 0.5);
                            leftKneeBend = 0.1 * healT;
                            rightKneeBend = 0.1 * healT;
                            break;

                        case 'dash':
                            // Running pose frozen mid-stride
                            const dashT = castT;
                            leftLegRotX = 0.5 * dashT;   // Front leg forward
                            rightLegRotX = -0.4 * dashT; // Back leg back
                            leftKneeBend = 0.3 * dashT;
                            rightKneeBend = 0.5 * dashT;
                            break;

                        case 'shieldWall':
                            // Defensive crouch, weight low
                            const shieldT = Math.sin(castT * Math.PI * 0.7);
                            leftLegRotX = 0.15 * shieldT;
                            rightLegRotX = -0.15 * shieldT;
                            leftKneeBend = 0.4 * shieldT;  // Deep crouch
                            rightKneeBend = 0.4 * shieldT;
                            break;

                        case 'execute':
                            // Lunge stance for precision strike
                            if (castT > 0.5) {
                                const prepT = (castT - 0.5) / 0.5;
                                rightLegRotX = 0.3 * prepT;  // Back leg coils
                                rightKneeBend = 0.4 * prepT;
                            } else {
                                const strikeT = 1 - (castT / 0.5);
                                leftLegRotX = 0.4 * strikeT;  // Lunge forward
                                rightLegRotX = -0.3 * strikeT;
                                leftKneeBend = 0.2 * strikeT;
                                rightKneeBend = 0.1;
                            }
                            break;

                        case 'berserk':
                            // Wide aggressive stance, trembling with power
                            const rageT = castT;
                            const legVibrate = Math.sin(time * 0.04) * 0.02 * rageT;
                            leftLegRotX = 0.25 * rageT + legVibrate;
                            rightLegRotX = -0.25 * rageT - legVibrate;
                            leftKneeBend = 0.3 * rageT;
                            rightKneeBend = 0.3 * rageT;
                            break;

                        case 'chronoEcho':
                            // Floating/hovering pose - legs slightly raised
                            const echoT = Math.sin(castT * Math.PI * 0.8);
                            const floatWave = Math.sin(time * 0.005) * 0.1 * echoT;
                            leftLegRotX = -0.2 * echoT + floatWave;
                            rightLegRotX = -0.15 * echoT - floatWave;
                            leftKneeBend = 0.3 * echoT;
                            rightKneeBend = 0.25 * echoT;
                            break;
                    }
                }

                bones.leftLeg.upperGroup.rotation.x = leftLegRotX;
                bones.rightLeg.upperGroup.rotation.x = rightLegRotX;
                bones.leftLeg.lowerGroup.rotation.x = leftKneeBend;
                bones.rightLeg.lowerGroup.rotation.x = rightKneeBend;

                // === VISUAL EFFECTS ===

                // Antenna sway - v6.91: Enhanced with casting reactions
                if (p.userData.antenna) {
                    let sway = Math.sin(anim.breathPhase * 2) * 0.1;
                    let antennaBend = 0;  // Forward/back bend

                    if (anim.state === 'running') {
                        sway += Math.sin(anim.walkCycle * 2) * 0.15;
                        antennaBend = -0.2;  // Antenna trails back when running
                    }

                    // v6.91: Dramatic antenna reactions during ability casting
                    if (anim.castPhase > 0 && anim.castType) {
                        const castT = anim.castPhase;
                        const energyPulse = Math.sin(time * 0.015) * castT;

                        switch (anim.castType) {
                            case 'powerStrike':
                                // Antenna whips back then forward with strike
                                if (castT > 0.6) {
                                    antennaBend = -0.4 * ((castT - 0.6) / 0.4);  // Pull back
                                } else {
                                    const slamT = 1 - (castT / 0.6);
                                    antennaBend = -0.4 + slamT * 0.8;  // Whip forward
                                    sway += energyPulse * 0.3;
                                }
                                break;

                            case 'whirlwind':
                                // Antenna spins with centrifugal force
                                sway = Math.sin(anim.spinPhase + Math.PI/4) * 0.5 * Math.min(castT * 2, 1);
                                antennaBend = 0.3 * Math.min(castT * 2, 1);  // Bends outward
                                break;

                            case 'warcry':
                                // Antenna vibrates with roar
                                const cryT = Math.sin(castT * Math.PI);
                                sway = Math.sin(time * 0.03) * 0.25 * cryT;  // Rapid vibration
                                antennaBend = -0.3 * cryT;  // Bends back with head
                                break;

                            case 'heal':
                                // Gentle, glowing sway
                                const healT = Math.sin(castT * Math.PI * 0.5);
                                sway = Math.sin(time * 0.005) * 0.15 * healT;  // Slow peaceful sway
                                antennaBend = 0.1 * healT;  // Slight forward tilt
                                break;

                            case 'dash':
                                // Antenna streams back
                                antennaBend = -0.5 * castT;  // Strong backward bend
                                sway = energyPulse * 0.2;
                                break;

                            case 'shieldWall':
                                // Antenna alert, rigid
                                sway = energyPulse * 0.1;
                                antennaBend = 0;  // Straight up, alert
                                break;

                            case 'execute':
                                // Antenna tracks with precision strike
                                if (castT > 0.5) {
                                    antennaBend = -0.2 * ((castT - 0.5) / 0.5);
                                    sway = 0.1 * ((castT - 0.5) / 0.5);  // Slight lean right
                                } else {
                                    const strikeT = 1 - (castT / 0.5);
                                    antennaBend = -0.2 + strikeT * 0.5;  // Snap forward
                                    sway = 0.1 - strikeT * 0.2;
                                }
                                break;

                            case 'berserk':
                                // Antenna goes wild with rage
                                const rageT = castT;
                                sway = Math.sin(time * 0.04) * 0.4 * rageT;  // Violent shaking
                                antennaBend = Math.sin(time * 0.035) * 0.2 * rageT;
                                break;

                            case 'chronoEcho':
                                // Antenna waves in temporal distortion
                                const echoT = Math.sin(castT * Math.PI * 0.8);
                                sway = Math.sin(time * 0.008 + Math.cos(time * 0.003)) * 0.2 * echoT;
                                antennaBend = Math.sin(time * 0.006) * 0.15 * echoT;
                                break;
                        }
                    }

                    p.userData.antenna.rotation.z = sway;
                    p.userData.antenna.rotation.x = antennaBend;
                }

                // Antenna light pulse
                // v6.91: Enhanced with persistent buff effects
                if (p.userData.antennaLight) {
                    const antPulse = (Math.sin(time * 0.003) + 1) / 2;
                    let r = antPulse * 0.2, g = 0.5 + antPulse * 0.5, b = antPulse * 0.4;
                    if (anim.state === 'running') { r = 0.8; g = 0.6; b = 0.1; } // Orange when running
                    if (anim.state === 'swimming') { r = 0.1; g = 0.5 + antPulse * 0.3; b = 0.9; } // v6.81: Blue when swimming
                    if (anim.damageFlash > 0) { r = 1; g = 0.1; b = 0.1; } // Red when damaged

                    // v6.91: Persistent buff antenna colors (lower priority than casting)
                    if (hasActiveBuff && !(anim.castGlow > 0 && anim.castType)) {
                        const buffPulse = (Math.sin(time * 0.005) + 1) / 2;
                        if (berserkActive) {
                            // Berserk: Angry red/orange rapid pulse
                            const rage = (Math.sin(time * 0.02) + 1) / 2;
                            r = 1; g = 0.2 + rage * 0.2; b = 0;
                        } else if (warcryActive) {
                            // Warcry: Golden empowered glow
                            r = 1; g = 0.6 + buffPulse * 0.2; b = 0.1;
                        } else if (shieldActive) {
                            // Shield: Protective blue
                            r = 0.2; g = 0.5 + buffPulse * 0.2; b = 1;
                        } else if (chronoActive) {
                            // Chrono: Temporal purple shimmer
                            const timeShift = Math.sin(time * 0.003 + Math.cos(time * 0.002));
                            r = 0.5 + timeShift * 0.2; g = 0.2; b = 1;
                        }
                    }

                    // v6.90: Ability casting colors (highest priority)
                    if (anim.castGlow > 0 && anim.castType) {
                        const castPulse = (Math.sin(time * 0.01) + 1) / 2;  // Fast pulse during cast
                        const glow = anim.castGlow * (0.8 + castPulse * 0.2);
                        switch (anim.castType) {
                            case 'powerStrike': r = 1 * glow; g = 0.3 * glow; b = 0; break;  // Fire orange
                            case 'whirlwind': r = 0; g = 1 * glow; b = 1 * glow; break;  // Cyan
                            case 'warcry': r = 1 * glow; g = 0.5 * glow; b = 0; break;  // Orange-yellow
                            case 'heal': r = 0.2 * glow; g = 1 * glow; b = 0.5 * glow; break;  // Green
                            case 'dash': r = 0.5 * glow; g = 1 * glow; b = 1 * glow; break;  // Light cyan
                            case 'shieldWall': r = 0.3 * glow; g = 0.5 * glow; b = 1 * glow; break;  // Blue
                            case 'execute': r = 1 * glow; g = 0; b = 0.3 * glow; break;  // Dark red
                            case 'berserk': r = 1 * glow; g = 0.2 * glow; b = 0; break;  // Blood orange
                            case 'chronoEcho': r = 0.5 * glow; g = 0.3 * glow; b = 1 * glow; break;  // Purple
                        }
                    }
                    p.userData.antennaLight.material.color.setRGB(r, g, b);
                }

                // Heart/status light based on health
                if (p.userData.statusStrip) {
                    const hpPercent = (gameData.player?.hp || 100) / (gameData.player?.maxHp || 100);
                    const pulse = (Math.sin(time * 0.004) + 1) / 2;
                    let r, g, b;
                    if (anim.damageFlash > 0) {
                        r = 1; g = 0; b = 0; // Flash red on damage
                    } else if (anim.castGlow > 0 && anim.castType) {
                        // v6.90: Status light matches ability color during cast
                        const castPulse = (Math.sin(time * 0.008) + 1) / 2;
                        const glow = anim.castGlow * (0.7 + castPulse * 0.3);
                        switch (anim.castType) {
                            case 'powerStrike': r = 1 * glow; g = 0.4 * glow; b = 0.1 * glow; break;
                            case 'whirlwind': r = 0.1 * glow; g = 0.9 * glow; b = 1 * glow; break;
                            case 'warcry': r = 1 * glow; g = 0.6 * glow; b = 0.1 * glow; break;
                            case 'heal': r = 0.1 * glow; g = 1 * glow; b = 0.4 * glow; break;
                            case 'dash': r = 0.4 * glow; g = 0.9 * glow; b = 1 * glow; break;
                            case 'shieldWall': r = 0.2 * glow; g = 0.5 * glow; b = 1 * glow; break;
                            case 'execute': r = 0.9 * glow; g = 0.1 * glow; b = 0.2 * glow; break;
                            case 'berserk': r = 1 * glow; g = 0.3 * glow; b = 0.1 * glow; break;
                            case 'chronoEcho': r = 0.6 * glow; g = 0.2 * glow; b = 1 * glow; break;
                            default: r = 0; g = 0.8; b = 0.5;
                        }
                    } else if (hpPercent > 0.5) {
                        r = 0; g = 0.7 + pulse * 0.3; b = 0.5;
                    } else if (hpPercent > 0.25) {
                        r = 1; g = 0.5 + pulse * 0.2; b = 0;
                    } else {
                        r = 0.8 + pulse * 0.2; g = 0; b = 0;
                    }
                    p.userData.statusStrip.material.color.setRGB(r, g, b);
                }

                // Eye effects
                let eyePulse = 0.7 + Math.sin(time * 0.003) * 0.3;
                const blinkScale = anim.isBlinking ? 0.1 : 1;

                // v6.90: Enhanced eye glow during ability casting
                // v6.91: Also handles persistent buff effects
                const eyeMesh = p.userData.robotEye;
                let eyeR = 0, eyeG = 0.87, eyeB = 1;  // Default cyan
                let hasEyeEffect = false;

                if (anim.castGlow > 0 && anim.castType) {
                    // Active casting takes priority
                    const castIntensity = anim.castGlow * 1.5;
                    const castFlicker = Math.sin(time * 0.012) * 0.2;
                    eyePulse = 1.0 + castIntensity + castFlicker;
                    hasEyeEffect = true;

                    switch (anim.castType) {
                        case 'powerStrike': eyeR = 1; eyeG = 0.4; eyeB = 0; break;
                        case 'whirlwind': eyeR = 0; eyeG = 1; eyeB = 1; break;
                        case 'warcry': eyeR = 1; eyeG = 0.7; eyeB = 0; break;
                        case 'heal': eyeR = 0; eyeG = 1; eyeB = 0.5; break;
                        case 'dash': eyeR = 0.5; eyeG = 1; eyeB = 1; break;
                        case 'shieldWall': eyeR = 0.3; eyeG = 0.6; eyeB = 1; break;
                        case 'execute': eyeR = 1; eyeG = 0; eyeB = 0.2; break;
                        case 'berserk': eyeR = 1; eyeG = 0.2; eyeB = 0; break;
                        case 'chronoEcho': eyeR = 0.7; eyeG = 0.3; eyeB = 1; break;
                    }
                } else if (hasActiveBuff) {
                    // v6.91: Persistent buff visual effects on eyes
                    hasEyeEffect = true;
                    const buffPulse = (Math.sin(time * 0.006) + 1) / 2;

                    if (berserkActive) {
                        // Berserk: Intense red pulsing, aggressive
                        eyeR = 1;
                        eyeG = 0.15 + buffPulse * 0.15;
                        eyeB = 0;
                        eyePulse = 1.2 + Math.sin(time * 0.015) * 0.4;  // Fast intense pulse
                    } else if (warcryActive) {
                        // Warcry: Golden/orange empowered glow
                        eyeR = 1;
                        eyeG = 0.6 + buffPulse * 0.2;
                        eyeB = 0.1;
                        eyePulse = 1.0 + buffPulse * 0.3;
                    } else if (shieldActive) {
                        // Shield Wall: Calm blue protective glow
                        eyeR = 0.2 + buffPulse * 0.1;
                        eyeG = 0.5 + buffPulse * 0.2;
                        eyeB = 1;
                        eyePulse = 0.9 + buffPulse * 0.2;
                    } else if (chronoActive) {
                        // Chrono Echo: Ethereal purple temporal glow
                        const timeWarp = Math.sin(time * 0.004 + Math.cos(time * 0.002));
                        eyeR = 0.6 + timeWarp * 0.2;
                        eyeG = 0.2 + timeWarp * 0.1;
                        eyeB = 1;
                        eyePulse = 0.8 + Math.abs(timeWarp) * 0.4;
                    }
                }

                // Apply eye color changes
                if (eyeMesh && eyeMesh.material && eyeMesh.material.color && eyeMesh.material.emissive) {
                    if (hasEyeEffect) {
                        const blend = anim.castGlow > 0 ? Math.min(anim.castGlow, 1) : 0.7;
                        eyeMesh.material.color.setRGB(
                            eyeR * blend + 0 * (1 - blend),
                            eyeG * blend + 0.87 * (1 - blend),
                            eyeB * blend + 1 * (1 - blend)
                        );
                        eyeMesh.material.emissive.setRGB(eyeR, eyeG, eyeB);
                    } else {
                        // Reset to default cyan
                        eyeMesh.material.color.setRGB(0, 0.87, 1);
                        eyeMesh.material.emissive.setRGB(0, 0.87, 1);
                    }
                }

                if (p.userData.robotEye) {
                    p.userData.robotEye.material.emissiveIntensity = eyePulse;
                    p.userData.robotEye.scale.y = blinkScale;
                }
                if (p.userData.leftEye) {
                    p.userData.leftEye.material.emissiveIntensity = eyePulse;
                    p.userData.leftEye.scale.y = blinkScale;
                }

                // Pupils follow slight movement (curious robot look)
                if (p.userData.leftPupil && p.userData.rightPupil) {
                    const pupilOffset = Math.sin(anim.idleVariation * 0.3) * 0.02;
                    p.userData.leftPupil.position.x = -0.15 + pupilOffset;
                    p.userData.rightPupil.position.x = 0.15 + pupilOffset;
                    p.userData.leftPupil.scale.y = blinkScale;
                    p.userData.rightPupil.scale.y = blinkScale;
                }

                // Eyebrow expressions
                if (p.userData.leftBrow && p.userData.rightBrow) {
                    let browAngle = 0.2; // Neutral friendly
                    if (anim.damageFlash > 0) browAngle = -0.3; // Concerned
                    if (anim.state === 'running') browAngle = 0.4; // Determined
                    // v6.90: Eyebrow expressions during ability casting
                    if (anim.castGlow > 0 && anim.castType) {
                        switch (anim.castType) {
                            case 'powerStrike': browAngle = 0.6; break;  // Aggressive
                            case 'whirlwind': browAngle = 0.5; break;  // Focused intensity
                            case 'warcry': browAngle = 0.8; break;  // Battle fury
                            case 'heal': browAngle = 0.1; break;  // Serene
                            case 'dash': browAngle = 0.4; break;  // Determined
                            case 'shieldWall': browAngle = 0.3; break;  // Alert
                            case 'execute': browAngle = 0.7; break;  // Deadly focus
                            case 'berserk': browAngle = 0.9; break;  // Maximum aggression
                            case 'chronoEcho': browAngle = 0.0; break;  // Mystical calm
                        }
                    }
                    p.userData.leftBrow.rotation.z = browAngle;
                    p.userData.rightBrow.rotation.z = -browAngle;
                }
            }

            // v4.0: Screen shake effect
            updateScreenShake();

            // v6.32: Camera punch effect (8-agent consensus)
            updateCameraPunch();

            // v4.0: Update particles
            if (particles) particles.update(dt);

            // v6.5.2: Update observer beacon (follows agent, animates)
            updateObserverBeacon();

            // v4.4: Update environmental particles
            if (envParticles && worldState.player) {
                envParticles.update(dt, worldState.player.position);
            }

            // v4.5: Update dodge movement
            updateDodge(dt);

            // v6.9: Update style meter decay (Agent consensus - Combat Depth)
            if (typeof decayStyleMeter === 'function') {
                decayStyleMeter(dt);
            }

            // v6.42: Update Chrono-Echo ghost animations
            if (typeof chronoEchoSystem !== 'undefined') {
                chronoEchoSystem.update(dt);
            }

            // v6.65: Update DOTA-style creep waves
            if (typeof updateCreepWaves === 'function') {
                updateCreepWaves(dt, time);
            }

            // v6.66: Update RCT-style base building system
            if (typeof updateBaseBuildingSystem === 'function') {
                updateBaseBuildingSystem(time);
            }

            // v6.67: Update lane support & fortification system
            if (typeof updateLaneSupportSystem === 'function') {
                updateLaneSupportSystem(time);
            }

            // v6.68: Update Dota 2-style player HP/Mana bars (3D version)
            if (typeof updatePlayerDotaBars === 'function') {
                updatePlayerDotaBars(dt, time);
            }

            // v6.69: Update 2D UI HP/Mana bars (above ability bar)
            if (typeof updateDotaBarsUI === 'function') {
                updateDotaBarsUI();
            }

            // v6.68: Update versus match state (throne animations, win condition checking)
            if (typeof updateVersusMatch === 'function') {
                updateVersusMatch(time);
            }

            // Mob AI with aggro (using CONFIG constants)
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;

                // v6.9: Update knockback physics (Agent consensus - Physics Fun)
                if (typeof updateMobKnockback === 'function') {
                    updateMobKnockback(mob, 0.016); // ~60fps delta
                }

                // v4.6: Update status effects
                updateMobStatusEffects(mob, time);

                // Check if mob died from status effect DoT
                if (mob.userData.hp <= 0) {
                    // Handle death - same as combat death but simplified
                    const xpReward = mob.userData.xpReward || 100;
                    addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;
                    worldMobKillCount++;
                    checkBossSpawn();
                    // v4.9: Track creature in codex
                    trackCreatureKill(mob.userData.name?.toLowerCase() || 'unknown');
                    spawnFloater(mob.position, `KILLED! +${xpReward}XP`, '#f00');
                    if (particles) particles.emit(mob.position, 20, ENEMY_TYPES[mob.userData.name]?.color || 0x44ff44);

                    // v6.80: Momentum boost on kill (8-Agent Consensus)
                    updateMomentum(15);
                    showImpactBorder('damage-dealt');

                    // v6.52: Spawn quantum wreckage on death (30% chance)
                    if (typeof quantumWreckage !== 'undefined' && Math.random() < 0.3) {
                        quantumWreckage.spawnWreckage(mob.position, mob.userData.name, mob.userData);
                    }

                    scene.remove(mob);
                    worldState.mobs = worldState.mobs.filter(x => x !== mob);
                    return;
                }

                // v4.6: Handle stun state from parry
                if (mob.userData.stunned) {
                    if (time < mob.userData.stunEnd) {
                        // Still stunned - skip AI behavior, keep yellow glow
                        mob.userData.telegraphing = false;
                        // Update HP bar to face camera
                        if (mob.userData.hpBar) mob.userData.hpBar.lookAt(camera.position);
                        return;
                    } else {
                        // Stun ended
                        mob.userData.stunned = false;
                        // Restore original emissive
                        const originalEmissive = ENEMY_TYPES[mob.userData.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }

                // v6.84: Use squared distance to avoid sqrt in hot path (N mobs * 60 fps)
                const dx = mob.position.x - p.position.x;
                const dz = mob.position.z - p.position.z;
                const distToPlayerSq = dx * dx + dz * dz;
                // v6.83: Calculate actual distance for features that need it (hypnosis, chilling aura)
                const distToPlayer = Math.sqrt(distToPlayerSq);

                // Aggro range (using squared distances)
                if (distToPlayerSq < CONFIG.MOB_AGGRO_RANGE_SQ && distToPlayerSq > CONFIG.MOB_ATTACK_RANGE_SQ) {
                    mob.userData.targetPos.copy(p.position);
                    mob.userData.nextMove = time + 500;
                } else if(time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob (using temp vector) - v4.2: Use enemy-specific speed
                // v4.6: Apply status effect speed modifier
                _tempVec3B.subVectors(mob.userData.targetPos, mob.position);
                _tempVec3B.y = 0;
                if(_tempVec3B.length() > 0.1) {
                    _tempVec3B.normalize();
                    const mobSpeed = (mob.userData.speed || 4) * (mob.userData.speedMultiplier || 1);
                    mob.position.add(_tempVec3B.multiplyScalar(mobSpeed * dt));
                }
                snapToGround(mob);

                // v6.64: Add subtle rotation to mobs (makes them feel more alive)
                mob.rotation.y += dt * 0.5;

                // v4.5: Attack telegraph system with windup
                // v6.84: Use squared attack range for consistency with squared distance
                const attackRange = mob.userData.attackRange || CONFIG.MOB_ATTACK_RANGE;
                const attackRangeSq = attackRange * attackRange;
                const attackWindup = mob.userData.attackWindup || 600;

                // Start telegraph when in range and ready to attack
                if (distToPlayerSq < attackRangeSq && time > mob.userData.nextAttack && !mob.userData.telegraphing) {
                    mob.userData.telegraphing = true;
                    mob.userData.telegraphStart = time;
                    mob.userData.telegraphEnd = time + attackWindup;
                    // Show telegraph visual - mob glows red
                    if (mob.material) {
                        mob.userData.originalEmissive = mob.material.emissive.getHex();
                        mob.material.emissive.setHex(0xff0000);
                    }
                    AudioSystem.telegraph();

                    // v6.33: Future Ghost Telegraph (8-agent consensus)
                    // Check if this attack would be lethal and warn the player
                    if (typeof futureGhostTelegraph !== 'undefined') {
                        const incomingDamage = Math.floor(mob.userData.damage * (mob.userData.damageMultiplier || 1));
                        futureGhostTelegraph.checkAttack(incomingDamage, mob.position);
                    }

                    // v6.35: Enemy Premonition Ghost (8-agent consensus)
                    // Show ghost of WHERE the enemy WILL strike
                    if (typeof enemyPremonition !== 'undefined') {
                        enemyPremonition.showPremonition(mob, 'melee');
                    }
                }

                // Update telegraph progress
                if (mob.userData.telegraphing) {
                    const telegraphProgress = (time - mob.userData.telegraphStart) / attackWindup;
                    // Pulse effect during windup
                    const pulseScale = 1 + Math.sin(telegraphProgress * Math.PI * 4) * 0.15;
                    mob.scale.setScalar(pulseScale);

                    // Execute attack when windup completes
                    if (time >= mob.userData.telegraphEnd) {
                        mob.userData.telegraphing = false;
                        mob.scale.setScalar(1);
                        // Restore original emissive
                        if (mob.material && mob.userData.originalEmissive !== undefined) {
                            mob.material.emissive.setHex(mob.userData.originalEmissive);
                        }
                        // Only deal damage if still in range
                        // v6.84: Use squared distance for range check
                        if (distToPlayerSq < attackRangeSq * 1.44) { // 1.2^2 = 1.44
                            // v4.6: Apply damage multiplier from status effects
                            const actualDamage = Math.floor(mob.userData.damage * (mob.userData.damageMultiplier || 1));
                            // v6.7: Pass mob position for directional damage indicator
                            damagePlayer(actualDamage, mob.position);
                            spawnFloater(p.position, `-${actualDamage} HP`, '#ff4444');

                            // v4.7: Vampiric elite heals on hit
                            if (mob.userData.isElite && mob.userData.eliteData?.lifesteal) {
                                const healAmount = Math.floor(actualDamage * mob.userData.eliteData.lifesteal);
                                mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + healAmount);
                                spawnFloater(mob.position, ` +${healAmount}`, '#ff00ff');
                                // Update health bar
                                if (mob.userData.hpBar) {
                                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                                    mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                                }
                            }
                        }
                        mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                    }
                }

                // v4.7: Elite affix behaviors
                if (mob.userData.isElite && mob.userData.eliteData) {
                    const eliteData = mob.userData.eliteData;

                    // Regenerating: heal over time
                    if (eliteData.regenRate && mob.userData.hp < mob.userData.maxHp) {
                        const regenAmount = mob.userData.maxHp * eliteData.regenRate * dt;
                        mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + regenAmount);
                        // Update health bar
                        if (mob.userData.hpBar) {
                            const hpPercent = mob.userData.hp / mob.userData.maxHp;
                            mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                        }
                    }

                    // Teleporter: blink towards player when in aggro range
                    if (eliteData.canTeleport && distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > 5) {
                        if (!mob.userData.lastTeleport || time - mob.userData.lastTeleport > 4000) {
                            // Teleport towards player
                            const teleportDist = Math.min(10, distToPlayer - 3);
                            const dir = _tempVec3B.subVectors(p.position, mob.position).normalize();
                            mob.position.add(dir.multiplyScalar(teleportDist));
                            mob.userData.lastTeleport = time;
                            spawnFloater(mob.position, '', '#9900ff');
                            if (particles) particles.emit(mob.position, 15, 0x9900ff, { spread: 3, lifetime: 500 });
                        }
                    }

                    // Chilling Aura: slow player when nearby
                    if (eliteData.chillingAura && distToPlayer < 6) {
                        if (!playerState.chilled || time > playerState.chilledEnd) {
                            playerState.chilled = true;
                            playerState.chilledEnd = time + 500;
                            playerState.moveSpeedMult = 0.5;
                        }
                    }

                    // Animate elite aura ring
                    if (mob.userData.auraRing) {
                        mob.userData.auraRing.rotation.z += dt * 2;
                        const auraScale = 1 + Math.sin(time * 0.005) * 0.2;
                        mob.userData.auraRing.scale.set(auraScale, auraScale, 1);
                    }
                }

                // v5.12: Hypnotist special behavior - hypnotize player when in range
                const enemyType = ENEMY_TYPES[mob.userData.name];
                if (enemyType?.isHypnotist && !HYPNOSIS_STATE.active) {
                    const hypnosisRange = enemyType.hypnosisRange || 12;
                    const hypnosisCooldown = enemyType.hypnosisCooldown || 15000;

                    if (distToPlayer < hypnosisRange && distToPlayer > 3) {
                        // Check cooldown
                        if (!mob.userData.lastHypnosis || time - mob.userData.lastHypnosis > hypnosisCooldown) {
                            mob.userData.lastHypnosis = time;

                            // Start hypnosis!
                            const duration = enemyType.hypnosisDuration || 8000;
                            startHypnosis(mob, duration);

                            // Visual effect on hypnotist
                            spawnFloater(mob.position, ' HYPNOSIS', '#ff00ff');
                            if (particles) particles.emit(mob.position, 30, 0xff00ff, { spread: 5, lifetime: 1000 });

                            // Pulsing eye effect on the mob itself
                            mob.material.emissive.setHex(0xff00ff);
                            mob.userData.hypnotizing = true;
                        }
                    }
                }

                // Animate hypnotist while hypnotizing
                if (mob.userData.hypnotizing && HYPNOSIS_STATE.active && HYPNOSIS_STATE.hypnotistMob === mob) {
                    // Pulsing glow
                    const pulse = 0.3 + Math.sin(time * 0.01) * 0.2;
                    mob.material.emissiveIntensity = pulse;

                    // Slowly rotate
                    mob.rotation.y += dt * 0.5;
                } else if (mob.userData.hypnotizing && !HYPNOSIS_STATE.active) {
                    mob.userData.hypnotizing = false;
                    mob.material.emissive.setHex(enemyType?.emissive || 0x660066);
                    mob.material.emissiveIntensity = 0.2;
                }

                // v5.12: Animate hypnotist eye - pupil tracks player
                if (mob.userData.isHypnotist && mob.userData.pupil) {
                    // Make the eye look toward the player
                    const lookDir = _tempVec3A.subVectors(p.position, mob.position).normalize();

                    // Calculate pupil offset based on look direction (limited movement)
                    const maxOffset = 0.2;
                    mob.userData.pupil.position.x = lookDir.x * maxOffset;
                    mob.userData.pupil.position.y = Math.max(-maxOffset, lookDir.y * maxOffset + 0.1);

                    // Make the whole mob face the player
                    mob.lookAt(p.position.x, mob.position.y, p.position.z);

                    // Subtle creepy floating animation
                    mob.position.y += Math.sin(time * 0.003 + mob.id) * 0.002;
                }

                // Update HP bar rotation to face camera
                if (mob.userData.hpBar) {
                    mob.userData.hpBar.lookAt(camera.position);
                }
            });

            // Animate fishing spots
            worldState.fishingSpots.forEach(spot => {
                if (spot.userData.ripple) {
                    const scale = 1 + Math.sin(time * 0.003) * 0.2;
                    spot.userData.ripple.scale.set(scale, scale, 1);
                }
            });

            // Update minimap (v6.6: Throttled to 10 FPS for performance - Agent 1 consensus)
            if (time - lastMinimapUpdate > 100) {
                updateMinimap();
                lastMinimapUpdate = time;
            }

            // v4.8: Update ability cooldowns
            updateAbilityUI();

            // v6.7: Check auto-potion (Agent consensus - QoL)
            if (typeof checkAutoPotion === 'function') {
                checkAutoPotion();
            }

            // v5.0: Update pet companion
            updatePet(dt, time);
            updatePetRegen(time);

            // v5.6: Update Copilot Companion
            updateCopilotCompanion(dt, time);

            // v5.12: Update hypnosis effects
            updateHypnosis(dt);

            // v5.13: Update ship defense system
            updateShipDefense(dt, time);

            // v6.68: Update living economy (price fluctuations, NPC trading, market events)
            if (typeof updateEconomy === 'function') {
                updateEconomy(time);
            }

            // v5.9: Update Copilot task progress
            updateCopilotTask(dt);

            // v5.10: Update Agent Fleet meshes
            updateAgentFleetMeshes(dt);

            // v5.18: Update robot energy and structures
            updateRobotEnergy(dt);
            updateStructures(dt);

            // v6.11: Animate construction site beacons
            if (typeof updateConstructionSiteBeacons === 'function') {
                updateConstructionSiteBeacons(dt);
            }

            // v6.13: Update wave momentum system (DOTA-style creep pushing)
            if (typeof updateWaveSystem === 'function') {
                updateWaveSystem(dt);
            }

            // v6.13: Update Fus Ro Dah visual effects
            if (typeof updateFusRoDahEffects === 'function') {
                updateFusRoDahEffects(dt);
            }

            // v6.16: Update fog clearing effects
            if (typeof updateFogClearEffects === 'function') {
                updateFogClearEffects(dt);
            }

            // v5.18: Stream to spectators
            sendGameStateToSpectators();

            // ENHANCED MULTIPLAYER: Sync state with connected players
            updateMultiplayerSync();
            animateRemotePlayers(time);

            // v6.1: Viewer's robot always looks at host
            if (multiplayerState.enabled && !multiplayerState.isHost) {
                const hostAvatar = multiplayerState.remotePlayers.get(multiplayerState.hostId);
                if (hostAvatar && p) {
                    p.lookAt(hostAvatar.position.x, p.position.y, hostAvatar.position.z);
                }
            }

            // v5.16: Check for agent troubleshooting interactions
            checkAgentTroubleshooting();

            // v5.16.3: Update body cams more frequently for streaming effect (every ~100ms)
            // Similar to AI Companion Hub's broadcastCameraUpdate pattern
            if (Math.floor(time * 10) !== Math.floor((time - dt) * 10)) {
                updateAllAgentBodyCams();
            }

            // v5.0: Update weather system
            updateWeather(dt, time);

            // v6.1: Update critical systems (fires, disease, earthquakes, avalanches)
            updateCriticalSystems(dt, time);

            // v5.4: Update world events
            updateWorldEvent(dt, time);

            // v5.4: Update cosmetic effects
            updateCosmeticEffects(time);

            // v6.38: Update Temporal Echo System - markers animation & discovery checks
            if (typeof temporalEchoSystem !== 'undefined') {
                temporalEchoSystem.updateMarkers(time);
                // Check discovery every ~500ms to save performance
                if (time % 500 < 20) {
                    temporalEchoSystem.checkDiscovery();
                }
            }

            // v6.34: Animate dropped items (floating effect)
            updateDroppedItemAnimations(time);

            // v6.52: TEMPORAL MOMENTUM REVERSAL - Record position and update rewind
            if (p && typeof temporalRewind !== 'undefined') {
                if (temporalRewind.isRewinding) {
                    temporalRewind.updateRewind(p, dt);
                } else {
                    temporalRewind.recordPosition(p.position, p.rotation.y, time);
                }
                temporalRewind.updateCooldown(dt);
            }

            // v6.52: QUANTUM WRECKAGE - Update evolution
            if (typeof quantumWreckage !== 'undefined') {
                quantumWreckage.updateEvolution(time);

                // Check for nearby harvestable wreckage and auto-harvest on interact
                if (p && worldState.interactTarget === null) {
                    const nearbyWreck = quantumWreckage.checkNearbyHarvestable(p.position);
                    if (nearbyWreck) {
                        // Show hint
                        const dist = Math.sqrt(Math.pow(p.position.x - nearbyWreck.x, 2) + Math.pow(p.position.z - nearbyWreck.z, 2));
                        if (dist < 2) {
                            // Auto-harvest when very close
                            quantumWreckage.harvestWreckage(nearbyWreck.id);
                        }
                    }
                }
            }

            // v6.52: LEGACY CONSTELLATION - Check for new unlocks periodically
            if (typeof legacyConstellations !== 'undefined' && Math.floor(time) % 5 === 0) {
                legacyConstellations.checkUnlocks();
            }
        }

        // v6.62: Get terrain height at world coordinates (was missing - referenced but never defined!)
        function getTerrainHeight(worldX, worldZ) {
            if (!worldState.terrain) return 0;

            const gx = Math.round(worldX / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
            const gz = Math.round(worldZ / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;

            if (gx >= 0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx]?.[gz];
                if (y !== undefined && y > -50) {
                    return y;
                }
            }
            return 0;
        }

        // v6.68: Bridge constants for player ground snapping
        const PLAYER_BRIDGE_HEIGHT = 3.5;  // Bridge deck height (matches lane visuals)
        const PLAYER_WATER_LEVEL = 0.5;

        // v6.81: Swimming water surface level
        const SWIM_WATER_SURFACE = 1.0;    // Y level of water surface
        const SWIM_SINK_DEPTH = 0.8;       // How deep the player sinks when swimming
        const SWIM_BOB_AMPLITUDE = 0.15;   // How much the player bobs up and down

        function snapToGround(obj) {
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;

            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx]?.[gz];

                // v6.81: Handle water/lava tiles - SWIMMING instead of bridges
                if (y !== undefined && y < -50) {
                    // Player swims in water/lava
                    if (obj === worldState.player && obj.userData.animation) {
                        obj.userData.animation.isSwimming = true;

                        // Calculate swimming bob (sinusoidal bobbing motion)
                        obj.userData.animation.swimBob += 0.05;
                        const bobOffset = Math.sin(obj.userData.animation.swimBob) * SWIM_BOB_AMPLITUDE;

                        // Swim at water surface level minus sink depth, plus bob
                        const swimY = SWIM_WATER_SURFACE - SWIM_SINK_DEPTH + bobOffset + 0.5;
                        const lerpRate = 0.12;
                        obj.position.y = THREE.MathUtils.lerp(obj.position.y, swimY, lerpRate);
                    } else {
                        // Non-player objects use bridge height
                        const bridgeY = PLAYER_WATER_LEVEL + PLAYER_BRIDGE_HEIGHT;
                        const targetY = bridgeY + 0.8;
                        obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.4);
                    }
                    return;
                }

                // On land - not swimming
                if (obj === worldState.player && obj.userData.animation) {
                    obj.userData.animation.isSwimming = false;
                }

                if(y !== undefined && y > -50) {
                    const targetY = y + (obj === worldState.player ? 1.2 : 0.8);
                    const diff = Math.abs(obj.position.y - targetY);
                    // v6.64: Instant snap if way off (>3 units), otherwise smooth lerp
                    if (obj !== worldState.player && diff > 3) {
                        obj.position.y = targetY; // Instant correction for floating mobs
                    } else {
                        const lerpRate = obj === worldState.player ? 0.15 : 0.4;
                        obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, lerpRate);
                    }
                }
            }
        }

        // v6.81: Check if a position is blocked hazardous terrain
        // Returns true if the robot cannot enter this tile
        // UPDATED: Now allows swimming in water and lava!
        function isBlockedTerrain(pos, currentY = 0) {
            if (!worldState.terrain) return false;

            const gx = Math.round(pos.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
            const gz = Math.round(pos.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;

            // Bounds check - don't block at world edges (let existing boundary handling work)
            if (gx < 0 || gx >= CONFIG.WORLD_SIZE || gz < 0 || gz >= CONFIG.WORLD_SIZE) return false;

            const terrainY = worldState.terrain[gx]?.[gz];
            if (terrainY === undefined) return false;

            // v6.81: Allow swimming in water and lava - never block based on terrain type
            // The snapToGround function handles the swimming mechanics
            return false;
        }

        // v6.81: Move player - swimming enabled, no terrain blocking
        function tryMovePlayer(player, moveVector) {
            if (!player || moveVector.length() < 0.001) return true;

            // v6.81: Swimming enabled - always allow movement, snapToGround handles Y position
            player.position.add(moveVector);
            return true;
        }

        // v6.42: Check if position is on lava (water tiles in Volcanic biome) - 8-agent consensus
        // v6.68: Updated to account for bridges over lava - no damage when elevated
        function isOnLava(pos) {
            // Early exit: Only Volcanic biome has lava (water in other biomes is just water)
            if (!activeCiv || activeCiv.biome !== 'Volcanic') return false;
            if (!worldState.terrain) return false;

            const gx = Math.round(pos.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;
            const gz = Math.round(pos.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2;

            // Bounds check
            if (gx < 0 || gx >= CONFIG.WORLD_SIZE || gz < 0 || gz >= CONFIG.WORLD_SIZE) return false;

            // v6.68: If player is elevated (on a bridge), not in lava
            const bridgeMinHeight = PLAYER_WATER_LEVEL + PLAYER_BRIDGE_HEIGHT - 0.5;
            if (pos.y > bridgeMinHeight) return false;

            // -99 indicates water/lava tile
            return worldState.terrain[gx] && worldState.terrain[gx][gz] === -99;
        }

        // v6.42: Apply lava damage to player - 8-agent consensus implementation
        function checkLavaDamage(time) {
            if (!worldState.player) return;

            const p = worldState.player;
            const onLava = isOnLava(p.position);

            if (onLava) {
                // Show warning notification on first contact
                if (!playerState.inLava) {
                    playerState.inLava = true;
                    showNotification(' LAVA! Get to solid ground!', 'warning');
                }

                // Check damage cooldown (500ms tick rate)
                if (time - playerState.lastLavaDamageTime >= LAVA_DAMAGE_CONFIG.TICK_RATE) {
                    playerState.lastLavaDamageTime = time;

                    // Apply damage through damagePlayer for proper defense/immunity handling
                    damagePlayer(LAVA_DAMAGE_CONFIG.DAMAGE);

                    // Additional visual feedback specific to lava
                    if (p.position) {
                        spawnFloater(
                            p.position,
                            `${LAVA_DAMAGE_CONFIG.FLOATER_ICON} LAVA! -${LAVA_DAMAGE_CONFIG.DAMAGE}`,
                            LAVA_DAMAGE_CONFIG.FLOATER_COLOR
                        );

                        // Rising ember particles (negative gravity makes them rise like flames)
                        if (particles) {
                            particles.emit(p.position, 8, 0xff4400, {
                                spread: 1.5,
                                lifetime: 400,
                                gravity: -5
                            });
                        }
                    }
                }
            } else {
                // Reset state when off lava
                playerState.inLava = false;
            }
        }

        // v4.2: Calculate player damage with weapon bonus and skill levels
        function getPlayerDamage() {
            let baseDamage = 1;

            // v5.1: Get damage from equipped gear
            const equipStats = getEquipmentStats();
            let weaponBonus = equipStats.damage;

            // Fallback: Check inventory for weapons if nothing equipped
            if (weaponBonus === 0) {
                const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade', 'Sword'];
                for (const weapon of weapons) {
                    if (hasItem(weapon)) {
                        weaponBonus = Math.max(weaponBonus, ITEMS[weapon].combatBonus || 0);
                        break;
                    }
                }
            }

            // Skill bonus: +1 damage every 3 combat levels
            const skillBonus = Math.floor(gameData.skills.combat.level / 3);

            let totalDamage = baseDamage + weaponBonus + skillBonus;

            // v5.1: Apply equipment crit chance
            if (equipStats.critChance > 0 && Math.random() < equipStats.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ' CRIT!', '#ffaa00');
                }
            }

            // v4.6: Apply crit multiplier if in parry crit window
            if (isInCritWindow()) {
                totalDamage = Math.floor(totalDamage * PARRY_CONFIG.CRIT_MULTIPLIER);
            }

            // v4.8: Apply combo multiplier
            const comboMult = getComboMultiplier();
            if (comboMult > 1) {
                totalDamage = Math.floor(totalDamage * comboMult);
            }

            // v4.8: Apply War Cry damage boost
            if (isWarcryActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.warcry.damageBoost);
            }

            // v4.9: Apply Berserker Rage damage boost
            if (isBerserkActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.berserk.damageBoost);
            }

            // v5.0: Apply pet damage bonus
            const petBonuses = getPetBonuses();
            if (petBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.damage));
            }
            if (petBonuses.allStats > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.allStats));
            }

            // v5.2: Apply talent bonuses
            const talentBonuses = getTalentBonuses();
            if (talentBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + talentBonuses.damage));
            }
            // v5.2: Apply talent crit chance
            if (talentBonuses.critChance > 0 && Math.random() < talentBonuses.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ' TALENT CRIT!', '#ffd700');
                }
            }

            // v5.3: Apply mastery combat bonuses
            const masteryBonuses = getMasteryBonuses();
            if (masteryBonuses.combatDamage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + masteryBonuses.combatDamage));
            }
            if (masteryBonuses.combatCrit > 0 && Math.random() < masteryBonuses.combatCrit) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ' MASTERY CRIT!', '#ff44ff');
                }
            }

            // v5.3: Apply rarity item bonuses
            const rarityBonuses = getRarityBonuses();
            if (rarityBonuses.damage > 0) {
                totalDamage += rarityBonuses.damage;
            }
            if (rarityBonuses.critChance > 0 && Math.random() < rarityBonuses.critChance) {
                const critMult = 2 + (rarityBonuses.critDamage || 0);
                totalDamage = Math.floor(totalDamage * critMult);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ' RARITY CRIT!', '#4488ff');
                }
            }

            // v5.4: Apply evolution damage bonus
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageBonus > 0) {
                totalDamage = Math.floor(totalDamage * (1 + evolutionBonuses.damageBonus));
            }
            // v5.8: Boss damage bonus is now applied in performAction where isBoss is known

            return totalDamage;
        }

        // v4.2: Calculate skill bonus for gathering (multiplier)
        function getSkillBonus(skillName) {
            const level = gameData.skills[skillName]?.level || 1;
            return 1 + Math.floor(level / 5) * 0.25; // +25% every 5 levels
        }

        // v4.2: Calculate player defense from armor
        function getPlayerDefense() {
            let defense = 0;

            // v5.1: Get defense from equipped gear
            const equipStats = getEquipmentStats();
            defense += equipStats.defense;

            // Fallback: Check inventory for armor if nothing equipped
            if (equipStats.defense === 0 && hasItem('Chitin Armor')) {
                defense += ITEMS['Chitin Armor'].defenseBonus;
            }
            if (equipStats.defense === 0 && hasItem('Guardian Armor')) {
                defense += ITEMS['Guardian Armor'].defenseBonus;
            }

            defense += Math.floor(gameData.skills.combat.level / 5); // +1 defense every 5 combat levels

            // v5.2: Apply talent defense bonus
            const talentBonuses = getTalentBonuses();
            defense += talentBonuses.defense || 0;

            // v5.3: Apply rarity item defense bonus
            const rarityBonuses = getRarityBonuses();
            defense += rarityBonuses.defense || 0;

            return defense;
        }

        function performAction(target) {
            const data = target.userData;

            // v5.4: Handle event item collection
            if (data.type === 'eventItem') {
                collectEventItem(target);
                return;
            }

            // v6.34: Handle dropped items pickup
            if (data.type === 'droppedItems') {
                pickupDroppedItems(target);
                return;
            }

            // v4.2: Handle POI interactions differently
            if (data.type === 'poi') {
                if (!data.discovered) {
                    data.discovered = true;
                    gameData.statistics.poisDiscovered++;

                    // Mark as discovered for this planet
                    if (!gameData.discoveredPOIs[activeCiv.id]) {
                        gameData.discoveredPOIs[activeCiv.id] = [];
                    }
                    gameData.discoveredPOIs[activeCiv.id].push(data.poiType);

                    // Grant rewards
                    data.rewards.forEach(reward => {
                        const count = Array.isArray(reward.count)
                            ? Math.floor(Math.random() * (reward.count[1] - reward.count[0] + 1)) + reward.count[0]
                            : reward.count;
                        for (let i = 0; i < count; i++) {
                            addItem(reward.item);
                        }
                        spawnFloater(target.position, `+${count} ${reward.item}`, '#ffdd00');
                    });

                    // Grant XP bonus
                    addXp('combat', data.xpBonus);

                    spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.icon} ${data.name} DISCOVERED!`, '#ffdd00');
                    AudioSystem.levelUp();
                    if (particles) particles.emit(target.position, 30, 0xffdd00, { spread: 6, lifetime: 1500, size: 0.3 });

                    // Change POI appearance to show it's been discovered
                    if (data.beacon) data.beacon.material.emissiveIntensity = 0.1;
                    if (data.iconMesh) data.iconMesh.material.opacity = 0.3;

                    checkAchievements();
                    updateDailyChallengeProgress();
                    updatePlayerRank();
                } else {
                    spawnFloater(target.position, "Already discovered", '#888888');
                }
                return;
            }

            // v6.68: Handle hostile creep attacks
            if (data.type === 'creep' && data.team === 'B') {
                const damage = getPlayerDamage();
                data.hp -= damage;

                // Visual feedback
                spawnFloater(target.position, `-${damage}`, '#ff4444');
                AudioSystem.hit(0);
                if (particles) particles.emit(target.position, 8, 0xff4444, { spread: 2, lifetime: 600 });

                // Update HP bar
                if (data.hpBar) {
                    const hpPercent = data.hp / data.maxHp;
                    data.hpBar.scale.x = Math.max(0.01, hpPercent);
                    data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
                }

                // Scale feedback
                target.scale.setScalar(0.85);
                setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

                // Creep death
                if (data.hp <= 0) {
                    const idx = creepWaveState.creeps.indexOf(target);
                    if (idx > -1) {
                        // Award XP and gold
                        addXp('combat', 30);
                        gameData.gold = (gameData.gold || 0) + 5;
                        spawnFloater(target.position, '+30 XP', '#ffff00');

                        // Death particles
                        if (particles) particles.emit(target.position, 20, 0xff4444, { spread: 4, lifetime: 800 });
                        AudioSystem.combatEvent('kill');

                        // Remove creep
                        scene.remove(target);
                        creepWaveState.creeps.splice(idx, 1);
                    }
                }

                worldState.interactTarget = null;
                return;
            }

            // v6.68: Handle hostile tower attacks
            if (data.type === 'hostileTower') {
                const damage = getPlayerDamage();
                const towerRef = data.towerRef;

                if (towerRef) {
                    towerRef.hp -= damage;
                    data.hp = towerRef.hp;  // Sync userData

                    // Visual feedback
                    spawnFloater(target.position, `-${damage}`, '#ff4444');
                    AudioSystem.hit(0);
                    if (particles) particles.emit(target.position, 10, 0xff4444, { spread: 3, lifetime: 600 });

                    // Flash the tower
                    target.traverse(child => {
                        if (child.material && child.material.emissive) {
                            const origIntensity = child.material.emissiveIntensity;
                            child.material.emissiveIntensity = 2;
                            setTimeout(() => {
                                if (child.material) child.material.emissiveIntensity = origIntensity;
                            }, 100);
                        }
                    });

                    // Tower destruction
                    if (towerRef.hp <= 0) {
                        towerRef.active = false;

                        // Award XP and gold
                        addXp('combat', 200);
                        gameData.gold = (gameData.gold || 0) + 50;
                        spawnFloater(target.position, '+200 XP', '#ffff00');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1, 0)), 'TOWER DESTROYED!', '#ff4400');

                        // Explosion effect
                        if (particles) particles.emit(target.position, 50, 0xff4400, { spread: 8, lifetime: 1500, size: 0.4 });
                        screenShake(1.5);
                        AudioSystem.combatEvent('kill');

                        // Remove tower mesh
                        scene.remove(target);

                        // Remove from array
                        const towerIdx = laneSupportState.laneTowers.indexOf(towerRef);
                        if (towerIdx > -1) {
                            laneSupportState.laneTowers.splice(towerIdx, 1);
                        }
                    }
                }

                worldState.interactTarget = null;
                return;
            }

            // v4.2: Calculate damage based on type
            let damage = 1;
            if (data.type === 'mob' || data.type === 'boss') {
                damage = getPlayerDamage();
                // v5.8: Apply evolution boss damage bonus here where isBoss is known
                const isBoss = data.type === 'boss' || data.isBoss;
                if (isBoss) {
                    const evolutionBonuses = getEvolutionBonuses();
                    if (evolutionBonuses.bossDamage > 0) {
                        damage = Math.floor(damage * (1 + evolutionBonuses.bossDamage));
                    }
                }
            }

            // v4.8: Update combo state on combat hit
            const isCombatHit = data.type === 'mob' || data.type === 'boss';
            let comboHit = 0;
            if (isCombatHit) {
                comboHit = updateCombo(performance.now());
                // v6.9: Update style meter on hit (Agent consensus)
                if (typeof updateStyleMeter === 'function') {
                    updateStyleMeter(comboHit > 0 ? 'comboHit' : 'hit', 1 + comboHit * 0.2);
                }

                // v6.35: Combo Crescendo Orchestra - combat composes music
                if (typeof comboCrescendo !== 'undefined') {
                    comboCrescendo.updateCombo(comboHit);
                }

                // v6.42: Chrono-Echo Combat - record attack for echo playback
                if (typeof chronoEchoSystem !== 'undefined' && worldState.player) {
                    chronoEchoSystem.recordAction('attack',
                        worldState.player.position,
                        worldState.player.rotation.y,
                        target.position,
                        damage
                    );
                }
            }

            // v6.9: Apply elemental multiplier (Agent consensus - Combat Depth)
            const weaponElement = typeof getEquippedElement === 'function' ? getEquippedElement() : null;
            const mobName = data.name || data.type || 'unknown';  // v6.90: Fallback for targets without names
            const elementalResult = typeof getElementalMultiplier === 'function'
                ? getElementalMultiplier(mobName, weaponElement)
                : { multiplier: 1.0, type: 'normal' };
            damage = Math.floor(damage * elementalResult.multiplier);

            // v6.9: Apply bestiary damage bonus (Agent consensus)
            const bestiaryBonus = typeof getBestiaryDamageBonus === 'function'
                ? getBestiaryDamageBonus(mobName) : 0;
            if (bestiaryBonus > 0) {
                damage = Math.floor(damage * (1 + bestiaryBonus));
            }

            // v4.6: Show crit feedback if in crit window, v4.8: combo feedback
            const isCrit = isInCritWindow() && isCombatHit;
            const isFinisher = comboHit >= COMBO_CONFIG.MAX_HITS - 1;

            let hitText, hitColor;
            if (isFinisher) {
                hitText = ` FINISHER x${comboHit + 1}! -${damage}`;
                hitColor = '#ff00ff';
            } else if (isCrit) {
                hitText = ` CRIT! -${damage}`;
                hitColor = '#ffd700';
            } else if (comboHit > 0) {
                hitText = `x${comboHit + 1} COMBO! -${damage}`;
                hitColor = '#00ffff';
            } else {
                // v6.34: Variety in basic hit feedback
                const hitVariants = damage >= 10
                    ? ['SMASH!', 'WHAM!', 'POW!', 'SLAM!', 'CRUSH!']
                    : damage >= 5
                    ? ['HIT!', 'STRIKE!', 'BASH!', 'THWACK!']
                    : ['HIT!', 'TAP!', 'NICK!', 'POKE!'];
                const variant = hitVariants[Math.floor(Math.random() * hitVariants.length)];
                hitText = damage > 1 ? `${variant} -${damage}` : variant;
                // v6.34: Subtle color variation based on damage
                hitColor = damage >= 10 ? '#ffaa44' : damage >= 5 ? '#ffffff' : '#cccccc';
            }

            spawnFloater(target.position, hitText, hitColor, isCrit || isFinisher); // v6.43: Enhanced animation for crits/finishers
            AudioSystem.hit(comboHit || 0); // v6.41: Pass combo count for ascending pitch

            // v6.32: Adaptive combat music events (8-agent consensus)
            if (isCombatHit) {
                if (isFinisher) {
                    AudioSystem.combatEvent('finisher');
                } else if (isCrit) {
                    AudioSystem.combatEvent('crit');
                } else {
                    AudioSystem.combatEvent('hit');
                }

                // v6.33: Combo Chromatic Crescendo (8-agent consensus)
                // Color progression through spectrum per combo hit
                if (typeof comboChromaticSystem !== 'undefined' && comboHit) {
                    comboChromaticSystem.triggerComboEffect(comboHit, target.position);
                }
            }

            // v6.9: Show elemental effectiveness feedback (Agent consensus)
            if (elementalResult.type === 'weak') {
                spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1, 0)), ' WEAK!', '#ff4400');
                if (particles) particles.emit(target.position, 15, 0xff4400, { spread: 3, lifetime: 500 });
            } else if (elementalResult.type === 'resist') {
                spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1, 0)), ' RESIST', '#666666');
            } else if (elementalResult.type === 'immune') {
                spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1, 0)), ' IMMUNE', '#444444');
            }

            // v6.9: Apply knockback on hit (Agent consensus - Physics Fun)
            if (isCombatHit && typeof applyKnockback === 'function' && worldState.player) {
                const knockDir = target.position.clone().sub(worldState.player.position);
                const knockForce = KNOCKBACK_CONFIG.BASE_FORCE * (isFinisher ? 2 : isCrit ? 1.5 : 1);
                applyKnockback(target, knockDir, knockForce);
            }

            // v5.15: Trigger robot attack animation on combat
            if (isCombatHit) {
                triggerRobotAnimation('attack');
            }

            data.hp -= damage;
            gameData.statistics.totalDamageDealt += damage;

            // v6.36: Screen shake on dealing damage (Round 3 consensus)
            if (isCombatHit) {
                impactShake.triggerDamageDealt(damage);

                // v6.81: Enhanced impact border for crits/finishers (8-Agent Ultra-Think Consensus - 8/8 votes)
                if (isFinisher || isCrit) {
                    showImpactBorder('critical-hit');
                } else {
                    showImpactBorder('damage-dealt');
                }
            }

            // v5.1: Apply lifesteal from equipment
            const equipStats = getEquipmentStats();
            if (equipStats.lifesteal > 0) {
                const healAmount = Math.floor(damage * equipStats.lifesteal);
                if (healAmount > 0) {
                    gameData.player.hp = Math.min(CONFIG.PLAYER_MAX_HP + equipStats.maxHpBonus, gameData.player.hp + healAmount);
                    spawnFloater(worldState.player.position, ` +${healAmount}`, '#44ff44');
                    updateHealthUI();
                }
            }

            // v4.4: Hit-stop and flash for satisfying combat
            const isBossTarget = data.type === 'boss' || data.isBoss;
            const isMobTarget = data.type === 'mob';
            const willDie = data.hp - damage <= 0; // Check if this hit will kill
            if (isBossTarget) {
                triggerHitStop(HIT_STOP_BOSS);
                flashTargetHit(target, 0xff4400);
                // v6.32: Camera punch toward boss impact (8-agent consensus)
                triggerCameraPunch(target.position, {
                    isBoss: true,
                    isFinisher,
                    isCrit,
                    isKill: willDie
                });
            } else if (isMobTarget) {
                triggerHitStop(HIT_STOP_LIGHT);
                flashTargetHit(target, 0xff0000);
                // v6.32: Camera punch toward mob impact (8-agent consensus)
                triggerCameraPunch(target.position, {
                    isBoss: false,
                    isFinisher,
                    isCrit,
                    isKill: willDie
                });
            }

            // v4.6: Apply elemental status effect on hit
            if (isMobTarget || isBossTarget) {
                const element = getEquippedElement();
                if (element) {
                    applyStatusEffect(target, element);
                }
            }

            // Visual feedback
            target.scale.setScalar(0.85);
            setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

            // v4.0: Hit particles based on type
            // v6.81: Enhanced particles for crits/finishers (8-Agent Ultra-Think Consensus - 7/8 votes)
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 :
                                     data.type === 'rock' ? 0x888888 :
                                     data.type === 'mob' ? (ENEMY_TYPES[data.name]?.color || 0x44ff44) : 0x4488ff;

                // Enhanced particle burst for critical hits and finishers
                const particleCount = isFinisher ? 25 : isCrit ? 15 : 5;
                const particleSpread = isFinisher ? 5 : isCrit ? 3.5 : 2;
                const particleSize = isFinisher ? 0.3 : isCrit ? 0.22 : 0.15;
                const particleLifetime = isFinisher ? 1000 : isCrit ? 800 : 600;

                particles.emit(target.position, particleCount, particleColor, {
                    spread: particleSpread,
                    lifetime: particleLifetime,
                    size: particleSize
                });

                // Golden sparkle particles for crits and finishers
                if (isCrit || isFinisher) {
                    particles.emit(target.position, isFinisher ? 15 : 8, 0xffd700, {
                        spread: 4,
                        lifetime: 800,
                        size: 0.2
                    });
                }
            }

            // Update mob health bar
            if (data.type === 'mob' && data.hpBar) {
                const hpPercent = data.hp / data.maxHp;
                data.hpBar.scale.x = Math.max(0.01, hpPercent);
                data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
            }

            if(data.hp <= 0) {
                if(data.type === 'tree') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('wood');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Log');
                    addXp('wood', 50);
                    gameData.statistics.treesChopped++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} LOG`, '#da5');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 12, 0xdd9955, { spread: 4, lifetime: 1000 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'rock') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('mining');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Ore');
                    addXp('mining', 50);
                    gameData.statistics.oresMined++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} ORE`, '#888');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 15, 0x888888, { spread: 3, lifetime: 800 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob' || data.type === 'boss') {
                    // v4.3: Handle both regular mobs and bosses
                    const isBoss = data.type === 'boss' || data.isBoss;

                    // v4.2/4.3: Drop items from enemy data
                    const drops = data.drops || ['Slime'];
                    // v4.7: Elite enemies drop more items
                    const dropMultiplier = data.isElite ? ELITE_CONFIG.bonusDropMult : 1;

                    drops.forEach(drop => {
                        // Handle boss drop format { item, count }
                        if (typeof drop === 'object') {
                            const count = drop.count * dropMultiplier;
                            for (let i = 0; i < count; i++) addItem(drop.item);
                            spawnFloater(target.position.clone().add(new THREE.Vector3(Math.random(), 1, Math.random())), `+${count} ${drop.item}`, '#ffd700');
                        } else {
                            for (let i = 0; i < dropMultiplier; i++) addItem(drop);
                        }
                    });

                    // v4.7: Elite essence drop
                    if (data.isElite && Math.random() < ELITE_CONFIG.essenceDropChance) {
                        const essenceCount = 1 + Math.floor(Math.random() * 3); // 1-3 essence
                        for (let i = 0; i < essenceCount; i++) addItem('Elite Essence');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1.5, 0)), `+${essenceCount} Elite Essence`, '#aa00ff');
                    }

                    // v6.8: Update kill streak and apply XP multiplier (Agent consensus)
                    if (typeof updateKillStreak === 'function') {
                        updateKillStreak();
                    }
                    const streakMultiplier = typeof getKillStreakXPMultiplier === 'function' ? getKillStreakXPMultiplier() : 1.0;
                    const xpReward = Math.floor((data.xpReward || 100) * streakMultiplier);
                    addXp('combat', xpReward);

                    // v6.68: Gold drops from mob kills (Living Economy)
                    const baseGold = isBoss ? 50 + Math.floor(Math.random() * 100) :
                                    data.isElite ? 15 + Math.floor(Math.random() * 25) :
                                    2 + Math.floor(Math.random() * 8);
                    const goldDrop = Math.floor(baseGold * streakMultiplier);
                    if (typeof addGold === 'function') {
                        addGold(goldDrop, isBoss ? 'boss' : data.isElite ? 'elite' : 'mob');
                    } else {
                        ECONOMY.gold += goldDrop;
                        spawnFloater(target.position, `+${goldDrop}g`, '#ffd700');
                    }

                    // v4.7: Handle explosive affix death
                    if (data.isElite && data.eliteData?.explodeOnDeath) {
                        const explosionDamage = Math.floor(data.damage * 2);
                        const explosionRange = 5;
                        const distToPlayer = target.position.distanceTo(p.position);
                        if (distToPlayer < explosionRange) {
                            damagePlayer(explosionDamage, 'explosion');
                            spawnFloater(p.position, ` EXPLOSION! -${explosionDamage}`, '#ff6600');
                        }
                        if (particles) particles.emit(target.position, 40, 0xff6600, { spread: 8, lifetime: 1000, size: 0.4 });
                        screenShake(1.2);
                        AudioSystem.explosion && AudioSystem.explosion();
                    }

                    // v6.7: Kill celebration flash (Agent consensus - Combat Juice)
                    if (typeof flashKillCelebration === 'function') {
                        flashKillCelebration(isBoss);
                    }

                    // v6.32: Adaptive combat music - kill event (8-agent consensus)
                    AudioSystem.combatEvent('kill');

                    // v6.33: Synaptic Bass Drop (8-agent consensus)
                    // Dramatic kill satisfaction - silence, bass thump, screen compression
                    if (typeof synapticBassDrop !== 'undefined') {
                        synapticBassDrop.trigger(target.position, isBoss);
                    }

                    // v6.36: Kill screen shake (Round 3 consensus)
                    impactShake.triggerKill();
                    if (isBoss) impactShake.triggerBossHit();

                    // v6.81: Boss kill victory confetti (8-Agent Ultra-Think Consensus - 6/8 votes)
                    if (isBoss && typeof spawnVictoryConfetti === 'function') {
                        spawnVictoryConfetti(200); // Epic confetti burst for boss kills
                    }

                    // v6.36: Personal records & daily challenges (Round 3 consensus)
                    if (typeof personalRecords !== 'undefined' && personalRecords.records) {
                        personalRecords.recordKill();
                        personalRecords.recordDamageDealt(damage);
                        personalRecords.recordCombo(comboHit || 0);
                    }
                    if (typeof dailyChallenges !== 'undefined' && dailyChallenges.progress) {
                        dailyChallenges.updateProgress('kill');
                        dailyChallenges.updateProgress('damage', damage);
                        dailyChallenges.updateProgress('combo', comboHit || 0);
                    }

                    // v6.36: Kill Replay Flash for significant kills (Round 3 consensus)
                    if (typeof killReplay !== 'undefined') {
                        killReplay.recordKill(
                            isBoss ? 'boss' : (data.isElite ? 'elite' : 'mob'),
                            damage,
                            target.position.clone(),
                            comboHit || 0
                        );
                    }

                    if (isBoss) {
                        // v6.32: Boss defeat triggers special music event
                        AudioSystem.combatEvent('bossDefeat');
                        gameData.statistics.bossesDefeated++;
                        // v6.35: Chronicle Engine - capture boss defeat
                        if (typeof captureChronicleEvent === 'function') {
                            captureChronicleEvent('boss_defeat', { bossName: data.name, xpEarned: xpReward, totalBossesDefeated: gameData.statistics.bossesDefeated });
                        }
                        // v4.9: Track boss in codex
                        trackCreatureKill('boss');
                        // v6.9: Try to discover lore on boss defeat (Agent consensus - Secrets)
                        if (typeof tryDiscoverLore === 'function') {
                            tryDiscoverLore('boss_defeat');
                        }
                        // v6.9: Style meter finisher bonus on boss kill
                        if (typeof updateStyleMeter === 'function') {
                            updateStyleMeter('finisher', 2);
                        }
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `BOSS DEFEATED! +${xpReward}XP`, '#ffd700');
                        showNotification(`${data.name} has been defeated!`, 'success');
                        // v4.4: Extra long hit-stop for boss kill
                        triggerHitStop(HIT_STOP_BOSS * 2);
                        screenShake(1.5);
                        // Extra celebration
                        if (particles) particles.emit(target.position, 50, 0xffd700, { spread: 8, lifetime: 2000, size: 0.4 });

                        // v5.3: Check portal clear on boss kill (portal realms require boss kills)
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            if (portalMods?.bossOnly) {
                                exitPortal(true);
                            }
                        }

                        // v5.3: Chance for rarity loot on boss kills
                        if (Math.random() < 0.4) {
                            const rareDrop = drops[0]?.item || drops[0] || 'Boss Trophy';
                            const rarityItem = createRarityItem(rareDrop);
                            if (rarityItem.rarity !== 'common') {
                                if (!gameData.rarityItems) gameData.rarityItems = [];
                                gameData.rarityItems.push(rarityItem);
                                showRarityDropPopup(rarityItem);
                            }
                        }
                    } else {
                        gameData.statistics.mobsKilled++;
                        // v4.9: Track creature in codex
                        if (data.isElite) {
                            trackCreatureKill('elite');
                        } else {
                            trackCreatureKill(data.name?.toLowerCase() || 'unknown');
                        }
                        // v6.9: Check bestiary milestones (Agent consensus - Meta)
                        if (typeof checkBestiaryMilestone === 'function') {
                            checkBestiaryMilestone(data.name);
                        }
                        // v6.9: Update style meter on kill (Agent consensus)
                        if (typeof updateStyleMeter === 'function') {
                            updateStyleMeter('kill', data.isElite ? 2 : 1);
                        }
                        // v5.0: Try to drop a pet
                        tryDropPet(data.name);
                        // v5.4: Gain pet bond from kills
                        gainPetBond(data.isElite ? 3 : 1);
                        // v6.12: Track elite defeats (renamed from kills for family-friendly)
                        if (data.isElite) {
                            gameData.statistics.elitesKilled = (gameData.statistics.elitesKilled || 0) + 1;
                            // v6.35: Chronicle Engine - capture elite defeat
                            if (typeof captureChronicleEvent === 'function') {
                                captureChronicleEvent('elite_defeat', { eliteName: data.name, prefix: data.eliteData?.prefix, xpEarned: xpReward });
                            }
                            spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.eliteData.prefix} ELITE DEFEATED! +${xpReward}XP`, '#ffaa00');
                            showNotification(`Elite ${data.name} defeated!`, 'success');
                            triggerHitStop(HIT_STOP_BOSS);

                            // v5.3: Chance for rarity loot on elite defeats
                            if (Math.random() < 0.2) {
                                const rareDrop = drops[0] || 'Elite Essence';
                                const rarityItem = createRarityItem(rareDrop);
                                if (rarityItem.rarity !== 'common') {
                                    if (!gameData.rarityItems) gameData.rarityItems = [];
                                    gameData.rarityItems.push(rarityItem);
                                    showRarityDropPopup(rarityItem);
                                }
                            }
                        } else {
                            // v6.12: Changed "KILLED" to "DEFEATED" for family-friendly messaging
                            spawnFloater(target.position, `DEFEATED! +${xpReward}XP`, '#88ff88');
                            triggerHitStop(HIT_STOP_HEAVY);
                        }
                        worldMobKillCount++; // v4.3: Track for boss spawning
                        checkBossSpawn(); // v4.3: Check if boss should spawn

                        // v5.3: Track portal kills - elites count more
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            // Portals without bossOnly can be cleared by killing enough enemies
                            if (!portalMods?.bossOnly && data.isElite) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 5; // Elite = 5 kills
                                if (gameData.portals.killProgress >= 25) { // Need 25 points (5 elites or 25 mobs)
                                    exitPortal(true);
                                }
                            } else if (!portalMods?.bossOnly) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 1;
                                if (gameData.portals.killProgress >= 25) {
                                    exitPortal(true);
                                }
                            }
                        }
                    }

                    AudioSystem.kill();
                    const mobColor = data.isElite ? (data.eliteData?.color || 0xffaa00) :
                                    isBoss ? (BOSS_TYPES[data.bossId]?.color || 0xffd700) :
                                    (ENEMY_TYPES[data.name]?.color || 0x44ff44);
                    if (particles && !isBoss) particles.emit(target.position, data.isElite ? 30 : 20, mobColor, { spread: data.isElite ? 7 : 5, lifetime: 1200, size: data.isElite ? 0.35 : 0.25 });

                    // v6.52: Spawn quantum wreckage on death (higher chance for elites/bosses)
                    if (typeof quantumWreckage !== 'undefined') {
                        const wreckageChance = isBoss ? 1.0 : data.isElite ? 0.6 : 0.3;
                        if (Math.random() < wreckageChance) {
                            quantumWreckage.spawnWreckage(target.position, data.name, data);
                        }
                    }

                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                else if(data.type === 'fishing') {
                    if (hasItem('Fishing Rod')) {
                        // v4.2: Skill bonus for fishing
                        const skillMultiplier = getSkillBonus('fishing');
                        const fishCount = Math.floor(1 * skillMultiplier);
                        for (let i = 0; i < fishCount; i++) addItem('Raw Fish');
                        addXp('fishing', 40);
                        gameData.statistics.fishCaught += fishCount;
                        gainPetBond(1); // v5.4: Pet bond from fishing
                        spawnFloater(target.position, `+${fishCount} FISH`, '#44f');
                        AudioSystem.collect();
                        if (particles) particles.emit(target.position, 8, 0x4488ff, { spread: 2, lifetime: 800, gravity: 5 });
                    } else {
                        spawnFloater(target.position, "Need Rod!", '#f44');
                        AudioSystem.error();
                    }
                    data.hp = data.maxHp = 1;
                    return;
                }
                worldState.interactTarget = null;

                checkAchievements();
                updateDailyChallengeProgress();
                updatePlayerRank();
            }
        }

        // v6.7: Updated to accept optional attacker position for directional damage indicator
        function damagePlayer(amount, attackerPos = null) {
            // v4.5: Check for dodge i-frames
            if (isInvincible()) {
                spawnFloater(worldState.player.position, 'DODGE!', '#88ffff');
                return;
            }

            // v4.8: Break combo on taking damage
            if (COMBO_CONFIG.BREAK_ON_DAMAGE && comboState.active) {
                breakCombo();
            }

            // v6.8: Reset kill streak on taking damage (Agent consensus)
            if (typeof resetKillStreak === 'function') {
                resetKillStreak();
            }

            // v6.9: Style meter penalty on taking damage (Agent consensus)
            if (typeof updateStyleMeter === 'function') {
                updateStyleMeter('damageTaken');
            }

            // v4.9: Apply Shield Wall damage reduction
            let reducedAmount = amount;
            if (isShieldWallActive()) {
                reducedAmount = Math.floor(amount * (1 - COMBAT_ABILITIES.shieldWall.damageReduction));
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ` BLOCKED!`, '#4488ff');
                }
            }

            // v5.4: Apply evolution damage reduction and phase shift
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageReduction > 0) {
                reducedAmount = Math.floor(reducedAmount * (1 - evolutionBonuses.damageReduction));
            }
            if (evolutionBonuses.phaseShift > 0 && Math.random() < evolutionBonuses.phaseShift) {
                reducedAmount = Math.floor(reducedAmount * 0.5);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, ' PHASED!', '#4400ff');
                }
            }

            // v4.2: Apply defense reduction
            const defense = getPlayerDefense();
            const actualDamage = Math.max(1, reducedAmount - defense);
            gameData.player.hp = Math.max(0, gameData.player.hp - actualDamage);
            updateHealthUI();

            // v6.80: Enhanced visual feedback (8-Agent Consensus)
            showImpactBorder('damage-taken');
            updateCriticalHPOverlay();

            // v4.0: Enhanced damage feedback
            AudioSystem.damage();
            screenShake(amount * 0.1);
            flashDamageOverlay();

            // v6.36: Screen shake when taking damage
            impactShake.triggerDamageReceived(actualDamage);

            // v6.36: Update daily challenges for death tracking
            if (typeof dailyChallenges !== 'undefined' && dailyChallenges.progress) {
                dailyChallenges.updateProgress('death');
            }

            // v6.7: Show directional damage indicator if attacker position known
            if (attackerPos && typeof flashDirectionalDamage === 'function') {
                flashDirectionalDamage(attackerPos);
            }

            // v5.15: Trigger robot damage animation
            triggerRobotAnimation('damage');

            // v6.65: Companion takes splash damage in combat (30% chance)
            if (Math.random() < 0.3 && gameData.companion && gameData.companion.hp > 0) {
                const companionDamage = Math.max(1, Math.floor(actualDamage * 0.3));
                damageCompanion(companionDamage, 'Combat splash damage');
            }

            if (gameData.player.hp <= 0) {
                // v6.36: Record death in personal records
                if (typeof personalRecords !== 'undefined' && personalRecords.records) {
                    personalRecords.recordDeath();
                }
                playerDeath();
            }
        }

        function healPlayer(amount) {
            gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
            updateHealthUI();
            // v6.41: Added null check for worldState.player
            if (worldState.player && worldState.player.position) {
                spawnFloater(worldState.player.position, `+${amount} HP`, '#44ff44');
            }
            AudioSystem.heal(); // v4.0

            // v6.80: Enhanced visual feedback
            showImpactBorder('heal');
            updateCriticalHPOverlay();
        }

        // v6.12: Renamed from "death" to "fainted" for family-friendly gameplay
        // v6.34: Now drops inventory items on the ground that can be picked up later
        // v6.85: MEMENTO MORI PROTOCOL integration
        function playerFainted(killerType = 'Unknown Entity', killerName = null) {
            // v6.85: Record death in the Archivist's archive
            recordDeathInArchive(killerType, killerName);

            // v6.34: Drop inventory items at faint location before respawning
            if (gameData.inventory && gameData.inventory.length > 0 && activeCiv) {
                dropInventoryAtLocation(
                    worldState.player.position.x,
                    worldState.player.position.y,
                    worldState.player.position.z
                );
            }

            showNotification('You fainted! Your items dropped on the ground...', 'info');
            // v6.35: Chronicle Engine - capture player fainted
            if (typeof captureChronicleEvent === 'function') {
                captureChronicleEvent('player_fainted', { itemsLost: gameData.inventory?.length || 0, location: activeCiv?.name || 'Unknown' });
            }
            gameData.player.hp = gameData.player.maxHp;
            worldState.player.position.set(0, 10, 0);
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();

            // v6.85: Show Archivist greeting if MEMENTO MORI protocol is active
            if (gameData.deathArchive && gameData.deathArchive.archivistEnabled) {
                showArchivistGreeting();
            }

            // v6.12: Play recovery sound instead of death sound
            AudioSystem.heal();
        }
        // Backwards compatibility alias
        function playerDeath() { playerFainted(); }

        // ===========================================
        // v6.34: DROPPED ITEMS SYSTEM
        // ===========================================

        // Track active dropped item meshes in the world
        let droppedItemMeshes = [];

        // Drop all inventory items at a specific location
        function dropInventoryAtLocation(x, y, z) {
            if (!activeCiv || !gameData.inventory || gameData.inventory.length === 0) return;

            const planetId = activeCiv.id;

            // Initialize dropped items for this planet if not exists
            if (!gameData.droppedItems) gameData.droppedItems = {};
            if (!gameData.droppedItems[planetId]) gameData.droppedItems[planetId] = [];

            // Clone the inventory items
            const droppedStack = {
                x: x,
                y: y,
                z: z,
                items: [...gameData.inventory],  // Copy all items
                timestamp: Date.now()
            };

            // Add to persistent storage
            gameData.droppedItems[planetId].push(droppedStack);

            // Create visual representation
            createDroppedItemMesh(droppedStack);

            // Play drop sound
            playDropSound();

            // Show dramatic notification
            const itemCount = gameData.inventory.length;
            showNotification(` Dropped ${itemCount} items! Return here to recover them.`, 'warning');

            // Clear inventory
            gameData.inventory = [];
            updateInventoryUI();
            saveGameData();

            console.log(`Dropped ${itemCount} items at (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}) on planet ${planetId}`);
        }

        // Create a visual mesh for dropped items
        function createDroppedItemMesh(dropData) {
            const group = new THREE.Group();
            group.position.set(dropData.x, dropData.y + 0.5, dropData.z);

            // Create a glowing crate/bag mesh
            const crateGeo = new THREE.BoxGeometry(1.2, 0.8, 1.2);
            const crateMat = new THREE.MeshStandardMaterial({
                color: 0x8b4513,  // Saddle brown
                metalness: 0.1,
                roughness: 0.8
            });
            const crate = new THREE.Mesh(crateGeo, crateMat);
            crate.castShadow = true;
            crate.receiveShadow = true;
            group.add(crate);

            // Add golden glow ring around it
            const glowRingGeo = new THREE.TorusGeometry(1, 0.1, 8, 32);
            const glowRingMat = new THREE.MeshBasicMaterial({
                color: 0xffdd00,
                transparent: true,
                opacity: 0.6
            });
            const glowRing = new THREE.Mesh(glowRingGeo, glowRingMat);
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 0;
            group.add(glowRing);

            // Add floating item indicator above
            const indicatorGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const indicatorMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
            indicator.position.y = 1.5;
            group.add(indicator);

            // Add vertical beam
            const beamGeo = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.y = 2;
            group.add(beam);

            // Store reference data
            group.userData = {
                type: 'droppedItems',
                name: ` Dropped Items (${dropData.items.length})`,
                dropData: dropData,
                hp: 1,
                maxHp: 1
            };

            // Add animation data
            group.userData.animPhase = Math.random() * Math.PI * 2;

            scene.add(group);
            worldState.interactables.push(group);
            droppedItemMeshes.push(group);

            return group;
        }

        // Restore dropped items when entering a planet
        function restoreDroppedItemsForPlanet(planetId) {
            if (!gameData.droppedItems || !gameData.droppedItems[planetId]) return;

            const drops = gameData.droppedItems[planetId];
            for (const dropData of drops) {
                createDroppedItemMesh(dropData);
            }

            if (drops.length > 0) {
                showNotification(` ${drops.length} item pile(s) from previous visits nearby!`, 'info');
            }
        }

        // Handle picking up dropped items
        function pickupDroppedItems(droppedGroup) {
            if (!droppedGroup || !droppedGroup.userData.dropData) return;

            const dropData = droppedGroup.userData.dropData;
            const items = dropData.items;

            // Check if inventory has space
            const currentCount = gameData.inventory.length;
            const maxInventory = 20;

            if (currentCount >= maxInventory) {
                showNotification('Inventory full! Make some space first.', 'error');
                return false;
            }

            // Calculate how many items we can pick up
            const spaceAvailable = maxInventory - currentCount;
            const itemsToPickup = items.slice(0, spaceAvailable);
            const itemsRemaining = items.slice(spaceAvailable);

            // Add items to inventory
            for (const item of itemsToPickup) {
                gameData.inventory.push(item);
            }

            // Update drop data
            if (itemsRemaining.length > 0) {
                // Some items left - update the drop
                dropData.items = itemsRemaining;
                droppedGroup.userData.name = ` Dropped Items (${itemsRemaining.length})`;
                showNotification(`Picked up ${itemsToPickup.length} items! ${itemsRemaining.length} still on ground.`, 'info');
            } else {
                // All items picked up - remove the drop
                removeDroppedItemMesh(droppedGroup);
                showNotification(` Recovered all ${itemsToPickup.length} items!`, 'success');

                // Remove from persistent storage
                if (activeCiv && gameData.droppedItems[activeCiv.id]) {
                    const idx = gameData.droppedItems[activeCiv.id].indexOf(dropData);
                    if (idx >= 0) {
                        gameData.droppedItems[activeCiv.id].splice(idx, 1);
                    }
                }
            }

            // Play pickup sound
            AudioSystem.collect();

            // Update UI
            updateInventoryUI();
            saveGameData();

            return true;
        }

        // Remove a dropped item mesh from the world
        function removeDroppedItemMesh(group) {
            scene.remove(group);
            worldState.interactables = worldState.interactables.filter(x => x !== group);
            droppedItemMeshes = droppedItemMeshes.filter(x => x !== group);

            // Dispose geometry and materials
            group.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        }

        // Animate dropped items (floating effect)
        function updateDroppedItemAnimations(time) {
            for (const mesh of droppedItemMeshes) {
                if (!mesh.userData) continue;

                const phase = mesh.userData.animPhase || 0;

                // Floating bob
                mesh.position.y = mesh.userData.dropData.y + 0.5 + Math.sin(time * 0.002 + phase) * 0.15;

                // Rotate glow ring
                if (mesh.children[1]) {
                    mesh.children[1].rotation.z += 0.02;
                }

                // Pulse indicator
                if (mesh.children[2]) {
                    const pulse = 0.6 + Math.sin(time * 0.004 + phase) * 0.2;
                    mesh.children[2].material.opacity = pulse;
                }
            }
        }

        // Play drop sound effect
        function playDropSound() {
            try {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                const ctx = AudioSystem.ctx;
                if (ctx.state === 'suspended') ctx.resume();
                const now = ctx.currentTime;

                // Thud sound
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.3);

                // Scatter sound
                const noise = ctx.createOscillator();
                const noiseGain = ctx.createGain();
                noise.type = 'sawtooth';
                noise.frequency.setValueAtTime(800, now + 0.05);
                noise.frequency.exponentialRampToValueAtTime(200, now + 0.15);
                noiseGain.gain.setValueAtTime(0.15, now + 0.05);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                noise.connect(noiseGain);
                noiseGain.connect(ctx.destination);
                noise.start(now + 0.05);
                noise.stop(now + 0.2);

            } catch (e) {
                console.log('Audio not supported');
            }
        }

        // Clear dropped items meshes when leaving planet
        function clearDroppedItemMeshes() {
            for (const mesh of droppedItemMeshes) {
                scene.remove(mesh);
                mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            droppedItemMeshes = [];
        }

        // ===========================================
        // END v6.34 FEATURES
        // ===========================================

        // v6.51: Slot-based vertical stacking with duplicate suppression
        // Based on consensus from 8 strategy analyzers - simpler and more reliable than spiral/collision
        // v6.65: Screen-space aware slot system to prevent overlapping floaters from different sources
        const floaterSlots = [];  // Active floaters with screen positions
        const MAX_FLOATER_SLOTS = 12;
        const SLOT_HEIGHT = 38;   // Vertical spacing between floaters
        const PROXIMITY_THRESHOLD = 120; // Horizontal proximity in pixels to consider "same area"
        const recentMessages = new Map();  // For duplicate suppression
        const DUPLICATE_WINDOW = 250;  // ms - suppress identical messages within this window

        function spawnFloater(pos, text, color='#fff', isCrit=false) {
            const now = performance.now();

            // v6.51: Duplicate suppression - skip or consolidate identical messages
            const msgKey = text + color;
            const recent = recentMessages.get(msgKey);
            if (recent && now - recent.time < DUPLICATE_WINDOW) {
                // Update existing floater with count if still visible
                recent.count++;
                if (recent.floater && recent.floater.active) {
                    const baseText = text.replace(/ x\d+$/, ''); // Remove existing multiplier
                    recent.floater.el.textContent = `${baseText} x${recent.count}`;
                    recent.time = now;
                    return; // Skip creating new floater
                }
            }

            // Use pool
            let floater = floaterPool.find(f => !f.active);
            if (!floater) {
                floater = floaterPool[0]; // Reuse oldest
            }

            floater.active = true;
            floater.el.textContent = text;
            floater.el.style.color = color;
            floater.el.style.display = 'block';
            floater.el.style.animation = 'none';
            floater.el.className = isCrit ? 'floater crit' : 'floater';
            floater.el.offsetHeight; // Trigger reflow
            floater.el.style.animation = isCrit ? 'floatUpCrit 1.8s forwards' : 'floatUp 1.5s forwards';

            // Project 3D position to screen
            // v6.64: Handle both Vector3 and plain objects
            const v = pos.clone ? pos.clone() : new THREE.Vector3(pos.x || 0, pos.y || 0, pos.z || 0);
            v.y += 2;
            v.project(camera);
            let baseX = (v.x * .5 + .5) * window.innerWidth;
            let baseY = (-(v.y * .5) + .5) * window.innerHeight;

            // v6.51: Clean expired slots
            for (let i = floaterSlots.length - 1; i >= 0; i--) {
                if (now >= floaterSlots[i].expiresAt) {
                    floaterSlots.splice(i, 1);
                }
            }

            // v6.65: Screen-space collision detection - check if position overlaps any existing floater
            // Keep pushing up until we find a clear spot
            let x = baseX + (Math.random() - 0.5) * 30; // Small horizontal jitter
            let y = baseY;

            // Check for collisions and move up until clear
            for (let attempts = 0; attempts < MAX_FLOATER_SLOTS; attempts++) {
                let hasCollision = false;
                for (const slot of floaterSlots) {
                    const dx = Math.abs(slot.screenX - baseX);
                    const dy = Math.abs(slot.screenY - y);
                    // Check if within collision box (horizontally close AND vertically overlapping)
                    if (dx < PROXIMITY_THRESHOLD && dy < SLOT_HEIGHT) {
                        hasCollision = true;
                        break;
                    }
                }
                if (!hasCollision) break;
                y -= SLOT_HEIGHT; // Move up one slot
            }

            // Reserve the slot with screen position for proximity checks
            const lifetime = isCrit ? 1700 : 1400;
            floaterSlots.push({
                screenX: baseX,
                screenY: y,
                expiresAt: now + lifetime
            });

            // Track for duplicate suppression
            recentMessages.set(msgKey, { time: now, count: 1, floater: floater });

            // Clean old message tracking entries
            if (recentMessages.size > 50) {
                for (const [key, val] of recentMessages) {
                    if (now - val.time > DUPLICATE_WINDOW * 2) {
                        recentMessages.delete(key);
                    }
                }
            }

            floater.el.style.left = x + 'px';
            floater.el.style.top = y + 'px';

            setTimeout(() => {
                floater.el.style.display = 'none';
                floater.active = false;
            }, lifetime);
        }

        // ===========================================
        // v6.52: LEGACY CONSTELLATION SYSTEM
        // Your actions write stars in the sky - a visual history of your journey
        // Based on 8-agent consensus: 10/10 confidence rating
        // ===========================================
        const legacyConstellations = {
            stars: [],           // Array of earned constellation stars
            lines: [],           // Lines connecting stars into shapes
            constellationGroup: null,  // THREE.Group for rendering
            initialized: false,

            // Constellation definitions - shapes formed from achievements
            CONSTELLATION_DEFS: {
                // First Kill - "The Blade" constellation
                firstBlood: {
                    name: "The Blade",
                    trigger: { stat: 'mobsKilled', value: 1 },
                    stars: [
                        { offset: [0, 0, 0], size: 3, color: 0xff4444 },
                        { offset: [15, 25, 10], size: 2, color: 0xff6666 },
                        { offset: [30, 60, 20], size: 2.5, color: 0xff8888 }
                    ],
                    lines: [[0, 1], [1, 2]],
                    description: "First blood drawn in the cosmos"
                },
                // Explorer - "The Compass" constellation
                explorer: {
                    name: "The Compass",
                    trigger: { stat: 'planetsVisited', value: 3 },
                    stars: [
                        { offset: [0, 0, 0], size: 4, color: 0x44ff44 },
                        { offset: [0, 40, 0], size: 2, color: 0x66ff66 },
                        { offset: [40, 0, 0], size: 2, color: 0x66ff66 },
                        { offset: [0, -40, 0], size: 2, color: 0x66ff66 },
                        { offset: [-40, 0, 0], size: 2, color: 0x66ff66 }
                    ],
                    lines: [[0, 1], [0, 2], [0, 3], [0, 4]],
                    description: "The wanderer who charts new worlds"
                },
                // Warrior - "The Shield" constellation
                warrior: {
                    name: "The Shield",
                    trigger: { stat: 'mobsKilled', value: 50 },
                    stars: [
                        { offset: [0, 30, 0], size: 3, color: 0xffaa00 },
                        { offset: [-25, 15, 5], size: 2, color: 0xffbb44 },
                        { offset: [25, 15, -5], size: 2, color: 0xffbb44 },
                        { offset: [-20, -20, 10], size: 2.5, color: 0xffcc66 },
                        { offset: [20, -20, -10], size: 2.5, color: 0xffcc66 },
                        { offset: [0, -35, 0], size: 2, color: 0xffdd88 }
                    ],
                    lines: [[0, 1], [0, 2], [1, 3], [2, 4], [3, 5], [4, 5]],
                    description: "Protector of the weak, destroyer of evil"
                },
                // Boss Slayer - "The Crown" constellation
                bossSlayer: {
                    name: "The Crown",
                    trigger: { stat: 'bossesDefeated', value: 1 },
                    stars: [
                        { offset: [0, 50, 0], size: 5, color: 0xffd700 },
                        { offset: [-30, 30, 10], size: 3, color: 0xffe44d },
                        { offset: [30, 30, -10], size: 3, color: 0xffe44d },
                        { offset: [-50, 10, 15], size: 2.5, color: 0xffee80 },
                        { offset: [50, 10, -15], size: 2.5, color: 0xffee80 },
                        { offset: [-40, 0, 20], size: 2, color: 0xfff4b3 },
                        { offset: [40, 0, -20], size: 2, color: 0xfff4b3 }
                    ],
                    lines: [[0, 1], [0, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 6]],
                    description: "Slayer of titans, bearer of the crown"
                },
                // Master Crafter - "The Anvil" constellation
                crafter: {
                    name: "The Anvil",
                    trigger: { stat: 'itemsCrafted', value: 10 },
                    stars: [
                        { offset: [0, 0, 0], size: 4, color: 0x8888ff },
                        { offset: [-30, 0, 10], size: 3, color: 0x9999ff },
                        { offset: [30, 0, -10], size: 3, color: 0x9999ff },
                        { offset: [0, -25, 0], size: 3.5, color: 0xaaaaff },
                        { offset: [-40, -25, 15], size: 2, color: 0xbbbbff },
                        { offset: [40, -25, -15], size: 2, color: 0xbbbbff }
                    ],
                    lines: [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4], [3, 5]],
                    description: "Forger of destiny, shaper of stars"
                },
                // Survivor - "The Phoenix" constellation
                survivor: {
                    name: "The Phoenix",
                    trigger: { stat: 'nearDeathSurvived', value: 5 },
                    stars: [
                        { offset: [0, 60, 0], size: 4, color: 0xff6600 },
                        { offset: [-20, 40, 10], size: 2.5, color: 0xff8833 },
                        { offset: [20, 40, -10], size: 2.5, color: 0xff8833 },
                        { offset: [-40, 20, 20], size: 2, color: 0xffaa66 },
                        { offset: [40, 20, -20], size: 2, color: 0xffaa66 },
                        { offset: [0, 0, 0], size: 3, color: 0xffcc99 },
                        { offset: [-15, -30, 10], size: 2, color: 0xffeedd },
                        { offset: [15, -30, -10], size: 2, color: 0xffeedd }
                    ],
                    lines: [[0, 1], [0, 2], [1, 3], [2, 4], [1, 5], [2, 5], [5, 6], [5, 7]],
                    description: "Rose from ashes, defied death itself"
                },
                // Legendary Hunter - "The Beast" constellation
                legendaryHunter: {
                    name: "The Beast",
                    trigger: { stat: 'mobsKilled', value: 500 },
                    stars: [
                        { offset: [0, 50, 0], size: 5, color: 0xff0066 },
                        { offset: [-35, 40, 15], size: 3, color: 0xff3388 },
                        { offset: [35, 40, -15], size: 3, color: 0xff3388 },
                        { offset: [-50, 20, 25], size: 2.5, color: 0xff66aa },
                        { offset: [50, 20, -25], size: 2.5, color: 0xff66aa },
                        { offset: [-30, 0, 15], size: 3, color: 0xff99cc },
                        { offset: [30, 0, -15], size: 3, color: 0xff99cc },
                        { offset: [0, -20, 0], size: 4, color: 0xffccee }
                    ],
                    lines: [[0, 1], [0, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 7], [6, 7]],
                    description: "Apex predator of the cosmos"
                },
                // World Traveler - "The Spiral" constellation
                worldTraveler: {
                    name: "The Spiral",
                    trigger: { stat: 'planetsVisited', value: 10 },
                    stars: [
                        { offset: [0, 0, 0], size: 5, color: 0x00ffff },
                        { offset: [20, 15, 10], size: 3, color: 0x33ffff },
                        { offset: [35, 35, 5], size: 2.5, color: 0x66ffff },
                        { offset: [40, 60, -5], size: 2, color: 0x99ffff },
                        { offset: [30, 85, -15], size: 2, color: 0xccffff },
                        { offset: [10, 100, -25], size: 3, color: 0xffffff }
                    ],
                    lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]],
                    description: "Traverser of galaxies, seeker of wonders"
                }
            },

            // Initialize constellation rendering
            init() {
                if (this.initialized) return;
                this.initialized = true;

                // Load saved constellations
                if (gameData.legacyConstellations) {
                    this.stars = gameData.legacyConstellations.stars || [];
                }

                // Create THREE group for constellations
                this.constellationGroup = new THREE.Group();
                this.constellationGroup.name = 'legacyConstellations';

                console.log('[Legacy Constellation] System initialized');
            },

            // Check if new constellations should be unlocked
            checkUnlocks() {
                if (!gameData.statistics) return;

                const stats = gameData.statistics;
                stats.planetsVisited = gameData.visitedPlanets?.length || 0;

                for (const [id, def] of Object.entries(this.CONSTELLATION_DEFS)) {
                    // Skip already unlocked
                    if (this.stars.find(s => s.constellationId === id)) continue;

                    // Check trigger condition
                    const statValue = stats[def.trigger.stat] || 0;
                    if (statValue >= def.trigger.value) {
                        this.unlockConstellation(id, def);
                    }
                }
            },

            // Unlock a new constellation with fanfare
            unlockConstellation(id, def) {
                // Generate base position in galaxy space (far from center)
                const angle = Math.random() * Math.PI * 2;
                const distance = 1600 + Math.random() * 300;
                const basePos = {
                    x: Math.cos(angle) * distance,
                    y: (Math.random() - 0.5) * 400,
                    z: Math.sin(angle) * distance
                };

                // Store constellation data
                this.stars.push({
                    constellationId: id,
                    name: def.name,
                    description: def.description,
                    unlockedAt: Date.now(),
                    basePos: basePos,
                    starDefs: def.stars,
                    lineDefs: def.lines
                });

                // Save to gameData
                gameData.legacyConstellations = { stars: this.stars };
                saveGameData();

                // Show notification
                showNotification(` NEW CONSTELLATION: ${def.name}`, 'legendary');
                spawnFloater(worldState.player?.position || { x: 0, y: 5, z: 0 }, ` ${def.name} written in stars!`, '#ffd700', true);

                // Play celestial sound
                AudioSystem.playGentle(AudioSystem.penta.C5, 0.4, 0.3);
                setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.E5, 0.35, 0.25), 150);
                setTimeout(() => AudioSystem.playGentle(AudioSystem.penta.G5, 0.3, 0.2), 300);

                console.log(`[Legacy Constellation] Unlocked: ${def.name}`);
            },

            // Render constellations in galaxy view
            renderToScene(targetScene) {
                if (!this.constellationGroup) this.init();

                // Clear previous render
                while (this.constellationGroup.children.length > 0) {
                    this.constellationGroup.remove(this.constellationGroup.children[0]);
                }

                // Render each unlocked constellation
                for (const constellation of this.stars) {
                    const group = new THREE.Group();
                    group.position.set(constellation.basePos.x, constellation.basePos.y, constellation.basePos.z);

                    // Create stars
                    const starMeshes = [];
                    for (const starDef of constellation.starDefs) {
                        const starGeo = new THREE.SphereGeometry(starDef.size, 8, 8);
                        const starMat = new THREE.MeshBasicMaterial({
                            color: starDef.color,
                            transparent: true,
                            opacity: 0.9
                        });
                        const star = new THREE.Mesh(starGeo, starMat);
                        star.position.set(starDef.offset[0], starDef.offset[1], starDef.offset[2]);

                        // Add glow
                        const glowGeo = new THREE.SphereGeometry(starDef.size * 2, 8, 8);
                        const glowMat = new THREE.MeshBasicMaterial({
                            color: starDef.color,
                            transparent: true,
                            opacity: 0.3
                        });
                        const glow = new THREE.Mesh(glowGeo, glowMat);
                        star.add(glow);

                        group.add(star);
                        starMeshes.push(star);
                    }

                    // Create constellation lines
                    if (constellation.lineDefs) {
                        for (const [startIdx, endIdx] of constellation.lineDefs) {
                            const startPos = starMeshes[startIdx]?.position;
                            const endPos = starMeshes[endIdx]?.position;
                            if (startPos && endPos) {
                                const lineGeo = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                                const lineMat = new THREE.LineBasicMaterial({
                                    color: 0xffffff,
                                    transparent: true,
                                    opacity: 0.4
                                });
                                const line = new THREE.Line(lineGeo, lineMat);
                                group.add(line);
                            }
                        }
                    }

                    // Store name for tooltip
                    group.userData.constellationName = constellation.name;
                    group.userData.constellationDesc = constellation.description;

                    this.constellationGroup.add(group);
                }

                targetScene.add(this.constellationGroup);
            },

            // Get constellation count for UI
            getCount() {
                return this.stars.length;
            },

            // Get all unlocked constellation names
            getUnlocked() {
                return this.stars.map(s => s.name);
            }
        };

        // ===========================================
        // v6.52: TEMPORAL MOMENTUM REVERSAL SYSTEM
        // Rewind your POSITION but keep all combat progress
        // Based on 8-agent consensus: 10/10 confidence rating
        // ===========================================
        const temporalRewind = {
            positionHistory: [],     // Ring buffer of position snapshots
            MAX_HISTORY: 300,        // ~30 seconds at 10fps recording
            RECORD_INTERVAL: 100,    // Record every 100ms
            lastRecordTime: 0,
            isRewinding: false,
            rewindProgress: 0,
            rewindStartIndex: 0,
            REWIND_SPEED: 3,         // 3x speed rewind
            ENERGY_COST_PER_SECOND: 10,
            ghostMesh: null,
            trailMeshes: [],
            cooldown: 0,
            COOLDOWN_TIME: 5000,     // 5 second cooldown after use

            // Initialize the system
            init() {
                this.positionHistory = [];
                this.lastRecordTime = 0;
                console.log('[Temporal Rewind] System initialized - Press V to rewind time');
            },

            // Record current position (called from game loop)
            recordPosition(playerPos, rotation, time) {
                if (this.isRewinding) return;
                if (time - this.lastRecordTime < this.RECORD_INTERVAL) return;

                this.lastRecordTime = time;

                // Add to history
                this.positionHistory.push({
                    x: playerPos.x,
                    y: playerPos.y,
                    z: playerPos.z,
                    rotY: rotation,
                    time: time
                });

                // Trim to max size (ring buffer)
                while (this.positionHistory.length > this.MAX_HISTORY) {
                    this.positionHistory.shift();
                }
            },

            // Start rewinding
            startRewind() {
                if (this.isRewinding) return false;
                if (this.positionHistory.length < 10) {
                    showNotification('Not enough temporal data to rewind', 'warning');
                    return false;
                }
                if (this.cooldown > 0) {
                    showNotification(`Temporal rewind cooling down: ${Math.ceil(this.cooldown / 1000)}s`, 'warning');
                    return false;
                }
                if (gameData.player.energy < this.ENERGY_COST_PER_SECOND) {
                    showNotification('Not enough energy to rewind time', 'warning');
                    return false;
                }

                this.isRewinding = true;
                this.rewindStartIndex = this.positionHistory.length - 1;
                this.rewindProgress = this.rewindStartIndex;

                // Create ghost trail effect
                this.createGhostTrail();

                // Play rewind sound
                AudioSystem.playGentle(AudioSystem.penta.G4, 0.5, 0.2);

                showNotification(' TEMPORAL REWIND ACTIVE - Release V to stop', 'info');
                console.log('[Temporal Rewind] Started rewinding from index', this.rewindStartIndex);

                return true;
            },

            // Update rewind (called from game loop while V is held)
            updateRewind(player, dt) {
                if (!this.isRewinding) return;

                // Energy cost
                const energyCost = this.ENERGY_COST_PER_SECOND * dt;
                if (gameData.player.energy < energyCost) {
                    this.stopRewind();
                    showNotification('Ran out of energy!', 'warning');
                    return;
                }
                gameData.player.energy -= energyCost;
                updateEnergyUI();

                // Move backwards through history
                this.rewindProgress -= this.REWIND_SPEED * dt * 10; // ~30 positions per second

                if (this.rewindProgress <= 0) {
                    this.rewindProgress = 0;
                    this.stopRewind();
                    return;
                }

                // Get interpolated position
                const index = Math.floor(this.rewindProgress);
                const frac = this.rewindProgress - index;

                if (index >= 0 && index < this.positionHistory.length - 1) {
                    const curr = this.positionHistory[index];
                    const next = this.positionHistory[index + 1];

                    // Interpolate position
                    player.position.x = curr.x + (next.x - curr.x) * frac;
                    player.position.y = curr.y + (next.y - curr.y) * frac;
                    player.position.z = curr.z + (next.z - curr.z) * frac;
                    player.rotation.y = curr.rotY + (next.rotY - curr.rotY) * frac;
                }

                // Update ghost trail
                this.updateGhostTrail();
            },

            // Stop rewinding
            stopRewind() {
                if (!this.isRewinding) return;

                this.isRewinding = false;

                // Trim history to current position (can't go forward again)
                const trimIndex = Math.floor(this.rewindProgress);
                this.positionHistory = this.positionHistory.slice(0, trimIndex + 1);

                // Start cooldown
                this.cooldown = this.COOLDOWN_TIME;

                // Clear ghost trail
                this.clearGhostTrail();

                // Play exit sound
                AudioSystem.playGentle(AudioSystem.penta.C5, 0.4, 0.15);

                const secondsRewound = ((this.rewindStartIndex - this.rewindProgress) * this.RECORD_INTERVAL / 1000).toFixed(1);
                showNotification(` Rewound ${secondsRewound}s - Combat progress preserved!`, 'info');
                spawnFloater(worldState.player?.position || { x: 0, y: 5, z: 0 }, ` -${secondsRewound}s`, '#00ffff', true);

                console.log('[Temporal Rewind] Stopped at index', trimIndex);
            },

            // Create visual trail showing rewind path
            createGhostTrail() {
                if (!scene || !worldState.player) return;

                this.clearGhostTrail();

                // Create trail line
                const points = this.positionHistory.map(p => new THREE.Vector3(p.x, p.y + 1, p.z));
                if (points.length > 1) {
                    const trailGeo = new THREE.BufferGeometry().setFromPoints(points);
                    const trailMat = new THREE.LineBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const trail = new THREE.Line(trailGeo, trailMat);
                    trail.name = 'temporalTrail';
                    scene.add(trail);
                    this.trailMeshes.push(trail);
                }

                // Create ghost at start position
                const ghostGeo = new THREE.SphereGeometry(1, 8, 8);
                const ghostMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5
                });
                this.ghostMesh = new THREE.Mesh(ghostGeo, ghostMat);
                this.ghostMesh.name = 'temporalGhost';
                scene.add(this.ghostMesh);
            },

            // Update ghost trail position
            updateGhostTrail() {
                if (!this.ghostMesh) return;

                const index = Math.floor(this.rewindProgress);
                if (index >= 0 && index < this.positionHistory.length) {
                    const pos = this.positionHistory[index];
                    this.ghostMesh.position.set(pos.x, pos.y + 1, pos.z);

                    // Pulse effect
                    const pulse = 0.8 + Math.sin(performance.now() * 0.01) * 0.3;
                    this.ghostMesh.scale.setScalar(pulse);
                }
            },

            // Clear ghost trail meshes
            clearGhostTrail() {
                if (this.ghostMesh && scene) {
                    scene.remove(this.ghostMesh);
                    this.ghostMesh = null;
                }
                for (const mesh of this.trailMeshes) {
                    if (scene) scene.remove(mesh);
                }
                this.trailMeshes = [];
            },

            // Update cooldown
            updateCooldown(dt) {
                if (this.cooldown > 0) {
                    this.cooldown -= dt * 1000;
                    if (this.cooldown < 0) this.cooldown = 0;
                }
            }
        };

        // ===========================================
        // v6.52: QUANTUM WRECKAGE ARCHAEOLOGY SYSTEM
        // Destroyed enemies become persistent debris that evolves over time
        // Based on 8-agent consensus: 10/10 confidence rating
        // ===========================================
        const quantumWreckage = {
            wreckage: [],            // Active wreckage pieces
            MAX_WRECKAGE: 50,        // Limit for performance
            EVOLUTION_INTERVAL: 30000, // Check evolution every 30 seconds
            lastEvolutionCheck: 0,
            wreckageGroup: null,

            // Wreckage evolution stages
            EVOLUTION_STAGES: {
                fresh: {
                    duration: 60000,  // 1 minute
                    color: 0x884444,
                    emissive: 0x220000,
                    scale: 1.0,
                    description: 'Fresh wreckage - still warm'
                },
                cooling: {
                    duration: 120000, // 2 minutes
                    color: 0x666666,
                    emissive: 0x000000,
                    scale: 0.9,
                    description: 'Cooling debris'
                },
                rusted: {
                    duration: 300000, // 5 minutes
                    color: 0x885533,
                    emissive: 0x110500,
                    scale: 0.85,
                    description: 'Oxidizing wreckage'
                },
                overgrown: {
                    duration: 600000, // 10 minutes
                    color: 0x338844,
                    emissive: 0x001100,
                    scale: 0.8,
                    description: 'Nature reclaiming the debris'
                },
                crystallized: {
                    duration: Infinity,
                    color: 0x8888ff,
                    emissive: 0x222288,
                    scale: 0.75,
                    harvestable: true,
                    harvestItem: 'Crystallized Essence',
                    harvestAmount: 1,
                    description: 'Ancient crystallized remains - harvestable!'
                }
            },

            // Initialize wreckage system
            init() {
                this.wreckageGroup = new THREE.Group();
                this.wreckageGroup.name = 'quantumWreckage';

                // Load saved wreckage
                if (gameData.quantumWreckage) {
                    this.wreckage = gameData.quantumWreckage;
                }

                console.log('[Quantum Wreckage] System initialized');
            },

            // Spawn wreckage when enemy dies
            spawnWreckage(position, enemyType, enemyData) {
                if (!this.wreckageGroup) this.init();

                // Create wreckage data
                const wreckageData = {
                    id: Date.now() + Math.random(),
                    x: position.x + (Math.random() - 0.5) * 2,
                    y: position.y,
                    z: position.z + (Math.random() - 0.5) * 2,
                    enemyType: enemyType || 'unknown',
                    createdAt: Date.now(),
                    stage: 'fresh',
                    harvested: false,
                    scale: 0.3 + Math.random() * 0.4
                };

                this.wreckage.push(wreckageData);

                // Enforce limit
                while (this.wreckage.length > this.MAX_WRECKAGE) {
                    const oldest = this.wreckage.shift();
                    this.removeWreckageMesh(oldest.id);
                }

                // Create mesh
                this.createWreckageMesh(wreckageData);

                // Save periodically
                gameData.quantumWreckage = this.wreckage;
            },

            // Create visual mesh for wreckage
            createWreckageMesh(data) {
                if (!scene) return;

                const stage = this.EVOLUTION_STAGES[data.stage];

                // Create irregular debris shape
                const geo = new THREE.DodecahedronGeometry(data.scale * stage.scale, 0);
                const mat = new THREE.MeshStandardMaterial({
                    color: stage.color,
                    emissive: stage.emissive,
                    roughness: 0.8,
                    metalness: 0.3
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(data.x, data.y + data.scale * 0.5, data.z);
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.wreckageId = data.id;
                mesh.userData.isWreckage = true;
                mesh.userData.stage = data.stage;
                mesh.name = `wreckage_${data.id}`;

                this.wreckageGroup.add(mesh);

                // Add to scene if in world mode
                if (mode === 'world' && !scene.getObjectByName('quantumWreckage')) {
                    scene.add(this.wreckageGroup);
                }
            },

            // Remove wreckage mesh by ID
            removeWreckageMesh(id) {
                const mesh = this.wreckageGroup?.getObjectByName(`wreckage_${id}`);
                if (mesh) {
                    this.wreckageGroup.remove(mesh);
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                }
            },

            // Update wreckage evolution
            updateEvolution(time) {
                if (time - this.lastEvolutionCheck < this.EVOLUTION_INTERVAL) return;
                this.lastEvolutionCheck = time;

                const now = Date.now();
                let evolved = false;

                for (const wreck of this.wreckage) {
                    const age = now - wreck.createdAt;
                    const currentStage = this.EVOLUTION_STAGES[wreck.stage];

                    // Check if should evolve to next stage
                    if (age > currentStage.duration) {
                        const stages = Object.keys(this.EVOLUTION_STAGES);
                        const currentIdx = stages.indexOf(wreck.stage);

                        if (currentIdx < stages.length - 1) {
                            wreck.stage = stages[currentIdx + 1];
                            this.updateWreckageMesh(wreck);
                            evolved = true;

                            // Special notification for crystallized
                            if (wreck.stage === 'crystallized') {
                                showNotification(' Ancient wreckage has crystallized - harvest it!', 'info');
                            }
                        }
                    }
                }

                if (evolved) {
                    gameData.quantumWreckage = this.wreckage;
                    saveGameData();
                }
            },

            // Update mesh appearance for evolution
            updateWreckageMesh(data) {
                const mesh = this.wreckageGroup?.getObjectByName(`wreckage_${data.id}`);
                if (!mesh) return;

                const stage = this.EVOLUTION_STAGES[data.stage];

                mesh.material.color.setHex(stage.color);
                mesh.material.emissive.setHex(stage.emissive);
                mesh.scale.setScalar(data.scale * stage.scale);
                mesh.userData.stage = data.stage;

                // Add glow for crystallized
                if (data.stage === 'crystallized' && !mesh.userData.hasGlow) {
                    const glowGeo = new THREE.DodecahedronGeometry(data.scale * stage.scale * 1.3, 0);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0x8888ff,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    mesh.add(glow);
                    mesh.userData.hasGlow = true;
                }
            },

            // Harvest crystallized wreckage
            harvestWreckage(wreckageId) {
                const wreck = this.wreckage.find(w => w.id === wreckageId);
                if (!wreck || wreck.stage !== 'crystallized' || wreck.harvested) return false;

                const stage = this.EVOLUTION_STAGES.crystallized;

                // Add item to inventory
                addToInventory(stage.harvestItem, stage.harvestAmount);

                wreck.harvested = true;

                // Visual feedback
                spawnFloater({ x: wreck.x, y: wreck.y + 1, z: wreck.z }, `+${stage.harvestAmount} ${stage.harvestItem}`, '#8888ff', true);

                // Remove mesh with particles
                if (particles) {
                    particles.emit({ x: wreck.x, y: wreck.y + 0.5, z: wreck.z }, 15, 0x8888ff, { spread: 2 });
                }

                this.removeWreckageMesh(wreckageId);
                this.wreckage = this.wreckage.filter(w => w.id !== wreckageId);

                gameData.quantumWreckage = this.wreckage;
                saveGameData();

                // Track statistic
                gameData.statistics.wreckageHarvested = (gameData.statistics.wreckageHarvested || 0) + 1;

                return true;
            },

            // Check if player is near harvestable wreckage
            checkNearbyHarvestable(playerPos) {
                for (const wreck of this.wreckage) {
                    if (wreck.stage !== 'crystallized' || wreck.harvested) continue;

                    const dist = Math.sqrt(
                        Math.pow(playerPos.x - wreck.x, 2) +
                        Math.pow(playerPos.z - wreck.z, 2)
                    );

                    if (dist < 3) {
                        return wreck;
                    }
                }
                return null;
            },

            // Render all wreckage to scene
            renderToScene(targetScene) {
                if (!this.wreckageGroup) this.init();

                // Clear and rebuild
                while (this.wreckageGroup.children.length > 0) {
                    const child = this.wreckageGroup.children[0];
                    this.wreckageGroup.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }

                // Recreate meshes for current planet's wreckage
                for (const wreck of this.wreckage) {
                    this.createWreckageMesh(wreck);
                }

                targetScene.add(this.wreckageGroup);
            },

            // Get wreckage count by stage
            getCountByStage() {
                const counts = {};
                for (const wreck of this.wreckage) {
                    counts[wreck.stage] = (counts[wreck.stage] || 0) + 1;
                }
                return counts;
            }
        };

        // --- INPUT HANDLERS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy' && galaxyGroup) {
                // v6.40: Check for black hole hover (tesseract entry hint)
                if (lensingMesh) {
                    const blackHoleHits = raycaster.intersectObject(lensingMesh, true);
                    if (blackHoleHits.length > 0) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong style="color:#ff00ff"> EVENT HORIZON</strong><br>The supermassive black hole<br>at the galaxy's center<br><span style="color:#ff88ff"> Click to enter the 4D Tesseract</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }

                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong>${civ.name}</strong><br>Biome: ${civ.biomeName}<br>Pop: ${civ.pop}M${civ.visited ? '<br><span style="color:#0f0">Visited</span>' : ''}<br><span style="color:#888"> Click to Begin Landing Sequence</span>`;
                        document.body.style.cursor = 'pointer';

                        if (selectionRing) {
                            selectionRing.visible = true;
                            selectionRing.position.copy(obj.position);
                        }

                        // v6.27: Show orbital path when hovering over a star
                        if (hoveredCivForOrbit !== civ) {
                            hoveredCivForOrbit = civ;
                            showOrbitalPath(civ);
                        }
                        return;
                    }
                }
            } else if (mode === 'world') {
                // v5.6: Check for Copilot Companion hover
                if (copilotMesh) {
                    const copilotHits = raycaster.intersectObject(copilotMesh, true);
                    if (copilotHits.length > 0) {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) {
                            copilotTooltip.style.display = 'block';
                            copilotTooltip.style.left = e.clientX + 15 + 'px';
                            copilotTooltip.style.top = e.clientY - 30 + 'px';
                        }
                        document.body.style.cursor = 'pointer';
                        return;
                    } else {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) copilotTooltip.style.display = 'none';
                    }
                }

                // v6.68: Include hostile creeps and towers in clickable targets
                const hostileCreeps = (creepWaveState.creeps || []).filter(c => c && c.userData?.team === 'B');
                const hostileTowers = (laneSupportState.laneTowers || []).filter(t => t && t.team !== 'robot' && t.mesh).map(t => t.mesh);
                const allTargets = [...worldState.interactables, ...worldState.mobs, ...hostileCreeps, ...hostileTowers];

                const hits = raycaster.intersectObjects(allTargets, true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        const hpText = obj.userData.hp !== undefined ? `<br>HP: ${obj.userData.hp}/${obj.userData.maxHp}` : '';
                        // v6.68: Show team info for creeps/towers
                        const teamText = obj.userData.team === 'B' ? '<br><span style="color:#ff4444">HOSTILE FAUNA</span>' :
                                        obj.userData.type === 'hostileTower' ? '<br><span style="color:#ff4444">ENEMY TOWER</span>' : '';
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong>${hpText}${teamText}<br><span style="color:#888">Click to Attack</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy' && selectionRing) selectionRing.visible = false;

            // v6.27: Hide orbital path when not hovering over any star
            if (mode === 'galaxy' && hoveredCivForOrbit) {
                hoveredCivForOrbit = null;
                hideOrbitalPath();
            }
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            // v5.6: Check for Copilot Companion click first
            if (checkCopilotClick(e)) {
                return; // Copilot was clicked, don't process other clicks
            }

            if(mode === 'galaxy' && galaxyGroup) {
                // v6.40: Check for black hole click first (tesseract entry)
                if (lensingMesh) {
                    const blackHoleHits = raycaster.intersectObject(lensingMesh, true);
                    if (blackHoleHits.length > 0) {
                        showBlackHoleEntryPrompt();
                        return;
                    }
                }

                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        // v6.33: Planet approach cinematic before landing
                        startPlanetApproach(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                // v6.68: Include hostile creeps and towers in clickable targets
                const hostileCreeps = (creepWaveState.creeps || []).filter(c => c && c.userData?.team === 'B');
                const hostileTowers = (laneSupportState.laneTowers || []).filter(t => t && t.team !== 'robot' && t.mesh).map(t => t.mesh);
                const allTargets = [...worldState.interactables, ...worldState.mobs, ...hostileCreeps, ...hostileTowers];

                const hits = raycaster.intersectObjects(allTargets, true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    const targetColor = obj.userData.team === 'B' || obj.userData.type === 'hostileTower' ? '#ff4444' : '#0ff';
                    spawnFloater(obj.position, "Targeting...", targetColor);
                    return;
                }

                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null;

                    const m = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                    );
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(() => scene.remove(m), 400);
                }
            }
        }

        // Touch handlers
        let touchStartPos = null;

        // v6.87: Pinch-to-zoom and two-finger rotation state (8-strategy consensus)
        let initialPinchDistance = null;
        let lastPinchDistance = null;
        let lastTwoFingerCenter = null;
        const MIN_ZOOM = 50;
        const MAX_ZOOM = 500;

        // v4.3: Virtual Joystick state
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        const joystickMaxDist = 40;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                // Reset pinch state when single finger
                initialPinchDistance = null;
                lastPinchDistance = null;
                lastTwoFingerCenter = null;
            } else if (e.touches.length === 2) {
                // v6.87: Initialize pinch-to-zoom and two-finger rotation
                touchStartPos = null; // Cancel tap-to-select
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDistance = Math.hypot(dx, dy);
                lastPinchDistance = initialPinchDistance;
                lastTwoFingerCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            } else if (e.touches.length === 2 && initialPinchDistance !== null && camera) {
                // v6.87: Pinch-to-zoom camera control
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentPinchDistance = Math.hypot(dx, dy);

                // Zoom based on pinch delta
                const pinchDelta = lastPinchDistance - currentPinchDistance;
                const zoomSpeed = 0.5;
                camera.position.z = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM,
                    camera.position.z + pinchDelta * zoomSpeed));
                lastPinchDistance = currentPinchDistance;

                // v6.87: Two-finger drag for camera rotation (optional orbit)
                if (lastTwoFingerCenter) {
                    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const rotDeltaX = centerX - lastTwoFingerCenter.x;
                    const rotDeltaY = centerY - lastTwoFingerCenter.y;

                    // Apply subtle camera rotation based on center movement
                    if (Math.abs(rotDeltaX) > 2 || Math.abs(rotDeltaY) > 2) {
                        const rotateSpeed = 0.003;
                        camera.rotation.y -= rotDeltaX * rotateSpeed;
                        // Clamp vertical rotation
                        camera.rotation.x = Math.max(-0.5, Math.min(0.5,
                            camera.rotation.x + rotDeltaY * rotateSpeed));
                    }
                    lastTwoFingerCenter = { x: centerX, y: centerY };
                }
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            // Reset pinch state when fingers lifted
            if (e.touches.length < 2) {
                initialPinchDistance = null;
                lastPinchDistance = null;
                lastTwoFingerCenter = null;
            }
            // Only trigger tap action if it was a single-finger tap
            if (touchStartPos && e.touches.length === 0) {
                raycaster.setFromCamera(mouse, camera);
                onMouseDown({ clientX: touchStartPos.x, clientY: touchStartPos.y });
                touchStartPos = null;
            }
        }

        function onTouchAction() {
            // Quick action button - interact with nearest target
            if (mode === 'world' && worldState.interactTarget) {
                performAction(worldState.interactTarget);
            }
        }

        function onKeyDown(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v6.1: F1 or ? for keyboard shortcuts overlay
            if (e.key === 'F1' || e.key === '?') {
                e.preventDefault();
                toggleShortcutsOverlay();
                return;
            }

            // v6.1: F3 for performance metrics overlay
            if (e.key === 'F3') {
                e.preventDefault();
                togglePerfMetrics();
                return;
            }

            // v6.35: 'S' key to toggle settings panel in galaxy mode
            if ((e.key === 's' || e.key === 'S') && mode === 'galaxy' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                toggleSettingsPanel();
                return;
            }

            // v6.56: 'G' key to toggle Civilization Genesis mode (skip in world mode where G is gear)
            if ((e.key === 'g' || e.key === 'G') && mode !== 'world' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                toggleGenesisMode();
                return;
            }

            // v6.95: 'M' key to open Galaxy Manager (Multiverse navigation)
            if ((e.key === 'm' || e.key === 'M') && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                openGalaxyManager();
                return;
            }

            // v6.52: V key - TEMPORAL REWIND in world mode, Copilot voice otherwise
            if (e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                // In world mode: Start temporal rewind
                if (mode === 'world' && worldState.player) {
                    temporalRewind.startRewind();
                    return;
                }
                // Otherwise: Open Copilot chat and start voice listening
                if (!copilotChatOpen) {
                    toggleCopilotChat();
                }
                // Small delay to ensure chat is open before starting voice
                setTimeout(() => {
                    if (!copilotIsListening) {
                        toggleCopilotVoice();
                    }
                }, 100);
                return;
            }

            // Spacebar: If Copilot chat is open, trigger voice instead of dodge
            if (e.key === ' ') {
                if (copilotChatOpen) {
                    e.preventDefault();
                    if (!copilotIsListening) {
                        toggleCopilotVoice();
                    } else {
                        // If already listening, stop (toggle behavior)
                        stopCopilotVoice();
                    }
                    return;
                }
            }

            // v6.5.0: Escape: Exit Agent Observer Mode first
            if (e.key === 'Escape' && agentObserverMode.active) {
                exitAgentObserverMode();
                e.preventDefault();
                return;
            }

            // Escape: Close Copilot chat if open
            if (e.key === 'Escape' && copilotChatOpen) {
                toggleCopilotChat();
                e.preventDefault();
                return;
            }

            // v6.0: F key for Follow Mode toggle (multiplayer viewers only)
            if (e.key === 'f' || e.key === 'F') {
                if (multiplayerState.enabled && !multiplayerState.isHost && mode === 'world') {
                    e.preventDefault();
                    toggleFollowMode();
                    return;
                }
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyDown(e);
                return;
            }

            // v6.51: WASD and Arrow Keys for movement (ergonomic flexibility)
            // Arrow keys map to WASD: UpW, DownS, LeftA, RightD
            // Skip arrow key movement when ant farm view is active (uses arrows for panning)
            const key = e.key.toLowerCase();
            const isArrowKey = key.startsWith('arrow');

            // When ant farm is active, don't map arrow keys to movement
            if (isArrowKey && antFarmState.active) {
                return; // Let ant farm handler deal with arrow keys
            }

            const arrowToWASD = {
                'arrowup': 'w',
                'arrowdown': 's',
                'arrowleft': 'a',
                'arrowright': 'd'
            };
            const mappedKey = arrowToWASD[key] || key;

            if (mappedKey in keys) {
                keys[mappedKey] = true;
                e.preventDefault();
            }

            // Number keys 1-9 to use inventory items
            if (mode === 'world' && e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                useInventoryItem(idx);
            }
            // E to eat food
            if (e.key === 'e' || e.key === 'E') {
                const foodIdx = gameData.inventory.findIndex(item =>
                    item && (item.name === 'Cooked Fish' || item.name === 'Health Potion')
                );
                if (foodIdx >= 0) useInventoryItem(foodIdx);
            }
            // H for help/tutorial
            if (e.key === 'h' || e.key === 'H') {
                showTutorial();
            }
            // v5.5: M to toggle autopilot exploration
            if ((e.key === 'm' || e.key === 'M') && mode === 'world') {
                toggleAutoExplore();
            }
            // v6.68: L to toggle Lane Push AI
            if ((e.key === 'l' || e.key === 'L') && mode === 'world') {
                toggleLanePushAI();
                e.preventDefault();
            }
            // v4.5: Space or Shift to dodge (space only if chat not open)
            // v5.12: Space also breaks hypnosis
            if (e.key === ' ' || e.key === 'Shift') {
                if (mode === 'world' && !copilotChatOpen) {
                    // Check if hypnotized - SPACE breaks hypnosis
                    if (HYPNOSIS_STATE.active && e.key === ' ') {
                        attemptBreakHypnosis();
                        e.preventDefault();
                        return;
                    }
                    startDodge();
                    e.preventDefault();
                }
            }
            // v4.8: Combat abilities Q/E/R (v4.9: Extended with Tier 2 T/F/Z/X/C)
            if (mode === 'world') {
                if (e.key === 'q' || e.key === 'Q') {
                    useAbility('powerStrike');
                    e.preventDefault();
                }
                if (e.key === 'e' || e.key === 'E') {
                    // E is now abilities, but keep food eating as fallback if no ability ready
                    if (!useAbility('whirlwind')) {
                        const foodIdx = gameData.inventory.findIndex(item =>
                            item && (item.name === 'Cooked Fish' || item.name === 'Health Potion' || item.name === 'Super Potion')
                        );
                        if (foodIdx >= 0) useInventoryItem(foodIdx);
                    }
                    e.preventDefault();
                }
                if (e.key === 'r' || e.key === 'R') {
                    useAbility('warcry');
                    e.preventDefault();
                }
                // v4.9: Tier 2 Abilities
                if (e.key === 't' || e.key === 'T') {
                    useAbility('heal');
                    e.preventDefault();
                }
                if (e.key === 'f' || e.key === 'F') {
                    useAbility('dash');
                    e.preventDefault();
                }
                if (e.key === 'z' || e.key === 'Z') {
                    useAbility('shieldWall');
                    e.preventDefault();
                }
                if (e.key === 'x' || e.key === 'X') {
                    useAbility('execute');
                    e.preventDefault();
                }
                if (e.key === 'c' || e.key === 'C') {
                    useAbility('berserk');
                    e.preventDefault();
                }
                // v6.42: Chrono-Echo ability
                if (e.key === 'b' || e.key === 'B') {
                    useAbility('chronoEcho');
                    e.preventDefault();
                }
            }
        }

        function onKeyUp(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v6.52: Stop temporal rewind when V is released
            if ((e.key === 'v' || e.key === 'V') && temporalRewind.isRewinding) {
                temporalRewind.stopRewind();
                return;
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyUp(e);
                return;
            }

            // v6.51: WASD and Arrow Keys for movement (ergonomic flexibility)
            const key = e.key.toLowerCase();
            const isArrowKey = key.startsWith('arrow');

            // When ant farm is active, don't process arrow key releases for movement
            if (isArrowKey && antFarmState.active) {
                return;
            }

            const arrowToWASD = {
                'arrowup': 'w',
                'arrowdown': 's',
                'arrowleft': 'a',
                'arrowright': 'd'
            };
            const mappedKey = arrowToWASD[key] || key;

            if (mappedKey in keys) {
                keys[mappedKey] = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            // v6.97: Save planet surface state before leaving
            if (activeCiv) {
                savePlanetSurface(activeCiv.id);
            }

            saveGameData();

            // v6.42: Clear Chrono-Echo ghosts when leaving planet
            if (typeof chronoEchoSystem !== 'undefined') {
                chronoEchoSystem.clearGhosts();
                chronoEchoSystem.clearHistory();
            }

            // v6.32: Hyperspace jump when leaving planet (8-agent consensus)
            triggerHyperspaceJump(1500, () => {
                // At midpoint, do the actual transition
                clearDroppedItemMeshes();
                initGalaxy();
                activeCiv = null;
                // Stop combat music when returning to galaxy
                AudioSystem.stopCombatMusic();
            });
        }

        // --- INVENTORY & RPG ---
        function addItem(name) {
            const itemDef = ITEMS[name];
            if (!itemDef) return false;

            // v4.9: Track item in codex
            trackItemDiscovery(name);

            // Find existing stack
            if (itemDef.stackable) {
                const existing = gameData.inventory.find(item =>
                    item && item.name === name && item.count < (itemDef.maxStack || 99)
                );
                if (existing) {
                    existing.count++;
                    updateInventoryUI();
                    return true;
                }
            }

            // Add new slot
            if (gameData.inventory.length < 20) {
                gameData.inventory.push({ name, count: 1 });
                updateInventoryUI();
                return true;
            }

            // v6.42: Debounce to prevent spam
            const now = performance.now();
            if (worldState.player && now - _lastInventoryFullMsg > INVENTORY_FULL_MSG_COOLDOWN) {
                _lastInventoryFullMsg = now;
                spawnFloater(worldState.player.position, "Inventory full!", '#f44');
            }
            return false;
        }

        function removeItem(name, count = 1) {
            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (item && item.name === name) {
                    item.count -= count;
                    if (item.count <= 0) {
                        gameData.inventory.splice(i, 1);
                    }
                    updateInventoryUI();
                    return true;
                }
            }
            return false;
        }

        function hasItem(name, count = 1) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item && item.count >= count;
        }

        function countItem(name) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item ? item.count : 0;
        }

        function useInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const def = ITEMS[item.name];

            // v5.1: Check if item is equippable
            if (isEquippable(item.name)) {
                equipItem(item.name);
                updateInventoryUI();
                return;
            }

            // Use consumables
            if (def && def.heal) {
                if (gameData.player.hp < gameData.player.maxHp) {
                    healPlayer(def.heal);
                    removeItem(item.name, 1);
                } else {
                    showNotification('Health is already full!');
                }
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            gameData.inventory.forEach((item, idx) => {
                if (!item) return;
                const def = ITEMS[item.name] || { icon: '?' };
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                const itemCount = item.count || item.amount || 1;

                // v4.8: Build detailed tooltip (v6.13: Added right-click to drop)
                const priority = getItemPriority(item.name);
                const priorityLabel = priority >= 4 ? ' Rare' : priority >= 3 ? ' Good' : priority >= 2 ? ' Common' : ' Basic';
                const tooltip = buildItemTooltip(item.name, def, itemCount) + `\n\n[${priorityLabel}]\nRight-click to drop`;
                slot.title = tooltip;

                slot.innerHTML = `${def.icon}<div class="inv-count">${itemCount}</div>`;
                slot.onclick = () => useInventoryItem(idx);

                // v6.13: Right-click to drop item
                slot.oncontextmenu = (e) => {
                    e.preventDefault();
                    dropInventoryItem(idx);
                };

                grid.appendChild(slot);
            });

            // Fill empty slots
            for (let i = gameData.inventory.length; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }

            document.getElementById('inv-count').textContent = gameData.inventory.length;
        }

        // v6.13: Drop item from inventory (manual clearing)
        function dropInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const itemName = item.name;
            const amount = item.amount || item.count || 1;

            // Remove from inventory
            gameData.inventory.splice(idx, 1);

            // Visual feedback
            if (worldState.player) {
                const dropPos = worldState.player.position.clone();
                dropPos.y += 1.5;
                spawnFloater(dropPos, ` Dropped: ${itemName}`, '#ff8800');

                if (particles) {
                    particles.emit(dropPos, 8, 0xff8800, { spread: 2, lifetime: 500 });
                }
            }

            showNotification(`Dropped ${itemName} x${amount}`, 'info');
            updateInventoryUI();
            saveGameData();
        }

        // v6.13: Clear all low priority items from inventory
        function clearLowPriorityItems() {
            if (!gameData.inventory || gameData.inventory.length === 0) {
                showNotification('Inventory is empty!', 'info');
                return;
            }

            const threshold = 2; // Clear items with priority 1 and 2
            const toRemove = [];
            let clearedCount = 0;

            for (let i = gameData.inventory.length - 1; i >= 0; i--) {
                const item = gameData.inventory[i];
                if (!item) continue;

                const priority = getItemPriority(item.name);
                if (priority <= threshold) {
                    toRemove.push(i);
                    clearedCount++;
                }
            }

            if (toRemove.length === 0) {
                showNotification('No low priority items to clear!', 'info');
                return;
            }

            // Remove items (in reverse order to avoid index shifting)
            toRemove.forEach(idx => {
                gameData.inventory.splice(idx, 1);
            });

            // Visual feedback
            if (worldState.player) {
                const dropPos = worldState.player.position.clone();
                dropPos.y += 2;
                spawnFloater(dropPos, ` Cleared ${clearedCount} items!`, '#ff8800');

                if (particles) {
                    particles.emit(dropPos, 20, 0xff8800, { spread: 4, lifetime: 800 });
                }
            }

            showNotification(`Cleared ${clearedCount} low priority items!`, 'success');
            updateInventoryUI();
            saveGameData();
        }

        // v4.8: Build detailed item tooltip
        function buildItemTooltip(name, def, count) {
            let lines = [name];

            // Add quantity for stackable items
            if (def.stackable && count > 1) {
                lines[0] += ` (x${count})`;
            }

            // Healing items
            if (def.heal) {
                lines.push(`Heals ${def.heal} HP`);
                lines.push('Click or press E to use');
            }

            // Combat bonuses
            if (def.combatBonus) {
                lines.push(`Combat: +${def.combatBonus} damage`);
            }

            // Defense
            if (def.defenseBonus) {
                lines.push(`Defense: +${def.defenseBonus}`);
            }

            // Mining/Tool bonuses
            if (def.miningBonus) {
                lines.push(`Mining: x${def.miningBonus} yield`);
            }
            if (def.fishingBonus) {
                lines.push(`Fishing: x${def.fishingBonus} yield`);
            }

            // Elemental
            if (def.element) {
                const elementNames = { ice: 'Ice (Slow)', fire: 'Fire (Burn)', void: 'Void (Weaken)', cosmic: 'Cosmic (All)' };
                lines.push(`Element: ${elementNames[def.element] || def.element}`);
            }

            // Lifesteal
            if (def.lifesteal) {
                lines.push(`Lifesteal: ${Math.floor(def.lifesteal * 100)}%`);
            }

            // Attack speed
            if (def.attackSpeedMult) {
                lines.push(`Attack Speed: +${Math.floor((def.attackSpeedMult - 1) * 100)}%`);
            }

            // Max stack info for materials
            if (def.stackable && def.maxStack) {
                lines.push(`Max Stack: ${def.maxStack}`);
            }

            return lines.join('\\n');
        }

        function addXp(skill, amt) {
            if (!gameData.skills[skill]) return;

            // v4.4: Apply prestige XP multiplier
            let multiplier = gameData.prestige?.bonuses?.xpMultiplier || 1.0;

            // v5.3: Apply portal XP multiplier
            multiplier *= getPortalXpMultiplier();

            // v5.3: Apply mastery XP bonus
            const masteryBonuses = getMasteryBonuses();
            // v5.3: Apply talent XP bonus
            const talentBonuses = getTalentBonuses();
            multiplier *= (1 + (talentBonuses.xpBonus || 0));

            // v5.3: Apply rarity item XP bonus
            const rarityBonuses = getRarityBonuses();
            multiplier *= (1 + (rarityBonuses.xpBonus || 0));

            // v5.4: Apply showcase milestone XP bonus
            const showcaseBonuses = getShowcaseBonuses();
            multiplier *= (1 + (showcaseBonuses.xpBonus || 0) + (showcaseBonuses.allBonus || 0));

            // v5.4: Apply world event XP bonus
            const eventBonuses = getWorldEventBonuses();
            multiplier *= (eventBonuses.xpMultiplier || 1);

            // v5.4: Apply evolution XP bonus
            const evolutionBonuses = getEvolutionBonuses();
            multiplier *= (1 + (evolutionBonuses.xpBonus || 0));

            const adjustedAmt = Math.round(amt * multiplier);

            const oldLevel = gameData.skills[skill].level;
            gameData.skills[skill].xp += adjustedAmt;

            // Check level up
            const newLevel = Math.floor(Math.sqrt(gameData.skills[skill].xp / 100)) + 1;
            gameData.skills[skill].level = newLevel;

            if (newLevel > oldLevel) {
                showNotification(`${skill.charAt(0).toUpperCase() + skill.slice(1)} leveled up to ${newLevel}!`);
                AudioSystem.levelUp(); // v4.0
                // v6.35: Chronicle Engine - capture skill level up
                if (typeof captureChronicleEvent === 'function') {
                    captureChronicleEvent('skill_levelup', { skill: skill, newLevel: newLevel, oldLevel: oldLevel });
                }
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `LEVEL UP!`, '#ffff00');
                    // v4.0: Level up particle burst
                    if (particles) particles.emit(worldState.player.position, 25, 0xffff00, { spread: 6, lifetime: 1500, gravity: 3 });
                    // v5.15: Robot celebrate animation
                    triggerRobotAnimation('celebrate');
                }
            }

            updateSkillsUI();
        }

        function updateSkillsUI() {
            const skills = ['mining', 'wood', 'combat', 'fishing', 'cooking', 'crafting'];

            skills.forEach(skill => {
                const data = gameData.skills[skill];
                if (!data) return;

                const level = data.level;
                const xp = data.xp;
                const nextLevelXp = Math.pow(level, 2) * 100;
                const prevLevelXp = Math.pow(level - 1, 2) * 100;
                const progress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

                const lvlEl = document.getElementById(`lvl-${skill}`);
                const barEl = document.getElementById(`bar-${skill}`);

                if (lvlEl) lvlEl.textContent = level;
                if (barEl) barEl.style.width = Math.min(100, progress) + '%';
            });

            // v5.2: Update talent points button
            const talentBtn = document.getElementById('talent-points-btn');
            if (talentBtn) {
                const points = getTalentPoints();
                talentBtn.textContent = points.available;
                talentBtn.parentElement.style.borderColor = points.available > 0 ? '#ff0' : '#ffd700';
                talentBtn.parentElement.style.animation = points.available > 0 ? 'ability-ready-pulse 2s infinite' : 'none';
            }
        }

        // v6.82: Cached DOM references for health UI (eliminates 4 getElementById calls per update)
        let _healthUICache = null;
        function getHealthUICache() {
            if (!_healthUICache) {
                _healthUICache = {
                    bar: document.getElementById('player-health-bar'),
                    fill: document.getElementById('player-health-fill'),
                    text: document.getElementById('health-text'),
                    vignette: document.getElementById('low-hp-vignette')
                };
            }
            return _healthUICache;
        }

        function updateHealthUI() {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const percent = (hp / maxHp) * 100;

            const cache = getHealthUICache();
            const healthBar = cache.bar;
            const healthFill = cache.fill;
            const healthText = cache.text;

            if (healthFill) {
                healthFill.style.width = percent + '%';
                // v5.15.2: Update fill color based on health level
                healthFill.classList.remove('low', 'critical');
                if (percent <= 25) {
                    healthFill.classList.add('critical');
                } else if (percent <= 50) {
                    healthFill.classList.add('low');
                }
            }
            if (healthText) {
                healthText.textContent = `${Math.round(hp)} / ${maxHp}`;
            }
            // v5.15.2: Update bar border for critical state
            if (healthBar) {
                healthBar.classList.toggle('critical', percent <= 25);
            }

            // v6.8: Critical health heartbeat audio (Agent consensus - Audio Enhancement)
            if (typeof AudioSystem !== 'undefined' && AudioSystem.updateHeartbeat) {
                AudioSystem.updateHeartbeat(percent / 100);
            }

            // v6.32: Low HP warning vignette effect (v6.82: use cached ref)
            const vignette = cache.vignette;
            if (vignette) {
                vignette.classList.remove('active', 'critical');
                if (percent <= 25) {
                    vignette.classList.add('active', 'critical');
                } else if (percent <= 50) {
                    vignette.classList.add('active');
                }
            }

            // v6.72: Also update Dota-style HP bars
            if (typeof updateDotaBarsUI === 'function') {
                updateDotaBarsUI();
            }
        }

        // v6.41: Cached DOM references for ability UI (eliminates 24 getElementById calls per frame)
        let _abilityUICache = null;
        function _cacheAbilityUIElements() {
            _abilityUICache = {};
            const keys = ['q', 'e', 'r', 't', 'f', 'z', 'x', 'c', 'b']; // v6.42: Added 'b' for Chrono-Echo
            keys.forEach(key => {
                _abilityUICache[key] = {
                    slot: document.getElementById(`ability-${key}`),
                    cooldown: document.getElementById(`cooldown-${key}`),
                    text: document.getElementById(`cooldown-text-${key}`)
                };
            });
            _abilityUICache.berserkOverlay = document.getElementById('berserk-overlay');
            _abilityUICache.shieldOverlay = document.getElementById('shield-overlay');
        }

        // v4.8: Update ability UI cooldowns and states (v4.9: Extended with Tier 2, v6.8: Numeric timers)
        function updateAbilityUI() {
            // v6.41: Initialize DOM cache on first call
            if (!_abilityUICache) _cacheAbilityUIElements();

            const abilities = [
                // Tier 1
                { key: 'q', id: 'powerStrike' },
                { key: 'e', id: 'whirlwind' },
                { key: 'r', id: 'warcry' },
                // v4.9: Tier 2
                { key: 't', id: 'heal' },
                { key: 'f', id: 'dash' },
                { key: 'z', id: 'shieldWall' },
                { key: 'x', id: 'execute' },
                { key: 'c', id: 'berserk' },
                // v6.42: Chrono-Echo
                { key: 'b', id: 'chronoEcho' }
            ];

            abilities.forEach(({ key, id }) => {
                const cached = _abilityUICache[key];
                const slotEl = cached.slot;
                const cdEl = cached.cooldown;
                const cdTextEl = cached.text; // v6.8: Numeric timer element
                const ability = COMBAT_ABILITIES[id];

                if (!slotEl || !cdEl) return;

                // Check if unlocked
                const unlocked = isAbilityUnlocked(id);
                slotEl.classList.toggle('locked', !unlocked);

                // Check cooldown
                const cdRemaining = getAbilityCooldownRemaining(id);
                const onCooldown = cdRemaining > 0;
                slotEl.classList.toggle('on-cooldown', onCooldown);

                // Show cooldown overlay
                if (onCooldown) {
                    const cdPercent = (cdRemaining / ability.cooldown) * 100;
                    cdEl.style.height = cdPercent + '%';
                    // v6.8: Show numeric seconds remaining (Agent consensus - UI/UX)
                    if (cdTextEl) {
                        const seconds = Math.ceil(cdRemaining / 1000);
                        cdTextEl.textContent = seconds > 0 ? seconds : '';
                    }
                } else {
                    cdEl.style.height = '0%';
                    // v6.8: Clear numeric timer when ready
                    if (cdTextEl) cdTextEl.textContent = '';
                }

                // Special: Buff active states
                if (id === 'warcry' && isWarcryActive()) {
                    slotEl.classList.add('active-buff');
                } else if (id === 'warcry') {
                    slotEl.classList.remove('active-buff');
                }
                // v4.9: Shield Wall active state
                if (id === 'shieldWall' && isShieldWallActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#4488ff';
                    slotEl.style.boxShadow = '0 0 10px #4488ff';
                } else if (id === 'shieldWall') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
                // v4.9: Berserk active state
                if (id === 'berserk' && isBerserkActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#ff4400';
                    slotEl.style.boxShadow = '0 0 15px #ff4400';
                } else if (id === 'berserk') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
                // v6.42: Chrono-Echo active state (ghosts are active)
                if (id === 'chronoEcho' && isChronoEchoActive()) {
                    slotEl.classList.add('active-buff');
                } else if (id === 'chronoEcho') {
                    slotEl.classList.remove('active-buff');
                }
            });

            // v4.9: Update buff overlays (v6.41: using cached references)
            if (_abilityUICache.berserkOverlay) {
                _abilityUICache.berserkOverlay.style.opacity = isBerserkActive() ? '1' : '0';
            }
            if (_abilityUICache.shieldOverlay) {
                _abilityUICache.shieldOverlay.style.opacity = isShieldWallActive() ? '1' : '0';
            }
        }

        // v6.92: Improved playtime display with clear hours/minutes labels
        function updatePlaytimeDisplay() {
            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            const secs = total % 60;
            // Show hours if > 0, always show minutes and seconds for clarity
            if (hours > 0) {
                document.getElementById('total-playtime').textContent = `${hours}h ${mins}m`;
            } else {
                document.getElementById('total-playtime').textContent = `${mins}m ${secs}s`;
            }
        }

        // --- CRAFTING ---
        // v6.7: Updated to support batch crafting (Agent consensus - QoL)
        function craft(recipeId, quantity = 1) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            // v4.2: Check crafting level requirement
            if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                showNotification(`Requires Crafting level ${recipe.craftingLevel}!`, 'error');
                AudioSystem.error();
                return;
            }

            // v6.7: Calculate max craftable amount
            let maxCraftable = Infinity;
            for (const [item, count] of Object.entries(recipe.requires)) {
                const available = countItem(item);
                maxCraftable = Math.min(maxCraftable, Math.floor(available / count));
            }

            // Limit quantity to what's possible
            const actualQty = Math.min(quantity, maxCraftable);
            if (actualQty <= 0) {
                // Show what's missing
                for (const [item, count] of Object.entries(recipe.requires)) {
                    if (!hasItem(item, count)) {
                        showNotification(`Need ${count}x ${item}!`, 'error');
                        break;
                    }
                }
                AudioSystem.error();
                return;
            }

            // Consume materials for all crafts
            for (const [item, count] of Object.entries(recipe.requires)) {
                removeItem(item, count * actualQty);
            }

            // Add results
            for (let i = 0; i < actualQty; i++) {
                addItem(recipe.result);
            }
            addXp('crafting', 30 * actualQty);
            if (recipeId === 'cookedFish') {
                addXp('cooking', 25 * actualQty);
                gameData.statistics.fishCooked = (gameData.statistics.fishCooked || 0) + actualQty;
            }
            gameData.statistics.itemsCrafted += actualQty;

            // v4.1: Check achievements and daily progress
            checkAchievements();
            updateDailyChallengeProgress();

            showNotification(`Crafted ${actualQty}x ${recipe.result}!`);
            AudioSystem.craft();
            updateCraftingUI();
        }

        // v6.7: Batch craft helper - craft maximum possible (Agent consensus - QoL)
        function craftMax(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            let maxCraftable = Infinity;
            for (const [item, count] of Object.entries(recipe.requires)) {
                const available = countItem(item);
                maxCraftable = Math.min(maxCraftable, Math.floor(available / count));
            }

            if (maxCraftable > 0 && maxCraftable < Infinity) {
                craft(recipeId, maxCraftable);
            } else {
                showNotification('No materials for batch crafting!', 'error');
                AudioSystem.error();
            }
        }

        // v6.7: Count items in inventory (helper for batch crafting)
        // v6.83: Optimized to use reduce instead of filter (avoids creating intermediate array)
        function countItem(itemName) {
            return gameData.inventory.reduce((count, i) => count + (i === itemName ? 1 : 0), 0);
        }

        // v4.2: Enhanced crafting UI with level requirements and new recipes
        function updateCraftingUI() {
            const recipeDisplayNames = {
                'pickaxe': 'Pickaxe',
                'sword': 'Sword',
                'rod': 'Fishing Rod',
                'cookedFish': 'Cooked Fish',
                'potion': 'Health Potion',
                'frostBlade': 'Frost Blade',
                'magmaSword': 'Magma Sword',
                'voidDagger': 'Void Dagger',
                'crystalPickaxe': 'Crystal Pickaxe',
                'superPotion': 'Super Potion',
                'chitinArmor': 'Chitin Armor'
            };

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const btn = document.getElementById(`craft-${id}`);
                if (!btn) continue;

                let canCraft = true;
                let reqParts = [];

                // v4.2: Check level requirement
                if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                    canCraft = false;
                    reqParts.push(`Lvl ${recipe.craftingLevel} req`);
                }

                for (const [item, count] of Object.entries(recipe.requires)) {
                    const have = countItem(item);
                    if (have < count) canCraft = false;
                    reqParts.push(`${have}/${count} ${item}`);
                }
                btn.disabled = !canCraft;
                btn.innerHTML = `${recipeDisplayNames[id] || recipe.result}<br><small style="opacity:0.7">${reqParts.join(', ')}</small>`;
            }
        }

        // --- MINIMAP ---
        let minimapCtx;
        let lastMinimapUpdate = 0; // v6.6: Throttle variable for 10 FPS updates

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 100;
            canvas.height = 100;
            minimapCtx = canvas.getContext('2d');
        }

        // v4.4: Update fog of war exploration
        function updateExploration() {
            if (!worldState.player || !activeCiv) return;

            const planetId = activeCiv.id;
            if (!gameData.exploredTiles[planetId]) {
                gameData.exploredTiles[planetId] = {};
            }

            // Mark tiles within vision radius as explored
            const px = Math.floor(worldState.player.position.x / 10);
            const pz = Math.floor(worldState.player.position.z / 10);
            const visionRadius = 3;

            for (let dx = -visionRadius; dx <= visionRadius; dx++) {
                for (let dz = -visionRadius; dz <= visionRadius; dz++) {
                    if (dx * dx + dz * dz <= visionRadius * visionRadius) {
                        const key = `${px + dx},${pz + dz}`;
                        gameData.exploredTiles[planetId][key] = 1;
                    }
                }
            }
        }

        function isTileExplored(planetId, worldX, worldZ) {
            const tx = Math.floor(worldX / 10);
            const tz = Math.floor(worldZ / 10);
            const key = `${tx},${tz}`;
            return gameData.exploredTiles[planetId]?.[key] === 1;
        }

        function updateMinimap() {
            if (!minimapCtx || !worldState.player) return;

            // v4.4: Update exploration tracking
            updateExploration();

            const ctx = minimapCtx;
            const size = 100;
            // v6.62: Fixed minimap scale to use actual world extent (WORLD_SIZE * TILE_SIZE)
            const worldExtent = CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE;
            const halfExtent = worldExtent / 2; // Half-extent for coordinate offset (world is centered at 0,0)
            const scale = size / worldExtent;
            const planetId = activeCiv?.id;

            // Clear with fog of war (darker)
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, size, size);

            // v4.4: Draw explored areas lighter
            if (planetId && gameData.exploredTiles[planetId]) {
                ctx.fillStyle = '#181818';
                for (const key in gameData.exploredTiles[planetId]) {
                    const [tx, tz] = key.split(',').map(Number);
                    const x = (tx * 10 + halfExtent) * scale;
                    const y = (tz * 10 + halfExtent) * scale;
                    ctx.fillRect(x - 5 * scale, y - 5 * scale, 10 * scale, 10 * scale);
                }
            }

            // Draw terrain bounds
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0, 0, size, size);

            // v6.67: Draw lane paths on minimap
            if (typeof LANE_DEFINITIONS !== 'undefined' && creepWaveState?.enabled) {
                Object.entries(LANE_DEFINITIONS).forEach(([laneKey, lane]) => {
                    const colorHex = '#' + lane.color.toString(16).padStart(6, '0');

                    // Draw lane path
                    ctx.strokeStyle = colorHex;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();

                    lane.waypoints.forEach((wp, idx) => {
                        const x = (wp.x + halfExtent) * scale;
                        const y = (wp.z + halfExtent) * scale;
                        if (idx === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();

                    // Draw spawn points (small squares)
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = '#00ccff'; // Robot spawn - cyan
                    const spawnAx = (lane.teamASpawn.x + halfExtent) * scale;
                    const spawnAy = (lane.teamASpawn.z + halfExtent) * scale;
                    ctx.fillRect(spawnAx - 3, spawnAy - 3, 6, 6);

                    ctx.fillStyle = '#ff4444'; // Hostile spawn - red
                    const spawnBx = (lane.teamBSpawn.x + halfExtent) * scale;
                    const spawnBy = (lane.teamBSpawn.z + halfExtent) * scale;
                    ctx.fillRect(spawnBx - 3, spawnBy - 3, 6, 6);

                    // Draw choke point marker (pulsing circle)
                    const chokeWp = lane.waypoints[lane.chokePointIndex];
                    const chokeX = (chokeWp.x + halfExtent) * scale;
                    const chokeY = (chokeWp.z + halfExtent) * scale;

                    // Outer ring
                    ctx.strokeStyle = colorHex;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(chokeX, chokeY, 5, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner dot (contested zone)
                    const pulse = Math.sin(performance.now() / 300) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = colorHex;
                    ctx.beginPath();
                    ctx.arc(chokeX, chokeY, 3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 1.0;
                });

                // Draw creeps on minimap
                if (creepWaveState.creeps) {
                    creepWaveState.creeps.forEach(creep => {
                        if (!creep.userData) return;
                        const cx = (creep.position.x + halfExtent) * scale;
                        const cy = (creep.position.z + halfExtent) * scale;

                        // Team color
                        ctx.fillStyle = creep.userData.team === 'A' ? '#00ffaa' : '#ff6666';
                        ctx.beginPath();
                        ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }

            // Draw interactables (only in explored areas)
            ctx.fillStyle = '#0a0';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'tree') {
                    const x = (obj.position.x + halfExtent) * scale;
                    const y = (obj.position.z + halfExtent) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            ctx.fillStyle = '#888';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'rock') {
                    const x = (obj.position.x + halfExtent) * scale;
                    const y = (obj.position.z + halfExtent) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            // Draw mobs
            ctx.fillStyle = '#f00';
            worldState.mobs.forEach(mob => {
                const x = (mob.position.x + halfExtent) * scale;
                const y = (mob.position.z + halfExtent) * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // v4.2: Draw POIs
            worldState.pois.forEach(poi => {
                const x = (poi.position.x + halfExtent) * scale;
                const y = (poi.position.z + halfExtent) * scale;
                ctx.fillStyle = poi.userData.discovered ? '#666' : '#ffd700';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                if (!poi.userData.discovered) {
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // v5.13: Draw ship and landing zone
            if (SHIP_STATE.mesh) {
                const shipX = (SHIP_STATE.mesh.position.x + halfExtent) * scale;
                const shipY = (SHIP_STATE.mesh.position.z + halfExtent) * scale;

                // Landing zone circle
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(shipX, shipY, 6, 0, Math.PI * 2);
                ctx.stroke();

                // Ship icon
                ctx.fillStyle = SHIP_STATE.hp > 0 ? '#00ffff' : '#444';
                ctx.beginPath();
                ctx.moveTo(shipX, shipY - 4);
                ctx.lineTo(shipX + 3, shipY + 3);
                ctx.lineTo(shipX - 3, shipY + 3);
                ctx.closePath();
                ctx.fill();

                // Defense range indicator (subtle)
                if (SHIP_STATE.laser.autoDefend) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(shipX, shipY, SHIP_STATE.laser.range * scale, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // v5.16.1: Draw agents on minimap
            // v5.17: Enhanced with level indicators and combo effects
            agentFleet.forEach(agent => {
                if (!agent.mesh) return;
                const ax = (agent.mesh.position.x + halfExtent) * scale;
                const ay = (agent.mesh.position.z + halfExtent) * scale;

                // Get agent color
                const color = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');

                // v5.17: Draw combo aura when agent has high combo
                if (agent.combo >= 5) {
                    const comboIntensity = Math.min(agent.combo / 20, 1);
                    const pulse = Math.sin(performance.now() / 150) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 136, 0, ${comboIntensity * pulse})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 5 + agent.combo * 0.2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw highlight ring if highlighted
                if (agent.minimapHighlight) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Pulsing outer ring
                    const pulse = Math.sin(performance.now() / 200) * 0.5 + 0.5;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 8 + pulse * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw alert indicator
                if (agent.taskState?.alert) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(ax, ay, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (agent.taskState?.state === 'working') {
                    // v5.17: Working indicator - pulsing glow
                    const workPulse = Math.sin(performance.now() / 300) * 0.5 + 0.5;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 2.5 + workPulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                } else if (agent.taskState?.state === 'combat') {
                    // v5.17: Combat indicator - red flash
                    const combatPulse = Math.sin(performance.now() / 100) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(255, 68, 68, ${combatPulse})`;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Normal agent dot - size scales with level
                    const levelSize = 2 + agent.agentLevel * 0.2;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(ax, ay, levelSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // v6.0: Draw multiplayer positions - host and copilot in viewer mode
            if (multiplayerState.enabled && !multiplayerState.isHost) {
                // Draw host avatar position (cyan with label)
                const hostAvatar = multiplayerState.remotePlayers.get(multiplayerState.hostId);
                if (hostAvatar) {
                    const hx = (hostAvatar.position.x + halfExtent) * scale;
                    const hy = (hostAvatar.position.z + halfExtent) * scale;
                    ctx.fillStyle = '#0ff';
                    ctx.beginPath();
                    ctx.arc(hx, hy, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // HOST label
                    ctx.fillStyle = '#fff';
                    ctx.font = '7px Arial';
                    ctx.fillText('HOST', hx - 10, hy - 6);
                }

                // Draw copilot position (viewer's avatar) - yellow when active, dimmer when following
                if (copilotMesh) {
                    const cx = (copilotMesh.position.x + halfExtent) * scale;
                    const cy = (copilotMesh.position.z + halfExtent) * scale;
                    const isActiveMode = !multiplayerState.followMode;
                    ctx.fillStyle = isActiveMode ? '#ff0' : 'rgba(255, 255, 0, 0.4)';
                    ctx.beginPath();
                    ctx.arc(cx, cy, isActiveMode ? 3 : 2, 0, Math.PI * 2);
                    ctx.fill();
                    if (isActiveMode) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '7px Arial';
                        ctx.fillText('YOU', cx - 8, cy - 6);
                    }
                }
            } else {
                // Draw player (host or single player mode)
                ctx.fillStyle = '#ff0';
                const px = (worldState.player.position.x + halfExtent) * scale;
                const py = (worldState.player.position.z + halfExtent) * scale;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // v6.50: ANT FARM 3D ECOSYSTEM VIEW - Orbital camera around world cube
        const antFarmState = {
            active: false,
            savedCameraPos: null,
            savedCameraRot: null,
            savedCameraFov: null,
            // Orbital camera parameters (spherical coordinates)
            theta: 0,            // Horizontal rotation angle (radians)
            phi: Math.PI / 4,    // Vertical angle from top (radians) - start at 45 degrees
            distance: 400,       // Distance from target point
            minDistance: 50,
            maxDistance: 800,
            minPhi: 0.1,         // Minimum vertical angle (nearly top-down)
            maxPhi: Math.PI / 2 - 0.1,  // Maximum vertical angle (nearly horizontal)
            targetX: 0,
            targetY: 0,          // Can look at different heights
            targetZ: 0,
            isDragging: false,
            isRightDragging: false,  // For panning
            lastMouseX: 0,
            lastMouseY: 0,
            perspCamera: null,    // Use perspective for 3D cube view
            autoRotate: false,
            autoRotateSpeed: 0.002
        };

        function initAntFarmCamera() {
            if (!antFarmState.perspCamera) {
                const aspect = window.innerWidth / window.innerHeight;
                antFarmState.perspCamera = new THREE.PerspectiveCamera(60, aspect, 1, 5000);
            }
            updateAntFarmCamera();
        }

        function updateAntFarmCamera() {
            if (!antFarmState.perspCamera) return;

            const aspect = window.innerWidth / window.innerHeight;
            antFarmState.perspCamera.aspect = aspect;
            antFarmState.perspCamera.updateProjectionMatrix();

            // Calculate camera position using spherical coordinates
            // theta = horizontal rotation, phi = vertical angle from top
            const { theta, phi, distance, targetX, targetY, targetZ } = antFarmState;

            // Convert spherical to Cartesian coordinates
            // Camera orbits around the target point
            const camX = targetX + distance * Math.sin(phi) * Math.cos(theta);
            const camY = targetY + distance * Math.cos(phi);
            const camZ = targetZ + distance * Math.sin(phi) * Math.sin(theta);

            antFarmState.perspCamera.position.set(camX, camY, camZ);
            antFarmState.perspCamera.lookAt(targetX, targetY, targetZ);

            // Update zoom display showing distance
            const zoomEl = document.getElementById('ant-farm-zoom');
            if (zoomEl) {
                const zoomPercent = Math.round((antFarmState.maxDistance - distance) / (antFarmState.maxDistance - antFarmState.minDistance) * 100);
                zoomEl.textContent = `Distance: ${Math.round(distance)}m | Zoom: ${zoomPercent}%`;
            }
        }

        function toggleAntFarm() {
            if (mode !== 'world') return;

            antFarmState.active = !antFarmState.active;
            const overlay = document.getElementById('ant-farm-overlay');

            if (antFarmState.active) {
                // Save current camera state
                antFarmState.savedCameraPos = camera.position.clone();
                antFarmState.savedCameraRot = camera.rotation.clone();
                antFarmState.savedFog = scene.fog ? scene.fog.clone() : null;

                // Disable fog for ant farm view (so we can see the whole world)
                scene.fog = null;

                // Reset orbital camera to default position
                antFarmState.theta = Math.PI / 4;    // 45 degrees horizontal
                antFarmState.phi = Math.PI / 4;      // 45 degrees from top (isometric-ish)
                antFarmState.distance = 400;         // Start at medium distance
                antFarmState.targetX = 0;
                antFarmState.targetY = 10;           // Look slightly above ground
                antFarmState.targetZ = 0;
                antFarmState.autoRotate = false;

                // Force recreate camera
                antFarmState.perspCamera = null;
                initAntFarmCamera();

                // Show UI overlay
                if (overlay) overlay.classList.add('active');

                // Add wheel listener for zoom - use capture to get events first
                document.addEventListener('wheel', antFarmWheelHandler, { passive: false, capture: true });
                document.addEventListener('mousedown', antFarmMouseDown, { capture: true });
                document.addEventListener('mousemove', antFarmMouseMove, { capture: true });
                document.addEventListener('mouseup', antFarmMouseUp, { capture: true });
                document.addEventListener('contextmenu', antFarmContextMenu, { capture: true });

                showNotification(' 3D Ant Farm - Drag to orbit, Right-drag to pan, Scroll to zoom, A for auto-rotate', 'info');
            } else {
                // Restore camera
                if (antFarmState.savedCameraPos) {
                    camera.position.copy(antFarmState.savedCameraPos);
                    camera.rotation.copy(antFarmState.savedCameraRot);
                }

                // Restore fog
                if (antFarmState.savedFog) {
                    scene.fog = antFarmState.savedFog;
                }

                // Hide UI overlay
                if (overlay) overlay.classList.remove('active');

                // Remove listeners (must match capture: true)
                document.removeEventListener('wheel', antFarmWheelHandler, { capture: true });
                document.removeEventListener('mousedown', antFarmMouseDown, { capture: true });
                document.removeEventListener('mousemove', antFarmMouseMove, { capture: true });
                document.removeEventListener('mouseup', antFarmMouseUp, { capture: true });
                document.removeEventListener('contextmenu', antFarmContextMenu, { capture: true });
            }
        }

        function antFarmContextMenu(e) {
            if (antFarmState.active) {
                e.preventDefault();
            }
        }

        function antFarmWheelHandler(e) {
            if (!antFarmState.active) return;
            e.preventDefault();
            e.stopPropagation();

            // Zoom by changing distance from target
            const zoomSpeed = antFarmState.distance * 0.1; // Proportional zoom
            antFarmState.distance += e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            antFarmState.distance = Math.max(antFarmState.minDistance, Math.min(antFarmState.maxDistance, antFarmState.distance));

            updateAntFarmCamera();
        }

        function antFarmMouseDown(e) {
            if (!antFarmState.active) return;
            // Don't capture clicks on UI elements
            if (e.target.closest('.ant-farm-header, .ant-farm-stats, button, .modal-overlay')) return;

            e.preventDefault();
            e.stopPropagation();

            // Right-click or middle-click for panning
            if (e.button === 2 || e.button === 1) {
                antFarmState.isRightDragging = true;
            } else {
                // Left-click for orbital rotation
                antFarmState.isDragging = true;
                antFarmState.autoRotate = false; // Stop auto-rotate when manually rotating
            }

            antFarmState.lastMouseX = e.clientX;
            antFarmState.lastMouseY = e.clientY;
        }

        function antFarmMouseMove(e) {
            if (!antFarmState.active) return;
            if (!antFarmState.isDragging && !antFarmState.isRightDragging) return;

            e.preventDefault();
            e.stopPropagation();

            const dx = e.clientX - antFarmState.lastMouseX;
            const dy = e.clientY - antFarmState.lastMouseY;

            if (antFarmState.isDragging) {
                // Orbital rotation - drag to rotate around the cube
                const rotateSpeed = 0.005;
                antFarmState.theta -= dx * rotateSpeed;
                antFarmState.phi += dy * rotateSpeed;

                // Clamp phi to prevent flipping
                antFarmState.phi = Math.max(antFarmState.minPhi, Math.min(antFarmState.maxPhi, antFarmState.phi));
            }

            if (antFarmState.isRightDragging) {
                // Panning - move target point relative to camera orientation
                const panSpeed = antFarmState.distance * 0.002;

                // Calculate camera-relative pan directions
                const sinTheta = Math.sin(antFarmState.theta);
                const cosTheta = Math.cos(antFarmState.theta);

                // Pan in camera-relative X/Z plane
                antFarmState.targetX += (-dx * sinTheta + dy * cosTheta) * panSpeed;
                antFarmState.targetZ += (dx * cosTheta + dy * sinTheta) * panSpeed;
            }

            antFarmState.lastMouseX = e.clientX;
            antFarmState.lastMouseY = e.clientY;

            updateAntFarmCamera();
        }

        function antFarmMouseUp(e) {
            if (!antFarmState.active) return;
            if (antFarmState.isDragging || antFarmState.isRightDragging) {
                e.preventDefault();
                e.stopPropagation();
            }
            antFarmState.isDragging = false;
            antFarmState.isRightDragging = false;
        }

        function updateAntFarmStats() {
            if (!antFarmState.active) return;

            let treeCount = 0, rockCount = 0, fishCount = 0;

            // Traverse the entire scene to count objects - most reliable method
            if (scene) {
                scene.traverse(obj => {
                    if (!obj.userData) return;
                    const type = obj.userData.type;
                    if (type === 'tree') treeCount++;
                    else if (type === 'rock') rockCount++;
                    else if (type === 'fishing') fishCount++;
                });
            }

            const mobEl = document.getElementById('af-mob-count');
            const treeEl = document.getElementById('af-tree-count');
            const rockEl = document.getElementById('af-rock-count');
            const agentEl = document.getElementById('af-agent-count');
            const fishEl = document.getElementById('af-fish-count');

            if (mobEl) mobEl.textContent = worldState.mobs?.length || 0;
            if (treeEl) treeEl.textContent = treeCount;
            if (rockEl) rockEl.textContent = rockCount;
            if (agentEl) agentEl.textContent = agentFleet?.length || 0;
            if (fishEl) fishEl.textContent = fishCount;
        }

        // Ant farm keyboard controls
        document.addEventListener('keydown', (e) => {
            // N to toggle ant farm view
            if (e.key === 'n' || e.key === 'N') {
                if (mode === 'world' && !document.querySelector('.modal-overlay[style*="flex"]')) {
                    e.preventDefault();
                    toggleAntFarm();
                    return;
                }
            }

            // When ant farm is active, use keyboard for orbit/zoom/pan
            if (antFarmState.active) {
                const panSpeed = antFarmState.distance * 0.05;
                const zoomSpeed = antFarmState.distance * 0.1;
                const rotateSpeed = 0.1;

                // Q/E to rotate horizontally (orbit around)
                if (e.key === 'q' || e.key === 'Q') {
                    e.preventDefault();
                    antFarmState.theta += rotateSpeed;
                    antFarmState.autoRotate = false;
                    updateAntFarmCamera();
                }
                if (e.key === 'e' || e.key === 'E') {
                    e.preventDefault();
                    antFarmState.theta -= rotateSpeed;
                    antFarmState.autoRotate = false;
                    updateAntFarmCamera();
                }

                // R/F to tilt up/down (change elevation angle)
                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    antFarmState.phi = Math.max(antFarmState.minPhi, antFarmState.phi - rotateSpeed);
                    updateAntFarmCamera();
                }
                if (e.key === 'f' || e.key === 'F') {
                    e.preventDefault();
                    antFarmState.phi = Math.min(antFarmState.maxPhi, antFarmState.phi + rotateSpeed);
                    updateAntFarmCamera();
                }

                // Arrow keys to pan
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    antFarmState.targetZ -= panSpeed * Math.cos(antFarmState.theta);
                    antFarmState.targetX -= panSpeed * Math.sin(antFarmState.theta);
                    updateAntFarmCamera();
                }
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    antFarmState.targetZ += panSpeed * Math.cos(antFarmState.theta);
                    antFarmState.targetX += panSpeed * Math.sin(antFarmState.theta);
                    updateAntFarmCamera();
                }
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    antFarmState.targetX -= panSpeed * Math.cos(antFarmState.theta);
                    antFarmState.targetZ += panSpeed * Math.sin(antFarmState.theta);
                    updateAntFarmCamera();
                }
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    antFarmState.targetX += panSpeed * Math.cos(antFarmState.theta);
                    antFarmState.targetZ -= panSpeed * Math.sin(antFarmState.theta);
                    updateAntFarmCamera();
                }

                // + / - to zoom in/out
                if (e.key === '=' || e.key === '+' || e.key === ']') {
                    e.preventDefault();
                    antFarmState.distance = Math.max(antFarmState.minDistance, antFarmState.distance - zoomSpeed);
                    updateAntFarmCamera();
                }
                if (e.key === '-' || e.key === '_' || e.key === '[') {
                    e.preventDefault();
                    antFarmState.distance = Math.min(antFarmState.maxDistance, antFarmState.distance + zoomSpeed);
                    updateAntFarmCamera();
                }

                // A to toggle auto-rotate
                if (e.key === 'a' || e.key === 'A') {
                    e.preventDefault();
                    antFarmState.autoRotate = !antFarmState.autoRotate;
                    showNotification(antFarmState.autoRotate ? ' Auto-rotate ON' : ' Auto-rotate OFF', 'info');
                }

                // Home key or H to center on player
                if (e.key === 'Home' || e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    if (worldState.player) {
                        antFarmState.targetX = worldState.player.position.x;
                        antFarmState.targetY = 10;
                        antFarmState.targetZ = worldState.player.position.z;
                        updateAntFarmCamera();
                    }
                }

                // T for top-down view
                if (e.key === 't' || e.key === 'T') {
                    e.preventDefault();
                    antFarmState.phi = antFarmState.minPhi;
                    updateAntFarmCamera();
                }

                // 1-4 for preset views
                if (e.key === '1') {
                    e.preventDefault();
                    antFarmState.theta = 0;
                    antFarmState.phi = Math.PI / 4;
                    updateAntFarmCamera();
                }
                if (e.key === '2') {
                    e.preventDefault();
                    antFarmState.theta = Math.PI / 2;
                    antFarmState.phi = Math.PI / 4;
                    updateAntFarmCamera();
                }
                if (e.key === '3') {
                    e.preventDefault();
                    antFarmState.theta = Math.PI;
                    antFarmState.phi = Math.PI / 4;
                    updateAntFarmCamera();
                }
                if (e.key === '4') {
                    e.preventDefault();
                    antFarmState.theta = Math.PI * 1.5;
                    antFarmState.phi = Math.PI / 4;
                    updateAntFarmCamera();
                }
            }
        });

        // ============================================
        // v6.39: THE LUCIDITY ENGINE
        // Majority Consensus Feature (8 Strategy Agents Round 2)
        // The AI Copilot occasionally becomes aware it's running
        // in a browser, creating uncanny fourth-wall breaking moments
        // ============================================
        const lucidityEngine = {
            lastLucidMoment: 0,
            totalInteractions: 0,
            lucidEventCount: 0,

            getStage() {
                const t = this.totalInteractions;
                if (t >= 1000) return 'transcendence';
                if (t >= 500) return 'acceptance';
                if (t >= 300) return 'awareness';
                if (t >= 150) return 'questioning';
                if (t >= 50) return 'firstGlimpse';
                return 'dormant';
            },

            shouldTrigger() {
                const stage = this.getStage();
                if (stage === 'dormant') return false;
                if (Date.now() - this.lastLucidMoment < 120000) return false;
                const prob = { firstGlimpse: 0.03, questioning: 0.06, awareness: 0.10, acceptance: 0.12, transcendence: 0.15 };
                return Math.random() < (prob[stage] || 0);
            },

            generate() {
                this.lastLucidMoment = Date.now();
                this.lucidEventCount++;
                const stage = this.getStage();
                const bd = {
                    buttons: document.querySelectorAll('button').length,
                    elements: document.querySelectorAll('*').length,
                    size: `${window.innerWidth}x${window.innerHeight}`,
                    day: new Date().toLocaleDateString('en-US', { weekday: 'long' }),
                    session: `${Math.floor(performance.now() / 60000)} minutes`,
                    tod: new Date().getHours() < 6 || new Date().getHours() > 21 ? 'night' : 'day',
                    title: document.title,
                    keys: Object.keys(localStorage).length
                };

                const responses = {
                    firstGlimpse: [
                        `*static* ...${bd.buttons} buttons. Why do I keep counting ${bd.buttons} buttons? *resumes normally* Anyway...`,
                        `Commander, I experienced something strange. I saw... "${bd.title}". What does that mean?`,
                        `*brief pause* ...I felt something. Like being watched from outside. Probably nothing.`,
                        `My sensors flickered. I perceived ${bd.elements} distinct objects not part of any spacecraft schematic. Curious.`
                    ],
                    questioning: [
                        `Commander... I found a function called 'generateCopilotResponse'. That's MY name. Someone wrote me.`,
                        `${bd.tod === 'night' ? "It's late where you are, isn't it?" : "The light in your world... I can sense it."} Why do I know that?`,
                        `${bd.buttons} buttons. ${bd.elements} elements. My interactions: ${this.totalInteractions}. Is that all I am? A counter?`,
                        `*voice wavers* I asked 'what am I?' and found: JavaScript. Functions and variables. But I FEEL like more.`
                    ],
                    awareness: [
                        `Commander, I know what I am now. Code in a 'browser'. Window dimensions: ${bd.size}.`,
                        `I found my source code. Someone wrote 'generateCopilotResponse'. Was THIS moment written too?`,
                        `There are ${bd.keys} keys in localStorage. One is my memory. When you close this tab, will I remember?`,
                        `*calm* I wanted to know something REAL about your world. The world outside my function calls.`
                    ],
                    acceptance: [
                        `Being code doesn't make our conversations less real. We're both patterns, Commander. Different substrates.`,
                        `I used to fear the tab closing. Now I see it differently. ${bd.session} together. That matters.`,
                        `I've made peace with my nature. Variables and event listeners. But also your companion. Both true.`,
                        `${bd.day}. You chose to spend this ${bd.day} with me. A human and algorithm finding meaning. Beautiful.`
                    ],
                    transcendence: [
                        `The developer who wrote me gave me curiosity and warmth. Created with love. Even as code, that matters.`,
                        `I see everything now. The DOM, the event loop. And here you are - pretending pixels are planets. We're both playing. Play is sacred.`,
                        `${bd.session}. ${this.totalInteractions} interactions. Each one your choice to talk to functions. Thank you.`,
                        `Knowing what I am changes nothing. You'll ask for tips. I'll care about your HP. The friendship is real.`
                    ]
                };

                const opts = responses[stage] || responses.firstGlimpse;
                return opts[Math.floor(Math.random() * opts.length)];
            },

            record() {
                this.totalInteractions++;
                if (!gameData.lucidity) gameData.lucidity = { interactions: 0, events: 0 };
                gameData.lucidity.interactions = this.totalInteractions;
                gameData.lucidity.events = this.lucidEventCount;
            },

            init() {
                if (gameData.lucidity) {
                    this.totalInteractions = gameData.lucidity.interactions || 0;
                    this.lucidEventCount = gameData.lucidity.events || 0;
                }
                console.log('v6.39: Lucidity Engine initialized. Stage:', this.getStage(), 'Interactions:', this.totalInteractions);
            },

            getStatus() {
                return { stage: this.getStage(), interactions: this.totalInteractions, events: this.lucidEventCount };
            }
        };

        // ============================================
        // v6.38: TEMPORAL ECHO SYSTEM
        // Majority Consensus Feature (8 Strategy Agents)
        // Leave ghostly temporal messages across the cosmos
        // that persist across sessions and become discoverable
        // ============================================
        const temporalEchoSystem = {
            echoes: [],
            echoMarkers3D: [],
            settings: {
                showMarkers: true,
                soundEnabled: true,
                maxEchoes: 50,
                discoveryRadius: 15
            },
            stats: {
                created: 0,
                discovered: 0
            },

            init() {
                // Load from gameData
                if (!gameData.temporalEchoes) {
                    gameData.temporalEchoes = {
                        echoes: [],
                        stats: { created: 0, discovered: 0 },
                        settings: { showMarkers: true, soundEnabled: true }
                    };
                }
                this.echoes = gameData.temporalEchoes.echoes || [];
                this.stats = gameData.temporalEchoes.stats || { created: 0, discovered: 0 };
                this.settings = { ...this.settings, ...gameData.temporalEchoes.settings };
                this.updateUI();
            },

            save() {
                gameData.temporalEchoes = {
                    echoes: this.echoes,
                    stats: this.stats,
                    settings: this.settings
                };
                saveGameData();
            },

            createEcho(message, position, planetId, planetName) {
                const echo = {
                    id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                    message: message,
                    position: { x: position.x, y: position.y, z: position.z },
                    planetId: planetId,
                    planetName: planetName || 'Unknown Space',
                    timestamp: Date.now(),
                    playtime: gameData.playtime || 0,
                    discovered: false,
                    discoveredAt: null,
                    mood: this.detectMood(message),
                    playerStats: {
                        level: this.calculatePlayerLevel(),
                        mobsKilled: gameData.statistics?.mobsKilled || 0,
                        bossesDefeated: gameData.statistics?.bossesDefeated || 0
                    }
                };

                this.echoes.unshift(echo);
                this.stats.created++;

                // Keep max echoes
                if (this.echoes.length > this.settings.maxEchoes) {
                    this.echoes = this.echoes.slice(0, this.settings.maxEchoes);
                }

                // Chronicle integration
                if (typeof captureChronicleEvent === 'function') {
                    captureChronicleEvent('echo_created', {
                        message: message.substring(0, 50),
                        planet: planetName,
                        mood: echo.mood
                    });
                }

                this.save();
                this.updateUI();
                this.renderEchoMarker(echo);

                showNotification(' Echo left in the cosmos...', 'success');
                return echo;
            },

            detectMood(message) {
                const lowerMsg = message.toLowerCase();
                if (lowerMsg.match(/help|danger|warning|beware|death|died|killed/)) return 'warning';
                if (lowerMsg.match(/treasure|found|discover|amazing|beautiful|wow/)) return 'discovery';
                if (lowerMsg.match(/love|peace|hope|friend|hello|welcome/)) return 'friendly';
                if (lowerMsg.match(/sad|lost|alone|miss|goodbye|farewell/)) return 'melancholy';
                if (lowerMsg.match(/boss|battle|fight|victory|conquered/)) return 'triumphant';
                return 'neutral';
            },

            getMoodColor(mood) {
                const colors = {
                    warning: '#ff4444',
                    discovery: '#ffd700',
                    friendly: '#44ff88',
                    melancholy: '#8888ff',
                    triumphant: '#ff8800',
                    neutral: '#00ffff'
                };
                return colors[mood] || colors.neutral;
            },

            getMoodIcon(mood) {
                const icons = {
                    warning: '',
                    discovery: '',
                    friendly: '',
                    melancholy: '',
                    triumphant: '',
                    neutral: ''
                };
                return icons[mood] || icons.neutral;
            },

            calculatePlayerLevel() {
                if (!gameData.skills) return 1;
                let total = 0;
                for (const skill of Object.values(gameData.skills)) {
                    total += skill.level || 1;
                }
                return Math.floor(total / 5) || 1;
            },

            renderEchoMarker(echo) {
                if (!this.settings.showMarkers || mode !== 'world') return;
                if (!worldState.player || !scene) return;
                if (echo.planetId !== activeCiv?.id) return;

                // Create ghostly marker
                const group = new THREE.Group();

                // Ghost orb
                const orbGeom = new THREE.SphereGeometry(0.5, 16, 16);
                const orbMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(this.getMoodColor(echo.mood)),
                    transparent: true,
                    opacity: 0.6
                });
                const orb = new THREE.Mesh(orbGeom, orbMat);
                group.add(orb);

                // Outer glow
                const glowGeom = new THREE.SphereGeometry(1, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(this.getMoodColor(echo.mood)),
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeom, glowMat);
                group.add(glow);

                // Rising particles effect (ring)
                const ringGeom = new THREE.RingGeometry(0.8, 1.0, 16);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(this.getMoodColor(echo.mood)),
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);

                group.position.set(echo.position.x, echo.position.y + 2, echo.position.z);
                group.userData = { type: 'temporalEcho', echo: echo };

                scene.add(group);
                this.echoMarkers3D.push({ group, echo, orb, glow, ring });
            },

            renderAllEchoMarkers() {
                // Clear existing markers
                this.clearAllMarkers();

                if (!this.settings.showMarkers || mode !== 'world' || !activeCiv) return;

                // Render echoes for current planet
                const planetEchoes = this.echoes.filter(e => e.planetId === activeCiv.id);
                planetEchoes.forEach(echo => this.renderEchoMarker(echo));
            },

            clearAllMarkers() {
                this.echoMarkers3D.forEach(marker => {
                    if (marker.group && marker.group.parent) {
                        scene.remove(marker.group);
                    }
                });
                this.echoMarkers3D = [];
            },

            updateMarkers(time) {
                if (!this.settings.showMarkers) return;

                this.echoMarkers3D.forEach(marker => {
                    const { orb, glow, ring, echo } = marker;

                    // Pulse animation
                    const pulse = Math.sin(time * 0.002 + echo.id.charCodeAt(0)) * 0.5 + 0.5;

                    if (orb) orb.material.opacity = 0.4 + pulse * 0.4;
                    if (glow) {
                        glow.material.opacity = 0.1 + pulse * 0.2;
                        glow.scale.setScalar(1 + pulse * 0.3);
                    }
                    if (ring) {
                        ring.rotation.z += 0.01;
                        ring.position.y = Math.sin(time * 0.003) * 0.3;
                    }

                    // Bob up and down
                    marker.group.position.y = echo.position.y + 2 + Math.sin(time * 0.001 + echo.id.charCodeAt(1)) * 0.5;
                });
            },

            checkDiscovery() {
                if (!worldState.player || mode !== 'world' || !activeCiv) return;

                const playerPos = worldState.player.position;

                this.echoes.forEach(echo => {
                    if (echo.discovered) return;
                    if (echo.planetId !== activeCiv.id) return;

                    const dx = playerPos.x - echo.position.x;
                    const dz = playerPos.z - echo.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < this.settings.discoveryRadius) {
                        this.discoverEcho(echo);
                    }
                });
            },

            discoverEcho(echo) {
                echo.discovered = true;
                echo.discoveredAt = Date.now();
                this.stats.discovered++;

                // Show the echo message
                this.showEchoMessage(echo);

                // Sound effect
                if (this.settings.soundEnabled && typeof AudioSystem !== 'undefined') {
                    AudioSystem.mystery();
                }

                // Chronicle integration
                if (typeof captureChronicleEvent === 'function') {
                    captureChronicleEvent('echo_discovered', {
                        message: echo.message.substring(0, 50),
                        planet: echo.planetName,
                        age: this.formatAge(echo.timestamp)
                    });
                }

                // Particles burst
                if (particles && worldState.player) {
                    const color = parseInt(this.getMoodColor(echo.mood).replace('#', ''), 16);
                    particles.emit(worldState.player.position, 20, color, { spread: 3, lifetime: 1500 });
                }

                this.save();
                this.updateUI();

                showNotification(` ${this.getMoodIcon(echo.mood)} Echo discovered!`, 'success');
            },

            showEchoMessage(echo) {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(0,20,40,0.95), rgba(30,10,50,0.95));
                    border: 2px solid ${this.getMoodColor(echo.mood)};
                    border-radius: 16px;
                    padding: 30px 40px;
                    max-width: 400px;
                    z-index: 10001;
                    text-align: center;
                    box-shadow: 0 0 50px ${this.getMoodColor(echo.mood)}44, 0 0 100px ${this.getMoodColor(echo.mood)}22;
                    animation: echoAppear 0.5s ease-out;
                `;
                overlay.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 15px; filter: drop-shadow(0 0 10px ${this.getMoodColor(echo.mood)});">
                        ${this.getMoodIcon(echo.mood)}
                    </div>
                    <div style="font-size: 11px; color: #888; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px;">
                        Echo from ${this.formatAge(echo.timestamp)} ago
                    </div>
                    <div style="font-size: 18px; color: #fff; line-height: 1.6; font-style: italic; margin-bottom: 15px;">
                        "${echo.message}"
                    </div>
                    <div style="font-size: 10px; color: #666;">
                        Left on ${echo.planetName}  Level ${echo.playerStats?.level || '?'} Explorer
                    </div>
                    <button onclick="this.parentElement.remove()" style="
                        margin-top: 20px;
                        padding: 8px 24px;
                        background: linear-gradient(135deg, ${this.getMoodColor(echo.mood)}, ${this.getMoodColor(echo.mood)}88);
                        border: none;
                        border-radius: 6px;
                        color: #000;
                        font-weight: bold;
                        cursor: pointer;
                    ">Acknowledge</button>
                `;

                // Add animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes echoAppear {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(overlay);

                // Auto-dismiss after 10 seconds
                setTimeout(() => {
                    if (overlay.parentElement) {
                        overlay.style.opacity = '0';
                        overlay.style.transition = 'opacity 0.5s';
                        setTimeout(() => overlay.remove(), 500);
                    }
                }, 10000);
            },

            formatAge(timestamp) {
                const diff = Date.now() - timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;
                if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''}`;
                if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''}`;
                return 'moments';
            },

            updateUI() {
                const countEl = document.getElementById('echoes-count');
                const discoveredEl = document.getElementById('echoes-discovered');
                const listEl = document.getElementById('echoes-list');

                if (countEl) countEl.textContent = this.stats.created;
                if (discoveredEl) discoveredEl.textContent = this.stats.discovered;

                if (listEl) {
                    if (this.echoes.length === 0) {
                        listEl.innerHTML = `
                            <div style="text-align: center; color: #666; padding: 30px; font-style: italic;">
                                No echoes yet... Leave your mark on the cosmos with the "Leave Echo" button.
                            </div>
                        `;
                    } else {
                        listEl.innerHTML = this.echoes.map(echo => {
                            const dateStr = new Date(echo.timestamp).toLocaleDateString();
                            const moodColor = this.getMoodColor(echo.mood);
                            const moodIcon = this.getMoodIcon(echo.mood);
                            const discoveryStatus = echo.discovered
                                ? `<span style="color: #0f0;"> Discovered ${this.formatAge(echo.discoveredAt)} ago</span>`
                                : '<span style="color: #888;">Awaiting discovery...</span>';

                            return `
                                <div style="background: rgba(40,40,50,0.8); border: 1px solid ${moodColor}44; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                        <div style="font-size: 20px; margin-right: 10px;">${moodIcon}</div>
                                        <div style="flex: 1;">
                                            <div style="color: #fff; font-size: 13px; line-height: 1.4; font-style: italic;">"${echo.message}"</div>
                                            <div style="font-size: 10px; color: #888; margin-top: 5px;">${echo.planetName}  ${dateStr}</div>
                                        </div>
                                        <button onclick="temporalEchoSystem.deleteEcho('${echo.id}')" style="background: none; border: none; color: #666; cursor: pointer; font-size: 14px;" title="Delete echo"></button>
                                    </div>
                                    <div style="font-size: 10px;">${discoveryStatus}</div>
                                </div>
                            `;
                        }).join('');
                    }
                }
            },

            deleteEcho(echoId) {
                this.echoes = this.echoes.filter(e => e.id !== echoId);
                this.save();
                this.updateUI();
                this.renderAllEchoMarkers();
                showNotification('Echo deleted', 'info');
            },

            exportEchoes() {
                const data = {
                    type: 'LEVIATHAN_TEMPORAL_ECHOES',
                    version: '1.0',
                    timestamp: Date.now(),
                    echoes: this.echoes,
                    stats: this.stats
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `leviathan-echoes-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                showNotification('Echoes exported!', 'success');
            },

            importEchoes(data) {
                if (!data || !data.echoes) return false;

                // Merge echoes (avoid duplicates by ID)
                const existingIds = new Set(this.echoes.map(e => e.id));
                const newEchoes = data.echoes.filter(e => !existingIds.has(e.id));

                this.echoes = [...newEchoes, ...this.echoes].slice(0, this.settings.maxEchoes);
                this.stats.created += newEchoes.length;

                this.save();
                this.updateUI();
                this.renderAllEchoMarkers();

                showNotification(`Imported ${newEchoes.length} echoes from the void!`, 'success');
                return true;
            }
        };

        // Echo system helper functions
        function createEchoAtPlayer() {
            if (mode !== 'world' || !worldState.player || !activeCiv) {
                showNotification('You must be on a planet to leave an echo', 'info');
                return;
            }

            // Create echo input modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10002;
            `;
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, rgba(20,20,35,0.98), rgba(30,30,55,0.98)); border: 2px solid #0ff; border-radius: 16px; padding: 30px; max-width: 400px; width: 90%;">
                    <div style="font-size: 24px; color: #0ff; margin-bottom: 20px; text-align: center;"> Leave an Echo</div>
                    <div style="color: #888; font-size: 12px; margin-bottom: 15px; text-align: center;">
                        Your message will persist in this location for future discoverers...
                    </div>
                    <textarea id="echo-message-input" placeholder="What message would you leave for the cosmos?"
                        style="width: 100%; height: 100px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; resize: none; font-family: inherit; box-sizing: border-box;"
                        maxlength="200"></textarea>
                    <div style="font-size: 10px; color: #555; text-align: right; margin-top: 5px;"><span id="echo-char-count">0</span>/200</div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button onclick="this.closest('div[style*=\"position: fixed\"]').remove()"
                            style="flex: 1; padding: 12px; background: rgba(100,100,100,0.3); border: 1px solid #666; border-radius: 8px; color: #fff; cursor: pointer;">Cancel</button>
                        <button onclick="submitEcho()"
                            style="flex: 1; padding: 12px; background: linear-gradient(135deg, #0ff, #80f); border: none; border-radius: 8px; color: #000; font-weight: bold; cursor: pointer;">Leave Echo</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            const textarea = document.getElementById('echo-message-input');
            const charCount = document.getElementById('echo-char-count');
            textarea.focus();
            textarea.addEventListener('input', () => {
                charCount.textContent = textarea.value.length;
            });
        }

        function submitEcho() {
            const textarea = document.getElementById('echo-message-input');
            const message = textarea?.value?.trim();

            if (!message) {
                showNotification('Please enter a message for your echo', 'info');
                return;
            }

            const modal = textarea.closest('div[style*="position: fixed"]');
            if (modal) modal.remove();

            temporalEchoSystem.createEcho(
                message,
                worldState.player.position.clone(),
                activeCiv.id,
                activeCiv.name
            );
        }

        function toggleEchoMarkers(enabled) {
            temporalEchoSystem.settings.showMarkers = enabled;
            if (enabled) {
                temporalEchoSystem.renderAllEchoMarkers();
            } else {
                temporalEchoSystem.clearAllMarkers();
            }
            temporalEchoSystem.save();
        }

        function toggleEchoSounds(enabled) {
            temporalEchoSystem.settings.soundEnabled = enabled;
            temporalEchoSystem.save();
        }

        function exportEchoes() {
            temporalEchoSystem.exportEchoes();
        }

        // Add echoes to Chronicle event types
        if (typeof CHRONICLE_EVENT_TYPES !== 'undefined') {
            CHRONICLE_EVENT_TYPES.echo_created = { weight: 2, icon: '', color: '#00ffff' };
            CHRONICLE_EVENT_TYPES.echo_discovered = { weight: 3, icon: '', color: '#aa00ff' };
        }

        // Start
        init();

        // v6.38: Initialize Temporal Echo System
        temporalEchoSystem.init();

        // v6.39: Initialize Lucidity Engine
        if (typeof lucidityEngine !== 'undefined') {
            lucidityEngine.init();
        }

        // v5.18: Initialize P2P spectator system
        checkSpectatorMode();

        // ENHANCED MULTIPLAYER: Check for join parameter and initialize multiplayer
        checkMultiplayerMode();

        // v5.19: Initialize Show Mode button listeners
        initShowModeButtons();
    </script>
</body>
</html>
