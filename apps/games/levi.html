<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Share+Tech+Mono&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: #fff;
        }
        
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 32px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
        }

        .stats-box {
            display: flex;
            gap: 20px;
            text-align: right;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: 20px; color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: 10px; color: #666; text-transform: uppercase; }

        /* RPG INTERFACE (Bottom) */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 180px;
            background: linear-gradient(to top, #050505, transparent);
            display: none; /* Hidden in Galaxy Mode */
            padding: 20px;
            pointer-events: none;
            align-items: flex-end;
            justify-content: space-between;
        }

        .inventory-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: 300px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .panel-title {
            color: #fb0;
            font-family: 'Cinzel', serif;
            border-bottom: 1px solid #445;
            margin-bottom: 10px;
            padding-bottom: 5px;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 2px; right: 4px;
            font-size: 12px;
            color: #fff;
            font-weight: bold;
        }

        .player-stats {
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 15px;
            width: 250px;
        }

        .xp-bar-container {
            margin-bottom: 8px;
        }
        .xp-label { font-size: 12px; color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-top: 4px; }
        .xp-bar-fill { height: 100%; background: #0f0; width: 0%; transition: width 0.3s; }

        /* Action Button */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Cinzel', serif;
            pointer-events: auto;
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0ff;
            padding: 5px 10px;
            color: #0ff;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        
        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; justify-content: center; align-items: center;
            z-index: 999; font-size: 24px; font-family: 'Cinzel';
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">INITIALIZING OMNIVERSE ENGINE...</div>
    <div id="container"></div>
    
    <div class="ui-layer">
        
        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div style="color: #666; font-size: 12px;">GALAXY SIMULATION v2.0</div>
            </div>
            
            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <button class="action-btn" onclick="returnToGalaxy()">LEAVE PLANET</button>
            </div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <div id="rpg-ui" class="rpg-ui">
            <div class="player-stats">
                <div class="panel-title">Skills</div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
            </div>

            <div class="inventory-panel">
                <div class="panel-title">Backpack</div>
                <div class="inv-grid" id="inventory-grid">
                    </div>
            </div>
        </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            WORLD_SIZE: 100, // Larger world for RPG
            TILE_SIZE: 2
        };

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, name: 'Magma' }
        };

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple Perlin-ish noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy'; // 'galaxy' or 'world'
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;

        // RPG State (The RuneScape Clone)
        let worldState = {
            player: null,
            terrain: [], // simplified collision map
            interactables: [], // Trees, Rocks
            mobs: [],
            sun: null,
            moon: null,
            ambient: null,
            timeOfDay: 0, // 0 to 1
            inventory: { wood: 0, ore: 0, slime: 0 },
            skills: { mining: 1, wood: 1, combat: 1, minXp:0, woodXp:0, combXp:0 },
            target: null, // Move target
            interactTarget: null // Entity to interact with
        };

        // --- INITIALIZATION ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            initGalaxy();
            updateInventoryUI(); // Init empty UI
            
            document.getElementById('loading').style.display = 'none';
            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            // Reset Scene
            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            // Lighting
            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<10000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:2})));

            // Civilizations
            const rng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();
            
            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(200, 1200);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = rng.range(-100, 100);
                
                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: rng.pick(Object.keys(BIOMES)),
                    pop: rng.int(1, 100)
                };
                civilizations.push(civ);

                // Visuals
                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);
                
                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(8, 16, 16),
                    new THREE.MeshBasicMaterial({color: color})
                );
                sysGroup.add(star);
                
                // Glow
                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.2})
                );
                sysGroup.add(glow);
                
                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            // Selection Ring
            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            // Camera
            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            // UI
            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('civ-count').innerText = CONFIG.NUM_CIVS;
        }

        // --- WORLD MODE (RUNESCAPE CLONE) ---
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';

            // Reset Scene
            while(scene.children.length > 0) scene.remove(scene.children[0]);
            
            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            // 1. Lighting (Day/Night)
            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 2048;
            worldState.sun.shadow.mapSize.height = 2048;
            scene.add(worldState.sun);

            // 2. Terrain Generation (Voxel/Tile style)
            const rng = new SeededRNG(civ.name);
            worldState.terrain = []; // Collision map
            worldState.interactables = [];
            worldState.mobs = [];
            
            // Merged geometry for ground to save Draw Calls
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            // We will actually use instanced mesh for performance if we had textures, 
            // but for simple colors we'll just create a group of meshes for simplicity in this file
            
            const groundMat = new THREE.MeshLambertMaterial({color: biome.ground});
            const waterMat = new THREE.MeshLambertMaterial({color: 0x2244aa, transparent:true, opacity:0.8});

            const worldGroup = new THREE.Group();
            
            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    // Height noise
                    const hVal = noise(x + civ.id, z + civ.id);
                    const height = Math.floor((hVal + 1) * 3); // 0 to 6
                    const realY = height * CONFIG.TILE_SIZE/2; // Center Y
                    
                    const isWater = height < 1;
                    
                    const mesh = new THREE.Mesh(groundGeo, isWater ? waterMat : groundMat);
                    mesh.position.set(
                        (x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE,
                        realY,
                        (z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE
                    );
                    mesh.receiveShadow = true;
                    worldGroup.add(mesh);

                    // Store logic height
                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    // Decorators (Trees/Rocks)
                    if(!isWater && rng.next() > 0.85) {
                        const type = rng.next() > 0.5 ? 'tree' : 'rock';
                        createProp(type, mesh.position.x, mesh.position.y + CONFIG.TILE_SIZE/2, mesh.position.z, biome);
                    }
                }
            }
            scene.add(worldGroup);
            
            // 3. Player
            const playerGeo = new THREE.CapsuleGeometry(1, 2, 4, 8);
            const playerMat = new THREE.MeshStandardMaterial({color: 0xffff00});
            worldState.player = new THREE.Mesh(playerGeo, playerMat);
            worldState.player.position.set(0, 10, 0);
            worldState.player.castShadow = true;
            
            // Player marker (ring)
            const ring = new THREE.Mesh(new THREE.RingGeometry(1, 1.2, 16), new THREE.MeshBasicMaterial({color:0xffff00}));
            ring.rotation.x = -Math.PI/2;
            ring.position.y = -1;
            worldState.player.add(ring);
            
            scene.add(worldState.player);

            // 4. Mobs
            for(let i=0; i<5; i++) {
                createMob(rng, biome);
            }

            // UI Switch
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('rpg-ui').style.display = 'flex';
            
            // Reset State
            worldState.target = null;
            worldState.interactTarget = null;
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.6, 2, 6),
                    new THREE.MeshLambertMaterial({color: 0x553311})
                );
                trunk.position.y = 1;
                group.add(trunk);
                
                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5, 3, 8),
                    new THREE.MeshLambertMaterial({color: biome.tree})
                );
                leaves.position.y = 3;
                group.add(leaves);
                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: 'Ancient Tree' };
            } else {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1.2),
                    new THREE.MeshLambertMaterial({color: biome.rock})
                );
                rock.position.y = 0.6;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }
            
            group.castShadow = true;
            scene.add(group);
            worldState.interactables.push(group);
        }

        function createMob(rng, biome) {
            const mobGeo = new THREE.SphereGeometry(1, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({color: 0xff0000, roughness: 0.2});
            const mob = new THREE.Mesh(mobGeo, mobMat);
            
            // Random pos
            const rx = (rng.next() - 0.5) * 50;
            const rz = (rng.next() - 0.5) * 50;
            mob.position.set(rx, 10, rz); // will snap to floor in update
            
            mob.userData = { 
                type: 'mob', 
                hp: 10, 
                maxHp: 10, 
                name: 'Slime',
                nextMove: 0,
                targetPos: new THREE.Vector3()
            };
            
            scene.add(mob);
            worldState.mobs.push(mob);
        }

        // --- GAME LOGIC ---
        
        function loop(time) {
            requestAnimationFrame(loop);
            
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            if(mode === 'galaxy') {
                // Rotate galaxy
                galaxyGroup.rotation.y += 0.001;
                
                // Selection ring animation
                if(activeCiv) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);
                }
            } 
            else if(mode === 'world') {
                updateWorld(dt, time);
            }
            
            renderer.render(scene, camera);
        }

        function updateWorld(dt, time) {
            // 1. Day/Night Cycle
            worldState.timeOfDay = (time * 0.0001) % 1; // 0 to 1 cycle
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;
            
            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0, Math.sin(angle)) * 1.2;
            
            // Sky color lerp
            const biome = BIOMES[activeCiv.biome];
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x050510);
            const lerpFactor = (Math.sin(angle) + 1) / 2;
            scene.background.lerpColors(nightColor, dayColor, Math.max(0, Math.sin(angle)));
            scene.fog.color.copy(scene.background);

            // 2. Player Movement (Click to Move)
            const p = worldState.player;
            const speed = 15;

            if(worldState.target) {
                const dir = new THREE.Vector3().subVectors(worldState.target, p.position);
                dir.y = 0; // Planar movement
                const dist = dir.length();

                if(dist > 0.5) {
                    dir.normalize();
                    p.position.add(dir.multiplyScalar(speed * dt));
                    p.lookAt(worldState.target.x, p.position.y, worldState.target.z);
                } else {
                    worldState.target = null; // Arrived
                }
            }

            // Snap Player Y to Terrain
            snapToGround(p);

            // 3. Interaction Logic
            if(worldState.interactTarget) {
                // Check range
                const t = worldState.interactTarget;
                const dist = p.position.distanceTo(t.position);
                
                if(dist < 4) {
                    // Stop moving
                    worldState.target = null;
                    
                    // Perform Action (Rate limited by animation in real game, here instant-ish)
                    if(Math.random() < 0.05) { // Tick chance
                        performAction(t);
                    }
                } else if (!worldState.target) {
                    // Move towards it
                    worldState.target = t.position.clone();
                }
            }

            // 4. Camera Follow
            const camOffset = new THREE.Vector3(0, 30, 30);
            camera.position.lerp(p.position.clone().add(camOffset), 0.1);
            camera.lookAt(p.position);

            // 5. Mob AI
            worldState.mobs.forEach(mob => {
                // Simple wander
                if(time > mob.userData.nextMove) {
                    const rng = Math.random();
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob
                const dir = new THREE.Vector3().subVectors(mob.userData.targetPos, mob.position);
                dir.y = 0;
                if(dir.length() > 0.1) {
                    dir.normalize();
                    mob.position.add(dir.multiplyScalar(3 * dt));
                    mob.lookAt(mob.userData.targetPos.x, mob.position.y, mob.userData.targetPos.z);
                }
                snapToGround(mob);
            });
        }

        function snapToGround(obj) {
            // Convert world pos to grid pos
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            
            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx][gz];
                if(y > -50) { // Not water
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, y + (obj.geometry.parameters.height || 1)/2, 0.2);
                }
            }
        }

        function performAction(target) {
            const data = target.userData;
            
            // Floating Text
            spawnFloater(target.position, "HIT!");

            // Damage/Gather
            data.hp--;
            
            // FX
            target.scale.setScalar(0.9);
            setTimeout(()=> target.scale.setScalar(1), 100);

            if(data.hp <= 0) {
                // Destroyed
                if(data.type === 'tree') {
                    addItem('Log');
                    addXp('wood', 50);
                    spawnFloater(target.position, "+1 LOG", '#da5');
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                } 
                else if(data.type === 'rock') {
                    addItem('Ore');
                    addXp('mining', 50);
                    spawnFloater(target.position, "+1 ORE", '#888');
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob') {
                    addItem('Slime');
                    addXp('combat', 100);
                    spawnFloater(target.position, "KILLED!", '#f00');
                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                worldState.interactTarget = null;
            }
        }

        function spawnFloater(pos, text, color='#fff') {
            const el = document.createElement('div');
            el.className = 'floater';
            el.textContent = text;
            el.style.color = color;
            
            // Project 3D pos to 2D screen
            const v = pos.clone();
            v.y += 2;
            v.project(camera);
            
            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;
            
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            
            setTimeout(() => el.remove(), 1400);
        }

        // --- INPUTS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    // climb up to group
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    
                    if(obj.userData.type === 'civ') {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `${obj.userData.data.name}<br><span style="color:#aaa">Click to Land</span>`;
                        document.body.style.cursor = 'pointer';
                        
                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
            } else if (mode === 'world') {
                // Check hover over interactables
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    
                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `${obj.userData.name}<br><span style="color:#aaa">Click to Interact</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy') selectionRing.visible = false;
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        initWorld(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                // 1. Check Interactables
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    spawnFloater(obj.position, "Targeting...", '#0ff');
                    return;
                }

                // 2. Move to Ground
                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null; // Cancel interaction
                    
                    // visual marker
                    const m = new THREE.Mesh(new THREE.RingGeometry(0.5,0.6), new THREE.MeshBasicMaterial({color:0xffff00}));
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(()=>scene.remove(m), 500);
                }
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            initGalaxy();
            mode = 'galaxy';
            activeCiv = null;
        }

        // --- RPG SYSTEMS ---
        function addItem(name) {
            // Simple inventory logic
            const grid = document.getElementById('inventory-grid');
            
            // Check existing
            let found = false;
            for(let i=0; i<grid.children.length; i++) {
                if(grid.children[i].dataset.item === name) {
                    let count = grid.children[i].querySelector('.inv-count');
                    count.innerText = parseInt(count.innerText) + 1;
                    found = true;
                    break;
                }
            }
            
            if(!found && grid.children.length < 16) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                slot.dataset.item = name;
                
                let icon = 'ðŸ“¦';
                if(name === 'Log') icon = 'ðŸªµ';
                if(name === 'Ore') icon = 'ðŸª¨';
                if(name === 'Slime') icon = 'ðŸŸ¢';
                
                slot.innerHTML = `${icon}<div class="inv-count">1</div>`;
                grid.appendChild(slot);
            }
        }

        function updateInventoryUI() {
            document.getElementById('inventory-grid').innerHTML = '';
        }

        function addXp(skill, amt) {
            // Simplified XP Curve
            if(skill === 'mining') worldState.skills.minXp += amt;
            if(skill === 'wood') worldState.skills.woodXp += amt;
            if(skill === 'combat') worldState.skills.combXp += amt;
            
            // Check level up
            checkLevel(skill);
        }
        
        function checkLevel(skill) {
            let xp = 0;
            let elId = '';
            let barId = '';
            
            if(skill === 'mining') { xp = worldState.skills.minXp; elId = 'lvl-mining'; barId='bar-mining'; }
            if(skill === 'wood') { xp = worldState.skills.woodXp; elId = 'lvl-wood'; barId='bar-wood'; }
            if(skill === 'combat') { xp = worldState.skills.combXp; elId = 'lvl-combat'; barId='bar-combat'; }
            
            const level = Math.floor(Math.sqrt(xp / 100)) + 1;
            const nextLevelXp = Math.pow((level), 2) * 100;
            const prevLevelXp = Math.pow((level-1), 2) * 100;
            const progress = (xp - prevLevelXp) / (nextLevelXp - prevLevelXp) * 100;
            
            document.getElementById(elId).innerText = level;
            document.getElementById(barId).style.width = progress + '%';
        }

        // Start
        init();
    </script>
</body>
</html>