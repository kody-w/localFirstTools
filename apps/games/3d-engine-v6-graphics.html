<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Game Engine - Graphics Quality</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Glassmorphism UI */
        .ui-panel {
            position: absolute;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ui-panel:hover {
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(10, 10, 50, 0.95) 0%, rgba(30, 10, 60, 0.95) 100%);
            z-index: 1000;
        }

        .menu-content {
            text-align: center;
            max-width: 500px;
            animation: fadeInUp 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                filter: drop-shadow(0 0 10px rgba(102, 126, 234, 0.5));
            }
            to {
                filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.8));
            }
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0ff;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(160, 160, 255, 0.3);
        }

        input, button, select, textarea {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: none;
            pointer-events: none;
        }

        .hud-element {
            pointer-events: auto;
            margin-bottom: 10px;
        }

        #chat-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 350px;
            max-height: 300px;
            display: none;
        }

        #chat-messages {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            font-size: 14px;
        }

        #chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        #chat-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        #chat-messages::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }

        #chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #667eea;
            animation: slideInLeft 0.3s ease;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .chat-username {
            color: #667eea;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 250px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #a0a0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .button-group button {
            flex: 1;
            padding: 10px;
            font-size: 14px;
        }

        #editor-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            display: none;
        }

        .color-picker {
            width: 100%;
            height: 50px;
            cursor: pointer;
            border-radius: 8px;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(102, 126, 234, 0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 1.2em;
            color: #667eea;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
        }

        .hidden {
            display: none !important;
        }

        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tab-button {
            flex: 1;
            padding: 8px;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #replay-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }

        .replay-button {
            padding: 10px 20px;
            margin: 0 5px;
            background: rgba(102, 126, 234, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(102, 126, 234, 0.95);
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 1.2em;
            display: none;
            z-index: 3000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .particle-trail {
            position: absolute;
            pointer-events: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(102, 126, 234, 1) 0%, rgba(102, 126, 234, 0) 70%);
            animation: particle-fade 1s ease-out forwards;
        }

        @keyframes particle-fade {
            to {
                opacity: 0;
                transform: scale(2);
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <div class="loading-text">Loading Graphics Engine...</div>
    </div>

    <div id="menu-screen">
        <div class="menu-content">
            <h1>3D Game Engine</h1>
            <div class="subtitle">Graphics Quality Edition</div>
            <input type="text" id="username" placeholder="Enter your username" maxlength="20">
            <div class="button-group">
                <button onclick="createRoom()">Create Room</button>
                <button onclick="showJoinRoom()">Join Room</button>
            </div>
            <div id="join-room-section" class="hidden">
                <input type="text" id="room-code" placeholder="Enter room code" maxlength="6">
                <button onclick="joinRoom()">Connect</button>
            </div>
            <button onclick="startSinglePlayer()">Single Player</button>
            <button onclick="showLevelEditor()">Level Editor</button>
            <button onclick="showReplayViewer()">View Replays</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="game-hud">
        <div class="ui-panel hud-element" id="room-info">
            <div id="room-code-display"></div>
            <div id="players-list"></div>
        </div>
    </div>

    <div id="chat-panel" class="ui-panel">
        <div id="chat-messages"></div>
        <input type="text" id="chat-input" placeholder="Press Enter to chat..." maxlength="200">
    </div>

    <div id="controls-panel" class="ui-panel">
        <div class="tab-buttons">
            <button class="tab-button active" onclick="switchTab('graphics')">Graphics</button>
            <button class="tab-button" onclick="switchTab('game')">Game</button>
        </div>

        <div id="graphics-tab" class="tab-content active">
            <div class="control-group">
                <label>Shadows</label>
                <input type="checkbox" id="shadows-toggle" checked onchange="toggleShadows()">
            </div>
            <div class="control-group">
                <label>Bloom</label>
                <input type="checkbox" id="bloom-toggle" checked onchange="toggleBloom()">
            </div>
            <div class="control-group">
                <label>Particles</label>
                <input type="checkbox" id="particles-toggle" checked onchange="toggleParticles()">
            </div>
            <div class="control-group">
                <label>Anti-Aliasing</label>
                <input type="checkbox" id="aa-toggle" checked onchange="toggleAA()">
            </div>
        </div>

        <div id="game-tab" class="tab-content">
            <div class="control-group">
                <label>Controls</label>
                <div style="font-size: 12px; color: #a0a0ff;">
                    WASD - Move<br>
                    Space - Jump<br>
                    Mouse - Look<br>
                    Click - Lock Pointer
                </div>
            </div>
            <button onclick="returnToMenu()">Exit to Menu</button>
        </div>
    </div>

    <div id="editor-panel" class="ui-panel">
        <h3 style="margin-bottom: 15px;">Level Editor</h3>
        <div class="control-group">
            <label>Object Type</label>
            <select id="object-type">
                <option value="box">Box</option>
                <option value="sphere">Sphere</option>
                <option value="cylinder">Cylinder</option>
                <option value="platform">Platform</option>
            </select>
        </div>
        <div class="control-group">
            <label>Color</label>
            <input type="color" id="object-color" class="color-picker" value="#667eea">
        </div>
        <div class="button-group">
            <button onclick="placeObject()">Place</button>
            <button onclick="deleteObject()">Delete</button>
        </div>
        <div class="button-group">
            <button onclick="saveLevel()">Save</button>
            <button onclick="loadLevel()">Load</button>
        </div>
        <button onclick="exitEditor()">Exit Editor</button>
    </div>

    <div id="replay-controls" class="ui-panel">
        <button class="replay-button" onclick="replayPlayPause()">Play/Pause</button>
        <button class="replay-button" onclick="replayRestart()">Restart</button>
        <button class="replay-button" onclick="exitReplay()">Exit</button>
        <div style="margin-top: 10px; text-align: center;">
            <span id="replay-time">0:00 / 0:00</span>
        </div>
    </div>

    <div id="notification"></div>

    <script>
        // Three.js inline (minimal version for core functionality)
        // For a production version, you'd need the full Three.js library
        // This is a simplified version that includes the essential Three.js code

        // ============== THREE.JS CORE (Simplified) ==============
        const THREE = {
            REVISION: '151',

            Vector3: class {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }
                copy(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                }
                add(v) {
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    return this;
                }
                sub(v) {
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    return this;
                }
                multiplyScalar(s) {
                    this.x *= s;
                    this.y *= s;
                    this.z *= s;
                    return this;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                normalize() {
                    const len = this.length();
                    if (len > 0) {
                        this.multiplyScalar(1 / len);
                    }
                    return this;
                }
                clone() {
                    return new THREE.Vector3(this.x, this.y, this.z);
                }
            },

            Quaternion: class {
                constructor(x = 0, y = 0, z = 0, w = 1) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                }
                setFromEuler(euler) {
                    const c1 = Math.cos(euler.x / 2);
                    const c2 = Math.cos(euler.y / 2);
                    const c3 = Math.cos(euler.z / 2);
                    const s1 = Math.sin(euler.x / 2);
                    const s2 = Math.sin(euler.y / 2);
                    const s3 = Math.sin(euler.z / 2);

                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;

                    return this;
                }
            },

            Euler: class {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
            },

            Color: class {
                constructor(r, g, b) {
                    if (typeof r === 'string') {
                        this.setHex(parseInt(r.replace('#', '0x')));
                    } else if (typeof r === 'number' && g === undefined) {
                        this.setHex(r);
                    } else {
                        this.r = r || 0;
                        this.g = g || 0;
                        this.b = b || 0;
                    }
                }
                setHex(hex) {
                    this.r = ((hex >> 16) & 255) / 255;
                    this.g = ((hex >> 8) & 255) / 255;
                    this.b = (hex & 255) / 255;
                    return this;
                }
                getHex() {
                    return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
                }
            },

            // Simplified WebGL renderer simulation
            WebGLRenderer: class {
                constructor(params = {}) {
                    this.domElement = document.createElement('canvas');
                    this.domElement.width = window.innerWidth;
                    this.domElement.height = window.innerHeight;

                    const contextAttributes = {
                        alpha: params.alpha !== undefined ? params.alpha : false,
                        antialias: params.antialias !== undefined ? params.antialias : true,
                        premultipliedAlpha: params.premultipliedAlpha !== undefined ? params.premultipliedAlpha : true,
                        stencil: params.stencil !== undefined ? params.stencil : true,
                        preserveDrawingBuffer: params.preserveDrawingBuffer !== undefined ? params.preserveDrawingBuffer : false,
                        powerPreference: params.powerPreference !== undefined ? params.powerPreference : 'high-performance'
                    };

                    this.gl = this.domElement.getContext('webgl2', contextAttributes) ||
                              this.domElement.getContext('webgl', contextAttributes);

                    if (!this.gl) {
                        throw new Error('WebGL not supported');
                    }

                    this.shadowMap = {
                        enabled: false,
                        type: THREE.PCFSoftShadowMap
                    };

                    this.toneMapping = THREE.ACESFilmicToneMapping;
                    this.toneMappingExposure = 1.0;
                    this.outputEncoding = THREE.sRGBEncoding;

                    this.scenes = [];
                    this.objects = [];
                }

                setSize(width, height) {
                    this.domElement.width = width;
                    this.domElement.height = height;
                    this.gl.viewport(0, 0, width, height);
                }

                setPixelRatio(ratio) {
                    this.pixelRatio = ratio;
                }

                render(scene, camera) {
                    const gl = this.gl;
                    gl.clearColor(0.05, 0.05, 0.1, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.enable(gl.DEPTH_TEST);

                    // Simplified rendering - in a real implementation, this would
                    // process the scene graph and render all meshes with proper shaders
                }
            },

            Scene: class {
                constructor() {
                    this.children = [];
                    this.fog = null;
                    this.background = null;
                }
                add(object) {
                    this.children.push(object);
                }
                remove(object) {
                    const index = this.children.indexOf(object);
                    if (index !== -1) {
                        this.children.splice(index, 1);
                    }
                }
            },

            PerspectiveCamera: class {
                constructor(fov, aspect, near, far) {
                    this.fov = fov;
                    this.aspect = aspect;
                    this.near = near;
                    this.far = far;
                    this.position = new THREE.Vector3();
                    this.rotation = new THREE.Euler();
                    this.quaternion = new THREE.Quaternion();
                }
                updateProjectionMatrix() {
                    // Update projection matrix
                }
            },

            Mesh: class {
                constructor(geometry, material) {
                    this.geometry = geometry;
                    this.material = material;
                    this.position = new THREE.Vector3();
                    this.rotation = new THREE.Euler();
                    this.quaternion = new THREE.Quaternion();
                    this.scale = new THREE.Vector3(1, 1, 1);
                    this.castShadow = false;
                    this.receiveShadow = false;
                }
            },

            BoxGeometry: class {
                constructor(width, height, depth) {
                    this.parameters = { width, height, depth };
                }
            },

            SphereGeometry: class {
                constructor(radius, widthSegments, heightSegments) {
                    this.parameters = { radius, widthSegments, heightSegments };
                }
            },

            CylinderGeometry: class {
                constructor(radiusTop, radiusBottom, height, radialSegments) {
                    this.parameters = { radiusTop, radiusBottom, height, radialSegments };
                }
            },

            PlaneGeometry: class {
                constructor(width, height) {
                    this.parameters = { width, height };
                }
            },

            MeshStandardMaterial: class {
                constructor(params = {}) {
                    this.color = params.color ? new THREE.Color(params.color) : new THREE.Color(0xffffff);
                    this.roughness = params.roughness !== undefined ? params.roughness : 0.5;
                    this.metalness = params.metalness !== undefined ? params.metalness : 0.5;
                    this.emissive = params.emissive ? new THREE.Color(params.emissive) : new THREE.Color(0x000000);
                    this.emissiveIntensity = params.emissiveIntensity !== undefined ? params.emissiveIntensity : 1;
                }
            },

            MeshPhongMaterial: class {
                constructor(params = {}) {
                    this.color = params.color ? new THREE.Color(params.color) : new THREE.Color(0xffffff);
                    this.specular = params.specular ? new THREE.Color(params.specular) : new THREE.Color(0x111111);
                    this.shininess = params.shininess !== undefined ? params.shininess : 30;
                }
            },

            PointLight: class {
                constructor(color, intensity, distance, decay) {
                    this.color = new THREE.Color(color);
                    this.intensity = intensity;
                    this.distance = distance;
                    this.decay = decay;
                    this.position = new THREE.Vector3();
                    this.castShadow = false;
                }
            },

            DirectionalLight: class {
                constructor(color, intensity) {
                    this.color = new THREE.Color(color);
                    this.intensity = intensity;
                    this.position = new THREE.Vector3();
                    this.castShadow = false;
                    this.shadow = {
                        camera: {
                            left: -10,
                            right: 10,
                            top: 10,
                            bottom: -10,
                            near: 0.5,
                            far: 500
                        },
                        mapSize: { width: 2048, height: 2048 }
                    };
                }
            },

            AmbientLight: class {
                constructor(color, intensity) {
                    this.color = new THREE.Color(color);
                    this.intensity = intensity;
                }
            },

            HemisphereLight: class {
                constructor(skyColor, groundColor, intensity) {
                    this.skyColor = new THREE.Color(skyColor);
                    this.groundColor = new THREE.Color(groundColor);
                    this.intensity = intensity;
                    this.position = new THREE.Vector3();
                }
            },

            Fog: class {
                constructor(color, near, far) {
                    this.color = new THREE.Color(color);
                    this.near = near;
                    this.far = far;
                }
            },

            // Constants
            PCFSoftShadowMap: 2,
            ACESFilmicToneMapping: 4,
            sRGBEncoding: 3001,
        };

        // ============== CANNON.JS PHYSICS (Simplified) ==============
        const CANNON = {
            Vec3: class {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
                copy(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                }
            },

            World: class {
                constructor() {
                    this.gravity = new CANNON.Vec3(0, -9.82, 0);
                    this.bodies = [];
                    this.defaultContactMaterial = {
                        friction: 0.3,
                        restitution: 0.3
                    };
                }
                addBody(body) {
                    this.bodies.push(body);
                }
                removeBody(body) {
                    const index = this.bodies.indexOf(body);
                    if (index !== -1) {
                        this.bodies.splice(index, 1);
                    }
                }
                step(dt) {
                    // Simplified physics simulation
                    for (const body of this.bodies) {
                        if (body.mass > 0) {
                            // Apply gravity
                            body.velocity.x += this.gravity.x * dt;
                            body.velocity.y += this.gravity.y * dt;
                            body.velocity.z += this.gravity.z * dt;

                            // Update position
                            body.position.x += body.velocity.x * dt;
                            body.position.y += body.velocity.y * dt;
                            body.position.z += body.velocity.z * dt;

                            // Simple ground collision
                            if (body.position.y < 0.5) {
                                body.position.y = 0.5;
                                body.velocity.y = 0;
                            }
                        }
                    }
                }
            },

            Body: class {
                constructor(params = {}) {
                    this.mass = params.mass !== undefined ? params.mass : 0;
                    this.position = params.position || new CANNON.Vec3();
                    this.velocity = new CANNON.Vec3();
                    this.quaternion = { x: 0, y: 0, z: 0, w: 1 };
                    this.shape = params.shape;
                }
                applyImpulse(impulse, point) {
                    if (this.mass > 0) {
                        this.velocity.x += impulse.x / this.mass;
                        this.velocity.y += impulse.y / this.mass;
                        this.velocity.z += impulse.z / this.mass;
                    }
                }
            },

            Box: class {
                constructor(halfExtents) {
                    this.halfExtents = halfExtents;
                }
            },

            Sphere: class {
                constructor(radius) {
                    this.radius = radius;
                }
            },

            Cylinder: class {
                constructor(radiusTop, radiusBottom, height, numSegments) {
                    this.radiusTop = radiusTop;
                    this.radiusBottom = radiusBottom;
                    this.height = height;
                    this.numSegments = numSegments;
                }
            },

            Plane: class {
                constructor() {
                    this.type = 'Plane';
                }
            }
        };

        // ============== PARTICLE SYSTEM ==============
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.maxParticles = 1000;
                this.enabled = true;
            }

            emit(position, color = 0x667eea, count = 10) {
                if (!this.enabled) return;

                for (let i = 0; i < count; i++) {
                    if (this.particles.length >= this.maxParticles) {
                        const old = this.particles.shift();
                        this.scene.remove(old.mesh);
                    }

                    const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 2,
                        roughness: 0.2,
                        metalness: 0.8
                    });
                    const mesh = new THREE.Mesh(geometry, material);

                    mesh.position.copy(position);

                    const particle = {
                        mesh: mesh,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 5
                        ),
                        life: 1.0,
                        decay: 0.02
                    };

                    this.particles.push(particle);
                    this.scene.add(mesh);
                }
            }

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];

                    particle.velocity.y -= 9.8 * dt;
                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(dt));
                    particle.life -= particle.decay;

                    particle.mesh.material.opacity = particle.life;
                    particle.mesh.scale.multiplyScalar(0.98);

                    if (particle.life <= 0) {
                        this.scene.remove(particle.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }

            clear() {
                for (const particle of this.particles) {
                    this.scene.remove(particle.mesh);
                }
                this.particles = [];
            }
        }

        // ============== GAME STATE ==============
        let scene, camera, renderer, physicsWorld;
        let player, playerMesh, playerBody;
        let particles;
        let keys = {};
        let mouseMovement = { x: 0, y: 0 };
        let pointerLocked = false;
        let gameMode = 'menu'; // menu, singleplayer, multiplayer, editor, replay
        let isHost = false;
        let roomCode = '';
        let username = '';
        let peers = new Map();
        let dataChannels = new Map();
        let chatMessages = [];
        let replayData = [];
        let replayPlayback = false;
        let replayTime = 0;
        let replayPlaying = false;
        let levelObjects = [];
        let editorMode = false;
        let selectedObject = null;

        // Graphics settings
        let settings = {
            shadows: true,
            bloom: true,
            particles: true,
            antialiasing: true
        };

        // ============== INITIALIZATION ==============
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);
            scene.background = new THREE.Color(0x1a1a2e);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                antialias: settings.antialiasing,
                alpha: false,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = settings.shadows;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;

            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create physics world
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.82, 0);

            // Create particle system
            particles = new ParticleSystem(scene);

            // Create lighting
            createLighting();

            // Create ground
            createGround();

            // Create player
            createPlayer();

            // Create some obstacles
            createObstacles();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', () => {
                if (gameMode !== 'menu' && !pointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === renderer.domElement;
            });

            // Chat input
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    sendChatMessage(e.target.value.trim());
                    e.target.value = '';
                }
            });

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').classList.add('hidden');
            }, 1500);

            // Start animation loop
            animate();
        }

        function createLighting() {
            // Hemisphere light for ambient lighting
            const hemiLight = new THREE.HemisphereLight(0x667eea, 0x764ba2, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);

            // Directional light (sun) with shadows
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            // Point lights for atmosphere
            const pointLight1 = new THREE.PointLight(0x667eea, 2, 20, 2);
            pointLight1.position.set(-5, 3, -5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x764ba2, 2, 20, 2);
            pointLight2.position.set(5, 3, 5);
            scene.add(pointLight2);

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                roughness: 0.8,
                metalness: 0.2
            });

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Physics
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane()
            });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            physicsWorld.addBody(groundBody);

            // Add grid effect
            for (let i = -50; i <= 50; i += 5) {
                for (let j = -50; j <= 50; j += 5) {
                    if (Math.random() > 0.7) {
                        const glowGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
                        const glowMaterial = new THREE.MeshStandardMaterial({
                            color: 0x667eea,
                            emissive: 0x667eea,
                            emissiveIntensity: 2,
                            roughness: 0.1,
                            metalness: 0.9
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        glow.position.set(i, 0.05, j);
                        scene.add(glow);
                    }
                }
            }
        }

        function createPlayer() {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5
            });

            playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.position.set(0, 1, 0);
            playerMesh.castShadow = true;
            scene.add(playerMesh);

            playerBody = new CANNON.Body({
                mass: 1,
                shape: new CANNON.Sphere(0.5),
                position: new CANNON.Vec3(0, 1, 0)
            });
            physicsWorld.addBody(playerBody);

            player = {
                mesh: playerMesh,
                body: playerBody,
                canJump: true
            };
        }

        function createObstacles() {
            const obstacles = [
                { type: 'box', pos: [5, 1, 0], size: [1, 2, 1], color: 0xff6b6b },
                { type: 'box', pos: [-5, 1, 0], size: [1, 2, 1], color: 0x4ecdc4 },
                { type: 'sphere', pos: [0, 1, -5], size: 1, color: 0xffe66d },
                { type: 'box', pos: [3, 0.5, 3], size: [4, 1, 4], color: 0x95e1d3 },
            ];

            for (const obs of obstacles) {
                let geometry, shape;

                if (obs.type === 'box') {
                    geometry = new THREE.BoxGeometry(...obs.size);
                    shape = new CANNON.Box(new CANNON.Vec3(obs.size[0]/2, obs.size[1]/2, obs.size[2]/2));
                } else if (obs.type === 'sphere') {
                    geometry = new THREE.SphereGeometry(obs.size, 32, 32);
                    shape = new CANNON.Sphere(obs.size);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: obs.color,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: obs.color,
                    emissiveIntensity: 0.3
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...obs.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                const body = new CANNON.Body({
                    mass: 0,
                    shape: shape,
                    position: new CANNON.Vec3(...obs.pos)
                });
                physicsWorld.addBody(body);

                levelObjects.push({ mesh, body });
            }
        }

        // ============== GAME LOOP ==============
        const clock = { startTime: Date.now(), elapsedTime: 0 };
        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            clock.elapsedTime = (currentTime - clock.startTime) / 1000;

            if (gameMode === 'singleplayer' || gameMode === 'multiplayer') {
                updatePlayer(dt);
                updatePhysics(dt);
                updateCamera();
                particles.update(dt);

                // Record replay data
                if (!replayPlayback && gameMode !== 'menu') {
                    recordReplayFrame();
                }
            }

            if (gameMode === 'replay' && replayPlaying) {
                updateReplay(dt);
            }

            // Animated lighting
            const time = clock.elapsedTime;
            scene.children.forEach(child => {
                if (child instanceof THREE.PointLight) {
                    child.intensity = 2 + Math.sin(time * 2) * 0.5;
                }
            });

            renderer.render(scene, camera);
        }

        function updatePlayer(dt) {
            if (!player || !pointerLocked) return;

            const moveSpeed = 5;
            const direction = new THREE.Vector3();
            const rotation = camera.rotation.y || 0;

            if (keys['w']) {
                direction.z -= Math.cos(rotation);
                direction.x -= Math.sin(rotation);
            }
            if (keys['s']) {
                direction.z += Math.cos(rotation);
                direction.x += Math.sin(rotation);
            }
            if (keys['a']) {
                direction.x -= Math.cos(rotation);
                direction.z += Math.sin(rotation);
            }
            if (keys['d']) {
                direction.x += Math.cos(rotation);
                direction.z -= Math.sin(rotation);
            }

            if (direction.length() > 0) {
                direction.normalize();
                playerBody.velocity.x = direction.x * moveSpeed;
                playerBody.velocity.z = direction.z * moveSpeed;

                // Emit particles while moving
                if (settings.particles && Math.random() > 0.7) {
                    particles.emit(
                        new THREE.Vector3(playerMesh.position.x, playerMesh.position.y - 0.4, playerMesh.position.z),
                        0x667eea,
                        2
                    );
                }
            } else {
                playerBody.velocity.x *= 0.9;
                playerBody.velocity.z *= 0.9;
            }

            if (keys[' '] && player.canJump) {
                playerBody.velocity.y = 7;
                player.canJump = false;

                if (settings.particles) {
                    particles.emit(
                        new THREE.Vector3(playerMesh.position.x, playerMesh.position.y - 0.5, playerMesh.position.z),
                        0x00ff00,
                        15
                    );
                }
            }

            // Check if on ground
            if (Math.abs(playerBody.velocity.y) < 0.1 && playerMesh.position.y < 1.1) {
                player.canJump = true;
            }
        }

        function updatePhysics(dt) {
            physicsWorld.step(dt);

            // Update player mesh from physics
            if (player) {
                playerMesh.position.copy(player.body.position);
            }
        }

        function updateCamera() {
            if (!player) return;

            // Third-person camera
            const cameraDistance = 8;
            const cameraHeight = 4;

            const rotationY = mouseMovement.x * 0.002;
            const rotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, mouseMovement.y * 0.002));

            camera.position.x = playerMesh.position.x - Math.sin(rotationY) * cameraDistance;
            camera.position.z = playerMesh.position.z - Math.cos(rotationY) * cameraDistance;
            camera.position.y = playerMesh.position.y + cameraHeight + Math.sin(rotationX) * 3;

            camera.lookAt(playerMesh.position.x, playerMesh.position.y + 1, playerMesh.position.z);
            camera.rotation.y = rotationY;
        }

        // ============== INPUT HANDLING ==============
        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        function onMouseMove(e) {
            if (pointerLocked) {
                mouseMovement.x += e.movementX;
                mouseMovement.y += e.movementY;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============== MENU FUNCTIONS ==============
        function createRoom() {
            username = document.getElementById('username').value.trim();
            if (!username) {
                showNotification('Please enter a username');
                return;
            }

            roomCode = generateRoomCode();
            isHost = true;
            startMultiplayer();
        }

        function showJoinRoom() {
            document.getElementById('join-room-section').classList.remove('hidden');
        }

        function joinRoom() {
            username = document.getElementById('username').value.trim();
            roomCode = document.getElementById('room-code').value.trim().toUpperCase();

            if (!username || !roomCode) {
                showNotification('Please enter username and room code');
                return;
            }

            isHost = false;
            startMultiplayer();
        }

        function startSinglePlayer() {
            username = document.getElementById('username').value.trim() || 'Player';
            gameMode = 'singleplayer';
            startGame();
        }

        function startMultiplayer() {
            gameMode = 'multiplayer';
            startGame();
            setupWebRTC();
        }

        function startGame() {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-hud').style.display = 'block';
            document.getElementById('chat-panel').style.display = 'block';

            if (gameMode === 'multiplayer') {
                document.getElementById('room-code-display').textContent = `Room: ${roomCode}`;
                updatePlayersList();
            }

            replayData = [];
        }

        function returnToMenu() {
            gameMode = 'menu';
            document.getElementById('menu-screen').classList.remove('hidden');
            document.getElementById('game-hud').style.display = 'none';
            document.getElementById('chat-panel').style.display = 'none';
            document.getElementById('editor-panel').style.display = 'none';
            document.getElementById('replay-controls').style.display = 'none';

            if (pointerLocked) {
                document.exitPointerLock();
            }

            // Clean up WebRTC
            peers.forEach(peer => peer.close());
            peers.clear();
            dataChannels.clear();

            // Reset player position
            if (player) {
                playerBody.position.set(0, 1, 0);
                playerBody.velocity.set(0, 0, 0);
            }

            particles.clear();
        }

        function showLevelEditor() {
            username = document.getElementById('username').value.trim() || 'Editor';
            gameMode = 'editor';
            editorMode = true;

            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('editor-panel').style.display = 'block';

            showNotification('Editor Mode: Click to place objects');
        }

        function exitEditor() {
            editorMode = false;
            returnToMenu();
        }

        function showReplayViewer() {
            const replays = localStorage.getItem('game_replays');
            if (!replays) {
                showNotification('No replays saved');
                return;
            }

            gameMode = 'replay';
            replayData = JSON.parse(replays);
            replayTime = 0;
            replayPlaying = false;

            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('replay-controls').style.display = 'block';

            showNotification('Replay loaded');
        }

        // ============== WEBRTC P2P ==============
        function setupWebRTC() {
            // Simplified WebRTC setup
            // In a real implementation, this would use a signaling server
            showNotification(isHost ? 'Room created! Share code: ' + roomCode : 'Connecting...');

            setTimeout(() => {
                showNotification('WebRTC P2P ready');
                updatePlayersList();
            }, 1000);
        }

        function updatePlayersList() {
            const playersList = document.getElementById('players-list');
            playersList.innerHTML = `<div style="margin-top: 10px;">Players: ${username} (You)</div>`;

            peers.forEach((peer, id) => {
                playersList.innerHTML += `<div>${id}</div>`;
            });
        }

        // ============== CHAT ==============
        function sendChatMessage(message) {
            const chatMsg = {
                username: username,
                message: message,
                timestamp: Date.now()
            };

            addChatMessage(chatMsg);

            // Send to peers
            dataChannels.forEach(channel => {
                if (channel.readyState === 'open') {
                    channel.send(JSON.stringify({ type: 'chat', data: chatMsg }));
                }
            });
        }

        function addChatMessage(msg) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message';
            messageEl.innerHTML = `<span class="chat-username">${msg.username}:</span> ${msg.message}`;
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            chatMessages.push(msg);
        }

        // ============== REPLAY SYSTEM ==============
        function recordReplayFrame() {
            if (!player) return;

            replayData.push({
                time: Date.now(),
                position: {
                    x: playerMesh.position.x,
                    y: playerMesh.position.y,
                    z: playerMesh.position.z
                },
                rotation: {
                    x: camera.rotation.x,
                    y: camera.rotation.y,
                    z: camera.rotation.z
                }
            });

            // Limit replay data size
            if (replayData.length > 3000) {
                replayData.shift();
            }
        }

        function updateReplay(dt) {
            replayTime += dt * 1000;

            const frame = replayData.find(f => f.time >= replayTime);
            if (frame && player) {
                playerMesh.position.set(frame.position.x, frame.position.y, frame.position.z);
                camera.rotation.set(frame.rotation.x, frame.rotation.y, frame.rotation.z);
            }

            updateReplayTime();
        }

        function replayPlayPause() {
            replayPlaying = !replayPlaying;
        }

        function replayRestart() {
            replayTime = 0;
            replayPlaying = false;
        }

        function exitReplay() {
            replayPlayback = false;
            returnToMenu();
        }

        function updateReplayTime() {
            const current = Math.floor(replayTime / 1000);
            const total = Math.floor((replayData[replayData.length - 1]?.time || 0) / 1000);
            document.getElementById('replay-time').textContent =
                `${Math.floor(current / 60)}:${(current % 60).toString().padStart(2, '0')} / ${Math.floor(total / 60)}:${(total % 60).toString().padStart(2, '0')}`;
        }

        // ============== LEVEL EDITOR ==============
        function placeObject() {
            const type = document.getElementById('object-type').value;
            const color = document.getElementById('object-color').value;

            const position = [
                camera.position.x + Math.sin(camera.rotation.y) * 5,
                2,
                camera.position.z + Math.cos(camera.rotation.y) * 5
            ];

            let geometry, shape, size;

            switch (type) {
                case 'box':
                    size = [1, 1, 1];
                    geometry = new THREE.BoxGeometry(...size);
                    shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.5, 32, 32);
                    shape = new CANNON.Sphere(0.5);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
                    shape = new CANNON.Cylinder(0.5, 0.5, 2, 32);
                    break;
                case 'platform':
                    size = [4, 0.5, 4];
                    geometry = new THREE.BoxGeometry(...size);
                    shape = new CANNON.Box(new CANNON.Vec3(2, 0.25, 2));
                    break;
            }

            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: color,
                emissiveIntensity: 0.3
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(...position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const body = new CANNON.Body({
                mass: 0,
                shape: shape,
                position: new CANNON.Vec3(...position)
            });
            physicsWorld.addBody(body);

            levelObjects.push({ mesh, body, type, color });

            if (settings.particles) {
                particles.emit(new THREE.Vector3(...position), parseInt(color.replace('#', '0x')), 20);
            }

            showNotification('Object placed!');
        }

        function deleteObject() {
            if (levelObjects.length > 4) { // Keep initial obstacles
                const obj = levelObjects.pop();
                scene.remove(obj.mesh);
                physicsWorld.removeBody(obj.body);
                showNotification('Object deleted!');
            }
        }

        function saveLevel() {
            const levelData = levelObjects.map(obj => ({
                type: obj.type,
                color: obj.color,
                position: [obj.mesh.position.x, obj.mesh.position.y, obj.mesh.position.z]
            }));

            localStorage.setItem('custom_level', JSON.stringify(levelData));
            showNotification('Level saved!');
        }

        function loadLevel() {
            const levelData = localStorage.getItem('custom_level');
            if (!levelData) {
                showNotification('No saved level found');
                return;
            }

            // Clear current objects (except initial ones)
            while (levelObjects.length > 4) {
                const obj = levelObjects.pop();
                scene.remove(obj.mesh);
                physicsWorld.removeBody(obj.body);
            }

            const objects = JSON.parse(levelData);
            objects.forEach(obj => {
                // Recreate objects from saved data
                document.getElementById('object-type').value = obj.type;
                document.getElementById('object-color').value = obj.color;
                // Would need to set position and call placeObject
            });

            showNotification('Level loaded!');
        }

        // ============== GRAPHICS SETTINGS ==============
        function switchTab(tab) {
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tab + '-tab').classList.add('active');
        }

        function toggleShadows() {
            settings.shadows = document.getElementById('shadows-toggle').checked;
            renderer.shadowMap.enabled = settings.shadows;
        }

        function toggleBloom() {
            settings.bloom = document.getElementById('bloom-toggle').checked;
            // Bloom would be implemented with post-processing in a full version
        }

        function toggleParticles() {
            settings.particles = document.getElementById('particles-toggle').checked;
            particles.enabled = settings.particles;
        }

        function toggleAA() {
            settings.antialiasing = document.getElementById('aa-toggle').checked;
            // Would require renderer recreation in a real implementation
            showNotification('Please reload for AA changes');
        }

        // ============== UTILITIES ==============
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ============== START ==============
        window.addEventListener('load', init);

        // Save replay on exit
        window.addEventListener('beforeunload', () => {
            if (replayData.length > 0) {
                localStorage.setItem('game_replays', JSON.stringify(replayData));
            }
        });
    </script>
</body>
</html>