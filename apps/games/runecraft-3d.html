<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Runecraft 3D - Isometric MMORPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .ui-element {
            position: absolute;
            pointer-events: auto;
        }

        /* Chat Box */
        .chat-box {
            bottom: 10px;
            left: 10px;
            width: 400px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 5px;
            padding: 5px;
            font-size: 12px;
            color: #fff;
            overflow-y: auto;
        }

        .chat-message {
            margin: 2px 0;
            text-shadow: 1px 1px 0 #000;
        }

        .chat-message.combat { color: #ff6b6b; }
        .chat-message.loot { color: #ffd93d; }
        .chat-message.system { color: #6bcf7f; }
        .chat-message.level { color: #00ffff; font-weight: bold; }

        /* Minimap */
        .minimap {
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
            border-radius: 5px;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* Stats Panel */
        .stats-panel {
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 5px;
            padding: 10px;
            color: #fff;
            min-width: 200px;
        }

        .stat-bar {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            font-size: 12px;
            width: 60px;
            text-shadow: 1px 1px 0 #000;
        }

        .stat-bar-bg {
            flex: 1;
            height: 20px;
            background: #222;
            border: 1px solid #444;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s;
            position: relative;
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            z-index: 1;
        }

        .health-fill { background: linear-gradient(to bottom, #ff6b6b, #cc0000); }
        .mana-fill { background: linear-gradient(to bottom, #6bb6ff, #0066cc); }
        .exp-fill { background: linear-gradient(to bottom, #ffd700, #cc9900); }

        /* Inventory */
        .inventory {
            bottom: 10px;
            right: 10px;
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
            border-radius: 5px;
            padding: 10px;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(8, 35px);
            gap: 3px;
        }

        .inv-slot {
            width: 35px;
            height: 35px;
            background: rgba(50, 50, 50, 0.8);
            border: 1px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 20px;
        }

        .inv-slot:hover {
            border-color: #ff0;
            background: rgba(80, 80, 50, 0.8);
        }

        .item-count {
            position: absolute;
            bottom: 0;
            right: 2px;
            font-size: 10px;
            color: #ff0;
            text-shadow: 1px 1px 0 #000;
        }

        /* Action Bar */
        .action-bar {
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border: 2px solid #444;
            border-radius: 5px;
        }

        .action-slot {
            width: 50px;
            height: 50px;
            background: rgba(50, 50, 50, 0.9);
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 24px;
        }

        .action-slot:hover {
            border-color: #ff0;
        }

        .action-slot.on-cooldown {
            filter: brightness(0.3);
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 255, 0.3);
            transition: height 0.1s;
        }

        .hotkey {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #ff0;
            text-shadow: 1px 1px 0 #000;
        }

        /* Enemy Health Bar */
        .enemy-health {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -200px);
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #666;
            min-width: 200px;
            display: none;
        }

        .enemy-health.active {
            display: block;
        }

        .enemy-name {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 5px;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
        }

        .enemy-bar {
            height: 20px;
            background: #222;
            border: 1px solid #444;
            position: relative;
        }

        .enemy-bar-fill {
            height: 100%;
            background: linear-gradient(to bottom, #ff6b6b, #cc0000);
            transition: width 0.3s;
        }

        /* Damage Numbers */
        .damage-text {
            position: absolute;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }

        @keyframes damageFloat {
            0% {
                transform: translate(-50%, 0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50px);
                opacity: 0;
            }
        }

        .damage-player { color: #ff6b6b; }
        .damage-enemy { color: #ffd700; }
        .damage-heal { color: #6bcf7f; }

        /* Level Up Effect */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 3px 3px 0 #000;
            animation: levelUpPulse 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes levelUpPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #666;
            display: none;
            z-index: 1000;
        }

        .context-menu.active {
            display: block;
        }

        .context-option {
            padding: 5px 15px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
        }

        .context-option:hover {
            background: rgba(255, 255, 0, 0.2);
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 2000;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 18px;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: #222;
            border: 1px solid #444;
            margin-top: 10px;
        }

        .loading-fill {
            height: 100%;
            background: #ff0;
            width: 0%;
            transition: width 0.3s;
        }

        /* Skills Window */
        .skills-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 500px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #666;
            border-radius: 5px;
            padding: 20px;
            display: none;
            overflow-y: auto;
        }

        .skills-window.active {
            display: block;
        }

        .skills-title {
            color: #ff0;
            text-align: center;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px;
            background: rgba(50, 50, 50, 0.5);
            border: 1px solid #333;
        }

        .skill-name {
            color: #fff;
            font-size: 14px;
        }

        .skill-level {
            color: #ff0;
            font-weight: bold;
        }

        .skill-exp-bar {
            width: 100%;
            height: 5px;
            background: #222;
            margin-top: 3px;
        }

        .skill-exp-fill {
            height: 100%;
            background: #0f0;
        }

        /* Save/Load Buttons */
        .save-controls {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .save-btn {
            padding: 8px 15px;
            background: rgba(0, 100, 0, 0.8);
            border: 1px solid #0f0;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
        }

        .save-btn:hover {
            background: rgba(0, 150, 0, 0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <!-- Stats Panel -->
            <div class="stats-panel ui-element">
                <div class="stat-bar">
                    <span class="stat-label">HP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill health-fill" id="healthBar" style="width: 100%">
                            <span class="stat-bar-text" id="healthText">100/100</span>
                        </div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">MP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill mana-fill" id="manaBar" style="width: 100%">
                            <span class="stat-bar-text" id="manaText">50/50</span>
                        </div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">XP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill exp-fill" id="expBar" style="width: 0%">
                            <span class="stat-bar-text" id="expText">0/100</span>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 10px; color: #ffd700; font-size: 14px;">
                    <span>Level: <span id="playerLevel">1</span></span> |
                    <span>Gold: <span id="playerGold">0</span></span>
                </div>
            </div>

            <!-- Minimap -->
            <div class="minimap ui-element">
                <canvas id="minimapCanvas"></canvas>
            </div>

            <!-- Enemy Health Bar -->
            <div class="enemy-health ui-element" id="enemyHealth">
                <div class="enemy-name" id="enemyName">Goblin</div>
                <div class="enemy-bar">
                    <div class="enemy-bar-fill" id="enemyHealthFill" style="width: 100%"></div>
                </div>
            </div>

            <!-- Action Bar -->
            <div class="action-bar ui-element">
                <div class="action-slot" data-action="attack">
                    <span class="hotkey">1</span>
                    ⚔️
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="magic">
                    <span class="hotkey">2</span>
                    🔮
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="ranged">
                    <span class="hotkey">3</span>
                    🏹
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="heal">
                    <span class="hotkey">4</span>
                    ❤️
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="special">
                    <span class="hotkey">5</span>
                    ⚡
                    <div class="cooldown-overlay"></div>
                </div>
            </div>

            <!-- Inventory -->
            <div class="inventory ui-element">
                <div style="color: #fff; margin-bottom: 10px; text-align: center;">Inventory</div>
                <div class="inv-grid" id="inventoryGrid"></div>
            </div>

            <!-- Chat Box -->
            <div class="chat-box ui-element" id="chatBox"></div>

            <!-- Save Controls -->
            <div class="save-controls ui-element">
                <button class="save-btn" onclick="game.saveGame()">💾 Save</button>
                <button class="save-btn" onclick="game.loadGame()">📂 Load</button>
                <button class="save-btn" onclick="game.exportSave()">📤 Export</button>
                <button class="save-btn" onclick="game.importSave()">📥 Import</button>
            </div>

            <!-- Skills Window -->
            <div class="skills-window ui-element" id="skillsWindow">
                <div class="skills-title">SKILLS</div>
                <div id="skillsList"></div>
                <button class="save-btn" style="margin-top: 20px; width: 100%;" onclick="game.toggleSkills()">Close</button>
            </div>

            <!-- Context Menu -->
            <div class="context-menu ui-element" id="contextMenu"></div>
        </div>

        <!-- Loading Screen -->
        <div class="loading" id="loadingScreen">
            <div class="loading-text">Loading Runecraft 3D...</div>
            <div class="loading-bar">
                <div class="loading-fill" id="loadingFill"></div>
            </div>
        </div>
    </div>

    <script>
        class Runecraft3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');

                // Set canvas size
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Game state
                this.tileSize = 32;
                this.viewWidth = 25;
                this.viewHeight = 18;

                // Camera
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 1,
                    angle: 45 * Math.PI / 180,
                    height: 0.5
                };

                // Player data
                this.player = {
                    x: 12,
                    y: 9,
                    z: 0,
                    targetX: 12,
                    targetY: 9,
                    facing: 'south',
                    moving: false,
                    moveProgress: 0,
                    level: 1,
                    health: 100,
                    maxHealth: 100,
                    mana: 50,
                    maxMana: 50,
                    exp: 0,
                    expToNext: 100,
                    gold: 0,
                    combatLevel: 1,
                    inCombat: false,
                    lastCombat: 0,
                    skills: {
                        attack: { level: 1, exp: 0, expToNext: 83 },
                        strength: { level: 1, exp: 0, expToNext: 83 },
                        defense: { level: 1, exp: 0, expToNext: 83 },
                        hitpoints: { level: 10, exp: 1154, expToNext: 1358 },
                        ranged: { level: 1, exp: 0, expToNext: 83 },
                        prayer: { level: 1, exp: 0, expToNext: 83 },
                        magic: { level: 1, exp: 0, expToNext: 83 },
                        cooking: { level: 1, exp: 0, expToNext: 83 },
                        woodcutting: { level: 1, exp: 0, expToNext: 83 },
                        fletching: { level: 1, exp: 0, expToNext: 83 },
                        fishing: { level: 1, exp: 0, expToNext: 83 },
                        firemaking: { level: 1, exp: 0, expToNext: 83 },
                        crafting: { level: 1, exp: 0, expToNext: 83 },
                        smithing: { level: 1, exp: 0, expToNext: 83 },
                        mining: { level: 1, exp: 0, expToNext: 83 },
                        herblore: { level: 1, exp: 0, expToNext: 83 },
                        agility: { level: 1, exp: 0, expToNext: 83 },
                        thieving: { level: 1, exp: 0, expToNext: 83 },
                        slayer: { level: 1, exp: 0, expToNext: 83 },
                        farming: { level: 1, exp: 0, expToNext: 83 },
                        runecrafting: { level: 1, exp: 0, expToNext: 83 },
                        hunter: { level: 1, exp: 0, expToNext: 83 },
                        construction: { level: 1, exp: 0, expToNext: 83 }
                    },
                    inventory: [],
                    equipment: {
                        weapon: null,
                        armor: null,
                        shield: null,
                        helmet: null,
                        boots: null,
                        gloves: null,
                        amulet: null,
                        ring: null
                    }
                };

                // World map
                this.worldMap = this.generateWorld();

                // NPCs and Enemies
                this.npcs = [];
                this.enemies = [];
                this.projectiles = [];
                this.effects = [];
                this.lootDrops = [];

                // Game timing
                this.lastTime = 0;
                this.deltaTime = 0;
                this.gameTime = 0;

                // Input
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };

                // Initialize game
                this.init();
            }

            generateWorld() {
                const width = 50;
                const height = 50;
                const map = [];

                // Generate base terrain
                for (let y = 0; y < height; y++) {
                    map[y] = [];
                    for (let x = 0; x < width; x++) {
                        const dist = Math.sqrt(Math.pow(x - 25, 2) + Math.pow(y - 25, 2));
                        let tile = 'grass';

                        // Create varied terrain
                        if (Math.random() < 0.1) tile = 'grass2';
                        if (Math.random() < 0.05) tile = 'flower';
                        if (dist > 20) tile = 'dirt';
                        if (dist > 30) tile = 'stone';
                        if (x === 0 || y === 0 || x === width-1 || y === height-1) tile = 'water';

                        // Add trees
                        if (tile === 'grass' && Math.random() < 0.05) tile = 'tree';

                        // Add rocks
                        if ((tile === 'stone' || tile === 'dirt') && Math.random() < 0.1) tile = 'rock';

                        map[y][x] = {
                            type: tile,
                            height: tile === 'tree' ? 1 : tile === 'rock' ? 0.5 : 0,
                            solid: tile === 'water' || tile === 'tree' || tile === 'rock'
                        };
                    }
                }

                // Add paths
                for (let i = 0; i < 5; i++) {
                    let x = Math.floor(Math.random() * width);
                    let y = Math.floor(Math.random() * height);
                    let dir = Math.floor(Math.random() * 4);
                    let length = 10 + Math.floor(Math.random() * 20);

                    for (let j = 0; j < length; j++) {
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            map[y][x] = { type: 'path', height: 0, solid: false };

                            // Randomly change direction
                            if (Math.random() < 0.3) {
                                dir = Math.floor(Math.random() * 4);
                            }

                            // Move in direction
                            switch(dir) {
                                case 0: y--; break;
                                case 1: x++; break;
                                case 2: y++; break;
                                case 3: x--; break;
                            }
                        }
                    }
                }

                // Create spawn area
                for (let y = 8; y < 12; y++) {
                    for (let x = 10; x < 15; x++) {
                        map[y][x] = { type: 'stone_floor', height: 0, solid: false };
                    }
                }

                return map;
            }

            init() {
                // Set up input handlers
                this.setupInput();

                // Spawn initial enemies
                this.spawnEnemies();

                // Start game loop
                this.hideLoading();
                this.gameLoop(0);

                // Start regeneration
                setInterval(() => this.regenerate(), 2000);

                // Initial UI update
                this.updateUI();
                this.renderInventory();
                this.addChatMessage('Welcome to Runecraft 3D!', 'system');
                this.addChatMessage('Click to move, click enemies to attack!', 'system');
                this.addChatMessage('Press K for skills, I for inventory', 'system');
            }

            setupInput() {
                // Mouse controls
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleKeyPress(e.key.toLowerCase());
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Action bar clicks
                document.querySelectorAll('.action-slot').forEach(slot => {
                    slot.addEventListener('click', () => {
                        const action = slot.dataset.action;
                        this.useAbility(action);
                    });
                });
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Convert screen to world coordinates
                const worldPos = this.screenToWorld(x, y);

                // Check if clicking on enemy
                const enemy = this.getEnemyAt(worldPos.x, worldPos.y);
                if (enemy) {
                    this.targetEnemy(enemy);
                    return;
                }

                // Check if clicking on loot
                const loot = this.getLootAt(worldPos.x, worldPos.y);
                if (loot) {
                    this.pickupLoot(loot);
                    return;
                }

                // Move player
                this.movePlayer(worldPos.x, worldPos.y);
            }

            handleRightClick(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const worldPos = this.screenToWorld(x, y);
                const enemy = this.getEnemyAt(worldPos.x, worldPos.y);

                if (enemy) {
                    this.showContextMenu(e.clientX, e.clientY, [
                        { text: 'Attack', action: () => this.targetEnemy(enemy) },
                        { text: 'Examine', action: () => this.examineEnemy(enemy) }
                    ]);
                }
            }

            handleKeyPress(key) {
                switch(key) {
                    case '1': this.useAbility('attack'); break;
                    case '2': this.useAbility('magic'); break;
                    case '3': this.useAbility('ranged'); break;
                    case '4': this.useAbility('heal'); break;
                    case '5': this.useAbility('special'); break;
                    case 'k': this.toggleSkills(); break;
                    case 'i': this.toggleInventory(); break;
                    case 'escape': this.closeAllWindows(); break;
                }
            }

            screenToWorld(screenX, screenY) {
                // Simplified isometric conversion
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                const isoX = (screenX - centerX) / this.tileSize;
                const isoY = (screenY - centerY) / (this.tileSize * 0.5);

                const worldX = (isoX + isoY) / 2 + this.camera.x;
                const worldY = (isoY - isoX) / 2 + this.camera.y;

                return {
                    x: Math.floor(worldX + this.player.x),
                    y: Math.floor(worldY + this.player.y)
                };
            }

            worldToScreen(worldX, worldY, worldZ = 0) {
                const relX = worldX - this.player.x - this.camera.x;
                const relY = worldY - this.player.y - this.camera.y;

                const isoX = (relX - relY) * this.tileSize;
                const isoY = (relX + relY) * this.tileSize * 0.5 - worldZ * this.tileSize;

                return {
                    x: this.canvas.width / 2 + isoX,
                    y: this.canvas.height / 2 + isoY
                };
            }

            movePlayer(targetX, targetY) {
                if (this.player.moving) return;

                // Check if target is valid
                if (!this.isValidPosition(targetX, targetY)) return;

                // Check distance (max 1 tile at a time for smooth movement)
                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) return; // Too far

                // Set target and start moving
                this.player.targetX = targetX;
                this.player.targetY = targetY;
                this.player.moving = true;
                this.player.moveProgress = 0;

                // Update facing direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.player.facing = dx > 0 ? 'east' : 'west';
                } else {
                    this.player.facing = dy > 0 ? 'south' : 'north';
                }
            }

            isValidPosition(x, y) {
                if (x < 0 || y < 0 || x >= this.worldMap[0].length || y >= this.worldMap.length) {
                    return false;
                }
                return !this.worldMap[y][x].solid;
            }

            getEnemyAt(x, y) {
                return this.enemies.find(e =>
                    Math.floor(e.x) === x && Math.floor(e.y) === y && e.health > 0
                );
            }

            getLootAt(x, y) {
                return this.lootDrops.find(l =>
                    Math.floor(l.x) === x && Math.floor(l.y) === y
                );
            }

            targetEnemy(enemy) {
                this.player.target = enemy;
                this.player.inCombat = true;
                this.player.lastCombat = this.gameTime;

                // Show enemy health bar
                const enemyHealth = document.getElementById('enemyHealth');
                enemyHealth.classList.add('active');

                // Move towards enemy if not in range
                const dist = this.getDistance(this.player, enemy);
                if (dist > 1.5) {
                    this.movePlayer(Math.floor(enemy.x), Math.floor(enemy.y));
                } else {
                    this.attackEnemy(enemy);
                }
            }

            attackEnemy(enemy, type = 'melee') {
                if (!enemy || enemy.health <= 0) return;

                const dist = this.getDistance(this.player, enemy);

                // Check range based on attack type
                const maxRange = type === 'ranged' ? 8 : type === 'magic' ? 6 : 1.5;
                if (dist > maxRange) {
                    this.addChatMessage('Target is too far away!', 'combat');
                    return;
                }

                // Calculate damage
                let damage = 0;
                let accuracy = 0;

                switch(type) {
                    case 'melee':
                        damage = Math.floor(Math.random() * 10) + this.player.skills.strength.level;
                        accuracy = 50 + this.player.skills.attack.level * 2;
                        this.addSkillExp('attack', 4);
                        this.addSkillExp('strength', 4);
                        break;
                    case 'ranged':
                        damage = Math.floor(Math.random() * 8) + this.player.skills.ranged.level;
                        accuracy = 50 + this.player.skills.ranged.level * 2;
                        this.addSkillExp('ranged', 4);
                        // Create arrow projectile
                        this.createProjectile(this.player, enemy, 'arrow');
                        break;
                    case 'magic':
                        if (this.player.mana < 5) {
                            this.addChatMessage('Not enough mana!', 'combat');
                            return;
                        }
                        this.player.mana -= 5;
                        damage = Math.floor(Math.random() * 12) + this.player.skills.magic.level * 2;
                        accuracy = 60 + this.player.skills.magic.level * 2;
                        this.addSkillExp('magic', 5);
                        // Create magic projectile
                        this.createProjectile(this.player, enemy, 'magic');
                        break;
                }

                // Roll for hit
                if (Math.random() * 100 > accuracy) {
                    this.showDamageText(enemy.x, enemy.y, 'Miss', 'damage-player');
                    this.addChatMessage('You missed!', 'combat');
                    return;
                }

                // Apply damage
                enemy.health -= damage;
                this.showDamageText(enemy.x, enemy.y, damage, 'damage-enemy');
                this.addSkillExp('hitpoints', Math.floor(damage * 1.33));

                if (enemy.health <= 0) {
                    this.enemyDefeated(enemy);
                } else {
                    // Enemy retaliation
                    setTimeout(() => this.enemyAttack(enemy), 1000);
                }

                this.updateUI();
            }

            enemyAttack(enemy) {
                if (!enemy || enemy.health <= 0) return;
                if (this.getDistance(this.player, enemy) > 2) return;

                const accuracy = 50 + enemy.level * 2;
                if (Math.random() * 100 > accuracy) {
                    this.showDamageText(this.player.x, this.player.y, 'Miss', 'damage-player');
                    return;
                }

                const damage = Math.floor(Math.random() * enemy.maxDamage) + 1;
                const reducedDamage = Math.max(1, damage - Math.floor(this.player.skills.defense.level / 2));

                this.player.health -= reducedDamage;
                this.showDamageText(this.player.x, this.player.y, reducedDamage, 'damage-player');
                this.addSkillExp('defense', 1);

                if (this.player.health <= 0) {
                    this.playerDeath();
                }

                this.updateUI();
            }

            enemyDefeated(enemy) {
                const exp = enemy.exp || 20;
                const gold = enemy.gold || Math.floor(Math.random() * 20) + 5;

                this.player.exp += exp;
                this.player.gold += gold;

                this.addChatMessage(`Defeated ${enemy.name}! +${exp} XP, +${gold} gold`, 'loot');

                // Drop loot
                if (Math.random() < 0.3) {
                    this.dropLoot(enemy.x, enemy.y, enemy.level);
                }

                // Remove enemy
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }

                // Hide enemy health bar
                document.getElementById('enemyHealth').classList.remove('active');
                this.player.target = null;
                this.player.inCombat = false;

                // Check level up
                this.checkLevelUp();

                // Respawn enemy after delay
                setTimeout(() => this.spawnEnemy(), 10000);
            }

            dropLoot(x, y, level) {
                const items = [
                    { name: 'Health Potion', icon: '🧪', type: 'potion', value: 50 },
                    { name: 'Mana Potion', icon: '💙', type: 'potion', value: 30 },
                    { name: 'Iron Sword', icon: '⚔️', type: 'weapon', value: 100 },
                    { name: 'Leather Armor', icon: '🦺', type: 'armor', value: 75 },
                    { name: 'Gold Ring', icon: '💍', type: 'accessory', value: 150 },
                    { name: 'Magic Scroll', icon: '📜', type: 'magic', value: 200 }
                ];

                const item = items[Math.floor(Math.random() * items.length)];

                this.lootDrops.push({
                    x: x,
                    y: y,
                    z: 0,
                    item: item,
                    bounce: 1
                });

                this.addChatMessage(`${item.name} dropped!`, 'loot');
            }

            pickupLoot(loot) {
                if (this.getDistance(this.player, loot) > 1.5) {
                    this.movePlayer(Math.floor(loot.x), Math.floor(loot.y));
                    return;
                }

                // Add to inventory
                if (this.player.inventory.length < 28) {
                    this.player.inventory.push(loot.item);
                    this.addChatMessage(`Picked up ${loot.item.name}`, 'loot');

                    // Remove loot
                    const index = this.lootDrops.indexOf(loot);
                    if (index > -1) {
                        this.lootDrops.splice(index, 1);
                    }

                    this.renderInventory();
                } else {
                    this.addChatMessage('Inventory full!', 'system');
                }
            }

            createProjectile(source, target, type) {
                this.projectiles.push({
                    x: source.x,
                    y: source.y,
                    z: 0.5,
                    targetX: target.x,
                    targetY: target.y,
                    type: type,
                    progress: 0,
                    speed: type === 'arrow' ? 0.05 : 0.03
                });
            }

            showDamageText(x, y, text, className) {
                const pos = this.worldToScreen(x, y, 0.5);
                const elem = document.createElement('div');
                elem.className = `damage-text ${className}`;
                elem.textContent = text;
                elem.style.left = pos.x + 'px';
                elem.style.top = pos.y + 'px';
                document.querySelector('.ui-overlay').appendChild(elem);

                setTimeout(() => elem.remove(), 1000);
            }

            useAbility(ability) {
                if (!this.player.target) {
                    this.addChatMessage('No target selected!', 'combat');
                    return;
                }

                switch(ability) {
                    case 'attack':
                        this.attackEnemy(this.player.target, 'melee');
                        break;
                    case 'magic':
                        this.attackEnemy(this.player.target, 'magic');
                        break;
                    case 'ranged':
                        this.attackEnemy(this.player.target, 'ranged');
                        break;
                    case 'heal':
                        this.healPlayer();
                        break;
                    case 'special':
                        this.specialAttack();
                        break;
                }

                // Show cooldown animation
                const slot = document.querySelector(`[data-action="${ability}"]`);
                if (slot) {
                    slot.classList.add('on-cooldown');
                    setTimeout(() => slot.classList.remove('on-cooldown'), 1000);
                }
            }

            healPlayer() {
                if (this.player.mana < 10) {
                    this.addChatMessage('Not enough mana!', 'combat');
                    return;
                }

                const healAmount = Math.min(20 + this.player.skills.prayer.level * 2,
                                           this.player.maxHealth - this.player.health);

                if (healAmount <= 0) {
                    this.addChatMessage('Already at full health!', 'system');
                    return;
                }

                this.player.mana -= 10;
                this.player.health += healAmount;
                this.showDamageText(this.player.x, this.player.y, `+${healAmount}`, 'damage-heal');
                this.addChatMessage(`Healed ${healAmount} HP`, 'system');
                this.addSkillExp('prayer', 5);
                this.updateUI();
            }

            specialAttack() {
                if (this.player.mana < 20) {
                    this.addChatMessage('Not enough mana!', 'combat');
                    return;
                }

                this.player.mana -= 20;

                // Area attack
                this.enemies.forEach(enemy => {
                    if (this.getDistance(this.player, enemy) < 3) {
                        const damage = Math.floor(Math.random() * 20) + 10;
                        enemy.health -= damage;
                        this.showDamageText(enemy.x, enemy.y, damage, 'damage-enemy');

                        if (enemy.health <= 0) {
                            this.enemyDefeated(enemy);
                        }
                    }
                });

                // Visual effect
                this.effects.push({
                    x: this.player.x,
                    y: this.player.y,
                    type: 'explosion',
                    frame: 0
                });

                this.addChatMessage('Special attack!', 'combat');
                this.updateUI();
            }

            getDistance(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            spawnEnemies() {
                const enemyTypes = [
                    { name: 'Goblin', icon: '👺', color: '#4a4', health: 30, maxDamage: 5, level: 1, exp: 20 },
                    { name: 'Skeleton', icon: '💀', color: '#ccc', health: 40, maxDamage: 7, level: 2, exp: 30 },
                    { name: 'Orc', icon: '👹', color: '#484', health: 60, maxDamage: 10, level: 3, exp: 50 },
                    { name: 'Spider', icon: '🕷️', color: '#333', health: 25, maxDamage: 6, level: 1, exp: 15 },
                    { name: 'Wolf', icon: '🐺', color: '#666', health: 45, maxDamage: 8, level: 2, exp: 35 }
                ];

                // Spawn initial enemies
                for (let i = 0; i < 10; i++) {
                    this.spawnEnemy();
                }
            }

            spawnEnemy() {
                const enemyTypes = [
                    { name: 'Goblin', icon: '👺', color: '#4a4', health: 30, maxDamage: 5, level: 1, exp: 20, gold: 10 },
                    { name: 'Skeleton', icon: '💀', color: '#ccc', health: 40, maxDamage: 7, level: 2, exp: 30, gold: 15 },
                    { name: 'Orc', icon: '👹', color: '#484', health: 60, maxDamage: 10, level: 3, exp: 50, gold: 25 },
                    { name: 'Spider', icon: '🕷️', color: '#333', health: 25, maxDamage: 6, level: 1, exp: 15, gold: 8 },
                    { name: 'Wolf', icon: '🐺', color: '#666', health: 45, maxDamage: 8, level: 2, exp: 35, gold: 18 }
                ];

                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

                let x, y;
                do {
                    x = Math.floor(Math.random() * 40) + 5;
                    y = Math.floor(Math.random() * 40) + 5;
                } while (!this.isValidPosition(x, y) || this.getDistance({x, y}, this.player) < 5);

                this.enemies.push({
                    ...type,
                    x: x,
                    y: y,
                    z: 0,
                    maxHealth: type.health,
                    targetX: x,
                    targetY: y,
                    moving: false,
                    moveProgress: 0
                });
            }

            update(deltaTime) {
                // Update player movement
                if (this.player.moving) {
                    this.player.moveProgress += deltaTime * 0.005;

                    if (this.player.moveProgress >= 1) {
                        this.player.x = this.player.targetX;
                        this.player.y = this.player.targetY;
                        this.player.moving = false;
                        this.player.moveProgress = 0;

                        // Attack if we reached enemy
                        if (this.player.target) {
                            const dist = this.getDistance(this.player, this.player.target);
                            if (dist <= 1.5) {
                                this.attackEnemy(this.player.target);
                            }
                        }
                    } else {
                        // Interpolate position
                        const startX = this.player.x;
                        const startY = this.player.y;
                        const t = this.easeInOutQuad(this.player.moveProgress);

                        this.player.x = startX + (this.player.targetX - startX) * t;
                        this.player.y = startY + (this.player.targetY - startY) * t;
                    }
                }

                // Update enemies
                this.enemies.forEach(enemy => {
                    // Simple AI: move towards player if close enough
                    const dist = this.getDistance(enemy, this.player);
                    if (dist < 8 && dist > 1.5 && Math.random() < 0.01) {
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const moveX = Math.sign(dx);
                        const moveY = Math.sign(dy);

                        const newX = Math.floor(enemy.x + moveX);
                        const newY = Math.floor(enemy.y + moveY);

                        if (this.isValidPosition(newX, newY)) {
                            enemy.targetX = newX;
                            enemy.targetY = newY;
                            enemy.moving = true;
                            enemy.moveProgress = 0;
                        }
                    }

                    // Update enemy movement
                    if (enemy.moving) {
                        enemy.moveProgress += deltaTime * 0.003;

                        if (enemy.moveProgress >= 1) {
                            enemy.x = enemy.targetX;
                            enemy.y = enemy.targetY;
                            enemy.moving = false;
                            enemy.moveProgress = 0;

                            // Attack player if close
                            if (this.getDistance(enemy, this.player) <= 1.5) {
                                this.enemyAttack(enemy);
                            }
                        } else {
                            const t = this.easeInOutQuad(enemy.moveProgress);
                            const startX = enemy.x - (enemy.targetX - enemy.x);
                            const startY = enemy.y - (enemy.targetY - enemy.y);

                            enemy.x = startX + (enemy.targetX - startX) * t;
                            enemy.y = startY + (enemy.targetY - startY) * t;
                        }
                    }
                });

                // Update projectiles
                this.projectiles.forEach((proj, index) => {
                    proj.progress += proj.speed;

                    if (proj.progress >= 1) {
                        this.projectiles.splice(index, 1);
                    } else {
                        const t = proj.progress;
                        proj.x += (proj.targetX - proj.x) * t;
                        proj.y += (proj.targetY - proj.y) * t;
                        proj.z = 0.5 + Math.sin(t * Math.PI) * 0.5;
                    }
                });

                // Update loot drops (bouncing animation)
                this.lootDrops.forEach(loot => {
                    loot.bounce *= 0.98;
                    loot.z = Math.abs(Math.sin(this.gameTime * 0.003)) * 0.2 * loot.bounce;
                });

                // Update effects
                this.effects.forEach((effect, index) => {
                    effect.frame++;
                    if (effect.frame > 30) {
                        this.effects.splice(index, 1);
                    }
                });

                // Update UI if target exists
                if (this.player.target && this.player.target.health > 0) {
                    document.getElementById('enemyName').textContent = this.player.target.name;
                    const healthPercent = (this.player.target.health / this.player.target.maxHealth) * 100;
                    document.getElementById('enemyHealthFill').style.width = healthPercent + '%';
                } else if (this.player.target) {
                    document.getElementById('enemyHealth').classList.remove('active');
                    this.player.target = null;
                }
            }

            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Calculate visible tiles
                const startX = Math.floor(this.player.x - this.viewWidth / 2);
                const endX = Math.ceil(this.player.x + this.viewWidth / 2);
                const startY = Math.floor(this.player.y - this.viewHeight / 2);
                const endY = Math.ceil(this.player.y + this.viewHeight / 2);

                // Render tiles
                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        if (y >= 0 && y < this.worldMap.length && x >= 0 && x < this.worldMap[0].length) {
                            const tile = this.worldMap[y][x];
                            this.renderTile(x, y, tile);
                        }
                    }
                }

                // Render entities in correct order (back to front)
                const entities = [
                    ...this.lootDrops.map(l => ({...l, type: 'loot'})),
                    ...this.enemies.map(e => ({...e, type: 'enemy'})),
                    ...this.projectiles.map(p => ({...p, type: 'projectile'})),
                    {x: this.player.x, y: this.player.y, z: 0, type: 'player'}
                ];

                // Sort by Y position for correct rendering order
                entities.sort((a, b) => {
                    const orderA = a.y + a.x * 0.01;
                    const orderB = b.y + b.x * 0.01;
                    return orderA - orderB;
                });

                // Render entities
                entities.forEach(entity => {
                    switch(entity.type) {
                        case 'player':
                            this.renderPlayer();
                            break;
                        case 'enemy':
                            this.renderEnemy(entity);
                            break;
                        case 'loot':
                            this.renderLoot(entity);
                            break;
                        case 'projectile':
                            this.renderProjectile(entity);
                            break;
                    }
                });

                // Render effects
                this.effects.forEach(effect => {
                    this.renderEffect(effect);
                });

                // Render minimap
                this.renderMinimap();
            }

            renderTile(x, y, tile) {
                const pos = this.worldToScreen(x, y, 0);

                // Tile colors
                const colors = {
                    grass: '#4a7c4e',
                    grass2: '#3d6640',
                    flower: '#5a8c5e',
                    dirt: '#8b7355',
                    stone: '#808080',
                    stone_floor: '#666666',
                    path: '#9b8c75',
                    water: '#4682b4',
                    tree: '#228b22',
                    rock: '#696969'
                };

                const tileColor = colors[tile.type] || '#333';

                // Draw tile
                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Draw diamond shape (isometric square)
                this.ctx.beginPath();
                this.ctx.moveTo(0, -this.tileSize * 0.5);
                this.ctx.lineTo(this.tileSize, 0);
                this.ctx.lineTo(0, this.tileSize * 0.5);
                this.ctx.lineTo(-this.tileSize, 0);
                this.ctx.closePath();

                // Fill tile
                this.ctx.fillStyle = tileColor;
                this.ctx.fill();

                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                // Draw height objects (trees, rocks)
                if (tile.height > 0) {
                    if (tile.type === 'tree') {
                        // Draw tree
                        this.ctx.fillStyle = '#654321';
                        this.ctx.fillRect(-5, -tile.height * this.tileSize - 10, 10, tile.height * this.tileSize);

                        this.ctx.fillStyle = '#228b22';
                        this.ctx.beginPath();
                        this.ctx.arc(0, -tile.height * this.tileSize - 15, 15, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else if (tile.type === 'rock') {
                        // Draw rock
                        this.ctx.fillStyle = '#5a5a5a';
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, -tile.height * this.tileSize * 0.5, 12, 8, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                this.ctx.restore();
            }

            renderPlayer() {
                const pos = this.worldToScreen(this.player.x, this.player.y, 0);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 5, 10, 5, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Body
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(-8, -30, 16, 20);

                // Head
                this.ctx.fillStyle = '#fdbcb4';
                this.ctx.beginPath();
                this.ctx.arc(0, -35, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // Armor/clothes
                this.ctx.fillStyle = '#4169e1';
                this.ctx.fillRect(-8, -20, 16, 15);

                // Legs
                this.ctx.fillStyle = '#4169e1';
                this.ctx.fillRect(-5, -10, 4, 10);
                this.ctx.fillRect(1, -10, 4, 10);

                // Weapon
                if (this.player.equipment.weapon) {
                    this.ctx.strokeStyle = '#silver';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(10, -20);
                    this.ctx.lineTo(10, -35);
                    this.ctx.stroke();
                }

                // Name
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('You', 0, -45);

                this.ctx.restore();
            }

            renderEnemy(enemy) {
                const pos = this.worldToScreen(enemy.x, enemy.y, enemy.z);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 5, 10, 5, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Simple enemy sprite
                this.ctx.fillStyle = enemy.color;
                this.ctx.fillRect(-10, -25, 20, 25);

                // Icon
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(enemy.icon, 0, -5);

                // Name
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Arial';
                this.ctx.fillText(enemy.name, 0, -35);

                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const healthPercent = enemy.health / enemy.maxHealth;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(-20, -45, 40, 4);

                    this.ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                    this.ctx.fillRect(-20, -45, 40 * healthPercent, 4);
                }

                this.ctx.restore();
            }

            renderLoot(loot) {
                const pos = this.worldToScreen(loot.x, loot.y, loot.z);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                // Shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 5, 8, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Glow effect
                this.ctx.shadowColor = '#ff0';
                this.ctx.shadowBlur = 10;

                // Item icon
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(loot.item.icon, 0, 0);

                this.ctx.restore();
            }

            renderProjectile(proj) {
                const pos = this.worldToScreen(proj.x, proj.y, proj.z);

                this.ctx.save();
                this.ctx.translate(pos.x, pos.y);

                if (proj.type === 'arrow') {
                    // Arrow
                    this.ctx.strokeStyle = '#8b4513';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-5, 0);
                    this.ctx.lineTo(5, 0);
                    this.ctx.stroke();
                } else if (proj.type === 'magic') {
                    // Magic bolt
                    this.ctx.fillStyle = '#00f';
                    this.ctx.shadowColor = '#00f';
                    this.ctx.shadowBlur = 10;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.restore();
            }

            renderEffect(effect) {
                if (effect.type === 'explosion') {
                    const pos = this.worldToScreen(effect.x, effect.y, 0);

                    this.ctx.save();
                    this.ctx.translate(pos.x, pos.y);

                    const radius = effect.frame * 3;
                    const opacity = 1 - (effect.frame / 30);

                    this.ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    this.ctx.stroke();

                    this.ctx.restore();
                }
            }

            renderMinimap() {
                const scale = 3;
                const width = 150;
                const height = 150;

                // Clear minimap
                this.minimapCtx.fillStyle = '#000';
                this.minimapCtx.fillRect(0, 0, width, height);

                // Draw map
                const centerX = width / 2;
                const centerY = height / 2;

                for (let y = -25; y <= 25; y++) {
                    for (let x = -25; x <= 25; x++) {
                        const mapX = Math.floor(this.player.x + x);
                        const mapY = Math.floor(this.player.y + y);

                        if (mapX >= 0 && mapY >= 0 && mapY < this.worldMap.length && mapX < this.worldMap[0].length) {
                            const tile = this.worldMap[mapY][mapX];

                            const colors = {
                                grass: '#2d4a2f',
                                grass2: '#254027',
                                flower: '#3a5c3e',
                                dirt: '#5b4a35',
                                stone: '#404040',
                                stone_floor: '#333333',
                                path: '#6b5c45',
                                water: '#2a5a7a',
                                tree: '#1a5a1a',
                                rock: '#3a3a3a'
                            };

                            this.minimapCtx.fillStyle = colors[tile.type] || '#222';
                            this.minimapCtx.fillRect(
                                centerX + x * scale,
                                centerY + y * scale,
                                scale,
                                scale
                            );
                        }
                    }
                }

                // Draw enemies
                this.enemies.forEach(enemy => {
                    const dx = enemy.x - this.player.x;
                    const dy = enemy.y - this.player.y;
                    if (Math.abs(dx) < 25 && Math.abs(dy) < 25) {
                        this.minimapCtx.fillStyle = '#f00';
                        this.minimapCtx.fillRect(
                            centerX + dx * scale - 1,
                            centerY + dy * scale - 1,
                            3,
                            3
                        );
                    }
                });

                // Draw player
                this.minimapCtx.fillStyle = '#fff';
                this.minimapCtx.fillRect(centerX - 2, centerY - 2, 4, 4);
            }

            updateUI() {
                // Health
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent =
                    `${Math.floor(this.player.health)}/${this.player.maxHealth}`;

                // Mana
                const manaPercent = (this.player.mana / this.player.maxMana) * 100;
                document.getElementById('manaBar').style.width = manaPercent + '%';
                document.getElementById('manaText').textContent =
                    `${Math.floor(this.player.mana)}/${this.player.maxMana}`;

                // Experience
                const expPercent = (this.player.exp / this.player.expToNext) * 100;
                document.getElementById('expBar').style.width = expPercent + '%';
                document.getElementById('expText').textContent =
                    `${this.player.exp}/${this.player.expToNext}`;

                // Level and gold
                document.getElementById('playerLevel').textContent = this.player.level;
                document.getElementById('playerGold').textContent = this.player.gold;

                // Combat level
                this.updateCombatLevel();
            }

            updateCombatLevel() {
                const att = this.player.skills.attack.level;
                const str = this.player.skills.strength.level;
                const def = this.player.skills.defense.level;
                const hp = this.player.skills.hitpoints.level;
                const pray = this.player.skills.prayer.level;
                const range = this.player.skills.ranged.level;
                const mage = this.player.skills.magic.level;

                // Runescape combat level formula
                const base = 0.25 * (def + hp + Math.floor(pray / 2));
                const melee = 0.325 * (att + str);
                const ranger = 0.325 * (Math.floor(range * 1.5));
                const magic = 0.325 * (Math.floor(mage * 1.5));

                this.player.combatLevel = Math.floor(base + Math.max(melee, ranger, magic));
            }

            renderInventory() {
                const grid = document.getElementById('inventoryGrid');
                grid.innerHTML = '';

                for (let i = 0; i < 28; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot';

                    if (this.player.inventory[i]) {
                        const item = this.player.inventory[i];
                        slot.innerHTML = item.icon;
                        if (item.quantity > 1) {
                            const count = document.createElement('div');
                            count.className = 'item-count';
                            count.textContent = item.quantity;
                            slot.appendChild(count);
                        }

                        slot.onclick = () => this.useItem(i);
                    }

                    grid.appendChild(slot);
                }
            }

            useItem(index) {
                const item = this.player.inventory[index];
                if (!item) return;

                if (item.type === 'potion') {
                    if (item.name.includes('Health')) {
                        const healAmount = Math.min(50, this.player.maxHealth - this.player.health);
                        this.player.health += healAmount;
                        this.showDamageText(this.player.x, this.player.y, `+${healAmount}`, 'damage-heal');
                        this.addChatMessage(`Used ${item.name}`, 'system');
                    } else if (item.name.includes('Mana')) {
                        const manaAmount = Math.min(30, this.player.maxMana - this.player.mana);
                        this.player.mana += manaAmount;
                        this.addChatMessage(`Used ${item.name}, restored ${manaAmount} MP`, 'system');
                    }

                    this.player.inventory.splice(index, 1);
                    this.renderInventory();
                    this.updateUI();
                } else if (item.type === 'weapon' || item.type === 'armor') {
                    // Equip item
                    const slot = item.type === 'weapon' ? 'weapon' : 'armor';
                    const oldItem = this.player.equipment[slot];
                    this.player.equipment[slot] = item;

                    if (oldItem) {
                        this.player.inventory[index] = oldItem;
                    } else {
                        this.player.inventory.splice(index, 1);
                    }

                    this.addChatMessage(`Equipped ${item.name}`, 'system');
                    this.renderInventory();
                    this.updateUI();
                }
            }

            addSkillExp(skill, amount) {
                const s = this.player.skills[skill];
                if (!s) return;

                s.exp += amount;

                // Level up check
                while (s.exp >= s.expToNext) {
                    s.level++;
                    s.exp -= s.expToNext;
                    s.expToNext = Math.floor(s.expToNext * 1.15);

                    this.addChatMessage(`${skill.charAt(0).toUpperCase() + skill.slice(1)} level up! Now level ${s.level}`, 'level');

                    // Special bonuses
                    if (skill === 'hitpoints') {
                        this.player.maxHealth += 5;
                        this.player.health += 5;
                    }
                }

                this.updateUI();
            }

            checkLevelUp() {
                while (this.player.exp >= this.player.expToNext) {
                    this.player.level++;
                    this.player.exp -= this.player.expToNext;
                    this.player.expToNext = Math.floor(this.player.expToNext * 1.5);

                    // Increase stats
                    this.player.maxHealth += 10;
                    this.player.health = this.player.maxHealth;
                    this.player.maxMana += 5;
                    this.player.mana = this.player.maxMana;

                    // Show level up effect
                    const levelUpDiv = document.createElement('div');
                    levelUpDiv.className = 'level-up';
                    levelUpDiv.textContent = 'LEVEL UP!';
                    document.querySelector('.ui-overlay').appendChild(levelUpDiv);
                    setTimeout(() => levelUpDiv.remove(), 2000);

                    this.addChatMessage(`LEVEL UP! You are now level ${this.player.level}!`, 'level');
                }

                this.updateUI();
            }

            regenerate() {
                // Regen health when out of combat
                if (this.gameTime - this.player.lastCombat > 5000) {
                    if (this.player.health < this.player.maxHealth) {
                        this.player.health = Math.min(this.player.health + 2, this.player.maxHealth);
                    }
                }

                // Regen mana
                if (this.player.mana < this.player.maxMana) {
                    this.player.mana = Math.min(this.player.mana + 1, this.player.maxMana);
                }

                this.updateUI();
            }

            playerDeath() {
                this.player.health = this.player.maxHealth;
                this.player.x = 12;
                this.player.y = 9;
                this.player.gold = Math.max(0, this.player.gold - Math.floor(this.player.gold * 0.1));

                this.addChatMessage('You died! Lost 10% of your gold. Respawning...', 'combat');

                // Clear combat
                this.player.inCombat = false;
                this.player.target = null;
                document.getElementById('enemyHealth').classList.remove('active');

                this.updateUI();
            }

            addChatMessage(text, type = '') {
                const chatBox = document.getElementById('chatBox');
                const message = document.createElement('div');
                message.className = `chat-message ${type}`;
                message.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                chatBox.appendChild(message);
                chatBox.scrollTop = chatBox.scrollHeight;

                // Limit messages
                while (chatBox.children.length > 50) {
                    chatBox.removeChild(chatBox.firstChild);
                }
            }

            toggleSkills() {
                const window = document.getElementById('skillsWindow');
                window.classList.toggle('active');

                if (window.classList.contains('active')) {
                    this.renderSkillsWindow();
                }
            }

            renderSkillsWindow() {
                const list = document.getElementById('skillsList');
                list.innerHTML = '';

                for (const [name, skill] of Object.entries(this.player.skills)) {
                    const item = document.createElement('div');
                    item.className = 'skill-item';

                    const expPercent = (skill.exp / skill.expToNext) * 100;

                    item.innerHTML = `
                        <span class="skill-name">${name.charAt(0).toUpperCase() + name.slice(1)}</span>
                        <span class="skill-level">Level ${skill.level}</span>
                        <div class="skill-exp-bar">
                            <div class="skill-exp-fill" style="width: ${expPercent}%"></div>
                        </div>
                    `;

                    list.appendChild(item);
                }
            }

            toggleInventory() {
                // Inventory is always visible in this version
                const inv = document.querySelector('.inventory');
                inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
            }

            closeAllWindows() {
                document.getElementById('skillsWindow').classList.remove('active');
                document.getElementById('contextMenu').classList.remove('active');
            }

            showContextMenu(x, y, options) {
                const menu = document.getElementById('contextMenu');
                menu.innerHTML = '';

                options.forEach(opt => {
                    const div = document.createElement('div');
                    div.className = 'context-option';
                    div.textContent = opt.text;
                    div.onclick = () => {
                        opt.action();
                        menu.classList.remove('active');
                    };
                    menu.appendChild(div);
                });

                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.add('active');

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', () => {
                        menu.classList.remove('active');
                    }, { once: true });
                }, 100);
            }

            examineEnemy(enemy) {
                this.addChatMessage(`${enemy.name}: Level ${enemy.level}, ${enemy.health}/${enemy.maxHealth} HP`, 'system');
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.minimapCanvas.width = 150;
                this.minimapCanvas.height = 150;
            }

            hideLoading() {
                const loading = document.getElementById('loadingScreen');
                document.getElementById('loadingFill').style.width = '100%';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
            }

            gameLoop(timestamp) {
                this.deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.gameTime = timestamp;

                this.update(this.deltaTime);
                this.render();

                requestAnimationFrame((t) => this.gameLoop(t));
            }

            // Save/Load functionality
            saveGame() {
                const saveData = {
                    player: this.player,
                    timestamp: Date.now(),
                    version: '1.0'
                };

                localStorage.setItem('runecraft3d_save', JSON.stringify(saveData));
                this.addChatMessage('Game saved!', 'system');
            }

            loadGame() {
                const saveData = localStorage.getItem('runecraft3d_save');
                if (!saveData) {
                    this.addChatMessage('No save game found!', 'system');
                    return;
                }

                try {
                    const data = JSON.parse(saveData);
                    this.player = data.player;
                    this.updateUI();
                    this.renderInventory();
                    this.addChatMessage('Game loaded!', 'system');
                } catch (e) {
                    this.addChatMessage('Failed to load save!', 'system');
                }
            }

            exportSave() {
                const saveData = localStorage.getItem('runecraft3d_save');
                if (!saveData) {
                    this.addChatMessage('No save to export!', 'system');
                    return;
                }

                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `runecraft3d_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.addChatMessage('Save exported!', 'system');
            }

            importSave() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            localStorage.setItem('runecraft3d_save', event.target.result);
                            this.loadGame();
                        } catch (err) {
                            this.addChatMessage('Invalid save file!', 'system');
                        }
                    };
                    reader.readAsText(file);
                };

                input.click();
            }
        }

        // Initialize game
        const game = new Runecraft3D();

        // Handle window focus for pausing
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Pause game
            } else {
                // Resume game
            }
        });
    </script>
</body>
</html>