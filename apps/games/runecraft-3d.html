<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Runecraft 3D - Isometric MMORPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .ui-element {
            position: absolute;
            pointer-events: auto;
        }

        /* Boss Battle UI */
        .boss-battle-ui {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0.7));
            padding: 30px;
            border-top: 3px solid #ff0000;
        }

        .boss-battle-ui.active {
            display: block;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .boss-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .boss-name {
            font-size: 32px;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .boss-health-container {
            max-width: 600px;
            margin: 0 auto 20px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 15px;
            border: 2px solid #ff0000;
        }

        .boss-health-bar {
            height: 30px;
            background: linear-gradient(90deg, #ff0000, #ff6666);
            border-radius: 10px;
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 16px;
        }

        .battle-actions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 800px;
            margin: 0 auto;
        }

        .battle-action-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .battle-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .battle-action-btn:active {
            transform: scale(0.95);
        }

        .battle-action-btn.attack {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .battle-action-btn.skill {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .battle-action-btn.item {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .battle-action-btn.flee {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .battle-action-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .battle-log {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            display: none;
            z-index: 1000;
            border: 2px solid #00ff88;
            max-width: 400px;
            text-align: center;
        }

        .battle-log.show {
            display: block;
            animation: battleLogPulse 0.5s ease;
        }

        @keyframes battleLogPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* Chat Box */
        .chat-box {
            bottom: 20px;
            left: 20px;
            width: 400px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            color: white;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-box.boss-battle-mode {
            display: none;
        }

        .chat-message {
            margin: 5px 0;
            font-size: 14px;
        }

        .chat-message.combat { color: #ff6b6b; }
        .chat-message.loot { color: #ffd93d; }
        .chat-message.system { color: #00ff88; }
        .chat-message.level { color: #00ffff; font-weight: bold; }
        .chat-message.boss { color: #ff00ff; font-weight: bold; }

        /* Minimap */
        .minimap {
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .minimap.boss-battle-mode {
            display: none;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        /* Stats Panel */
        .stats-panel {
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-bar {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            font-size: 14px;
            width: 60px;
            color: #00ff88;
            font-weight: bold;
        }

        .stat-bar-bg {
            flex: 1;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s;
            position: relative;
            border-radius: 10px;
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            z-index: 1;
        }

        .health-fill { background: linear-gradient(90deg, #ff4444, #ff6b6b); }
        .mana-fill { background: linear-gradient(90deg, #4444ff, #6bb6ff); }
        .exp-fill { background: linear-gradient(90deg, #ffaa00, #ffd700); }

        /* Inventory */
        .inventory {
            bottom: 20px;
            right: 20px;
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inventory.boss-battle-mode {
            display: none;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(8, 35px);
            gap: 3px;
        }

        .inv-slot {
            width: 35px;
            height: 35px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 20px;
            transition: all 0.3s;
        }

        .inv-slot:hover {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            transform: scale(1.1);
        }

        .item-count {
            position: absolute;
            bottom: 0;
            right: 2px;
            font-size: 10px;
            color: #00ff88;
        }

        /* Action Bar */
        .action-bar {
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .action-bar.boss-battle-mode {
            display: none;
        }

        .action-slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 24px;
            transition: all 0.3s;
        }

        .action-slot:hover {
            border-color: #00ff88;
            transform: scale(1.1);
        }

        .action-slot.on-cooldown {
            filter: brightness(0.3);
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 100, 255, 0.3);
            transition: height 0.1s;
            border-radius: 0 0 8px 8px;
        }

        .hotkey {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #00ff88;
            font-weight: bold;
        }

        /* Enemy Health Bar */
        .enemy-health {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -200px);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            min-width: 200px;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .enemy-health.active {
            display: block;
        }

        .enemy-health.boss-battle-mode {
            display: none !important;
        }

        .enemy-name {
            color: #ff6b6b;
            text-align: center;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .enemy-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .enemy-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6b6b);
            transition: width 0.3s;
            border-radius: 10px;
        }

        /* Damage Numbers */
        .damage-text {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }

        @keyframes damageFloat {
            0% {
                transform: translate(-50%, 0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50px);
                opacity: 0;
            }
        }

        .damage-player { color: #ff6b6b; }
        .damage-enemy { color: #ffd700; }
        .damage-heal { color: #00ff88; }

        /* Level Up Effect */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ffd700;
            font-weight: bold;
            animation: levelUpPulse 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes levelUpPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .context-menu.active {
            display: block;
        }

        .context-option {
            padding: 10px 20px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .context-option:hover {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 2000;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
        }

        .loading-bar {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-fill {
            height: 100%;
            background: #00ff88;
            width: 0%;
            transition: width 0.3s;
            border-radius: 3px;
        }

        /* Skills Window */
        .skills-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 500px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 20px;
            display: none;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .skills-window.active {
            display: block;
        }

        .skills-title {
            color: #00ff88;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }

        .skill-name {
            color: #fff;
            font-size: 14px;
        }

        .skill-level {
            color: #00ff88;
            font-weight: bold;
        }

        .skill-exp-bar {
            width: 100%;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 5px;
            border-radius: 3px;
            overflow: hidden;
        }

        .skill-exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc66);
            border-radius: 3px;
        }

        /* Save/Load Buttons */
        .save-controls {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .save-btn {
            padding: 8px 16px;
            background: #00ff88;
            border: none;
            color: #000;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .save-btn:hover {
            background: #00cc66;
            transform: scale(1.05);
        }

        .boss-entrance-effect {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.8));
            pointer-events: none;
            opacity: 0;
            z-index: 999;
        }

        .boss-entrance-effect.active {
            animation: bossEntrance 1s ease-out;
        }

        @keyframes bossEntrance {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .teleport-btn {
            top: 180px;
            left: 20px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .teleport-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .enemy-count {
            top: 230px;
            left: 20px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <!-- Boss Entrance Effect -->
            <div class="boss-entrance-effect" id="bossEntranceEffect"></div>

            <!-- Boss Battle UI -->
            <div class="boss-battle-ui" id="bossBattleUI">
                <div class="boss-info">
                    <div class="boss-name" id="bossBattleName">DRAGON LORD</div>
                    <div class="boss-health-container">
                        <div class="boss-health-bar" id="bossBattleHealthBar" style="width: 100%">
                            <div class="boss-health-text" id="bossBattleHealthText">500/500</div>
                        </div>
                    </div>
                </div>
                <div class="battle-actions">
                    <button class="battle-action-btn attack" onclick="game.bossBattleAction('attack')">
                        <div class="battle-action-icon">⚔️</div>
                        <div>Attack</div>
                    </button>
                    <button class="battle-action-btn skill" onclick="game.bossBattleAction('skill')">
                        <div class="battle-action-icon">✨</div>
                        <div>Skill</div>
                    </button>
                    <button class="battle-action-btn item" onclick="game.bossBattleAction('item')">
                        <div class="battle-action-icon">🧪</div>
                        <div>Item</div>
                    </button>
                    <button class="battle-action-btn flee" onclick="game.bossBattleAction('flee')">
                        <div class="battle-action-icon">🏃</div>
                        <div>Flee</div>
                    </button>
                </div>
            </div>

            <!-- Battle Log -->
            <div class="battle-log" id="battleLog"></div>

            <!-- Stats Panel -->
            <div class="stats-panel ui-element">
                <div class="stat-bar">
                    <span class="stat-label">HP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill health-fill" id="healthBar" style="width: 100%">
                            <span class="stat-bar-text" id="healthText">100/100</span>
                        </div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">MP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill mana-fill" id="manaBar" style="width: 100%">
                            <span class="stat-bar-text" id="manaText">50/50</span>
                        </div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">XP</span>
                    <div class="stat-bar-bg">
                        <div class="stat-bar-fill exp-fill" id="expBar" style="width: 0%">
                            <span class="stat-bar-text" id="expText">0/100</span>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 15px; color: #00ff88; font-size: 14px;">
                    <span style="color: white;">Level:</span> <span id="playerLevel" style="font-weight: bold;">1</span> |
                    <span style="color: white;">Gold:</span> <span id="playerGold" style="font-weight: bold;">0</span>
                </div>
            </div>

            <!-- Teleport to Boss Button -->
            <button class="teleport-btn ui-element" onclick="game.teleportToBoss()">📍 Teleport to Boss</button>
            
            <!-- Enemy Count -->
            <div class="enemy-count ui-element" id="enemyCount">Enemies: 0</div>

            <!-- Minimap -->
            <div class="minimap ui-element" id="minimapContainer">
                <canvas id="minimapCanvas"></canvas>
            </div>

            <!-- Enemy Health Bar -->
            <div class="enemy-health ui-element" id="enemyHealth">
                <div class="enemy-name" id="enemyName">Goblin</div>
                <div class="enemy-bar">
                    <div class="enemy-bar-fill" id="enemyHealthFill" style="width: 100%"></div>
                </div>
            </div>

            <!-- Action Bar -->
            <div class="action-bar ui-element" id="actionBar">
                <div class="action-slot" data-action="attack">
                    <span class="hotkey">1</span>
                    ⚔️
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="magic">
                    <span class="hotkey">2</span>
                    🔮
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="ranged">
                    <span class="hotkey">3</span>
                    🏹
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="heal">
                    <span class="hotkey">4</span>
                    ❤️
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="action-slot" data-action="special">
                    <span class="hotkey">5</span>
                    ⚡
                    <div class="cooldown-overlay"></div>
                </div>
            </div>

            <!-- Inventory -->
            <div class="inventory ui-element" id="inventoryContainer">
                <div style="color: #00ff88; margin-bottom: 10px; text-align: center; font-weight: bold;">Inventory</div>
                <div class="inv-grid" id="inventoryGrid"></div>
            </div>

            <!-- Chat Box -->
            <div class="chat-box ui-element" id="chatBox"></div>

            <!-- Save Controls -->
            <div class="save-controls ui-element">
                <button class="save-btn" onclick="game.saveGame()">💾 Save</button>
                <button class="save-btn" onclick="game.loadGame()">📂 Load</button>
                <button class="save-btn" onclick="game.exportSave()">📤 Export</button>
                <button class="save-btn" onclick="game.importSave()">📥 Import</button>
            </div>

            <!-- Skills Window -->
            <div class="skills-window ui-element" id="skillsWindow">
                <div class="skills-title">SKILLS</div>
                <div id="skillsList"></div>
                <button class="save-btn" style="margin-top: 20px; width: 100%;" onclick="game.toggleSkills()">Close</button>
            </div>

            <!-- Context Menu -->
            <div class="context-menu ui-element" id="contextMenu"></div>
        </div>

        <!-- Loading Screen -->
        <div class="loading" id="loadingScreen">
            <div class="loading-text">Loading Runecraft 3D...</div>
            <div class="loading-bar">
                <div class="loading-fill" id="loadingFill"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class Runecraft3D {
            constructor() {
                // Three.js setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

                // Camera setup - Isometric view
                const aspect = window.innerWidth / window.innerHeight;
                const d = 50;
                this.camera = new THREE.OrthographicCamera(
                    -d * aspect, d * aspect, d, -d, 1, 1000
                );
                this.camera.position.set(100, 100, 100);
                this.camera.lookAt(0, 0, 0);

                // Store original camera settings for returning from boss battle
                this.originalCameraSettings = {
                    left: -d * aspect,
                    right: d * aspect,
                    top: d,
                    bottom: -d,
                    position: new THREE.Vector3(100, 100, 100),
                    lookAt: new THREE.Vector3(0, 0, 0)
                };

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB);

                // Lighting
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(this.ambientLight);

                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.directionalLight.position.set(50, 100, 50);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.camera.left = -100;
                this.directionalLight.shadow.camera.right = 100;
                this.directionalLight.shadow.camera.top = 100;
                this.directionalLight.shadow.camera.bottom = -100;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(this.directionalLight);

                // Boss battle state
                this.inBossBattle = false;
                this.currentBoss = null;
                this.bossBattleTurn = 'player';
                this.bossBattleAnimating = false;

                // Minimap canvas
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.minimapCanvas.width = 150;
                this.minimapCanvas.height = 150;

                // Game state
                this.tileSize = 5;
                this.worldSize = 50;
                this.chatMessages = [];
                this.maxEnemies = 15;
                this.enemySpawnTimer = 0;
                this.enemySpawnInterval = 5000; // Spawn new enemy every 5 seconds

                // Player data
                this.player = {
                    x: 12,
                    y: 9,
                    z: 0,
                    actualX: 12,  // Smooth position
                    actualY: 9,   // Smooth position
                    targetX: 12,
                    targetY: 9,
                    facing: 'south',
                    moving: false,
                    moveProgress: 0,
                    level: 1,
                    health: 100,
                    maxHealth: 100,
                    mana: 50,
                    maxMana: 50,
                    exp: 0,
                    expToNext: 100,
                    gold: 0,
                    combatLevel: 1,
                    inCombat: false,
                    lastCombat: 0,
                    mesh: null,
                    skills: {
                        attack: { level: 1, exp: 0, expToNext: 83 },
                        strength: { level: 1, exp: 0, expToNext: 83 },
                        defense: { level: 1, exp: 0, expToNext: 83 },
                        hitpoints: { level: 10, exp: 1154, expToNext: 1358 },
                        ranged: { level: 1, exp: 0, expToNext: 83 },
                        prayer: { level: 1, exp: 0, expToNext: 83 },
                        magic: { level: 1, exp: 0, expToNext: 83 },
                        cooking: { level: 1, exp: 0, expToNext: 83 },
                        woodcutting: { level: 1, exp: 0, expToNext: 83 },
                        fletching: { level: 1, exp: 0, expToNext: 83 },
                        fishing: { level: 1, exp: 0, expToNext: 83 },
                        firemaking: { level: 1, exp: 0, expToNext: 83 },
                        crafting: { level: 1, exp: 0, expToNext: 83 },
                        smithing: { level: 1, exp: 0, expToNext: 83 },
                        mining: { level: 1, exp: 0, expToNext: 83 },
                        herblore: { level: 1, exp: 0, expToNext: 83 },
                        agility: { level: 1, exp: 0, expToNext: 83 },
                        thieving: { level: 1, exp: 0, expToNext: 83 },
                        slayer: { level: 1, exp: 0, expToNext: 83 },
                        farming: { level: 1, exp: 0, expToNext: 83 },
                        runecrafting: { level: 1, exp: 0, expToNext: 83 },
                        hunter: { level: 1, exp: 0, expToNext: 83 },
                        construction: { level: 1, exp: 0, expToNext: 83 }
                    },
                    inventory: [],
                    equipment: {
                        weapon: null,
                        armor: null,
                        shield: null,
                        helmet: null,
                        boots: null,
                        gloves: null,
                        amulet: null,
                        ring: null
                    }
                };

                // Add starting potions to inventory
                this.player.inventory.push({ name: 'Health Potion', icon: '🧪', type: 'potion', value: 50 });
                this.player.inventory.push({ name: 'Health Potion', icon: '🧪', type: 'potion', value: 50 });
                this.player.inventory.push({ name: 'Mana Potion', icon: '💙', type: 'potion', value: 30 });

                // World map
                this.worldMap = this.generateWorld();
                this.createWorld3D();

                // NPCs and Enemies
                this.enemies = [];
                this.projectiles = [];
                this.effects = [];
                this.lootDrops = [];

                // Enemy behavior patterns with flocking parameters
                this.enemyPatterns = {
                    passive: { 
                        aggroRange: 3, 
                        moveChance: 0.02, 
                        attackSpeed: 2000,
                        moveSpeed: 0.015,
                        flockRadius: 5,
                        separationDistance: 1.5,
                        cohesionStrength: 0.3,
                        alignmentStrength: 0.2,
                        separationStrength: 0.5
                    },
                    aggressive: { 
                        aggroRange: 6, 
                        moveChance: 0.04, 
                        attackSpeed: 1500,
                        moveSpeed: 0.02,
                        flockRadius: 4,
                        separationDistance: 1.2,
                        cohesionStrength: 0.2,
                        alignmentStrength: 0.3,
                        separationStrength: 0.4
                    },
                    defensive: { 
                        aggroRange: 4, 
                        moveChance: 0.03, 
                        attackSpeed: 2500,
                        moveSpeed: 0.018,
                        flockRadius: 6,
                        separationDistance: 2,
                        cohesionStrength: 0.4,
                        alignmentStrength: 0.3,
                        separationStrength: 0.3
                    }
                };

                // Game timing
                this.lastTime = 0;
                this.deltaTime = 0;
                this.gameTime = 0;
                this.clock = new THREE.Clock();
                this.totalPlayTime = 0;

                // Input
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                // Mouse follow movement
                this.mouseFollowTarget = { x: 12, y: 9 };
                this.isMouseMoving = false;
                this.lastMouseMoveTime = 0;

                // Initialize game
                this.init();
            }

            generateWorld() {
                const width = this.worldSize;
                const height = this.worldSize;
                const map = [];

                for (let y = 0; y < height; y++) {
                    map[y] = [];
                    for (let x = 0; x < width; x++) {
                        const dist = Math.sqrt(Math.pow(x - 25, 2) + Math.pow(y - 25, 2));
                        let tile = 'grass';

                        if (Math.random() < 0.1) tile = 'grass2';
                        if (Math.random() < 0.05) tile = 'flower';
                        if (dist > 20) tile = 'dirt';
                        if (dist > 30) tile = 'stone';
                        if (x === 0 || y === 0 || x === width-1 || y === height-1) tile = 'water';

                        if (tile === 'grass' && Math.random() < 0.05) tile = 'tree';
                        if ((tile === 'stone' || tile === 'dirt') && Math.random() < 0.1) tile = 'rock';

                        map[y][x] = {
                            type: tile,
                            height: tile === 'tree' ? 1 : tile === 'rock' ? 0.5 : 0,
                            solid: tile === 'water' || tile === 'tree' || tile === 'rock'
                        };
                    }
                }

                // Add paths
                for (let i = 0; i < 5; i++) {
                    let x = Math.floor(Math.random() * width);
                    let y = Math.floor(Math.random() * height);
                    let dir = Math.floor(Math.random() * 4);
                    let length = 10 + Math.floor(Math.random() * 20);

                    for (let j = 0; j < length; j++) {
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            map[y][x] = { type: 'path', height: 0, solid: false };

                            if (Math.random() < 0.3) {
                                dir = Math.floor(Math.random() * 4);
                            }

                            switch(dir) {
                                case 0: y--; break;
                                case 1: x++; break;
                                case 2: y++; break;
                                case 3: x--; break;
                            }
                        }
                    }
                }

                // Create spawn area
                for (let y = 8; y < 12; y++) {
                    for (let x = 10; x < 15; x++) {
                        map[y][x] = { type: 'stone_floor', height: 0, solid: false };
                    }
                }

                // Create boss arena area - MAKE IT ACCESSIBLE
                for (let y = 23; y < 28; y++) {
                    for (let x = 23; x < 28; x++) {
                        // Only walls on the very edge, leave entrance
                        if ((y === 23 || y === 27 || x === 23 || x === 27) && !(x === 25 && y === 23)) {
                            map[y][x] = { type: 'stone', height: 0.5, solid: true };
                        } else {
                            map[y][x] = { type: 'stone_floor', height: 0, solid: false };
                        }
                    }
                }

                // Create a clear path to boss arena
                for (let y = 12; y < 24; y++) {
                    for (let x = 24; x < 27; x++) {
                        map[y][x] = { type: 'path', height: 0, solid: false };
                    }
                }

                return map;
            }

            createWorld3D() {
                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(
                    this.worldSize * this.tileSize, 
                    this.worldSize * this.tileSize
                );
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a8c3a });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);

                // Create tiles and obstacles
                for (let y = 0; y < this.worldSize; y++) {
                    for (let x = 0; x < this.worldSize; x++) {
                        const tile = this.worldMap[y][x];
                        const worldX = (x - this.worldSize/2) * this.tileSize;
                        const worldZ = (y - this.worldSize/2) * this.tileSize;

                        if (tile.type === 'tree') {
                            this.createTree(worldX, worldZ);
                        } else if (tile.type === 'rock') {
                            this.createRock(worldX, worldZ);
                        } else if (tile.type === 'water') {
                            this.createWaterTile(worldX, worldZ);
                        } else if (tile.type === 'stone_floor') {
                            this.createStoneTile(worldX, worldZ);
                        } else if (tile.type === 'path') {
                            this.createPathTile(worldX, worldZ);
                        }
                    }
                }

                // Create player mesh
                this.createPlayer();
            }

            createTree(x, z) {
                const group = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Foliage
                const foliageGeometry = new THREE.SphereGeometry(2, 8, 6);
                const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 5;
                foliage.castShadow = true;
                group.add(foliage);
                
                group.position.set(x, 0, z);
                this.scene.add(group);
            }

            createRock(x, z) {
                const geometry = new THREE.SphereGeometry(1, 6, 5);
                const material = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const rock = new THREE.Mesh(geometry, material);
                rock.position.set(x, 0.5, z);
                rock.scale.y = 0.7;
                rock.castShadow = true;
                this.scene.add(rock);
            }

            createWaterTile(x, z) {
                const geometry = new THREE.PlaneGeometry(this.tileSize, this.tileSize);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x4682b4,
                    transparent: true,
                    opacity: 0.8
                });
                const water = new THREE.Mesh(geometry, material);
                water.rotation.x = -Math.PI / 2;
                water.position.set(x, 0.1, z);
                this.scene.add(water);
            }

            createStoneTile(x, z) {
                const geometry = new THREE.PlaneGeometry(this.tileSize * 0.95, this.tileSize * 0.95);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x555555
                });
                const stone = new THREE.Mesh(geometry, material);
                stone.rotation.x = -Math.PI / 2;
                stone.position.set(x, 0.05, z);
                this.scene.add(stone);
            }

            createPathTile(x, z) {
                const geometry = new THREE.PlaneGeometry(this.tileSize * 0.95, this.tileSize * 0.95);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x8B7355
                });
                const path = new THREE.Mesh(geometry, material);
                path.rotation.x = -Math.PI / 2;
                path.position.set(x, 0.02, z);
                this.scene.add(path);
            }

            createPlayer() {
                const group = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169e1 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                body.castShadow = true;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, 8, 6);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xfdbcb4 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2;
                head.castShadow = true;
                group.add(head);
                
                // Light
                const light = new THREE.PointLight(0x00ff88, 0.5, 10);
                light.position.y = 2.5;
                group.add(light);
                
                this.player.mesh = group;
                this.scene.add(group);
                this.updatePlayerPosition();
            }

            createEnemy3D(enemy) {
                const group = new THREE.Group();
                
                // Boss enemies get special treatment
                if (enemy.isBoss) {
                    // Create larger, more impressive model for boss
                    const coreGeometry = new THREE.OctahedronGeometry(2, 1);
                    const coreMaterial = new THREE.MeshLambertMaterial({ 
                        color: enemy.color3d,
                        emissive: enemy.color3d,
                        emissiveIntensity: 0.3
                    });
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    core.castShadow = true;
                    group.add(core);
                    
                    // Add rotating rings for boss
                    for (let i = 0; i < 3; i++) {
                        const ringGeometry = new THREE.TorusGeometry(2.5 + i * 0.5, 0.2, 8, 20);
                        const ringMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xffffff,
                            emissive: enemy.color3d,
                            emissiveIntensity: 0.5
                        });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.rotation.x = Math.PI / 2 * Math.random();
                        ring.rotation.y = Math.PI * Math.random();
                        group.add(ring);
                        
                        if (!enemy.rings) enemy.rings = [];
                        enemy.rings.push(ring);
                    }
                    
                    // Boss light
                    const bossLight = new THREE.PointLight(enemy.color3d, 2, 15);
                    group.add(bossLight);
                    
                } else {
                    // Regular enemy creation with variety based on type
                    let enemyMesh;
                    
                    if (enemy.droneType === 'sphere') {
                        enemyMesh = new THREE.SphereGeometry(0.5, 8, 6);
                    } else if (enemy.droneType === 'pyramid') {
                        enemyMesh = new THREE.TetrahedronGeometry(0.7, 0);
                    } else if (enemy.droneType === 'cube') {
                        enemyMesh = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    } else if (enemy.droneType === 'spider') {
                        enemyMesh = new THREE.OctahedronGeometry(0.6, 0);
                    } else {
                        enemyMesh = new THREE.DodecahedronGeometry(0.6, 0);
                    }
                    
                    const bodyMaterial = new THREE.MeshLambertMaterial({ 
                        color: enemy.color3d
                    });
                    const body = new THREE.Mesh(enemyMesh, bodyMaterial);
                    body.position.y = 0.5;
                    body.castShadow = true;
                    group.add(body);
                }
                
                enemy.mesh = group;
                enemy.hoverOffset = Math.random() * Math.PI * 2;
                enemy.velocityX = 0;
                enemy.velocityY = 0;
                enemy.actualX = enemy.x;
                enemy.actualY = enemy.y;
                this.scene.add(group);
                return group;
            }

            teleportToBoss() {
                // Find the boss
                const boss = this.enemies.find(e => e.isBoss);
                if (!boss) {
                    this.addChatMessage('No boss found!', 'system');
                    return;
                }

                // Teleport player near the boss (but not on top)
                this.player.x = boss.x - 2;
                this.player.y = boss.y - 2;
                this.player.actualX = this.player.x;
                this.player.actualY = this.player.y;
                this.updatePlayerPosition();
                
                this.addChatMessage('Teleported near the Dragon Lord!', 'system');
                this.addChatMessage('Click on the boss to challenge it!', 'boss');
            }

            startBossBattle(boss) {
                this.inBossBattle = true;
                this.currentBoss = boss;
                this.bossBattleTurn = 'player';
                this.bossBattleAnimating = false;
                
                // Show entrance effect
                const entranceEffect = document.getElementById('bossEntranceEffect');
                entranceEffect.classList.add('active');
                setTimeout(() => entranceEffect.classList.remove('active'), 1000);
                
                // Play boss music/sound (if implemented)
                this.addChatMessage(`BOSS BATTLE: ${boss.name} appears!`, 'boss');
                
                // Setup boss battle camera
                this.setupBossBattleCamera();
                
                // Show boss battle UI
                document.getElementById('bossBattleUI').classList.add('active');
                document.getElementById('bossBattleName').textContent = boss.name;
                this.updateBossBattleUI();
                
                // Hide normal UI elements
                document.getElementById('chatBox').classList.add('boss-battle-mode');
                document.getElementById('actionBar').classList.add('boss-battle-mode');
                document.getElementById('inventoryContainer').classList.add('boss-battle-mode');
                document.getElementById('minimapContainer').classList.add('boss-battle-mode');
                document.getElementById('enemyHealth').classList.add('boss-battle-mode');
            }

            setupBossBattleCamera() {
                // Calculate center position between player and boss
                const centerX = ((this.player.x + this.currentBoss.x) / 2 - this.worldSize/2) * this.tileSize;
                const centerZ = ((this.player.y + this.currentBoss.y) / 2 - this.worldSize/2) * this.tileSize;
                
                // Animate camera to boss battle position
                const targetPosition = new THREE.Vector3(centerX + 15, 20, centerZ + 15);
                const targetLookAt = new THREE.Vector3(centerX, 0, centerZ);
                
                // Update camera for close-up view
                const aspect = window.innerWidth / window.innerHeight;
                const d = 15; // Much closer zoom
                this.camera.left = -d * aspect;
                this.camera.right = d * aspect;
                this.camera.top = d;
                this.camera.bottom = -d;
                this.camera.updateProjectionMatrix();
                
                // Set new camera position
                this.camera.position.copy(targetPosition);
                this.camera.lookAt(targetLookAt);
                
                // Add some dramatic lighting for boss battle
                this.ambientLight.intensity = 0.4;
                this.directionalLight.intensity = 1.0;
                this.directionalLight.position.set(10, 30, 10);
                
                // Position models for battle view
                if (this.player.mesh && this.currentBoss.mesh) {
                    // Position player on left side
                    const playerX = centerX - 5;
                    const playerZ = centerZ;
                    this.player.mesh.position.set(playerX, 0, playerZ);
                    
                    // Position boss on right side
                    const bossX = centerX + 5;
                    const bossZ = centerZ;
                    this.currentBoss.mesh.position.set(bossX, this.currentBoss.isBoss ? 2 : 1, bossZ);
                    
                    // Make them face each other
                    this.player.mesh.lookAt(bossX, 0, bossZ);
                    this.currentBoss.mesh.lookAt(playerX, 0, playerZ);
                }
            }

            endBossBattle() {
                this.inBossBattle = false;
                
                // Hide boss battle UI
                document.getElementById('bossBattleUI').classList.remove('active');
                
                // Show normal UI elements
                document.getElementById('chatBox').classList.remove('boss-battle-mode');
                document.getElementById('actionBar').classList.remove('boss-battle-mode');
                document.getElementById('inventoryContainer').classList.remove('boss-battle-mode');
                document.getElementById('minimapContainer').classList.remove('boss-battle-mode');
                document.getElementById('enemyHealth').classList.remove('boss-battle-mode');
                
                // Reset camera to original settings
                const aspect = window.innerWidth / window.innerHeight;
                const d = 50;
                this.camera.left = -d * aspect;
                this.camera.right = d * aspect;
                this.camera.top = d;
                this.camera.bottom = -d;
                this.camera.updateProjectionMatrix();
                
                // Reset camera position
                const targetCameraX = (this.player.x - this.worldSize/2) * this.tileSize * 0.3;
                const targetCameraZ = (this.player.y - this.worldSize/2) * this.tileSize * 0.3;
                this.camera.position.set(100 + targetCameraX, 100, 100 + targetCameraZ);
                this.camera.lookAt(targetCameraX, 0, targetCameraZ);
                
                // Reset lighting
                this.ambientLight.intensity = 0.6;
                this.directionalLight.intensity = 0.8;
                this.directionalLight.position.set(50, 100, 50);
                
                // Reset model positions
                this.updatePlayerPosition();
                if (this.currentBoss && this.currentBoss.mesh) {
                    const worldX = (this.currentBoss.x - this.worldSize/2) * this.tileSize;
                    const worldZ = (this.currentBoss.y - this.worldSize/2) * this.tileSize;
                    this.currentBoss.mesh.position.set(worldX, 2, worldZ);
                }
                
                this.currentBoss = null;
            }

            bossBattleAction(action) {
                if (this.bossBattleAnimating || this.bossBattleTurn !== 'player') return;
                
                this.bossBattleAnimating = true;
                const battleLog = document.getElementById('battleLog');
                
                switch(action) {
                    case 'attack':
                        const damage = Math.floor(Math.random() * 20) + 10 + this.player.skills.attack.level * 2;
                        this.currentBoss.health -= damage;
                        this.showBattleLog(`You attack for ${damage} damage!`);
                        this.addSkillExp('attack', 10);
                        this.addSkillExp('strength', 10);
                        
                        // Animate player attack
                        if (this.player.mesh) {
                            const originalPos = this.player.mesh.position.x;
                            this.player.mesh.position.x += 2;
                            setTimeout(() => {
                                this.player.mesh.position.x = originalPos;
                            }, 300);
                        }
                        break;
                        
                    case 'skill':
                        if (this.player.mana < 20) {
                            this.showBattleLog('Not enough mana!');
                            this.bossBattleAnimating = false;
                            return;
                        }
                        this.player.mana -= 20;
                        const skillDamage = Math.floor(Math.random() * 30) + 20 + this.player.skills.magic.level * 3;
                        this.currentBoss.health -= skillDamage;
                        this.showBattleLog(`Magic blast for ${skillDamage} damage!`);
                        this.addSkillExp('magic', 15);
                        
                        // Create magic effect
                        this.createMagicEffect();
                        break;
                        
                    case 'item':
                        // Use healing item if available
                        const healthPotion = this.player.inventory.find(item => item.name === 'Health Potion');
                        if (healthPotion) {
                            const healAmount = Math.min(50, this.player.maxHealth - this.player.health);
                            this.player.health += healAmount;
                            this.showBattleLog(`Used Health Potion! Restored ${healAmount} HP`);
                            const index = this.player.inventory.indexOf(healthPotion);
                            this.player.inventory.splice(index, 1);
                            this.renderInventory();
                        } else {
                            this.showBattleLog('No items available!');
                            this.bossBattleAnimating = false;
                            return;
                        }
                        break;
                        
                    case 'flee':
                        if (Math.random() < 0.3) {
                            this.showBattleLog('Escaped from battle!');
                            setTimeout(() => {
                                this.endBossBattle();
                                // Move boss away
                                this.currentBoss.x = 25;
                                this.currentBoss.y = 25;
                            }, 1000);
                            return;
                        } else {
                            this.showBattleLog("Can't escape!");
                        }
                        break;
                }
                
                this.updateBossBattleUI();
                this.updateUI();
                
                // Check if boss is defeated
                if (this.currentBoss.health <= 0) {
                    this.bossBattleVictory();
                    return;
                }
                
                // Boss turn
                setTimeout(() => {
                    this.bossBattleTurn = 'boss';
                    this.bossTurn();
                }, 1000);
            }

            bossTurn() {
                const attackType = Math.random();
                const battleLog = document.getElementById('battleLog');
                
                if (attackType < 0.6) {
                    // Normal attack
                    const damage = Math.floor(Math.random() * 15) + 10;
                    this.player.health -= damage;
                    this.showBattleLog(`${this.currentBoss.name} attacks for ${damage} damage!`);
                    
                    // Animate boss attack
                    if (this.currentBoss.mesh) {
                        const originalPos = this.currentBoss.mesh.position.x;
                        this.currentBoss.mesh.position.x -= 2;
                        setTimeout(() => {
                            this.currentBoss.mesh.position.x = originalPos;
                        }, 300);
                    }
                } else if (attackType < 0.9) {
                    // Special attack
                    const damage = Math.floor(Math.random() * 25) + 15;
                    this.player.health -= damage;
                    this.showBattleLog(`${this.currentBoss.name} uses FLAME BURST for ${damage} damage!`);
                    
                    // Create fire effect
                    this.createFireEffect();
                } else {
                    // Heal
                    const heal = Math.floor(Math.random() * 20) + 10;
                    this.currentBoss.health = Math.min(this.currentBoss.health + heal, this.currentBoss.maxHealth);
                    this.showBattleLog(`${this.currentBoss.name} regenerates ${heal} HP!`);
                }
                
                this.updateBossBattleUI();
                this.updateUI();
                
                // Check if player is defeated
                if (this.player.health <= 0) {
                    this.bossBattleDefeat();
                    return;
                }
                
                // Return to player turn
                setTimeout(() => {
                    this.bossBattleTurn = 'player';
                    this.bossBattleAnimating = false;
                }, 1000);
            }

            bossBattleVictory() {
                const exp = this.currentBoss.exp || 500;
                const gold = this.currentBoss.gold || 200;
                
                this.player.exp += exp;
                this.player.gold += gold;
                
                this.showBattleLog(`VICTORY! Gained ${exp} EXP and ${gold} gold!`);
                this.addChatMessage(`Defeated ${this.currentBoss.name}! +${exp} XP, +${gold} gold`, 'boss');
                
                // Drop special loot
                this.dropBossLoot(this.currentBoss.x, this.currentBoss.y);
                
                // Remove boss
                if (this.currentBoss.mesh) {
                    this.scene.remove(this.currentBoss.mesh);
                }
                
                const index = this.enemies.indexOf(this.currentBoss);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }
                
                this.checkLevelUp();
                
                setTimeout(() => {
                    this.endBossBattle();
                    // Spawn new boss after 30 seconds
                    setTimeout(() => this.spawnBossEnemy(), 30000);
                }, 2000);
            }

            bossBattleDefeat() {
                this.showBattleLog('You have been defeated!');
                this.player.health = this.player.maxHealth;
                this.player.x = 12;
                this.player.y = 9;
                this.player.actualX = 12;
                this.player.actualY = 9;
                
                setTimeout(() => {
                    this.endBossBattle();
                    this.updatePlayerPosition();
                }, 2000);
            }

            dropBossLoot(x, y) {
                const bossItems = [
                    { name: 'Dragon Sword', icon: '🗡️', type: 'weapon', value: 500, dropRate: 1 },
                    { name: 'Dragon Scale', icon: '🛡️', type: 'armor', value: 400, dropRate: 1 }
                ];
                
                bossItems.forEach(item => {
                    const lootMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.5, 0.5),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xff00ff,
                            emissive: 0xff00ff,
                            emissiveIntensity: 0.3
                        })
                    );
                    const worldX = (x - this.worldSize/2) * this.tileSize;
                    const worldZ = (y - this.worldSize/2) * this.tileSize;
                    lootMesh.position.set(worldX, 0.5, worldZ);
                    this.scene.add(lootMesh);
                    
                    this.lootDrops.push({
                        x: x,
                        y: y,
                        z: 0,
                        item: item,
                        mesh: lootMesh,
                        bounce: 1
                    });
                });
                
                this.addChatMessage('Legendary items dropped!', 'loot');
            }

            showBattleLog(message) {
                const battleLog = document.getElementById('battleLog');
                battleLog.textContent = message;
                battleLog.classList.add('show');
                
                setTimeout(() => {
                    battleLog.classList.remove('show');
                }, 2000);
            }

            updateBossBattleUI() {
                const healthPercent = (this.currentBoss.health / this.currentBoss.maxHealth) * 100;
                document.getElementById('bossBattleHealthBar').style.width = Math.max(0, healthPercent) + '%';
                document.getElementById('bossBattleHealthText').textContent = 
                    `${Math.max(0, Math.floor(this.currentBoss.health))}/${this.currentBoss.maxHealth}`;
            }

            createMagicEffect() {
                const particles = [];
                for (let i = 0; i < 20; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.2, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x0000ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    
                    const centerX = ((this.player.x + this.currentBoss.x) / 2 - this.worldSize/2) * this.tileSize;
                    const centerZ = ((this.player.y + this.currentBoss.y) / 2 - this.worldSize/2) * this.tileSize;
                    
                    particle.position.set(
                        centerX + (Math.random() - 0.5) * 10,
                        Math.random() * 5,
                        centerZ + (Math.random() - 0.5) * 10
                    );
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                
                // Animate and remove particles
                let opacity = 0.8;
                const animateParticles = () => {
                    opacity -= 0.05;
                    particles.forEach(p => {
                        p.position.y += 0.1;
                        p.material.opacity = opacity;
                    });
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animateParticles);
                    } else {
                        particles.forEach(p => this.scene.remove(p));
                    }
                };
                animateParticles();
            }

            createFireEffect() {
                const fireGeometry = new THREE.ConeGeometry(2, 4, 8);
                const fireMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.7
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                
                const playerWorldX = (this.player.x - this.worldSize/2) * this.tileSize;
                const playerWorldZ = (this.player.y - this.worldSize/2) * this.tileSize;
                fire.position.set(playerWorldX, 2, playerWorldZ);
                
                this.scene.add(fire);
                
                // Animate fire
                let scale = 0.1;
                const animateFire = () => {
                    scale += 0.1;
                    fire.scale.set(scale, scale, scale);
                    fire.material.opacity -= 0.05;
                    fire.rotation.y += 0.1;
                    
                    if (fire.material.opacity > 0) {
                        requestAnimationFrame(animateFire);
                    } else {
                        this.scene.remove(fire);
                    }
                };
                animateFire();
            }

            init() {
                // Set up input handlers
                this.setupInput();

                // Check for saved game first
                const hasSave = localStorage.getItem('runecraft3d_save');
                if (hasSave) {
                    this.addChatMessage('Found saved game! Loading...', 'system');
                    setTimeout(() => this.loadGame(), 100);
                } else {
                    // Spawn initial enemies only if no save
                    this.spawnEnemies();
                    this.spawnBossEnemy();
                    this.addChatMessage('Welcome to Runecraft 3D!', 'system');
                    this.addChatMessage('Move your mouse to guide your character!', 'system');
                    this.addChatMessage('Click enemies to attack, click items to pick them up!', 'system');
                    this.addChatMessage('DRAGON LORD spawned in the arena! Click "Teleport to Boss" button!', 'boss');
                    this.addChatMessage('Press K for skills, I for inventory', 'system');
                }

                // Start game loop
                this.hideLoading();
                this.animate();

                // Start regeneration
                setInterval(() => this.regenerate(), 2000);

                // Start enemy behavior tick
                setInterval(() => this.enemyBehaviorTick(), 100);

                // Initial UI update
                this.updateUI();
                this.updateEnemyCount();
                this.renderInventory();

                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Auto-save every minute
                setInterval(() => {
                    this.saveGame();
                    this.addChatMessage('Auto-saved game', 'system');
                }, 60000);
            }

            onWindowResize() {
                const aspect = window.innerWidth / window.innerHeight;
                
                if (this.inBossBattle) {
                    const d = 15;
                    this.camera.left = -d * aspect;
                    this.camera.right = d * aspect;
                } else {
                    const d = 50;
                    this.camera.left = -d * aspect;
                    this.camera.right = d * aspect;
                }
                
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            setupInput() {
                // Mouse/touch movement tracking
                const handlePointerMove = (clientX, clientY) => {
                    if (this.inBossBattle) return; // Disable movement during boss battle
                    
                    this.mouse.x = clientX;
                    this.mouse.y = clientY;
                    
                    // Update mouse position for raycaster
                    this.mouseVector.x = (clientX / window.innerWidth) * 2 - 1;
                    this.mouseVector.y = -(clientY / window.innerHeight) * 2 + 1;
                    
                    // Cast ray to get world position
                    this.raycaster.setFromCamera(this.mouseVector, this.camera);
                    const intersects = this.raycaster.intersectObject(this.ground);
                    
                    if (intersects.length > 0) {
                        const point = intersects[0].point;
                        const tileX = Math.floor((point.x / this.tileSize) + this.worldSize/2);
                        const tileY = Math.floor((point.z / this.tileSize) + this.worldSize/2);
                        
                        // Update mouse follow target
                        if (this.isValidPosition(tileX, tileY)) {
                            this.mouseFollowTarget.x = tileX;
                            this.mouseFollowTarget.y = tileY;
                            this.isMouseMoving = true;
                            this.lastMouseMoveTime = Date.now();
                        }
                    }
                };
                
                // Mouse movement
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    handlePointerMove(e.clientX, e.clientY);
                });
                
                // Touch movement for mobile
                this.renderer.domElement.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
                    }
                });
                
                // Touch start for mobile
                this.renderer.domElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
                        this.isMouseMoving = true;
                    }
                });
                
                // Touch end for mobile
                this.renderer.domElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.isMouseMoving = false;
                });

                // Mouse clicks for interactions
                this.renderer.domElement.addEventListener('click', (e) => this.handleClick(e));
                this.renderer.domElement.addEventListener('contextmenu', (e) => this.handleRightClick(e));

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleKeyPress(e.key.toLowerCase());
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Action bar clicks
                document.querySelectorAll('.action-slot').forEach(slot => {
                    slot.addEventListener('click', () => {
                        const action = slot.dataset.action;
                        this.useAbility(action);
                    });
                });
            }

            handleClick(e) {
                if (this.inBossBattle) return; // Disable clicking during boss battle
                
                // Update mouse position for raycaster
                this.mouseVector.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouseVector.y = -(e.clientY / window.innerHeight) * 2 + 1;

                // Cast ray
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                const intersects = this.raycaster.intersectObject(this.ground);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const tileX = Math.floor((point.x / this.tileSize) + this.worldSize/2);
                    const tileY = Math.floor((point.z / this.tileSize) + this.worldSize/2);

                    // Check for enemy
                    const enemy = this.getEnemyAt(tileX, tileY);
                    if (enemy) {
                        if (enemy.isBoss) {
                            // Start boss battle instead of normal combat
                            const dist = this.getDistance(this.player, enemy);
                            if (dist <= 3) {
                                this.startBossBattle(enemy);
                            } else {
                                this.addChatMessage('Move closer to challenge the boss!', 'boss');
                            }
                        } else {
                            this.targetEnemy(enemy);
                        }
                        return;
                    }

                    // Check for loot
                    const loot = this.getLootAt(tileX, tileY);
                    if (loot) {
                        this.pickupLoot(loot);
                        return;
                    }
                }
            }

            handleRightClick(e) {
                e.preventDefault();
                // Similar to handleClick but for context menu
            }

            handleKeyPress(key) {
                if (this.inBossBattle) {
                    // Different controls during boss battle
                    switch(key) {
                        case '1': this.bossBattleAction('attack'); break;
                        case '2': this.bossBattleAction('skill'); break;
                        case '3': this.bossBattleAction('item'); break;
                        case '4': this.bossBattleAction('flee'); break;
                        case 'escape': this.bossBattleAction('flee'); break;
                    }
                } else {
                    switch(key) {
                        case '1': this.useAbility('attack'); break;
                        case '2': this.useAbility('magic'); break;
                        case '3': this.useAbility('ranged'); break;
                        case '4': this.useAbility('heal'); break;
                        case '5': this.useAbility('special'); break;
                        case 'k': this.toggleSkills(); break;
                        case 'i': this.toggleInventory(); break;
                        case 'escape': this.closeAllWindows(); break;
                    }
                }
            }

            movePlayer(targetX, targetY) {
                if (this.player.moving || this.inBossBattle) return;

                if (!this.isValidPosition(targetX, targetY)) return;

                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) return;

                this.player.targetX = targetX;
                this.player.targetY = targetY;
                this.player.moving = true;
                this.player.moveProgress = 0;

                if (Math.abs(dx) > Math.abs(dy)) {
                    this.player.facing = dx > 0 ? 'east' : 'west';
                } else {
                    this.player.facing = dy > 0 ? 'south' : 'north';
                }
            }

            updatePlayerPosition() {
                if (this.player.mesh && !this.inBossBattle) {
                    const worldX = (this.player.actualX - this.worldSize/2) * this.tileSize;
                    const worldZ = (this.player.actualY - this.worldSize/2) * this.tileSize;
                    this.player.mesh.position.set(worldX, 0, worldZ);
                }
            }

            isValidPosition(x, y) {
                if (x < 0 || y < 0 || x >= this.worldMap[0].length || y >= this.worldMap.length) {
                    return false;
                }
                return !this.worldMap[y][x].solid;
            }

            getEnemyAt(x, y) {
                return this.enemies.find(e =>
                    Math.floor(e.actualX) === x && Math.floor(e.actualY) === y && e.health > 0
                );
            }

            getLootAt(x, y) {
                return this.lootDrops.find(l =>
                    Math.floor(l.x) === x && Math.floor(l.y) === y
                );
            }

            targetEnemy(enemy) {
                this.player.target = enemy;
                this.player.inCombat = true;
                this.player.lastCombat = this.gameTime;

                const enemyHealth = document.getElementById('enemyHealth');
                enemyHealth.classList.add('active');

                const dist = this.getDistance(this.player, enemy);
                if (dist > 1.5) {
                    // Don't auto-move to enemy with mouse follow controls
                    // Player needs to move there manually
                } else {
                    this.attackEnemy(enemy);
                }
            }

            attackEnemy(enemy, type = 'melee') {
                if (!enemy || enemy.health <= 0) return;

                const dist = this.getDistance(this.player, enemy);
                const maxRange = type === 'ranged' ? 8 : type === 'magic' ? 6 : 1.5;
                
                if (dist > maxRange) {
                    this.addChatMessage('Target is too far away!', 'combat');
                    return;
                }

                let damage = 0;
                let accuracy = 0;

                switch(type) {
                    case 'melee':
                        damage = Math.floor(Math.random() * 10) + this.player.skills.strength.level;
                        accuracy = 50 + this.player.skills.attack.level * 2;
                        this.addSkillExp('attack', 4);
                        this.addSkillExp('strength', 4);
                        break;
                    case 'ranged':
                        damage = Math.floor(Math.random() * 8) + this.player.skills.ranged.level;
                        accuracy = 50 + this.player.skills.ranged.level * 2;
                        this.addSkillExp('ranged', 4);
                        this.createProjectile(this.player, enemy, 'arrow');
                        break;
                    case 'magic':
                        if (this.player.mana < 5) {
                            this.addChatMessage('Not enough mana!', 'combat');
                            return;
                        }
                        this.player.mana -= 5;
                        damage = Math.floor(Math.random() * 12) + this.player.skills.magic.level * 2;
                        accuracy = 60 + this.player.skills.magic.level * 2;
                        this.addSkillExp('magic', 5);
                        this.createProjectile(this.player, enemy, 'magic');
                        break;
                }

                if (Math.random() * 100 > accuracy) {
                    this.showDamageText(enemy.actualX, enemy.actualY, 'Miss', 'damage-player');
                    this.addChatMessage('You missed!', 'combat');
                    return;
                }

                enemy.health -= damage;
                this.showDamageText(enemy.actualX, enemy.actualY, damage, 'damage-enemy');
                this.addSkillExp('hitpoints', Math.floor(damage * 1.33));

                if (enemy.health <= 0) {
                    this.enemyDefeated(enemy);
                } else {
                    enemy.nextAttack = this.gameTime + enemy.pattern.attackSpeed;
                }

                this.updateUI();
            }

            enemyAttack(enemy) {
                if (!enemy || enemy.health <= 0 || enemy.isBoss) return;
                if (this.getDistance(this.player, enemy) > 2) return;

                const accuracy = 50 + enemy.level * 2;
                if (Math.random() * 100 > accuracy) {
                    this.showDamageText(this.player.actualX, this.player.actualY, 'Miss', 'damage-player');
                    return;
                }

                const damage = Math.floor(Math.random() * enemy.maxDamage) + 1;
                const reducedDamage = Math.max(1, damage - Math.floor(this.player.skills.defense.level / 2));

                this.player.health -= reducedDamage;
                this.showDamageText(this.player.actualX, this.player.actualY, reducedDamage, 'damage-player');
                this.addSkillExp('defense', 1);

                if (this.player.health <= 0) {
                    this.playerDeath();
                }

                this.updateUI();
            }

            enemyBehaviorTick() {
                // Spawn new enemies if below max
                this.enemySpawnTimer += 100;
                if (this.enemySpawnTimer >= this.enemySpawnInterval) {
                    this.enemySpawnTimer = 0;
                    const nonBossEnemies = this.enemies.filter(e => !e.isBoss);
                    if (nonBossEnemies.length < this.maxEnemies) {
                        this.spawnEnemy();
                    }
                }

                this.enemies.forEach(enemy => {
                    if (!enemy || enemy.health <= 0 || enemy.isBoss) return;

                    const dist = this.getDistance(enemy, this.player);
                    const pattern = enemy.pattern;

                    // Attack if in range
                    if (enemy.nextAttack && this.gameTime >= enemy.nextAttack && dist <= 1.5) {
                        this.enemyAttack(enemy);
                        enemy.nextAttack = this.gameTime + pattern.attackSpeed;
                    }

                    // Flocking behavior
                    if (!this.inBossBattle) {
                        let forceX = 0;
                        let forceY = 0;
                        
                        // Find nearby enemies of same type for flocking
                        const nearbyAllies = this.enemies.filter(other => 
                            other !== enemy &&
                            other.behaviorType === enemy.behaviorType &&
                            this.getDistance(enemy, other) < pattern.flockRadius &&
                            other.health > 0
                        );

                        if (nearbyAllies.length > 0) {
                            // Separation - avoid crowding
                            nearbyAllies.forEach(other => {
                                const dx = enemy.actualX - other.actualX;
                                const dy = enemy.actualY - other.actualY;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < pattern.separationDistance && distance > 0) {
                                    forceX += (dx / distance) * pattern.separationStrength;
                                    forceY += (dy / distance) * pattern.separationStrength;
                                }
                            });

                            // Cohesion - move towards center of group
                            const centerX = nearbyAllies.reduce((sum, e) => sum + e.actualX, 0) / nearbyAllies.length;
                            const centerY = nearbyAllies.reduce((sum, e) => sum + e.actualY, 0) / nearbyAllies.length;
                            forceX += (centerX - enemy.actualX) * pattern.cohesionStrength * 0.01;
                            forceY += (centerY - enemy.actualY) * pattern.cohesionStrength * 0.01;

                            // Alignment - match velocity of neighbors
                            const avgVelX = nearbyAllies.reduce((sum, e) => sum + e.velocityX, 0) / nearbyAllies.length;
                            const avgVelY = nearbyAllies.reduce((sum, e) => sum + e.velocityY, 0) / nearbyAllies.length;
                            forceX += avgVelX * pattern.alignmentStrength;
                            forceY += avgVelY * pattern.alignmentStrength;
                        }

                        // Aggro towards player
                        if (dist < pattern.aggroRange) {
                            const dx = this.player.actualX - enemy.actualX;
                            const dy = this.player.actualY - enemy.actualY;
                            forceX += (dx / dist) * 0.3;
                            forceY += (dy / dist) * 0.3;
                        } else if (Math.random() < pattern.moveChance) {
                            // Random wandering
                            forceX += (Math.random() - 0.5) * 0.5;
                            forceY += (Math.random() - 0.5) * 0.5;
                        }

                        // Apply forces to velocity
                        enemy.velocityX += forceX * 0.1;
                        enemy.velocityY += forceY * 0.1;
                        
                        // Apply friction
                        enemy.velocityX *= 0.9;
                        enemy.velocityY *= 0.9;
                        
                        // Limit max speed
                        const speed = Math.sqrt(enemy.velocityX * enemy.velocityX + enemy.velocityY * enemy.velocityY);
                        if (speed > pattern.moveSpeed) {
                            enemy.velocityX = (enemy.velocityX / speed) * pattern.moveSpeed;
                            enemy.velocityY = (enemy.velocityY / speed) * pattern.moveSpeed;
                        }

                        // Apply velocity to position
                        const newX = enemy.actualX + enemy.velocityX;
                        const newY = enemy.actualY + enemy.velocityY;

                        if (this.isValidPosition(Math.floor(newX), Math.floor(newY))) {
                            enemy.actualX = newX;
                            enemy.actualY = newY;
                            enemy.x = Math.floor(newX);
                            enemy.y = Math.floor(newY);
                        } else {
                            // Bounce off walls
                            enemy.velocityX *= -0.5;
                            enemy.velocityY *= -0.5;
                        }
                    }
                });
            }

            enemyDefeated(enemy) {
                const exp = enemy.exp || 20;
                const gold = enemy.gold || Math.floor(Math.random() * 20) + 5;

                this.player.exp += exp;
                this.player.gold += gold;

                this.addChatMessage(`Defeated ${enemy.name}! +${exp} XP, +${gold} gold`, 'loot');

                if (Math.random() < 0.3) {
                    this.dropLoot(enemy.x, enemy.y, enemy.level);
                }

                // Remove enemy mesh
                if (enemy.mesh) {
                    this.scene.remove(enemy.mesh);
                }

                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }

                document.getElementById('enemyHealth').classList.remove('active');
                this.player.target = null;
                this.player.inCombat = false;

                this.checkLevelUp();
                this.updateEnemyCount();
            }

            dropLoot(x, y, level) {
                const items = [
                    { name: 'Health Potion', icon: '🧪', type: 'potion', value: 50, dropRate: 0.4 },
                    { name: 'Mana Potion', icon: '💙', type: 'potion', value: 30, dropRate: 0.3 },
                    { name: 'Iron Sword', icon: '⚔️', type: 'weapon', value: 100, dropRate: 0.1 },
                    { name: 'Leather Armor', icon: '🦺', type: 'armor', value: 75, dropRate: 0.1 },
                    { name: 'Gold Ring', icon: '💍', type: 'accessory', value: 150, dropRate: 0.05 },
                    { name: 'Magic Scroll', icon: '📜', type: 'magic', value: 200, dropRate: 0.05 }
                ];

                const roll = Math.random();
                let cumulative = 0;
                let selectedItem = items[0];

                for (const item of items) {
                    cumulative += item.dropRate;
                    if (roll < cumulative) {
                        selectedItem = item;
                        break;
                    }
                }

                // Create 3D loot object
                const lootMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.5, 0.5),
                    new THREE.MeshLambertMaterial({ 
                        color: 0xffd700,
                        emissive: 0xffd700,
                        emissiveIntensity: 0.2
                    })
                );
                const worldX = (x - this.worldSize/2) * this.tileSize;
                const worldZ = (y - this.worldSize/2) * this.tileSize;
                lootMesh.position.set(worldX, 0.5, worldZ);
                this.scene.add(lootMesh);

                this.lootDrops.push({
                    x: x,
                    y: y,
                    z: 0,
                    item: selectedItem,
                    mesh: lootMesh,
                    bounce: 1
                });

                this.addChatMessage(`${selectedItem.name} dropped!`, 'loot');
            }

            pickupLoot(loot) {
                if (this.getDistance(this.player, loot) > 1.5) {
                    // Don't auto-move with mouse follow controls
                    this.addChatMessage('Move closer to pick up the item!', 'system');
                    return;
                }

                if (this.player.inventory.length < 28) {
                    this.player.inventory.push(loot.item);
                    this.addChatMessage(`Picked up ${loot.item.name}`, 'loot');

                    if (loot.mesh) {
                        this.scene.remove(loot.mesh);
                    }

                    const index = this.lootDrops.indexOf(loot);
                    if (index > -1) {
                        this.lootDrops.splice(index, 1);
                    }

                    this.renderInventory();
                } else {
                    this.addChatMessage('Inventory full!', 'system');
                }
            }

            createProjectile(source, target, type) {
                const projectileMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 6),
                    new THREE.MeshLambertMaterial({ 
                        color: type === 'arrow' ? 0x8b4513 : 0x0000ff,
                        emissive: type === 'arrow' ? 0x000000 : 0x0000ff,
                        emissiveIntensity: type === 'arrow' ? 0 : 0.5
                    })
                );

                const worldX = (source.actualX - this.worldSize/2) * this.tileSize;
                const worldZ = (source.actualY - this.worldSize/2) * this.tileSize;
                projectileMesh.position.set(worldX, 2, worldZ);
                this.scene.add(projectileMesh);

                this.projectiles.push({
                    x: source.actualX,
                    y: source.actualY,
                    z: 0.5,
                    targetX: target.actualX,
                    targetY: target.actualY,
                    type: type,
                    progress: 0,
                    speed: type === 'arrow' ? 0.05 : 0.03,
                    mesh: projectileMesh
                });
            }

            showDamageText(x, y, text, className) {
                const worldX = (x - this.worldSize/2) * this.tileSize;
                const worldZ = (y - this.worldSize/2) * this.tileSize;
                const screenPos = this.worldToScreen(worldX, 0, worldZ);
                
                const elem = document.createElement('div');
                elem.className = `damage-text ${className}`;
                elem.textContent = text;
                elem.style.left = screenPos.x + 'px';
                elem.style.top = screenPos.y + 'px';
                document.querySelector('.ui-overlay').appendChild(elem);

                setTimeout(() => elem.remove(), 1000);
            }

            worldToScreen(x, y, z) {
                const vector = new THREE.Vector3(x, y, z);
                vector.project(this.camera);

                const widthHalf = window.innerWidth / 2;
                const heightHalf = window.innerHeight / 2;

                return {
                    x: (vector.x * widthHalf) + widthHalf,
                    y: -(vector.y * heightHalf) + heightHalf
                };
            }

            useAbility(ability) {
                if (!this.player.target || this.inBossBattle) {
                    if (!this.inBossBattle) {
                        this.addChatMessage('No target selected!', 'combat');
                    }
                    return;
                }

                switch(ability) {
                    case 'attack':
                        this.attackEnemy(this.player.target, 'melee');
                        break;
                    case 'magic':
                        this.attackEnemy(this.player.target, 'magic');
                        break;
                    case 'ranged':
                        this.attackEnemy(this.player.target, 'ranged');
                        break;
                    case 'heal':
                        this.healPlayer();
                        break;
                    case 'special':
                        this.specialAttack();
                        break;
                }

                const slot = document.querySelector(`[data-action="${ability}"]`);
                if (slot) {
                    slot.classList.add('on-cooldown');
                    setTimeout(() => slot.classList.remove('on-cooldown'), 1000);
                }
            }

            healPlayer() {
                if (this.player.mana < 10) {
                    this.addChatMessage('Not enough mana!', 'combat');
                    return;
                }

                const healAmount = Math.min(20 + this.player.skills.prayer.level * 2,
                                           this.player.maxHealth - this.player.health);

                if (healAmount <= 0) {
                    this.addChatMessage('Already at full health!', 'system');
                    return;
                }

                this.player.mana -= 10;
                this.player.health += healAmount;
                this.showDamageText(this.player.actualX, this.player.actualY, `+${healAmount}`, 'damage-heal');
                this.addChatMessage(`Healed ${healAmount} HP`, 'system');
                this.addSkillExp('prayer', 5);
                this.updateUI();
            }

            specialAttack() {
                if (this.player.mana < 20) {
                    this.addChatMessage('Not enough mana!', 'combat');
                    return;
                }

                this.player.mana -= 20;

                this.enemies.forEach(enemy => {
                    if (!enemy.isBoss && this.getDistance(this.player, enemy) < 3) {
                        const damage = Math.floor(Math.random() * 20) + 10;
                        enemy.health -= damage;
                        this.showDamageText(enemy.actualX, enemy.actualY, damage, 'damage-enemy');

                        if (enemy.health <= 0) {
                            this.enemyDefeated(enemy);
                        }
                    }
                });

                // Create explosion effect
                const explosion = new THREE.Mesh(
                    new THREE.SphereGeometry(5, 16, 12),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                const worldX = (this.player.actualX - this.worldSize/2) * this.tileSize;
                const worldZ = (this.player.actualY - this.worldSize/2) * this.tileSize;
                explosion.position.set(worldX, 1, worldZ);
                this.scene.add(explosion);

                // Animate explosion
                let scale = 0.1;
                const animateExplosion = () => {
                    scale += 0.1;
                    explosion.scale.set(scale, scale, scale);
                    explosion.material.opacity -= 0.03;
                    if (explosion.material.opacity > 0) {
                        requestAnimationFrame(animateExplosion);
                    } else {
                        this.scene.remove(explosion);
                    }
                };
                animateExplosion();

                this.addChatMessage('Special attack!', 'combat');
                this.updateUI();
            }

            getDistance(a, b) {
                const dx = (a.actualX || a.x) - (b.actualX || b.x);
                const dy = (a.actualY || a.y) - (b.actualY || b.y);
                return Math.sqrt(dx * dx + dy * dy);
            }

            spawnEnemies() {
                for (let i = 0; i < 10; i++) {
                    this.spawnEnemy();
                }
            }

            spawnEnemy() {
                const enemyTypes = [
                    { 
                        name: 'Goblin Drone', icon: '👺', color: '#4a4', color3d: 0x4a8c4a,
                        health: 30, maxDamage: 5, level: 1, exp: 20, gold: 10,
                        behaviorType: 'aggressive', droneType: 'sphere'
                    },
                    { 
                        name: 'Skeleton Drone', icon: '💀', color: '#ccc', color3d: 0xcccccc,
                        health: 40, maxDamage: 7, level: 2, exp: 30, gold: 15,
                        behaviorType: 'aggressive', droneType: 'pyramid'
                    },
                    { 
                        name: 'Orc Drone', icon: '👹', color: '#484', color3d: 0x448844,
                        health: 60, maxDamage: 10, level: 3, exp: 50, gold: 25,
                        behaviorType: 'aggressive', droneType: 'cube'
                    },
                    { 
                        name: 'Spider Drone', icon: '🕷️', color: '#333', color3d: 0x333333,
                        health: 25, maxDamage: 6, level: 1, exp: 15, gold: 8,
                        behaviorType: 'passive', droneType: 'spider'
                    },
                    { 
                        name: 'Wolf Drone', icon: '🐺', color: '#666', color3d: 0x666666,
                        health: 45, maxDamage: 8, level: 2, exp: 35, gold: 18,
                        behaviorType: 'defensive', droneType: 'diamond'
                    }
                ];

                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

                let x, y;
                do {
                    x = Math.floor(Math.random() * 40) + 5;
                    y = Math.floor(Math.random() * 40) + 5;
                } while (!this.isValidPosition(x, y) || this.getDistance({x, y}, this.player) < 5);

                const enemy = {
                    ...type,
                    id: Date.now() + Math.random(),
                    x: x,
                    y: y,
                    z: 0,
                    actualX: x,
                    actualY: y,
                    velocityX: 0,
                    velocityY: 0,
                    maxHealth: type.health,
                    targetX: x,
                    targetY: y,
                    moving: false,
                    moveProgress: 0,
                    pattern: this.enemyPatterns[type.behaviorType],
                    nextAttack: null,
                    isBoss: false
                };

                this.createEnemy3D(enemy);
                this.enemies.push(enemy);
                this.updateEnemyCount();
            }

            spawnBossEnemy() {
                const boss = {
                    id: 'boss_dragon_lord_' + Date.now(),
                    name: 'DRAGON LORD',
                    icon: '🐉',
                    color: '#ff0000',
                    color3d: 0xff0000,
                    health: 500,
                    maxHealth: 500,
                    maxDamage: 25,
                    level: 10,
                    exp: 500,
                    gold: 200,
                    x: 25,
                    y: 25,
                    z: 0,
                    actualX: 25,
                    actualY: 25,
                    velocityX: 0,
                    velocityY: 0,
                    targetX: 25,
                    targetY: 25,
                    moving: false,
                    moveProgress: 0,
                    pattern: this.enemyPatterns.defensive,
                    nextAttack: null,
                    isBoss: true,
                    droneType: 'boss',
                    behaviorType: 'defensive'
                };

                this.createEnemy3D(boss);
                this.enemies.push(boss);
                
                this.addChatMessage('A powerful DRAGON LORD has appeared in the arena!', 'boss');
                this.updateEnemyCount();
            }

            updateEnemyCount() {
                const nonBossEnemies = this.enemies.filter(e => !e.isBoss).length;
                const bossCount = this.enemies.filter(e => e.isBoss).length;
                let text = `Enemies: ${nonBossEnemies}`;
                if (bossCount > 0) {
                    text += ` | Boss: ${bossCount}`;
                }
                document.getElementById('enemyCount').textContent = text;
            }

            update(deltaTime) {
                // Handle smooth player movement
                if ((this.isMouseMoving || Date.now() - this.lastMouseMoveTime < 100) && !this.inBossBattle) {
                    // Calculate direction to mouse target
                    const dx = this.mouseFollowTarget.x - this.player.actualX;
                    const dy = this.mouseFollowTarget.y - this.player.actualY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Smooth movement
                    if (dist > 0.1) {
                        const moveSpeed = 0.03;
                        const moveX = (dx / dist) * moveSpeed * deltaTime;
                        const moveY = (dy / dist) * moveSpeed * deltaTime;
                        
                        const newX = this.player.actualX + moveX;
                        const newY = this.player.actualY + moveY;
                        
                        if (this.isValidPosition(Math.floor(newX), Math.floor(newY))) {
                            this.player.actualX = newX;
                            this.player.actualY = newY;
                            this.player.x = Math.floor(newX);
                            this.player.y = Math.floor(newY);
                            
                            // Update facing direction
                            if (Math.abs(dx) > Math.abs(dy)) {
                                this.player.facing = dx > 0 ? 'east' : 'west';
                            } else {
                                this.player.facing = dy > 0 ? 'south' : 'north';
                            }
                        }
                    }

                    this.updatePlayerPosition();
                }

                // Update enemies with smooth movement
                this.enemies.forEach(enemy => {
                    if (!this.inBossBattle || enemy !== this.currentBoss) {
                        // Update enemy 3D position with smooth movement
                        if (enemy.mesh && (!this.inBossBattle || enemy !== this.currentBoss)) {
                            const worldX = (enemy.actualX - this.worldSize/2) * this.tileSize;
                            const worldZ = (enemy.actualY - this.worldSize/2) * this.tileSize;
                            
                            // Hovering effect for boss and floating animation for all
                            const hoverHeight = enemy.isBoss ? 
                                3 + Math.sin(this.gameTime * 0.002 + enemy.hoverOffset) * 0.5 : 
                                0.5 + Math.sin(this.gameTime * 0.003 + enemy.hoverOffset) * 0.2;
                            
                            enemy.mesh.position.set(worldX, hoverHeight, worldZ);
                            
                            // Rotation animations
                            if (enemy.isBoss && enemy.rings) {
                                enemy.rings.forEach((ring, i) => {
                                    ring.rotation.x += deltaTime * 0.002 * (i + 1);
                                    ring.rotation.y += deltaTime * 0.003 * (i + 1);
                                    ring.rotation.z += deltaTime * 0.001 * (i + 1);
                                });
                            } else {
                                // Rotate normal enemies
                                enemy.mesh.rotation.y += deltaTime * 0.001;
                            }
                        }
                    }
                });

                // Update projectiles
                this.projectiles.forEach((proj, index) => {
                    proj.progress += proj.speed;

                    if (proj.progress >= 1) {
                        if (proj.mesh) {
                            this.scene.remove(proj.mesh);
                        }
                        this.projectiles.splice(index, 1);
                    } else {
                        const t = proj.progress;
                        proj.x += (proj.targetX - proj.x) * t;
                        proj.y += (proj.targetY - proj.y) * t;
                        proj.z = 0.5 + Math.sin(t * Math.PI) * 0.5;

                        // Update projectile 3D position
                        if (proj.mesh) {
                            const worldX = (proj.x - this.worldSize/2) * this.tileSize;
                            const worldZ = (proj.y - this.worldSize/2) * this.tileSize;
                            proj.mesh.position.set(worldX, proj.z * 2 + 1, worldZ);
                        }
                    }
                });

                // Update loot drops (bouncing animation)
                this.lootDrops.forEach(loot => {
                    loot.bounce *= 0.98;
                    loot.z = Math.abs(Math.sin(this.gameTime * 0.003)) * 0.2 * loot.bounce;
                    
                    if (loot.mesh) {
                        loot.mesh.position.y = 0.5 + loot.z;
                        loot.mesh.rotation.y += deltaTime * 0.002;
                    }
                });

                // Update UI if target exists
                if (this.player.target && this.player.target.health > 0 && !this.inBossBattle) {
                    document.getElementById('enemyName').textContent = this.player.target.name;
                    const healthPercent = (this.player.target.health / this.player.target.maxHealth) * 100;
                    document.getElementById('enemyHealthFill').style.width = healthPercent + '%';
                } else if (this.player.target && !this.inBossBattle) {
                    document.getElementById('enemyHealth').classList.remove('active');
                    this.player.target = null;
                }

                // Update camera to follow player smoothly (only when not in boss battle)
                if (!this.inBossBattle) {
                    const targetCameraX = (this.player.actualX - this.worldSize/2) * this.tileSize * 0.3;
                    const targetCameraZ = (this.player.actualY - this.worldSize/2) * this.tileSize * 0.3;
                    
                    this.camera.position.x = 100 + targetCameraX;
                    this.camera.position.z = 100 + targetCameraZ;
                    this.camera.lookAt(targetCameraX, 0, targetCameraZ);
                }
            }

            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const deltaTime = this.clock.getDelta() * 1000;
                this.gameTime += deltaTime;
                this.totalPlayTime += deltaTime;

                this.update(deltaTime);
                this.renderer.render(this.scene, this.camera);
                
                if (!this.inBossBattle) {
                    this.renderMinimap();
                }
            }

            renderMinimap() {
                const scale = 3;
                const width = 150;
                const height = 150;

                // Clear minimap
                this.minimapCtx.fillStyle = '#000';
                this.minimapCtx.fillRect(0, 0, width, height);

                // Draw map
                const centerX = width / 2;
                const centerY = height / 2;

                for (let y = -25; y <= 25; y++) {
                    for (let x = -25; x <= 25; x++) {
                        const mapX = Math.floor(this.player.actualX + x);
                        const mapY = Math.floor(this.player.actualY + y);

                        if (mapX >= 0 && mapY >= 0 && mapY < this.worldMap.length && mapX < this.worldMap[0].length) {
                            const tile = this.worldMap[mapY][mapX];

                            const colors = {
                                grass: '#2d4a2f',
                                grass2: '#254027',
                                flower: '#3a5c3e',
                                dirt: '#5b4a35',
                                stone: '#404040',
                                stone_floor: '#333333',
                                path: '#6b5c45',
                                water: '#2a5a7a',
                                tree: '#1a5a1a',
                                rock: '#3a3a3a'
                            };

                            this.minimapCtx.fillStyle = colors[tile.type] || '#222';
                            this.minimapCtx.fillRect(
                                centerX + x * scale,
                                centerY + y * scale,
                                scale,
                                scale
                            );
                        }
                    }
                }

                // Draw enemies
                this.enemies.forEach(enemy => {
                    const dx = enemy.actualX - this.player.actualX;
                    const dy = enemy.actualY - this.player.actualY;
                    if (Math.abs(dx) < 25 && Math.abs(dy) < 25) {
                        this.minimapCtx.fillStyle = enemy.isBoss ? '#ff00ff' : '#f00';
                        const size = enemy.isBoss ? 5 : 3;
                        this.minimapCtx.fillRect(
                            centerX + dx * scale - size/2,
                            centerY + dy * scale - size/2,
                            size,
                            size
                        );
                    }
                });

                // Draw player
                this.minimapCtx.fillStyle = '#00ff88';
                this.minimapCtx.fillRect(centerX - 2, centerY - 2, 4, 4);
            }

            updateUI() {
                // Health
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent =
                    `${Math.floor(this.player.health)}/${this.player.maxHealth}`;

                // Mana
                const manaPercent = (this.player.mana / this.player.maxMana) * 100;
                document.getElementById('manaBar').style.width = manaPercent + '%';
                document.getElementById('manaText').textContent =
                    `${Math.floor(this.player.mana)}/${this.player.maxMana}`;

                // Experience
                const expPercent = (this.player.exp / this.player.expToNext) * 100;
                document.getElementById('expBar').style.width = expPercent + '%';
                document.getElementById('expText').textContent =
                    `${this.player.exp}/${this.player.expToNext}`;

                // Level and gold
                document.getElementById('playerLevel').textContent = this.player.level;
                document.getElementById('playerGold').textContent = this.player.gold;

                // Combat level
                this.updateCombatLevel();
            }

            updateCombatLevel() {
                const att = this.player.skills.attack.level;
                const str = this.player.skills.strength.level;
                const def = this.player.skills.defense.level;
                const hp = this.player.skills.hitpoints.level;
                const pray = this.player.skills.prayer.level;
                const range = this.player.skills.ranged.level;
                const mage = this.player.skills.magic.level;

                // Runescape combat level formula
                const base = 0.25 * (def + hp + Math.floor(pray / 2));
                const melee = 0.325 * (att + str);
                const ranger = 0.325 * (Math.floor(range * 1.5));
                const magic = 0.325 * (Math.floor(mage * 1.5));

                this.player.combatLevel = Math.floor(base + Math.max(melee, ranger, magic));
            }

            renderInventory() {
                const grid = document.getElementById('inventoryGrid');
                grid.innerHTML = '';

                for (let i = 0; i < 28; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot';

                    if (this.player.inventory[i]) {
                        const item = this.player.inventory[i];
                        slot.innerHTML = item.icon;
                        if (item.quantity > 1) {
                            const count = document.createElement('div');
                            count.className = 'item-count';
                            count.textContent = item.quantity;
                            slot.appendChild(count);
                        }

                        slot.onclick = () => this.useItem(i);
                    }

                    grid.appendChild(slot);
                }
            }

            useItem(index) {
                const item = this.player.inventory[index];
                if (!item) return;

                if (item.type === 'potion') {
                    if (item.name.includes('Health')) {
                        const healAmount = Math.min(50, this.player.maxHealth - this.player.health);
                        this.player.health += healAmount;
                        this.showDamageText(this.player.actualX, this.player.actualY, `+${healAmount}`, 'damage-heal');
                        this.addChatMessage(`Used ${item.name}`, 'system');
                    } else if (item.name.includes('Mana')) {
                        const manaAmount = Math.min(30, this.player.maxMana - this.player.mana);
                        this.player.mana += manaAmount;
                        this.addChatMessage(`Used ${item.name}, restored ${manaAmount} MP`, 'system');
                    }

                    this.player.inventory.splice(index, 1);
                    this.renderInventory();
                    this.updateUI();
                } else if (item.type === 'weapon' || item.type === 'armor') {
                    // Equip item
                    const slot = item.type === 'weapon' ? 'weapon' : 'armor';
                    const oldItem = this.player.equipment[slot];
                    this.player.equipment[slot] = item;

                    if (oldItem) {
                        this.player.inventory[index] = oldItem;
                    } else {
                        this.player.inventory.splice(index, 1);
                    }

                    this.addChatMessage(`Equipped ${item.name}`, 'system');
                    this.renderInventory();
                    this.updateUI();
                }
            }

            addSkillExp(skill, amount) {
                const s = this.player.skills[skill];
                if (!s) return;

                s.exp += amount;

                // Level up check
                while (s.exp >= s.expToNext) {
                    s.level++;
                    s.exp -= s.expToNext;
                    s.expToNext = Math.floor(s.expToNext * 1.15);

                    this.addChatMessage(`${skill.charAt(0).toUpperCase() + skill.slice(1)} level up! Now level ${s.level}`, 'level');

                    // Special bonuses
                    if (skill === 'hitpoints') {
                        this.player.maxHealth += 5;
                        this.player.health += 5;
                    }
                }

                this.updateUI();
            }

            checkLevelUp() {
                while (this.player.exp >= this.player.expToNext) {
                    this.player.level++;
                    this.player.exp -= this.player.expToNext;
                    this.player.expToNext = Math.floor(this.player.expToNext * 1.5);

                    // Increase stats
                    this.player.maxHealth += 10;
                    this.player.health = this.player.maxHealth;
                    this.player.maxMana += 5;
                    this.player.mana = this.player.maxMana;

                    // Show level up effect
                    const levelUpDiv = document.createElement('div');
                    levelUpDiv.className = 'level-up';
                    levelUpDiv.textContent = 'LEVEL UP!';
                    document.querySelector('.ui-overlay').appendChild(levelUpDiv);
                    setTimeout(() => levelUpDiv.remove(), 2000);

                    this.addChatMessage(`LEVEL UP! You are now level ${this.player.level}!`, 'level');
                }

                this.updateUI();
            }

            regenerate() {
                // Regen health when out of combat
                if (this.gameTime - this.player.lastCombat > 5000 && !this.inBossBattle) {
                    if (this.player.health < this.player.maxHealth) {
                        this.player.health = Math.min(this.player.health+ 2, this.player.maxHealth);
                    }
                }

                // Regen mana
                if (this.player.mana < this.player.maxMana) {
                    this.player.mana = Math.min(this.player.mana + 1, this.player.maxMana);
                }

                this.updateUI();
            }

            playerDeath() {
                this.player.health = this.player.maxHealth;
                this.player.x = 12;
                this.player.y = 9;
                this.player.actualX = 12;
                this.player.actualY = 9;
                this.player.gold = Math.max(0, this.player.gold - Math.floor(this.player.gold * 0.1));

                this.addChatMessage('You died! Lost 10% of your gold. Respawning...', 'combat');

                // Clear combat
                this.player.inCombat = false;
                this.player.target = null;
                document.getElementById('enemyHealth').classList.remove('active');

                this.updatePlayerPosition();
                this.updateUI();
            }

            addChatMessage(text, type = '') {
                const message = {
                    text: text,
                    type: type,
                    timestamp: new Date().toLocaleTimeString()
                };
                
                this.chatMessages.push(message);
                
                // Limit messages
                while (this.chatMessages.length > 50) {
                    this.chatMessages.shift();
                }
                
                this.renderChat();
            }
            
            renderChat() {
                const chatBox = document.getElementById('chatBox');
                chatBox.innerHTML = '';
                
                this.chatMessages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `chat-message ${msg.type}`;
                    messageDiv.textContent = `[${msg.timestamp}] ${msg.text}`;
                    chatBox.appendChild(messageDiv);
                });
                
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            toggleSkills() {
                const window = document.getElementById('skillsWindow');
                window.classList.toggle('active');

                if (window.classList.contains('active')) {
                    this.renderSkillsWindow();
                }
            }

            renderSkillsWindow() {
                const list = document.getElementById('skillsList');
                list.innerHTML = '';

                for (const [name, skill] of Object.entries(this.player.skills)) {
                    const item = document.createElement('div');
                    item.className = 'skill-item';

                    const expPercent = (skill.exp / skill.expToNext) * 100;

                    item.innerHTML = `
                        <span class="skill-name">${name.charAt(0).toUpperCase() + name.slice(1)}</span>
                        <span class="skill-level">Level ${skill.level}</span>
                        <div class="skill-exp-bar">
                            <div class="skill-exp-fill" style="width: ${expPercent}%"></div>
                        </div>
                    `;

                    list.appendChild(item);
                }
            }

            toggleInventory() {
                // Inventory is always visible in this version
                const inv = document.querySelector('.inventory');
                inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
            }

            closeAllWindows() {
                document.getElementById('skillsWindow').classList.remove('active');
                document.getElementById('contextMenu').classList.remove('active');
            }

            showContextMenu(x, y, options) {
                const menu = document.getElementById('contextMenu');
                menu.innerHTML = '';

                options.forEach(opt => {
                    const div = document.createElement('div');
                    div.className = 'context-option';
                    div.textContent = opt.text;
                    div.onclick = () => {
                        opt.action();
                        menu.classList.remove('active');
                    };
                    menu.appendChild(div);
                });

                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.add('active');

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', () => {
                        menu.classList.remove('active');
                    }, { once: true });
                }, 100);
            }

            examineEnemy(enemy) {
                this.addChatMessage(`${enemy.name}: Level ${enemy.level}, ${enemy.health}/${enemy.maxHealth} HP`, 'system');
            }

            hideLoading() {
                const loading = document.getElementById('loadingScreen');
                document.getElementById('loadingFill').style.width = '100%';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
            }

            // Enhanced Save/Load functionality with full state preservation
            saveGame() {
                const saveData = {
                    version: '3.0',
                    timestamp: Date.now(),
                    totalPlayTime: this.totalPlayTime,
                    gameTime: this.gameTime,
                    
                    // Complete player state with smooth positions
                    player: {
                        x: this.player.x,
                        y: this.player.y,
                        z: this.player.z,
                        actualX: this.player.actualX,
                        actualY: this.player.actualY,
                        targetX: this.player.targetX,
                        targetY: this.player.targetY,
                        facing: this.player.facing,
                        moving: this.player.moving,
                        moveProgress: this.player.moveProgress,
                        level: this.player.level,
                        health: this.player.health,
                        maxHealth: this.player.maxHealth,
                        mana: this.player.mana,
                        maxMana: this.player.maxMana,
                        exp: this.player.exp,
                        expToNext: this.player.expToNext,
                        gold: this.player.gold,
                        combatLevel: this.player.combatLevel,
                        inCombat: this.player.inCombat,
                        lastCombat: this.player.lastCombat,
                        skills: this.player.skills,
                        inventory: this.player.inventory,
                        equipment: this.player.equipment
                    },
                    
                    // World map state
                    worldMap: this.worldMap,
                    
                    // All enemies with their complete state including smooth positions
                    enemies: this.enemies.map(enemy => ({
                        id: enemy.id,
                        name: enemy.name,
                        icon: enemy.icon,
                        color: enemy.color,
                        color3d: enemy.color3d,
                        health: enemy.health,
                        maxHealth: enemy.maxHealth,
                        maxDamage: enemy.maxDamage,
                        level: enemy.level,
                        exp: enemy.exp,
                        gold: enemy.gold,
                        x: enemy.x,
                        y: enemy.y,
                        z: enemy.z,
                        actualX: enemy.actualX,
                        actualY: enemy.actualY,
                        velocityX: enemy.velocityX,
                        velocityY: enemy.velocityY,
                        targetX: enemy.targetX,
                        targetY: enemy.targetY,
                        moving: enemy.moving,
                        moveProgress: enemy.moveProgress,
                        behaviorType: enemy.behaviorType,
                        nextAttack: enemy.nextAttack,
                        isBoss: enemy.isBoss,
                        droneType: enemy.droneType,
                        hoverOffset: enemy.hoverOffset
                    })),
                    
                    // Loot drops
                    lootDrops: this.lootDrops.map(loot => ({
                        x: loot.x,
                        y: loot.y,
                        z: loot.z,
                        item: loot.item,
                        bounce: loot.bounce
                    })),
                    
                    // Chat messages
                    chatMessages: this.chatMessages,
                    
                    // Boss battle state
                    bossBattleState: {
                        inBossBattle: this.inBossBattle,
                        bossBattleTurn: this.bossBattleTurn,
                        currentBossId: this.currentBoss ? this.currentBoss.id : null
                    },
                    
                    // Mouse follow state
                    mouseState: {
                        mouseFollowTarget: this.mouseFollowTarget,
                        isMouseMoving: this.isMouseMoving,
                        lastMouseMoveTime: this.lastMouseMoveTime
                    },
                    
                    // Game settings
                    gameSettings: {
                        maxEnemies: this.maxEnemies,
                        enemySpawnTimer: this.enemySpawnTimer,
                        enemySpawnInterval: this.enemySpawnInterval
                    }
                };

                localStorage.setItem('runecraft3d_save', JSON.stringify(saveData));
                this.addChatMessage('Game saved!', 'system');
            }

            loadGame() {
                const saveData = localStorage.getItem('runecraft3d_save');
                if (!saveData) {
                    this.addChatMessage('No save game found!', 'system');
                    return;
                }

                try {
                    const data = JSON.parse(saveData);
                    
                    // Restore game time
                    this.totalPlayTime = data.totalPlayTime || 0;
                    this.gameTime = data.gameTime || 0;
                    
                    // Restore complete player state
                    Object.assign(this.player, data.player);
                    
                    // Restore game settings
                    if (data.gameSettings) {
                        this.maxEnemies = data.gameSettings.maxEnemies;
                        this.enemySpawnTimer = data.gameSettings.enemySpawnTimer;
                        this.enemySpawnInterval = data.gameSettings.enemySpawnInterval;
                    }
                    
                    // Restore world map if saved
                    if (data.worldMap) {
                        this.worldMap = data.worldMap;
                        
                        // Rebuild 3D world
                        this.clearWorld3D();
                        this.createWorld3D();
                    }
                    
                    // Clear existing enemies
                    this.enemies.forEach(enemy => {
                        if (enemy.mesh) {
                            this.scene.remove(enemy.mesh);
                        }
                    });
                    this.enemies = [];
                    
                    // Restore enemies
                    if (data.enemies) {
                        data.enemies.forEach(enemyData => {
                            const enemy = {
                                ...enemyData,
                                pattern: this.enemyPatterns[enemyData.behaviorType],
                                mesh: null,
                                rings: []
                            };
                            
                            // Ensure smooth position values
                            if (enemy.actualX === undefined) enemy.actualX = enemy.x;
                            if (enemy.actualY === undefined) enemy.actualY = enemy.y;
                            if (enemy.velocityX === undefined) enemy.velocityX = 0;
                            if (enemy.velocityY === undefined) enemy.velocityY = 0;
                            
                            this.createEnemy3D(enemy);
                            this.enemies.push(enemy);
                        });
                    }
                    
                    // Clear existing loot
                    this.lootDrops.forEach(loot => {
                        if (loot.mesh) {
                            this.scene.remove(loot.mesh);
                        }
                    });
                    this.lootDrops = [];
                    
                    // Restore loot drops
                    if (data.lootDrops) {
                        data.lootDrops.forEach(lootData => {
                            const lootMesh = new THREE.Mesh(
                                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                                new THREE.MeshLambertMaterial({ 
                                    color: lootData.item.type === 'weapon' || lootData.item.type === 'armor' ? 0xff00ff : 0xffd700,
                                    emissive: lootData.item.type === 'weapon' || lootData.item.type === 'armor' ? 0xff00ff : 0xffd700,
                                    emissiveIntensity: lootData.item.type === 'weapon' || lootData.item.type === 'armor' ? 0.3 : 0.2
                                })
                            );
                            const worldX = (lootData.x - this.worldSize/2) * this.tileSize;
                            const worldZ = (lootData.y - this.worldSize/2) * this.tileSize;
                            lootMesh.position.set(worldX, 0.5, worldZ);
                            this.scene.add(lootMesh);
                            
                            this.lootDrops.push({
                                ...lootData,
                                mesh: lootMesh
                            });
                        });
                    }
                    
                    // Restore chat messages
                    if (data.chatMessages) {
                        this.chatMessages = data.chatMessages;
                        this.renderChat();
                    }
                    
                    // Restore boss battle state
                    if (data.bossBattleState) {
                        this.inBossBattle = data.bossBattleState.inBossBattle;
                        this.bossBattleTurn = data.bossBattleState.bossBattleTurn;
                        
                        if (data.bossBattleState.currentBossId && this.inBossBattle) {
                            this.currentBoss = this.enemies.find(e => e.id === data.bossBattleState.currentBossId);
                            if (this.currentBoss) {
                                // Resume boss battle UI
                                this.setupBossBattleCamera();
                                document.getElementById('bossBattleUI').classList.add('active');
                                document.getElementById('bossBattleName').textContent = this.currentBoss.name;
                                this.updateBossBattleUI();
                                
                                // Hide normal UI elements
                                document.getElementById('chatBox').classList.add('boss-battle-mode');
                                document.getElementById('actionBar').classList.add('boss-battle-mode');
                                document.getElementById('inventoryContainer').classList.add('boss-battle-mode');
                                document.getElementById('minimapContainer').classList.add('boss-battle-mode');
                                document.getElementById('enemyHealth').classList.add('boss-battle-mode');
                            } else {
                                this.inBossBattle = false;
                            }
                        }
                    }
                    
                    // Restore mouse state
                    if (data.mouseState) {
                        this.mouseFollowTarget = data.mouseState.mouseFollowTarget;
                        this.isMouseMoving = data.mouseState.isMouseMoving;
                        this.lastMouseMoveTime = data.mouseState.lastMouseMoveTime;
                    }
                    
                    // Update all UI elements
                    this.updatePlayerPosition();
                    this.updateUI();
                    this.updateEnemyCount();
                    this.renderInventory();
                    
                    this.addChatMessage('Game loaded successfully!', 'system');
                    this.addChatMessage(`Welcome back! Play time: ${Math.floor(this.totalPlayTime / 60000)} minutes`, 'system');
                    
                    // Check if boss exists but wasn't defeated
                    const boss = this.enemies.find(e => e.isBoss);
                    if (!boss && data.version >= '2.0') {
                        this.addChatMessage('Boss was defeated! Spawning new boss in 30 seconds...', 'boss');
                        setTimeout(() => this.spawnBossEnemy(), 30000);
                    }
                    
                } catch (e) {
                    console.error('Failed to load save:', e);
                    this.addChatMessage('Failed to load save! Starting new game...', 'system');
                    
                    // Start fresh if load fails
                    this.spawnEnemies();
                    this.spawnBossEnemy();
                }
            }

            clearWorld3D() {
                // Remove all world objects except player and lights
                const toRemove = [];
                this.scene.traverse((child) => {
                    if (child.type === 'Group' || child.type === 'Mesh') {
                        if (child !== this.player.mesh && 
                            child !== this.ground &&
                            !child.isLight) {
                            toRemove.push(child);
                        }
                    }
                });
                
                toRemove.forEach(obj => this.scene.remove(obj));
            }

            exportSave() {
                const saveData = localStorage.getItem('runecraft3d_save');
                if (!saveData) {
                    this.addChatMessage('No save to export!', 'system');
                    return;
                }

                // Parse and enhance save data with metadata
                const data = JSON.parse(saveData);
                data.exportDate = new Date().toISOString();
                data.gameVersion = '3.0';
                
                const enhancedSave = JSON.stringify(data, null, 2);
                const blob = new Blob([enhancedSave], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Create filename with player info
                const filename = `runecraft3d_L${data.player.level}_${Date.now()}.json`;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                this.addChatMessage(`Save exported as ${filename}!`, 'system');
            }

            importSave() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            // Validate save file
                            if (!data.player || !data.version) {
                                throw new Error('Invalid save file format');
                            }
                            
                            // Warn about overwriting
                            const existingSave = localStorage.getItem('runecraft3d_save');
                            if (existingSave) {
                                if (!confirm('This will overwrite your current save. Continue?')) {
                                    return;
                                }
                            }
                            
                            localStorage.setItem('runecraft3d_save', event.target.result);
                            this.addChatMessage('Save imported! Reloading game...', 'system');
                            
                            // Reload the imported save
                            setTimeout(() => {
                                this.clearWorld3D();
                                this.loadGame();
                            }, 500);
                            
                        } catch (err) {
                            console.error('Import error:', err);
                            this.addChatMessage('Invalid save file! Please select a valid Runecraft 3D save.', 'system');
                        }
                    };
                    reader.readAsText(file);
                };

                input.click();
            }
        }

        // Initialize game
        const game = new Runecraft3D();

        // Handle window focus for pausing
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Auto-save when tab loses focus
                game.saveGame();
            }
        });
        
        // Save before page unload
        window.addEventListener('beforeunload', (e) => {
            game.saveGame();
        });
    </script>
</body>
</html>