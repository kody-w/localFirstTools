<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Battle Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            padding: 10px;
        }

        .player-area {
            height: 35vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .player-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .player-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .health {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
        }

        .mana {
            font-size: 18px;
            color: #4dabf7;
        }

        .hand {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex: 1;
            align-items: center;
            padding: 10px;
            min-height: 140px;
        }

        .battlefield {
            height: 30vh;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
        }

        .battlefield-row {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 10px;
        }

        .card {
            width: 100px;
            height: 140px;
            background: linear-gradient(135deg, #e3e3e3 0%, #ffffff 100%);
            border: 3px solid #333;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            padding: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.4);
        }

        .card.selected {
            border-color: #ffd43b;
            box-shadow: 0 0 20px rgba(255, 212, 59, 0.8);
        }

        .card.can-attack {
            border-color: #51cf66;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px rgba(81, 207, 102, 0.5); }
            50% { box-shadow: 0 0 20px rgba(81, 207, 102, 0.8); }
            100% { box-shadow: 0 0 10px rgba(81, 207, 102, 0.5); }
        }

        .card.exhausted {
            opacity: 0.6;
            border-color: #868e96;
        }

        .card-cost {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 30px;
            height: 30px;
            background: #4dabf7;
            border: 2px solid #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
        }

        .card-name {
            background: #333;
            color: white;
            padding: 3px;
            border-radius: 5px;
            font-size: 11px;
            text-align: center;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-art {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }

        .card-text {
            font-size: 10px;
            text-align: center;
            margin-bottom: 5px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-stats {
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
        }

        .card-attack {
            background: #ff6b6b;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        .card-health {
            background: #51cf66;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        .spell-card .card-stats {
            display: none;
        }

        .spell-card .card-art {
            background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
        }

        .turn-indicator {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
        }

        .end-turn-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #f59f00 0%, #f76707 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .end-turn-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }

        .end-turn-btn:disabled {
            background: #868e96;
            cursor: not-allowed;
            transform: scale(1);
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
        }

        .game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .restart-btn {
            padding: 15px 40px;
            background: #51cf66;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
        }

        .targeting-line {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            stroke: #ffd43b;
            stroke-width: 3;
            fill: none;
            stroke-dasharray: 5, 5;
            animation: dash 0.5s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }

        .damage-animation {
            position: absolute;
            font-size: 36px;
            font-weight: bold;
            color: #ff6b6b;
            pointer-events: none;
            animation: damage-float 1s ease-out forwards;
            z-index: 200;
        }

        @keyframes damage-float {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        .draw-animation {
            animation: draw-card 0.5s ease-out;
        }

        @keyframes draw-card {
            from {
                transform: translateX(100px) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        .opponent-hand .card {
            background: linear-gradient(135deg, #495057 0%, #343a40 100%);
        }

        .opponent-hand .card-name,
        .opponent-hand .card-text,
        .opponent-hand .card-cost,
        .opponent-hand .card-stats {
            visibility: hidden;
        }

        .opponent-hand .card-art {
            background: #212529;
            font-size: 40px;
        }

        .opponent-hand .card-art::after {
            content: "?";
            color: #868e96;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="player-area opponent-area">
            <div class="player-info">
                <div class="player-stats">
                    <span class="player-name">CPU Opponent</span>
                    <span class="health">‚ù§Ô∏è <span id="opponent-health">30</span></span>
                    <span class="mana">üíé <span id="opponent-mana">0</span>/<span id="opponent-max-mana">0</span></span>
                </div>
                <span id="opponent-cards">Cards: 0</span>
            </div>
            <div class="hand opponent-hand" id="opponent-hand"></div>
        </div>

        <div class="battlefield">
            <div class="battlefield-row" id="opponent-battlefield"></div>
            <div class="battlefield-row" id="player-battlefield"></div>
        </div>

        <div class="player-area">
            <div class="hand" id="player-hand"></div>
            <div class="player-info">
                <div class="player-stats">
                    <span class="player-name">You</span>
                    <span class="health">‚ù§Ô∏è <span id="player-health">30</span></span>
                    <span class="mana">üíé <span id="player-mana">0</span>/<span id="player-max-mana">0</span></span>
                </div>
                <div class="turn-indicator">
                    <button class="end-turn-btn" id="end-turn-btn">End Turn</button>
                </div>
            </div>
        </div>
    </div>

    <svg id="targeting-svg" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;">
        <line id="targeting-line" class="targeting-line" style="display: none;"></line>
    </svg>

    <script>
        const CARD_DATABASE = {
            // Neutral Minions
            recruit: { name: "Recruit", cost: 1, attack: 1, health: 2, type: "minion", text: "", emoji: "üó°Ô∏è" },
            scout: { name: "Scout", cost: 2, attack: 2, health: 3, type: "minion", text: "", emoji: "üèπ" },
            knight: { name: "Knight", cost: 3, attack: 3, health: 4, type: "minion", text: "", emoji: "‚öîÔ∏è" },
            veteran: { name: "Veteran", cost: 4, attack: 4, health: 5, type: "minion", text: "", emoji: "üõ°Ô∏è" },
            champion: { name: "Champion", cost: 5, attack: 5, health: 6, type: "minion", text: "", emoji: "üëë" },
            
            // Special Minions
            berserker: { name: "Berserker", cost: 3, attack: 5, health: 2, type: "minion", text: "Charge", emoji: "üò§", charge: true },
            healer: { name: "Healer", cost: 2, attack: 1, health: 3, type: "minion", text: "Heal 2", emoji: "üíö", battlecry: "heal" },
            assassin: { name: "Assassin", cost: 4, attack: 4, health: 2, type: "minion", text: "Stealth", emoji: "ü•∑", stealth: true },
            tank: { name: "Tank", cost: 5, attack: 3, health: 8, type: "minion", text: "Taunt", emoji: "üõ°Ô∏è", taunt: true },
            wizard: { name: "Wizard", cost: 6, attack: 4, health: 4, type: "minion", text: "Spell +1", emoji: "üßô", spellpower: 1 },
            
            // Spells
            fireball: { name: "Fireball", cost: 4, type: "spell", text: "Deal 6 damage", emoji: "üî•", damage: 6 },
            lightning: { name: "Lightning", cost: 2, type: "spell", text: "Deal 3 damage", emoji: "‚ö°", damage: 3 },
            heal: { name: "Heal", cost: 1, type: "spell", text: "Restore 3 health", emoji: "‚ú®", heal: 3 },
            draw: { name: "Arcane Intellect", cost: 3, type: "spell", text: "Draw 2 cards", emoji: "üìö", draw: 2 },
            buff: { name: "Blessing", cost: 2, type: "spell", text: "+2/+2 to minion", emoji: "‚≠ê", buffAttack: 2, buffHealth: 2 },
            freeze: { name: "Frost Bolt", cost: 3, type: "spell", text: "Deal 3 damage and Freeze", emoji: "‚ùÑÔ∏è", damage: 3, freeze: true },
            aoe: { name: "Flamestrike", cost: 7, type: "spell", text: "Deal 4 to all enemies", emoji: "üî•", aoe: 4 }
        };

        class Card {
            constructor(template, id) {
                Object.assign(this, template);
                this.id = id;
                this.currentHealth = this.health;
                this.currentAttack = this.attack;
                this.exhausted = false;
                this.frozen = false;
                this.attacksThisTurn = 0;
            }

            canAttack() {
                return this.type === "minion" && !this.exhausted && !this.frozen && this.attacksThisTurn === 0;
            }

            takeDamage(amount) {
                this.currentHealth -= amount;
                return this.currentHealth <= 0;
            }

            heal(amount) {
                this.currentHealth = Math.min(this.currentHealth + amount, this.health);
            }

            buff(attack, health) {
                this.currentAttack += attack;
                this.attack += attack;
                this.currentHealth += health;
                this.health += health;
            }
        }

        class Game {
            constructor() {
                this.playerHealth = 30;
                this.playerMaxHealth = 30;
                this.opponentHealth = 30;
                this.opponentMaxHealth = 30;
                this.playerMana = 0;
                this.playerMaxMana = 0;
                this.opponentMana = 0;
                this.opponentMaxMana = 0;
                this.turn = 1;
                this.isPlayerTurn = true;
                this.playerHand = [];
                this.opponentHand = [];
                this.playerBattlefield = [];
                this.opponentBattlefield = [];
                this.playerDeck = [];
                this.opponentDeck = [];
                this.selectedCard = null;
                this.targetingMode = false;
                this.gameOver = false;
                this.cardIdCounter = 0;
                
                this.initializeDecks();
                this.setupEventListeners();
                this.startGame();
            }

            initializeDecks() {
                const deckTemplate = [
                    'recruit', 'recruit', 'scout', 'scout', 'knight', 'knight',
                    'veteran', 'champion', 'berserker', 'healer', 'assassin',
                    'tank', 'wizard', 'fireball', 'fireball', 'lightning',
                    'lightning', 'heal', 'heal', 'draw', 'draw', 'buff',
                    'buff', 'freeze', 'freeze', 'aoe', 'recruit', 'scout',
                    'knight', 'veteran'
                ];

                for (let cardName of deckTemplate) {
                    this.playerDeck.push(new Card(CARD_DATABASE[cardName], this.cardIdCounter++));
                    this.opponentDeck.push(new Card(CARD_DATABASE[cardName], this.cardIdCounter++));
                }

                this.shuffleDeck(this.playerDeck);
                this.shuffleDeck(this.opponentDeck);
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            setupEventListeners() {
                document.getElementById('end-turn-btn').addEventListener('click', () => this.endTurn());
                document.addEventListener('click', (e) => this.handleGlobalClick(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }

            startGame() {
                for (let i = 0; i < 3; i++) {
                    this.drawCard(true);
                    this.drawCard(false);
                }
                this.drawCard(true);
                this.startTurn();
            }

            startTurn() {
                if (this.turn <= 10) {
                    if (this.isPlayerTurn) {
                        this.playerMaxMana = this.turn;
                    } else {
                        this.opponentMaxMana = this.turn;
                    }
                }

                this.playerMana = this.playerMaxMana;
                this.opponentMana = this.opponentMaxMana;

                this.drawCard(this.isPlayerTurn);

                const battlefield = this.isPlayerTurn ? this.playerBattlefield : this.opponentBattlefield;
                battlefield.forEach(card => {
                    card.exhausted = false;
                    card.attacksThisTurn = 0;
                    if (card.frozen) {
                        card.frozen = false;
                        card.exhausted = true;
                    }
                });

                this.updateDisplay();

                if (!this.isPlayerTurn) {
                    setTimeout(() => this.executeCPUTurn(), 1000);
                }
            }

            drawCard(isPlayer) {
                const deck = isPlayer ? this.playerDeck : this.opponentDeck;
                const hand = isPlayer ? this.playerHand : this.opponentHand;

                if (deck.length > 0 && hand.length < 10) {
                    const card = deck.shift();
                    hand.push(card);
                    this.updateDisplay();
                }
            }

            playCard(card, isPlayer) {
                const hand = isPlayer ? this.playerHand : this.opponentHand;
                const mana = isPlayer ? this.playerMana : this.opponentMana;

                if (card.cost > mana) return false;

                const index = hand.indexOf(card);
                if (index === -1) return false;

                if (isPlayer) {
                    this.playerMana -= card.cost;
                } else {
                    this.opponentMana -= card.cost;
                }

                hand.splice(index, 1);

                if (card.type === "minion") {
                    const battlefield = isPlayer ? this.playerBattlefield : this.opponentBattlefield;
                    if (battlefield.length < 7) {
                        card.exhausted = !card.charge;
                        battlefield.push(card);
                        
                        if (card.battlecry === "heal") {
                            if (isPlayer) {
                                this.playerHealth = Math.min(this.playerHealth + 2, this.playerMaxHealth);
                            } else {
                                this.opponentHealth = Math.min(this.opponentHealth + 2, this.opponentMaxHealth);
                            }
                        }
                    }
                }

                return true;
            }

            executeSpell(spell, target, isPlayer) {
                if (spell.damage) {
                    const damage = spell.damage;
                    if (target.type === "minion") {
                        const isDead = target.takeDamage(damage);
                        this.showDamageAnimation(target.element, damage);
                        if (isDead) {
                            this.removeMinion(target);
                        }
                        if (spell.freeze) {
                            target.frozen = true;
                        }
                    } else if (target.type === "hero") {
                        if (target.isPlayer) {
                            this.playerHealth -= damage;
                        } else {
                            this.opponentHealth -= damage;
                        }
                        this.checkGameOver();
                    }
                }

                if (spell.heal) {
                    if (target.type === "minion") {
                        target.heal(spell.heal);
                    } else if (target.type === "hero") {
                        if (target.isPlayer) {
                            this.playerHealth = Math.min(this.playerHealth + spell.heal, this.playerMaxHealth);
                        } else {
                            this.opponentHealth = Math.min(this.opponentHealth + spell.heal, this.opponentMaxHealth);
                        }
                    }
                }

                if (spell.draw) {
                    for (let i = 0; i < spell.draw; i++) {
                        this.drawCard(isPlayer);
                    }
                }

                if (spell.buffAttack && target.type === "minion") {
                    target.buff(spell.buffAttack, spell.buffHealth);
                }

                if (spell.aoe) {
                    const targets = isPlayer ? this.opponentBattlefield : this.playerBattlefield;
                    const toRemove = [];
                    targets.forEach(minion => {
                        const isDead = minion.takeDamage(spell.aoe);
                        if (minion.element) {
                            this.showDamageAnimation(minion.element, spell.aoe);
                        }
                        if (isDead) {
                            toRemove.push(minion);
                        }
                    });
                    toRemove.forEach(minion => this.removeMinion(minion));
                }

                this.updateDisplay();
            }

            performAttack(attacker, target) {
                if (!attacker.canAttack()) return;

                attacker.attacksThisTurn++;
                
                if (target.type === "minion") {
                    const attackerDead = attacker.takeDamage(target.currentAttack);
                    const targetDead = target.takeDamage(attacker.currentAttack);
                    
                    this.showDamageAnimation(attacker.element, target.currentAttack);
                    this.showDamageAnimation(target.element, attacker.currentAttack);
                    
                    if (attackerDead) this.removeMinion(attacker);
                    if (targetDead) this.removeMinion(target);
                } else if (target.type === "hero") {
                    if (target.isPlayer) {
                        this.playerHealth -= attacker.currentAttack;
                    } else {
                        this.opponentHealth -= attacker.currentAttack;
                    }
                    this.checkGameOver();
                }

                this.updateDisplay();
            }

            removeMinion(minion) {
                const playerIndex = this.playerBattlefield.indexOf(minion);
                const opponentIndex = this.opponentBattlefield.indexOf(minion);
                
                if (playerIndex !== -1) {
                    this.playerBattlefield.splice(playerIndex, 1);
                } else if (opponentIndex !== -1) {
                    this.opponentBattlefield.splice(opponentIndex, 1);
                }
            }

            showDamageAnimation(element, damage) {
                if (!element) return;
                
                const rect = element.getBoundingClientRect();
                const damageEl = document.createElement('div');
                damageEl.className = 'damage-animation';
                damageEl.textContent = `-${damage}`;
                damageEl.style.left = rect.left + rect.width / 2 + 'px';
                damageEl.style.top = rect.top + 'px';
                document.body.appendChild(damageEl);
                
                setTimeout(() => damageEl.remove(), 1000);
            }

            endTurn() {
                if (!this.isPlayerTurn || this.gameOver) return;
                
                this.isPlayerTurn = false;
                if (this.turn === 1) {
                    this.turn++;
                }
                this.startTurn();
            }

            executeCPUTurn() {
                if (this.gameOver) return;

                setTimeout(() => {
                    // Play cards
                    const playableCards = this.opponentHand.filter(card => card.cost <= this.opponentMana);
                    playableCards.sort((a, b) => b.cost - a.cost);

                    for (let card of playableCards) {
                        if (card.type === "minion" && this.opponentBattlefield.length < 7) {
                            if (this.playCard(card, false)) {
                                this.updateDisplay();
                            }
                        } else if (card.type === "spell") {
                            if (this.executeCPUSpell(card)) {
                                break;
                            }
                        }
                    }

                    // Attack phase
                    setTimeout(() => {
                        const attackers = this.opponentBattlefield.filter(card => card.canAttack());
                        const playerTaunts = this.playerBattlefield.filter(card => card.taunt);
                        
                        for (let attacker of attackers) {
                            if (playerTaunts.length > 0) {
                                const target = playerTaunts[Math.floor(Math.random() * playerTaunts.length)];
                                this.performAttack(attacker, target);
                            } else if (this.playerBattlefield.length > 0 && Math.random() > 0.3) {
                                const target = this.playerBattlefield[Math.floor(Math.random() * this.playerBattlefield.length)];
                                this.performAttack(attacker, target);
                            } else {
                                this.performAttack(attacker, { type: "hero", isPlayer: true });
                            }
                        }

                        setTimeout(() => {
                            this.isPlayerTurn = true;
                            this.startTurn();
                        }, 500);
                    }, 1000);
                }, 500);
            }

            executeCPUSpell(spell) {
                if (spell.cost > this.opponentMana) return false;

                if (spell.damage) {
                    const targets = spell.aoe ? [] : 
                        [...this.playerBattlefield, { type: "hero", isPlayer: true }];
                    if (targets.length > 0 && !spell.aoe) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        if (this.playCard(spell, false)) {
                            this.executeSpell(spell, target, false);
                            return true;
                        }
                    } else if (spell.aoe && this.playerBattlefield.length >= 2) {
                        if (this.playCard(spell, false)) {
                            this.executeSpell(spell, null, false);
                            return true;
                        }
                    }
                }

                if (spell.heal) {
                    if (this.opponentHealth < 20) {
                        if (this.playCard(spell, false)) {
                            this.executeSpell(spell, { type: "hero", isPlayer: false }, false);
                            return true;
                        }
                    }
                }

                if (spell.draw && this.opponentHand.length < 5) {
                    if (this.playCard(spell, false)) {
                        this.executeSpell(spell, null, false);
                        return true;
                    }
                }

                if (spell.buffAttack && this.opponentBattlefield.length > 0) {
                    const target = this.opponentBattlefield[Math.floor(Math.random() * this.opponentBattlefield.length)];
                    if (this.playCard(spell, false)) {
                        this.executeSpell(spell, target, false);
                        return true;
                    }
                }

                return false;
            }

            handleGlobalClick(e) {
                const cardEl = e.target.closest('.card');
                const isPlayerCard = cardEl && cardEl.closest('#player-hand');
                const isBattlefieldCard = cardEl && (cardEl.closest('#player-battlefield') || cardEl.closest('#opponent-battlefield'));
                const isPlayerInfo = e.target.closest('.player-info');

                if (this.targetingMode && this.selectedCard) {
                    let target = null;

                    if (isBattlefieldCard) {
                        const cardId = parseInt(cardEl.dataset.cardId);
                        target = [...this.playerBattlefield, ...this.opponentBattlefield].find(c => c.id === cardId);
                    } else if (isPlayerInfo) {
                        const isPlayer = !isPlayerInfo.closest('.opponent-area');
                        target = { type: "hero", isPlayer };
                    }

                    if (target) {
                        if (this.selectedCard.type === "spell") {
                            this.executeSpell(this.selectedCard, target, true);
                            this.targetingMode = false;
                            this.selectedCard = null;
                            document.getElementById('targeting-line').style.display = 'none';
                        } else if (this.selectedCard.type === "minion") {
                            this.performAttack(this.selectedCard, target);
                            this.targetingMode = false;
                            this.selectedCard = null;
                        }
                    }
                } else if (isPlayerCard && this.isPlayerTurn) {
                    const cardId = parseInt(cardEl.dataset.cardId);
                    const card = this.playerHand.find(c => c.id === cardId);
                    
                    if (card) {
                        if (card.type === "minion") {
                            this.playCard(card, true);
                            this.updateDisplay();
                        } else if (card.type === "spell") {
                            if (card.damage || card.heal || card.buffAttack) {
                                if (this.playCard(card, true)) {
                                    this.selectedCard = card;
                                    this.targetingMode = true;
                                    cardEl.classList.add('selected');
                                }
                            } else {
                                if (this.playCard(card, true)) {
                                    this.executeSpell(card, null, true);
                                }
                            }
                        }
                    }
                } else if (isBattlefieldCard) {
                    const cardId = parseInt(cardEl.dataset.cardId);
                    const card = this.playerBattlefield.find(c => c.id === cardId);
                    
                    if (card && card.canAttack() && this.isPlayerTurn) {
                        this.selectedCard = card;
                        this.targetingMode = true;
                        cardEl.classList.add('selected');
                    }
                }
            }

            handleMouseMove(e) {
                if (this.targetingMode && this.selectedCard) {
                    const line = document.getElementById('targeting-line');
                    const selectedEl = document.querySelector('.card.selected');
                    
                    if (selectedEl) {
                        const rect = selectedEl.getBoundingClientRect();
                        line.setAttribute('x1', rect.left + rect.width / 2);
                        line.setAttribute('y1', rect.top + rect.height / 2);
                        line.setAttribute('x2', e.clientX);
                        line.setAttribute('y2', e.clientY);
                        line.style.display = 'block';
                    }
                }
            }

            checkGameOver() {
                if (this.playerHealth <= 0) {
                    this.showGameOver(false);
                } else if (this.opponentHealth <= 0) {
                    this.showGameOver(true);
                }
            }

            showGameOver(playerWon) {
                this.gameOver = true;
                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <div class="game-over-content">
                        <h2>${playerWon ? 'Victory!' : 'Defeat!'}</h2>
                        <p>${playerWon ? 'You defeated your opponent!' : 'Your opponent defeated you!'}</p>
                        <button class="restart-btn" onclick="location.reload()">Play Again</button>
                    </div>
                `;
                document.body.appendChild(gameOverDiv);
            }

            createCardElement(card, isHidden = false) {
                const div = document.createElement('div');
                div.className = `card ${card.type === 'spell' ? 'spell-card' : ''}`;
                if (card.exhausted) div.classList.add('exhausted');
                if (card.canAttack && card.canAttack()) div.classList.add('can-attack');
                div.dataset.cardId = card.id;
                
                if (isHidden) {
                    div.innerHTML = `
                        <div class="card-art"></div>
                    `;
                } else {
                    div.innerHTML = `
                        <div class="card-cost">${card.cost}</div>
                        <div class="card-name">${card.name}</div>
                        <div class="card-art">${card.emoji || ''}</div>
                        <div class="card-text">${card.text || ''}</div>
                        ${card.type === 'minion' ? `
                            <div class="card-stats">
                                <span class="card-attack">${card.currentAttack || card.attack}</span>
                                <span class="card-health">${card.currentHealth || card.health}</span>
                            </div>
                        ` : ''}
                    `;
                }
                
                card.element = div;
                return div;
            }

            updateDisplay() {
                // Update health and mana
                document.getElementById('player-health').textContent = this.playerHealth;
                document.getElementById('opponent-health').textContent = this.opponentHealth;
                document.getElementById('player-mana').textContent = this.playerMana;
                document.getElementById('player-max-mana').textContent = this.playerMaxMana;
                document.getElementById('opponent-mana').textContent = this.opponentMana;
                document.getElementById('opponent-max-mana').textContent = this.opponentMaxMana;
                document.getElementById('opponent-cards').textContent = `Cards: ${this.opponentHand.length}`;
                
                // Update hands
                const playerHandEl = document.getElementById('player-hand');
                const opponentHandEl = document.getElementById('opponent-hand');
                
                playerHandEl.innerHTML = '';
                this.playerHand.forEach(card => {
                    const cardEl = this.createCardElement(card);
                    if (card.cost <= this.playerMana) {
                        cardEl.style.borderColor = '#51cf66';
                    }
                    playerHandEl.appendChild(cardEl);
                });
                
                opponentHandEl.innerHTML = '';
                this.opponentHand.forEach(card => {
                    opponentHandEl.appendChild(this.createCardElement(card, true));
                });
                
                // Update battlefields
                const playerBattlefieldEl = document.getElementById('player-battlefield');
                const opponentBattlefieldEl = document.getElementById('opponent-battlefield');
                
                playerBattlefieldEl.innerHTML = '';
                this.playerBattlefield.forEach(card => {
                    playerBattlefieldEl.appendChild(this.createCardElement(card));
                });
                
                opponentBattlefieldEl.innerHTML = '';
                this.opponentBattlefield.forEach(card => {
                    opponentBattlefieldEl.appendChild(this.createCardElement(card));
                });
                
                // Update end turn button
                document.getElementById('end-turn-btn').disabled = !this.isPlayerTurn;
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>