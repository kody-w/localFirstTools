<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer Game Engine - Modular Architecture</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #renderCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        /* Menu Screen */
        #menuScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            text-align: center;
        }

        #menuScreen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00d4ff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .menu-section {
            margin: 20px 0;
        }

        .menu-section h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            font-size: 1em;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }

        button {
            padding: 12px 24px;
            margin: 5px;
            background: linear-gradient(135deg, #0099ff, #00d4ff);
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #555, #777);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: none;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .hud-info {
            background: rgba(20, 20, 40, 0.8);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        /* Chat */
        #chatPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 350px;
            max-height: 300px;
            display: none;
        }

        #chatMessages {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .chat-message .sender {
            color: #00d4ff;
            font-weight: bold;
        }

        #chatInput {
            display: flex;
            gap: 5px;
        }

        #chatInput input {
            flex: 1;
        }

        #chatInput button {
            padding: 8px 16px;
        }

        /* Players List */
        #playersPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            display: none;
        }

        #playersList {
            margin-top: 10px;
        }

        .player-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff00;
        }

        /* Level Editor */
        #editorPanel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            display: none;
        }

        .editor-controls {
            margin-top: 10px;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }

        .editor-grid button {
            padding: 8px;
            font-size: 0.9em;
            margin: 0;
        }

        /* Replay Controls */
        #replayPanel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }

        .replay-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #replayTimeline {
            width: 300px;
        }

        /* Controls Help */
        #controlsHelp {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            padding: 15px;
            border-radius: 4px;
            font-size: 0.85em;
            max-width: 250px;
        }

        #controlsHelp h4 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        #controlsHelp ul {
            list-style: none;
        }

        #controlsHelp li {
            margin: 5px 0;
            padding-left: 15px;
            position: relative;
        }

        #controlsHelp li:before {
            content: "›";
            position: absolute;
            left: 0;
            color: #00d4ff;
        }

        /* Loading Spinner */
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin: 0 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Notification */
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 212, 255, 0.9);
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 1.2em;
            display: none;
            z-index: 1000;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- UI Overlay -->
        <div id="uiOverlay">
            <!-- Menu Screen -->
            <div id="menuScreen" class="ui-panel">
                <h1>3D Multiplayer Engine</h1>

                <div class="menu-section">
                    <h3>Create Room</h3>
                    <input type="text" id="createRoomCode" placeholder="Enter room code" maxlength="20">
                    <button onclick="gameManager.createRoom()">Create & Host</button>
                </div>

                <div class="menu-section">
                    <h3>Join Room</h3>
                    <input type="text" id="joinRoomCode" placeholder="Enter room code" maxlength="20">
                    <button onclick="gameManager.joinRoom()">Join Room</button>
                </div>

                <div class="menu-section">
                    <h3>Single Player</h3>
                    <button onclick="gameManager.startSinglePlayer()">Play Solo</button>
                    <button class="secondary" onclick="gameManager.showLevelEditor()">Level Editor</button>
                </div>

                <div class="menu-section">
                    <button class="secondary" onclick="gameManager.importData()">Import Level</button>
                    <button class="secondary" onclick="gameManager.exportData()">Export Level</button>
                </div>
            </div>

            <!-- HUD -->
            <div id="hud">
                <div class="hud-row">
                    <div class="hud-info">
                        <div>Room: <span id="roomCode">-</span></div>
                        <div>Players: <span id="playerCount">1</span></div>
                    </div>
                    <div class="hud-info">
                        <div>FPS: <span id="fps">60</span></div>
                        <div>Position: <span id="playerPos">0, 0, 0</span></div>
                    </div>
                    <div class="hud-info">
                        <button onclick="gameManager.toggleEditor()">Editor</button>
                        <button onclick="gameManager.toggleReplay()">Replay</button>
                        <button onclick="gameManager.leaveRoom()">Leave</button>
                    </div>
                </div>
            </div>

            <!-- Chat Panel -->
            <div id="chatPanel" class="ui-panel">
                <h4>Chat</h4>
                <div id="chatMessages"></div>
                <div id="chatInput">
                    <input type="text" id="chatMessageInput" placeholder="Type message..." maxlength="200">
                    <button onclick="gameManager.sendChat()">Send</button>
                </div>
            </div>

            <!-- Players Panel -->
            <div id="playersPanel" class="ui-panel">
                <h4>Players</h4>
                <div id="playersList"></div>
            </div>

            <!-- Level Editor Panel -->
            <div id="editorPanel" class="ui-panel">
                <h4>Level Editor</h4>
                <div class="editor-controls">
                    <div>Selected: <span id="selectedObjectType">Box</span></div>
                    <div class="editor-grid">
                        <button onclick="gameManager.selectObjectType('box')">Box</button>
                        <button onclick="gameManager.selectObjectType('sphere')">Sphere</button>
                        <button onclick="gameManager.selectObjectType('cylinder')">Cylinder</button>
                        <button onclick="gameManager.selectObjectType('platform')">Platform</button>
                        <button onclick="gameManager.selectObjectType('ramp')">Ramp</button>
                        <button onclick="gameManager.selectObjectType('cone')">Cone</button>
                    </div>
                    <button onclick="gameManager.deleteSelected()">Delete Selected</button>
                    <button onclick="gameManager.clearLevel()">Clear Level</button>
                    <button class="secondary" onclick="gameManager.saveLevel()">Save Level</button>
                    <button class="secondary" onclick="gameManager.loadLevel()">Load Level</button>
                </div>
            </div>

            <!-- Replay Panel -->
            <div id="replayPanel" class="ui-panel">
                <div class="replay-controls">
                    <button onclick="gameManager.replayPlay()">▶</button>
                    <button onclick="gameManager.replayPause()">⏸</button>
                    <button onclick="gameManager.replayStop()">⏹</button>
                    <input type="range" id="replayTimeline" min="0" max="100" value="0">
                    <span id="replayTime">0:00</span>
                </div>
            </div>

            <!-- Notification -->
            <div id="notification"></div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CORE FRAMEWORK - Event System
        // ============================================================================

        class EventEmitter {
            constructor() {
                this.events = {};
            }

            on(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
                return () => this.off(event, callback);
            }

            off(event, callback) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(cb => cb !== callback);
            }

            emit(event, ...args) {
                if (!this.events[event]) return;
                this.events[event].forEach(callback => {
                    try {
                        callback(...args);
                    } catch (error) {
                        console.error(`Error in event handler for ${event}:`, error);
                    }
                });
            }

            once(event, callback) {
                const wrapper = (...args) => {
                    callback(...args);
                    this.off(event, wrapper);
                };
                this.on(event, wrapper);
            }
        }

        // ============================================================================
        // CORE FRAMEWORK - Registry Pattern
        // ============================================================================

        class Registry {
            constructor() {
                this.items = new Map();
            }

            register(key, value) {
                if (this.items.has(key)) {
                    console.warn(`Registry: Overwriting existing key: ${key}`);
                }
                this.items.set(key, value);
            }

            unregister(key) {
                return this.items.delete(key);
            }

            get(key) {
                return this.items.get(key);
            }

            has(key) {
                return this.items.has(key);
            }

            getAll() {
                return Array.from(this.items.values());
            }

            getAllKeys() {
                return Array.from(this.items.keys());
            }

            clear() {
                this.items.clear();
            }
        }

        // ============================================================================
        // THREE.JS - Inline Implementation (Simplified)
        // ============================================================================

        const THREE = (() => {
            const _Math = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: (() => {
                    const lut = [];
                    for (let i = 0; i < 256; i++) {
                        lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
                    }
                    return function generateUUID() {
                        const d0 = Math.random() * 0xffffffff | 0;
                        const d1 = Math.random() * 0xffffffff | 0;
                        const d2 = Math.random() * 0xffffffff | 0;
                        const d3 = Math.random() * 0xffffffff | 0;
                        const uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +
                            lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +
                            lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +
                            lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
                        return uuid.toLowerCase();
                    };
                })()
            };

            class Vector3 {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }

                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }

                copy(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                }

                clone() {
                    return new Vector3(this.x, this.y, this.z);
                }

                add(v) {
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    return this;
                }

                sub(v) {
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    return this;
                }

                multiplyScalar(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    return this;
                }

                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }

                normalize() {
                    const len = this.length();
                    if (len > 0) {
                        this.multiplyScalar(1 / len);
                    }
                    return this;
                }

                dot(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z;
                }

                cross(v) {
                    const x = this.y * v.z - this.z * v.y;
                    const y = this.z * v.x - this.x * v.z;
                    const z = this.x * v.y - this.y * v.x;
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }

                applyQuaternion(q) {
                    const x = this.x, y = this.y, z = this.z;
                    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
                    const ix = qw * x + qy * z - qz * y;
                    const iy = qw * y + qz * x - qx * z;
                    const iz = qw * z + qx * y - qy * x;
                    const iw = -qx * x - qy * y - qz * z;
                    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                    return this;
                }
            }

            class Quaternion {
                constructor(x = 0, y = 0, z = 0, w = 1) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                }

                set(x, y, z, w) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                    return this;
                }

                setFromEuler(euler) {
                    const x = euler.x, y = euler.y, z = euler.z;
                    const c1 = Math.cos(x / 2);
                    const c2 = Math.cos(y / 2);
                    const c3 = Math.cos(z / 2);
                    const s1 = Math.sin(x / 2);
                    const s2 = Math.sin(y / 2);
                    const s3 = Math.sin(z / 2);
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    return this;
                }

                multiply(q) {
                    return this.multiplyQuaternions(this, q);
                }

                multiplyQuaternions(a, b) {
                    const qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
                    const qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
                    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                    return this;
                }
            }

            class Euler {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }

                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }
            }

            class Color {
                constructor(r = 1, g = 1, b = 1) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                }

                setHex(hex) {
                    this.r = ((hex >> 16) & 255) / 255;
                    this.g = ((hex >> 8) & 255) / 255;
                    this.b = (hex & 255) / 255;
                    return this;
                }

                getHex() {
                    return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
                }
            }

            class Object3D {
                constructor() {
                    this.uuid = _Math.generateUUID();
                    this.position = new Vector3();
                    this.rotation = new Euler();
                    this.quaternion = new Quaternion();
                    this.scale = new Vector3(1, 1, 1);
                    this.children = [];
                    this.parent = null;
                    this.visible = true;
                }

                add(object) {
                    if (object === this) {
                        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                        return this;
                    }
                    if (object.parent !== null) {
                        object.parent.remove(object);
                    }
                    object.parent = this;
                    this.children.push(object);
                    return this;
                }

                remove(object) {
                    const index = this.children.indexOf(object);
                    if (index !== -1) {
                        object.parent = null;
                        this.children.splice(index, 1);
                    }
                    return this;
                }
            }

            class Scene extends Object3D {
                constructor() {
                    super();
                    this.type = 'Scene';
                    this.background = new Color(0.1, 0.1, 0.2);
                }
            }

            class Camera extends Object3D {
                constructor() {
                    super();
                    this.type = 'Camera';
                }
            }

            class PerspectiveCamera extends Camera {
                constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
                    super();
                    this.type = 'PerspectiveCamera';
                    this.fov = fov;
                    this.aspect = aspect;
                    this.near = near;
                    this.far = far;
                }
            }

            class Light extends Object3D {
                constructor(color, intensity = 1) {
                    super();
                    this.type = 'Light';
                    this.color = new Color().setHex(color);
                    this.intensity = intensity;
                }
            }

            class AmbientLight extends Light {
                constructor(color, intensity) {
                    super(color, intensity);
                    this.type = 'AmbientLight';
                }
            }

            class DirectionalLight extends Light {
                constructor(color, intensity) {
                    super(color, intensity);
                    this.type = 'DirectionalLight';
                }
            }

            class PointLight extends Light {
                constructor(color, intensity, distance = 0, decay = 1) {
                    super(color, intensity);
                    this.type = 'PointLight';
                    this.distance = distance;
                    this.decay = decay;
                }
            }

            class Mesh extends Object3D {
                constructor(geometry, material) {
                    super();
                    this.type = 'Mesh';
                    this.geometry = geometry;
                    this.material = material;
                }
            }

            class BoxGeometry {
                constructor(width = 1, height = 1, depth = 1) {
                    this.type = 'BoxGeometry';
                    this.parameters = { width, height, depth };
                }
            }

            class SphereGeometry {
                constructor(radius = 1, widthSegments = 32, heightSegments = 16) {
                    this.type = 'SphereGeometry';
                    this.parameters = { radius, widthSegments, heightSegments };
                }
            }

            class CylinderGeometry {
                constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8) {
                    this.type = 'CylinderGeometry';
                    this.parameters = { radiusTop, radiusBottom, height, radialSegments };
                }
            }

            class ConeGeometry {
                constructor(radius = 1, height = 1, radialSegments = 8) {
                    this.type = 'ConeGeometry';
                    this.parameters = { radius, height, radialSegments };
                }
            }

            class PlaneGeometry {
                constructor(width = 1, height = 1) {
                    this.type = 'PlaneGeometry';
                    this.parameters = { width, height };
                }
            }

            class MeshBasicMaterial {
                constructor(parameters = {}) {
                    this.type = 'MeshBasicMaterial';
                    this.color = parameters.color !== undefined ? new Color().setHex(parameters.color) : new Color(1, 1, 1);
                    this.wireframe = parameters.wireframe || false;
                }
            }

            class MeshPhongMaterial {
                constructor(parameters = {}) {
                    this.type = 'MeshPhongMaterial';
                    this.color = parameters.color !== undefined ? new Color().setHex(parameters.color) : new Color(1, 1, 1);
                    this.wireframe = parameters.wireframe || false;
                    this.shininess = parameters.shininess || 30;
                }
            }

            class WebGLRenderer {
                constructor(parameters = {}) {
                    this.domElement = parameters.canvas || document.createElement('canvas');
                    this.context = this.domElement.getContext('webgl') || this.domElement.getContext('experimental-webgl');

                    if (!this.context) {
                        console.error('WebGL not supported');
                        return;
                    }

                    this.setSize(window.innerWidth, window.innerHeight);
                    this.camera = null;
                    this.scene = null;
                }

                setSize(width, height) {
                    this.domElement.width = width;
                    this.domElement.height = height;
                    if (this.context) {
                        this.context.viewport(0, 0, width, height);
                    }
                }

                setClearColor(color, alpha = 1) {
                    const c = new Color().setHex(color);
                    if (this.context) {
                        this.context.clearColor(c.r, c.g, c.b, alpha);
                    }
                }

                render(scene, camera) {
                    this.scene = scene;
                    this.camera = camera;

                    if (!this.context) return;

                    const gl = this.context;
                    const bg = scene.background;
                    gl.clearColor(bg.r, bg.g, bg.b, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.enable(gl.DEPTH_TEST);

                    // Simple render - in a real implementation, this would render all meshes
                    // For this modular engine, we're focusing on architecture over full WebGL implementation
                }
            }

            class Raycaster {
                constructor(origin, direction) {
                    this.ray = {
                        origin: origin || new Vector3(),
                        direction: direction || new Vector3()
                    };
                }

                setFromCamera(coords, camera) {
                    // Simplified raycasting implementation
                    this.ray.origin.copy(camera.position);
                    this.ray.direction.set(coords.x, coords.y, -0.5).normalize();
                }

                intersectObjects(objects, recursive = false) {
                    const intersects = [];
                    // Simplified intersection testing
                    objects.forEach(obj => {
                        if (obj.visible && obj.type === 'Mesh') {
                            const distance = this.ray.origin.clone().sub(obj.position).length();
                            if (distance < 50) { // Simple distance check
                                intersects.push({
                                    object: obj,
                                    distance: distance,
                                    point: obj.position.clone()
                                });
                            }
                        }
                    });
                    return intersects.sort((a, b) => a.distance - b.distance);
                }
            }

            return {
                Vector3,
                Quaternion,
                Euler,
                Color,
                Scene,
                PerspectiveCamera,
                AmbientLight,
                DirectionalLight,
                PointLight,
                Mesh,
                BoxGeometry,
                SphereGeometry,
                CylinderGeometry,
                ConeGeometry,
                PlaneGeometry,
                MeshBasicMaterial,
                MeshPhongMaterial,
                WebGLRenderer,
                Raycaster,
                Math: _Math
            };
        })();

        // ============================================================================
        // CANNON.JS - Inline Implementation (Simplified)
        // ============================================================================

        const CANNON = (() => {
            class Vec3 {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }

                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }

                copy(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                }

                vadd(v, target) {
                    if (target) {
                        target.x = this.x + v.x;
                        target.y = this.y + v.y;
                        target.z = this.z + v.z;
                        return target;
                    }
                    return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
                }

                scale(scalar, target) {
                    if (target) {
                        target.x = this.x * scalar;
                        target.y = this.y * scalar;
                        target.z = this.z * scalar;
                        return target;
                    }
                    return new Vec3(this.x * scalar, this.y * scalar, this.z * scalar);
                }
            }

            class Quaternion {
                constructor(x = 0, y = 0, z = 0, w = 1) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                }

                set(x, y, z, w) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                    return this;
                }
            }

            class Shape {
                constructor() {
                    this.type = 'Shape';
                }
            }

            class Box extends Shape {
                constructor(halfExtents) {
                    super();
                    this.type = 'Box';
                    this.halfExtents = halfExtents || new Vec3(0.5, 0.5, 0.5);
                }
            }

            class Sphere extends Shape {
                constructor(radius) {
                    super();
                    this.type = 'Sphere';
                    this.radius = radius || 1;
                }
            }

            class Cylinder extends Shape {
                constructor(radiusTop, radiusBottom, height, numSegments) {
                    super();
                    this.type = 'Cylinder';
                    this.radiusTop = radiusTop || 1;
                    this.radiusBottom = radiusBottom || 1;
                    this.height = height || 1;
                    this.numSegments = numSegments || 8;
                }
            }

            class Plane extends Shape {
                constructor() {
                    super();
                    this.type = 'Plane';
                }
            }

            class Body {
                constructor(options = {}) {
                    this.mass = options.mass !== undefined ? options.mass : 0;
                    this.position = options.position || new Vec3();
                    this.quaternion = options.quaternion || new Quaternion();
                    this.velocity = new Vec3();
                    this.angularVelocity = new Vec3();
                    this.force = new Vec3();
                    this.shapes = [];

                    if (options.shape) {
                        this.addShape(options.shape);
                    }

                    this.type = this.mass === 0 ? Body.STATIC : Body.DYNAMIC;
                    this.sleepState = Body.AWAKE;
                }

                addShape(shape) {
                    this.shapes.push(shape);
                }

                applyForce(force, relativePoint) {
                    if (this.type === Body.DYNAMIC) {
                        this.force.x += force.x;
                        this.force.y += force.y;
                        this.force.z += force.z;
                    }
                }

                applyImpulse(impulse, relativePoint) {
                    if (this.type === Body.DYNAMIC) {
                        this.velocity.x += impulse.x / this.mass;
                        this.velocity.y += impulse.y / this.mass;
                        this.velocity.z += impulse.z / this.mass;
                    }
                }
            }

            Body.DYNAMIC = 1;
            Body.STATIC = 2;
            Body.KINEMATIC = 4;
            Body.AWAKE = 0;
            Body.SLEEPY = 1;
            Body.SLEEPING = 2;

            class World {
                constructor() {
                    this.gravity = new Vec3(0, -9.82, 0);
                    this.bodies = [];
                    this.dt = 1 / 60;
                    this.broadphase = null;
                    this.solver = null;
                }

                addBody(body) {
                    this.bodies.push(body);
                }

                removeBody(body) {
                    const index = this.bodies.indexOf(body);
                    if (index !== -1) {
                        this.bodies.splice(index, 1);
                    }
                }

                step(dt) {
                    // Simplified physics simulation
                    this.bodies.forEach(body => {
                        if (body.type === Body.DYNAMIC) {
                            // Apply gravity
                            body.force.y += body.mass * this.gravity.y;

                            // Update velocity
                            body.velocity.x += (body.force.x / body.mass) * dt;
                            body.velocity.y += (body.force.y / body.mass) * dt;
                            body.velocity.z += (body.force.z / body.mass) * dt;

                            // Update position
                            body.position.x += body.velocity.x * dt;
                            body.position.y += body.velocity.y * dt;
                            body.position.z += body.velocity.z * dt;

                            // Reset forces
                            body.force.set(0, 0, 0);

                            // Simple ground collision
                            if (body.position.y < 0) {
                                body.position.y = 0;
                                body.velocity.y = 0;
                            }
                        }
                    });
                }
            }

            return {
                Vec3,
                Quaternion,
                World,
                Body,
                Box,
                Sphere,
                Cylinder,
                Plane,
                Shape
            };
        })();

        // ============================================================================
        // GAME ENTITY SYSTEM - Base Classes
        // ============================================================================

        class GameObject extends EventEmitter {
            constructor(config = {}) {
                super();
                this.id = config.id || THREE.Math.generateUUID();
                this.type = config.type || 'GameObject';
                this.mesh = null;
                this.body = null;
                this.userData = config.userData || {};
            }

            serialize() {
                const data = {
                    id: this.id,
                    type: this.type,
                    userData: this.userData
                };

                if (this.mesh) {
                    data.position = {
                        x: this.mesh.position.x,
                        y: this.mesh.position.y,
                        z: this.mesh.position.z
                    };
                    data.rotation = {
                        x: this.mesh.rotation.x,
                        y: this.mesh.rotation.y,
                        z: this.mesh.rotation.z
                    };
                    data.scale = {
                        x: this.mesh.scale.x,
                        y: this.mesh.scale.y,
                        z: this.mesh.scale.z
                    };
                }

                return data;
            }

            deserialize(data) {
                this.id = data.id;
                this.type = data.type;
                this.userData = data.userData || {};

                if (this.mesh && data.position) {
                    this.mesh.position.set(data.position.x, data.position.y, data.position.z);
                }
                if (this.mesh && data.rotation) {
                    this.mesh.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
                }
                if (this.mesh && data.scale) {
                    this.mesh.scale.set(data.scale.x, data.scale.y, data.scale.z);
                }

                if (this.body && data.position) {
                    this.body.position.set(data.position.x, data.position.y, data.position.z);
                }
            }

            update(deltaTime) {
                // Override in subclasses
            }

            destroy() {
                this.emit('destroy', this);
            }
        }

        // ============================================================================
        // GAME ENTITY FACTORY - Plugin System
        // ============================================================================

        class GameObjectFactory {
            constructor(scene, world) {
                this.scene = scene;
                this.world = world;
                this.blueprints = new Registry();
                this.registerDefaultBlueprints();
            }

            registerBlueprint(type, createFn) {
                this.blueprints.register(type, createFn);
            }

            create(type, config = {}) {
                const createFn = this.blueprints.get(type);
                if (!createFn) {
                    console.error(`Unknown game object type: ${type}`);
                    return null;
                }
                return createFn(this.scene, this.world, config);
            }

            registerDefaultBlueprints() {
                // Box
                this.registerBlueprint('box', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'box' });

                    const size = config.size || { x: 1, y: 1, z: 1 };
                    const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0xff6b6b
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    scene.add(obj.mesh);

                    // Physics
                    const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                    obj.body = new CANNON.Body({
                        mass: config.mass !== undefined ? config.mass : 1,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        )
                    });
                    world.addBody(obj.body);

                    return obj;
                });

                // Sphere
                this.registerBlueprint('sphere', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'sphere' });

                    const radius = config.radius || 0.5;
                    const geometry = new THREE.SphereGeometry(radius, 32, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0x4ecdc4
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    scene.add(obj.mesh);

                    // Physics
                    const shape = new CANNON.Sphere(radius);
                    obj.body = new CANNON.Body({
                        mass: config.mass !== undefined ? config.mass : 1,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        )
                    });
                    world.addBody(obj.body);

                    return obj;
                });

                // Cylinder
                this.registerBlueprint('cylinder', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'cylinder' });

                    const radius = config.radius || 0.5;
                    const height = config.height || 1;
                    const geometry = new THREE.CylinderGeometry(radius, radius, height, 8);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0xf38181
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    scene.add(obj.mesh);

                    // Physics
                    const shape = new CANNON.Cylinder(radius, radius, height, 8);
                    obj.body = new CANNON.Body({
                        mass: config.mass !== undefined ? config.mass : 1,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        )
                    });
                    world.addBody(obj.body);

                    return obj;
                });

                // Cone
                this.registerBlueprint('cone', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'cone' });

                    const radius = config.radius || 0.5;
                    const height = config.height || 1;
                    const geometry = new THREE.ConeGeometry(radius, height, 8);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0xfeca57
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    scene.add(obj.mesh);

                    // Physics (using cylinder as approximation)
                    const shape = new CANNON.Cylinder(0, radius, height, 8);
                    obj.body = new CANNON.Body({
                        mass: config.mass !== undefined ? config.mass : 1,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        )
                    });
                    world.addBody(obj.body);

                    return obj;
                });

                // Platform
                this.registerBlueprint('platform', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'platform' });

                    const size = config.size || { x: 3, y: 0.5, z: 3 };
                    const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0x95a5a6
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    scene.add(obj.mesh);

                    // Physics - static
                    const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                    obj.body = new CANNON.Body({
                        mass: 0,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        )
                    });
                    world.addBody(obj.body);

                    return obj;
                });

                // Ramp
                this.registerBlueprint('ramp', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'ramp' });

                    const size = config.size || { x: 3, y: 1, z: 3 };
                    const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0x7f8c8d
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    // Tilt the ramp
                    obj.mesh.rotation.z = Math.PI / 6;

                    scene.add(obj.mesh);

                    // Physics - static
                    const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                    obj.body = new CANNON.Body({
                        mass: 0,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        )
                    });
                    obj.body.quaternion.setFromEuler(0, 0, Math.PI / 6);
                    world.addBody(obj.body);

                    return obj;
                });

                // Player
                this.registerBlueprint('player', (scene, world, config) => {
                    const obj = new GameObject({ ...config, type: 'player' });

                    const geometry = new THREE.SphereGeometry(0.5, 32, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: config.color || 0x00ff00
                    });
                    obj.mesh = new THREE.Mesh(geometry, material);

                    if (config.position) {
                        obj.mesh.position.set(config.position.x, config.position.y, config.position.z);
                    }

                    scene.add(obj.mesh);

                    // Physics
                    const shape = new CANNON.Sphere(0.5);
                    obj.body = new CANNON.Body({
                        mass: 1,
                        shape: shape,
                        position: new CANNON.Vec3(
                            obj.mesh.position.x,
                            obj.mesh.position.y,
                            obj.mesh.position.z
                        ),
                        linearDamping: 0.9
                    });
                    world.addBody(obj.body);

                    return obj;
                });
            }
        }

        // ============================================================================
        // NETWORKING SYSTEM - WebRTC P2P
        // ============================================================================

        class NetworkManager extends EventEmitter {
            constructor() {
                super();
                this.peerId = null;
                this.roomCode = null;
                this.isHost = false;
                this.peers = new Map();
                this.connections = new Map();
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' }
                ];
            }

            async createRoom(roomCode) {
                this.roomCode = roomCode;
                this.peerId = this.generatePeerId();
                this.isHost = true;
                this.emit('room-created', { roomCode, peerId: this.peerId });
                return { roomCode, peerId: this.peerId };
            }

            async joinRoom(roomCode) {
                this.roomCode = roomCode;
                this.peerId = this.generatePeerId();
                this.isHost = false;

                // In a real implementation, this would connect via signaling server
                // For this demo, we'll simulate it
                setTimeout(() => {
                    this.emit('room-joined', { roomCode, peerId: this.peerId });
                }, 500);

                return { roomCode, peerId: this.peerId };
            }

            async connectToPeer(peerId) {
                if (this.connections.has(peerId)) return;

                const connection = {
                    peerId: peerId,
                    dataChannel: null,
                    peerConnection: null,
                    state: 'connecting'
                };

                this.connections.set(peerId, connection);

                // Simulate connection
                setTimeout(() => {
                    connection.state = 'connected';
                    this.emit('peer-connected', peerId);
                }, 1000);
            }

            send(peerId, data) {
                const connection = this.connections.get(peerId);
                if (connection && connection.state === 'connected') {
                    // In real implementation, send via WebRTC data channel
                    // For demo, we'll emit an event
                    this.emit('data-sent', { peerId, data });
                }
            }

            broadcast(data) {
                this.connections.forEach((connection, peerId) => {
                    this.send(peerId, data);
                });
            }

            disconnect() {
                this.connections.forEach((connection, peerId) => {
                    // Close connections
                    this.emit('peer-disconnected', peerId);
                });
                this.connections.clear();
                this.peers.clear();
                this.roomCode = null;
                this.peerId = null;
                this.isHost = false;
            }

            generatePeerId() {
                return 'peer-' + Math.random().toString(36).substr(2, 9);
            }
        }

        // ============================================================================
        // REPLAY SYSTEM
        // ============================================================================

        class ReplaySystem extends EventEmitter {
            constructor() {
                super();
                this.recording = false;
                this.playing = false;
                this.frames = [];
                this.currentFrame = 0;
                this.startTime = 0;
                this.recordInterval = 1000 / 30; // 30 FPS
                this.lastRecordTime = 0;
            }

            startRecording() {
                this.recording = true;
                this.frames = [];
                this.startTime = performance.now();
                this.lastRecordTime = 0;
                this.emit('recording-started');
            }

            stopRecording() {
                this.recording = false;
                this.emit('recording-stopped', { frameCount: this.frames.length });
                return this.frames;
            }

            recordFrame(gameState) {
                if (!this.recording) return;

                const now = performance.now();
                if (now - this.lastRecordTime < this.recordInterval) return;

                this.frames.push({
                    time: now - this.startTime,
                    state: JSON.parse(JSON.stringify(gameState))
                });

                this.lastRecordTime = now;
            }

            startPlayback() {
                if (this.frames.length === 0) return;

                this.playing = true;
                this.currentFrame = 0;
                this.startTime = performance.now();
                this.emit('playback-started');
            }

            stopPlayback() {
                this.playing = false;
                this.currentFrame = 0;
                this.emit('playback-stopped');
            }

            getFrameAtTime(time) {
                if (this.frames.length === 0) return null;

                for (let i = 0; i < this.frames.length; i++) {
                    if (this.frames[i].time >= time) {
                        return this.frames[i];
                    }
                }

                return this.frames[this.frames.length - 1];
            }

            update(deltaTime) {
                if (!this.playing) return null;

                const elapsed = performance.now() - this.startTime;
                const frame = this.getFrameAtTime(elapsed);

                if (frame) {
                    this.emit('frame-update', frame);
                    return frame;
                }

                return null;
            }

            exportReplay() {
                return {
                    version: '1.0',
                    duration: this.frames.length > 0 ? this.frames[this.frames.length - 1].time : 0,
                    frameCount: this.frames.length,
                    frames: this.frames
                };
            }

            importReplay(data) {
                if (data.version === '1.0') {
                    this.frames = data.frames;
                    this.emit('replay-loaded', { frameCount: this.frames.length });
                }
            }
        }

        // ============================================================================
        // LEVEL EDITOR SYSTEM
        // ============================================================================

        class LevelEditor extends EventEmitter {
            constructor(scene, world, factory) {
                super();
                this.scene = scene;
                this.world = world;
                this.factory = factory;
                this.enabled = false;
                this.selectedObjectType = 'box';
                this.selectedObject = null;
                this.objects = new Map();
            }

            enable() {
                this.enabled = true;
                this.emit('enabled');
            }

            disable() {
                this.enabled = false;
                this.selectedObject = null;
                this.emit('disabled');
            }

            selectObjectType(type) {
                this.selectedObjectType = type;
                this.emit('object-type-selected', type);
            }

            placeObject(position) {
                if (!this.enabled) return;

                const obj = this.factory.create(this.selectedObjectType, {
                    position: position,
                    mass: 0 // Editor objects are static by default
                });

                if (obj) {
                    this.objects.set(obj.id, obj);
                    this.emit('object-placed', obj);
                    return obj;
                }
            }

            selectObject(object) {
                if (this.selectedObject && this.selectedObject.mesh.material) {
                    // Restore original color (simplified)
                    this.selectedObject.mesh.material.wireframe = false;
                }

                this.selectedObject = object;

                if (object && object.mesh.material) {
                    object.mesh.material.wireframe = true;
                }

                this.emit('object-selected', object);
            }

            deleteSelected() {
                if (!this.selectedObject) return;

                const obj = this.selectedObject;
                this.objects.delete(obj.id);

                if (obj.mesh) {
                    this.scene.remove(obj.mesh);
                }
                if (obj.body) {
                    this.world.removeBody(obj.body);
                }

                this.selectedObject = null;
                this.emit('object-deleted', obj);
            }

            clearLevel() {
                this.objects.forEach(obj => {
                    if (obj.mesh) this.scene.remove(obj.mesh);
                    if (obj.body) this.world.removeBody(obj.body);
                });
                this.objects.clear();
                this.selectedObject = null;
                this.emit('level-cleared');
            }

            exportLevel() {
                const levelData = {
                    version: '1.0',
                    objects: []
                };

                this.objects.forEach(obj => {
                    levelData.objects.push(obj.serialize());
                });

                return levelData;
            }

            importLevel(levelData) {
                this.clearLevel();

                if (levelData.version === '1.0' && levelData.objects) {
                    levelData.objects.forEach(objData => {
                        const obj = this.factory.create(objData.type, {
                            id: objData.id,
                            userData: objData.userData
                        });

                        if (obj) {
                            obj.deserialize(objData);
                            this.objects.set(obj.id, obj);
                        }
                    });

                    this.emit('level-loaded', { objectCount: this.objects.size });
                }
            }
        }

        // ============================================================================
        // CHAT SYSTEM
        // ============================================================================

        class ChatSystem extends EventEmitter {
            constructor() {
                super();
                this.messages = [];
                this.maxMessages = 100;
            }

            addMessage(sender, message) {
                this.messages.push({
                    sender: sender,
                    message: message,
                    timestamp: Date.now()
                });

                if (this.messages.length > this.maxMessages) {
                    this.messages.shift();
                }

                this.emit('message-added', { sender, message });
            }

            getMessages() {
                return this.messages;
            }

            clear() {
                this.messages = [];
                this.emit('messages-cleared');
            }
        }

        // ============================================================================
        // INPUT MANAGER
        // ============================================================================

        class InputManager extends EventEmitter {
            constructor(canvas) {
                super();
                this.canvas = canvas;
                this.keys = new Set();
                this.mouseButtons = new Set();
                this.mousePosition = { x: 0, y: 0 };
                this.mouseDelta = { x: 0, y: 0 };
                this.pointerLocked = false;

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys.add(e.code);
                    this.emit('keydown', e.code);
                });

                window.addEventListener('keyup', (e) => {
                    this.keys.delete(e.code);
                    this.emit('keyup', e.code);
                });

                // Mouse
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouseButtons.add(e.button);
                    this.emit('mousedown', e);
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    this.mouseButtons.delete(e.button);
                    this.emit('mouseup', e);
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.pointerLocked) {
                        this.mouseDelta.x = e.movementX;
                        this.mouseDelta.y = e.movementY;
                    }

                    this.mousePosition.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mousePosition.y = -(e.clientY / window.innerHeight) * 2 + 1;

                    this.emit('mousemove', e);
                });

                this.canvas.addEventListener('click', (e) => {
                    this.emit('click', e);
                });

                // Pointer lock
                this.canvas.addEventListener('click', () => {
                    if (!this.pointerLocked) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement === this.canvas;
                    this.emit('pointerlockchange', this.pointerLocked);
                });
            }

            isKeyPressed(code) {
                return this.keys.has(code);
            }

            isMouseButtonPressed(button) {
                return this.mouseButtons.has(button);
            }

            resetMouseDelta() {
                this.mouseDelta.x = 0;
                this.mouseDelta.y = 0;
            }
        }

        // ============================================================================
        // PLAYER CONTROLLER
        // ============================================================================

        class PlayerController extends EventEmitter {
            constructor(player, camera, input) {
                super();
                this.player = player;
                this.camera = camera;
                this.input = input;
                this.moveSpeed = 5;
                this.jumpForce = 5;
                this.lookSensitivity = 0.002;
                this.cameraOffset = new THREE.Vector3(0, 2, 5);
                this.yaw = 0;
                this.pitch = 0;
            }

            update(deltaTime) {
                if (!this.player || !this.player.body) return;

                // Movement
                const moveDirection = new CANNON.Vec3(0, 0, 0);

                if (this.input.isKeyPressed('KeyW')) {
                    moveDirection.z -= 1;
                }
                if (this.input.isKeyPressed('KeyS')) {
                    moveDirection.z += 1;
                }
                if (this.input.isKeyPressed('KeyA')) {
                    moveDirection.x -= 1;
                }
                if (this.input.isKeyPressed('KeyD')) {
                    moveDirection.x += 1;
                }

                // Apply movement
                if (moveDirection.x !== 0 || moveDirection.z !== 0) {
                    const force = new CANNON.Vec3(
                        moveDirection.x * this.moveSpeed,
                        0,
                        moveDirection.z * this.moveSpeed
                    );
                    this.player.body.applyForce(force, this.player.body.position);
                }

                // Jump
                if (this.input.isKeyPressed('Space')) {
                    // Simple jump (check if grounded in real implementation)
                    if (Math.abs(this.player.body.velocity.y) < 0.1) {
                        this.player.body.applyImpulse(
                            new CANNON.Vec3(0, this.jumpForce, 0),
                            this.player.body.position
                        );
                    }
                }

                // Camera rotation
                if (this.input.pointerLocked) {
                    this.yaw -= this.input.mouseDelta.x * this.lookSensitivity;
                    this.pitch -= this.input.mouseDelta.y * this.lookSensitivity;
                    this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                }

                // Update camera position
                this.updateCamera();

                this.input.resetMouseDelta();
            }

            updateCamera() {
                if (!this.player || !this.player.mesh) return;

                const offset = this.cameraOffset.clone();
                offset.applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(this.pitch, this.yaw, 0)));

                this.camera.position.copy(this.player.mesh.position);
                this.camera.position.add(offset);

                this.camera.rotation.set(this.pitch, this.yaw, 0);
            }
        }

        // ============================================================================
        // GAME MANAGER - Main Controller
        // ============================================================================

        class GameManager extends EventEmitter {
            constructor() {
                super();

                // Core systems
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.factory = null;

                // Managers
                this.network = new NetworkManager();
                this.replay = new ReplaySystem();
                this.chat = new ChatSystem();
                this.levelEditor = null;
                this.input = null;

                // Game state
                this.gameState = 'menu'; // menu, playing, editor, replay
                this.gameObjects = new Map();
                this.player = null;
                this.playerController = null;
                this.remotePlayers = new Map();

                // Performance
                this.lastTime = performance.now();
                this.fps = 60;
                this.fpsUpdateInterval = 1000;
                this.lastFpsUpdate = 0;
                this.frameCount = 0;

                this.initialize();
            }

            initialize() {
                // Initialize renderer
                const canvas = document.getElementById('renderCanvas');
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x1a1a2e);

                // Initialize scene
                this.scene = new THREE.Scene();

                // Initialize camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);

                // Initialize physics
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);

                // Initialize factory
                this.factory = new GameObjectFactory(this.scene, this.world);

                // Initialize level editor
                this.levelEditor = new LevelEditor(this.scene, this.world, this.factory);

                // Initialize input
                this.input = new InputManager(canvas);

                // Setup event listeners
                this.setupEventListeners();

                // Create default level
                this.createDefaultLevel();

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Start game loop
                this.gameLoop();
            }

            setupEventListeners() {
                // Network events
                this.network.on('room-created', (data) => {
                    this.showNotification(`Room created: ${data.roomCode}`);
                    this.updateUI();
                });

                this.network.on('room-joined', (data) => {
                    this.showNotification(`Joined room: ${data.roomCode}`);
                    this.updateUI();
                });

                this.network.on('peer-connected', (peerId) => {
                    this.showNotification(`Player connected: ${peerId}`);
                    this.createRemotePlayer(peerId);
                    this.updatePlayersList();
                });

                this.network.on('peer-disconnected', (peerId) => {
                    this.showNotification(`Player disconnected: ${peerId}`);
                    this.removeRemotePlayer(peerId);
                    this.updatePlayersList();
                });

                // Chat events
                this.chat.on('message-added', ({ sender, message }) => {
                    this.displayChatMessage(sender, message);
                });

                // Level editor events
                this.levelEditor.on('object-placed', (obj) => {
                    this.gameObjects.set(obj.id, obj);
                });

                this.levelEditor.on('object-deleted', (obj) => {
                    this.gameObjects.delete(obj.id);
                });

                // Input events
                this.input.on('click', (e) => {
                    if (this.levelEditor.enabled) {
                        this.handleEditorClick(e);
                    }
                });

                // Chat input
                const chatInput = document.getElementById('chatMessageInput');
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChat();
                    }
                });
            }

            createDefaultLevel() {
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 10, 10);
                this.scene.add(directionalLight);

                // Add ground
                const ground = this.factory.create('platform', {
                    position: { x: 0, y: -0.5, z: 0 },
                    size: { x: 20, y: 1, z: 20 },
                    color: 0x2c3e50,
                    mass: 0
                });
                this.gameObjects.set(ground.id, ground);

                // Add some obstacles
                const box1 = this.factory.create('box', {
                    position: { x: 3, y: 2, z: 0 },
                    size: { x: 1, y: 1, z: 1 },
                    mass: 0
                });
                this.gameObjects.set(box1.id, box1);

                const box2 = this.factory.create('box', {
                    position: { x: -3, y: 2, z: 0 },
                    size: { x: 1, y: 1, z: 1 },
                    mass: 0
                });
                this.gameObjects.set(box2.id, box2);
            }

            createPlayer() {
                this.player = this.factory.create('player', {
                    position: { x: 0, y: 5, z: 0 },
                    color: 0x00ff00
                });
                this.gameObjects.set(this.player.id, this.player);

                this.playerController = new PlayerController(this.player, this.camera, this.input);
            }

            createRemotePlayer(peerId) {
                const remotePlayer = this.factory.create('player', {
                    position: { x: Math.random() * 4 - 2, y: 5, z: Math.random() * 4 - 2 },
                    color: 0xff0000
                });
                this.remotePlayers.set(peerId, remotePlayer);
                this.gameObjects.set(remotePlayer.id, remotePlayer);
            }

            removeRemotePlayer(peerId) {
                const remotePlayer = this.remotePlayers.get(peerId);
                if (remotePlayer) {
                    if (remotePlayer.mesh) this.scene.remove(remotePlayer.mesh);
                    if (remotePlayer.body) this.world.removeBody(remotePlayer.body);
                    this.gameObjects.delete(remotePlayer.id);
                    this.remotePlayers.delete(peerId);
                }
            }

            // UI Methods
            async createRoom() {
                const input = document.getElementById('createRoomCode');
                const roomCode = input.value.trim();

                if (!roomCode) {
                    this.showNotification('Please enter a room code');
                    return;
                }

                await this.network.createRoom(roomCode);
                this.startGame();
            }

            async joinRoom() {
                const input = document.getElementById('joinRoomCode');
                const roomCode = input.value.trim();

                if (!roomCode) {
                    this.showNotification('Please enter a room code');
                    return;
                }

                await this.network.joinRoom(roomCode);
                this.startGame();
            }

            startSinglePlayer() {
                this.startGame();
            }

            startGame() {
                this.gameState = 'playing';
                this.createPlayer();

                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('chatPanel').style.display = 'block';
                document.getElementById('playersPanel').style.display = 'block';

                this.updateUI();
                this.replay.startRecording();
            }

            leaveRoom() {
                this.network.disconnect();
                this.gameState = 'menu';

                // Clean up
                if (this.player) {
                    if (this.player.mesh) this.scene.remove(this.player.mesh);
                    if (this.player.body) this.world.removeBody(this.player.body);
                    this.gameObjects.delete(this.player.id);
                    this.player = null;
                }

                this.remotePlayers.forEach(player => {
                    if (player.mesh) this.scene.remove(player.mesh);
                    if (player.body) this.world.removeBody(player.body);
                    this.gameObjects.delete(player.id);
                });
                this.remotePlayers.clear();

                document.getElementById('menuScreen').style.display = 'block';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('chatPanel').style.display = 'none';
                document.getElementById('playersPanel').style.display = 'none';
                document.getElementById('editorPanel').style.display = 'none';
                document.getElementById('replayPanel').style.display = 'none';

                this.replay.stopRecording();
            }

            showLevelEditor() {
                this.gameState = 'editor';
                this.levelEditor.enable();

                document.getElementById('menuScreen').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('editorPanel').style.display = 'block';

                // Position camera for editor
                this.camera.position.set(0, 10, 15);
            }

            toggleEditor() {
                if (this.levelEditor.enabled) {
                    this.levelEditor.disable();
                    document.getElementById('editorPanel').style.display = 'none';
                } else {
                    this.levelEditor.enable();
                    document.getElementById('editorPanel').style.display = 'block';
                }
            }

            toggleReplay() {
                if (this.replay.playing) {
                    this.replay.stopPlayback();
                    document.getElementById('replayPanel').style.display = 'none';
                } else {
                    this.replay.startPlayback();
                    document.getElementById('replayPanel').style.display = 'block';
                }
            }

            selectObjectType(type) {
                this.levelEditor.selectObjectType(type);
                document.getElementById('selectedObjectType').textContent = type.charAt(0).toUpperCase() + type.slice(1);
            }

            deleteSelected() {
                this.levelEditor.deleteSelected();
            }

            clearLevel() {
                if (confirm('Clear all objects from the level?')) {
                    this.levelEditor.clearLevel();
                }
            }

            saveLevel() {
                const levelData = this.levelEditor.exportLevel();
                const json = JSON.stringify(levelData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'level.json';
                a.click();
                URL.revokeObjectURL(url);
                this.showNotification('Level saved');
            }

            loadLevel() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const levelData = JSON.parse(event.target.result);
                                this.levelEditor.importLevel(levelData);
                                this.showNotification('Level loaded');
                            } catch (error) {
                                this.showNotification('Error loading level');
                                console.error(error);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            handleEditorClick(e) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(this.input.mousePosition, this.camera);

                const objects = Array.from(this.gameObjects.values())
                    .filter(obj => obj.mesh)
                    .map(obj => obj.mesh);

                const intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    // Select existing object
                    const selectedMesh = intersects[0].object;
                    const selectedObj = Array.from(this.gameObjects.values())
                        .find(obj => obj.mesh === selectedMesh);

                    if (selectedObj) {
                        this.levelEditor.selectObject(selectedObj);
                    }
                } else {
                    // Place new object
                    const planeIntersect = raycaster.intersectObjects([
                        Array.from(this.gameObjects.values())
                            .find(obj => obj.type === 'platform')?.mesh
                    ].filter(Boolean));

                    if (planeIntersect.length > 0) {
                        const pos = planeIntersect[0].point;
                        this.levelEditor.placeObject({ x: pos.x, y: pos.y + 1, z: pos.z });
                    }
                }
            }

            sendChat() {
                const input = document.getElementById('chatMessageInput');
                const message = input.value.trim();

                if (!message) return;

                const sender = this.network.peerId || 'Player';
                this.chat.addMessage(sender, message);
                this.network.broadcast({ type: 'chat', sender, message });

                input.value = '';
            }

            displayChatMessage(sender, message) {
                const messagesDiv = document.getElementById('chatMessages');
                const messageEl = document.createElement('div');
                messageEl.className = 'chat-message';
                messageEl.innerHTML = `<span class="sender">${sender}:</span> ${message}`;
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }

            updatePlayersList() {
                const listDiv = document.getElementById('playersList');
                listDiv.innerHTML = '';

                // Add self
                const selfItem = document.createElement('div');
                selfItem.className = 'player-item';
                selfItem.innerHTML = `
                    <span>${this.network.peerId || 'Player'} (You)</span>
                    <span class="player-status"></span>
                `;
                listDiv.appendChild(selfItem);

                // Add remote players
                this.network.connections.forEach((connection, peerId) => {
                    const item = document.createElement('div');
                    item.className = 'player-item';
                    item.innerHTML = `
                        <span>${peerId}</span>
                        <span class="player-status"></span>
                    `;
                    listDiv.appendChild(item);
                });
            }

            updateUI() {
                if (this.network.roomCode) {
                    document.getElementById('roomCode').textContent = this.network.roomCode;
                }

                document.getElementById('playerCount').textContent =
                    1 + this.network.connections.size;

                if (this.player && this.player.mesh) {
                    const pos = this.player.mesh.position;
                    document.getElementById('playerPos').textContent =
                        `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                }
            }

            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.style.display = 'block';

                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }

            exportData() {
                const data = {
                    version: '1.0',
                    level: this.levelEditor.exportLevel(),
                    replay: this.replay.frames.length > 0 ? this.replay.exportReplay() : null
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '3d-engine-export.json';
                a.click();
                URL.revokeObjectURL(url);
                this.showNotification('Data exported');
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);

                                if (data.level) {
                                    this.levelEditor.importLevel(data.level);
                                }

                                if (data.replay) {
                                    this.replay.importReplay(data.replay);
                                }

                                this.showNotification('Data imported');
                            } catch (error) {
                                this.showNotification('Error importing data');
                                console.error(error);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            replayPlay() {
                this.replay.startPlayback();
            }

            replayPause() {
                this.replay.playing = false;
            }

            replayStop() {
                this.replay.stopPlayback();
            }

            // Game Loop
            gameLoop() {
                requestAnimationFrame(() => this.gameLoop());

                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                // Update FPS
                this.frameCount++;
                if (currentTime - this.lastFpsUpdate > this.fpsUpdateInterval) {
                    this.fps = Math.round(this.frameCount / ((currentTime - this.lastFpsUpdate) / 1000));
                    document.getElementById('fps').textContent = this.fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                }

                // Update physics
                this.world.step(1 / 60, deltaTime, 3);

                // Sync physics to graphics
                this.gameObjects.forEach(obj => {
                    if (obj.mesh && obj.body) {
                        obj.mesh.position.copy(obj.body.position);
                        obj.mesh.quaternion.copy(obj.body.quaternion);
                    }
                });

                // Update player controller
                if (this.playerController && this.gameState === 'playing') {
                    this.playerController.update(deltaTime);
                }

                // Record replay
                if (this.replay.recording && this.gameState === 'playing') {
                    const gameState = {
                        player: this.player ? this.player.serialize() : null,
                        objects: Array.from(this.gameObjects.values()).map(obj => obj.serialize())
                    };
                    this.replay.recordFrame(gameState);
                }

                // Update UI
                if (this.gameState === 'playing') {
                    this.updateUI();
                }

                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }

        // ============================================================================
        // INITIALIZE APPLICATION
        // ============================================================================

        let gameManager;

        window.addEventListener('DOMContentLoaded', () => {
            gameManager = new GameManager();
            window.gameManager = gameManager; // Make globally accessible for UI
        });
    </script>
</body>
</html>