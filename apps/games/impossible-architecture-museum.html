<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impossible Architecture Museum</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .data-controls button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #importFile {
            display: none;
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 100;
        }

        .room-title {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 8px;
            text-transform: uppercase;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -40%); }
            20% { opacity: 1; transform: translate(-50%, -50%); }
            80% { opacity: 1; transform: translate(-50%, -50%); }
            100% { opacity: 0; transform: translate(-50%, -60%); }
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1000;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 2000;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading Impossible Architecture...</div>
    <canvas id="gameCanvas"></canvas>

    <div class="data-controls">
        <button onclick="exportData()">Export Museum</button>
        <button onclick="document.getElementById('importFile').click()">Import Museum</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
    </div>

    <div class="hud">
        <div>Room: <span id="currentRoom">Entrance Hall</span></div>
        <div>Gravity: <span id="gravityDirection">Down</span></div>
    </div>

    <div class="crosshair"></div>

    <div class="instructions">
        WASD: Move | Mouse: Look | Click: Interact with Doors | Space: Jump | R: Reset Gravity
    </div>

    <div class="room-title" id="roomTitle"></div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js';

        const APP_NAME = 'impossible-architecture-museum';

        // Museum state management
        let museumData = {
            rooms: [],
            currentRoom: 0,
            playerPosition: { x: 0, y: 2, z: 0 },
            gravityRotation: 0,
            visitedRooms: [],
            customLayouts: []
        };

        // Load saved data
        function loadData() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    Object.assign(museumData, parsed);
                } catch (e) {
                    console.error('Failed to load saved data:', e);
                }
            }
        }

        // Save data
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(museumData));
        }

        // Export museum data
        window.exportData = function() {
            const dataStr = JSON.stringify(museumData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        };

        // Import museum data
        window.importData = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    museumData = JSON.parse(e.target.result);
                    saveData();
                    location.reload();
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        };

        // Initialize Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x764ba2, 10, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('gameCanvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Player controls
        const playerState = {
            position: new THREE.Vector3(0, 2, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0),
            gravityDirection: new THREE.Vector3(0, -1, 0),
            isGrounded: false,
            currentRoom: null,
            transitionProgress: 0
        };

        const keys = {};
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;

        // Input handlers
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        document.addEventListener('click', () => {
            if (!isPointerLocked) {
                document.body.requestPointerLock();
            } else {
                checkDoorInteraction();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseX += e.movementX * 0.002;
                mouseY -= e.movementY * 0.002;
                mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
            }
        });

        // Room class for impossible geometries
        class ImpossibleRoom {
            constructor(name, type) {
                this.name = name;
                this.type = type;
                this.group = new THREE.Group();
                this.doors = [];
                this.specialFeatures = [];
                this.generate();
            }

            generate() {
                const floorMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    side: THREE.DoubleSide
                });

                const wallMaterial = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    side: THREE.DoubleSide
                });

                switch(this.type) {
                    case 'penrose_stairs':
                        this.createPenroseStairs();
                        break;
                    case 'impossible_triangle':
                        this.createImpossibleTriangle();
                        break;
                    case 'gravity_room':
                        this.createGravityRoom();
                        break;
                    case 'infinite_corridor':
                        this.createInfiniteCorridor();
                        break;
                    case 'mobius_chamber':
                        this.createMobiusChamber();
                        break;
                    case 'escher_waterfall':
                        this.createEscherWaterfall();
                        break;
                    case 'tesseract_room':
                        this.createTesseractRoom();
                        break;
                    default:
                        this.createBasicRoom();
                }
            }

            createPenroseStairs() {
                // Create impossible staircase that loops infinitely
                const stairCount = 16;
                const stairHeight = 0.5;
                const radius = 8;

                for (let i = 0; i < stairCount; i++) {
                    const angle = (i / stairCount) * Math.PI * 2;
                    const nextAngle = ((i + 1) / stairCount) * Math.PI * 2;

                    // Create stair step
                    const stepGeom = new THREE.BoxGeometry(3, stairHeight, 2);
                    const stepMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(i / stairCount, 0.5, 0.5)
                    });
                    const step = new THREE.Mesh(stepGeom, stepMat);

                    // Position with impossible height loop
                    const height = (i * stairHeight) % (stairHeight * 4);
                    step.position.set(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );
                    step.rotation.y = -angle;
                    step.castShadow = true;
                    step.receiveShadow = true;
                    this.group.add(step);

                    // Add railing
                    const railGeom = new THREE.BoxGeometry(0.1, 2, 2);
                    const rail = new THREE.Mesh(railGeom, stepMat);
                    rail.position.set(
                        Math.cos(angle) * (radius + 1.5),
                        height + 1,
                        Math.sin(angle) * (radius + 1.5)
                    );
                    rail.rotation.y = -angle;
                    this.group.add(rail);
                }

                // Central pillar
                const pillarGeom = new THREE.CylinderGeometry(2, 2, 20);
                const pillarMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const pillar = new THREE.Mesh(pillarGeom, pillarMat);
                pillar.castShadow = true;
                this.group.add(pillar);
            }

            createImpossibleTriangle() {
                // Create Penrose triangle
                const triangleParts = [];
                const size = 10;
                const thickness = 2;

                // Create three beams that form impossible triangle
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const beamGeom = new THREE.BoxGeometry(size, thickness, thickness);
                    const beamMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(i / 3, 0.7, 0.5)
                    });
                    const beam = new THREE.Mesh(beamGeom, beamMat);

                    // Position and rotate for impossible effect
                    beam.position.set(
                        Math.cos(angle) * size/2,
                        Math.sin(i * Math.PI * 0.7) * 3,
                        Math.sin(angle) * size/2
                    );
                    beam.rotation.z = angle;
                    beam.rotation.y = angle * 0.5;
                    beam.castShadow = true;
                    this.group.add(beam);
                }

                // Add floating platforms around triangle
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const platformGeom = new THREE.BoxGeometry(4, 0.5, 4);
                    const platformMat = new THREE.MeshPhongMaterial({
                        color: 0x555555,
                        emissive: 0x111111
                    });
                    const platform = new THREE.Mesh(platformGeom, platformMat);
                    platform.position.set(
                        Math.cos(angle) * 12,
                        Math.sin(i * 2) * 2,
                        Math.sin(angle) * 12
                    );
                    platform.receiveShadow = true;
                    this.group.add(platform);
                }
            }

            createGravityRoom() {
                // Room where each wall can be walked on
                const roomSize = 20;
                const wallThickness = 0.5;

                // Create walls with different gravity orientations
                const walls = [
                    { pos: [0, -roomSize/2, 0], rot: [0, 0, 0], color: 0x442222 }, // Floor
                    { pos: [0, roomSize/2, 0], rot: [Math.PI, 0, 0], color: 0x224422 }, // Ceiling
                    { pos: [-roomSize/2, 0, 0], rot: [0, 0, Math.PI/2], color: 0x222244 }, // Left
                    { pos: [roomSize/2, 0, 0], rot: [0, 0, -Math.PI/2], color: 0x444422 }, // Right
                    { pos: [0, 0, -roomSize/2], rot: [Math.PI/2, 0, 0], color: 0x442244 }, // Back
                    { pos: [0, 0, roomSize/2], rot: [-Math.PI/2, 0, 0], color: 0x224444 } // Front
                ];

                walls.forEach((wall, index) => {
                    const wallGeom = new THREE.BoxGeometry(roomSize, wallThickness, roomSize);
                    const wallMat = new THREE.MeshPhongMaterial({
                        color: wall.color,
                        side: THREE.DoubleSide
                    });
                    const wallMesh = new THREE.Mesh(wallGeom, wallMat);
                    wallMesh.position.set(...wall.pos);
                    wallMesh.rotation.set(...wall.rot);
                    wallMesh.receiveShadow = true;
                    wallMesh.userData = { gravityDirection: index };
                    this.group.add(wallMesh);

                    // Add furniture on each wall
                    const furnitureGeom = new THREE.BoxGeometry(2, 3, 2);
                    const furniture = new THREE.Mesh(furnitureGeom, new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(index / 6, 0.5, 0.4)
                    }));
                    furniture.position.copy(wallMesh.position).multiplyScalar(0.8);
                    furniture.rotation.copy(wallMesh.rotation);
                    furniture.castShadow = true;
                    this.group.add(furniture);
                });

                // Add gravity indicators
                for (let i = 0; i < 6; i++) {
                    const arrowGeom = new THREE.ConeGeometry(1, 3, 8);
                    const arrowMat = new THREE.MeshPhongMaterial({
                        color: 0xff0000,
                        emissive: 0x440000
                    });
                    const arrow = new THREE.Mesh(arrowGeom, arrowMat);
                    const angle = (i / 6) * Math.PI * 2;
                    arrow.position.set(
                        Math.cos(angle) * 8,
                        0,
                        Math.sin(angle) * 8
                    );
                    arrow.rotation.z = angle;
                    this.group.add(arrow);
                }
            }

            createInfiniteCorridor() {
                // Create corridor that seems to go on forever
                const segmentCount = 20;
                const segmentLength = 5;

                for (let i = 0; i < segmentCount; i++) {
                    const scale = 1 - (i / segmentCount) * 0.8;

                    // Create corridor segment
                    const segmentGroup = new THREE.Group();

                    // Floor
                    const floorGeom = new THREE.PlaneGeometry(6 * scale, segmentLength);
                    const floorMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(i / segmentCount, 0.3, 0.3),
                        side: THREE.DoubleSide
                    });
                    const floor = new THREE.Mesh(floorGeom, floorMat);
                    floor.rotation.x = -Math.PI / 2;
                    floor.position.y = -3;
                    segmentGroup.add(floor);

                    // Walls
                    const wallGeom = new THREE.PlaneGeometry(segmentLength, 6 * scale);
                    const leftWall = new THREE.Mesh(wallGeom, floorMat);
                    leftWall.rotation.y = Math.PI / 2;
                    leftWall.position.x = -3 * scale;
                    segmentGroup.add(leftWall);

                    const rightWall = new THREE.Mesh(wallGeom, floorMat);
                    rightWall.rotation.y = -Math.PI / 2;
                    rightWall.position.x = 3 * scale;
                    segmentGroup.add(rightWall);

                    // Position segment
                    segmentGroup.position.z = -i * segmentLength;

                    // Add twist for non-euclidean effect
                    segmentGroup.rotation.y = Math.sin(i * 0.3) * 0.2;
                    segmentGroup.rotation.z = Math.cos(i * 0.2) * 0.1;

                    this.group.add(segmentGroup);

                    // Add floating lights
                    const lightGeom = new THREE.SphereGeometry(0.3);
                    const lightMat = new THREE.MeshPhongMaterial({
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    const light = new THREE.Mesh(lightGeom, lightMat);
                    light.position.set(0, 1, -i * segmentLength);
                    this.group.add(light);

                    const pointLight = new THREE.PointLight(0xffff00, 0.5, 10);
                    pointLight.position.copy(light.position);
                    this.group.add(pointLight);
                }
            }

            createMobiusChamber() {
                // Create a Möbius strip-inspired room
                const segments = 32;
                const radius = 10;
                const width = 6;

                for (let i = 0; i < segments; i++) {
                    const t = (i / segments) * Math.PI * 2;
                    const twist = t / 2; // Half twist for Möbius

                    // Create segment
                    const segmentGeom = new THREE.BoxGeometry(width, 0.5, 2);
                    const segmentMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(i / segments, 0.6, 0.5)
                    });
                    const segment = new THREE.Mesh(segmentGeom, segmentMat);

                    // Position on Möbius path
                    segment.position.set(
                        Math.cos(t) * radius,
                        Math.sin(twist) * 3,
                        Math.sin(t) * radius
                    );
                    segment.rotation.y = -t;
                    segment.rotation.z = twist;
                    segment.receiveShadow = true;
                    segment.castShadow = true;
                    this.group.add(segment);

                    // Add decorative element
                    if (i % 4 === 0) {
                        const decorGeom = new THREE.OctahedronGeometry(1);
                        const decor = new THREE.Mesh(decorGeom, segmentMat);
                        decor.position.copy(segment.position);
                        decor.position.y += 2;
                        this.group.add(decor);
                    }
                }

                // Central impossible object
                const centerGeom = new THREE.TorusKnotGeometry(3, 1, 100, 16);
                const centerMat = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x004444,
                    wireframe: true
                });
                const center = new THREE.Mesh(centerGeom, centerMat);
                this.group.add(center);
            }

            createEscherWaterfall() {
                // Create impossible waterfall
                const channelLength = 15;
                const channelWidth = 2;
                const channelHeight = 0.5;

                // Create water channels at different levels
                const channels = [
                    { start: [0, 5, -5], end: [10, 4, -5], level: 0 },
                    { start: [10, 4, -5], end: [10, 3, 5], level: 1 },
                    { start: [10, 3, 5], end: [0, 2, 5], level: 2 },
                    { start: [0, 2, 5], end: [0, 5, -5], level: 3 } // Impossible connection
                ];

                channels.forEach((channel, index) => {
                    const channelGeom = new THREE.BoxGeometry(channelLength, channelHeight, channelWidth);
                    const channelMat = new THREE.MeshPhongMaterial({
                        color: 0x444466,
                        emissive: 0x111122
                    });
                    const channelMesh = new THREE.Mesh(channelGeom, channelMat);

                    // Position between start and end
                    channelMesh.position.set(
                        (channel.start[0] + channel.end[0]) / 2,
                        (channel.start[1] + channel.end[1]) / 2,
                        (channel.start[2] + channel.end[2]) / 2
                    );

                    // Rotate to align with direction
                    const direction = new THREE.Vector3(
                        channel.end[0] - channel.start[0],
                        channel.end[1] - channel.start[1],
                        channel.end[2] - channel.start[2]
                    );
                    channelMesh.lookAt(channelMesh.position.clone().add(direction));
                    channelMesh.receiveShadow = true;
                    this.group.add(channelMesh);

                    // Add water particles
                    const particleCount = 20;
                    for (let i = 0; i < particleCount; i++) {
                        const particleGeom = new THREE.SphereGeometry(0.2);
                        const particleMat = new THREE.MeshPhongMaterial({
                            color: 0x0088ff,
                            emissive: 0x004488,
                            transparent: true,
                            opacity: 0.7
                        });
                        const particle = new THREE.Mesh(particleGeom, particleMat);

                        const t = i / particleCount;
                        particle.position.set(
                            channel.start[0] + (channel.end[0] - channel.start[0]) * t,
                            channel.start[1] + (channel.end[1] - channel.start[1]) * t + Math.sin(t * Math.PI) * 0.5,
                            channel.start[2] + (channel.end[2] - channel.start[2]) * t
                        );
                        particle.userData = {
                            channel: index,
                            progress: t,
                            basePosition: particle.position.clone()
                        };
                        this.specialFeatures.push(particle);
                        this.group.add(particle);
                    }
                });

                // Add waterwheel
                const wheelGeom = new THREE.CylinderGeometry(3, 3, 1, 16);
                const wheelMat = new THREE.MeshPhongMaterial({ color: 0x885533 });
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.position.set(5, 0, 0);
                wheel.rotation.z = Math.PI / 2;
                wheel.userData = { isWheel: true };
                this.specialFeatures.push(wheel);
                this.group.add(wheel);
            }

            createTesseractRoom() {
                // Create 4D tesseract projection
                const size = 5;
                const vertices = [];

                // Generate 4D hypercube vertices
                for (let i = 0; i < 16; i++) {
                    const x = ((i & 1) ? 1 : -1) * size;
                    const y = ((i & 2) ? 1 : -1) * size;
                    const z = ((i & 4) ? 1 : -1) * size;
                    const w = ((i & 8) ? 1 : -1) * size;

                    // Project 4D to 3D
                    const projection = {
                        x: x + w * 0.5,
                        y: y + w * 0.5,
                        z: z + w * 0.5
                    };
                    vertices.push(projection);
                }

                // Create edges
                const edgeGeom = new THREE.CylinderGeometry(0.1, 0.1, 1);
                const edgeMat = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    emissive: 0x004400
                });

                // Connect vertices
                for (let i = 0; i < vertices.length; i++) {
                    for (let j = i + 1; j < vertices.length; j++) {
                        // Check if vertices differ by only one bit (are connected)
                        const diff = i ^ j;
                        if ((diff & (diff - 1)) === 0) {
                            const edge = new THREE.Mesh(edgeGeom, edgeMat);
                            const v1 = vertices[i];
                            const v2 = vertices[j];

                            const midpoint = {
                                x: (v1.x + v2.x) / 2,
                                y: (v1.y + v2.y) / 2,
                                z: (v1.z + v2.z) / 2
                            };

                            const length = Math.sqrt(
                                Math.pow(v2.x - v1.x, 2) +
                                Math.pow(v2.y - v1.y, 2) +
                                Math.pow(v2.z - v1.z, 2)
                            );

                            edge.position.set(midpoint.x, midpoint.y, midpoint.z);
                            edge.scale.y = length;
                            edge.lookAt(v2.x, v2.y, v2.z);
                            edge.rotateX(Math.PI / 2);
                            this.group.add(edge);
                        }
                    }

                    // Add vertex spheres
                    const vertexGeom = new THREE.SphereGeometry(0.3);
                    const vertexMat = new THREE.MeshPhongMaterial({
                        color: 0xff00ff,
                        emissive: 0x440044
                    });
                    const vertex = new THREE.Mesh(vertexGeom, vertexMat);
                    vertex.position.set(vertices[i].x, vertices[i].y, vertices[i].z);
                    this.group.add(vertex);
                }

                // Add rotating inner cube
                const innerCubeGeom = new THREE.BoxGeometry(3, 3, 3);
                const innerCubeMat = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    emissive: 0x444400,
                    transparent: true,
                    opacity: 0.3
                });
                const innerCube = new THREE.Mesh(innerCubeGeom, innerCubeMat);
                innerCube.userData = { isRotating: true };
                this.specialFeatures.push(innerCube);
                this.group.add(innerCube);
            }

            createBasicRoom() {
                // Fallback basic room
                const roomGeom = new THREE.BoxGeometry(20, 10, 20);
                const roomMat = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    side: THREE.BackSide
                });
                const room = new THREE.Mesh(roomGeom, roomMat);
                room.receiveShadow = true;
                this.group.add(room);
            }

            update(time) {
                // Animate special features
                this.specialFeatures.forEach(feature => {
                    if (feature.userData.isWheel) {
                        feature.rotation.x += 0.01;
                    }
                    if (feature.userData.isRotating) {
                        feature.rotation.x += 0.005;
                        feature.rotation.y += 0.007;
                        feature.rotation.z += 0.003;
                    }
                    if (feature.userData.basePosition) {
                        // Animate water particles
                        feature.userData.progress += 0.01;
                        if (feature.userData.progress > 1) {
                            feature.userData.progress = 0;
                        }
                        const t = feature.userData.progress;
                        feature.position.y = feature.userData.basePosition.y + Math.sin(t * Math.PI * 2) * 0.5;
                    }
                });

                // Rotate entire room for disorienting effect in some room types
                if (this.type === 'mobius_chamber') {
                    this.group.rotation.y += 0.001;
                }
                if (this.type === 'tesseract_room') {
                    this.group.rotation.x += 0.001;
                    this.group.rotation.z += 0.0007;
                }
            }
        }

        // Create museum rooms
        const roomTypes = [
            { name: 'Entrance Hall', type: 'penrose_stairs' },
            { name: 'Triangle Paradox', type: 'impossible_triangle' },
            { name: 'Gravity Chamber', type: 'gravity_room' },
            { name: 'Infinite Corridor', type: 'infinite_corridor' },
            { name: 'Möbius Gallery', type: 'mobius_chamber' },
            { name: 'Waterfall Impossibility', type: 'escher_waterfall' },
            { name: 'Tesseract Vault', type: 'tesseract_room' }
        ];

        let currentRoomIndex = 0;
        let currentRoom = null;

        function loadRoom(index) {
            // Remove current room
            if (currentRoom) {
                scene.remove(currentRoom.group);
            }

            // Create and add new room
            const roomData = roomTypes[index % roomTypes.length];
            currentRoom = new ImpossibleRoom(roomData.name, roomData.type);
            scene.add(currentRoom.group);

            // Update HUD
            document.getElementById('currentRoom').textContent = roomData.name;

            // Show room title
            const titleElement = document.getElementById('roomTitle');
            titleElement.textContent = roomData.name;
            titleElement.style.animation = 'none';
            setTimeout(() => {
                titleElement.style.animation = 'fadeInOut 3s ease-in-out';
            }, 10);

            // Save state
            museumData.currentRoom = index;
            museumData.visitedRooms.push(roomData.name);
            saveData();
        }

        // Door interaction
        function checkDoorInteraction() {
            // Simple room transition on click
            currentRoomIndex = (currentRoomIndex + 1) % roomTypes.length;
            loadRoom(currentRoomIndex);

            // Reset player position for new room
            playerState.position.set(0, 2, 0);
            playerState.velocity.set(0, 0, 0);
        }

        // Player movement
        function updatePlayer(deltaTime) {
            const speed = 5;
            const jumpPower = 8;

            // Apply gravity
            if (!playerState.isGrounded) {
                playerState.velocity.add(
                    playerState.gravityDirection.clone().multiplyScalar(9.8 * deltaTime)
                );
            }

            // Movement based on gravity orientation
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);

            // Remove vertical component based on gravity
            forward.sub(playerState.gravityDirection.clone().multiplyScalar(
                forward.dot(playerState.gravityDirection)
            )).normalize();
            right.sub(playerState.gravityDirection.clone().multiplyScalar(
                right.dot(playerState.gravityDirection)
            )).normalize();

            // Apply input
            if (keys['w']) playerState.position.add(forward.clone().multiplyScalar(speed * deltaTime));
            if (keys['s']) playerState.position.sub(forward.clone().multiplyScalar(speed * deltaTime));
            if (keys['a']) playerState.position.sub(right.clone().multiplyScalar(speed * deltaTime));
            if (keys['d']) playerState.position.add(right.clone().multiplyScalar(speed * deltaTime));

            // Jump
            if (keys[' '] && playerState.isGrounded) {
                playerState.velocity.sub(playerState.gravityDirection.clone().multiplyScalar(jumpPower));
                playerState.isGrounded = false;
            }

            // Reset gravity
            if (keys['r']) {
                playerState.gravityDirection.set(0, -1, 0);
                document.getElementById('gravityDirection').textContent = 'Down';
            }

            // Apply velocity
            playerState.position.add(playerState.velocity.clone().multiplyScalar(deltaTime));

            // Simple ground check
            if (playerState.position.y <= 2 && playerState.velocity.y <= 0) {
                playerState.position.y = 2;
                playerState.velocity.y = 0;
                playerState.isGrounded = true;
            }

            // Update camera
            camera.position.copy(playerState.position);
            camera.rotation.y = mouseX;
            camera.rotation.x = mouseY;

            // Room bounds
            const bound = 25;
            playerState.position.x = Math.max(-bound, Math.min(bound, playerState.position.x));
            playerState.position.z = Math.max(-bound, Math.min(bound, playerState.position.z));
        }

        // Animation loop
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update player
            updatePlayer(deltaTime);

            // Update current room
            if (currentRoom) {
                currentRoom.update(currentTime * 0.001);
            }

            // Render
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        loadData();
        loadRoom(museumData.currentRoom || 0);
        document.getElementById('loading').style.display = 'none';
        animate();
    </script>
</body>
</html>