<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo 2 Lockout - Multiplayer FPS</title>
    <meta name="description" content="Multiplayer first-person shooter inspired by Halo 2's iconic Lockout map with WebRTC P2P networking">
    <!-- 3d, fps, multiplayer, webrtc, game, shooter -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        /* Menu Screens */
        #menu-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a1628 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #menu-screen.hidden { display: none; }

        .menu-title {
            font-size: 64px;
            font-weight: bold;
            color: #5af;
            text-shadow: 0 0 30px #0af, 0 0 60px #05a;
            margin-bottom: 10px;
            letter-spacing: 8px;
        }

        .menu-subtitle {
            font-size: 24px;
            color: #8bf;
            margin-bottom: 40px;
            letter-spacing: 4px;
        }

        .menu-section {
            background: rgba(20, 40, 80, 0.8);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 30px;
            margin: 10px;
            min-width: 420px;
            box-shadow: 0 0 30px rgba(50, 150, 255, 0.3);
        }

        .section-title {
            font-size: 18px;
            color: #5af;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-input {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            background: rgba(0, 20, 50, 0.8);
            border: 1px solid #3af;
            color: #fff;
            font-size: 16px;
            border-radius: 4px;
            outline: none;
            transition: all 0.3s;
        }

        .menu-input:focus {
            border-color: #5cf;
            box-shadow: 0 0 15px rgba(50, 150, 255, 0.5);
        }

        .menu-button {
            width: 100%;
            padding: 16px;
            margin: 8px 0;
            background: linear-gradient(180deg, #2a5a9a 0%, #1a3a6a 100%);
            border: 2px solid #4af;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .menu-button:hover {
            background: linear-gradient(180deg, #3a7aca 0%, #2a5a9a 100%);
            box-shadow: 0 0 20px rgba(50, 150, 255, 0.5);
            transform: scale(1.02);
        }

        .menu-button:active { transform: scale(0.98); }

        /* v1.02: Focus indicators for accessibility */
        .menu-button:focus,
        .menu-input:focus,
        button:focus {
            outline: 3px solid #5cf;
            outline-offset: 2px;
        }

        .menu-button.secondary {
            background: rgba(50, 50, 50, 0.5);
            border-color: #666;
        }

        .menu-button.start-game {
            background: linear-gradient(180deg, #2a9a5a 0%, #1a6a3a 100%);
            border-color: #4fa;
        }

        #lobby-code-display {
            font-size: 36px;
            font-weight: bold;
            color: #5cf;
            text-align: center;
            margin: 15px 0;
            letter-spacing: 8px;
            text-shadow: 0 0 20px #0af;
        }

        #lobby-players {
            max-height: 200px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .lobby-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: rgba(0, 40, 80, 0.5);
            border-radius: 4px;
            border-left: 3px solid #3af;
        }

        .lobby-player.ready { border-left-color: #4fa; }
        .lobby-player .host-badge {
            background: #fa0;
            color: #000;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        /* Game Canvas Container */
        #game-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .crosshair-br {
            width: 40px; height: 40px;
        }

        .crosshair-br .dot {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 4px; height: 4px;
            background: #fff;
            border-radius: 50%;
        }

        .crosshair-br .line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair-br .line.top { width: 2px; height: 10px; top: 2px; left: 50%; transform: translateX(-50%); }
        .crosshair-br .line.bottom { width: 2px; height: 10px; bottom: 2px; left: 50%; transform: translateX(-50%); }
        .crosshair-br .line.left { width: 10px; height: 2px; left: 2px; top: 50%; transform: translateY(-50%); }
        .crosshair-br .line.right { width: 10px; height: 2px; right: 2px; top: 50%; transform: translateY(-50%); }

        /* Shield/Health Bar - Halo Style */
        #shield-container {
            position: fixed;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            width: 400px;
        }

        #shield-bar {
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #48f;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #shield-fill {
            height: 100%;
            background: linear-gradient(180deg, #6cf 0%, #48f 50%, #26a 100%);
            transition: width 0.15s;
            position: relative;
        }

        #shield-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
        }

        #shield-segments {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
        }

        .shield-segment {
            flex: 1;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
        }

        #health-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #a33;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        #health-fill {
            height: 100%;
            background: linear-gradient(180deg, #f44 0%, #a22 100%);
            transition: width 0.15s;
        }

        /* Shield Damage Flash */
        #shield-flash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(100, 180, 255, 0.4) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        #shield-flash.active { opacity: 1; }
        #shield-flash.broken {
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255, 50, 50, 0.5) 100%);
        }

        /* Weapon Display */
        #weapon-display {
            position: fixed;
            bottom: 30px; right: 30px;
            text-align: right;
        }

        #weapon-name {
            font-size: 14px;
            color: #8bf;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #ammo-display {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        #ammo-display .reserve {
            font-size: 24px;
            color: #8bf;
        }

        /* Kill Feed */
        #kill-feed {
            position: fixed;
            top: 80px; right: 20px;
            width: 350px;
        }

        .kill-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 14px;
            animation: killSlideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .kill-item .killer { color: #5cf; }
        .kill-item .victim { color: #f55; }
        .kill-item .weapon-icon {
            margin: 0 8px;
            color: #aaa;
            font-size: 12px;
        }

        @keyframes killSlideIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Scoreboard */
        #scoreboard {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.95);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 20px;
            min-width: 500px;
            display: none;
            z-index: 200;
        }

        #scoreboard.visible { display: block; }

        #scoreboard h2 {
            text-align: center;
            color: #5cf;
            margin-bottom: 20px;
            font-size: 24px;
            letter-spacing: 4px;
        }

        .scoreboard-header, .scoreboard-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(50, 150, 255, 0.3);
        }

        .scoreboard-header {
            color: #8bf;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .scoreboard-row.local { background: rgba(50, 150, 255, 0.2); }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 20px; left: 20px;
            width: 180px; height: 180px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #3af;
            border-radius: 4px;
        }

        #minimap-canvas {
            width: 100%; height: 100%;
        }

        /* Timer */
        #match-timer {
            position: fixed;
            top: 55px; left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: #8bf;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        /* Score Display */
        #score-display {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #3af;
        }

        #score-display .label {
            font-size: 12px;
            color: #8bf;
            text-transform: uppercase;
        }

        #score-display .value {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
        }

        /* Hit Marker */
        #hit-marker {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
        }

        #hit-marker.active { opacity: 1; }
        #hit-marker.kill { color: #f44; }

        .hit-marker-line {
            position: absolute;
            width: 15px; height: 3px;
            background: #fff;
        }

        .hit-marker-line:nth-child(1) { transform: rotate(45deg) translate(8px, 8px); }
        .hit-marker-line:nth-child(2) { transform: rotate(-45deg) translate(-8px, 8px); }
        .hit-marker-line:nth-child(3) { transform: rotate(135deg) translate(8px, -8px); }
        .hit-marker-line:nth-child(4) { transform: rotate(-135deg) translate(-8px, -8px); }

        /* Respawn Screen */
        #respawn-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
        }

        #respawn-screen.visible { display: flex; }

        #respawn-screen h1 {
            font-size: 48px;
            color: #f44;
            margin-bottom: 20px;
        }

        #respawn-timer {
            font-size: 72px;
            color: #fff;
        }

        /* Instructions Overlay */
        #instructions {
            position: fixed;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #8bf;
            text-align: center;
        }

        /* v1.06: Help Overlay - Comprehensive control documentation */
        #help-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            overflow-y: auto;
            padding: 40px 20px;
        }

        #help-overlay.visible { display: flex; }

        .help-container {
            background: rgba(20, 40, 80, 0.9);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 30px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 0 40px rgba(50, 150, 255, 0.5);
        }

        .help-title {
            font-size: 36px;
            font-weight: bold;
            color: #5cf;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #0af;
        }

        .help-subtitle {
            font-size: 14px;
            color: #8bf;
            text-align: center;
            margin-bottom: 30px;
        }

        .help-section {
            margin-bottom: 25px;
        }

        .help-section-title {
            font-size: 20px;
            color: #5cf;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(50, 150, 255, 0.3);
            padding-bottom: 8px;
        }

        .help-grid {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 10px 15px;
            font-size: 14px;
        }

        .help-key {
            background: rgba(50, 100, 150, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #3af;
            color: #5cf;
            font-weight: bold;
            text-align: center;
        }

        .help-description {
            color: #aaa;
            display: flex;
            align-items: center;
        }

        .help-close {
            width: 100%;
            padding: 14px;
            margin-top: 20px;
            background: linear-gradient(180deg, #2a5a9a 0%, #1a3a6a 100%);
            border: 2px solid #4af;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .help-close:hover {
            background: linear-gradient(180deg, #3a7aca 0%, #2a5a9a 100%);
            box-shadow: 0 0 20px rgba(50, 150, 255, 0.5);
        }

        @media (max-width: 768px) {
            .help-grid {
                grid-template-columns: 1fr;
                gap: 5px;
            }
            .help-key {
                text-align: left;
            }
        }

        /* v1.07: Settings Menu */
        #settings-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            overflow-y: auto;
            padding: 40px 20px;
        }

        #settings-overlay.visible { display: flex; }

        .settings-container {
            background: rgba(20, 40, 80, 0.9);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 0 40px rgba(50, 150, 255, 0.5);
        }

        .settings-title {
            font-size: 32px;
            font-weight: bold;
            color: #5cf;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0af;
        }

        .settings-group {
            margin-bottom: 25px;
        }

        .settings-label {
            display: block;
            font-size: 14px;
            color: #8bf;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .settings-slider {
            width: 100%;
            height: 6px;
            background: rgba(50, 100, 150, 0.3);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #5cf;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(80, 200, 255, 0.5);
        }

        .settings-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #5cf;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(80, 200, 255, 0.5);
        }

        .settings-value {
            display: inline-block;
            float: right;
            color: #fff;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }

        .settings-select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 20, 50, 0.8);
            border: 1px solid #3af;
            color: #fff;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
        }

        .settings-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #5cf;
        }

        /* v1.07: Match End Screen */
        #match-end-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }

        #match-end-screen.visible { display: flex; }

        .match-end-container {
            background: rgba(20, 40, 80, 0.95);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 40px;
            max-width: 700px;
            width: 90%;
            box-shadow: 0 0 50px rgba(50, 150, 255, 0.6);
        }

        .match-end-title {
            font-size: 48px;
            font-weight: bold;
            color: #4fa;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 30px #0f8;
        }

        .match-end-subtitle {
            font-size: 18px;
            color: #8bf;
            text-align: center;
            margin-bottom: 30px;
        }

        .mvp-section {
            background: rgba(100, 200, 100, 0.1);
            border: 2px solid #4fa;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 25px;
            text-align: center;
        }

        .mvp-label {
            font-size: 14px;
            color: #8bf;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .mvp-name {
            font-size: 32px;
            font-weight: bold;
            color: #4fa;
            text-shadow: 0 0 20px #0f8;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-box {
            background: rgba(50, 100, 150, 0.3);
            border: 1px solid #3af;
            border-radius: 4px;
            padding: 15px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #8bf;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #fff;
        }

        .match-end-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        .match-end-buttons button {
            flex: 1;
            padding: 14px;
            background: linear-gradient(180deg, #2a5a9a 0%, #1a3a6a 100%);
            border: 2px solid #4af;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .match-end-buttons button:hover {
            background: linear-gradient(180deg, #3a7aca 0%, #2a5a9a 100%);
            box-shadow: 0 0 20px rgba(50, 150, 255, 0.5);
        }

        /* v1.07: Killstreak Announcements */
        #killstreak-announcement {
            position: fixed;
            top: 30%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            font-weight: bold;
            color: #ff4400;
            text-shadow: 0 0 30px #ff4400, 0 0 60px #ff2200;
            opacity: 0;
            pointer-events: none;
            z-index: 500;
            animation: none;
            text-transform: uppercase;
            letter-spacing: 8px;
        }

        #killstreak-announcement.active {
            animation: killstreakPulse 1.5s ease-out;
        }

        @keyframes killstreakPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            40% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px; left: 10px;
            z-index: 1001;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            padding: 8px 14px;
            background: rgba(30, 60, 100, 0.8);
            border: 1px solid #3af;
            color: #8bf;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: rgba(50, 100, 150, 0.8);
            color: #fff;
        }

        /* Weapon Pickup Indicator */
        #weapon-pickup {
            position: fixed;
            bottom: 200px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border: 1px solid #5cf;
            border-radius: 4px;
            display: none;
            text-align: center;
        }

        #weapon-pickup.visible { display: block; }

        #weapon-pickup .key {
            display: inline-block;
            background: #3af;
            color: #000;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            margin-right: 8px;
        }

        /* Scope Overlay */
        #scope-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center,
                transparent 20%,
                rgba(0, 0, 0, 0.95) 35%,
                #000 40%);
            display: none;
            pointer-events: none;
            z-index: 90;
        }

        #scope-overlay.active { display: block; }

        .scope-crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }

        .scope-line {
            position: absolute;
            background: rgba(255, 0, 0, 0.7);
        }

        .scope-line.h {
            width: 800px; height: 1px;
            left: -400px; top: 0;
        }

        .scope-line.v {
            width: 1px; height: 600px;
            top: -300px; left: 0;
        }

        /* Connection Status */
        #connection-status {
            position: fixed;
            top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        #connection-status.connected { border-left: 3px solid #4fa; }
        #connection-status.connecting { border-left: 3px solid #fa0; }
        #connection-status.error { border-left: 3px solid #f44; }

        /* v1.03: FPS Counter */
        #fps-counter {
            position: fixed;
            top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 12px;
            color: #4fa;
            font-family: 'Courier New', monospace;
            border-left: 3px solid #4fa;
            display: none;
        }

        #fps-counter.visible { display: block; }
        #fps-counter.warning { color: #fa0; border-left-color: #fa0; }
        #fps-counter.critical { color: #f44; border-left-color: #f44; }

        /* v1.03: Mobile Touch Controls */
        #touch-controls {
            position: fixed;
            bottom: 0; left: 0;
            width: 100%; height: 200px;
            pointer-events: none;
            z-index: 150;
            display: none;
        }

        #touch-controls.visible { display: block; }

        .virtual-joystick {
            position: absolute;
            width: 120px; height: 120px;
            background: radial-gradient(circle, rgba(80, 150, 255, 0.3) 0%, transparent 70%);
            border: 2px solid rgba(80, 150, 255, 0.5);
            border-radius: 50%;
            pointer-events: auto;
        }

        #move-joystick {
            bottom: 30px; left: 30px;
        }

        .joystick-stick {
            position: absolute;
            width: 50px; height: 50px;
            background: rgba(100, 180, 255, 0.7);
            border: 2px solid rgba(150, 200, 255, 0.9);
            border-radius: 50%;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        .touch-button {
            position: absolute;
            width: 70px; height: 70px;
            background: rgba(80, 150, 255, 0.3);
            border: 2px solid rgba(80, 150, 255, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            pointer-events: auto;
            user-select: none;
        }

        .touch-button:active {
            background: rgba(100, 180, 255, 0.6);
            transform: scale(0.95);
        }

        #shoot-button { bottom: 30px; right: 30px; }
        #jump-button { bottom: 120px; right: 30px; }
        #reload-button { bottom: 30px; right: 120px; }

        /* v1.03: Responsive adjustments for mobile */
        @media (max-width: 768px) {
            .menu-title { font-size: 48px; }
            .menu-subtitle { font-size: 18px; }
            .menu-section { min-width: 320px; padding: 20px; }
            #shield-container { width: 90%; }
            #weapon-display { bottom: 220px; }
            #minimap { width: 140px; height: 140px; bottom: 230px; }
            #instructions { display: none; }
        }

        @media (max-width: 480px) {
            .menu-title { font-size: 36px; letter-spacing: 4px; }
            .menu-subtitle { font-size: 16px; }
            #ammo-display { font-size: 36px; }
            #score-display .value { font-size: 24px; }
        }

        /* Join Dialog */
        #join-dialog {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.98);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 30px;
            z-index: 1002;
            display: none;
        }

        #join-dialog.visible { display: block; }

        /* v1.02: Toast notification system for feedback */
        #toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            pointer-events: none;
        }

        .toast {
            background: rgba(10, 20, 40, 0.95);
            border: 2px solid #4af;
            border-radius: 4px;
            padding: 12px 24px;
            margin: 8px 0;
            color: #fff;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            animation: toastSlideIn 0.3s ease-out;
            min-width: 250px;
            text-align: center;
        }

        .toast.success { border-color: #4fa; }
        .toast.error { border-color: #f44; }
        .toast.warning { border-color: #fa0; }
        .toast.info { border-color: #4af; }

        @keyframes toastSlideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* v1.02: Loading indicator */
        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }

        #loading-screen.visible { display: flex; }

        .loading-spinner {
            border: 4px solid rgba(80, 180, 255, 0.3);
            border-top: 4px solid #5cf;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: #8bf;
            font-size: 18px;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <!-- v1.02: Toast notification container -->
    <div id="toast-container" role="status" aria-live="polite" aria-atomic="true"></div>

    <!-- v1.02: Loading screen -->
    <div id="loading-screen" role="alert" aria-busy="true">
        <div class="loading-spinner"></div>
        <div class="loading-text">LOADING...</div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls" role="toolbar" aria-label="Data management controls">
        <button onclick="exportData()" aria-label="Export game statistics to JSON file" tabindex="0">Export Stats</button>
        <button onclick="document.getElementById('importFile').click()" aria-label="Import game statistics from JSON file" tabindex="0">Import Stats</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)" aria-label="File input for importing statistics">
    </div>

    <!-- Menu Screen -->
    <div id="menu-screen" role="main" aria-label="Main menu">
        <h1 class="menu-title" role="heading" aria-level="1">LOCKOUT</h1>
        <p class="menu-subtitle">HALO 2 TRIBUTE</p>

        <div class="menu-section" role="form" aria-label="Spartan setup form">
            <div class="section-title" role="heading" aria-level="2">Spartan Setup</div>
            <input type="text" id="player-name" class="menu-input" placeholder="Enter Spartan name" maxlength="16"
                   aria-label="Enter your Spartan name" aria-required="true" tabindex="1">
            <select id="team-select" class="menu-input" aria-label="Select team or game mode" tabindex="2">
                <option value="none">Free For All</option>
                <option value="red">Red Team</option>
                <option value="blue">Blue Team</option>
            </select>
            <!-- v1.05: Bot difficulty selector -->
            <select id="bot-difficulty" class="menu-input" aria-label="Select bot difficulty" tabindex="3" onchange="BotAI.setDifficulty(this.value)">
                <option value="EASY">Bot Difficulty: Easy</option>
                <option value="MEDIUM" selected>Bot Difficulty: Medium</option>
                <option value="HARD">Bot Difficulty: Hard</option>
            </select>
            <button class="menu-button" onclick="createLobby()" aria-label="Host a new multiplayer game" tabindex="4">Host Game</button>
            <button class="menu-button secondary" onclick="showJoinDialog()" aria-label="Join an existing multiplayer game" tabindex="5">Join Game</button>
            <button class="menu-button secondary" onclick="startSinglePlayer()" aria-label="Start practice mode offline" tabindex="6">Practice (Offline)</button>
        </div>

        <div id="lobby-section" class="menu-section" style="display: none;" role="region" aria-label="Game lobby" aria-live="polite">
            <div class="section-title" role="heading" aria-level="2">Game Lobby</div>
            <p style="text-align: center; margin-bottom: 10px;">Share this code with friends:</p>
            <div id="lobby-code-display" role="status" aria-label="Lobby code"></div>
            <div id="lobby-players" role="list" aria-label="Connected players"></div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="menu-button start-game" onclick="startMultiplayerGame()" style="flex: 2;"
                        aria-label="Start multiplayer game with connected players" tabindex="0">START GAME</button>
                <button class="menu-button secondary" onclick="cancelLobby()" style="flex: 1;"
                        aria-label="Cancel lobby and return to main menu" tabindex="0">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Join Dialog -->
    <div id="join-dialog" role="dialog" aria-labelledby="join-dialog-title" aria-modal="true">
        <div class="section-title" id="join-dialog-title" role="heading" aria-level="2">Join Game</div>
        <input type="text" id="join-code" class="menu-input" placeholder="Enter lobby code" maxlength="6"
               style="text-transform: uppercase;" aria-label="Enter 6-character lobby code" aria-required="true" tabindex="0">
        <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button class="menu-button" onclick="joinLobby()" aria-label="Join game with entered code" tabindex="0">Join</button>
            <button class="menu-button secondary" onclick="hideJoinDialog()" aria-label="Cancel and close dialog" tabindex="0">Cancel</button>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container"></div>

    <!-- HUD -->
    <div id="hud" role="region" aria-label="Heads-up display">
        <!-- Shield Flash -->
        <div id="shield-flash" aria-hidden="true"></div>

        <!-- Shield/Health -->
        <div id="shield-container" role="group" aria-label="Shield and health status">
            <div id="shield-bar" role="progressbar" aria-label="Shield level" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
                <div id="shield-fill" style="width: 100%;"></div>
                <div id="shield-segments" aria-hidden="true">
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                </div>
            </div>
            <div id="health-bar" role="progressbar" aria-label="Health level" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
                <div id="health-fill" style="width: 100%;"></div>
            </div>
        </div>

        <!-- Timer -->
        <div id="match-timer" role="timer" aria-label="Match time remaining">10:00</div>

        <!-- Score -->
        <div id="score-display" role="status" aria-label="Player score">
            <div class="label">Score</div>
            <div class="value" id="player-score" aria-live="polite">0</div>
        </div>

        <!-- Crosshair -->
        <div id="crosshair" aria-hidden="true">
            <div class="crosshair-br">
                <div class="dot"></div>
                <div class="line top"></div>
                <div class="line bottom"></div>
                <div class="line left"></div>
                <div class="line right"></div>
            </div>
        </div>

        <!-- Hit Marker -->
        <div id="hit-marker" role="status" aria-label="Hit confirmation" aria-live="assertive" aria-atomic="true">
            <div class="hit-marker-line"></div>
            <div class="hit-marker-line"></div>
            <div class="hit-marker-line"></div>
            <div class="hit-marker-line"></div>
        </div>

        <!-- Weapon Display -->
        <div id="weapon-display" role="status" aria-label="Current weapon and ammunition">
            <div id="weapon-name" aria-label="Weapon name">BR55 Battle Rifle</div>
            <div id="ammo-display" aria-label="Ammunition count">
                <span id="current-ammo" aria-label="Current magazine">36</span>
                <span class="reserve">/ <span id="reserve-ammo" aria-label="Reserve ammunition">108</span></span>
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimap" role="img" aria-label="Minimap showing player positions and map layout">
            <canvas id="minimap-canvas" width="176" height="176"></canvas>
        </div>

        <!-- Kill Feed -->
        <div id="kill-feed" role="log" aria-label="Kill feed" aria-live="polite" aria-atomic="false"></div>

        <!-- Weapon Pickup -->
        <div id="weapon-pickup" role="status" aria-live="polite">
            <span class="key" aria-hidden="true">E</span> Pick up <span id="pickup-weapon-name">Sniper Rifle</span>
        </div>

        <!-- Instructions -->
        <div id="instructions" role="note" aria-label="Game controls">
            WASD: Move | Mouse: Aim | LMB: Shoot | R: Reload | Space: Jump | Shift/Ctrl: Crouch | Tab: Scoreboard | <strong>H: Help</strong> | <strong>P: Settings</strong>
        </div>
    </div>

    <!-- Scope Overlay -->
    <div id="scope-overlay" aria-hidden="true">
        <div class="scope-crosshair">
            <div class="scope-line h"></div>
            <div class="scope-line v"></div>
        </div>
    </div>

    <!-- Scoreboard -->
    <div id="scoreboard" role="dialog" aria-labelledby="scoreboard-title" aria-modal="false">
        <h2 id="scoreboard-title">SCOREBOARD</h2>
        <div class="scoreboard-header" role="row">
            <span role="columnheader">Player</span>
            <span role="columnheader">Kills</span>
            <span role="columnheader">Deaths</span>
            <span role="columnheader">Score</span>
        </div>
        <div id="scoreboard-rows" role="table" aria-label="Player scores"></div>
    </div>

    <!-- Respawn Screen -->
    <div id="respawn-screen" role="alert" aria-live="assertive">
        <h1>YOU DIED</h1>
        <div id="killed-by" role="status"></div>
        <div id="respawn-timer" role="timer" aria-label="Respawn countdown">5</div>
    </div>

    <!-- Connection Status -->
    <div id="connection-status" role="status" aria-label="Network connection status">
        <span id="peer-count" aria-label="Connected players">0</span> players | <span id="ping" aria-label="Network latency">--</span>ms
    </div>

    <!-- v1.03: FPS Counter -->
    <div id="fps-counter" class="visible" role="status" aria-label="Frames per second counter">
        FPS: <span id="fps-value">60</span>
    </div>

    <!-- v1.03: Mobile Touch Controls -->
    <div id="touch-controls" role="group" aria-label="Touch controls for mobile">
        <div id="move-joystick" class="virtual-joystick" aria-label="Movement joystick">
            <div class="joystick-stick"></div>
        </div>
        <button id="shoot-button" class="touch-button" aria-label="Shoot">FIRE</button>
        <button id="jump-button" class="touch-button" aria-label="Jump">JUMP</button>
        <button id="reload-button" class="touch-button" aria-label="Reload">R</button>
    </div>

    <!-- v1.06: Help Overlay - Comprehensive control documentation -->
    <div id="help-overlay" role="dialog" aria-labelledby="help-title" aria-modal="true">
        <div class="help-container">
            <h2 id="help-title" class="help-title">CONTROLS & HELP</h2>
            <p class="help-subtitle">Halo 2 Lockout - Multiplayer FPS</p>

            <div class="help-section">
                <h3 class="help-section-title">Movement</h3>
                <div class="help-grid">
                    <div class="help-key">W A S D</div>
                    <div class="help-description">Move forward/left/back/right</div>
                    <div class="help-key">SPACE</div>
                    <div class="help-description">Jump (hold CTRL for higher crouch jump)</div>
                    <div class="help-key">CTRL</div>
                    <div class="help-description">Crouch (reduces movement speed, enables crouch jump)</div>
                    <div class="help-key">SHIFT</div>
                    <div class="help-description">Sprint (faster movement)</div>
                    <div class="help-key">MOUSE</div>
                    <div class="help-description">Look around / Aim</div>
                </div>
            </div>

            <div class="help-section">
                <h3 class="help-section-title">Combat</h3>
                <div class="help-grid">
                    <div class="help-key">LEFT CLICK</div>
                    <div class="help-description">Fire weapon</div>
                    <div class="help-key">RIGHT CLICK</div>
                    <div class="help-description">Zoom / Scope (if weapon has scope)</div>
                    <div class="help-key">R</div>
                    <div class="help-description">Reload weapon</div>
                    <div class="help-key">1 - 6</div>
                    <div class="help-description">Switch weapons (if available)</div>
                    <div class="help-key">E</div>
                    <div class="help-description">Pick up nearby weapon</div>
                </div>
            </div>

            <div class="help-section">
                <h3 class="help-section-title">Interface</h3>
                <div class="help-grid">
                    <div class="help-key">TAB</div>
                    <div class="help-description">Show/hide scoreboard</div>
                    <div class="help-key">H</div>
                    <div class="help-description">Toggle this help screen</div>
                    <div class="help-key">P</div>
                    <div class="help-description">Open settings menu (sensitivity, volume, graphics)</div>
                    <div class="help-key">ESC</div>
                    <div class="help-description">Exit pointer lock / Return to menu</div>
                </div>
            </div>

            <div class="help-section">
                <h3 class="help-section-title">Game Tips</h3>
                <div class="help-grid">
                    <div class="help-key">Shields</div>
                    <div class="help-description">Regenerate after 4.5s without damage - take cover!</div>
                    <div class="help-key">Battle Rifle</div>
                    <div class="help-description">4-shot kill (3 body bursts + 1 headshot)</div>
                    <div class="help-key">Sniper</div>
                    <div class="help-description">1-shot headshot kill, 2-shot body kill</div>
                    <div class="help-key">Crouch Jump</div>
                    <div class="help-description">Jump 25% higher by holding CTRL while jumping</div>
                    <div class="help-key">High Ground</div>
                    <div class="help-description">Control top mid and BR tower for advantage</div>
                    <div class="help-key">Power Weapons</div>
                    <div class="help-description">Sniper and Rocket Launcher spawn at fixed locations</div>
                </div>
            </div>

            <button class="help-close" onclick="toggleHelp()">CLOSE (Press H or ESC)</button>
        </div>
    </div>

    <!-- v1.07: Settings Menu -->
    <div id="settings-overlay" role="dialog" aria-labelledby="settings-title" aria-modal="true">
        <div class="settings-container">
            <h2 id="settings-title" class="settings-title">SETTINGS</h2>

            <div class="settings-group">
                <label class="settings-label">
                    Mouse Sensitivity <span class="settings-value" id="sens-value">2.5</span>
                </label>
                <input type="range" class="settings-slider" id="sensitivity-slider"
                       min="0.5" max="5" step="0.1" value="2.5"
                       oninput="updateSensitivity(this.value)"
                       aria-label="Adjust mouse sensitivity">
            </div>

            <div class="settings-group">
                <label class="settings-label">
                    Master Volume <span class="settings-value" id="volume-value">70%</span>
                </label>
                <input type="range" class="settings-slider" id="volume-slider"
                       min="0" max="100" step="5" value="70"
                       oninput="updateVolume(this.value)"
                       aria-label="Adjust master volume">
            </div>

            <div class="settings-group">
                <label class="settings-label">Graphics Quality</label>
                <select class="settings-select" id="graphics-quality"
                        onchange="updateGraphicsQuality(this.value)"
                        aria-label="Select graphics quality preset">
                    <option value="LOW">Low (Best Performance)</option>
                    <option value="MEDIUM" selected>Medium (Balanced)</option>
                    <option value="HIGH">High (Best Quality)</option>
                </select>
            </div>

            <div class="settings-group">
                <div class="settings-checkbox">
                    <input type="checkbox" id="show-fps" checked
                           onchange="toggleFPSCounter(this.checked)"
                           aria-label="Toggle FPS counter display">
                    <label for="show-fps" class="settings-label" style="margin: 0;">Show FPS Counter</label>
                </div>
            </div>

            <div class="settings-group">
                <div class="settings-checkbox">
                    <input type="checkbox" id="show-minimap" checked
                           onchange="toggleMinimap(this.checked)"
                           aria-label="Toggle minimap display">
                    <label for="show-minimap" class="settings-label" style="margin: 0;">Show Minimap</label>
                </div>
            </div>

            <button class="help-close" onclick="toggleSettings()">CLOSE (Press P or ESC)</button>
        </div>
    </div>

    <!-- v1.07: Match End Screen -->
    <div id="match-end-screen" role="dialog" aria-labelledby="match-end-title" aria-modal="true">
        <div class="match-end-container">
            <h1 id="match-end-title" class="match-end-title">MATCH COMPLETE</h1>
            <p class="match-end-subtitle" id="match-winner">Red Team Wins!</p>

            <div class="mvp-section">
                <div class="mvp-label">Match MVP</div>
                <div class="mvp-name" id="mvp-player">Spartan117</div>
            </div>

            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Your Kills</div>
                    <div class="stat-value" id="end-kills">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Your Deaths</div>
                    <div class="stat-value" id="end-deaths">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">K/D Ratio</div>
                    <div class="stat-value" id="end-kd">0.00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Match Time</div>
                    <div class="stat-value" id="end-time">10:00</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="end-accuracy">0%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Headshots</div>
                    <div class="stat-value" id="end-headshots">0</div>
                </div>
            </div>

            <div class="match-end-buttons">
                <button onclick="returnToMenu()">MAIN MENU</button>
                <button onclick="restartMatch()">PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <!-- v1.07: Killstreak Announcement -->
    <div id="killstreak-announcement" role="status" aria-live="assertive" aria-atomic="true"></div>

    <!-- PeerJS for WebRTC signaling -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============================================================
        // HALO 2 LOCKOUT - MULTIPLAYER FPS
        // A tribute to Bungie's iconic arena shooter
        // ============================================================
        // v1.07 - Advanced Features and Game Polish:
        // - Settings Menu: In-game settings panel with sensitivity, volume, graphics presets (P key)
        // - Match End Screen: Comprehensive match summary with MVP, stats, K/D, accuracy
        // - Killstreak System: Visual/audio announcements (Double Kill, Triple, Killing Spree, etc.)
        // - Graphics Quality: Three quality presets (LOW/MED/HIGH) for performance tuning
        // - User Customization: Runtime configuration for all game settings
        // - Quality of Life: Toggle FPS counter, minimap visibility, improved UX
        //
        // v1.06 - Documentation, Edge Cases, and Final Polish:
        // - Documentation: Comprehensive JSDoc for all major functions and classes
        // - Help system: Inline help overlay (Press H) with full control documentation
        // - Code quality: Extensive inline comments explaining complex game logic
        // - Production mode: Conditional console logging via DEV_MODE flag
        // - Error handling: Enhanced try-catch boundaries with graceful degradation
        // - Maintainability: Improved code documentation for future development
        //
        // v1.05 - Network Quality, Bot AI, and Critical Bug Fixes:
        // - Network: Connection quality monitoring, ping/RTT tracking, adaptive updates
        // - Network: Visual connection indicator, lag compensation groundwork
        // - Bot AI: Null safety checks, difficulty system (Easy/Medium/Hard), AI scaling
        // - Bug fixes: Fixed ParticlePool.get()  acquire() critical error
        // - Polish: Connection status visibility, auto-reconnection, error handling
        // - UX: Visual network feedback, bot difficulty selector, connection timeouts
        //
        // v1.04 - Audio Polish, Visual Effects, and Game Feel:
        // - Camera shake: Dynamic shake for weapon fire, damage, and explosions
        // - Particle system: Muzzle flashes, bullet impacts, and explosion effects
        // - Ambient audio: Atmospheric wind sounds for immersive mountain environment
        // - Audio polish: Varied weapon shake intensity, ambient volume modulation
        // - Visual polish: Impact sparks, environmental hit detection, smooth transitions
        // - Game feel: Responsive feedback, screen shake decay, particle pooling
        //
        // v1.03 - Performance, Mobile Support, and Code Quality:
        // - Performance: Object pooling, delta time smoothing, FPS monitoring
        // - Mobile support: Touch event handlers, virtual joystick, responsive controls
        // - Code quality: Named constants, JSDoc documentation, refactored code
        // - Optimization: Visibility-based rendering, improved memory management
        //
        // v1.02 - Accessibility, Error Handling, and UX Improvements:
        // - Accessibility: Full ARIA labels, keyboard nav, screen reader support
        // - Error handling: Try-catch blocks, validation, user-friendly messages
        // - Feedback systems: Toast notifications, loading indicators, visual feedback
        // - Data versioning: Migration system for backwards compatibility
        // - Enhanced validation: Input checking, better error messages
        //
        // v1.01 - Authentic Halo 2 Improvements:
        // - Weapon balance: BR 4-shot kill, Sniper 1-shot headshot/2-shot body
        // - Movement physics: Floaty jumps, crouch jumping, no sprint
        // - Visual polish: Forerunner aesthetic, snowy mountains, better lighting
        // - Performance: DOM caching, squared distance checks, timer cleanup
        // - Shield system: Authentic regen delay and rate
        // ============================================================

        const APP_NAME = 'halo-lockout-fps';
        const APP_VERSION = '1.07'; // v1.07: Advanced Features and Game Polish

        // v1.06: Development mode flag - Set to false for production (disables console logs)
        const DEV_MODE = false;

        /**
         * v1.06: Conditional logging wrapper - Only logs in development mode
         * @param {...any} args - Arguments to log
         */
        const devLog = (...args) => DEV_MODE && console.log(...args);
        const devError = (...args) => DEV_MODE && console.error(...args);
        const devWarn = (...args) => DEV_MODE && console.warn(...args);

        // ============================================================
        // v1.03: GAME CONSTANTS - Extracted magic numbers for maintainability
        // v1.06: Fully documented with JSDoc comments
        // ============================================================
        /**
         * Centralized game configuration constants for easy tuning and maintenance.
         * All timing values in milliseconds, distances in world units, physics in m/s.
         * @constant {Object} GAME_CONSTANTS
         * @property {Object} Performance - Network and rendering performance settings
         * @property {Object} Match - Match duration and scoring rules
         * @property {Object} Shield - Halo-style shield regeneration system
         * @property {Object} Movement - Player movement physics (floaty Halo 2 style)
         * @property {Object} UI - User interface timing and visual feedback
         * @property {Object} Pooling - Object pool sizes for memory management
         * @property {Object} Camera - Camera shake and visual effects
         * @property {Object} Network - Network quality monitoring and reconnection
         * @property {Object} Bot - AI difficulty presets (Easy/Medium/Hard)
         */
        const GAME_CONSTANTS = {
            // Performance - Network update rates and frame smoothing
            NETWORK_UPDATE_INTERVAL: 50,      // ms between network position updates (20Hz tick rate)
            FPS_UPDATE_INTERVAL: 500,         // ms between FPS counter updates (UI refresh rate)
            DELTA_SMOOTHING_FACTOR: 0.1,      // Lerp factor for delta time smoothing (prevents stutter)
            MAX_DELTA_TIME: 0.1,              // Cap delta time to prevent physics issues on tab focus

            // Match settings - Scoring and timing
            MATCH_DURATION: 600,              // seconds (10 minutes) - standard Halo 2 match length
            KILL_LIMIT: 25,                   // kills to win - classic free-for-all target
            RESPAWN_DELAY: 5,                 // seconds - delay before respawn (dramatic pause)

            // Shield regeneration - Authentic Halo 2 shield behavior
            SHIELD_REGEN_DELAY: 4.5,          // seconds before shield starts regenerating (hide and recover)
            SHIELD_REGEN_RATE: 35,            // points per second (takes ~3s to fully recharge)
            SHIELD_MAX: 100,                  // maximum shield points (absorbs damage first)
            HEALTH_MAX: 100,                  // maximum health points (behind shields)

            // Movement physics - Floaty Halo 2 style movement
            MOVE_SPEED: 6.5,                  // base movement speed (world units/sec)
            JUMP_FORCE: 7.5,                  // base jump velocity (floaty jump arc)
            GRAVITY: 12,                      // gravity acceleration (slower fall = floaty feel)
            CROUCH_SPEED_MULTIPLIER: 0.5,     // movement speed when crouching (50% slower)
            CROUCH_JUMP_BONUS: 1.25,          // jump height bonus when crouch jumping (25% higher)

            // UI - Visual feedback timing
            KILL_FEED_DURATION: 5000,         // ms to show kill feed entries (5 seconds visibility)
            TOAST_DEFAULT_DURATION: 3000,     // ms to show toast notifications (3 seconds default)
            HIT_MARKER_DURATION: 100,         // ms to show hit marker (quick flash)

            // Object pooling - Pre-allocated pool sizes for performance
            POOL_SIZE_PARTICLES: 200,         // max particles in pool (impacts, explosions, muzzle flash)
            POOL_SIZE_BULLETS: 100,           // max bullet tracers in pool (visual projectiles)
            POOL_SIZE_EFFECTS: 50,            // max visual effects in pool (misc VFX)

            // v1.04: Camera shake and visual effects
            CAMERA_SHAKE_DECAY: 0.92,         // shake decay rate per frame
            CAMERA_SHAKE_WEAPON: 0.5,         // shake intensity for weapon fire
            CAMERA_SHAKE_HIT: 2.0,            // shake intensity when taking damage
            CAMERA_SHAKE_EXPLOSION: 5.0,      // shake intensity for explosions
            PARTICLE_LIFETIME: 1.0,           // seconds particles live
            AMBIENT_AUDIO_ENABLED: true,      // enable ambient wind/mountain sounds

            // v1.05: Network quality monitoring
            NETWORK_PING_INTERVAL: 2000,      // ms between ping measurements
            NETWORK_TIMEOUT: 10000,           // ms before connection timeout
            NETWORK_RECONNECT_ATTEMPTS: 3,    // max reconnection attempts
            NETWORK_RECONNECT_DELAY: 2000,    // ms between reconnect attempts
            PING_GOOD_THRESHOLD: 80,          // ms - green indicator
            PING_FAIR_THRESHOLD: 150,         // ms - yellow indicator
            PING_POOR_THRESHOLD: 250,         // ms - red indicator

            // v1.05: Bot AI difficulty settings
            BOT_DIFFICULTY: {
                EASY: {
                    accuracy: 0.4,            // 40% hit chance
                    reactionTime: 0.8,        // slower reactions
                    moveSpeed: 4,             // slower movement
                    detectionRange: 35,       // shorter sight
                    aimDrift: 0.15            // more aim wobble
                },
                MEDIUM: {
                    accuracy: 0.7,            // 70% hit chance
                    reactionTime: 0.4,        // medium reactions
                    moveSpeed: 5.5,           // normal movement
                    detectionRange: 50,       // normal sight
                    aimDrift: 0.08            // some aim wobble
                },
                HARD: {
                    accuracy: 0.9,            // 90% hit chance
                    reactionTime: 0.15,       // fast reactions
                    moveSpeed: 6.5,           // fast movement
                    detectionRange: 65,       // enhanced sight
                    aimDrift: 0.02            // minimal aim wobble
                }
            }
        };

        // ============================================================
        // v1.03: OBJECT POOL - Reduces garbage collection and improves performance
        // ============================================================

        /**
         * Generic object pool for reusing objects and reducing GC pressure
         * @class ObjectPool
         */
        class ObjectPool {
            /**
             * @param {Function} createFn - Function to create new objects
             * @param {Function} resetFn - Function to reset objects when returning to pool
             * @param {number} initialSize - Initial pool size
             */
            constructor(createFn, resetFn, initialSize = 10) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];

                // Pre-allocate initial objects
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(createFn());
                }
            }

            /**
             * Get an object from the pool
             * @returns {Object} - Pooled object
             */
            acquire() {
                let obj = this.pool.pop();
                if (!obj) {
                    obj = this.createFn();
                }
                this.active.push(obj);
                return obj;
            }

            /**
             * Return an object to the pool
             * @param {Object} obj - Object to return
             */
            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                }
                this.resetFn(obj);
                this.pool.push(obj);
            }

            /**
             * Release all active objects
             */
            releaseAll() {
                while (this.active.length > 0) {
                    this.release(this.active[0]);
                }
            }

            /**
             * Get count of active objects
             * @returns {number}
             */
            getActiveCount() {
                return this.active.length;
            }
        }

        // ============================================================
        // v1.03: PERFORMANCE MONITOR - FPS tracking and performance metrics
        // ============================================================

        /**
         * Performance monitoring system for tracking FPS and frame times
         * @class PerformanceMonitor
         */
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.frameTime = 0;
                this.frameTimes = [];
                this.lastTime = performance.now();
                this.lastFPSUpdate = 0;
                this.smoothedDelta = 0.016; // Start at 60fps equivalent
            }

            /**
             * Update performance metrics
             * @param {number} delta - Current frame delta time
             * @returns {number} - Smoothed delta time
             */
            update(delta) {
                const now = performance.now();
                this.frameTime = now - this.lastTime;
                this.lastTime = now;

                // Cap delta time to prevent physics explosions
                delta = Math.min(delta, GAME_CONSTANTS.MAX_DELTA_TIME);

                // Smooth delta time using exponential moving average
                this.smoothedDelta = THREE.MathUtils.lerp(
                    this.smoothedDelta,
                    delta,
                    GAME_CONSTANTS.DELTA_SMOOTHING_FACTOR
                );

                // Update FPS counter every 500ms
                if (now - this.lastFPSUpdate > GAME_CONSTANTS.FPS_UPDATE_INTERVAL) {
                    this.fps = Math.round(1000 / this.frameTime);
                    this.lastFPSUpdate = now;
                }

                return this.smoothedDelta;
            }

            /**
             * Get current FPS
             * @returns {number}
             */
            getFPS() {
                return this.fps;
            }

            /**
             * Get average frame time in ms
             * @returns {number}
             */
            getFrameTime() {
                return this.frameTime;
            }
        }

        // v1.03: Initialize performance monitor
        const perfMonitor = new PerformanceMonitor();

        // ============================================================
        // v1.04: CAMERA SHAKE SYSTEM - Adds impactful visual feedback
        // ============================================================

        /**
         * Camera shake system for weapon fire, damage, and explosions
         * @class CameraShake
         */
        class CameraShake {
            constructor() {
                this.intensity = 0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.offsetZ = 0;
            }

            /**
             * Trigger camera shake with specified intensity
             * @param {number} intensity - Shake strength
             */
            shake(intensity) {
                this.intensity = Math.max(this.intensity, intensity);
            }

            /**
             * Update shake values each frame
             */
            update() {
                if (this.intensity > 0.01) {
                    // Generate random offsets based on intensity
                    this.offsetX = (Math.random() - 0.5) * this.intensity * 0.02;
                    this.offsetY = (Math.random() - 0.5) * this.intensity * 0.02;
                    this.offsetZ = (Math.random() - 0.5) * this.intensity * 0.01;

                    // Decay intensity
                    this.intensity *= GAME_CONSTANTS.CAMERA_SHAKE_DECAY;
                } else {
                    this.intensity = 0;
                    this.offsetX = 0;
                    this.offsetY = 0;
                    this.offsetZ = 0;
                }
            }

            /**
             * Apply shake to camera
             * @param {THREE.Camera} camera - Three.js camera object
             */
            apply(camera) {
                camera.position.x += this.offsetX;
                camera.position.y += this.offsetY;
                camera.position.z += this.offsetZ;
            }

            /**
             * Reset shake immediately
             */
            reset() {
                this.intensity = 0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.offsetZ = 0;
            }
        }

        // v1.04: Initialize camera shake system
        const cameraShake = new CameraShake();

        // ============================================================
        // v1.04: PARTICLE SYSTEM - Visual effects for impacts, explosions, and atmosphere
        // ============================================================

        /**
         * Particle system for muzzle flashes, bullet impacts, and explosions
         * @class ParticleSystem
         */
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.particlePool = new ObjectPool(() => this.createParticle(), GAME_CONSTANTS.POOL_SIZE_PARTICLES);
            }

            /**
             * Create a new particle mesh
             * @returns {THREE.Mesh}
             */
            createParticle() {
                const geometry = new THREE.SphereGeometry(0.05, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.visible = false;
                this.scene.add(particle);
                return particle;
            }

            /**
             * Spawn bullet impact particles
             * @param {THREE.Vector3} position - Impact location
             * @param {THREE.Vector3} normal - Surface normal
             */
            spawnImpact(position, normal) {
                const count = 8;
                for (let i = 0; i < count; i++) {
                    const particle = this.particlePool.acquire();
                    if (!particle) continue;

                    particle.position.copy(position);
                    particle.visible = true;
                    particle.material.opacity = 1.0;
                    particle.material.color.setHex(0xffcc66); // Orange spark

                    // Random velocity based on surface normal
                    const velocity = new THREE.Vector3(
                        normal.x + (Math.random() - 0.5) * 0.5,
                        normal.y + Math.random() * 0.5,
                        normal.z + (Math.random() - 0.5) * 0.5
                    ).multiplyScalar(2 + Math.random() * 3);

                    this.particles.push({
                        mesh: particle,
                        velocity: velocity,
                        lifetime: GAME_CONSTANTS.PARTICLE_LIFETIME,
                        age: 0
                    });
                }
            }

            /**
             * Spawn muzzle flash particles
             * @param {THREE.Vector3} position - Weapon muzzle position
             * @param {THREE.Vector3} direction - Fire direction
             */
            spawnMuzzleFlash(position, direction) {
                const count = 4;
                for (let i = 0; i < count; i++) {
                    const particle = this.particlePool.acquire();
                    if (!particle) continue;

                    particle.position.copy(position);
                    particle.visible = true;
                    particle.material.opacity = 1.0;
                    particle.material.color.setHex(0xffff00); // Yellow flash

                    // Velocity in fire direction with spread
                    const velocity = direction.clone().multiplyScalar(5 + Math.random() * 5);
                    velocity.x += (Math.random() - 0.5) * 2;
                    velocity.y += (Math.random() - 0.5) * 2;
                    velocity.z += (Math.random() - 0.5) * 2;

                    this.particles.push({
                        mesh: particle,
                        velocity: velocity,
                        lifetime: 0.2, // Short-lived flash
                        age: 0
                    });
                }
            }

            /**
             * Spawn explosion particles
             * @param {THREE.Vector3} position - Explosion center
             */
            spawnExplosion(position) {
                const count = 20;
                for (let i = 0; i < count; i++) {
                    const particle = this.particlePool.acquire();
                    if (!particle) continue;

                    particle.position.copy(position);
                    particle.visible = true;
                    particle.material.opacity = 1.0;
                    particle.material.color.setHex(0xff4400); // Bright orange

                    // Spherical explosion pattern
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const speed = 5 + Math.random() * 10;
                    const velocity = new THREE.Vector3(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.sin(phi) * Math.sin(theta) * speed,
                        Math.cos(phi) * speed
                    );

                    this.particles.push({
                        mesh: particle,
                        velocity: velocity,
                        lifetime: GAME_CONSTANTS.PARTICLE_LIFETIME * 1.5,
                        age: 0
                    });
                }
            }

            /**
             * Update all active particles
             * @param {number} delta - Frame time in seconds
             */
            update(delta) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.age += delta;

                    // Apply velocity and gravity
                    p.mesh.position.x += p.velocity.x * delta;
                    p.mesh.position.y += p.velocity.y * delta;
                    p.mesh.position.z += p.velocity.z * delta;
                    p.velocity.y -= GAME_CONSTANTS.GRAVITY * delta;

                    // Fade out based on age
                    const lifePercent = p.age / p.lifetime;
                    p.mesh.material.opacity = 1.0 - lifePercent;

                    // Remove dead particles
                    if (p.age >= p.lifetime) {
                        p.mesh.visible = false;
                        this.particlePool.release(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }

            /**
             * Clear all particles
             */
            clear() {
                this.particles.forEach(p => {
                    p.mesh.visible = false;
                    this.particlePool.release(p.mesh);
                });
                this.particles = [];
            }
        }

        // Particle system will be initialized with scene later
        let particleSystem = null;

        // v1.02: Enhanced data loading with error handling
        let gameData;
        try {
            gameData = JSON.parse(localStorage.getItem(APP_NAME) || JSON.stringify({
                version: APP_VERSION,
                stats: { kills: 0, deaths: 0, gamesPlayed: 0, wins: 0 },
                settings: { sensitivity: 2.5, volume: 0.7, name: 'Spartan' },
                achievements: []
            }));
            // Data migration for older versions
            if (!gameData.version) {
                gameData.version = APP_VERSION;
            }
        } catch (err) {
            devError('Failed to load game data:', err);
            showToast('Failed to load saved data, using defaults', 'error');
            gameData = {
                version: APP_VERSION,
                stats: { kills: 0, deaths: 0, gamesPlayed: 0, wins: 0 },
                settings: { sensitivity: 2.5, volume: 0.7, name: 'Spartan' },
                achievements: []
            };
        }

        /**
         * v1.02: Toast notification system for user feedback
         * v1.06: Added JSDoc documentation
         * @param {string} message - Message to display in toast
         * @param {string} type - Toast type: 'info', 'success', 'warning', 'error'
         * @param {number} duration - Duration in ms (default 3000ms)
         */
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toast.setAttribute('role', 'status');
            toast.setAttribute('aria-live', 'polite');

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'toastSlideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        /**
         * v1.02: Loading screen helper
         * v1.06: Added JSDoc documentation
         * @param {boolean} show - Whether to show or hide loading screen
         * @param {string} text - Loading text to display
         */
        function showLoading(show = true, text = 'LOADING...') {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingText = loadingScreen.querySelector('.loading-text');
            if (show) {
                loadingText.textContent = text;
                loadingScreen.classList.add('visible');
                loadingScreen.setAttribute('aria-busy', 'true');
            } else {
                loadingScreen.classList.remove('visible');
                loadingScreen.setAttribute('aria-busy', 'false');
            }
        }

        // v1.02: Screen reader announcement helper
        function announceToScreenReader(message, priority = 'polite') {
            const announcement = document.createElement('div');
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', priority); // 'polite' or 'assertive'
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.style.position = 'absolute';
            announcement.style.left = '-10000px';
            announcement.style.width = '1px';
            announcement.style.height = '1px';
            announcement.style.overflow = 'hidden';
            announcement.textContent = message;

            document.body.appendChild(announcement);

            // Remove after announcement is made
            setTimeout(() => announcement.remove(), 1000);
        }

        // v1.02: Enhanced save with error handling
        function saveData() {
            try {
                gameData.version = APP_VERSION;
                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                return true;
            } catch (err) {
                devError('Failed to save data:', err);
                if (err.name === 'QuotaExceededError') {
                    showToast('Storage quota exceeded. Cannot save data.', 'error');
                } else {
                    showToast('Failed to save data', 'error');
                }
                return false;
            }
        }

        // v1.02: Enhanced export with feedback
        function exportData() {
            try {
                const dataStr = JSON.stringify(gameData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
                showToast('Stats exported successfully!', 'success');
            } catch (err) {
                devError('Failed to export data:', err);
                showToast('Failed to export data', 'error');
            }
        }

        /**
         * v1.06: Toggle help overlay display
         * Shows/hides the comprehensive help screen with controls and tips
         */
        function toggleHelp() {
            const helpOverlay = document.getElementById('help-overlay');
            if (helpOverlay) {
                helpOverlay.classList.toggle('visible');
                announceToScreenReader(
                    helpOverlay.classList.contains('visible')
                        ? 'Help overlay opened. Press H or Escape to close.'
                        : 'Help overlay closed.'
                );
            }
        }

        /**
         * v1.07: Toggle settings overlay display
         * Shows/hides the settings menu for runtime configuration
         */
        function toggleSettings() {
            const settingsOverlay = document.getElementById('settings-overlay');
            if (settingsOverlay) {
                settingsOverlay.classList.toggle('visible');
                announceToScreenReader(
                    settingsOverlay.classList.contains('visible')
                        ? 'Settings menu opened. Press P or Escape to close.'
                        : 'Settings menu closed.'
                );
            }
        }

        /**
         * v1.07: Update mouse sensitivity from settings slider
         * @param {number} value - New sensitivity value (0.5-5.0)
         */
        function updateSensitivity(value) {
            const numValue = parseFloat(value);
            if (PlayerController) {
                PlayerController.mouseSensitivity = numValue;
            }
            document.getElementById('sens-value').textContent = numValue.toFixed(1);
            gameData.settings.sensitivity = numValue;
            saveData();
        }

        /**
         * v1.07: Update master volume from settings slider
         * @param {number} value - New volume value (0-100)
         */
        function updateVolume(value) {
            const numValue = parseInt(value);
            if (AudioSystem && AudioSystem.context) {
                AudioSystem.masterGain.gain.value = numValue / 100;
            }
            document.getElementById('volume-value').textContent = numValue + '%';
            gameData.settings.volume = numValue / 100;
            saveData();
        }

        /**
         * v1.07: Update graphics quality preset
         * @param {string} quality - Quality level: LOW, MEDIUM, HIGH
         */
        function updateGraphicsQuality(quality) {
            const settings = {
                LOW: { particles: 50, shadows: false, renderDist: 80 },
                MEDIUM: { particles: 100, shadows: false, renderDist: 120 },
                HIGH: { particles: 200, shadows: true, renderDist: 160 }
            };

            const preset = settings[quality];
            if (preset) {
                GAME_CONSTANTS.POOL_SIZE_PARTICLES = preset.particles;
                // Apply settings
                if (renderer && renderer.shadowMap) {
                    renderer.shadowMap.enabled = preset.shadows;
                }
                showToast(`Graphics: ${quality}`, 'info', 2000);
                gameData.settings.graphics = quality;
                saveData();
            }
        }

        /**
         * v1.07: Toggle FPS counter visibility
         * @param {boolean} show - Whether to show FPS counter
         */
        function toggleFPSCounter(show) {
            const fpsCounter = document.getElementById('fps-counter');
            if (fpsCounter) {
                fpsCounter.style.display = show ? 'block' : 'none';
                gameData.settings.showFPS = show;
                saveData();
            }
        }

        /**
         * v1.07: Toggle minimap visibility
         * @param {boolean} show - Whether to show minimap
         */
        function toggleMinimap(show) {
            const minimap = document.getElementById('minimap');
            if (minimap) {
                minimap.style.display = show ? 'block' : 'none';
                gameData.settings.showMinimap = show;
                saveData();
            }
        }

        /**
         * v1.07: Killstreak tracking and announcement system
         */
        const KillstreakSystem = {
            consecutiveKills: 0,
            lastKillTime: 0,
            killstreakTimeout: 4000, // 4s window for multikills

            killstreaks: {
                2: { name: 'DOUBLE KILL', color: '#ff8800' },
                3: { name: 'TRIPLE KILL', color: '#ff4400' },
                4: { name: 'OVERKILL', color: '#ff0000' },
                5: { name: 'KILLING SPREE', color: '#ff00ff' },
                10: { name: 'RUNNING RIOT', color: '#8800ff' },
                15: { name: 'RAMPAGE', color: '#ff0088' },
                20: { name: 'UNTOUCHABLE', color: '#00ffff' }
            },

            /**
             * Register a kill and check for killstreaks
             */
            registerKill() {
                const now = Date.now();

                // Reset if too much time passed
                if (now - this.lastKillTime > this.killstreakTimeout) {
                    this.consecutiveKills = 1;
                } else {
                    this.consecutiveKills++;
                }

                this.lastKillTime = now;

                // Check for killstreak announcement
                const streak = this.killstreaks[this.consecutiveKills];
                if (streak) {
                    this.announce(streak.name, streak.color);
                }

                return this.consecutiveKills;
            },

            /**
             * Display killstreak announcement
             * @param {string} text - Killstreak text
             * @param {string} color - Text color
             */
            announce(text, color) {
                const announcement = document.getElementById('killstreak-announcement');
                if (announcement) {
                    announcement.textContent = text;
                    announcement.style.color = color;
                    announcement.style.textShadow = `0 0 30px ${color}, 0 0 60px ${color}`;
                    announcement.classList.remove('active');

                    // Force reflow to restart animation
                    void announcement.offsetWidth;
                    announcement.classList.add('active');

                    // Play sound effect if available
                    if (AudioSystem && AudioSystem.playKillSound) {
                        AudioSystem.playKillSound();
                    }

                    // Screen reader announcement
                    announceToScreenReader(`Killstreak: ${text}`, 'assertive');

                    // Remove class after animation
                    setTimeout(() => {
                        announcement.classList.remove('active');
                    }, 1500);
                }
            },

            /**
             * Reset killstreak counter (on death)
             */
            reset() {
                this.consecutiveKills = 0;
                this.lastKillTime = 0;
            }
        };

        /**
         * v1.07: Show match end screen with comprehensive stats
         */
        function showMatchEndScreen() {
            const endScreen = document.getElementById('match-end-screen');
            if (!endScreen) return;

            // Calculate stats
            const localPlayer = GameState.localPlayer;
            const kills = localPlayer ? localPlayer.kills : 0;
            const deaths = localPlayer ? localPlayer.deaths : 0;
            const kd = deaths > 0 ? (kills / deaths).toFixed(2) : kills.toFixed(2);

            // Find MVP (player with most kills)
            let mvpPlayer = null;
            let maxKills = 0;
            GameState.players.forEach(player => {
                if (player.kills > maxKills) {
                    maxKills = player.kills;
                    mvpPlayer = player;
                }
            });

            // Update UI elements
            document.getElementById('end-kills').textContent = kills;
            document.getElementById('end-deaths').textContent = deaths;
            document.getElementById('end-kd').textContent = kd;

            // Calculate match time elapsed
            const timeElapsed = GAME_CONSTANTS.MATCH_DURATION - GameState.matchTime;
            const minutes = Math.floor(timeElapsed / 60);
            const seconds = Math.floor(timeElapsed % 60);
            document.getElementById('end-time').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Mock accuracy and headshots (would need tracking in full implementation)
            document.getElementById('end-accuracy').textContent = '0%';
            document.getElementById('end-headshots').textContent = '0';

            // MVP
            if (mvpPlayer) {
                document.getElementById('mvp-player').textContent = mvpPlayer.name || 'Unknown';
            }

            // Winner text
            const winnerText = GameState.isMultiplayer ?
                (mvpPlayer ? `${mvpPlayer.name} Wins!` : 'Match Complete') :
                (kills >= GAME_CONSTANTS.KILL_LIMIT ? 'Victory!' : 'Time\'s Up!');
            document.getElementById('match-winner').textContent = winnerText;

            // Show screen
            endScreen.classList.add('visible');
            announceToScreenReader('Match ended. ' + winnerText, 'assertive');
        }

        /**
         * v1.07: Return to main menu from match end screen
         */
        function returnToMenu() {
            const endScreen = document.getElementById('match-end-screen');
            if (endScreen) {
                endScreen.classList.remove('visible');
            }

            // Stop game
            if (GameState.isRunning) {
                GameState.isRunning = false;
                cleanupTimers();
            }

            // Show menu
            document.getElementById('menu-screen').classList.remove('hidden');
            document.getElementById('hud').style.display = 'none';

            // Disconnect if multiplayer
            if (GameState.isMultiplayer && GameState.peer) {
                GameState.connections.forEach(conn => conn.close());
                GameState.connections.clear();
                if (GameState.peer) GameState.peer.destroy();
            }

            showToast('Returned to main menu', 'info');
        }

        /**
         * v1.07: Restart match with same settings
         */
        function restartMatch() {
            const endScreen = document.getElementById('match-end-screen');
            if (endScreen) {
                endScreen.classList.remove('visible');
            }

            // Reset game state
            GameState.matchTime = GAME_CONSTANTS.MATCH_DURATION;
            GameState.players.forEach(player => {
                player.kills = 0;
                player.deaths = 0;
            });

            if (GameState.localPlayer) {
                GameState.localPlayer.kills = 0;
                GameState.localPlayer.deaths = 0;
            }

            // Reset killstreak
            KillstreakSystem.reset();

            // Restart if single player
            if (!GameState.isMultiplayer) {
                GameState.isRunning = true;
                showToast('Match restarted!', 'success');
            } else {
                showToast('Restarting multiplayer matches requires all players to agree', 'warning');
            }
        }

        /**
         * v1.02: Enhanced import with validation and feedback
         * v1.06: Added JSDoc documentation
         * @param {Event} event - File input change event
         */
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoading(true, 'IMPORTING...');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);

                    // v1.02: Validate imported data structure
                    if (!imported.stats || typeof imported.stats.kills !== 'number') {
                        throw new Error('Invalid data structure');
                    }

                    // v1.02: Version compatibility check
                    if (imported.version && imported.version !== APP_VERSION) {
                        showToast(`Importing data from version ${imported.version}`, 'warning');
                    }

                    gameData = imported;
                    gameData.version = APP_VERSION; // Update to current version

                    if (saveData()) {
                        showToast('Stats imported successfully!', 'success');
                    }
                } catch (err) {
                    devError('Import failed:', err);
                    showToast('Invalid file format or corrupted data', 'error');
                } finally {
                    showLoading(false);
                }
            };

            reader.onerror = () => {
                showToast('Failed to read file', 'error');
                showLoading(false);
            };

            reader.readAsText(file);
        }

        // ============================================================
        // GAME STATE
        // ============================================================

        const GameState = {
            // Core state
            isRunning: false,
            isPaused: false,
            isMultiplayer: false,

            // Networking
            peer: null,
            connections: new Map(),
            isHost: false,
            lobbyCode: '',

            // Local player
            localPlayer: null,

            // All players (including local)
            players: new Map(),

            // v1.03: Match state from GAME_CONSTANTS
            matchTime: GAME_CONSTANTS.MATCH_DURATION,
            killLimit: GAME_CONSTANTS.KILL_LIMIT,
            gameMode: 'slayer',

            // Weapons on map
            weaponPickups: [],

            // Spawn points
            spawnPoints: [],

            // v1.01: Timer registry for proper cleanup
            // v1.08: Changed killFeedTimeouts from Array to Set for O(1) operations
            timers: {
                respawnInterval: null,
                killFeedTimeouts: new Set()
            }
        };

        // ============================================================
        // THREE.JS SETUP
        // ============================================================

        let scene, camera, renderer;
        let clock = new THREE.Clock();

        // v1.01: Player controller with authentic Halo 2 movement physics
        const PlayerController = {
            // Position
            position: new THREE.Vector3(0, 5, 0),
            velocity: new THREE.Vector3(),

            // Rotation (Euler)
            rotationX: 0, // Pitch
            rotationY: 0, // Yaw

            // v1.03: Movement physics from GAME_CONSTANTS
            moveSpeed: GAME_CONSTANTS.MOVE_SPEED,
            sprintMultiplier: 1.0, // No sprint in Halo 2
            jumpForce: GAME_CONSTANTS.JUMP_FORCE,
            gravity: GAME_CONSTANTS.GRAVITY,

            // State
            isGrounded: false,
            isCrouching: false,
            isSprinting: false,
            isScoped: false,

            // v1.03: Combat values from GAME_CONSTANTS
            shield: GAME_CONSTANTS.SHIELD_MAX,
            health: GAME_CONSTANTS.HEALTH_MAX,
            maxShield: GAME_CONSTANTS.SHIELD_MAX,
            maxHealth: GAME_CONSTANTS.HEALTH_MAX,
            shieldRegenDelay: GAME_CONSTANTS.SHIELD_REGEN_DELAY,
            shieldRegenRate: GAME_CONSTANTS.SHIELD_REGEN_RATE,
            lastDamageTime: 0,
            isDead: false,

            // Weapons
            weapons: [],
            currentWeaponIndex: 0,

            // Input state
            keys: {},
            mouse: { x: 0, y: 0, buttons: {} }
        };

        // ============================================================
        // WEAPONS SYSTEM
        // ============================================================

        // ============================================================
        // MODEL BUILDER - Creates 3D models from JSON definitions
        // ============================================================

        const ModelBuilder = {
            // Build a 3D model from JSON bodyParts definition
            buildFromDefinition(definition, scale = 1) {
                const group = new THREE.Group();

                if (!definition.bodyParts) return group;

                definition.bodyParts.forEach(part => {
                    const mesh = this.createPart(part, scale);
                    if (mesh) {
                        group.add(mesh);
                    }
                });

                return group;
            },

            createPart(part, scale) {
                let geometry;
                const s = scale;

                switch (part.shape) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            (part.width || 0.1) * s,
                            (part.height || 0.1) * s,
                            (part.depth || 0.1) * s
                        );
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            (part.radiusTop || 0.05) * s,
                            (part.radiusBottom || 0.05) * s,
                            (part.height || 0.1) * s,
                            part.segments || 12
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(
                            (part.size || 0.05) * s,
                            part.segments || 12,
                            part.segments || 12
                        );
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(
                            (part.size || 0.05) * s,
                            (part.height || 0.1) * s,
                            part.segments || 12
                        );
                        break;
                    default:
                        return null;
                }

                // Parse color
                const color = typeof part.color === 'string' ?
                    parseInt(part.color.replace('#', '0x')) : part.color;
                const emissiveColor = part.emissive ?
                    (typeof part.emissive === 'string' ?
                        parseInt(part.emissive.replace('#', '0x')) : part.emissive) : 0x000000;

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: part.metalness !== undefined ? part.metalness : 0.5,
                    roughness: part.roughness !== undefined ? part.roughness : 0.5,
                    emissive: emissiveColor,
                    emissiveIntensity: part.emissiveIntensity || 0.5
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Position
                if (part.position) {
                    mesh.position.set(
                        part.position[0] * s,
                        part.position[1] * s,
                        part.position[2] * s
                    );
                }

                // Rotation (convert degrees to radians)
                if (part.rotation) {
                    mesh.rotation.set(
                        (part.rotation[0] || 0) * Math.PI / 180,
                        (part.rotation[1] || 0) * Math.PI / 180,
                        (part.rotation[2] || 0) * Math.PI / 180
                    );
                }

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = part.name;

                return mesh;
            }
        };

        // ============================================================
        // HALO WEAPON MODEL DEFINITIONS
        // ============================================================

        const WeaponModels = {
            BR55: {
                name: "BR55 Battle Rifle",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Stock
                    { name: "stock", shape: "box", width: 0.06, height: 0.08, depth: 0.25,
                      color: "#2a2a2a", position: [0, 0, -0.2], metalness: 0.3, roughness: 0.7 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.04, height: 0.1, depth: 0.06,
                      color: "#1a1a1a", position: [0, -0.06, 0], rotation: [15, 0, 0], metalness: 0.2, roughness: 0.8 },
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.08, height: 0.1, depth: 0.35,
                      color: "#3a3a3a", position: [0, 0.03, 0.05], metalness: 0.6, roughness: 0.4 },
                    // Magazine
                    { name: "magazine", shape: "box", width: 0.035, height: 0.12, depth: 0.08,
                      color: "#444444", position: [0, -0.06, 0.1], metalness: 0.5, roughness: 0.5 },
                    // Barrel shroud
                    { name: "barrelShroud", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.04, height: 0.25,
                      color: "#2a2a2a", position: [0, 0.03, 0.35], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.3 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.15,
                      color: "#1a1a1a", position: [0, 0.03, 0.52], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Scope mount
                    { name: "scopeMount", shape: "box", width: 0.04, height: 0.025, depth: 0.12,
                      color: "#333333", position: [0, 0.1, 0.05], metalness: 0.5, roughness: 0.5 },
                    // Scope body
                    { name: "scopeBody", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.025, height: 0.15,
                      color: "#222222", position: [0, 0.13, 0.05], rotation: [90, 0, 0], metalness: 0.4, roughness: 0.6 },
                    // Scope lens front
                    { name: "scopeLensFront", shape: "sphere", size: 0.02,
                      color: "#00aaff", position: [0, 0.13, 0.13], emissive: "#0066aa", metalness: 0.9, roughness: 0.1 },
                    // Scope lens back
                    { name: "scopeLensBack", shape: "sphere", size: 0.015,
                      color: "#ff4400", position: [0, 0.13, -0.02], emissive: "#ff2200", metalness: 0.9, roughness: 0.1 },
                    // Muzzle brake
                    { name: "muzzle", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.02, height: 0.04,
                      color: "#1a1a1a", position: [0, 0.03, 0.62], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Ammo counter
                    { name: "ammoCounter", shape: "box", width: 0.02, height: 0.015, depth: 0.03,
                      color: "#00ff00", position: [0.04, 0.06, 0.02], emissive: "#00aa00", metalness: 0.3, roughness: 0.5 }
                ]
            },

            SNIPER: {
                name: "SRS99C-S2 AM Sniper Rifle",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Stock
                    { name: "stock", shape: "box", width: 0.05, height: 0.12, depth: 0.35,
                      color: "#1a1a1a", position: [0, -0.02, -0.35], metalness: 0.4, roughness: 0.6 },
                    // Cheek rest
                    { name: "cheekRest", shape: "box", width: 0.04, height: 0.04, depth: 0.15,
                      color: "#2a2a2a", position: [0, 0.04, -0.25], metalness: 0.3, roughness: 0.7 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.035, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.08, 0], rotation: [12, 0, 0], metalness: 0.2, roughness: 0.8 },
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.08, height: 0.1, depth: 0.45,
                      color: "#2a2a2a", position: [0, 0.02, 0.1], metalness: 0.6, roughness: 0.4 },
                    // Magazine
                    { name: "magazine", shape: "box", width: 0.04, height: 0.15, depth: 0.06,
                      color: "#333333", position: [0, -0.08, 0.15], metalness: 0.5, roughness: 0.5 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.03, height: 0.6,
                      color: "#1a1a1a", position: [0, 0.02, 0.65], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Barrel fluting
                    { name: "barrelFlute1", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.4,
                      color: "#0a0a0a", position: [0.02, 0.02, 0.55], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Muzzle brake
                    { name: "muzzleBrake", shape: "cylinder", radiusTop: 0.04, radiusBottom: 0.03, height: 0.08,
                      color: "#1a1a1a", position: [0, 0.02, 0.99], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Scope body
                    { name: "scopeBody", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.04, height: 0.3,
                      color: "#1a1a2a", position: [0, 0.12, 0.1], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Scope adjustment
                    { name: "scopeAdjust", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.03,
                      color: "#2a2a2a", position: [0.04, 0.12, 0.1], rotation: [0, 0, 90], metalness: 0.6, roughness: 0.4 },
                    // Scope lens front
                    { name: "scopeLensFront", shape: "sphere", size: 0.03,
                      color: "#4488ff", position: [0, 0.12, 0.26], emissive: "#2266cc", metalness: 0.9, roughness: 0.1 },
                    // Scope lens back
                    { name: "scopeLensBack", shape: "sphere", size: 0.025,
                      color: "#ff6600", position: [0, 0.12, -0.04], emissive: "#cc4400", metalness: 0.9, roughness: 0.1 },
                    // Bipod leg left
                    { name: "bipodL", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.01, height: 0.12,
                      color: "#333333", position: [-0.03, -0.06, 0.4], rotation: [20, 0, -15], metalness: 0.7, roughness: 0.3 },
                    // Bipod leg right
                    { name: "bipodR", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.01, height: 0.12,
                      color: "#333333", position: [0.03, -0.06, 0.4], rotation: [20, 0, 15], metalness: 0.7, roughness: 0.3 }
                ]
            },

            SMG: {
                name: "M7 SMG",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.06, height: 0.12, depth: 0.2,
                      color: "#3a3a3a", position: [0, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.035, height: 0.1, depth: 0.045,
                      color: "#2a2a2a", position: [0, -0.08, -0.02], rotation: [10, 0, 0], metalness: 0.3, roughness: 0.7 },
                    // Magazine (curved)
                    { name: "magazine", shape: "box", width: 0.04, height: 0.15, depth: 0.03,
                      color: "#444444", position: [0, -0.1, 0.06], rotation: [-15, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Barrel shroud
                    { name: "barrelShroud", shape: "cylinder", radiusTop: 0.03, radiusBottom: 0.035, height: 0.15,
                      color: "#2a2a2a", position: [0, 0, 0.18], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.1,
                      color: "#1a1a1a", position: [0, 0, 0.3], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Front sight
                    { name: "frontSight", shape: "box", width: 0.01, height: 0.03, depth: 0.01,
                      color: "#1a1a1a", position: [0, 0.04, 0.22], metalness: 0.5, roughness: 0.5 },
                    // Rear sight
                    { name: "rearSight", shape: "box", width: 0.025, height: 0.025, depth: 0.01,
                      color: "#1a1a1a", position: [0, 0.07, -0.05], metalness: 0.5, roughness: 0.5 },
                    // Charging handle
                    { name: "chargingHandle", shape: "box", width: 0.015, height: 0.02, depth: 0.04,
                      color: "#333333", position: [0.035, 0.03, 0.02], metalness: 0.6, roughness: 0.4 },
                    // Stock folded
                    { name: "stock", shape: "box", width: 0.02, height: 0.06, depth: 0.1,
                      color: "#2a2a2a", position: [0, 0.02, -0.15], metalness: 0.4, roughness: 0.6 },
                    // Flashlight
                    { name: "flashlight", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.06,
                      color: "#333333", position: [0, -0.04, 0.15], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Flashlight lens
                    { name: "flashlightLens", shape: "sphere", size: 0.012,
                      color: "#ffff88", position: [0, -0.04, 0.19], emissive: "#aaaa44", metalness: 0.8, roughness: 0.2 }
                ]
            },

            PISTOL: {
                name: "M6D Pistol",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Slide
                    { name: "slide", shape: "box", width: 0.035, height: 0.045, depth: 0.18,
                      color: "#2a2a2a", position: [0, 0.025, 0.02], metalness: 0.7, roughness: 0.3 },
                    // Frame
                    { name: "frame", shape: "box", width: 0.03, height: 0.035, depth: 0.12,
                      color: "#1a1a1a", position: [0, -0.005, -0.01], metalness: 0.5, roughness: 0.5 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.03, height: 0.1, depth: 0.04,
                      color: "#1a1a1a", position: [0, -0.06, -0.04], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    // Magazine
                    { name: "magazine", shape: "box", width: 0.025, height: 0.08, depth: 0.03,
                      color: "#333333", position: [0, -0.06, -0.035], metalness: 0.5, roughness: 0.5 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.08,
                      color: "#1a1a1a", position: [0, 0.015, 0.15], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Scope
                    { name: "scope", shape: "cylinder", radiusTop: 0.018, radiusBottom: 0.02, height: 0.08,
                      color: "#222222", position: [0, 0.065, 0.02], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Scope lens
                    { name: "scopeLens", shape: "sphere", size: 0.015,
                      color: "#ff4400", position: [0, 0.065, 0.065], emissive: "#ff2200", metalness: 0.9, roughness: 0.1 },
                    // Trigger guard
                    { name: "triggerGuard", shape: "box", width: 0.025, height: 0.01, depth: 0.04,
                      color: "#1a1a1a", position: [0, -0.025, 0.02], metalness: 0.5, roughness: 0.5 },
                    // Trigger
                    { name: "trigger", shape: "box", width: 0.008, height: 0.025, depth: 0.01,
                      color: "#333333", position: [0, -0.02, 0.015], metalness: 0.6, roughness: 0.4 }
                ]
            },

            SHOTGUN: {
                name: "M90 Shotgun",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Stock
                    { name: "stock", shape: "box", width: 0.05, height: 0.1, depth: 0.25,
                      color: "#1a1a1a", position: [0, 0, -0.25], metalness: 0.3, roughness: 0.8 },
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.06, height: 0.1, depth: 0.25,
                      color: "#2a2a2a", position: [0, 0, 0.02], metalness: 0.5, roughness: 0.5 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.04, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.08, -0.02], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.025, height: 0.5,
                      color: "#1a1a1a", position: [0, 0.02, 0.4], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Magazine tube
                    { name: "magTube", shape: "cylinder", radiusTop: 0.02, radiusBottom: 0.02, height: 0.35,
                      color: "#2a2a2a", position: [0, -0.03, 0.32], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Pump grip
                    { name: "pumpGrip", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.035, height: 0.12,
                      color: "#333333", position: [0, -0.015, 0.25], rotation: [90, 0, 0], metalness: 0.4, roughness: 0.7 },
                    // Pump ridges
                    { name: "pumpRidge1", shape: "box", width: 0.04, height: 0.005, depth: 0.01,
                      color: "#222222", position: [0, -0.015, 0.21], metalness: 0.5, roughness: 0.5 },
                    { name: "pumpRidge2", shape: "box", width: 0.04, height: 0.005, depth: 0.01,
                      color: "#222222", position: [0, -0.015, 0.24], metalness: 0.5, roughness: 0.5 },
                    { name: "pumpRidge3", shape: "box", width: 0.04, height: 0.005, depth: 0.01,
                      color: "#222222", position: [0, -0.015, 0.27], metalness: 0.5, roughness: 0.5 },
                    // Front sight
                    { name: "frontSight", shape: "box", width: 0.01, height: 0.025, depth: 0.01,
                      color: "#ff4400", position: [0, 0.045, 0.6], emissive: "#ff2200", metalness: 0.5, roughness: 0.5 },
                    // Flashlight
                    { name: "flashlight", shape: "cylinder", radiusTop: 0.02, radiusBottom: 0.02, height: 0.08,
                      color: "#333333", position: [0, -0.05, 0.45], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 }
                ]
            },

            ROCKET: {
                name: "M41 Rocket Launcher",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Twin tubes
                    { name: "tubeLeft", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.06, height: 0.8,
                      color: "#3a4a3a", position: [-0.05, 0, 0.25], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.6 },
                    { name: "tubeRight", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.06, height: 0.8,
                      color: "#3a4a3a", position: [0.05, 0, 0.25], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.6 },
                    // Tube caps front
                    { name: "capFrontL", shape: "cylinder", radiusTop: 0.055, radiusBottom: 0.06, height: 0.03,
                      color: "#2a3a2a", position: [-0.05, 0, 0.66], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    { name: "capFrontR", shape: "cylinder", radiusTop: 0.055, radiusBottom: 0.06, height: 0.03,
                      color: "#2a3a2a", position: [0.05, 0, 0.66], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Grip assembly
                    { name: "gripHousing", shape: "box", width: 0.08, height: 0.1, depth: 0.15,
                      color: "#2a2a2a", position: [0, -0.05, -0.05], metalness: 0.4, roughness: 0.6 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.04, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.12, -0.08], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    // Shoulder rest
                    { name: "shoulderRest", shape: "box", width: 0.12, height: 0.08, depth: 0.12,
                      color: "#2a2a2a", position: [0, 0.02, -0.2], metalness: 0.4, roughness: 0.7 },
                    // Scope housing
                    { name: "scopeHousing", shape: "box", width: 0.06, height: 0.08, depth: 0.12,
                      color: "#2a3a2a", position: [0, 0.08, 0.05], metalness: 0.5, roughness: 0.5 },
                    // Scope screen
                    { name: "scopeScreen", shape: "box", width: 0.04, height: 0.04, depth: 0.01,
                      color: "#00ff44", position: [0, 0.1, -0.01], emissive: "#00aa22", metalness: 0.3, roughness: 0.3 },
                    // Targeting laser
                    { name: "laser", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.008, height: 0.04,
                      color: "#ff0000", position: [0, 0.06, 0.15], rotation: [90, 0, 0], emissive: "#ff0000", metalness: 0.5, roughness: 0.3 },
                    // Warning stripe
                    { name: "warningStripe", shape: "box", width: 0.15, height: 0.01, depth: 0.05,
                      color: "#ffaa00", position: [0, 0.065, 0.5], metalness: 0.4, roughness: 0.6 }
                ]
            }
        };

        // ============================================================
        // SPARTAN PLAYER MODEL DEFINITION
        // ============================================================

        const SpartanModel = {
            name: "Spartan Soldier",
            type: "character",
            bodyParts: [
                // Torso
                { name: "torso", shape: "box", width: 0.5, height: 0.6, depth: 0.3,
                  color: "#4a6a4a", position: [0, 0.9, 0], metalness: 0.4, roughness: 0.6 },
                // Chest plate
                { name: "chestPlate", shape: "box", width: 0.52, height: 0.35, depth: 0.15,
                  color: "#3a5a3a", position: [0, 1.05, 0.12], metalness: 0.6, roughness: 0.4 },
                // Shoulder left
                { name: "shoulderL", shape: "box", width: 0.2, height: 0.15, depth: 0.2,
                  color: "#4a6a4a", position: [-0.35, 1.15, 0], metalness: 0.5, roughness: 0.5 },
                // Shoulder right
                { name: "shoulderR", shape: "box", width: 0.2, height: 0.15, depth: 0.2,
                  color: "#4a6a4a", position: [0.35, 1.15, 0], metalness: 0.5, roughness: 0.5 },
                // Upper arm left
                { name: "upperArmL", shape: "cylinder", radiusTop: 0.08, radiusBottom: 0.07, height: 0.3,
                  color: "#3a5a3a", position: [-0.35, 0.85, 0], metalness: 0.4, roughness: 0.6 },
                // Upper arm right
                { name: "upperArmR", shape: "cylinder", radiusTop: 0.08, radiusBottom: 0.07, height: 0.3,
                  color: "#3a5a3a", position: [0.35, 0.85, 0], metalness: 0.4, roughness: 0.6 },
                // Forearm left
                { name: "forearmL", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.07, height: 0.25,
                  color: "#4a6a4a", position: [-0.35, 0.55, 0], metalness: 0.5, roughness: 0.5 },
                // Forearm right
                { name: "forearmR", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.07, height: 0.25,
                  color: "#4a6a4a", position: [0.35, 0.55, 0], metalness: 0.5, roughness: 0.5 },
                // Waist
                { name: "waist", shape: "box", width: 0.4, height: 0.15, depth: 0.25,
                  color: "#2a4a2a", position: [0, 0.55, 0], metalness: 0.4, roughness: 0.6 },
                // Upper leg left
                { name: "upperLegL", shape: "cylinder", radiusTop: 0.1, radiusBottom: 0.08, height: 0.4,
                  color: "#3a5a3a", position: [-0.12, 0.28, 0], metalness: 0.4, roughness: 0.6 },
                // Upper leg right
                { name: "upperLegR", shape: "cylinder", radiusTop: 0.1, radiusBottom: 0.08, height: 0.4,
                  color: "#3a5a3a", position: [0.12, 0.28, 0], metalness: 0.4, roughness: 0.6 },
                // Lower leg left
                { name: "lowerLegL", shape: "cylinder", radiusTop: 0.07, radiusBottom: 0.08, height: 0.35,
                  color: "#4a6a4a", position: [-0.12, -0.1, 0], metalness: 0.5, roughness: 0.5 },
                // Lower leg right
                { name: "lowerLegR", shape: "cylinder", radiusTop: 0.07, radiusBottom: 0.08, height: 0.35,
                  color: "#4a6a4a", position: [0.12, -0.1, 0], metalness: 0.5, roughness: 0.5 },
                // Boot left
                { name: "bootL", shape: "box", width: 0.1, height: 0.1, depth: 0.18,
                  color: "#2a3a2a", position: [-0.12, -0.32, 0.02], metalness: 0.4, roughness: 0.7 },
                // Boot right
                { name: "bootR", shape: "box", width: 0.1, height: 0.1, depth: 0.18,
                  color: "#2a3a2a", position: [0.12, -0.32, 0.02], metalness: 0.4, roughness: 0.7 },
                // Helmet
                { name: "helmet", shape: "sphere", size: 0.2,
                  color: "#4a6a4a", position: [0, 1.45, 0], metalness: 0.5, roughness: 0.5 },
                // Visor
                { name: "visor", shape: "sphere", size: 0.15,
                  color: "#ffaa00", position: [0, 1.43, 0.1], emissive: "#ff8800", emissiveIntensity: 0.4, metalness: 0.9, roughness: 0.1 }
            ]
        };

        // ============================================================
        // FIRST PERSON WEAPON VIEW MODEL SYSTEM
        // ============================================================

        const ViewModelSystem = {
            weaponGroup: null,
            currentWeaponType: null,
            bobTime: 0,
            recoilOffset: 0,
            swayX: 0,
            swayY: 0,

            init(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.weaponGroup = new THREE.Group();
                this.weaponGroup.name = 'viewModel';

                // Create weapon container that follows camera
                this.container = new THREE.Group();
                this.container.add(this.weaponGroup);
                scene.add(this.container);
            },

            setWeapon(weaponType) {
                if (this.currentWeaponType === weaponType) return;

                // Clear existing weapon
                while (this.weaponGroup.children.length > 0) {
                    this.weaponGroup.remove(this.weaponGroup.children[0]);
                }

                // Get model definition
                const modelDef = WeaponModels[weaponType];
                if (!modelDef) return;

                // Build weapon model at viewmodel scale
                const weaponModel = ModelBuilder.buildFromDefinition(modelDef, 1.5);
                this.weaponGroup.add(weaponModel);

                // Position for first person view
                this.weaponGroup.position.set(0.25, -0.2, -0.5);
                this.weaponGroup.rotation.set(0, Math.PI, 0);

                this.currentWeaponType = weaponType;
            },

            update(delta, playerVelocity, isMoving, isCrouching, isAiming) {
                if (!this.weaponGroup || !this.camera) return;

                // Update container to follow camera
                this.container.position.copy(this.camera.position);
                this.container.rotation.copy(this.camera.rotation);

                // Weapon bob when moving (Halo 2 style - no sprint)
                if (isMoving) {
                    const bobSpeed = isCrouching ? 6 : 8;
                    this.bobTime += delta * bobSpeed;
                    const bobAmount = isCrouching ? 0.008 : 0.015;
                    const bobX = Math.sin(this.bobTime) * bobAmount;
                    const bobY = Math.abs(Math.cos(this.bobTime)) * bobAmount * 0.7;
                    this.weaponGroup.position.x = 0.25 + bobX;
                    this.weaponGroup.position.y = -0.2 + bobY;
                } else {
                    // Subtle idle sway
                    this.bobTime += delta * 2;
                    const idleSway = Math.sin(this.bobTime * 0.5) * 0.003;
                    this.weaponGroup.position.x = 0.25 + idleSway;
                    this.weaponGroup.position.y = -0.2 + Math.sin(this.bobTime * 0.7) * 0.002;
                }

                // Aim down sights position
                if (isAiming) {
                    this.weaponGroup.position.lerp(new THREE.Vector3(0, -0.15, -0.4), delta * 10);
                } else {
                    this.weaponGroup.position.x = THREE.MathUtils.lerp(this.weaponGroup.position.x, 0.25, delta * 5);
                }

                // Recoil recovery
                this.recoilOffset *= 0.9;
                this.weaponGroup.rotation.x = this.recoilOffset;
            },

            applyRecoil(amount = 0.1) {
                this.recoilOffset = -amount;
            },

            hide() {
                if (this.container) this.container.visible = false;
            },

            show() {
                if (this.container) this.container.visible = true;
            }
        };

        // v1.01: Authentic Halo 2 weapon balance - BR is 4-shot kill (3 bursts body + 1 headshot)
        // Shield = 100, Health = 100. Total = 200 damage to kill.
        // BR: 36 damage/burst (12 per bullet x 3), 4 bursts to kill = 144 body + headshot burst
        // Sniper: 100 body (2-shot kill), 200 headshot (1-shot kill)
        const WeaponTypes = {
            BR55: {
                name: 'BR55 Battle Rifle',
                shortName: 'BR55',
                // v1.01: Authentic Halo 2 BR - 4 bursts to kill (3 body + 1 headshot or 6 body)
                damage: 36, // Per burst (3 rounds x 12 damage each)
                headshotMultiplier: 1.5, // Headshot burst = 54 damage
                fireRate: 0.5, // Seconds between bursts - authentic Halo 2 timing
                burstCount: 3,
                burstDelay: 0.05,
                magSize: 36,
                reserveMax: 108,
                reloadTime: 2.1,
                range: 100,
                spread: 0.008, // v1.01: Tighter spread for competitive BR play
                automatic: false,
                scopeZoom: 2,
                modelColor: 0x444444
            },
            SNIPER: {
                name: 'SRS99C-S2 AM Sniper',
                shortName: 'Sniper',
                // v1.01: Authentic Halo 2 sniper - 1-shot headshot, 2-shot body
                damage: 101, // Just over half total health+shield for 2-shot body kill
                headshotMultiplier: 2, // 202 damage = instant kill on headshot
                fireRate: 0.8, // v1.01: Faster fire rate like Halo 2
                burstCount: 1,
                burstDelay: 0,
                magSize: 4,
                reserveMax: 20,
                reloadTime: 2.5, // v1.01: Slightly faster reload
                range: 500,
                spread: 0,
                automatic: false,
                scopeZoom: 5,
                scopeZoom2: 10,
                modelColor: 0x333333
            },
            SMG: {
                name: 'M7 SMG',
                shortName: 'SMG',
                // v1.01: SMG is weaker but faster - dual wield secondary
                damage: 7,
                headshotMultiplier: 1.15,
                fireRate: 0.05,
                burstCount: 1,
                burstDelay: 0,
                magSize: 60,
                reserveMax: 180,
                reloadTime: 1.8,
                range: 25, // v1.01: Shorter effective range
                spread: 0.08, // v1.01: More spread for close range weapon
                automatic: true,
                scopeZoom: 0,
                modelColor: 0x555555
            },
            PISTOL: {
                name: 'M6C Magnum', // v1.01: Halo 2 uses M6C, not M6D
                shortName: 'Magnum',
                // v1.01: Halo 2 pistol is weaker than Halo CE
                damage: 18,
                headshotMultiplier: 1.5,
                fireRate: 0.25, // v1.01: Faster fire rate
                burstCount: 1,
                burstDelay: 0,
                magSize: 12,
                reserveMax: 48,
                reloadTime: 1.3,
                range: 50, // v1.01: Reduced range from CE
                spread: 0.02,
                automatic: false,
                scopeZoom: 0, // v1.01: Halo 2 magnum has no scope
                modelColor: 0x444444
            },
            SHOTGUN: {
                name: 'M90 Shotgun',
                shortName: 'Shotgun',
                // v1.01: Shotgun pellets - devastating at close range
                damage: 18, // Per pellet, 12 pellets = 216 max damage (1-shot potential)
                headshotMultiplier: 1.1,
                fireRate: 0.9, // v1.01: Slightly faster pump
                burstCount: 1,
                burstDelay: 0,
                magSize: 12,
                reserveMax: 36,
                reloadTime: 0.5, // Per shell
                range: 12, // v1.01: Shorter range - true close quarters
                spread: 0.18, // v1.01: Wider spread
                automatic: false,
                scopeZoom: 0,
                pelletCount: 12,
                modelColor: 0x333333
            },
            ROCKET: {
                name: 'M41 SPNKr',
                shortName: 'Rockets',
                // v1.01: Rockets are instant kill in blast radius
                damage: 250,
                headshotMultiplier: 1,
                fireRate: 2.0, // v1.01: Slightly faster
                burstCount: 1,
                burstDelay: 0,
                magSize: 2,
                reserveMax: 6,
                reloadTime: 3.5, // v1.01: Faster reload
                range: 200,
                spread: 0,
                automatic: false,
                scopeZoom: 2,
                splashRadius: 6, // v1.01: Larger splash radius
                modelColor: 0x445544
            }
        };

        class Weapon {
            constructor(type) {
                this.type = type;
                this.config = WeaponTypes[type];
                this.currentAmmo = this.config.magSize;
                this.reserveAmmo = this.config.reserveMax;
                this.lastFireTime = 0;
                this.isReloading = false;
                this.reloadStartTime = 0;
                this.burstRemaining = 0;
                this.scopeLevel = 0; // 0 = no scope, 1 = first zoom, 2 = second zoom
            }

            canFire() {
                const now = performance.now() / 1000;
                return !this.isReloading &&
                       this.currentAmmo > 0 &&
                       now - this.lastFireTime >= this.config.fireRate &&
                       this.burstRemaining === 0;
            }

            fire() {
                if (!this.canFire()) return false;

                this.lastFireTime = performance.now() / 1000;
                this.burstRemaining = this.config.burstCount;
                return true;
            }

            processBurst() {
                if (this.burstRemaining > 0 && this.currentAmmo > 0) {
                    this.currentAmmo--;
                    this.burstRemaining--;
                    return true;
                }
                return false;
            }

            reload() {
                if (this.isReloading || this.currentAmmo === this.config.magSize || this.reserveAmmo === 0) {
                    return false;
                }

                this.isReloading = true;
                this.reloadStartTime = performance.now() / 1000;
                this.scopeLevel = 0; // Exit scope on reload
                return true;
            }

            updateReload() {
                if (!this.isReloading) return;

                const now = performance.now() / 1000;
                if (now - this.reloadStartTime >= this.config.reloadTime) {
                    const needed = this.config.magSize - this.currentAmmo;
                    const available = Math.min(needed, this.reserveAmmo);
                    this.currentAmmo += available;
                    this.reserveAmmo -= available;
                    this.isReloading = false;
                }
            }

            toggleScope() {
                if (this.config.scopeZoom === 0) return;

                if (this.config.scopeZoom2) {
                    this.scopeLevel = (this.scopeLevel + 1) % 3;
                } else {
                    this.scopeLevel = this.scopeLevel === 0 ? 1 : 0;
                }
            }

            getZoom() {
                if (this.scopeLevel === 0) return 1;
                if (this.scopeLevel === 1) return this.config.scopeZoom;
                return this.config.scopeZoom2 || this.config.scopeZoom;
            }
        }

        // ============================================================
        // LOCKOUT MAP GEOMETRY
        // ============================================================

        // ============================================================
        // LOCKOUT MAP - Accurate Recreation of Halo 2's Lockout
        // ============================================================

        const LockoutMap = {
            // Collision data
            platforms: [],  // Floor/ceiling collision
            walls: [],      // Wall collision

            // Gravity lift at center of BR tower
            gravLift: { x: 0, y: -2, z: 0, topY: 12, radius: 2.5, active: true },

            // Weapon spawns matching actual Lockout locations
            weaponSpawns: [
                { pos: { x: 0, y: 12.5, z: 0 }, weapon: 'BR55' },      // BR Tower top
                { pos: { x: -25, y: 9, z: 0 }, weapon: 'SNIPER' },     // Sniper Tower 1
                { pos: { x: 25, y: 9, z: 0 }, weapon: 'SNIPER' },      // Sniper Tower 2
                { pos: { x: 18, y: 3, z: 18 }, weapon: 'SMG' },        // Library
                { pos: { x: -18, y: 3, z: 18 }, weapon: 'SMG' },       // Elbow
                { pos: { x: 0, y: -2, z: 0 }, weapon: 'ROCKET' },      // Sword room (center bottom)
                { pos: { x: 0, y: 6, z: -20 }, weapon: 'SHOTGUN' },    // Blue hall
                { pos: { x: 15, y: 3, z: -15 }, weapon: 'PISTOL' }     // BR3
            ],

            // Spawn points on solid ground
            spawnPoints: [
                { x: 2, y: 12.5, z: 2 },       // BR Tower top
                { x: -2, y: 12.5, z: -2 },     // BR Tower top
                { x: -23, y: 9, z: 2 },        // Sniper 1
                { x: 23, y: 9, z: -2 },        // Sniper 2
                { x: 16, y: 3, z: 16 },        // Library
                { x: -16, y: 3, z: 16 },       // Elbow
                { x: 0, y: 6, z: -18 },        // Blue room
                { x: 0, y: -2, z: 8 }          // Bottom mid
            ],

            build(scene) {
                // v1.01: Authentic Forerunner/Lockout materials - cold, icy metal with purple/blue accents
                const floorMat = new THREE.MeshStandardMaterial({
                    color: 0x4a5a6a, metalness: 0.7, roughness: 0.35 // Slightly brighter, more metallic
                });
                const wallMat = new THREE.MeshStandardMaterial({
                    color: 0x3a4a5a, metalness: 0.75, roughness: 0.25 // Colder gray-blue metal
                });
                const accentMat = new THREE.MeshStandardMaterial({
                    color: 0x5577bb, metalness: 0.85, roughness: 0.15, // Forerunner blue-purple
                    emissive: 0x223366, emissiveIntensity: 0.4 // Brighter glow
                });
                const glassMat = new THREE.MeshStandardMaterial({
                    color: 0x7799dd, metalness: 0.3, roughness: 0.05,
                    transparent: true, opacity: 0.4 // More transparent, icy look
                });
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0x88bbff, transparent: true, opacity: 0.85 // Brighter Forerunner glow
                });

                // === HELPER FUNCTIONS ===

                // Create floor platform with collision
                const addFloor = (x, y, z, w, d, mat = floorMat) => {
                    const h = 0.5;
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x, y - h/2, z);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    scene.add(mesh);

                    this.platforms.push({
                        minX: x - w/2, maxX: x + w/2,
                        minY: y - h, maxY: y,
                        minZ: z - d/2, maxZ: z + d/2,
                        isFloor: true
                    });
                };

                // Create wall with collision
                const addWall = (x, y, z, w, h, d, mat = wallMat) => {
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x, y + h/2, z);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    scene.add(mesh);

                    this.walls.push({
                        minX: x - w/2, maxX: x + w/2,
                        minY: y, maxY: y + h,
                        minZ: z - d/2, maxZ: z + d/2
                    });
                };

                // Create ramp (series of steps)
                const addRamp = (x1, y1, z1, x2, y2, z2, width, steps = 12) => {
                    const dx = (x2 - x1) / steps;
                    const dy = (y2 - y1) / steps;
                    const dz = (z2 - z1) / steps;
                    const stepLen = Math.sqrt(dx*dx + dz*dz) * 1.3;

                    for (let i = 0; i < steps; i++) {
                        const x = x1 + dx * i;
                        const y = y1 + dy * i;
                        const z = z1 + dz * i;
                        addFloor(x, y, z, width, stepLen);
                    }
                };

                // Add glow strip
                const addGlow = (x, y, z, w, d) => {
                    const geo = new THREE.BoxGeometry(w, 0.05, d);
                    const mesh = new THREE.Mesh(geo, glowMat);
                    mesh.position.set(x, y, z);
                    scene.add(mesh);
                };

                // === BUILD THE MAP ===
                // Lockout is roughly symmetric, centered on BR Tower
                // Coordinate system: +X = right, +Z = forward (toward Library), -Z = back (toward Blue)

                // 
                // BOTTOM LEVEL (y = -2 to 0) - Sword Room / Bottom Mid
                // 

                // Central bottom floor (under BR tower)
                addFloor(0, -2, 0, 16, 16);

                // Bottom mid extensions
                addFloor(0, -2, 12, 10, 8);   // Toward library side
                addFloor(0, -2, -12, 10, 8);  // Toward blue side

                // Walls around bottom
                addWall(-8, -2, 0, 0.5, 4, 16);
                addWall(8, -2, 0, 0.5, 4, 16);
                addWall(0, -2, -16, 16, 4, 0.5);

                // Pillars supporting BR tower
                addWall(-4, -2, -4, 2, 8, 2, accentMat);
                addWall(4, -2, -4, 2, 8, 2, accentMat);
                addWall(-4, -2, 4, 2, 8, 2, accentMat);
                addWall(4, -2, 4, 2, 8, 2, accentMat);

                // 
                // MID LEVEL (y = 3 to 6) - Library, Elbow, Walkways
                // 

                // Library platform (right side, +X +Z)
                addFloor(18, 3, 18, 12, 12);
                // Library walls
                addWall(24, 3, 18, 0.5, 4, 12);        // Back wall
                addWall(18, 3, 24, 12, 4, 0.5);        // Side wall
                addWall(12, 3, 21, 0.5, 4, 6);         // Front partial

                // Elbow platform (left side, -X +Z) - mirrors Library
                addFloor(-18, 3, 18, 12, 12);
                // Elbow walls
                addWall(-24, 3, 18, 0.5, 4, 12);
                addWall(-18, 3, 24, 12, 4, 0.5);
                addWall(-12, 3, 21, 0.5, 4, 6);

                // BR2 / Center walkway (connects to BR tower)
                addFloor(0, 3, 14, 8, 6);

                // BR3 platform (right side toward blue)
                addFloor(15, 3, -15, 10, 10);
                addWall(20, 3, -15, 0.5, 3, 10);
                addWall(15, 3, -20, 10, 3, 0.5);

                // Connector walkways
                addFloor(10, 3, 5, 6, 14);   // Library to BR3
                addFloor(-10, 3, 5, 6, 14);  // Elbow to other side

                // Ramps from bottom to mid
                addRamp(-6, -2, 10, -6, 3, 16, 4, 10);  // Left ramp
                addRamp(6, -2, 10, 6, 3, 16, 4, 10);    // Right ramp

                // 
                // BLUE ROOM / GLASS HALL (y = 6)
                // 

                // Blue room floor
                addFloor(0, 6, -20, 16, 10);

                // Blue room walls with windows
                addWall(-8, 6, -20, 0.5, 4, 10);
                addWall(8, 6, -20, 0.5, 4, 10);
                addWall(0, 6, -25, 16, 4, 0.5);

                // Glass windows
                addWall(-4, 8, -15, 0.3, 2, 1, glassMat);
                addWall(4, 8, -15, 0.3, 2, 1, glassMat);

                // Ramp from BR3 to Blue
                addRamp(10, 3, -12, 6, 6, -16, 4, 8);

                // 
                // SNIPER TOWERS (y = 6 to 12)
                // 

                // Sniper Tower 1 (left, -X)
                addFloor(-25, 6, 0, 8, 10);    // Base
                addFloor(-25, 9, 0, 6, 8);     // Top platform
                addWall(-29, 6, 0, 0.5, 6, 10);  // Back wall
                addWall(-25, 6, -5, 8, 6, 0.5);  // Side wall
                addWall(-25, 6, 5, 8, 6, 0.5);   // Side wall
                // Ramp up
                addRamp(-21, 6, 3, -23, 9, 0, 3, 6);

                // Sniper Tower 2 (right, +X) - mirrors Tower 1
                addFloor(25, 6, 0, 8, 10);
                addFloor(25, 9, 0, 6, 8);
                addWall(29, 6, 0, 0.5, 6, 10);
                addWall(25, 6, -5, 8, 6, 0.5);
                addWall(25, 6, 5, 8, 6, 0.5);
                addRamp(21, 6, -3, 23, 9, 0, 3, 6);

                // Walkways to sniper towers
                addFloor(-18, 6, 6, 6, 6);    // Left connector
                addFloor(18, 6, -6, 6, 6);    // Right connector

                // 
                // BR TOWER (y = 6 to 14) - Central Tower
                // 

                // BR Tower base platform
                addFloor(0, 6, 0, 10, 10);

                // BR Tower mid level
                addFloor(0, 9, 0, 8, 8);

                // BR Tower top (where BR spawns)
                addFloor(0, 12, 0, 10, 10);

                // Tower roof/cover
                addFloor(0, 16, 0, 8, 8, accentMat);

                // BR Tower walls (partial cover)
                addWall(-5, 12, 0, 0.5, 4, 10);
                addWall(5, 12, 0, 0.5, 4, 10);

                // Ramps up to BR tower
                addRamp(-4, 3, 10, -3, 6, 4, 3, 8);   // From BR2
                addRamp(4, 6, 4, 3, 9, 2, 3, 6);      // Mid to upper
                addRamp(-3, 9, -2, -2, 12, 0, 3, 6);  // Upper to top

                // 
                // TOP MID / CATWALK (y = 10 to 12)
                // 

                // Top walkway connecting sniper towers
                addFloor(-12, 10, -8, 8, 6);
                addFloor(12, 10, -8, 8, 6);
                addFloor(0, 10, -10, 10, 6);

                // Railings (short walls)
                addWall(-12, 10, -11, 8, 1.2, 0.3);
                addWall(12, 10, -11, 8, 1.2, 0.3);

                // Connections from sniper towers to top
                addRamp(-20, 9, -3, -14, 10, -6, 3, 6);
                addRamp(20, 9, -3, 14, 10, -6, 3, 6);

                // 
                // GRAVITY LIFT (center of bottom)
                // 

                this.gravLift = { x: 0, y: -2, z: 0, topY: 12, radius: 2, active: true };

                // Grav lift visual
                const liftGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 16);
                const liftMesh = new THREE.Mesh(liftGeo, glowMat);
                liftMesh.position.set(0, -1.8, 0);
                scene.add(liftMesh);

                // Lift beam (visual only)
                const beamGeo = new THREE.CylinderGeometry(0.8, 1.2, 14, 8, 1, true);
                const beamMat = new THREE.MeshBasicMaterial({
                    color: 0x66aaff, transparent: true, opacity: 0.15, side: THREE.DoubleSide
                });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.set(0, 5, 0);
                scene.add(beam);

                // 
                // DECORATIVE GLOW STRIPS
                // 

                addGlow(0, 12.1, 0, 8, 0.2);
                addGlow(0, 12.1, 0, 0.2, 8);
                addGlow(-25, 9.1, 0, 4, 0.2);
                addGlow(25, 9.1, 0, 4, 0.2);
                addGlow(0, 6.1, -20, 0.2, 8);

                // 
                // SKYBOX / ENVIRONMENT
                // 

                // v1.01: Snowy mountains in background - authentic Lockout backdrop
                const mountainMat = new THREE.MeshStandardMaterial({
                    color: 0x6a7a8a, roughness: 0.8, metalness: 0.1 // Snow-capped appearance
                });
                const snowCapMat = new THREE.MeshStandardMaterial({
                    color: 0xaabbcc, roughness: 0.6, metalness: 0.0 // Bright snow caps
                });
                for (let i = 0; i < 10; i++) { // v1.01: More mountains for fuller backdrop
                    const angle = (i / 10) * Math.PI * 2;
                    const dist = 140 + Math.random() * 60;
                    const height = 50 + Math.random() * 40;
                    const mtnGeo = new THREE.ConeGeometry(25 + Math.random() * 25, height, 5);
                    const mtn = new THREE.Mesh(mtnGeo, mountainMat);
                    mtn.position.set(Math.cos(angle) * dist, height/2 - 25, Math.sin(angle) * dist);
                    mtn.rotation.y = Math.random() * Math.PI;
                    scene.add(mtn);

                    // v1.01: Add snow cap to larger mountains
                    if (height > 60) {
                        const capGeo = new THREE.ConeGeometry(10, height * 0.3, 5);
                        const cap = new THREE.Mesh(capGeo, snowCapMat);
                        cap.position.set(Math.cos(angle) * dist, height * 0.7 - 10, Math.sin(angle) * dist);
                        cap.rotation.y = mtn.rotation.y;
                        scene.add(cap);
                    }
                }

                // Store spawn points
                GameState.spawnPoints = this.spawnPoints;
            },

            // v1.01: Check if player is in gravity lift - uses squared distance for performance
            checkGravLift(position) {
                if (!this.gravLift.active) return false;
                const dx = position.x - this.gravLift.x;
                const dz = position.z - this.gravLift.z;
                const distSq = dx * dx + dz * dz;
                const radiusSq = this.gravLift.radius * this.gravLift.radius;
                return distSq < radiusSq &&
                       position.y >= this.gravLift.y &&
                       position.y < this.gravLift.topY;
            },

            // Wall collision - returns push vector if colliding
            checkWallCollision(position, radius = 0.4) {
                const push = { x: 0, y: 0, z: 0 };

                for (const wall of this.walls) {
                    // Check if player overlaps wall
                    const overlapX = position.x + radius > wall.minX && position.x - radius < wall.maxX;
                    const overlapY = position.y + 1.8 > wall.minY && position.y < wall.maxY;
                    const overlapZ = position.z + radius > wall.minZ && position.z - radius < wall.maxZ;

                    if (overlapX && overlapY && overlapZ) {
                        // Calculate push direction (shortest exit)
                        const pushLeft = position.x - radius - wall.minX;
                        const pushRight = wall.maxX - (position.x + radius);
                        const pushBack = position.z - radius - wall.minZ;
                        const pushFront = wall.maxZ - (position.z + radius);

                        // Find smallest overlap
                        const minPush = Math.min(
                            Math.abs(pushLeft), Math.abs(pushRight),
                            Math.abs(pushBack), Math.abs(pushFront)
                        );

                        if (Math.abs(pushLeft) === minPush && pushLeft < 0) {
                            push.x = pushLeft - 0.01;
                        } else if (Math.abs(pushRight) === minPush && pushRight < 0) {
                            push.x = -pushRight + 0.01;
                        } else if (Math.abs(pushBack) === minPush && pushBack < 0) {
                            push.z = pushBack - 0.01;
                        } else if (Math.abs(pushFront) === minPush && pushFront < 0) {
                            push.z = -pushFront + 0.01;
                        }
                    }
                }

                return push;
            },

            // Ground height check
            getGroundHeight(x, z, currentY) {
                let groundY = -100;

                for (const plat of this.platforms) {
                    if (x >= plat.minX && x <= plat.maxX &&
                        z >= plat.minZ && z <= plat.maxZ) {
                        if (plat.maxY <= currentY + 0.5 && plat.maxY > groundY) {
                            groundY = plat.maxY;
                        }
                    }
                }

                return groundY;
            },

            // Head collision (ceiling)
            checkCeiling(x, z, headY) {
                for (const plat of this.platforms) {
                    if (x >= plat.minX && x <= plat.maxX &&
                        z >= plat.minZ && z <= plat.maxZ) {
                        if (plat.minY > headY - 0.2 && plat.minY < headY + 1) {
                            return plat.minY;
                        }
                    }
                }
                return null;
            }
        };

        // ============================================================
        // AUDIO SYSTEM
        // ============================================================

        const AudioSystem = {
            context: null,
            masterGain: null,

            init() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.connect(this.context.destination);
                this.masterGain.gain.value = gameData.settings.volume;
            },

            // Generate weapon sounds procedurally
            playWeaponFire(weaponType) {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Create oscillator for gunshot
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                filter.type = 'lowpass';

                switch (weaponType) {
                    case 'BR55':
                        // 3-round burst sound
                        osc.frequency.setValueAtTime(150, now);
                        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                        filter.frequency.value = 2000;
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        break;

                    case 'SNIPER':
                        // Deep, powerful shot
                        osc.frequency.setValueAtTime(80, now);
                        osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
                        filter.frequency.value = 1000;
                        gain.gain.setValueAtTime(0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                        break;

                    case 'SMG':
                        // Rapid fire crack
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.exponentialRampToValueAtTime(80, now + 0.05);
                        filter.frequency.value = 3000;
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        break;
                }

                // Add noise for texture
                const noise = this.createNoise(0.1);

                osc.connect(filter);
                filter.connect(gain);
                noise.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.5);
            },

            playShieldHit() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);

                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.2);
            },

            playShieldBreak() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);

                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.5);
            },

            playShieldRecharge() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.5);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.05, now + 0.5);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.7);
            },

            playKillSound() {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Medal sound - rising tone
                [400, 500, 600, 800].forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    gain.gain.setValueAtTime(0, now + i * 0.05);
                    gain.gain.linearRampToValueAtTime(0.15, now + i * 0.05 + 0.02);
                    gain.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.15);

                    osc.connect(gain);
                    gain.connect(this.masterGain);

                    osc.start(now);
                    osc.stop(now + 0.5);
                });
            },

            playReload() {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Mag out
                const noise1 = this.createNoise(0.15);
                const gain1 = this.context.createGain();
                gain1.gain.setValueAtTime(0.1, now);
                gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                noise1.connect(gain1);
                gain1.connect(this.masterGain);

                // Mag in (delayed)
                setTimeout(() => {
                    const noise2 = this.createNoise(0.2);
                    const gain2 = this.context.createGain();
                    const now2 = this.context.currentTime;
                    gain2.gain.setValueAtTime(0.15, now2);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now2 + 0.2);
                    noise2.connect(gain2);
                    gain2.connect(this.masterGain);
                }, 500);
            },

            playFootstep() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const noise = this.createNoise(0.08);
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                filter.type = 'lowpass';
                filter.frequency.value = 500;

                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
            },

            playJump() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.2);
            },

            createNoise(duration) {
                const bufferSize = this.context.sampleRate * duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const source = this.context.createBufferSource();
                source.buffer = buffer;
                source.start();

                return source;
            },

            // v1.04: Ambient audio system for atmospheric mountain wind
            ambientSource: null,
            ambientGain: null,

            startAmbient() {
                if (!this.context || !GAME_CONSTANTS.AMBIENT_AUDIO_ENABLED) return;
                if (this.ambientSource) return; // Already playing

                // Create continuous wind sound using filtered noise
                const bufferSize = this.context.sampleRate * 4; // 4 second loop
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = buffer.getChannelData(0);

                // Generate smooth noise for wind
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    // Add multiple sine waves for natural wind variation
                    output[i] = (
                        Math.sin(t * Math.PI * 2 * 0.5) * 0.3 +
                        Math.sin(t * Math.PI * 2 * 1.7) * 0.2 +
                        Math.sin(t * Math.PI * 2 * 3.3) * 0.1 +
                        (Math.random() * 2 - 1) * 0.1
                    );
                }

                this.ambientSource = this.context.createBufferSource();
                this.ambientSource.buffer = buffer;
                this.ambientSource.loop = true;

                // Create filter for wind character
                const filter = this.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400; // Low rumble
                filter.Q.value = 0.5;

                // Ambient gain (quieter than effects)
                this.ambientGain = this.context.createGain();
                this.ambientGain.gain.value = 0.05; // Very subtle

                this.ambientSource.connect(filter);
                filter.connect(this.ambientGain);
                this.ambientGain.connect(this.masterGain);

                this.ambientSource.start();
            },

            stopAmbient() {
                if (this.ambientSource) {
                    this.ambientSource.stop();
                    this.ambientSource = null;
                    this.ambientGain = null;
                }
            },

            updateAmbientVolume(intensity) {
                if (this.ambientGain && GAME_CONSTANTS.AMBIENT_AUDIO_ENABLED) {
                    // Vary wind intensity based on game action
                    const targetVolume = 0.03 + intensity * 0.05;
                    this.ambientGain.gain.linearRampToValueAtTime(
                        targetVolume,
                        this.context.currentTime + 1.0
                    );
                }
            }
        };

        // ============================================================
        // NETWORKING (WebRTC via PeerJS)
        // ============================================================

        const Network = {
            peer: null,
            connections: new Map(),
            isHost: false,
            lobbyCode: '',
            pingInterval: null,

            // v1.05: Network quality monitoring
            connectionQuality: new Map(), // peerId -> { ping, packetLoss, lastSeen }
            avgPing: 0,
            reconnectAttempts: 0,
            lastPingTime: 0,

            generateLobbyCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            },

            async createLobby() {
                this.lobbyCode = this.generateLobbyCode();
                this.isHost = true;

                return new Promise((resolve, reject) => {
                    // PeerJS uses the code as peer ID for simplicity
                    this.peer = new Peer('lockout-' + this.lobbyCode, {
                        debug: 1
                    });

                    this.peer.on('open', (id) => {
                        devLog('Lobby created:', this.lobbyCode);

                        // Listen for incoming connections
                        this.peer.on('connection', (conn) => {
                            this.handleNewConnection(conn);
                        });

                        resolve(this.lobbyCode);
                    });

                    this.peer.on('error', (err) => {
                        devError('PeerJS error:', err);
                        reject(err);
                    });
                });
            },

            async joinLobby(code) {
                this.lobbyCode = code.toUpperCase();
                this.isHost = false;

                return new Promise((resolve, reject) => {
                    this.peer = new Peer(undefined, { debug: 1 });

                    this.peer.on('open', (id) => {
                        // Connect to host
                        const conn = this.peer.connect('lockout-' + this.lobbyCode, {
                            reliable: true
                        });

                        conn.on('open', () => {
                            this.handleNewConnection(conn);

                            // Send join message
                            conn.send({
                                type: 'join',
                                player: {
                                    id: this.peer.id,
                                    name: document.getElementById('player-name').value || 'Spartan',
                                    team: document.getElementById('team-select').value
                                }
                            });

                            resolve();
                        });

                        conn.on('error', reject);
                    });

                    this.peer.on('error', reject);
                });
            },

            handleNewConnection(conn) {
                devLog('New connection:', conn.peer);
                this.connections.set(conn.peer, conn);

                // v1.05: Initialize connection quality tracking
                this.connectionQuality.set(conn.peer, {
                    ping: 0,
                    packetLoss: 0,
                    lastSeen: Date.now(),
                    pingHistory: []
                });

                conn.on('data', (data) => {
                    // v1.05: Update last seen timestamp
                    const quality = this.connectionQuality.get(conn.peer);
                    if (quality) {
                        quality.lastSeen = Date.now();
                    }
                    this.handleMessage(conn.peer, data);
                });

                conn.on('close', () => {
                    devLog('Connection closed:', conn.peer);
                    this.connections.delete(conn.peer);
                    this.connectionQuality.delete(conn.peer);
                    GameState.players.delete(conn.peer);
                    this.updateLobbyUI();
                    this.updateConnectionStatus();
                });

                // v1.05: Set connection timeout monitoring
                this.monitorConnectionTimeout(conn.peer);

                this.updateConnectionStatus();
            },

            // v1.05: Monitor connection for timeouts
            monitorConnectionTimeout(peerId) {
                const checkTimeout = () => {
                    const quality = this.connectionQuality.get(peerId);
                    const conn = this.connections.get(peerId);

                    if (!quality || !conn) return;

                    const timeSinceLastSeen = Date.now() - quality.lastSeen;

                    if (timeSinceLastSeen > GAME_CONSTANTS.NETWORK_TIMEOUT) {
                        devWarn(`Connection timeout for ${peerId}`);
                        showToast(`Connection lost to ${GameState.players.get(peerId)?.name || 'player'}`, 'warning');
                        conn.close();
                    } else {
                        setTimeout(checkTimeout, 1000);
                    }
                };

                setTimeout(checkTimeout, 1000);
            },

            handleMessage(peerId, data) {
                switch (data.type) {
                    case 'join':
                        // New player joined
                        GameState.players.set(peerId, {
                            ...data.player,
                            id: peerId,
                            position: { x: 0, y: 10, z: 0 },
                            rotation: { x: 0, y: 0 },
                            kills: 0,
                            deaths: 0,
                            shield: 100,
                            health: 100,
                            weapon: 'BR55'
                        });

                        // If host, broadcast updated player list
                        if (this.isHost) {
                            this.broadcast({
                                type: 'playerList',
                                players: Array.from(GameState.players.entries())
                            });
                        }

                        this.updateLobbyUI();
                        break;

                    case 'playerList':
                        // Update player list from host
                        GameState.players = new Map(data.players);
                        this.updateLobbyUI();
                        break;

                    case 'gameStart':
                        startGame();
                        break;

                    case 'position':
                        // Update player position
                        const player = GameState.players.get(peerId);
                        if (player) {
                            player.position = data.position;
                            player.rotation = data.rotation;
                            player.velocity = data.velocity;
                        }
                        break;

                    case 'shoot':
                        // Handle remote player shooting
                        this.handleRemoteShoot(peerId, data);
                        break;

                    case 'hit':
                        // Handle hit registration
                        if (data.targetId === this.peer.id) {
                            PlayerController.takeDamage(data.damage, peerId);
                        }
                        break;

                    case 'death':
                        // Player died
                        const deadPlayer = GameState.players.get(data.playerId);
                        if (deadPlayer) {
                            deadPlayer.deaths++;
                            addKillFeedEntry(data.killerName, deadPlayer.name, data.weapon);
                        }
                        const killer = GameState.players.get(data.killerId);
                        if (killer) {
                            killer.kills++;
                        }
                        break;

                    case 'respawn':
                        const respawnPlayer = GameState.players.get(peerId);
                        if (respawnPlayer) {
                            respawnPlayer.position = data.position;
                            respawnPlayer.shield = 100;
                            respawnPlayer.health = 100;
                        }
                        break;

                    case 'weaponPickup':
                        // Remove weapon from map
                        break;

                    case 'ping':
                        // v1.05: Reply to ping with pong
                        const conn = this.connections.get(peerId);
                        if (conn && conn.open) {
                            conn.send({ type: 'pong', timestamp: data.timestamp });
                        }
                        break;

                    case 'pong':
                        // v1.05: Calculate RTT and update connection quality
                        const ping = Date.now() - data.timestamp;
                        const quality = this.connectionQuality.get(peerId);

                        if (quality) {
                            quality.ping = ping;
                            quality.pingHistory.push(ping);

                            // Keep only last 10 pings for moving average
                            if (quality.pingHistory.length > 10) {
                                quality.pingHistory.shift();
                            }

                            // Calculate average ping
                            const avgPing = quality.pingHistory.reduce((a, b) => a + b, 0) / quality.pingHistory.length;
                            this.avgPing = avgPing;
                        }

                        // v1.05: Update UI with color-coded ping
                        this.updatePingDisplay(ping);
                        break;
                }
            },

            handleRemoteShoot(peerId, data) {
                // Visual effect for remote player shooting
                const player = GameState.players.get(peerId);
                if (player) {
                    // Muzzle flash, sound, etc.
                    AudioSystem.playWeaponFire(data.weapon);
                }
            },

            broadcast(data) {
                this.connections.forEach(conn => {
                    if (conn.open) {
                        conn.send(data);
                    }
                });
            },

            sendPosition() {
                this.broadcast({
                    type: 'position',
                    position: {
                        x: PlayerController.position.x,
                        y: PlayerController.position.y,
                        z: PlayerController.position.z
                    },
                    rotation: {
                        x: PlayerController.rotationX,
                        y: PlayerController.rotationY
                    },
                    velocity: {
                        x: PlayerController.velocity.x,
                        y: PlayerController.velocity.y,
                        z: PlayerController.velocity.z
                    }
                });
            },

            sendShoot(weapon, direction) {
                this.broadcast({
                    type: 'shoot',
                    weapon: weapon,
                    position: {
                        x: PlayerController.position.x,
                        y: PlayerController.position.y + 1.6,
                        z: PlayerController.position.z
                    },
                    direction: direction
                });
            },

            sendHit(targetId, damage) {
                this.broadcast({
                    type: 'hit',
                    targetId: targetId,
                    damage: damage
                });
            },

            sendDeath(killerId, killerName, weapon) {
                this.broadcast({
                    type: 'death',
                    playerId: this.peer.id,
                    killerId: killerId,
                    killerName: killerName,
                    weapon: weapon
                });
            },

            // v1.05: Enhanced connection status with quality indicator
            updateConnectionStatus() {
                const statusEl = document.getElementById('connection-status');
                const countEl = document.getElementById('peer-count');

                if (!statusEl || !countEl) return;

                statusEl.style.display = 'block';

                // Color-code based on average ping
                if (this.avgPing === 0 || this.connections.size === 0) {
                    statusEl.className = 'connected';
                } else if (this.avgPing < GAME_CONSTANTS.PING_GOOD_THRESHOLD) {
                    statusEl.className = 'connected'; // Green
                } else if (this.avgPing < GAME_CONSTANTS.PING_FAIR_THRESHOLD) {
                    statusEl.className = 'connecting'; // Yellow
                } else {
                    statusEl.className = 'error'; // Red
                }

                countEl.textContent = this.connections.size + 1; // +1 for self
            },

            // v1.05: Update ping display with color coding
            updatePingDisplay(ping) {
                const pingEl = document.getElementById('ping');
                if (!pingEl) return;

                pingEl.textContent = Math.round(ping);

                // Color-code the ping value
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    if (ping < GAME_CONSTANTS.PING_GOOD_THRESHOLD) {
                        statusEl.className = 'connected';
                    } else if (ping < GAME_CONSTANTS.PING_FAIR_THRESHOLD) {
                        statusEl.className = 'connecting';
                    } else {
                        statusEl.className = 'error';
                    }
                }
            },

            updateLobbyUI() {
                const container = document.getElementById('lobby-players');
                container.innerHTML = '';

                GameState.players.forEach((player, id) => {
                    const div = document.createElement('div');
                    div.className = 'lobby-player';
                    div.innerHTML = `
                        <span>${player.name}</span>
                        ${player.isHost ? '<span class="host-badge">HOST</span>' : ''}
                    `;
                    container.appendChild(div);
                });
            },

            // v1.05: Enhanced ping loop with adaptive interval
            startPingLoop() {
                this.pingInterval = setInterval(() => {
                    this.connections.forEach((conn, peerId) => {
                        if (conn.open) {
                            try {
                                conn.send({ type: 'ping', timestamp: Date.now() });
                            } catch (err) {
                                devError(`Failed to ping ${peerId}:`, err);
                                // Connection may be dead, will be caught by timeout monitor
                            }
                        }
                    });
                }, GAME_CONSTANTS.NETWORK_PING_INTERVAL);
            },

            cleanup() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.connections.clear();
            }
        };

        // ============================================================
        // INPUT HANDLING
        // ============================================================

        const Input = {
            keys: {},
            mouse: { x: 0, y: 0, dx: 0, dy: 0, buttons: {} },
            isPointerLocked: false,

            init() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    // v1.06: Toggle help overlay (works in and out of game)
                    if (e.code === 'KeyH') {
                        toggleHelp();
                        e.preventDefault();
                        return;
                    }

                    // v1.07: Toggle settings menu (P key)
                    if (e.code === 'KeyP') {
                        toggleSettings();
                        e.preventDefault();
                        return;
                    }

                    // v1.06: Close help overlay with ESC key
                    // v1.07: Also close settings menu with ESC key
                    if (e.code === 'Escape') {
                        const helpOverlay = document.getElementById('help-overlay');
                        if (helpOverlay && helpOverlay.classList.contains('visible')) {
                            toggleHelp();
                            e.preventDefault();
                            return;
                        }
                        const settingsOverlay = document.getElementById('settings-overlay');
                        if (settingsOverlay && settingsOverlay.classList.contains('visible')) {
                            toggleSettings();
                            e.preventDefault();
                            return;
                        }
                    }

                    if (GameState.isRunning) {
                        // Prevent default for game keys
                        if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space', 'ShiftLeft', 'ControlLeft', 'KeyR', 'KeyE', 'Tab', 'KeyH'].includes(e.code)) {
                            e.preventDefault();
                        }

                        // Reload
                        if (e.code === 'KeyR') {
                            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                            if (weapon && weapon.reload()) {
                                AudioSystem.playReload();
                            }
                        }

                        // Weapon switch
                        if (e.code === 'Digit1') PlayerController.currentWeaponIndex = 0;
                        if (e.code === 'Digit2' && PlayerController.weapons.length > 1) PlayerController.currentWeaponIndex = 1;

                        // Scope toggle (right click or middle click alternative)
                        if (e.code === 'KeyZ') {
                            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                            if (weapon) weapon.toggleScope();
                        }

                        // v1.01: Tab for scoreboard using cached DOM
                        if (e.code === 'Tab') {
                            getUICache().scoreboard.classList.add('visible');
                        }

                        // Weapon pickup
                        if (e.code === 'KeyE') {
                            checkWeaponPickup();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;

                    // v1.01: Use cached DOM for scoreboard
                    if (e.code === 'Tab') {
                        getUICache().scoreboard.classList.remove('visible');
                    }
                });

                // Mouse
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouse.dx += e.movementX;
                        this.mouse.dy += e.movementY;
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    this.mouse.buttons[e.button] = true;

                    if (GameState.isRunning && !this.isPointerLocked) {
                        document.getElementById('game-container').requestPointerLock();
                    }

                    // Right click for scope
                    if (e.button === 2 && GameState.isRunning) {
                        const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                        if (weapon) weapon.toggleScope();
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    this.mouse.buttons[e.button] = false;
                });

                // Context menu prevention
                document.addEventListener('contextmenu', (e) => {
                    if (GameState.isRunning) e.preventDefault();
                });

                // Pointer lock
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement !== null;
                });

                // Scroll for weapon switch
                document.addEventListener('wheel', (e) => {
                    if (GameState.isRunning && PlayerController.weapons.length > 1) {
                        if (e.deltaY > 0) {
                            PlayerController.currentWeaponIndex = (PlayerController.currentWeaponIndex + 1) % PlayerController.weapons.length;
                        } else {
                            PlayerController.currentWeaponIndex = (PlayerController.currentWeaponIndex - 1 + PlayerController.weapons.length) % PlayerController.weapons.length;
                        }
                        updateWeaponUI();
                    }
                });
            },

            getMovementInput() {
                let forward = 0, right = 0;

                if (this.keys['KeyW']) forward += 1;
                if (this.keys['KeyS']) forward -= 1;
                if (this.keys['KeyA']) right -= 1;
                if (this.keys['KeyD']) right += 1;

                return { forward, right };
            },

            consumeMouseDelta() {
                const dx = this.mouse.dx;
                const dy = this.mouse.dy;
                this.mouse.dx = 0;
                this.mouse.dy = 0;
                return { dx, dy };
            }
        };

        // ============================================================
        // v1.03: TOUCH INPUT SYSTEM - Mobile/tablet support
        // ============================================================

        /**
         * Touch input system for mobile devices
         * Provides virtual joystick and touch buttons
         */
        const TouchInput = {
            enabled: false,
            joystick: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                dx: 0,
                dy: 0
            },
            buttons: {
                shoot: false,
                jump: false,
                reload: false
            },

            /**
             * Initialize touch input system
             * Automatically enables on touch-capable devices
             */
            init() {
                // Detect if device supports touch
                const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

                if (isTouchDevice) {
                    this.enabled = true;
                    document.getElementById('touch-controls').classList.add('visible');
                    this.setupTouchControls();
                }
            },

            /**
             * Setup touch event handlers for virtual joystick and buttons
             */
            setupTouchControls() {
                // Virtual joystick
                const joystickElement = document.getElementById('move-joystick');
                const joystickStick = joystickElement.querySelector('.joystick-stick');

                joystickElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystickElement.getBoundingClientRect();
                    this.joystick.active = true;
                    this.joystick.startX = rect.left + rect.width / 2;
                    this.joystick.startY = rect.top + rect.height / 2;
                    this.updateJoystick(touch.clientX, touch.clientY, joystickStick);
                });

                joystickElement.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystick.active) {
                        const touch = e.touches[0];
                        this.updateJoystick(touch.clientX, touch.clientY, joystickStick);
                    }
                });

                joystickElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.dx = 0;
                    this.joystick.dy = 0;
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                });

                // Touch buttons
                this.setupTouchButton('shoot-button', 'shoot', () => {
                    // Fire weapon
                    if (GameState.isRunning && !PlayerController.isDead) {
                        const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                        if (weapon) weapon.attemptFire();
                    }
                });

                this.setupTouchButton('jump-button', 'jump', () => {
                    // Jump
                    Input.keys['Space'] = true;
                    setTimeout(() => { Input.keys['Space'] = false; }, 100);
                });

                this.setupTouchButton('reload-button', 'reload', () => {
                    // Reload
                    const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                    if (weapon && weapon.reload()) {
                        AudioSystem.playReload();
                    }
                });
            },

            /**
             * Setup a single touch button
             * @param {string} elementId - Button element ID
             * @param {string} buttonName - Button state property name
             * @param {Function} onTap - Callback for tap action
             */
            setupTouchButton(elementId, buttonName, onTap) {
                const button = document.getElementById(elementId);
                if (!button) return;

                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.buttons[buttonName] = true;
                    if (onTap) onTap();
                });

                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.buttons[buttonName] = false;
                });
            },

            /**
             * Update joystick position and calculate normalized direction
             * @param {number} x - Touch X position
             * @param {number} y - Touch Y position
             * @param {HTMLElement} stickElement - Joystick stick element
             */
            updateJoystick(x, y, stickElement) {
                const dx = x - this.joystick.startX;
                const dy = y - this.joystick.startY;

                // Limit joystick movement to circle radius
                const maxRadius = 60;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > maxRadius) {
                    const angle = Math.atan2(dy, dx);
                    this.joystick.currentX = this.joystick.startX + Math.cos(angle) * maxRadius;
                    this.joystick.currentY = this.joystick.startY + Math.sin(angle) * maxRadius;
                } else {
                    this.joystick.currentX = x;
                    this.joystick.currentY = y;
                }

                // Update visual position
                const offsetX = this.joystick.currentX - this.joystick.startX;
                const offsetY = this.joystick.currentY - this.joystick.startY;
                stickElement.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                // Calculate normalized direction (-1 to 1)
                this.joystick.dx = Math.max(-1, Math.min(1, dx / maxRadius));
                this.joystick.dy = Math.max(-1, Math.min(1, dy / maxRadius));
            },

            /**
             * Get movement input from touch joystick
             * @returns {{forward: number, right: number}}
             */
            getMovementInput() {
                if (!this.enabled || !this.joystick.active) {
                    return { forward: 0, right: 0 };
                }

                return {
                    forward: -this.joystick.dy,  // Invert Y for forward/back
                    right: this.joystick.dx
                };
            }
        };

        // ============================================================
        // PLAYER MODELS (Remote Players)
        // ============================================================

        const PlayerModels = {
            models: new Map(),

            createPlayerModel(playerId, team) {
                // Create Spartan model with team colors
                const teamColors = {
                    red: { primary: '#aa2222', secondary: '#882222', accent: '#cc4444' },
                    blue: { primary: '#2222aa', secondary: '#222288', accent: '#4444cc' },
                    none: { primary: '#4a6a4a', secondary: '#3a5a3a', accent: '#5a7a5a' }
                };

                const colors = teamColors[team] || teamColors.none;

                // Clone and color the Spartan model for this team
                const teamSpartanDef = JSON.parse(JSON.stringify(SpartanModel));
                teamSpartanDef.bodyParts.forEach(part => {
                    if (part.name === 'torso' || part.name === 'helmet' || part.name.includes('Arm') ||
                        part.name.includes('Leg') || part.name.includes('shoulder')) {
                        part.color = colors.primary;
                    } else if (part.name === 'chestPlate' || part.name.includes('forearm')) {
                        part.color = colors.secondary;
                    } else if (part.name === 'waist' || part.name.includes('boot')) {
                        part.color = colors.accent;
                    }
                });

                const group = ModelBuilder.buildFromDefinition(teamSpartanDef, 1);

                scene.add(group);
                this.models.set(playerId, group);

                return group;
            },

            updatePlayerModel(playerId, position, rotation) {
                let model = this.models.get(playerId);

                if (!model) {
                    const player = GameState.players.get(playerId);
                    model = this.createPlayerModel(playerId, player?.team || 'none');
                }

                model.position.set(position.x, position.y, position.z);
                model.rotation.y = rotation.y;
            },

            removePlayerModel(playerId) {
                const model = this.models.get(playerId);
                if (model) {
                    scene.remove(model);
                    this.models.delete(playerId);
                }
            }
        };

        // ============================================================
        // BOT AI SYSTEM
        // ============================================================

        const BotAI = {
            // v1.05: Bot difficulty settings (initialized with MEDIUM by default)
            currentDifficulty: 'MEDIUM',
            difficulty: GAME_CONSTANTS.BOT_DIFFICULTY.MEDIUM,

            // Bot behavior settings (will be overridden by difficulty)
            moveSpeed: 5,
            turnSpeed: 3,
            detectionRange: 50,
            shootRange: 40,
            accuracy: 0.7, // 70% chance to hit
            reactionTime: 0.3, // seconds before shooting
            burstDelay: 0.15, // delay between burst shots

            // v1.05: Set bot difficulty
            setDifficulty(level) {
                if (GAME_CONSTANTS.BOT_DIFFICULTY[level]) {
                    this.currentDifficulty = level;
                    this.difficulty = GAME_CONSTANTS.BOT_DIFFICULTY[level];
                    this.moveSpeed = this.difficulty.moveSpeed;
                    this.detectionRange = this.difficulty.detectionRange;
                    this.accuracy = this.difficulty.accuracy;
                    this.reactionTime = this.difficulty.reactionTime;

                    devLog(`Bot difficulty set to ${level}`);
                    showToast(`Bot difficulty: ${level}`, 'info', 2000);
                }
            },

            // Patrol waypoints around Lockout
            waypoints: [
                { x: 0, y: 12, z: 0 },      // BR Tower top
                { x: -23, y: 9, z: 0 },     // Sniper 1
                { x: 23, y: 9, z: 0 },      // Sniper 2
                { x: 16, y: 3, z: 16 },     // Library
                { x: -16, y: 3, z: 16 },    // Elbow
                { x: 0, y: 6, z: -18 },     // Blue room
                { x: 0, y: -2, z: 0 },      // Bottom mid
                { x: 10, y: 3, z: 0 },      // Mid right
                { x: -10, y: 3, z: 0 }      // Mid left
            ],

            // Initialize bot state
            initBot(bot) {
                if (!bot.ai) {
                    bot.ai = {
                        state: 'patrol', // patrol, chase, attack, retreat
                        targetWaypoint: Math.floor(Math.random() * this.waypoints.length),
                        lastShotTime: 0,
                        burstCount: 0,
                        reactionTimer: 0,
                        stuckTimer: 0,
                        lastPosition: { ...bot.position }
                    };
                }
            },

            // v1.05: Update all bots with null safety
            update(delta) {
                if (!GameState.players || GameState.players.size === 0) return;

                GameState.players.forEach((bot, id) => {
                    if (!id || !id.startsWith('bot_')) return;
                    if (!bot || !bot.position || !bot.rotation) return; // v1.05: Null safety
                    if (bot.health <= 0) return; // Dead bot

                    this.initBot(bot);
                    this.updateBot(bot, delta);
                });
            },

            // v1.05: Update single bot with null safety
            updateBot(bot, delta) {
                if (!bot || !bot.position || !bot.rotation || !bot.ai) return; // v1.05: Null safety
                if (!PlayerController || !PlayerController.position) return; // v1.05: Null safety

                const playerPos = PlayerController.position;
                const botPos = bot.position;

                // Calculate distance to player
                const dx = playerPos.x - botPos.x;
                const dy = playerPos.y - botPos.y;
                const dz = playerPos.z - botPos.z;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy + dz * dz);

                // Check if player is in line of sight
                const canSeePlayer = distToPlayer < this.detectionRange && !PlayerController.isDead;

                // State machine
                if (canSeePlayer && distToPlayer < this.shootRange) {
                    bot.ai.state = 'attack';
                } else if (canSeePlayer) {
                    bot.ai.state = 'chase';
                } else if (bot.shield < 30) {
                    bot.ai.state = 'retreat';
                } else {
                    bot.ai.state = 'patrol';
                }

                // Execute behavior based on state
                switch (bot.ai.state) {
                    case 'patrol':
                        this.patrol(bot, delta);
                        break;
                    case 'chase':
                        this.chase(bot, playerPos, delta);
                        break;
                    case 'attack':
                        this.attack(bot, playerPos, distToPlayer, delta);
                        break;
                    case 'retreat':
                        this.retreat(bot, playerPos, delta);
                        break;
                }

                // Apply gravity and ground collision
                this.applyPhysics(bot, delta);

                // Regenerate shields (like player)
                if (bot.shield < 100) {
                    bot.shield = Math.min(100, bot.shield + 20 * delta);
                }
            },

            // Patrol behavior - move between waypoints
            patrol(bot, delta) {
                const waypoint = this.waypoints[bot.ai.targetWaypoint];
                const dx = waypoint.x - bot.position.x;
                const dz = waypoint.z - bot.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 3) {
                    // Reached waypoint, pick new one
                    bot.ai.targetWaypoint = Math.floor(Math.random() * this.waypoints.length);
                } else {
                    // Move toward waypoint
                    const angle = Math.atan2(dx, dz);
                    bot.rotation.y = this.lerpAngle(bot.rotation.y, angle, this.turnSpeed * delta);

                    bot.position.x += Math.sin(bot.rotation.y) * this.moveSpeed * delta;
                    bot.position.z += Math.cos(bot.rotation.y) * this.moveSpeed * delta;
                }
            },

            // Chase behavior - move toward player
            chase(bot, playerPos, delta) {
                const dx = playerPos.x - bot.position.x;
                const dz = playerPos.z - bot.position.z;

                // Face player
                const angle = Math.atan2(dx, dz);
                bot.rotation.y = this.lerpAngle(bot.rotation.y, angle, this.turnSpeed * 2 * delta);

                // Move toward player
                bot.position.x += Math.sin(bot.rotation.y) * this.moveSpeed * 1.2 * delta;
                bot.position.z += Math.cos(bot.rotation.y) * this.moveSpeed * 1.2 * delta;
            },

            // Attack behavior - face player and shoot
            attack(bot, playerPos, distToPlayer, delta) {
                const dx = playerPos.x - bot.position.x;
                const dz = playerPos.z - bot.position.z;

                // Face player
                const angle = Math.atan2(dx, dz);
                bot.rotation.y = this.lerpAngle(bot.rotation.y, angle, this.turnSpeed * 3 * delta);

                // Strafe while shooting
                const strafeDir = Math.sin(performance.now() / 500) * 0.5;
                bot.position.x += Math.cos(bot.rotation.y) * strafeDir * this.moveSpeed * delta;
                bot.position.z -= Math.sin(bot.rotation.y) * strafeDir * this.moveSpeed * delta;

                // Shoot at player
                bot.ai.reactionTimer += delta;
                if (bot.ai.reactionTimer > this.reactionTime) {
                    this.tryShoot(bot, playerPos, distToPlayer);
                }
            },

            // Retreat behavior - move away from player
            retreat(bot, playerPos, delta) {
                const dx = bot.position.x - playerPos.x;
                const dz = bot.position.z - playerPos.z;

                // Face away from player
                const angle = Math.atan2(dx, dz);
                bot.rotation.y = this.lerpAngle(bot.rotation.y, angle, this.turnSpeed * delta);

                // Move away
                bot.position.x += Math.sin(bot.rotation.y) * this.moveSpeed * delta;
                bot.position.z += Math.cos(bot.rotation.y) * this.moveSpeed * delta;
            },

            // v1.05: Try to shoot at player with difficulty-based accuracy
            tryShoot(bot, playerPos, distToPlayer) {
                const now = performance.now() / 1000;
                if (now - bot.ai.lastShotTime < this.burstDelay) return;

                bot.ai.lastShotTime = now;
                bot.ai.burstCount++;

                // Reset burst after 3 shots
                if (bot.ai.burstCount >= 3) {
                    bot.ai.burstCount = 0;
                    bot.ai.reactionTimer = 0; // Small delay between bursts
                }

                // v1.05: Apply difficulty-based aim drift
                const aimDrift = this.difficulty ? this.difficulty.aimDrift : 0.08;
                const aimOffset = {
                    x: (Math.random() - 0.5) * aimDrift * distToPlayer,
                    y: (Math.random() - 0.5) * aimDrift * distToPlayer * 0.5,
                    z: (Math.random() - 0.5) * aimDrift * distToPlayer
                };

                // Check if shot hits (based on accuracy and distance with aim drift)
                const baseAccuracy = this.difficulty ? this.difficulty.accuracy : this.accuracy;
                const hitChance = baseAccuracy * (1 - distToPlayer / this.shootRange * 0.3);
                if (Math.random() < hitChance) {
                    // Hit player
                    const damage = 12; // BR damage per bullet
                    if (PlayerController && PlayerController.takeDamage) {
                        PlayerController.takeDamage(damage, bot.id);
                    }
                    if (AudioSystem && AudioSystem.playBRShot) {
                        AudioSystem.playBRShot(); // Play BR sound
                    }
                } else {
                    // Miss - just play sound
                    if (AudioSystem && AudioSystem.playBRShot) {
                        AudioSystem.playBRShot();
                    }
                }
            },

            // Apply physics to bot
            applyPhysics(bot, delta) {
                // Simple gravity
                if (!bot.velocity) bot.velocity = { y: 0 };
                bot.velocity.y -= 12 * delta;

                bot.position.y += bot.velocity.y * delta;

                // Ground collision
                const groundY = LockoutMap.getGroundHeight(bot.position.x, bot.position.z, bot.position.y + 2);
                if (bot.position.y <= groundY + 1.8) {
                    bot.position.y = groundY + 1.8;
                    bot.velocity.y = 0;
                }

                // Wall collision
                const wallPush = LockoutMap.checkWallCollision(bot.position, 0.4);
                bot.position.x += wallPush.x;
                bot.position.z += wallPush.z;

                // Prevent falling off map
                if (bot.position.y < -30) {
                    const spawn = GameState.spawnPoints[Math.floor(Math.random() * GameState.spawnPoints.length)];
                    bot.position = { x: spawn.x, y: spawn.y + 2, z: spawn.z };
                    bot.velocity.y = 0;
                }
            },

            // Helper: lerp angle
            lerpAngle(from, to, t) {
                let diff = to - from;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return from + diff * Math.min(t, 1);
            }
        };

        // ============================================================
        // WEAPON PICKUP SYSTEM
        // ============================================================

        const WeaponPickups = {
            pickups: [],
            respawnTime: 30, // seconds

            init() {
                LockoutMap.weaponSpawns.forEach((spawn, index) => {
                    this.createPickup(index, spawn.pos, spawn.weapon);
                });
            },

            createPickup(id, position, weaponType) {
                const config = WeaponTypes[weaponType];

                // Visual representation
                const group = new THREE.Group();

                // Weapon model - use detailed model from WeaponModels
                const weaponModelDef = WeaponModels[weaponType];
                if (weaponModelDef) {
                    const weaponMesh = ModelBuilder.buildFromDefinition(weaponModelDef, 2.5);
                    weaponMesh.rotation.y = Math.PI / 2; // Rotate for better pickup display
                    group.add(weaponMesh);
                } else {
                    // Fallback to box if no model defined
                    const weaponGeo = new THREE.BoxGeometry(0.8, 0.2, 0.15);
                    const weaponMat = new THREE.MeshStandardMaterial({
                        color: config.modelColor,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const weaponMesh = new THREE.Mesh(weaponGeo, weaponMat);
                    group.add(weaponMesh);
                }

                // Glow ring
                const ringGeo = new THREE.TorusGeometry(0.6, 0.05, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x66aaff,
                    transparent: true,
                    opacity: 0.6
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = -0.2;
                group.add(ring);

                // Holographic platform
                const platformGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.02, 16);
                const platformMat = new THREE.MeshBasicMaterial({
                    color: 0x66aaff,
                    transparent: true,
                    opacity: 0.3
                });
                const platform = new THREE.Mesh(platformGeo, platformMat);
                platform.position.y = -0.25;
                group.add(platform);

                group.position.set(position.x, position.y + 0.5, position.z);
                scene.add(group);

                this.pickups.push({
                    id,
                    group,
                    position,
                    weaponType,
                    isAvailable: true,
                    respawnTimer: 0
                });
            },

            update(delta) {
                this.pickups.forEach(pickup => {
                    if (pickup.isAvailable) {
                        // Rotate and bob
                        pickup.group.rotation.y += delta * 2;
                        pickup.group.position.y = pickup.position.y + 0.5 + Math.sin(Date.now() / 500) * 0.1;
                        pickup.group.visible = true;
                    } else {
                        pickup.group.visible = false;
                        pickup.respawnTimer -= delta;
                        if (pickup.respawnTimer <= 0) {
                            pickup.isAvailable = true;
                        }
                    }
                });
            },

            // v1.01: Uses squared distance for performance (avoids sqrt)
            checkPickup(playerPosition) {
                const pickupRadiusSq = 4; // 2^2 = 4

                for (const pickup of this.pickups) {
                    if (!pickup.isAvailable) continue;

                    const dx = playerPosition.x - pickup.position.x;
                    const dy = playerPosition.y - pickup.position.y;
                    const dz = playerPosition.z - pickup.position.z;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < pickupRadiusSq) {
                        return pickup;
                    }
                }
                return null;
            },

            collectPickup(pickup) {
                pickup.isAvailable = false;
                pickup.respawnTimer = this.respawnTime;

                // Give weapon to player
                const newWeapon = new Weapon(pickup.weaponType);

                if (PlayerController.weapons.length < 2) {
                    PlayerController.weapons.push(newWeapon);
                } else {
                    // Replace current weapon
                    PlayerController.weapons[PlayerController.currentWeaponIndex] = newWeapon;
                }

                updateWeaponUI();

                // Broadcast pickup
                if (GameState.isMultiplayer) {
                    Network.broadcast({
                        type: 'weaponPickup',
                        pickupId: pickup.id
                    });
                }
            }
        };

        /**
         * Check if player is near a weapon pickup and show prompt
         * v1.06: Added JSDoc documentation
         *
         * Detects when player is within pickup range of a weapon spawned on the map.
         * Shows UI prompt with weapon name and pickup key (E).
         * Updates every frame during gameplay.
         */
        function checkWeaponPickup() {
            const pickup = WeaponPickups.checkPickup(PlayerController.position);
            if (pickup) {
                WeaponPickups.collectPickup(pickup);
            }
        }

        // ============================================================
        // RAYCASTING / HIT DETECTION
        // ============================================================

        const raycaster = new THREE.Raycaster();

        /**
         * Perform a weapon shot with raycasting hit detection
         * v1.06: Added comprehensive JSDoc documentation
         * @param {Weapon} weapon - The weapon being fired
         * @returns {boolean} - True if shot hit a target, false otherwise
         *
         * This function handles the core shooting mechanics:
         * 1. Calculates bullet trajectory with weapon spread
         * 2. Performs raycasting to detect hits on players
         * 3. Calculates damage (with headshot multipliers)
         * 4. Spawns particle effects for impacts
         * 5. Sends hit data over network in multiplayer
         * 6. Checks for environmental impacts if no player hit
         */
        function performShot(weapon) {
            const config = weapon.config;

            // Calculate shot direction with spread (reduced when scoped)
            const spread = config.spread * (weapon.scopeLevel > 0 ? 0.3 : 1);
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), PlayerController.rotationX + (Math.random() - 0.5) * spread);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), PlayerController.rotationY + (Math.random() - 0.5) * spread);

            // Set raycaster
            const origin = new THREE.Vector3(
                PlayerController.position.x,
                PlayerController.position.y + 1.6, // Eye height
                PlayerController.position.z
            );
            raycaster.set(origin, direction);
            raycaster.far = config.range;

            // Check hits against player models
            const playerMeshes = [];
            PlayerModels.models.forEach((model, id) => {
                if (id !== Network.peer?.id) {
                    model.traverse(child => {
                        if (child.isMesh) {
                            child.userData.playerId = id;
                            playerMeshes.push(child);
                        }
                    });
                }
            });

            const intersects = raycaster.intersectObjects(playerMeshes, false);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitPlayerId = hit.object.userData.playerId;

                // v1.04: Spawn impact particles on hit
                // v1.08: Enhanced null safety for particle system methods
                if (particleSystem && particleSystem.spawnImpact && hit.point) {
                    const normal = hit.face ? hit.face.normal.clone().transformDirection(hit.object.matrixWorld) : new THREE.Vector3(0, 1, 0);
                    particleSystem.spawnImpact(hit.point, normal);
                }

                // Calculate damage
                let damage = config.damage / config.burstCount; // Per bullet

                // Check for headshot (upper part of model)
                if (hit.point.y > hit.object.parent.position.y + 1.5) {
                    damage *= config.headshotMultiplier;
                }

                // Show hit marker
                showHitMarker(false);

                // Send hit to network
                if (GameState.isMultiplayer) {
                    Network.sendHit(hitPlayerId, damage);
                } else {
                    // Single player - apply damage to bot
                    const bot = GameState.players.get(hitPlayerId);
                    if (bot) {
                        applyDamageToPlayer(bot, damage, 'player');
                    }
                }

                return true;
            }

            // v1.04: If no player hit, check for environmental impact particles
            const envIntersects = raycaster.intersectObjects(scene.children, true);
            if (envIntersects.length > 0 && particleSystem) {
                const hit = envIntersects[0];
                if (hit.point && hit.face) {
                    const normal = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
                    particleSystem.spawnImpact(hit.point, normal);
                }
            }

            return false;
        }

        /**
         * Display hit marker feedback to player
         * v1.06: Added JSDoc documentation
         * @param {boolean} isKill - Whether this was a killing blow (shows red marker)
         *
         * Provides immediate visual feedback when shots land on target.
         * Uses white marker for hits, red marker for kills.
         */
        function showHitMarker(isKill) {
            // v1.01: Use cached DOM reference
            const marker = getUICache().hitMarker;
            marker.classList.add('active');
            if (isKill) marker.classList.add('kill');

            setTimeout(() => {
                marker.classList.remove('active', 'kill');
            }, 150);
        }

        // ============================================================
        // DAMAGE & DEATH SYSTEM
        // ============================================================

        PlayerController.takeDamage = function(damage, attackerId) {
            if (this.isDead) return;

            this.lastDamageTime = performance.now() / 1000;

            // v1.04: Camera shake based on damage severity
            const shakeIntensity = Math.min(damage / 50, 1) * GAME_CONSTANTS.CAMERA_SHAKE_HIT;
            cameraShake.shake(shakeIntensity);

            // v1.01: Use cached DOM references for shield flash
            const shieldFlash = getUICache().shieldFlash;

            // Damage shield first
            if (this.shield > 0) {
                const shieldDamage = Math.min(this.shield, damage);
                this.shield -= shieldDamage;
                damage -= shieldDamage;

                if (this.shield <= 0) {
                    AudioSystem.playShieldBreak();
                    shieldFlash.classList.add('active', 'broken');
                } else {
                    AudioSystem.playShieldHit();
                    shieldFlash.classList.add('active');
                }
            }

            // Remaining damage goes to health
            if (damage > 0) {
                this.health -= damage;
            }

            // Update UI
            updateHealthUI();

            setTimeout(() => {
                shieldFlash.classList.remove('active', 'broken');
            }, 100);

            // Check death
            if (this.health <= 0) {
                this.die(attackerId);
            }
        };

        PlayerController.die = function(killerId) {
            this.isDead = true;
            gameData.stats.deaths++;
            saveData();

            // v1.07: Reset killstreak on death
            KillstreakSystem.reset();

            const killer = GameState.players.get(killerId);
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];

            // Add to kill feed
            addKillFeedEntry(
                killer ? killer.name : 'Unknown',
                document.getElementById('player-name').value || 'Spartan',
                weapon ? weapon.config.shortName : 'BR55'
            );

            // Network death notification
            if (GameState.isMultiplayer) {
                Network.sendDeath(killerId, killer?.name || 'Unknown', weapon?.type || 'BR55');
            }

            // v1.01: Use cached DOM references for respawn screen
            const ui = getUICache();
            ui.respawnScreen.classList.add('visible');
            ui.killedBy.textContent = `Killed by ${killer?.name || 'Unknown'}`;

            // v1.01: Clear any existing respawn timer before creating new one
            if (GameState.timers.respawnInterval) {
                clearInterval(GameState.timers.respawnInterval);
            }

            // Respawn timer
            let respawnTime = 5;
            GameState.timers.respawnInterval = setInterval(() => {
                respawnTime--;
                ui.respawnTimer.textContent = respawnTime;

                if (respawnTime <= 0) {
                    clearInterval(GameState.timers.respawnInterval);
                    GameState.timers.respawnInterval = null;
                    this.respawn();
                }
            }, 1000);
        };

        PlayerController.respawn = function() {
            // Pick random spawn point
            const spawns = GameState.spawnPoints;
            const spawn = spawns[Math.floor(Math.random() * spawns.length)];

            this.position.set(spawn.x, spawn.y + 2, spawn.z);
            this.velocity.set(0, 0, 0);
            this.shield = this.maxShield;
            this.health = this.maxHealth;
            this.isDead = false;

            // Reset weapons
            this.weapons = [new Weapon('BR55')];
            this.currentWeaponIndex = 0;

            updateHealthUI();
            updateWeaponUI();

            // v1.01: Use cached DOM reference
            getUICache().respawnScreen.classList.remove('visible');

            // Network respawn
            if (GameState.isMultiplayer) {
                Network.broadcast({
                    type: 'respawn',
                    position: { x: spawn.x, y: spawn.y + 2, z: spawn.z }
                });
            }
        };

        /**
         * Apply damage to a player with shield/health system
         * v1.06: Added JSDoc documentation
         * @param {Object} player - Player object receiving damage
         * @param {number} damage - Amount of damage to apply
         * @param {string} attackerId - ID of attacking player (for kill attribution)
         *
         * Implements Halo-style two-layer damage system:
         * 1. Damage depletes shields first (with visual flash)
         * 2. Once shields break, damage affects health
         * 3. Resets shield regeneration timer on hit
         * 4. Triggers death/respawn if health reaches zero
         */
        function applyDamageToPlayer(player, damage, attackerId) {
            // For bots/remote players
            if (player.shield > 0) {
                const shieldDamage = Math.min(player.shield, damage);
                player.shield -= shieldDamage;
                damage -= shieldDamage;
            }

            if (damage > 0) {
                player.health -= damage;
            }

            if (player.health <= 0) {
                // Player killed
                player.deaths++;

                // Find killer
                if (attackerId === 'player') {
                    PlayerController.kills = (PlayerController.kills || 0) + 1;
                    gameData.stats.kills++;
                    saveData();

                    // v1.07: Register killstreak
                    KillstreakSystem.registerKill();

                    AudioSystem.playKillSound();
                    showHitMarker(true);

                    addKillFeedEntry(
                        document.getElementById('player-name').value || 'Spartan',
                        player.name,
                        PlayerController.weapons[PlayerController.currentWeaponIndex]?.config.shortName || 'BR55'
                    );

                    updateScoreUI();
                }

                // Respawn bot after delay
                setTimeout(() => {
                    const spawns = GameState.spawnPoints;
                    const spawn = spawns[Math.floor(Math.random() * spawns.length)];
                    player.position = { x: spawn.x, y: spawn.y + 2, z: spawn.z };
                    player.shield = 100;
                    player.health = 100;
                }, 3000);
            }
        }

        // ============================================================
        // UI UPDATES
        // ============================================================

        // v1.01: DOM cache for performance - avoids repeated getElementById calls
        let _uiCache = null;
        function getUICache() {
            if (!_uiCache) {
                _uiCache = {
                    shieldFill: document.getElementById('shield-fill'),
                    healthFill: document.getElementById('health-fill'),
                    weaponName: document.getElementById('weapon-name'),
                    currentAmmo: document.getElementById('current-ammo'),
                    reserveAmmo: document.getElementById('reserve-ammo'),
                    scopeOverlay: document.getElementById('scope-overlay'),
                    playerScore: document.getElementById('player-score'),
                    matchTimer: document.getElementById('match-timer'),
                    shieldFlash: document.getElementById('shield-flash'),
                    hitMarker: document.getElementById('hit-marker'),
                    killFeed: document.getElementById('kill-feed'),
                    weaponPickup: document.getElementById('weapon-pickup'),
                    pickupWeaponName: document.getElementById('pickup-weapon-name'),
                    respawnScreen: document.getElementById('respawn-screen'),
                    respawnTimer: document.getElementById('respawn-timer'),
                    killedBy: document.getElementById('killed-by'),
                    scoreboard: document.getElementById('scoreboard'),
                    scoreboardRows: document.getElementById('scoreboard-rows'),
                    minimapCanvas: document.getElementById('minimap-canvas')
                };
            }
            return _uiCache;
        }

        // v1.02: Enhanced with ARIA attributes for screen readers
        function updateHealthUI() {
            const ui = getUICache();
            const shieldPercent = (PlayerController.shield / PlayerController.maxShield) * 100;
            const healthPercent = (PlayerController.health / PlayerController.maxHealth) * 100;

            ui.shieldFill.style.width = shieldPercent + '%';
            ui.healthFill.style.width = healthPercent + '%';

            // v1.02: Update ARIA attributes for accessibility
            const shieldBar = document.getElementById('shield-bar');
            const healthBar = document.getElementById('health-bar');

            if (shieldBar) {
                shieldBar.setAttribute('aria-valuenow', Math.round(PlayerController.shield));
            }
            if (healthBar) {
                healthBar.setAttribute('aria-valuenow', Math.round(PlayerController.health));
            }
        }

        function updateWeaponUI() {
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            if (!weapon) return;

            const ui = getUICache();
            ui.weaponName.textContent = weapon.config.name;
            ui.currentAmmo.textContent = weapon.currentAmmo;
            ui.reserveAmmo.textContent = weapon.reserveAmmo;

            // Update scope overlay
            if (weapon.scopeLevel > 0 && weapon.config.scopeZoom > 0) {
                ui.scopeOverlay.classList.add('active');
            } else {
                ui.scopeOverlay.classList.remove('active');
            }
        }

        function updateScoreUI() {
            getUICache().playerScore.textContent = PlayerController.kills || 0;
        }

        function updateTimerUI() {
            const minutes = Math.floor(GameState.matchTime / 60);
            const seconds = Math.floor(GameState.matchTime % 60);
            getUICache().matchTimer.textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function addKillFeedEntry(killer, victim, weapon) {
            // v1.01: Use cached DOM reference
            const feed = getUICache().killFeed;
            const entry = document.createElement('div');
            entry.className = 'kill-item';
            entry.innerHTML = `
                <span class="killer">${killer}</span>
                <span class="weapon-icon">[${weapon}]</span>
                <span class="victim">${victim}</span>
            `;
            feed.appendChild(entry);

            // v1.01: Track timeout for proper cleanup
            // v1.08: Use Set for O(1) add/delete operations - prevents memory leak
            const timeoutId = setTimeout(() => {
                if (entry.parentNode) {
                    entry.remove();
                }
                // Remove this timeout from tracking Set (O(1) operation)
                GameState.timers.killFeedTimeouts.delete(timeoutId);
            }, 5000);
            GameState.timers.killFeedTimeouts.add(timeoutId);

            // Limit feed entries
            while (feed.children.length > 5) {
                feed.removeChild(feed.firstChild);
            }
        }

        function updateScoreboard() {
            // v1.01: Use cached DOM reference
            const rows = getUICache().scoreboardRows;
            rows.innerHTML = '';

            // Sort players by kills
            const sortedPlayers = Array.from(GameState.players.values())
                .sort((a, b) => b.kills - a.kills);

            // Add local player
            const localPlayer = {
                name: document.getElementById('player-name').value || 'Spartan',
                kills: PlayerController.kills || 0,
                deaths: gameData.stats.deaths,
                isLocal: true
            };

            sortedPlayers.push(localPlayer);
            sortedPlayers.sort((a, b) => b.kills - a.kills);

            sortedPlayers.forEach(player => {
                const row = document.createElement('div');
                row.className = 'scoreboard-row' + (player.isLocal ? ' local' : '');
                row.innerHTML = `
                    <span>${player.name}</span>
                    <span>${player.kills || 0}</span>
                    <span>${player.deaths || 0}</span>
                    <span>${(player.kills || 0) * 100}</span>
                `;
                rows.appendChild(row);
            });
        }

        // v1.01: Cache minimap context for performance
        let _minimapCtx = null;
        function getMinimapContext() {
            if (!_minimapCtx) {
                _minimapCtx = getUICache().minimapCanvas.getContext('2d');
            }
            return _minimapCtx;
        }

        function updateMinimap() {
            // v1.01: Use cached context for performance
            const ctx = getMinimapContext();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 176, 176);

            // Draw map outline (simplified)
            ctx.strokeStyle = '#3af';
            ctx.lineWidth = 1;
            ctx.strokeRect(20, 20, 136, 136);

            // Draw platforms
            ctx.fillStyle = 'rgba(50, 100, 150, 0.5)';
            LockoutMap.platforms.forEach(p => {
                const x = 88 + (p.minX + p.maxX) / 2 * 2;
                const y = 88 - (p.minZ + p.maxZ) / 2 * 2;
                const w = (p.maxX - p.minX) * 2;
                const h = (p.maxZ - p.minZ) * 2;
                ctx.fillRect(x - w/2, y - h/2, w, h);
            });

            // Draw local player
            const px = 88 + PlayerController.position.x * 2;
            const py = 88 - PlayerController.position.z * 2;

            ctx.fillStyle = '#5f5';
            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fill();

            // Direction indicator
            ctx.strokeStyle = '#5f5';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(
                px + Math.sin(PlayerController.rotationY) * 8,
                py - Math.cos(PlayerController.rotationY) * 8
            );
            ctx.stroke();

            // Draw other players
            GameState.players.forEach((player, id) => {
                if (id === Network.peer?.id) return;

                const opx = 88 + player.position.x * 2;
                const opy = 88 - player.position.z * 2;

                ctx.fillStyle = player.team === 'red' ? '#f55' :
                               player.team === 'blue' ? '#55f' : '#f55';
                ctx.beginPath();
                ctx.arc(opx, opy, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ============================================================
        // GAME INITIALIZATION
        // ============================================================

        function initThreeJS() {
            // v1.01: Scene with authentic Lockout atmosphere - cold, snowy mountain environment
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a3a); // Darker, colder blue
            scene.fog = new THREE.Fog(0x2a3a4a, 40, 180); // Closer fog for that Lockout visibility

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // v1.01: Authentic Lockout lighting - cold ambient with warm sun
            const ambientLight = new THREE.AmbientLight(0x405060, 0.6); // Slightly brighter cold ambient
            scene.add(ambientLight);

            // Main directional light (sun through clouds)
            const directionalLight = new THREE.DirectionalLight(0xddeeff, 0.9); // Slightly blue-white sun
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 300;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // v1.01: Forerunner glow lights for that authentic Lockout feel
            const rimLight1 = new THREE.PointLight(0x5588ff, 0.6, 80); // Blue Forerunner glow
            rimLight1.position.set(-30, 25, -30);
            scene.add(rimLight1);

            const rimLight2 = new THREE.PointLight(0x6688ff, 0.6, 80);
            rimLight2.position.set(30, 20, 30);
            scene.add(rimLight2);

            // v1.01: Purple accent light for Forerunner structures
            const accentLight = new THREE.PointLight(0x8866cc, 0.4, 60);
            accentLight.position.set(0, 15, 0); // Center on BR tower
            scene.add(accentLight);

            // v1.01: Skybox with authentic Lockout colors - icy mountain sky
            const skyGeo = new THREE.SphereGeometry(400, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0a1525) }, // Dark night blue at top
                    bottomColor: { value: new THREE.Color(0x6080aa) }, // Hazy mountain horizon
                    offset: { value: 80 },
                    exponent: { value: 0.5 } // Smoother gradient
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);

            // Build the Lockout map
            LockoutMap.build(scene);

            // Initialize first-person weapon view model system
            ViewModelSystem.init(scene, camera);

            // v1.04: Initialize particle system
            particleSystem = new ParticleSystem(scene);

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function initGame() {
            // Initialize Three.js
            initThreeJS();

            // Initialize audio (on user interaction)
            document.addEventListener('click', () => {
                if (!AudioSystem.context) {
                    AudioSystem.init();
                }
            }, { once: true });

            // Initialize input
            Input.init();

            // v1.03: Initialize touch input for mobile devices
            TouchInput.init();

            // Set player name from saved data
            if (gameData.settings.name) {
                document.getElementById('player-name').value = gameData.settings.name;
            }
        }

        // ============================================================
        // GAME LOOP
        // ============================================================

        let lastFootstepTime = 0;
        let burstTimer = 0;

        /**
         * v1.03: Main game loop with performance monitoring and delta smoothing
         * v1.06: Enhanced documentation
         * Runs at ~60 FPS and updates all game systems
         *
         * Game Loop Order:
         * 1. Delta time smoothing (prevents physics issues)
         * 2. FPS monitoring and display
         * 3. Match timer countdown
         * 4. Player movement (WASD, jumping, crouching)
         * 5. Camera rotation (mouse look)
         * 6. Weapon firing and reloading
         * 7. Shield regeneration system
         * 8. Bot AI updates (pathfinding, combat)
         * 9. Weapon pickup detection
         * 10. Camera shake and particle effects
         * 11. Network position sync (20Hz tick rate)
         * 12. Scene rendering with shake applied
         * 13. Minimap rendering
         */
        function gameLoop() {
            if (!GameState.isRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // v1.03: Get delta from clock and smooth it using performance monitor
            let delta = clock.getDelta();
            delta = perfMonitor.update(delta);

            // v1.03: Update FPS counter display
            const fpsElement = document.getElementById('fps-value');
            if (fpsElement) {
                const fps = perfMonitor.getFPS();
                fpsElement.textContent = fps;

                // Color code FPS counter based on performance
                const fpsCounter = document.getElementById('fps-counter');
                fpsCounter.classList.remove('warning', 'critical');
                if (fps < 30) {
                    fpsCounter.classList.add('critical');
                } else if (fps < 45) {
                    fpsCounter.classList.add('warning');
                }
            }

            // Update match timer
            GameState.matchTime -= delta;
            if (GameState.matchTime <= 0) {
                endMatch();
            }
            updateTimerUI();

            // Player movement
            if (!PlayerController.isDead) {
                updatePlayerMovement(delta);
                updatePlayerCamera(delta);
                updateCombat(delta);
            }

            // Shield regeneration
            updateShieldRegen(delta);

            // Update weapons
            PlayerController.weapons.forEach(w => w.updateReload());
            updateWeaponUI();

            // Update first-person weapon view model
            const currentWeapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            if (currentWeapon) {
                ViewModelSystem.setWeapon(currentWeapon.type);
                const isMoving = Input.keys['KeyW'] || Input.keys['KeyS'] || Input.keys['KeyA'] || Input.keys['KeyD'];
                const isAiming = currentWeapon.scopeLevel > 0;
                ViewModelSystem.update(delta, PlayerController.velocity, isMoving, PlayerController.isCrouching, isAiming);

                // Hide weapon when scoped
                if (isAiming) {
                    ViewModelSystem.hide();
                } else {
                    ViewModelSystem.show();
                }
            }

            // Update bot AI (single player mode)
            if (!GameState.isMultiplayer) {
                BotAI.update(delta);
            }

            // Update remote players and bot models
            GameState.players.forEach((player, id) => {
                if (id !== Network.peer?.id) {
                    PlayerModels.updatePlayerModel(id, player.position, player.rotation);
                }
            });

            // Update weapon pickups
            WeaponPickups.update(delta);

            // v1.01: Check for nearby weapon pickups using cached DOM
            const nearbyPickup = WeaponPickups.checkPickup(PlayerController.position);
            const ui = getUICache();
            if (nearbyPickup) {
                ui.weaponPickup.classList.add('visible');
                ui.pickupWeaponName.textContent = WeaponTypes[nearbyPickup.weaponType].name;
            } else {
                ui.weaponPickup.classList.remove('visible');
            }

            // Update minimap
            updateMinimap();

            // Update scoreboard
            updateScoreboard();

            // v1.04: Update camera shake and particle systems
            cameraShake.update();
            if (particleSystem) {
                particleSystem.update(delta);
            }

            // v1.03: Network position updates with proper throttling (using GAME_CONSTANTS)
            if (GameState.isMultiplayer) {
                const now = performance.now();
                if (!this._lastNetworkUpdate || now - this._lastNetworkUpdate > GAME_CONSTANTS.NETWORK_UPDATE_INTERVAL) {
                    this._lastNetworkUpdate = now;
                    Network.sendPosition();
                }
            }

            // v1.04: Apply camera shake before rendering
            const cameraBasePos = camera.position.clone();
            cameraShake.apply(camera);

            // Render
            renderer.render(scene, camera);

            // v1.04: Restore camera position after shake
            camera.position.copy(cameraBasePos);

            requestAnimationFrame(gameLoop);
        }

        /**
         * v1.03: Update player movement with keyboard and touch input support
         * @param {number} delta - Delta time in seconds
         */
        function updatePlayerMovement(delta) {
            // v1.03: Combine keyboard and touch input
            let keyInput = Input.getMovementInput();
            let touchInput = TouchInput.getMovementInput();

            // Use touch input if active, otherwise keyboard
            const { forward, right } = TouchInput.enabled && TouchInput.joystick.active
                ? touchInput
                : keyInput;

            // No sprint in Halo 2 - crouch only
            PlayerController.isSprinting = false;

            // Crouch
            PlayerController.isCrouching = Input.keys['ControlLeft'] || Input.keys['ShiftLeft'];

            // Calculate move speed
            let speed = PlayerController.moveSpeed;
            if (PlayerController.isCrouching) speed *= GAME_CONSTANTS.CROUCH_SPEED_MULTIPLIER;

            // Movement direction relative to camera
            const moveDir = new THREE.Vector3();

            if (forward !== 0 || right !== 0) {
                moveDir.x = right;
                moveDir.z = -forward;
                moveDir.normalize();

                // Rotate by player yaw (fixed rotation direction)
                const cos = Math.cos(PlayerController.rotationY);
                const sin = Math.sin(PlayerController.rotationY);
                const rx = moveDir.x * cos + moveDir.z * sin;
                const rz = -moveDir.x * sin + moveDir.z * cos;
                moveDir.x = rx;
                moveDir.z = rz;
            }

            // Apply horizontal movement
            PlayerController.velocity.x = moveDir.x * speed;
            PlayerController.velocity.z = moveDir.z * speed;

            // v1.03: Jump - Halo 2 style floaty physics with crouch jump bonus
            if (Input.keys['Space'] && PlayerController.isGrounded) {
                // Crouch jumping gives extra height like in Halo 2
                const crouchJumpBonus = PlayerController.isCrouching ? GAME_CONSTANTS.CROUCH_JUMP_BONUS : 1.0;
                PlayerController.velocity.y = PlayerController.jumpForce * crouchJumpBonus;
                PlayerController.isGrounded = false;
                AudioSystem.playJump();
            }

            // Apply gravity
            PlayerController.velocity.y -= PlayerController.gravity * delta;

            // Move position
            const newPos = PlayerController.position.clone();
            newPos.x += PlayerController.velocity.x * delta;
            newPos.y += PlayerController.velocity.y * delta;
            newPos.z += PlayerController.velocity.z * delta;

            // Ground collision
            const groundY = LockoutMap.getGroundHeight(newPos.x, newPos.z, newPos.y + 2);
            const playerHeight = PlayerController.isCrouching ? 1.2 : 1.8;

            if (newPos.y <= groundY + playerHeight) {
                newPos.y = groundY + playerHeight;
                PlayerController.velocity.y = 0;
                PlayerController.isGrounded = true;
            } else {
                PlayerController.isGrounded = false;
            }

            // Kill zone check (fell off map)
            if (newPos.y < -40) {
                PlayerController.takeDamage(1000, null); // Instant death
            }

            // Wall collision detection
            const wallPush = LockoutMap.checkWallCollision(newPos, 0.4);
            newPos.x += wallPush.x;
            newPos.z += wallPush.z;

            // Gravity lift check
            if (LockoutMap.checkGravLift(newPos)) {
                PlayerController.velocity.y = 15; // Strong upward lift
                PlayerController.isGrounded = false;
            }

            PlayerController.position.copy(newPos);

            // Footstep sounds
            if (PlayerController.isGrounded && (forward !== 0 || right !== 0)) {
                const footstepInterval = PlayerController.isCrouching ? 0.6 : 0.45;
                if (Date.now() / 1000 - lastFootstepTime > footstepInterval) {
                    AudioSystem.playFootstep();
                    lastFootstepTime = Date.now() / 1000;
                }
            }
        }

        /**
         * v1.03: Update player camera rotation based on mouse/touch input
         * @param {number} delta - Delta time in seconds
         */
        function updatePlayerCamera(delta) {
            // Mouse look
            const { dx, dy } = Input.consumeMouseDelta();
            const sensitivity = gameData.settings.sensitivity * 0.001;

            PlayerController.rotationY -= dx * sensitivity;
            PlayerController.rotationX -= dy * sensitivity;

            // Clamp pitch
            PlayerController.rotationX = Math.max(-Math.PI / 2 + 0.1,
                                          Math.min(Math.PI / 2 - 0.1, PlayerController.rotationX));

            // Update camera
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            const zoom = weapon ? weapon.getZoom() : 1;
            camera.fov = 75 / zoom;
            camera.updateProjectionMatrix();

            // Position camera at player eye level
            const eyeHeight = PlayerController.isCrouching ? 1.0 : 1.6;
            camera.position.set(
                PlayerController.position.x,
                PlayerController.position.y + eyeHeight - 1.8, // Adjust for player height
                PlayerController.position.z
            );

            // Apply rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = PlayerController.rotationY;
            camera.rotation.x = PlayerController.rotationX;
        }

        function updateCombat(delta) {
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            if (!weapon) return;

            // Handle burst fire
            if (weapon.burstRemaining > 0) {
                burstTimer -= delta;
                if (burstTimer <= 0) {
                    if (weapon.processBurst()) {
                        AudioSystem.playWeaponFire(weapon.type);
                        performShot(weapon);
                        burstTimer = weapon.config.burstDelay;

                        // v1.04: Camera shake for weapon fire
                        const weaponShake = weapon.type === 'SNIPER' ? GAME_CONSTANTS.CAMERA_SHAKE_WEAPON * 3 :
                                           weapon.type === 'SHOTGUN' ? GAME_CONSTANTS.CAMERA_SHAKE_WEAPON * 2 :
                                           weapon.type === 'ROCKET' ? GAME_CONSTANTS.CAMERA_SHAKE_WEAPON * 4 :
                                           GAME_CONSTANTS.CAMERA_SHAKE_WEAPON;
                        cameraShake.shake(weaponShake);

                        // v1.04: Muzzle flash particles
                        if (particleSystem) {
                            const muzzlePos = camera.position.clone();
                            const direction = new THREE.Vector3(
                                -Math.sin(PlayerController.rotationY) * Math.cos(PlayerController.rotationX),
                                Math.sin(PlayerController.rotationX),
                                -Math.cos(PlayerController.rotationY) * Math.cos(PlayerController.rotationX)
                            );
                            muzzlePos.add(direction.multiplyScalar(0.5));
                            particleSystem.spawnMuzzleFlash(muzzlePos, direction.normalize());
                        }

                        // Apply weapon recoil animation
                        const recoilAmount = weapon.type === 'SNIPER' ? 0.25 :
                                           weapon.type === 'SHOTGUN' ? 0.2 :
                                           weapon.type === 'ROCKET' ? 0.3 :
                                           weapon.type === 'SMG' ? 0.05 : 0.1;
                        ViewModelSystem.applyRecoil(recoilAmount);

                        // Network
                        if (GameState.isMultiplayer) {
                            Network.sendShoot(weapon.type, {
                                x: -Math.sin(PlayerController.rotationY) * Math.cos(PlayerController.rotationX),
                                y: Math.sin(PlayerController.rotationX),
                                z: -Math.cos(PlayerController.rotationY) * Math.cos(PlayerController.rotationX)
                            });
                        }
                    }
                }
            }

            // Fire weapon
            if (Input.mouse.buttons[0]) { // Left click
                if (weapon.config.automatic || !this.lastFirePressed) {
                    if (weapon.fire()) {
                        burstTimer = 0; // Start burst immediately
                    }
                }
                this.lastFirePressed = true;
            } else {
                this.lastFirePressed = false;
            }
        }

        /**
         * v1.03: Update shield regeneration system
         * Shields regenerate after SHIELD_REGEN_DELAY seconds without taking damage
         * @param {number} delta - Delta time in seconds
         */
        function updateShieldRegen(delta) {
            const now = performance.now() / 1000;
            const timeSinceDamage = now - PlayerController.lastDamageTime;

            if (timeSinceDamage >= GAME_CONSTANTS.SHIELD_REGEN_DELAY &&
                PlayerController.shield < GAME_CONSTANTS.SHIELD_MAX &&
                !PlayerController.isDead) {

                // Play recharge sound at start of regen
                if (PlayerController.shield === 0 ||
                    (PlayerController.shield < 10 && timeSinceDamage < PlayerController.shieldRegenDelay + 0.1)) {
                    AudioSystem.playShieldRecharge();
                }

                PlayerController.shield = Math.min(
                    PlayerController.maxShield,
                    PlayerController.shield + GAME_CONSTANTS.SHIELD_REGEN_RATE * delta
                );

                updateHealthUI();
            }
        }

        // v1.01: Clean up all tracked timers to prevent memory leaks
        function cleanupTimers() {
            // Clear respawn interval
            if (GameState.timers.respawnInterval) {
                clearInterval(GameState.timers.respawnInterval);
                GameState.timers.respawnInterval = null;
            }

            // Clear all kill feed timeouts
            // v1.08: Updated for Set-based timeout tracking
            GameState.timers.killFeedTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            GameState.timers.killFeedTimeouts.clear();
        }

        function endMatch() {
            GameState.isRunning = false;
            gameData.stats.gamesPlayed++;

            // v1.01: Clean up timers before ending
            cleanupTimers();

            // Check for win
            const highestKills = Math.max(...Array.from(GameState.players.values()).map(p => p.kills), PlayerController.kills || 0);
            if ((PlayerController.kills || 0) === highestKills) {
                gameData.stats.wins++;
            }

            saveData();

            // v1.07: Show match end screen with comprehensive stats
            showMatchEndScreen();

            // Show end screen (simplified - return to menu)
            alert(`Match Over!\nYour Score: ${PlayerController.kills || 0} kills`);
            location.reload();
        }

        // ============================================================
        // MENU FUNCTIONS
        // ============================================================

        function showJoinDialog() {
            document.getElementById('join-dialog').classList.add('visible');
        }

        function hideJoinDialog() {
            document.getElementById('join-dialog').classList.remove('visible');
        }

        // v1.02: Enhanced with loading indicators and better error handling
        async function createLobby() {
            const playerName = document.getElementById('player-name').value || 'Spartan';

            // v1.02: Validate player name
            if (!playerName.trim()) {
                showToast('Please enter a Spartan name', 'warning');
                document.getElementById('player-name').focus();
                return;
            }

            gameData.settings.name = playerName;
            saveData();

            showLoading(true, 'CREATING LOBBY...');

            try {
                const code = await Network.createLobby();

                // Add self to player list
                GameState.players.set(Network.peer.id, {
                    id: Network.peer.id,
                    name: playerName,
                    team: document.getElementById('team-select').value,
                    isHost: true,
                    kills: 0,
                    deaths: 0
                });

                document.getElementById('lobby-code-display').textContent = code;
                document.getElementById('lobby-section').style.display = 'block';
                Network.updateLobbyUI();

                GameState.isMultiplayer = true;
                showToast('Lobby created successfully!', 'success');
            } catch (err) {
                console.error('Lobby creation error:', err);
                showToast('Failed to create lobby: ' + err.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // v1.02: Enhanced with validation and better feedback
        async function joinLobby() {
            const code = document.getElementById('join-code').value.trim().toUpperCase();

            // v1.02: Enhanced validation with specific feedback
            if (!code) {
                showToast('Please enter a lobby code', 'warning');
                document.getElementById('join-code').focus();
                return;
            }

            if (code.length !== 6) {
                showToast('Lobby code must be 6 characters', 'warning');
                document.getElementById('join-code').focus();
                return;
            }

            const playerName = document.getElementById('player-name').value || 'Spartan';

            if (!playerName.trim()) {
                showToast('Please enter a Spartan name', 'warning');
                document.getElementById('player-name').focus();
                return;
            }

            gameData.settings.name = playerName;
            saveData();

            showLoading(true, 'JOINING LOBBY...');

            try {
                await Network.joinLobby(code);

                hideJoinDialog();
                document.getElementById('lobby-code-display').textContent = code;
                document.getElementById('lobby-section').style.display = 'block';

                // Hide start button for non-hosts
                document.querySelector('.start-game').style.display = 'none';

                GameState.isMultiplayer = true;
                showToast('Successfully joined lobby!', 'success');
            } catch (err) {
                console.error('Lobby join error:', err);
                showToast('Failed to join lobby: ' + err.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        function cancelLobby() {
            Network.cleanup();
            document.getElementById('lobby-section').style.display = 'none';
            GameState.players.clear();
            GameState.isMultiplayer = false;
        }

        function startMultiplayerGame() {
            if (!Network.isHost) return;

            // Broadcast game start
            Network.broadcast({ type: 'gameStart' });

            startGame();
        }

        function startSinglePlayer() {
            const playerName = document.getElementById('player-name').value || 'Spartan';
            gameData.settings.name = playerName;
            saveData();

            GameState.isMultiplayer = false;

            // Add some bots for practice
            for (let i = 0; i < 3; i++) {
                const botId = 'bot_' + i;
                const spawn = GameState.spawnPoints[i % GameState.spawnPoints.length];
                GameState.players.set(botId, {
                    id: botId,
                    name: 'Bot ' + (i + 1),
                    team: 'none',
                    position: { x: spawn.x, y: spawn.y + 2, z: spawn.z },
                    rotation: { x: 0, y: Math.random() * Math.PI * 2 },
                    kills: 0,
                    deaths: 0,
                    shield: 100,
                    health: 100,
                    weapon: 'BR55'
                });
            }

            startGame();
        }

        function startGame() {
            // Hide menu
            document.getElementById('menu-screen').classList.add('hidden');

            // Show HUD
            document.getElementById('hud').style.display = 'block';

            // Initialize player
            const spawn = GameState.spawnPoints[Math.floor(Math.random() * GameState.spawnPoints.length)];
            PlayerController.position.set(spawn.x, spawn.y + 2, spawn.z);
            PlayerController.weapons = [new Weapon('BR55')];
            PlayerController.kills = 0;

            // Initialize weapon pickups
            WeaponPickups.init();

            // Start networking updates
            if (GameState.isMultiplayer) {
                Network.startPingLoop();
            }

            // Start game
            GameState.isRunning = true;
            GameState.matchTime = 600; // 10 minutes

            // v1.04: Start ambient audio for atmosphere
            AudioSystem.startAmbient();

            // Request pointer lock
            document.getElementById('game-container').requestPointerLock();

            // Start game loop
            gameLoop();
        }

        // ============================================================
        // INITIALIZE ON LOAD
        // ============================================================

        window.addEventListener('load', initGame);

        // v1.01: Cleanup on page unload - prevents memory leaks
        window.addEventListener('beforeunload', () => {
            cleanupTimers();
            Network.cleanup();
        });
    </script>
</body>
</html>
