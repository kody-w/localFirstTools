<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo 2 Lockout - Multiplayer FPS</title>
    <meta name="description" content="Multiplayer first-person shooter inspired by Halo 2's iconic Lockout map with WebRTC P2P networking">
    <!-- 3d, fps, multiplayer, webrtc, game, shooter -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        /* Menu Screens */
        #menu-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a1628 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #menu-screen.hidden { display: none; }

        .menu-title {
            font-size: 64px;
            font-weight: bold;
            color: #5af;
            text-shadow: 0 0 30px #0af, 0 0 60px #05a;
            margin-bottom: 10px;
            letter-spacing: 8px;
        }

        .menu-subtitle {
            font-size: 24px;
            color: #8bf;
            margin-bottom: 40px;
            letter-spacing: 4px;
        }

        .menu-section {
            background: rgba(20, 40, 80, 0.8);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 30px;
            margin: 10px;
            min-width: 420px;
            box-shadow: 0 0 30px rgba(50, 150, 255, 0.3);
        }

        .section-title {
            font-size: 18px;
            color: #5af;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-input {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            background: rgba(0, 20, 50, 0.8);
            border: 1px solid #3af;
            color: #fff;
            font-size: 16px;
            border-radius: 4px;
            outline: none;
            transition: all 0.3s;
        }

        .menu-input:focus {
            border-color: #5cf;
            box-shadow: 0 0 15px rgba(50, 150, 255, 0.5);
        }

        .menu-button {
            width: 100%;
            padding: 16px;
            margin: 8px 0;
            background: linear-gradient(180deg, #2a5a9a 0%, #1a3a6a 100%);
            border: 2px solid #4af;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .menu-button:hover {
            background: linear-gradient(180deg, #3a7aca 0%, #2a5a9a 100%);
            box-shadow: 0 0 20px rgba(50, 150, 255, 0.5);
            transform: scale(1.02);
        }

        .menu-button:active { transform: scale(0.98); }

        .menu-button.secondary {
            background: rgba(50, 50, 50, 0.5);
            border-color: #666;
        }

        .menu-button.start-game {
            background: linear-gradient(180deg, #2a9a5a 0%, #1a6a3a 100%);
            border-color: #4fa;
        }

        #lobby-code-display {
            font-size: 36px;
            font-weight: bold;
            color: #5cf;
            text-align: center;
            margin: 15px 0;
            letter-spacing: 8px;
            text-shadow: 0 0 20px #0af;
        }

        #lobby-players {
            max-height: 200px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .lobby-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: rgba(0, 40, 80, 0.5);
            border-radius: 4px;
            border-left: 3px solid #3af;
        }

        .lobby-player.ready { border-left-color: #4fa; }
        .lobby-player .host-badge {
            background: #fa0;
            color: #000;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        /* Game Canvas Container */
        #game-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .crosshair-br {
            width: 40px; height: 40px;
        }

        .crosshair-br .dot {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 4px; height: 4px;
            background: #fff;
            border-radius: 50%;
        }

        .crosshair-br .line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair-br .line.top { width: 2px; height: 10px; top: 2px; left: 50%; transform: translateX(-50%); }
        .crosshair-br .line.bottom { width: 2px; height: 10px; bottom: 2px; left: 50%; transform: translateX(-50%); }
        .crosshair-br .line.left { width: 10px; height: 2px; left: 2px; top: 50%; transform: translateY(-50%); }
        .crosshair-br .line.right { width: 10px; height: 2px; right: 2px; top: 50%; transform: translateY(-50%); }

        /* Shield/Health Bar - Halo Style */
        #shield-container {
            position: fixed;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            width: 400px;
        }

        #shield-bar {
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #48f;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #shield-fill {
            height: 100%;
            background: linear-gradient(180deg, #6cf 0%, #48f 50%, #26a 100%);
            transition: width 0.15s;
            position: relative;
        }

        #shield-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
        }

        #shield-segments {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
        }

        .shield-segment {
            flex: 1;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
        }

        #health-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #a33;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        #health-fill {
            height: 100%;
            background: linear-gradient(180deg, #f44 0%, #a22 100%);
            transition: width 0.15s;
        }

        /* Shield Damage Flash */
        #shield-flash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(100, 180, 255, 0.4) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        #shield-flash.active { opacity: 1; }
        #shield-flash.broken {
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255, 50, 50, 0.5) 100%);
        }

        /* Weapon Display */
        #weapon-display {
            position: fixed;
            bottom: 30px; right: 30px;
            text-align: right;
        }

        #weapon-name {
            font-size: 14px;
            color: #8bf;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #ammo-display {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        #ammo-display .reserve {
            font-size: 24px;
            color: #8bf;
        }

        /* Kill Feed */
        #kill-feed {
            position: fixed;
            top: 80px; right: 20px;
            width: 350px;
        }

        .kill-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 14px;
            animation: killSlideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .kill-item .killer { color: #5cf; }
        .kill-item .victim { color: #f55; }
        .kill-item .weapon-icon {
            margin: 0 8px;
            color: #aaa;
            font-size: 12px;
        }

        @keyframes killSlideIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Scoreboard */
        #scoreboard {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.95);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 20px;
            min-width: 500px;
            display: none;
            z-index: 200;
        }

        #scoreboard.visible { display: block; }

        #scoreboard h2 {
            text-align: center;
            color: #5cf;
            margin-bottom: 20px;
            font-size: 24px;
            letter-spacing: 4px;
        }

        .scoreboard-header, .scoreboard-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(50, 150, 255, 0.3);
        }

        .scoreboard-header {
            color: #8bf;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .scoreboard-row.local { background: rgba(50, 150, 255, 0.2); }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 20px; left: 20px;
            width: 180px; height: 180px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #3af;
            border-radius: 4px;
        }

        #minimap-canvas {
            width: 100%; height: 100%;
        }

        /* Timer */
        #match-timer {
            position: fixed;
            top: 55px; left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: #8bf;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        /* Score Display */
        #score-display {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #3af;
        }

        #score-display .label {
            font-size: 12px;
            color: #8bf;
            text-transform: uppercase;
        }

        #score-display .value {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
        }

        /* Hit Marker */
        #hit-marker {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
        }

        #hit-marker.active { opacity: 1; }
        #hit-marker.kill { color: #f44; }

        .hit-marker-line {
            position: absolute;
            width: 15px; height: 3px;
            background: #fff;
        }

        .hit-marker-line:nth-child(1) { transform: rotate(45deg) translate(8px, 8px); }
        .hit-marker-line:nth-child(2) { transform: rotate(-45deg) translate(-8px, 8px); }
        .hit-marker-line:nth-child(3) { transform: rotate(135deg) translate(8px, -8px); }
        .hit-marker-line:nth-child(4) { transform: rotate(-135deg) translate(-8px, -8px); }

        /* Respawn Screen */
        #respawn-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
        }

        #respawn-screen.visible { display: flex; }

        #respawn-screen h1 {
            font-size: 48px;
            color: #f44;
            margin-bottom: 20px;
        }

        #respawn-timer {
            font-size: 72px;
            color: #fff;
        }

        /* Instructions Overlay */
        #instructions {
            position: fixed;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #8bf;
            text-align: center;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px; left: 10px;
            z-index: 1001;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            padding: 8px 14px;
            background: rgba(30, 60, 100, 0.8);
            border: 1px solid #3af;
            color: #8bf;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: rgba(50, 100, 150, 0.8);
            color: #fff;
        }

        /* Weapon Pickup Indicator */
        #weapon-pickup {
            position: fixed;
            bottom: 200px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border: 1px solid #5cf;
            border-radius: 4px;
            display: none;
            text-align: center;
        }

        #weapon-pickup.visible { display: block; }

        #weapon-pickup .key {
            display: inline-block;
            background: #3af;
            color: #000;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            margin-right: 8px;
        }

        /* Scope Overlay */
        #scope-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center,
                transparent 20%,
                rgba(0, 0, 0, 0.95) 35%,
                #000 40%);
            display: none;
            pointer-events: none;
            z-index: 90;
        }

        #scope-overlay.active { display: block; }

        .scope-crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }

        .scope-line {
            position: absolute;
            background: rgba(255, 0, 0, 0.7);
        }

        .scope-line.h {
            width: 800px; height: 1px;
            left: -400px; top: 0;
        }

        .scope-line.v {
            width: 1px; height: 600px;
            top: -300px; left: 0;
        }

        /* Connection Status */
        #connection-status {
            position: fixed;
            top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        #connection-status.connected { border-left: 3px solid #4fa; }
        #connection-status.connecting { border-left: 3px solid #fa0; }
        #connection-status.error { border-left: 3px solid #f44; }

        /* Join Dialog */
        #join-dialog {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.98);
            border: 2px solid #3af;
            border-radius: 8px;
            padding: 30px;
            z-index: 1002;
            display: none;
        }

        #join-dialog.visible { display: block; }
    </style>
</head>
<body>
    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Stats</button>
        <button onclick="document.getElementById('importFile').click()">Import Stats</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Menu Screen -->
    <div id="menu-screen">
        <h1 class="menu-title">LOCKOUT</h1>
        <p class="menu-subtitle">HALO 2 TRIBUTE</p>

        <div class="menu-section">
            <div class="section-title">Spartan Setup</div>
            <input type="text" id="player-name" class="menu-input" placeholder="Enter Spartan name" maxlength="16">
            <select id="team-select" class="menu-input">
                <option value="none">Free For All</option>
                <option value="red">Red Team</option>
                <option value="blue">Blue Team</option>
            </select>
            <button class="menu-button" onclick="createLobby()">Host Game</button>
            <button class="menu-button secondary" onclick="showJoinDialog()">Join Game</button>
            <button class="menu-button secondary" onclick="startSinglePlayer()">Practice (Offline)</button>
        </div>

        <div id="lobby-section" class="menu-section" style="display: none;">
            <div class="section-title">Game Lobby</div>
            <p style="text-align: center; margin-bottom: 10px;">Share this code with friends:</p>
            <div id="lobby-code-display"></div>
            <div id="lobby-players"></div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="menu-button start-game" onclick="startMultiplayerGame()" style="flex: 2;">START GAME</button>
                <button class="menu-button secondary" onclick="cancelLobby()" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Join Dialog -->
    <div id="join-dialog">
        <div class="section-title">Join Game</div>
        <input type="text" id="join-code" class="menu-input" placeholder="Enter lobby code" maxlength="6" style="text-transform: uppercase;">
        <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button class="menu-button" onclick="joinLobby()">Join</button>
            <button class="menu-button secondary" onclick="hideJoinDialog()">Cancel</button>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container"></div>

    <!-- HUD -->
    <div id="hud">
        <!-- Shield Flash -->
        <div id="shield-flash"></div>

        <!-- Shield/Health -->
        <div id="shield-container">
            <div id="shield-bar">
                <div id="shield-fill" style="width: 100%;"></div>
                <div id="shield-segments">
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                    <div class="shield-segment"></div>
                </div>
            </div>
            <div id="health-bar">
                <div id="health-fill" style="width: 100%;"></div>
            </div>
        </div>

        <!-- Timer -->
        <div id="match-timer">10:00</div>

        <!-- Score -->
        <div id="score-display">
            <div class="label">Score</div>
            <div class="value" id="player-score">0</div>
        </div>

        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-br">
                <div class="dot"></div>
                <div class="line top"></div>
                <div class="line bottom"></div>
                <div class="line left"></div>
                <div class="line right"></div>
            </div>
        </div>

        <!-- Hit Marker -->
        <div id="hit-marker">
            <div class="hit-marker-line"></div>
            <div class="hit-marker-line"></div>
            <div class="hit-marker-line"></div>
            <div class="hit-marker-line"></div>
        </div>

        <!-- Weapon Display -->
        <div id="weapon-display">
            <div id="weapon-name">BR55 Battle Rifle</div>
            <div id="ammo-display">
                <span id="current-ammo">36</span>
                <span class="reserve">/ <span id="reserve-ammo">108</span></span>
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas" width="176" height="176"></canvas>
        </div>

        <!-- Kill Feed -->
        <div id="kill-feed"></div>

        <!-- Weapon Pickup -->
        <div id="weapon-pickup">
            <span class="key">E</span> Pick up <span id="pickup-weapon-name">Sniper Rifle</span>
        </div>

        <!-- Instructions -->
        <div id="instructions">
            WASD: Move | Mouse: Aim | LMB: Shoot | R: Reload | Space: Jump | Shift/Ctrl: Crouch | Tab: Scoreboard
        </div>
    </div>

    <!-- Scope Overlay -->
    <div id="scope-overlay">
        <div class="scope-crosshair">
            <div class="scope-line h"></div>
            <div class="scope-line v"></div>
        </div>
    </div>

    <!-- Scoreboard -->
    <div id="scoreboard">
        <h2>SCOREBOARD</h2>
        <div class="scoreboard-header">
            <span>Player</span>
            <span>Kills</span>
            <span>Deaths</span>
            <span>Score</span>
        </div>
        <div id="scoreboard-rows"></div>
    </div>

    <!-- Respawn Screen -->
    <div id="respawn-screen">
        <h1>YOU DIED</h1>
        <div id="killed-by"></div>
        <div id="respawn-timer">5</div>
    </div>

    <!-- Connection Status -->
    <div id="connection-status">
        <span id="peer-count">0</span> players | <span id="ping">--</span>ms
    </div>

    <!-- PeerJS for WebRTC signaling -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============================================================
        // HALO 2 LOCKOUT - MULTIPLAYER FPS
        // A tribute to Bungie's iconic arena shooter
        // ============================================================

        const APP_NAME = 'halo-lockout-fps';
        let gameData = JSON.parse(localStorage.getItem(APP_NAME) || JSON.stringify({
            stats: { kills: 0, deaths: 0, gamesPlayed: 0, wins: 0 },
            settings: { sensitivity: 2.5, volume: 0.7, name: 'Spartan' },
            achievements: []
        }));

        // Save/Load functions
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(gameData));
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.stats) {
                        gameData = imported;
                        saveData();
                        alert('Stats imported successfully!');
                    }
                } catch (err) {
                    alert('Invalid file format');
                }
            };
            reader.readAsText(file);
        }

        // ============================================================
        // GAME STATE
        // ============================================================

        const GameState = {
            // Core state
            isRunning: false,
            isPaused: false,
            isMultiplayer: false,

            // Networking
            peer: null,
            connections: new Map(),
            isHost: false,
            lobbyCode: '',

            // Local player
            localPlayer: null,

            // All players (including local)
            players: new Map(),

            // Match state
            matchTime: 600, // 10 minutes
            killLimit: 25,
            gameMode: 'slayer',

            // Weapons on map
            weaponPickups: [],

            // Spawn points
            spawnPoints: [],

            // v1.01: Timer registry for proper cleanup
            timers: {
                respawnInterval: null,
                killFeedTimeouts: []
            }
        };

        // ============================================================
        // THREE.JS SETUP
        // ============================================================

        let scene, camera, renderer;
        let clock = new THREE.Clock();

        // v1.01: Player controller with authentic Halo 2 movement physics
        const PlayerController = {
            // Position
            position: new THREE.Vector3(0, 5, 0),
            velocity: new THREE.Vector3(),

            // Rotation (Euler)
            rotationX: 0, // Pitch
            rotationY: 0, // Yaw

            // v1.01: Authentic Halo 2 movement - floaty jumps, no sprint
            moveSpeed: 6.5, // v1.01: Slightly slower base speed (Halo 2 feels deliberate)
            sprintMultiplier: 1.0, // v1.01: No sprint in Halo 2
            jumpForce: 7.5, // v1.01: Lower initial jump for floaty arc
            gravity: 12, // v1.01: Lower gravity for floaty Halo feel

            // State
            isGrounded: false,
            isCrouching: false,
            isSprinting: false,
            isScoped: false,

            // Combat
            shield: 100,
            health: 100,
            maxShield: 100,
            maxHealth: 100,
            shieldRegenDelay: 4, // seconds
            shieldRegenRate: 25, // per second
            lastDamageTime: 0,
            isDead: false,

            // Weapons
            weapons: [],
            currentWeaponIndex: 0,

            // Input state
            keys: {},
            mouse: { x: 0, y: 0, buttons: {} }
        };

        // ============================================================
        // WEAPONS SYSTEM
        // ============================================================

        // ============================================================
        // MODEL BUILDER - Creates 3D models from JSON definitions
        // ============================================================

        const ModelBuilder = {
            // Build a 3D model from JSON bodyParts definition
            buildFromDefinition(definition, scale = 1) {
                const group = new THREE.Group();

                if (!definition.bodyParts) return group;

                definition.bodyParts.forEach(part => {
                    const mesh = this.createPart(part, scale);
                    if (mesh) {
                        group.add(mesh);
                    }
                });

                return group;
            },

            createPart(part, scale) {
                let geometry;
                const s = scale;

                switch (part.shape) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            (part.width || 0.1) * s,
                            (part.height || 0.1) * s,
                            (part.depth || 0.1) * s
                        );
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            (part.radiusTop || 0.05) * s,
                            (part.radiusBottom || 0.05) * s,
                            (part.height || 0.1) * s,
                            part.segments || 12
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(
                            (part.size || 0.05) * s,
                            part.segments || 12,
                            part.segments || 12
                        );
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(
                            (part.size || 0.05) * s,
                            (part.height || 0.1) * s,
                            part.segments || 12
                        );
                        break;
                    default:
                        return null;
                }

                // Parse color
                const color = typeof part.color === 'string' ?
                    parseInt(part.color.replace('#', '0x')) : part.color;
                const emissiveColor = part.emissive ?
                    (typeof part.emissive === 'string' ?
                        parseInt(part.emissive.replace('#', '0x')) : part.emissive) : 0x000000;

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: part.metalness !== undefined ? part.metalness : 0.5,
                    roughness: part.roughness !== undefined ? part.roughness : 0.5,
                    emissive: emissiveColor,
                    emissiveIntensity: part.emissiveIntensity || 0.5
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Position
                if (part.position) {
                    mesh.position.set(
                        part.position[0] * s,
                        part.position[1] * s,
                        part.position[2] * s
                    );
                }

                // Rotation (convert degrees to radians)
                if (part.rotation) {
                    mesh.rotation.set(
                        (part.rotation[0] || 0) * Math.PI / 180,
                        (part.rotation[1] || 0) * Math.PI / 180,
                        (part.rotation[2] || 0) * Math.PI / 180
                    );
                }

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = part.name;

                return mesh;
            }
        };

        // ============================================================
        // HALO WEAPON MODEL DEFINITIONS
        // ============================================================

        const WeaponModels = {
            BR55: {
                name: "BR55 Battle Rifle",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Stock
                    { name: "stock", shape: "box", width: 0.06, height: 0.08, depth: 0.25,
                      color: "#2a2a2a", position: [0, 0, -0.2], metalness: 0.3, roughness: 0.7 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.04, height: 0.1, depth: 0.06,
                      color: "#1a1a1a", position: [0, -0.06, 0], rotation: [15, 0, 0], metalness: 0.2, roughness: 0.8 },
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.08, height: 0.1, depth: 0.35,
                      color: "#3a3a3a", position: [0, 0.03, 0.05], metalness: 0.6, roughness: 0.4 },
                    // Magazine
                    { name: "magazine", shape: "box", width: 0.035, height: 0.12, depth: 0.08,
                      color: "#444444", position: [0, -0.06, 0.1], metalness: 0.5, roughness: 0.5 },
                    // Barrel shroud
                    { name: "barrelShroud", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.04, height: 0.25,
                      color: "#2a2a2a", position: [0, 0.03, 0.35], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.3 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.15,
                      color: "#1a1a1a", position: [0, 0.03, 0.52], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Scope mount
                    { name: "scopeMount", shape: "box", width: 0.04, height: 0.025, depth: 0.12,
                      color: "#333333", position: [0, 0.1, 0.05], metalness: 0.5, roughness: 0.5 },
                    // Scope body
                    { name: "scopeBody", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.025, height: 0.15,
                      color: "#222222", position: [0, 0.13, 0.05], rotation: [90, 0, 0], metalness: 0.4, roughness: 0.6 },
                    // Scope lens front
                    { name: "scopeLensFront", shape: "sphere", size: 0.02,
                      color: "#00aaff", position: [0, 0.13, 0.13], emissive: "#0066aa", metalness: 0.9, roughness: 0.1 },
                    // Scope lens back
                    { name: "scopeLensBack", shape: "sphere", size: 0.015,
                      color: "#ff4400", position: [0, 0.13, -0.02], emissive: "#ff2200", metalness: 0.9, roughness: 0.1 },
                    // Muzzle brake
                    { name: "muzzle", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.02, height: 0.04,
                      color: "#1a1a1a", position: [0, 0.03, 0.62], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Ammo counter
                    { name: "ammoCounter", shape: "box", width: 0.02, height: 0.015, depth: 0.03,
                      color: "#00ff00", position: [0.04, 0.06, 0.02], emissive: "#00aa00", metalness: 0.3, roughness: 0.5 }
                ]
            },

            SNIPER: {
                name: "SRS99C-S2 AM Sniper Rifle",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Stock
                    { name: "stock", shape: "box", width: 0.05, height: 0.12, depth: 0.35,
                      color: "#1a1a1a", position: [0, -0.02, -0.35], metalness: 0.4, roughness: 0.6 },
                    // Cheek rest
                    { name: "cheekRest", shape: "box", width: 0.04, height: 0.04, depth: 0.15,
                      color: "#2a2a2a", position: [0, 0.04, -0.25], metalness: 0.3, roughness: 0.7 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.035, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.08, 0], rotation: [12, 0, 0], metalness: 0.2, roughness: 0.8 },
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.08, height: 0.1, depth: 0.45,
                      color: "#2a2a2a", position: [0, 0.02, 0.1], metalness: 0.6, roughness: 0.4 },
                    // Magazine
                    { name: "magazine", shape: "box", width: 0.04, height: 0.15, depth: 0.06,
                      color: "#333333", position: [0, -0.08, 0.15], metalness: 0.5, roughness: 0.5 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.03, height: 0.6,
                      color: "#1a1a1a", position: [0, 0.02, 0.65], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Barrel fluting
                    { name: "barrelFlute1", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.4,
                      color: "#0a0a0a", position: [0.02, 0.02, 0.55], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Muzzle brake
                    { name: "muzzleBrake", shape: "cylinder", radiusTop: 0.04, radiusBottom: 0.03, height: 0.08,
                      color: "#1a1a1a", position: [0, 0.02, 0.99], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Scope body
                    { name: "scopeBody", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.04, height: 0.3,
                      color: "#1a1a2a", position: [0, 0.12, 0.1], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Scope adjustment
                    { name: "scopeAdjust", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.03,
                      color: "#2a2a2a", position: [0.04, 0.12, 0.1], rotation: [0, 0, 90], metalness: 0.6, roughness: 0.4 },
                    // Scope lens front
                    { name: "scopeLensFront", shape: "sphere", size: 0.03,
                      color: "#4488ff", position: [0, 0.12, 0.26], emissive: "#2266cc", metalness: 0.9, roughness: 0.1 },
                    // Scope lens back
                    { name: "scopeLensBack", shape: "sphere", size: 0.025,
                      color: "#ff6600", position: [0, 0.12, -0.04], emissive: "#cc4400", metalness: 0.9, roughness: 0.1 },
                    // Bipod leg left
                    { name: "bipodL", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.01, height: 0.12,
                      color: "#333333", position: [-0.03, -0.06, 0.4], rotation: [20, 0, -15], metalness: 0.7, roughness: 0.3 },
                    // Bipod leg right
                    { name: "bipodR", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.01, height: 0.12,
                      color: "#333333", position: [0.03, -0.06, 0.4], rotation: [20, 0, 15], metalness: 0.7, roughness: 0.3 }
                ]
            },

            SMG: {
                name: "M7 SMG",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.06, height: 0.12, depth: 0.2,
                      color: "#3a3a3a", position: [0, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.035, height: 0.1, depth: 0.045,
                      color: "#2a2a2a", position: [0, -0.08, -0.02], rotation: [10, 0, 0], metalness: 0.3, roughness: 0.7 },
                    // Magazine (curved)
                    { name: "magazine", shape: "box", width: 0.04, height: 0.15, depth: 0.03,
                      color: "#444444", position: [0, -0.1, 0.06], rotation: [-15, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Barrel shroud
                    { name: "barrelShroud", shape: "cylinder", radiusTop: 0.03, radiusBottom: 0.035, height: 0.15,
                      color: "#2a2a2a", position: [0, 0, 0.18], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.1,
                      color: "#1a1a1a", position: [0, 0, 0.3], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Front sight
                    { name: "frontSight", shape: "box", width: 0.01, height: 0.03, depth: 0.01,
                      color: "#1a1a1a", position: [0, 0.04, 0.22], metalness: 0.5, roughness: 0.5 },
                    // Rear sight
                    { name: "rearSight", shape: "box", width: 0.025, height: 0.025, depth: 0.01,
                      color: "#1a1a1a", position: [0, 0.07, -0.05], metalness: 0.5, roughness: 0.5 },
                    // Charging handle
                    { name: "chargingHandle", shape: "box", width: 0.015, height: 0.02, depth: 0.04,
                      color: "#333333", position: [0.035, 0.03, 0.02], metalness: 0.6, roughness: 0.4 },
                    // Stock folded
                    { name: "stock", shape: "box", width: 0.02, height: 0.06, depth: 0.1,
                      color: "#2a2a2a", position: [0, 0.02, -0.15], metalness: 0.4, roughness: 0.6 },
                    // Flashlight
                    { name: "flashlight", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.06,
                      color: "#333333", position: [0, -0.04, 0.15], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Flashlight lens
                    { name: "flashlightLens", shape: "sphere", size: 0.012,
                      color: "#ffff88", position: [0, -0.04, 0.19], emissive: "#aaaa44", metalness: 0.8, roughness: 0.2 }
                ]
            },

            PISTOL: {
                name: "M6D Pistol",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Slide
                    { name: "slide", shape: "box", width: 0.035, height: 0.045, depth: 0.18,
                      color: "#2a2a2a", position: [0, 0.025, 0.02], metalness: 0.7, roughness: 0.3 },
                    // Frame
                    { name: "frame", shape: "box", width: 0.03, height: 0.035, depth: 0.12,
                      color: "#1a1a1a", position: [0, -0.005, -0.01], metalness: 0.5, roughness: 0.5 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.03, height: 0.1, depth: 0.04,
                      color: "#1a1a1a", position: [0, -0.06, -0.04], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    // Magazine
                    { name: "magazine", shape: "box", width: 0.025, height: 0.08, depth: 0.03,
                      color: "#333333", position: [0, -0.06, -0.035], metalness: 0.5, roughness: 0.5 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.08,
                      color: "#1a1a1a", position: [0, 0.015, 0.15], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Scope
                    { name: "scope", shape: "cylinder", radiusTop: 0.018, radiusBottom: 0.02, height: 0.08,
                      color: "#222222", position: [0, 0.065, 0.02], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    // Scope lens
                    { name: "scopeLens", shape: "sphere", size: 0.015,
                      color: "#ff4400", position: [0, 0.065, 0.065], emissive: "#ff2200", metalness: 0.9, roughness: 0.1 },
                    // Trigger guard
                    { name: "triggerGuard", shape: "box", width: 0.025, height: 0.01, depth: 0.04,
                      color: "#1a1a1a", position: [0, -0.025, 0.02], metalness: 0.5, roughness: 0.5 },
                    // Trigger
                    { name: "trigger", shape: "box", width: 0.008, height: 0.025, depth: 0.01,
                      color: "#333333", position: [0, -0.02, 0.015], metalness: 0.6, roughness: 0.4 }
                ]
            },

            SHOTGUN: {
                name: "M90 Shotgun",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Stock
                    { name: "stock", shape: "box", width: 0.05, height: 0.1, depth: 0.25,
                      color: "#1a1a1a", position: [0, 0, -0.25], metalness: 0.3, roughness: 0.8 },
                    // Receiver
                    { name: "receiver", shape: "box", width: 0.06, height: 0.1, depth: 0.25,
                      color: "#2a2a2a", position: [0, 0, 0.02], metalness: 0.5, roughness: 0.5 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.04, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.08, -0.02], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.025, height: 0.5,
                      color: "#1a1a1a", position: [0, 0.02, 0.4], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Magazine tube
                    { name: "magTube", shape: "cylinder", radiusTop: 0.02, radiusBottom: 0.02, height: 0.35,
                      color: "#2a2a2a", position: [0, -0.03, 0.32], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Pump grip
                    { name: "pumpGrip", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.035, height: 0.12,
                      color: "#333333", position: [0, -0.015, 0.25], rotation: [90, 0, 0], metalness: 0.4, roughness: 0.7 },
                    // Pump ridges
                    { name: "pumpRidge1", shape: "box", width: 0.04, height: 0.005, depth: 0.01,
                      color: "#222222", position: [0, -0.015, 0.21], metalness: 0.5, roughness: 0.5 },
                    { name: "pumpRidge2", shape: "box", width: 0.04, height: 0.005, depth: 0.01,
                      color: "#222222", position: [0, -0.015, 0.24], metalness: 0.5, roughness: 0.5 },
                    { name: "pumpRidge3", shape: "box", width: 0.04, height: 0.005, depth: 0.01,
                      color: "#222222", position: [0, -0.015, 0.27], metalness: 0.5, roughness: 0.5 },
                    // Front sight
                    { name: "frontSight", shape: "box", width: 0.01, height: 0.025, depth: 0.01,
                      color: "#ff4400", position: [0, 0.045, 0.6], emissive: "#ff2200", metalness: 0.5, roughness: 0.5 },
                    // Flashlight
                    { name: "flashlight", shape: "cylinder", radiusTop: 0.02, radiusBottom: 0.02, height: 0.08,
                      color: "#333333", position: [0, -0.05, 0.45], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 }
                ]
            },

            ROCKET: {
                name: "M41 Rocket Launcher",
                type: "item",
                category: "weapon",
                bodyParts: [
                    // Twin tubes
                    { name: "tubeLeft", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.06, height: 0.8,
                      color: "#3a4a3a", position: [-0.05, 0, 0.25], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.6 },
                    { name: "tubeRight", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.06, height: 0.8,
                      color: "#3a4a3a", position: [0.05, 0, 0.25], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.6 },
                    // Tube caps front
                    { name: "capFrontL", shape: "cylinder", radiusTop: 0.055, radiusBottom: 0.06, height: 0.03,
                      color: "#2a3a2a", position: [-0.05, 0, 0.66], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    { name: "capFrontR", shape: "cylinder", radiusTop: 0.055, radiusBottom: 0.06, height: 0.03,
                      color: "#2a3a2a", position: [0.05, 0, 0.66], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Grip assembly
                    { name: "gripHousing", shape: "box", width: 0.08, height: 0.1, depth: 0.15,
                      color: "#2a2a2a", position: [0, -0.05, -0.05], metalness: 0.4, roughness: 0.6 },
                    // Grip
                    { name: "grip", shape: "box", width: 0.04, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.12, -0.08], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    // Shoulder rest
                    { name: "shoulderRest", shape: "box", width: 0.12, height: 0.08, depth: 0.12,
                      color: "#2a2a2a", position: [0, 0.02, -0.2], metalness: 0.4, roughness: 0.7 },
                    // Scope housing
                    { name: "scopeHousing", shape: "box", width: 0.06, height: 0.08, depth: 0.12,
                      color: "#2a3a2a", position: [0, 0.08, 0.05], metalness: 0.5, roughness: 0.5 },
                    // Scope screen
                    { name: "scopeScreen", shape: "box", width: 0.04, height: 0.04, depth: 0.01,
                      color: "#00ff44", position: [0, 0.1, -0.01], emissive: "#00aa22", metalness: 0.3, roughness: 0.3 },
                    // Targeting laser
                    { name: "laser", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.008, height: 0.04,
                      color: "#ff0000", position: [0, 0.06, 0.15], rotation: [90, 0, 0], emissive: "#ff0000", metalness: 0.5, roughness: 0.3 },
                    // Warning stripe
                    { name: "warningStripe", shape: "box", width: 0.15, height: 0.01, depth: 0.05,
                      color: "#ffaa00", position: [0, 0.065, 0.5], metalness: 0.4, roughness: 0.6 }
                ]
            }
        };

        // ============================================================
        // SPARTAN PLAYER MODEL DEFINITION
        // ============================================================

        const SpartanModel = {
            name: "Spartan Soldier",
            type: "character",
            bodyParts: [
                // Torso
                { name: "torso", shape: "box", width: 0.5, height: 0.6, depth: 0.3,
                  color: "#4a6a4a", position: [0, 0.9, 0], metalness: 0.4, roughness: 0.6 },
                // Chest plate
                { name: "chestPlate", shape: "box", width: 0.52, height: 0.35, depth: 0.15,
                  color: "#3a5a3a", position: [0, 1.05, 0.12], metalness: 0.6, roughness: 0.4 },
                // Shoulder left
                { name: "shoulderL", shape: "box", width: 0.2, height: 0.15, depth: 0.2,
                  color: "#4a6a4a", position: [-0.35, 1.15, 0], metalness: 0.5, roughness: 0.5 },
                // Shoulder right
                { name: "shoulderR", shape: "box", width: 0.2, height: 0.15, depth: 0.2,
                  color: "#4a6a4a", position: [0.35, 1.15, 0], metalness: 0.5, roughness: 0.5 },
                // Upper arm left
                { name: "upperArmL", shape: "cylinder", radiusTop: 0.08, radiusBottom: 0.07, height: 0.3,
                  color: "#3a5a3a", position: [-0.35, 0.85, 0], metalness: 0.4, roughness: 0.6 },
                // Upper arm right
                { name: "upperArmR", shape: "cylinder", radiusTop: 0.08, radiusBottom: 0.07, height: 0.3,
                  color: "#3a5a3a", position: [0.35, 0.85, 0], metalness: 0.4, roughness: 0.6 },
                // Forearm left
                { name: "forearmL", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.07, height: 0.25,
                  color: "#4a6a4a", position: [-0.35, 0.55, 0], metalness: 0.5, roughness: 0.5 },
                // Forearm right
                { name: "forearmR", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.07, height: 0.25,
                  color: "#4a6a4a", position: [0.35, 0.55, 0], metalness: 0.5, roughness: 0.5 },
                // Waist
                { name: "waist", shape: "box", width: 0.4, height: 0.15, depth: 0.25,
                  color: "#2a4a2a", position: [0, 0.55, 0], metalness: 0.4, roughness: 0.6 },
                // Upper leg left
                { name: "upperLegL", shape: "cylinder", radiusTop: 0.1, radiusBottom: 0.08, height: 0.4,
                  color: "#3a5a3a", position: [-0.12, 0.28, 0], metalness: 0.4, roughness: 0.6 },
                // Upper leg right
                { name: "upperLegR", shape: "cylinder", radiusTop: 0.1, radiusBottom: 0.08, height: 0.4,
                  color: "#3a5a3a", position: [0.12, 0.28, 0], metalness: 0.4, roughness: 0.6 },
                // Lower leg left
                { name: "lowerLegL", shape: "cylinder", radiusTop: 0.07, radiusBottom: 0.08, height: 0.35,
                  color: "#4a6a4a", position: [-0.12, -0.1, 0], metalness: 0.5, roughness: 0.5 },
                // Lower leg right
                { name: "lowerLegR", shape: "cylinder", radiusTop: 0.07, radiusBottom: 0.08, height: 0.35,
                  color: "#4a6a4a", position: [0.12, -0.1, 0], metalness: 0.5, roughness: 0.5 },
                // Boot left
                { name: "bootL", shape: "box", width: 0.1, height: 0.1, depth: 0.18,
                  color: "#2a3a2a", position: [-0.12, -0.32, 0.02], metalness: 0.4, roughness: 0.7 },
                // Boot right
                { name: "bootR", shape: "box", width: 0.1, height: 0.1, depth: 0.18,
                  color: "#2a3a2a", position: [0.12, -0.32, 0.02], metalness: 0.4, roughness: 0.7 },
                // Helmet
                { name: "helmet", shape: "sphere", size: 0.2,
                  color: "#4a6a4a", position: [0, 1.45, 0], metalness: 0.5, roughness: 0.5 },
                // Visor
                { name: "visor", shape: "sphere", size: 0.15,
                  color: "#ffaa00", position: [0, 1.43, 0.1], emissive: "#ff8800", emissiveIntensity: 0.4, metalness: 0.9, roughness: 0.1 }
            ]
        };

        // ============================================================
        // FIRST PERSON WEAPON VIEW MODEL SYSTEM
        // ============================================================

        const ViewModelSystem = {
            weaponGroup: null,
            currentWeaponType: null,
            bobTime: 0,
            recoilOffset: 0,
            swayX: 0,
            swayY: 0,

            init(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.weaponGroup = new THREE.Group();
                this.weaponGroup.name = 'viewModel';

                // Create weapon container that follows camera
                this.container = new THREE.Group();
                this.container.add(this.weaponGroup);
                scene.add(this.container);
            },

            setWeapon(weaponType) {
                if (this.currentWeaponType === weaponType) return;

                // Clear existing weapon
                while (this.weaponGroup.children.length > 0) {
                    this.weaponGroup.remove(this.weaponGroup.children[0]);
                }

                // Get model definition
                const modelDef = WeaponModels[weaponType];
                if (!modelDef) return;

                // Build weapon model at viewmodel scale
                const weaponModel = ModelBuilder.buildFromDefinition(modelDef, 1.5);
                this.weaponGroup.add(weaponModel);

                // Position for first person view
                this.weaponGroup.position.set(0.25, -0.2, -0.5);
                this.weaponGroup.rotation.set(0, Math.PI, 0);

                this.currentWeaponType = weaponType;
            },

            update(delta, playerVelocity, isMoving, isCrouching, isAiming) {
                if (!this.weaponGroup || !this.camera) return;

                // Update container to follow camera
                this.container.position.copy(this.camera.position);
                this.container.rotation.copy(this.camera.rotation);

                // Weapon bob when moving (Halo 2 style - no sprint)
                if (isMoving) {
                    const bobSpeed = isCrouching ? 6 : 8;
                    this.bobTime += delta * bobSpeed;
                    const bobAmount = isCrouching ? 0.008 : 0.015;
                    const bobX = Math.sin(this.bobTime) * bobAmount;
                    const bobY = Math.abs(Math.cos(this.bobTime)) * bobAmount * 0.7;
                    this.weaponGroup.position.x = 0.25 + bobX;
                    this.weaponGroup.position.y = -0.2 + bobY;
                } else {
                    // Subtle idle sway
                    this.bobTime += delta * 2;
                    const idleSway = Math.sin(this.bobTime * 0.5) * 0.003;
                    this.weaponGroup.position.x = 0.25 + idleSway;
                    this.weaponGroup.position.y = -0.2 + Math.sin(this.bobTime * 0.7) * 0.002;
                }

                // Aim down sights position
                if (isAiming) {
                    this.weaponGroup.position.lerp(new THREE.Vector3(0, -0.15, -0.4), delta * 10);
                } else {
                    this.weaponGroup.position.x = THREE.MathUtils.lerp(this.weaponGroup.position.x, 0.25, delta * 5);
                }

                // Recoil recovery
                this.recoilOffset *= 0.9;
                this.weaponGroup.rotation.x = this.recoilOffset;
            },

            applyRecoil(amount = 0.1) {
                this.recoilOffset = -amount;
            },

            hide() {
                if (this.container) this.container.visible = false;
            },

            show() {
                if (this.container) this.container.visible = true;
            }
        };

        // v1.01: Authentic Halo 2 weapon balance - BR is 4-shot kill (3 bursts body + 1 headshot)
        // Shield = 100, Health = 100. Total = 200 damage to kill.
        // BR: 36 damage/burst (12 per bullet x 3), 4 bursts to kill = 144 body + headshot burst
        // Sniper: 100 body (2-shot kill), 200 headshot (1-shot kill)
        const WeaponTypes = {
            BR55: {
                name: 'BR55 Battle Rifle',
                shortName: 'BR55',
                // v1.01: Authentic Halo 2 BR - 4 bursts to kill (3 body + 1 headshot or 6 body)
                damage: 36, // Per burst (3 rounds x 12 damage each)
                headshotMultiplier: 1.5, // Headshot burst = 54 damage
                fireRate: 0.5, // Seconds between bursts - authentic Halo 2 timing
                burstCount: 3,
                burstDelay: 0.05,
                magSize: 36,
                reserveMax: 108,
                reloadTime: 2.1,
                range: 100,
                spread: 0.008, // v1.01: Tighter spread for competitive BR play
                automatic: false,
                scopeZoom: 2,
                modelColor: 0x444444
            },
            SNIPER: {
                name: 'SRS99C-S2 AM Sniper',
                shortName: 'Sniper',
                // v1.01: Authentic Halo 2 sniper - 1-shot headshot, 2-shot body
                damage: 101, // Just over half total health+shield for 2-shot body kill
                headshotMultiplier: 2, // 202 damage = instant kill on headshot
                fireRate: 0.8, // v1.01: Faster fire rate like Halo 2
                burstCount: 1,
                burstDelay: 0,
                magSize: 4,
                reserveMax: 20,
                reloadTime: 2.5, // v1.01: Slightly faster reload
                range: 500,
                spread: 0,
                automatic: false,
                scopeZoom: 5,
                scopeZoom2: 10,
                modelColor: 0x333333
            },
            SMG: {
                name: 'M7 SMG',
                shortName: 'SMG',
                // v1.01: SMG is weaker but faster - dual wield secondary
                damage: 7,
                headshotMultiplier: 1.15,
                fireRate: 0.05,
                burstCount: 1,
                burstDelay: 0,
                magSize: 60,
                reserveMax: 180,
                reloadTime: 1.8,
                range: 25, // v1.01: Shorter effective range
                spread: 0.08, // v1.01: More spread for close range weapon
                automatic: true,
                scopeZoom: 0,
                modelColor: 0x555555
            },
            PISTOL: {
                name: 'M6C Magnum', // v1.01: Halo 2 uses M6C, not M6D
                shortName: 'Magnum',
                // v1.01: Halo 2 pistol is weaker than Halo CE
                damage: 18,
                headshotMultiplier: 1.5,
                fireRate: 0.25, // v1.01: Faster fire rate
                burstCount: 1,
                burstDelay: 0,
                magSize: 12,
                reserveMax: 48,
                reloadTime: 1.3,
                range: 50, // v1.01: Reduced range from CE
                spread: 0.02,
                automatic: false,
                scopeZoom: 0, // v1.01: Halo 2 magnum has no scope
                modelColor: 0x444444
            },
            SHOTGUN: {
                name: 'M90 Shotgun',
                shortName: 'Shotgun',
                // v1.01: Shotgun pellets - devastating at close range
                damage: 18, // Per pellet, 12 pellets = 216 max damage (1-shot potential)
                headshotMultiplier: 1.1,
                fireRate: 0.9, // v1.01: Slightly faster pump
                burstCount: 1,
                burstDelay: 0,
                magSize: 12,
                reserveMax: 36,
                reloadTime: 0.5, // Per shell
                range: 12, // v1.01: Shorter range - true close quarters
                spread: 0.18, // v1.01: Wider spread
                automatic: false,
                scopeZoom: 0,
                pelletCount: 12,
                modelColor: 0x333333
            },
            ROCKET: {
                name: 'M41 SPNKr',
                shortName: 'Rockets',
                // v1.01: Rockets are instant kill in blast radius
                damage: 250,
                headshotMultiplier: 1,
                fireRate: 2.0, // v1.01: Slightly faster
                burstCount: 1,
                burstDelay: 0,
                magSize: 2,
                reserveMax: 6,
                reloadTime: 3.5, // v1.01: Faster reload
                range: 200,
                spread: 0,
                automatic: false,
                scopeZoom: 2,
                splashRadius: 6, // v1.01: Larger splash radius
                modelColor: 0x445544
            }
        };

        class Weapon {
            constructor(type) {
                this.type = type;
                this.config = WeaponTypes[type];
                this.currentAmmo = this.config.magSize;
                this.reserveAmmo = this.config.reserveMax;
                this.lastFireTime = 0;
                this.isReloading = false;
                this.reloadStartTime = 0;
                this.burstRemaining = 0;
                this.scopeLevel = 0; // 0 = no scope, 1 = first zoom, 2 = second zoom
            }

            canFire() {
                const now = performance.now() / 1000;
                return !this.isReloading &&
                       this.currentAmmo > 0 &&
                       now - this.lastFireTime >= this.config.fireRate &&
                       this.burstRemaining === 0;
            }

            fire() {
                if (!this.canFire()) return false;

                this.lastFireTime = performance.now() / 1000;
                this.burstRemaining = this.config.burstCount;
                return true;
            }

            processBurst() {
                if (this.burstRemaining > 0 && this.currentAmmo > 0) {
                    this.currentAmmo--;
                    this.burstRemaining--;
                    return true;
                }
                return false;
            }

            reload() {
                if (this.isReloading || this.currentAmmo === this.config.magSize || this.reserveAmmo === 0) {
                    return false;
                }

                this.isReloading = true;
                this.reloadStartTime = performance.now() / 1000;
                this.scopeLevel = 0; // Exit scope on reload
                return true;
            }

            updateReload() {
                if (!this.isReloading) return;

                const now = performance.now() / 1000;
                if (now - this.reloadStartTime >= this.config.reloadTime) {
                    const needed = this.config.magSize - this.currentAmmo;
                    const available = Math.min(needed, this.reserveAmmo);
                    this.currentAmmo += available;
                    this.reserveAmmo -= available;
                    this.isReloading = false;
                }
            }

            toggleScope() {
                if (this.config.scopeZoom === 0) return;

                if (this.config.scopeZoom2) {
                    this.scopeLevel = (this.scopeLevel + 1) % 3;
                } else {
                    this.scopeLevel = this.scopeLevel === 0 ? 1 : 0;
                }
            }

            getZoom() {
                if (this.scopeLevel === 0) return 1;
                if (this.scopeLevel === 1) return this.config.scopeZoom;
                return this.config.scopeZoom2 || this.config.scopeZoom;
            }
        }

        // ============================================================
        // LOCKOUT MAP GEOMETRY
        // ============================================================

        // ============================================================
        // LOCKOUT MAP - Accurate Recreation of Halo 2's Lockout
        // ============================================================

        const LockoutMap = {
            // Collision data
            platforms: [],  // Floor/ceiling collision
            walls: [],      // Wall collision

            // Gravity lift at center of BR tower
            gravLift: { x: 0, y: -2, z: 0, topY: 12, radius: 2.5, active: true },

            // Weapon spawns matching actual Lockout locations
            weaponSpawns: [
                { pos: { x: 0, y: 12.5, z: 0 }, weapon: 'BR55' },      // BR Tower top
                { pos: { x: -25, y: 9, z: 0 }, weapon: 'SNIPER' },     // Sniper Tower 1
                { pos: { x: 25, y: 9, z: 0 }, weapon: 'SNIPER' },      // Sniper Tower 2
                { pos: { x: 18, y: 3, z: 18 }, weapon: 'SMG' },        // Library
                { pos: { x: -18, y: 3, z: 18 }, weapon: 'SMG' },       // Elbow
                { pos: { x: 0, y: -2, z: 0 }, weapon: 'ROCKET' },      // Sword room (center bottom)
                { pos: { x: 0, y: 6, z: -20 }, weapon: 'SHOTGUN' },    // Blue hall
                { pos: { x: 15, y: 3, z: -15 }, weapon: 'PISTOL' }     // BR3
            ],

            // Spawn points on solid ground
            spawnPoints: [
                { x: 2, y: 12.5, z: 2 },       // BR Tower top
                { x: -2, y: 12.5, z: -2 },     // BR Tower top
                { x: -23, y: 9, z: 2 },        // Sniper 1
                { x: 23, y: 9, z: -2 },        // Sniper 2
                { x: 16, y: 3, z: 16 },        // Library
                { x: -16, y: 3, z: 16 },       // Elbow
                { x: 0, y: 6, z: -18 },        // Blue room
                { x: 0, y: -2, z: 8 }          // Bottom mid
            ],

            build(scene) {
                // v1.01: Authentic Forerunner/Lockout materials - cold, icy metal with purple/blue accents
                const floorMat = new THREE.MeshStandardMaterial({
                    color: 0x4a5a6a, metalness: 0.7, roughness: 0.35 // Slightly brighter, more metallic
                });
                const wallMat = new THREE.MeshStandardMaterial({
                    color: 0x3a4a5a, metalness: 0.75, roughness: 0.25 // Colder gray-blue metal
                });
                const accentMat = new THREE.MeshStandardMaterial({
                    color: 0x5577bb, metalness: 0.85, roughness: 0.15, // Forerunner blue-purple
                    emissive: 0x223366, emissiveIntensity: 0.4 // Brighter glow
                });
                const glassMat = new THREE.MeshStandardMaterial({
                    color: 0x7799dd, metalness: 0.3, roughness: 0.05,
                    transparent: true, opacity: 0.4 // More transparent, icy look
                });
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0x88bbff, transparent: true, opacity: 0.85 // Brighter Forerunner glow
                });

                // === HELPER FUNCTIONS ===

                // Create floor platform with collision
                const addFloor = (x, y, z, w, d, mat = floorMat) => {
                    const h = 0.5;
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x, y - h/2, z);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    scene.add(mesh);

                    this.platforms.push({
                        minX: x - w/2, maxX: x + w/2,
                        minY: y - h, maxY: y,
                        minZ: z - d/2, maxZ: z + d/2,
                        isFloor: true
                    });
                };

                // Create wall with collision
                const addWall = (x, y, z, w, h, d, mat = wallMat) => {
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x, y + h/2, z);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    scene.add(mesh);

                    this.walls.push({
                        minX: x - w/2, maxX: x + w/2,
                        minY: y, maxY: y + h,
                        minZ: z - d/2, maxZ: z + d/2
                    });
                };

                // Create ramp (series of steps)
                const addRamp = (x1, y1, z1, x2, y2, z2, width, steps = 12) => {
                    const dx = (x2 - x1) / steps;
                    const dy = (y2 - y1) / steps;
                    const dz = (z2 - z1) / steps;
                    const stepLen = Math.sqrt(dx*dx + dz*dz) * 1.3;

                    for (let i = 0; i < steps; i++) {
                        const x = x1 + dx * i;
                        const y = y1 + dy * i;
                        const z = z1 + dz * i;
                        addFloor(x, y, z, width, stepLen);
                    }
                };

                // Add glow strip
                const addGlow = (x, y, z, w, d) => {
                    const geo = new THREE.BoxGeometry(w, 0.05, d);
                    const mesh = new THREE.Mesh(geo, glowMat);
                    mesh.position.set(x, y, z);
                    scene.add(mesh);
                };

                // === BUILD THE MAP ===
                // Lockout is roughly symmetric, centered on BR Tower
                // Coordinate system: +X = right, +Z = forward (toward Library), -Z = back (toward Blue)

                // 
                // BOTTOM LEVEL (y = -2 to 0) - Sword Room / Bottom Mid
                // 

                // Central bottom floor (under BR tower)
                addFloor(0, -2, 0, 16, 16);

                // Bottom mid extensions
                addFloor(0, -2, 12, 10, 8);   // Toward library side
                addFloor(0, -2, -12, 10, 8);  // Toward blue side

                // Walls around bottom
                addWall(-8, -2, 0, 0.5, 4, 16);
                addWall(8, -2, 0, 0.5, 4, 16);
                addWall(0, -2, -16, 16, 4, 0.5);

                // Pillars supporting BR tower
                addWall(-4, -2, -4, 2, 8, 2, accentMat);
                addWall(4, -2, -4, 2, 8, 2, accentMat);
                addWall(-4, -2, 4, 2, 8, 2, accentMat);
                addWall(4, -2, 4, 2, 8, 2, accentMat);

                // 
                // MID LEVEL (y = 3 to 6) - Library, Elbow, Walkways
                // 

                // Library platform (right side, +X +Z)
                addFloor(18, 3, 18, 12, 12);
                // Library walls
                addWall(24, 3, 18, 0.5, 4, 12);        // Back wall
                addWall(18, 3, 24, 12, 4, 0.5);        // Side wall
                addWall(12, 3, 21, 0.5, 4, 6);         // Front partial

                // Elbow platform (left side, -X +Z) - mirrors Library
                addFloor(-18, 3, 18, 12, 12);
                // Elbow walls
                addWall(-24, 3, 18, 0.5, 4, 12);
                addWall(-18, 3, 24, 12, 4, 0.5);
                addWall(-12, 3, 21, 0.5, 4, 6);

                // BR2 / Center walkway (connects to BR tower)
                addFloor(0, 3, 14, 8, 6);

                // BR3 platform (right side toward blue)
                addFloor(15, 3, -15, 10, 10);
                addWall(20, 3, -15, 0.5, 3, 10);
                addWall(15, 3, -20, 10, 3, 0.5);

                // Connector walkways
                addFloor(10, 3, 5, 6, 14);   // Library to BR3
                addFloor(-10, 3, 5, 6, 14);  // Elbow to other side

                // Ramps from bottom to mid
                addRamp(-6, -2, 10, -6, 3, 16, 4, 10);  // Left ramp
                addRamp(6, -2, 10, 6, 3, 16, 4, 10);    // Right ramp

                // 
                // BLUE ROOM / GLASS HALL (y = 6)
                // 

                // Blue room floor
                addFloor(0, 6, -20, 16, 10);

                // Blue room walls with windows
                addWall(-8, 6, -20, 0.5, 4, 10);
                addWall(8, 6, -20, 0.5, 4, 10);
                addWall(0, 6, -25, 16, 4, 0.5);

                // Glass windows
                addWall(-4, 8, -15, 0.3, 2, 1, glassMat);
                addWall(4, 8, -15, 0.3, 2, 1, glassMat);

                // Ramp from BR3 to Blue
                addRamp(10, 3, -12, 6, 6, -16, 4, 8);

                // 
                // SNIPER TOWERS (y = 6 to 12)
                // 

                // Sniper Tower 1 (left, -X)
                addFloor(-25, 6, 0, 8, 10);    // Base
                addFloor(-25, 9, 0, 6, 8);     // Top platform
                addWall(-29, 6, 0, 0.5, 6, 10);  // Back wall
                addWall(-25, 6, -5, 8, 6, 0.5);  // Side wall
                addWall(-25, 6, 5, 8, 6, 0.5);   // Side wall
                // Ramp up
                addRamp(-21, 6, 3, -23, 9, 0, 3, 6);

                // Sniper Tower 2 (right, +X) - mirrors Tower 1
                addFloor(25, 6, 0, 8, 10);
                addFloor(25, 9, 0, 6, 8);
                addWall(29, 6, 0, 0.5, 6, 10);
                addWall(25, 6, -5, 8, 6, 0.5);
                addWall(25, 6, 5, 8, 6, 0.5);
                addRamp(21, 6, -3, 23, 9, 0, 3, 6);

                // Walkways to sniper towers
                addFloor(-18, 6, 6, 6, 6);    // Left connector
                addFloor(18, 6, -6, 6, 6);    // Right connector

                // 
                // BR TOWER (y = 6 to 14) - Central Tower
                // 

                // BR Tower base platform
                addFloor(0, 6, 0, 10, 10);

                // BR Tower mid level
                addFloor(0, 9, 0, 8, 8);

                // BR Tower top (where BR spawns)
                addFloor(0, 12, 0, 10, 10);

                // Tower roof/cover
                addFloor(0, 16, 0, 8, 8, accentMat);

                // BR Tower walls (partial cover)
                addWall(-5, 12, 0, 0.5, 4, 10);
                addWall(5, 12, 0, 0.5, 4, 10);

                // Ramps up to BR tower
                addRamp(-4, 3, 10, -3, 6, 4, 3, 8);   // From BR2
                addRamp(4, 6, 4, 3, 9, 2, 3, 6);      // Mid to upper
                addRamp(-3, 9, -2, -2, 12, 0, 3, 6);  // Upper to top

                // 
                // TOP MID / CATWALK (y = 10 to 12)
                // 

                // Top walkway connecting sniper towers
                addFloor(-12, 10, -8, 8, 6);
                addFloor(12, 10, -8, 8, 6);
                addFloor(0, 10, -10, 10, 6);

                // Railings (short walls)
                addWall(-12, 10, -11, 8, 1.2, 0.3);
                addWall(12, 10, -11, 8, 1.2, 0.3);

                // Connections from sniper towers to top
                addRamp(-20, 9, -3, -14, 10, -6, 3, 6);
                addRamp(20, 9, -3, 14, 10, -6, 3, 6);

                // 
                // GRAVITY LIFT (center of bottom)
                // 

                this.gravLift = { x: 0, y: -2, z: 0, topY: 12, radius: 2, active: true };

                // Grav lift visual
                const liftGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 16);
                const liftMesh = new THREE.Mesh(liftGeo, glowMat);
                liftMesh.position.set(0, -1.8, 0);
                scene.add(liftMesh);

                // Lift beam (visual only)
                const beamGeo = new THREE.CylinderGeometry(0.8, 1.2, 14, 8, 1, true);
                const beamMat = new THREE.MeshBasicMaterial({
                    color: 0x66aaff, transparent: true, opacity: 0.15, side: THREE.DoubleSide
                });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.set(0, 5, 0);
                scene.add(beam);

                // 
                // DECORATIVE GLOW STRIPS
                // 

                addGlow(0, 12.1, 0, 8, 0.2);
                addGlow(0, 12.1, 0, 0.2, 8);
                addGlow(-25, 9.1, 0, 4, 0.2);
                addGlow(25, 9.1, 0, 4, 0.2);
                addGlow(0, 6.1, -20, 0.2, 8);

                // 
                // SKYBOX / ENVIRONMENT
                // 

                // v1.01: Snowy mountains in background - authentic Lockout backdrop
                const mountainMat = new THREE.MeshStandardMaterial({
                    color: 0x6a7a8a, roughness: 0.8, metalness: 0.1 // Snow-capped appearance
                });
                const snowCapMat = new THREE.MeshStandardMaterial({
                    color: 0xaabbcc, roughness: 0.6, metalness: 0.0 // Bright snow caps
                });
                for (let i = 0; i < 10; i++) { // v1.01: More mountains for fuller backdrop
                    const angle = (i / 10) * Math.PI * 2;
                    const dist = 140 + Math.random() * 60;
                    const height = 50 + Math.random() * 40;
                    const mtnGeo = new THREE.ConeGeometry(25 + Math.random() * 25, height, 5);
                    const mtn = new THREE.Mesh(mtnGeo, mountainMat);
                    mtn.position.set(Math.cos(angle) * dist, height/2 - 25, Math.sin(angle) * dist);
                    mtn.rotation.y = Math.random() * Math.PI;
                    scene.add(mtn);

                    // v1.01: Add snow cap to larger mountains
                    if (height > 60) {
                        const capGeo = new THREE.ConeGeometry(10, height * 0.3, 5);
                        const cap = new THREE.Mesh(capGeo, snowCapMat);
                        cap.position.set(Math.cos(angle) * dist, height * 0.7 - 10, Math.sin(angle) * dist);
                        cap.rotation.y = mtn.rotation.y;
                        scene.add(cap);
                    }
                }

                // Store spawn points
                GameState.spawnPoints = this.spawnPoints;
            },

            // v1.01: Check if player is in gravity lift - uses squared distance for performance
            checkGravLift(position) {
                if (!this.gravLift.active) return false;
                const dx = position.x - this.gravLift.x;
                const dz = position.z - this.gravLift.z;
                const distSq = dx * dx + dz * dz;
                const radiusSq = this.gravLift.radius * this.gravLift.radius;
                return distSq < radiusSq &&
                       position.y >= this.gravLift.y &&
                       position.y < this.gravLift.topY;
            },

            // Wall collision - returns push vector if colliding
            checkWallCollision(position, radius = 0.4) {
                const push = { x: 0, y: 0, z: 0 };

                for (const wall of this.walls) {
                    // Check if player overlaps wall
                    const overlapX = position.x + radius > wall.minX && position.x - radius < wall.maxX;
                    const overlapY = position.y + 1.8 > wall.minY && position.y < wall.maxY;
                    const overlapZ = position.z + radius > wall.minZ && position.z - radius < wall.maxZ;

                    if (overlapX && overlapY && overlapZ) {
                        // Calculate push direction (shortest exit)
                        const pushLeft = position.x - radius - wall.minX;
                        const pushRight = wall.maxX - (position.x + radius);
                        const pushBack = position.z - radius - wall.minZ;
                        const pushFront = wall.maxZ - (position.z + radius);

                        // Find smallest overlap
                        const minPush = Math.min(
                            Math.abs(pushLeft), Math.abs(pushRight),
                            Math.abs(pushBack), Math.abs(pushFront)
                        );

                        if (Math.abs(pushLeft) === minPush && pushLeft < 0) {
                            push.x = pushLeft - 0.01;
                        } else if (Math.abs(pushRight) === minPush && pushRight < 0) {
                            push.x = -pushRight + 0.01;
                        } else if (Math.abs(pushBack) === minPush && pushBack < 0) {
                            push.z = pushBack - 0.01;
                        } else if (Math.abs(pushFront) === minPush && pushFront < 0) {
                            push.z = -pushFront + 0.01;
                        }
                    }
                }

                return push;
            },

            // Ground height check
            getGroundHeight(x, z, currentY) {
                let groundY = -100;

                for (const plat of this.platforms) {
                    if (x >= plat.minX && x <= plat.maxX &&
                        z >= plat.minZ && z <= plat.maxZ) {
                        if (plat.maxY <= currentY + 0.5 && plat.maxY > groundY) {
                            groundY = plat.maxY;
                        }
                    }
                }

                return groundY;
            },

            // Head collision (ceiling)
            checkCeiling(x, z, headY) {
                for (const plat of this.platforms) {
                    if (x >= plat.minX && x <= plat.maxX &&
                        z >= plat.minZ && z <= plat.maxZ) {
                        if (plat.minY > headY - 0.2 && plat.minY < headY + 1) {
                            return plat.minY;
                        }
                    }
                }
                return null;
            }
        };

        // ============================================================
        // AUDIO SYSTEM
        // ============================================================

        const AudioSystem = {
            context: null,
            masterGain: null,

            init() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.connect(this.context.destination);
                this.masterGain.gain.value = gameData.settings.volume;
            },

            // Generate weapon sounds procedurally
            playWeaponFire(weaponType) {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Create oscillator for gunshot
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                filter.type = 'lowpass';

                switch (weaponType) {
                    case 'BR55':
                        // 3-round burst sound
                        osc.frequency.setValueAtTime(150, now);
                        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                        filter.frequency.value = 2000;
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        break;

                    case 'SNIPER':
                        // Deep, powerful shot
                        osc.frequency.setValueAtTime(80, now);
                        osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
                        filter.frequency.value = 1000;
                        gain.gain.setValueAtTime(0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                        break;

                    case 'SMG':
                        // Rapid fire crack
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.exponentialRampToValueAtTime(80, now + 0.05);
                        filter.frequency.value = 3000;
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        break;
                }

                // Add noise for texture
                const noise = this.createNoise(0.1);

                osc.connect(filter);
                filter.connect(gain);
                noise.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.5);
            },

            playShieldHit() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);

                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.2);
            },

            playShieldBreak() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);

                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.5);
            },

            playShieldRecharge() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.5);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.05, now + 0.5);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.7);
            },

            playKillSound() {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Medal sound - rising tone
                [400, 500, 600, 800].forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    gain.gain.setValueAtTime(0, now + i * 0.05);
                    gain.gain.linearRampToValueAtTime(0.15, now + i * 0.05 + 0.02);
                    gain.gain.linearRampToValueAtTime(0, now + i * 0.05 + 0.15);

                    osc.connect(gain);
                    gain.connect(this.masterGain);

                    osc.start(now);
                    osc.stop(now + 0.5);
                });
            },

            playReload() {
                if (!this.context) return;

                const now = this.context.currentTime;

                // Mag out
                const noise1 = this.createNoise(0.15);
                const gain1 = this.context.createGain();
                gain1.gain.setValueAtTime(0.1, now);
                gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                noise1.connect(gain1);
                gain1.connect(this.masterGain);

                // Mag in (delayed)
                setTimeout(() => {
                    const noise2 = this.createNoise(0.2);
                    const gain2 = this.context.createGain();
                    const now2 = this.context.currentTime;
                    gain2.gain.setValueAtTime(0.15, now2);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now2 + 0.2);
                    noise2.connect(gain2);
                    gain2.connect(this.masterGain);
                }, 500);
            },

            playFootstep() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const noise = this.createNoise(0.08);
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                filter.type = 'lowpass';
                filter.frequency.value = 500;

                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
            },

            playJump() {
                if (!this.context) return;

                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.2);
            },

            createNoise(duration) {
                const bufferSize = this.context.sampleRate * duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const source = this.context.createBufferSource();
                source.buffer = buffer;
                source.start();

                return source;
            }
        };

        // ============================================================
        // NETWORKING (WebRTC via PeerJS)
        // ============================================================

        const Network = {
            peer: null,
            connections: new Map(),
            isHost: false,
            lobbyCode: '',
            pingInterval: null,

            generateLobbyCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            },

            async createLobby() {
                this.lobbyCode = this.generateLobbyCode();
                this.isHost = true;

                return new Promise((resolve, reject) => {
                    // PeerJS uses the code as peer ID for simplicity
                    this.peer = new Peer('lockout-' + this.lobbyCode, {
                        debug: 1
                    });

                    this.peer.on('open', (id) => {
                        console.log('Lobby created:', this.lobbyCode);

                        // Listen for incoming connections
                        this.peer.on('connection', (conn) => {
                            this.handleNewConnection(conn);
                        });

                        resolve(this.lobbyCode);
                    });

                    this.peer.on('error', (err) => {
                        console.error('PeerJS error:', err);
                        reject(err);
                    });
                });
            },

            async joinLobby(code) {
                this.lobbyCode = code.toUpperCase();
                this.isHost = false;

                return new Promise((resolve, reject) => {
                    this.peer = new Peer(undefined, { debug: 1 });

                    this.peer.on('open', (id) => {
                        // Connect to host
                        const conn = this.peer.connect('lockout-' + this.lobbyCode, {
                            reliable: true
                        });

                        conn.on('open', () => {
                            this.handleNewConnection(conn);

                            // Send join message
                            conn.send({
                                type: 'join',
                                player: {
                                    id: this.peer.id,
                                    name: document.getElementById('player-name').value || 'Spartan',
                                    team: document.getElementById('team-select').value
                                }
                            });

                            resolve();
                        });

                        conn.on('error', reject);
                    });

                    this.peer.on('error', reject);
                });
            },

            handleNewConnection(conn) {
                console.log('New connection:', conn.peer);
                this.connections.set(conn.peer, conn);

                conn.on('data', (data) => {
                    this.handleMessage(conn.peer, data);
                });

                conn.on('close', () => {
                    console.log('Connection closed:', conn.peer);
                    this.connections.delete(conn.peer);
                    GameState.players.delete(conn.peer);
                    this.updateLobbyUI();
                });

                this.updateConnectionStatus();
            },

            handleMessage(peerId, data) {
                switch (data.type) {
                    case 'join':
                        // New player joined
                        GameState.players.set(peerId, {
                            ...data.player,
                            id: peerId,
                            position: { x: 0, y: 10, z: 0 },
                            rotation: { x: 0, y: 0 },
                            kills: 0,
                            deaths: 0,
                            shield: 100,
                            health: 100,
                            weapon: 'BR55'
                        });

                        // If host, broadcast updated player list
                        if (this.isHost) {
                            this.broadcast({
                                type: 'playerList',
                                players: Array.from(GameState.players.entries())
                            });
                        }

                        this.updateLobbyUI();
                        break;

                    case 'playerList':
                        // Update player list from host
                        GameState.players = new Map(data.players);
                        this.updateLobbyUI();
                        break;

                    case 'gameStart':
                        startGame();
                        break;

                    case 'position':
                        // Update player position
                        const player = GameState.players.get(peerId);
                        if (player) {
                            player.position = data.position;
                            player.rotation = data.rotation;
                            player.velocity = data.velocity;
                        }
                        break;

                    case 'shoot':
                        // Handle remote player shooting
                        this.handleRemoteShoot(peerId, data);
                        break;

                    case 'hit':
                        // Handle hit registration
                        if (data.targetId === this.peer.id) {
                            PlayerController.takeDamage(data.damage, peerId);
                        }
                        break;

                    case 'death':
                        // Player died
                        const deadPlayer = GameState.players.get(data.playerId);
                        if (deadPlayer) {
                            deadPlayer.deaths++;
                            addKillFeedEntry(data.killerName, deadPlayer.name, data.weapon);
                        }
                        const killer = GameState.players.get(data.killerId);
                        if (killer) {
                            killer.kills++;
                        }
                        break;

                    case 'respawn':
                        const respawnPlayer = GameState.players.get(peerId);
                        if (respawnPlayer) {
                            respawnPlayer.position = data.position;
                            respawnPlayer.shield = 100;
                            respawnPlayer.health = 100;
                        }
                        break;

                    case 'weaponPickup':
                        // Remove weapon from map
                        break;

                    case 'ping':
                        conn.send({ type: 'pong', timestamp: data.timestamp });
                        break;

                    case 'pong':
                        const ping = Date.now() - data.timestamp;
                        document.getElementById('ping').textContent = ping;
                        break;
                }
            },

            handleRemoteShoot(peerId, data) {
                // Visual effect for remote player shooting
                const player = GameState.players.get(peerId);
                if (player) {
                    // Muzzle flash, sound, etc.
                    AudioSystem.playWeaponFire(data.weapon);
                }
            },

            broadcast(data) {
                this.connections.forEach(conn => {
                    if (conn.open) {
                        conn.send(data);
                    }
                });
            },

            sendPosition() {
                this.broadcast({
                    type: 'position',
                    position: {
                        x: PlayerController.position.x,
                        y: PlayerController.position.y,
                        z: PlayerController.position.z
                    },
                    rotation: {
                        x: PlayerController.rotationX,
                        y: PlayerController.rotationY
                    },
                    velocity: {
                        x: PlayerController.velocity.x,
                        y: PlayerController.velocity.y,
                        z: PlayerController.velocity.z
                    }
                });
            },

            sendShoot(weapon, direction) {
                this.broadcast({
                    type: 'shoot',
                    weapon: weapon,
                    position: {
                        x: PlayerController.position.x,
                        y: PlayerController.position.y + 1.6,
                        z: PlayerController.position.z
                    },
                    direction: direction
                });
            },

            sendHit(targetId, damage) {
                this.broadcast({
                    type: 'hit',
                    targetId: targetId,
                    damage: damage
                });
            },

            sendDeath(killerId, killerName, weapon) {
                this.broadcast({
                    type: 'death',
                    playerId: this.peer.id,
                    killerId: killerId,
                    killerName: killerName,
                    weapon: weapon
                });
            },

            updateConnectionStatus() {
                const statusEl = document.getElementById('connection-status');
                const countEl = document.getElementById('peer-count');

                statusEl.style.display = 'block';
                statusEl.className = 'connected';
                countEl.textContent = this.connections.size + 1; // +1 for self
            },

            updateLobbyUI() {
                const container = document.getElementById('lobby-players');
                container.innerHTML = '';

                GameState.players.forEach((player, id) => {
                    const div = document.createElement('div');
                    div.className = 'lobby-player';
                    div.innerHTML = `
                        <span>${player.name}</span>
                        ${player.isHost ? '<span class="host-badge">HOST</span>' : ''}
                    `;
                    container.appendChild(div);
                });
            },

            startPingLoop() {
                this.pingInterval = setInterval(() => {
                    this.connections.forEach(conn => {
                        if (conn.open) {
                            conn.send({ type: 'ping', timestamp: Date.now() });
                        }
                    });
                }, 2000);
            },

            cleanup() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.connections.clear();
            }
        };

        // ============================================================
        // INPUT HANDLING
        // ============================================================

        const Input = {
            keys: {},
            mouse: { x: 0, y: 0, dx: 0, dy: 0, buttons: {} },
            isPointerLocked: false,

            init() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (GameState.isRunning) {
                        // Prevent default for game keys
                        if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space', 'ShiftLeft', 'ControlLeft', 'KeyR', 'KeyE', 'Tab'].includes(e.code)) {
                            e.preventDefault();
                        }

                        // Reload
                        if (e.code === 'KeyR') {
                            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                            if (weapon && weapon.reload()) {
                                AudioSystem.playReload();
                            }
                        }

                        // Weapon switch
                        if (e.code === 'Digit1') PlayerController.currentWeaponIndex = 0;
                        if (e.code === 'Digit2' && PlayerController.weapons.length > 1) PlayerController.currentWeaponIndex = 1;

                        // Scope toggle (right click or middle click alternative)
                        if (e.code === 'KeyZ') {
                            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                            if (weapon) weapon.toggleScope();
                        }

                        // v1.01: Tab for scoreboard using cached DOM
                        if (e.code === 'Tab') {
                            getUICache().scoreboard.classList.add('visible');
                        }

                        // Weapon pickup
                        if (e.code === 'KeyE') {
                            checkWeaponPickup();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;

                    // v1.01: Use cached DOM for scoreboard
                    if (e.code === 'Tab') {
                        getUICache().scoreboard.classList.remove('visible');
                    }
                });

                // Mouse
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouse.dx += e.movementX;
                        this.mouse.dy += e.movementY;
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    this.mouse.buttons[e.button] = true;

                    if (GameState.isRunning && !this.isPointerLocked) {
                        document.getElementById('game-container').requestPointerLock();
                    }

                    // Right click for scope
                    if (e.button === 2 && GameState.isRunning) {
                        const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
                        if (weapon) weapon.toggleScope();
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    this.mouse.buttons[e.button] = false;
                });

                // Context menu prevention
                document.addEventListener('contextmenu', (e) => {
                    if (GameState.isRunning) e.preventDefault();
                });

                // Pointer lock
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement !== null;
                });

                // Scroll for weapon switch
                document.addEventListener('wheel', (e) => {
                    if (GameState.isRunning && PlayerController.weapons.length > 1) {
                        if (e.deltaY > 0) {
                            PlayerController.currentWeaponIndex = (PlayerController.currentWeaponIndex + 1) % PlayerController.weapons.length;
                        } else {
                            PlayerController.currentWeaponIndex = (PlayerController.currentWeaponIndex - 1 + PlayerController.weapons.length) % PlayerController.weapons.length;
                        }
                        updateWeaponUI();
                    }
                });
            },

            getMovementInput() {
                let forward = 0, right = 0;

                if (this.keys['KeyW']) forward += 1;
                if (this.keys['KeyS']) forward -= 1;
                if (this.keys['KeyA']) right -= 1;
                if (this.keys['KeyD']) right += 1;

                return { forward, right };
            },

            consumeMouseDelta() {
                const dx = this.mouse.dx;
                const dy = this.mouse.dy;
                this.mouse.dx = 0;
                this.mouse.dy = 0;
                return { dx, dy };
            }
        };

        // ============================================================
        // PLAYER MODELS (Remote Players)
        // ============================================================

        const PlayerModels = {
            models: new Map(),

            createPlayerModel(playerId, team) {
                // Create Spartan model with team colors
                const teamColors = {
                    red: { primary: '#aa2222', secondary: '#882222', accent: '#cc4444' },
                    blue: { primary: '#2222aa', secondary: '#222288', accent: '#4444cc' },
                    none: { primary: '#4a6a4a', secondary: '#3a5a3a', accent: '#5a7a5a' }
                };

                const colors = teamColors[team] || teamColors.none;

                // Clone and color the Spartan model for this team
                const teamSpartanDef = JSON.parse(JSON.stringify(SpartanModel));
                teamSpartanDef.bodyParts.forEach(part => {
                    if (part.name === 'torso' || part.name === 'helmet' || part.name.includes('Arm') ||
                        part.name.includes('Leg') || part.name.includes('shoulder')) {
                        part.color = colors.primary;
                    } else if (part.name === 'chestPlate' || part.name.includes('forearm')) {
                        part.color = colors.secondary;
                    } else if (part.name === 'waist' || part.name.includes('boot')) {
                        part.color = colors.accent;
                    }
                });

                const group = ModelBuilder.buildFromDefinition(teamSpartanDef, 1);

                scene.add(group);
                this.models.set(playerId, group);

                return group;
            },

            updatePlayerModel(playerId, position, rotation) {
                let model = this.models.get(playerId);

                if (!model) {
                    const player = GameState.players.get(playerId);
                    model = this.createPlayerModel(playerId, player?.team || 'none');
                }

                model.position.set(position.x, position.y, position.z);
                model.rotation.y = rotation.y;
            },

            removePlayerModel(playerId) {
                const model = this.models.get(playerId);
                if (model) {
                    scene.remove(model);
                    this.models.delete(playerId);
                }
            }
        };

        // ============================================================
        // WEAPON PICKUP SYSTEM
        // ============================================================

        const WeaponPickups = {
            pickups: [],
            respawnTime: 30, // seconds

            init() {
                LockoutMap.weaponSpawns.forEach((spawn, index) => {
                    this.createPickup(index, spawn.pos, spawn.weapon);
                });
            },

            createPickup(id, position, weaponType) {
                const config = WeaponTypes[weaponType];

                // Visual representation
                const group = new THREE.Group();

                // Weapon model - use detailed model from WeaponModels
                const weaponModelDef = WeaponModels[weaponType];
                if (weaponModelDef) {
                    const weaponMesh = ModelBuilder.buildFromDefinition(weaponModelDef, 2.5);
                    weaponMesh.rotation.y = Math.PI / 2; // Rotate for better pickup display
                    group.add(weaponMesh);
                } else {
                    // Fallback to box if no model defined
                    const weaponGeo = new THREE.BoxGeometry(0.8, 0.2, 0.15);
                    const weaponMat = new THREE.MeshStandardMaterial({
                        color: config.modelColor,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const weaponMesh = new THREE.Mesh(weaponGeo, weaponMat);
                    group.add(weaponMesh);
                }

                // Glow ring
                const ringGeo = new THREE.TorusGeometry(0.6, 0.05, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x66aaff,
                    transparent: true,
                    opacity: 0.6
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = -0.2;
                group.add(ring);

                // Holographic platform
                const platformGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.02, 16);
                const platformMat = new THREE.MeshBasicMaterial({
                    color: 0x66aaff,
                    transparent: true,
                    opacity: 0.3
                });
                const platform = new THREE.Mesh(platformGeo, platformMat);
                platform.position.y = -0.25;
                group.add(platform);

                group.position.set(position.x, position.y + 0.5, position.z);
                scene.add(group);

                this.pickups.push({
                    id,
                    group,
                    position,
                    weaponType,
                    isAvailable: true,
                    respawnTimer: 0
                });
            },

            update(delta) {
                this.pickups.forEach(pickup => {
                    if (pickup.isAvailable) {
                        // Rotate and bob
                        pickup.group.rotation.y += delta * 2;
                        pickup.group.position.y = pickup.position.y + 0.5 + Math.sin(Date.now() / 500) * 0.1;
                        pickup.group.visible = true;
                    } else {
                        pickup.group.visible = false;
                        pickup.respawnTimer -= delta;
                        if (pickup.respawnTimer <= 0) {
                            pickup.isAvailable = true;
                        }
                    }
                });
            },

            // v1.01: Uses squared distance for performance (avoids sqrt)
            checkPickup(playerPosition) {
                const pickupRadiusSq = 4; // 2^2 = 4

                for (const pickup of this.pickups) {
                    if (!pickup.isAvailable) continue;

                    const dx = playerPosition.x - pickup.position.x;
                    const dy = playerPosition.y - pickup.position.y;
                    const dz = playerPosition.z - pickup.position.z;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < pickupRadiusSq) {
                        return pickup;
                    }
                }
                return null;
            },

            collectPickup(pickup) {
                pickup.isAvailable = false;
                pickup.respawnTimer = this.respawnTime;

                // Give weapon to player
                const newWeapon = new Weapon(pickup.weaponType);

                if (PlayerController.weapons.length < 2) {
                    PlayerController.weapons.push(newWeapon);
                } else {
                    // Replace current weapon
                    PlayerController.weapons[PlayerController.currentWeaponIndex] = newWeapon;
                }

                updateWeaponUI();

                // Broadcast pickup
                if (GameState.isMultiplayer) {
                    Network.broadcast({
                        type: 'weaponPickup',
                        pickupId: pickup.id
                    });
                }
            }
        };

        function checkWeaponPickup() {
            const pickup = WeaponPickups.checkPickup(PlayerController.position);
            if (pickup) {
                WeaponPickups.collectPickup(pickup);
            }
        }

        // ============================================================
        // RAYCASTING / HIT DETECTION
        // ============================================================

        const raycaster = new THREE.Raycaster();

        function performShot(weapon) {
            const config = weapon.config;

            // Calculate shot direction with spread
            const spread = config.spread * (weapon.scopeLevel > 0 ? 0.3 : 1);
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), PlayerController.rotationX + (Math.random() - 0.5) * spread);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), PlayerController.rotationY + (Math.random() - 0.5) * spread);

            // Set raycaster
            const origin = new THREE.Vector3(
                PlayerController.position.x,
                PlayerController.position.y + 1.6, // Eye height
                PlayerController.position.z
            );
            raycaster.set(origin, direction);
            raycaster.far = config.range;

            // Check hits against player models
            const playerMeshes = [];
            PlayerModels.models.forEach((model, id) => {
                if (id !== Network.peer?.id) {
                    model.traverse(child => {
                        if (child.isMesh) {
                            child.userData.playerId = id;
                            playerMeshes.push(child);
                        }
                    });
                }
            });

            const intersects = raycaster.intersectObjects(playerMeshes, false);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitPlayerId = hit.object.userData.playerId;

                // Calculate damage
                let damage = config.damage / config.burstCount; // Per bullet

                // Check for headshot (upper part of model)
                if (hit.point.y > hit.object.parent.position.y + 1.5) {
                    damage *= config.headshotMultiplier;
                }

                // Show hit marker
                showHitMarker(false);

                // Send hit to network
                if (GameState.isMultiplayer) {
                    Network.sendHit(hitPlayerId, damage);
                } else {
                    // Single player - apply damage to bot
                    const bot = GameState.players.get(hitPlayerId);
                    if (bot) {
                        applyDamageToPlayer(bot, damage, 'player');
                    }
                }

                return true;
            }

            return false;
        }

        function showHitMarker(isKill) {
            // v1.01: Use cached DOM reference
            const marker = getUICache().hitMarker;
            marker.classList.add('active');
            if (isKill) marker.classList.add('kill');

            setTimeout(() => {
                marker.classList.remove('active', 'kill');
            }, 150);
        }

        // ============================================================
        // DAMAGE & DEATH SYSTEM
        // ============================================================

        PlayerController.takeDamage = function(damage, attackerId) {
            if (this.isDead) return;

            this.lastDamageTime = performance.now() / 1000;

            // v1.01: Use cached DOM references for shield flash
            const shieldFlash = getUICache().shieldFlash;

            // Damage shield first
            if (this.shield > 0) {
                const shieldDamage = Math.min(this.shield, damage);
                this.shield -= shieldDamage;
                damage -= shieldDamage;

                if (this.shield <= 0) {
                    AudioSystem.playShieldBreak();
                    shieldFlash.classList.add('active', 'broken');
                } else {
                    AudioSystem.playShieldHit();
                    shieldFlash.classList.add('active');
                }
            }

            // Remaining damage goes to health
            if (damage > 0) {
                this.health -= damage;
            }

            // Update UI
            updateHealthUI();

            setTimeout(() => {
                shieldFlash.classList.remove('active', 'broken');
            }, 100);

            // Check death
            if (this.health <= 0) {
                this.die(attackerId);
            }
        };

        PlayerController.die = function(killerId) {
            this.isDead = true;
            gameData.stats.deaths++;
            saveData();

            const killer = GameState.players.get(killerId);
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];

            // Add to kill feed
            addKillFeedEntry(
                killer ? killer.name : 'Unknown',
                document.getElementById('player-name').value || 'Spartan',
                weapon ? weapon.config.shortName : 'BR55'
            );

            // Network death notification
            if (GameState.isMultiplayer) {
                Network.sendDeath(killerId, killer?.name || 'Unknown', weapon?.type || 'BR55');
            }

            // v1.01: Use cached DOM references for respawn screen
            const ui = getUICache();
            ui.respawnScreen.classList.add('visible');
            ui.killedBy.textContent = `Killed by ${killer?.name || 'Unknown'}`;

            // v1.01: Clear any existing respawn timer before creating new one
            if (GameState.timers.respawnInterval) {
                clearInterval(GameState.timers.respawnInterval);
            }

            // Respawn timer
            let respawnTime = 5;
            GameState.timers.respawnInterval = setInterval(() => {
                respawnTime--;
                ui.respawnTimer.textContent = respawnTime;

                if (respawnTime <= 0) {
                    clearInterval(GameState.timers.respawnInterval);
                    GameState.timers.respawnInterval = null;
                    this.respawn();
                }
            }, 1000);
        };

        PlayerController.respawn = function() {
            // Pick random spawn point
            const spawns = GameState.spawnPoints;
            const spawn = spawns[Math.floor(Math.random() * spawns.length)];

            this.position.set(spawn.x, spawn.y + 2, spawn.z);
            this.velocity.set(0, 0, 0);
            this.shield = this.maxShield;
            this.health = this.maxHealth;
            this.isDead = false;

            // Reset weapons
            this.weapons = [new Weapon('BR55')];
            this.currentWeaponIndex = 0;

            updateHealthUI();
            updateWeaponUI();

            // v1.01: Use cached DOM reference
            getUICache().respawnScreen.classList.remove('visible');

            // Network respawn
            if (GameState.isMultiplayer) {
                Network.broadcast({
                    type: 'respawn',
                    position: { x: spawn.x, y: spawn.y + 2, z: spawn.z }
                });
            }
        };

        function applyDamageToPlayer(player, damage, attackerId) {
            // For bots/remote players
            if (player.shield > 0) {
                const shieldDamage = Math.min(player.shield, damage);
                player.shield -= shieldDamage;
                damage -= shieldDamage;
            }

            if (damage > 0) {
                player.health -= damage;
            }

            if (player.health <= 0) {
                // Player killed
                player.deaths++;

                // Find killer
                if (attackerId === 'player') {
                    PlayerController.kills = (PlayerController.kills || 0) + 1;
                    gameData.stats.kills++;
                    saveData();

                    AudioSystem.playKillSound();
                    showHitMarker(true);

                    addKillFeedEntry(
                        document.getElementById('player-name').value || 'Spartan',
                        player.name,
                        PlayerController.weapons[PlayerController.currentWeaponIndex]?.config.shortName || 'BR55'
                    );

                    updateScoreUI();
                }

                // Respawn bot after delay
                setTimeout(() => {
                    const spawns = GameState.spawnPoints;
                    const spawn = spawns[Math.floor(Math.random() * spawns.length)];
                    player.position = { x: spawn.x, y: spawn.y + 2, z: spawn.z };
                    player.shield = 100;
                    player.health = 100;
                }, 3000);
            }
        }

        // ============================================================
        // UI UPDATES
        // ============================================================

        // v1.01: DOM cache for performance - avoids repeated getElementById calls
        let _uiCache = null;
        function getUICache() {
            if (!_uiCache) {
                _uiCache = {
                    shieldFill: document.getElementById('shield-fill'),
                    healthFill: document.getElementById('health-fill'),
                    weaponName: document.getElementById('weapon-name'),
                    currentAmmo: document.getElementById('current-ammo'),
                    reserveAmmo: document.getElementById('reserve-ammo'),
                    scopeOverlay: document.getElementById('scope-overlay'),
                    playerScore: document.getElementById('player-score'),
                    matchTimer: document.getElementById('match-timer'),
                    shieldFlash: document.getElementById('shield-flash'),
                    hitMarker: document.getElementById('hit-marker'),
                    killFeed: document.getElementById('kill-feed'),
                    weaponPickup: document.getElementById('weapon-pickup'),
                    pickupWeaponName: document.getElementById('pickup-weapon-name'),
                    respawnScreen: document.getElementById('respawn-screen'),
                    respawnTimer: document.getElementById('respawn-timer'),
                    killedBy: document.getElementById('killed-by'),
                    scoreboard: document.getElementById('scoreboard'),
                    scoreboardRows: document.getElementById('scoreboard-rows'),
                    minimapCanvas: document.getElementById('minimap-canvas')
                };
            }
            return _uiCache;
        }

        function updateHealthUI() {
            const ui = getUICache();
            const shieldPercent = (PlayerController.shield / PlayerController.maxShield) * 100;
            const healthPercent = (PlayerController.health / PlayerController.maxHealth) * 100;

            ui.shieldFill.style.width = shieldPercent + '%';
            ui.healthFill.style.width = healthPercent + '%';
        }

        function updateWeaponUI() {
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            if (!weapon) return;

            const ui = getUICache();
            ui.weaponName.textContent = weapon.config.name;
            ui.currentAmmo.textContent = weapon.currentAmmo;
            ui.reserveAmmo.textContent = weapon.reserveAmmo;

            // Update scope overlay
            if (weapon.scopeLevel > 0 && weapon.config.scopeZoom > 0) {
                ui.scopeOverlay.classList.add('active');
            } else {
                ui.scopeOverlay.classList.remove('active');
            }
        }

        function updateScoreUI() {
            getUICache().playerScore.textContent = PlayerController.kills || 0;
        }

        function updateTimerUI() {
            const minutes = Math.floor(GameState.matchTime / 60);
            const seconds = Math.floor(GameState.matchTime % 60);
            getUICache().matchTimer.textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function addKillFeedEntry(killer, victim, weapon) {
            // v1.01: Use cached DOM reference
            const feed = getUICache().killFeed;
            const entry = document.createElement('div');
            entry.className = 'kill-item';
            entry.innerHTML = `
                <span class="killer">${killer}</span>
                <span class="weapon-icon">[${weapon}]</span>
                <span class="victim">${victim}</span>
            `;
            feed.appendChild(entry);

            // v1.01: Track timeout for proper cleanup
            const timeoutId = setTimeout(() => {
                if (entry.parentNode) {
                    entry.remove();
                }
                // Remove this timeout from tracking array
                const idx = GameState.timers.killFeedTimeouts.indexOf(timeoutId);
                if (idx > -1) {
                    GameState.timers.killFeedTimeouts.splice(idx, 1);
                }
            }, 5000);
            GameState.timers.killFeedTimeouts.push(timeoutId);

            // Limit feed entries
            while (feed.children.length > 5) {
                feed.removeChild(feed.firstChild);
            }
        }

        function updateScoreboard() {
            // v1.01: Use cached DOM reference
            const rows = getUICache().scoreboardRows;
            rows.innerHTML = '';

            // Sort players by kills
            const sortedPlayers = Array.from(GameState.players.values())
                .sort((a, b) => b.kills - a.kills);

            // Add local player
            const localPlayer = {
                name: document.getElementById('player-name').value || 'Spartan',
                kills: PlayerController.kills || 0,
                deaths: gameData.stats.deaths,
                isLocal: true
            };

            sortedPlayers.push(localPlayer);
            sortedPlayers.sort((a, b) => b.kills - a.kills);

            sortedPlayers.forEach(player => {
                const row = document.createElement('div');
                row.className = 'scoreboard-row' + (player.isLocal ? ' local' : '');
                row.innerHTML = `
                    <span>${player.name}</span>
                    <span>${player.kills || 0}</span>
                    <span>${player.deaths || 0}</span>
                    <span>${(player.kills || 0) * 100}</span>
                `;
                rows.appendChild(row);
            });
        }

        function updateMinimap() {
            // v1.01: Use cached DOM reference
            const canvas = getUICache().minimapCanvas;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 176, 176);

            // Draw map outline (simplified)
            ctx.strokeStyle = '#3af';
            ctx.lineWidth = 1;
            ctx.strokeRect(20, 20, 136, 136);

            // Draw platforms
            ctx.fillStyle = 'rgba(50, 100, 150, 0.5)';
            LockoutMap.platforms.forEach(p => {
                const x = 88 + (p.minX + p.maxX) / 2 * 2;
                const y = 88 - (p.minZ + p.maxZ) / 2 * 2;
                const w = (p.maxX - p.minX) * 2;
                const h = (p.maxZ - p.minZ) * 2;
                ctx.fillRect(x - w/2, y - h/2, w, h);
            });

            // Draw local player
            const px = 88 + PlayerController.position.x * 2;
            const py = 88 - PlayerController.position.z * 2;

            ctx.fillStyle = '#5f5';
            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fill();

            // Direction indicator
            ctx.strokeStyle = '#5f5';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(
                px + Math.sin(PlayerController.rotationY) * 8,
                py - Math.cos(PlayerController.rotationY) * 8
            );
            ctx.stroke();

            // Draw other players
            GameState.players.forEach((player, id) => {
                if (id === Network.peer?.id) return;

                const opx = 88 + player.position.x * 2;
                const opy = 88 - player.position.z * 2;

                ctx.fillStyle = player.team === 'red' ? '#f55' :
                               player.team === 'blue' ? '#55f' : '#f55';
                ctx.beginPath();
                ctx.arc(opx, opy, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ============================================================
        // GAME INITIALIZATION
        // ============================================================

        function initThreeJS() {
            // v1.01: Scene with authentic Lockout atmosphere - cold, snowy mountain environment
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a3a); // Darker, colder blue
            scene.fog = new THREE.Fog(0x2a3a4a, 40, 180); // Closer fog for that Lockout visibility

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // v1.01: Authentic Lockout lighting - cold ambient with warm sun
            const ambientLight = new THREE.AmbientLight(0x405060, 0.6); // Slightly brighter cold ambient
            scene.add(ambientLight);

            // Main directional light (sun through clouds)
            const directionalLight = new THREE.DirectionalLight(0xddeeff, 0.9); // Slightly blue-white sun
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 300;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // v1.01: Forerunner glow lights for that authentic Lockout feel
            const rimLight1 = new THREE.PointLight(0x5588ff, 0.6, 80); // Blue Forerunner glow
            rimLight1.position.set(-30, 25, -30);
            scene.add(rimLight1);

            const rimLight2 = new THREE.PointLight(0x6688ff, 0.6, 80);
            rimLight2.position.set(30, 20, 30);
            scene.add(rimLight2);

            // v1.01: Purple accent light for Forerunner structures
            const accentLight = new THREE.PointLight(0x8866cc, 0.4, 60);
            accentLight.position.set(0, 15, 0); // Center on BR tower
            scene.add(accentLight);

            // v1.01: Skybox with authentic Lockout colors - icy mountain sky
            const skyGeo = new THREE.SphereGeometry(400, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0a1525) }, // Dark night blue at top
                    bottomColor: { value: new THREE.Color(0x6080aa) }, // Hazy mountain horizon
                    offset: { value: 80 },
                    exponent: { value: 0.5 } // Smoother gradient
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);

            // Build the Lockout map
            LockoutMap.build(scene);

            // Initialize first-person weapon view model system
            ViewModelSystem.init(scene, camera);

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function initGame() {
            // Initialize Three.js
            initThreeJS();

            // Initialize audio (on user interaction)
            document.addEventListener('click', () => {
                if (!AudioSystem.context) {
                    AudioSystem.init();
                }
            }, { once: true });

            // Initialize input
            Input.init();

            // Set player name from saved data
            if (gameData.settings.name) {
                document.getElementById('player-name').value = gameData.settings.name;
            }
        }

        // ============================================================
        // GAME LOOP
        // ============================================================

        let lastFootstepTime = 0;
        let burstTimer = 0;

        function gameLoop() {
            if (!GameState.isRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }

            const delta = clock.getDelta();

            // Update match timer
            GameState.matchTime -= delta;
            if (GameState.matchTime <= 0) {
                endMatch();
            }
            updateTimerUI();

            // Player movement
            if (!PlayerController.isDead) {
                updatePlayerMovement(delta);
                updatePlayerCamera(delta);
                updateCombat(delta);
            }

            // Shield regeneration
            updateShieldRegen(delta);

            // Update weapons
            PlayerController.weapons.forEach(w => w.updateReload());
            updateWeaponUI();

            // Update first-person weapon view model
            const currentWeapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            if (currentWeapon) {
                ViewModelSystem.setWeapon(currentWeapon.type);
                const isMoving = Input.keys['KeyW'] || Input.keys['KeyS'] || Input.keys['KeyA'] || Input.keys['KeyD'];
                const isAiming = currentWeapon.scopeLevel > 0;
                ViewModelSystem.update(delta, PlayerController.velocity, isMoving, PlayerController.isCrouching, isAiming);

                // Hide weapon when scoped
                if (isAiming) {
                    ViewModelSystem.hide();
                } else {
                    ViewModelSystem.show();
                }
            }

            // Update remote players
            GameState.players.forEach((player, id) => {
                if (id !== Network.peer?.id) {
                    PlayerModels.updatePlayerModel(id, player.position, player.rotation);
                }
            });

            // Update weapon pickups
            WeaponPickups.update(delta);

            // v1.01: Check for nearby weapon pickups using cached DOM
            const nearbyPickup = WeaponPickups.checkPickup(PlayerController.position);
            const ui = getUICache();
            if (nearbyPickup) {
                ui.weaponPickup.classList.add('visible');
                ui.pickupWeaponName.textContent = WeaponTypes[nearbyPickup.weaponType].name;
            } else {
                ui.weaponPickup.classList.remove('visible');
            }

            // Update minimap
            updateMinimap();

            // Update scoreboard
            updateScoreboard();

            // Network position updates (throttled)
            if (GameState.isMultiplayer && Date.now() % 3 === 0) {
                Network.sendPosition();
            }

            // Render
            renderer.render(scene, camera);

            requestAnimationFrame(gameLoop);
        }

        function updatePlayerMovement(delta) {
            const { forward, right } = Input.getMovementInput();

            // No sprint in Halo 2 - crouch only
            PlayerController.isSprinting = false;

            // Crouch
            PlayerController.isCrouching = Input.keys['ControlLeft'] || Input.keys['ShiftLeft'];

            // Calculate move speed
            let speed = PlayerController.moveSpeed;
            if (PlayerController.isCrouching) speed *= 0.5;

            // Movement direction relative to camera
            const moveDir = new THREE.Vector3();

            if (forward !== 0 || right !== 0) {
                moveDir.x = right;
                moveDir.z = -forward;
                moveDir.normalize();

                // Rotate by player yaw (fixed rotation direction)
                const cos = Math.cos(PlayerController.rotationY);
                const sin = Math.sin(PlayerController.rotationY);
                const rx = moveDir.x * cos + moveDir.z * sin;
                const rz = -moveDir.x * sin + moveDir.z * cos;
                moveDir.x = rx;
                moveDir.z = rz;
            }

            // Apply horizontal movement
            PlayerController.velocity.x = moveDir.x * speed;
            PlayerController.velocity.z = moveDir.z * speed;

            // Jump - Halo style floaty physics
            if (Input.keys['Space'] && PlayerController.isGrounded) {
                PlayerController.velocity.y = PlayerController.jumpForce;
                PlayerController.isGrounded = false;
                AudioSystem.playJump();
            }

            // Apply gravity
            PlayerController.velocity.y -= PlayerController.gravity * delta;

            // Move position
            const newPos = PlayerController.position.clone();
            newPos.x += PlayerController.velocity.x * delta;
            newPos.y += PlayerController.velocity.y * delta;
            newPos.z += PlayerController.velocity.z * delta;

            // Ground collision
            const groundY = LockoutMap.getGroundHeight(newPos.x, newPos.z, newPos.y + 2);
            const playerHeight = PlayerController.isCrouching ? 1.2 : 1.8;

            if (newPos.y <= groundY + playerHeight) {
                newPos.y = groundY + playerHeight;
                PlayerController.velocity.y = 0;
                PlayerController.isGrounded = true;
            } else {
                PlayerController.isGrounded = false;
            }

            // Kill zone check (fell off map)
            if (newPos.y < -40) {
                PlayerController.takeDamage(1000, null); // Instant death
            }

            // Wall collision detection
            const wallPush = LockoutMap.checkWallCollision(newPos, 0.4);
            newPos.x += wallPush.x;
            newPos.z += wallPush.z;

            // Gravity lift check
            if (LockoutMap.checkGravLift(newPos)) {
                PlayerController.velocity.y = 15; // Strong upward lift
                PlayerController.isGrounded = false;
            }

            PlayerController.position.copy(newPos);

            // Footstep sounds
            if (PlayerController.isGrounded && (forward !== 0 || right !== 0)) {
                const footstepInterval = PlayerController.isCrouching ? 0.6 : 0.45;
                if (Date.now() / 1000 - lastFootstepTime > footstepInterval) {
                    AudioSystem.playFootstep();
                    lastFootstepTime = Date.now() / 1000;
                }
            }
        }

        function updatePlayerCamera(delta) {
            // Mouse look
            const { dx, dy } = Input.consumeMouseDelta();
            const sensitivity = gameData.settings.sensitivity * 0.001;

            PlayerController.rotationY -= dx * sensitivity;
            PlayerController.rotationX -= dy * sensitivity;

            // Clamp pitch
            PlayerController.rotationX = Math.max(-Math.PI / 2 + 0.1,
                                          Math.min(Math.PI / 2 - 0.1, PlayerController.rotationX));

            // Update camera
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            const zoom = weapon ? weapon.getZoom() : 1;
            camera.fov = 75 / zoom;
            camera.updateProjectionMatrix();

            // Position camera at player eye level
            const eyeHeight = PlayerController.isCrouching ? 1.0 : 1.6;
            camera.position.set(
                PlayerController.position.x,
                PlayerController.position.y + eyeHeight - 1.8, // Adjust for player height
                PlayerController.position.z
            );

            // Apply rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = PlayerController.rotationY;
            camera.rotation.x = PlayerController.rotationX;
        }

        function updateCombat(delta) {
            const weapon = PlayerController.weapons[PlayerController.currentWeaponIndex];
            if (!weapon) return;

            // Handle burst fire
            if (weapon.burstRemaining > 0) {
                burstTimer -= delta;
                if (burstTimer <= 0) {
                    if (weapon.processBurst()) {
                        AudioSystem.playWeaponFire(weapon.type);
                        performShot(weapon);
                        burstTimer = weapon.config.burstDelay;

                        // Apply weapon recoil animation
                        const recoilAmount = weapon.type === 'SNIPER' ? 0.25 :
                                           weapon.type === 'SHOTGUN' ? 0.2 :
                                           weapon.type === 'ROCKET' ? 0.3 :
                                           weapon.type === 'SMG' ? 0.05 : 0.1;
                        ViewModelSystem.applyRecoil(recoilAmount);

                        // Network
                        if (GameState.isMultiplayer) {
                            Network.sendShoot(weapon.type, {
                                x: -Math.sin(PlayerController.rotationY) * Math.cos(PlayerController.rotationX),
                                y: Math.sin(PlayerController.rotationX),
                                z: -Math.cos(PlayerController.rotationY) * Math.cos(PlayerController.rotationX)
                            });
                        }
                    }
                }
            }

            // Fire weapon
            if (Input.mouse.buttons[0]) { // Left click
                if (weapon.config.automatic || !this.lastFirePressed) {
                    if (weapon.fire()) {
                        burstTimer = 0; // Start burst immediately
                    }
                }
                this.lastFirePressed = true;
            } else {
                this.lastFirePressed = false;
            }
        }

        function updateShieldRegen(delta) {
            const now = performance.now() / 1000;
            const timeSinceDamage = now - PlayerController.lastDamageTime;

            if (timeSinceDamage >= PlayerController.shieldRegenDelay &&
                PlayerController.shield < PlayerController.maxShield &&
                !PlayerController.isDead) {

                // Play recharge sound at start of regen
                if (PlayerController.shield === 0 ||
                    (PlayerController.shield < 10 && timeSinceDamage < PlayerController.shieldRegenDelay + 0.1)) {
                    AudioSystem.playShieldRecharge();
                }

                PlayerController.shield = Math.min(
                    PlayerController.maxShield,
                    PlayerController.shield + PlayerController.shieldRegenRate * delta
                );

                updateHealthUI();
            }
        }

        function endMatch() {
            GameState.isRunning = false;
            gameData.stats.gamesPlayed++;

            // Check for win
            const highestKills = Math.max(...Array.from(GameState.players.values()).map(p => p.kills), PlayerController.kills || 0);
            if ((PlayerController.kills || 0) === highestKills) {
                gameData.stats.wins++;
            }

            saveData();

            // Show end screen (simplified - return to menu)
            alert(`Match Over!\nYour Score: ${PlayerController.kills || 0} kills`);
            location.reload();
        }

        // ============================================================
        // MENU FUNCTIONS
        // ============================================================

        function showJoinDialog() {
            document.getElementById('join-dialog').classList.add('visible');
        }

        function hideJoinDialog() {
            document.getElementById('join-dialog').classList.remove('visible');
        }

        async function createLobby() {
            const playerName = document.getElementById('player-name').value || 'Spartan';
            gameData.settings.name = playerName;
            saveData();

            try {
                const code = await Network.createLobby();

                // Add self to player list
                GameState.players.set(Network.peer.id, {
                    id: Network.peer.id,
                    name: playerName,
                    team: document.getElementById('team-select').value,
                    isHost: true,
                    kills: 0,
                    deaths: 0
                });

                document.getElementById('lobby-code-display').textContent = code;
                document.getElementById('lobby-section').style.display = 'block';
                Network.updateLobbyUI();

                GameState.isMultiplayer = true;
            } catch (err) {
                alert('Failed to create lobby: ' + err.message);
            }
        }

        async function joinLobby() {
            const code = document.getElementById('join-code').value.trim().toUpperCase();
            if (!code || code.length !== 6) {
                alert('Please enter a valid 6-character lobby code');
                return;
            }

            const playerName = document.getElementById('player-name').value || 'Spartan';
            gameData.settings.name = playerName;
            saveData();

            try {
                await Network.joinLobby(code);

                hideJoinDialog();
                document.getElementById('lobby-code-display').textContent = code;
                document.getElementById('lobby-section').style.display = 'block';

                // Hide start button for non-hosts
                document.querySelector('.start-game').style.display = 'none';

                GameState.isMultiplayer = true;
            } catch (err) {
                alert('Failed to join lobby: ' + err.message);
            }
        }

        function cancelLobby() {
            Network.cleanup();
            document.getElementById('lobby-section').style.display = 'none';
            GameState.players.clear();
            GameState.isMultiplayer = false;
        }

        function startMultiplayerGame() {
            if (!Network.isHost) return;

            // Broadcast game start
            Network.broadcast({ type: 'gameStart' });

            startGame();
        }

        function startSinglePlayer() {
            const playerName = document.getElementById('player-name').value || 'Spartan';
            gameData.settings.name = playerName;
            saveData();

            GameState.isMultiplayer = false;

            // Add some bots for practice
            for (let i = 0; i < 3; i++) {
                const botId = 'bot_' + i;
                const spawn = GameState.spawnPoints[i % GameState.spawnPoints.length];
                GameState.players.set(botId, {
                    id: botId,
                    name: 'Bot ' + (i + 1),
                    team: 'none',
                    position: { x: spawn.x, y: spawn.y + 2, z: spawn.z },
                    rotation: { x: 0, y: Math.random() * Math.PI * 2 },
                    kills: 0,
                    deaths: 0,
                    shield: 100,
                    health: 100,
                    weapon: 'BR55'
                });
            }

            startGame();
        }

        function startGame() {
            // Hide menu
            document.getElementById('menu-screen').classList.add('hidden');

            // Show HUD
            document.getElementById('hud').style.display = 'block';

            // Initialize player
            const spawn = GameState.spawnPoints[Math.floor(Math.random() * GameState.spawnPoints.length)];
            PlayerController.position.set(spawn.x, spawn.y + 2, spawn.z);
            PlayerController.weapons = [new Weapon('BR55')];
            PlayerController.kills = 0;

            // Initialize weapon pickups
            WeaponPickups.init();

            // Start networking updates
            if (GameState.isMultiplayer) {
                Network.startPingLoop();
            }

            // Start game
            GameState.isRunning = true;
            GameState.matchTime = 600; // 10 minutes

            // Request pointer lock
            document.getElementById('game-container').requestPointerLock();

            // Start game loop
            gameLoop();
        }

        // ============================================================
        // INITIALIZE ON LOAD
        // ============================================================

        window.addEventListener('load', initGame);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            Network.cleanup();
        });
    </script>
</body>
</html>
