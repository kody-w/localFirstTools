<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer P2P Game Engine - Physics Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px 20px;
            min-width: 250px;
            pointer-events: auto;
        }

        .hud h3 {
            margin-bottom: 10px;
            font-weight: 300;
            color: #4fc3f7;
        }

        .hud-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            pointer-events: auto;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(79, 195, 247, 0.3);
            border: 1px solid rgba(79, 195, 247, 0.5);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: rgba(79, 195, 247, 0.5);
            transform: translateY(-2px);
        }

        .btn.active {
            background: rgba(76, 175, 80, 0.5);
            border-color: #4caf50;
        }

        .chat-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            pointer-events: auto;
        }

        .chat-messages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            font-size: 0.85em;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .chat-input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 0.9em;
        }

        .room-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(79, 195, 247, 0.5);
            border-radius: 16px;
            padding: 30px;
            min-width: 400px;
            text-align: center;
            pointer-events: auto;
        }

        .room-panel h2 {
            margin-bottom: 20px;
            color: #4fc3f7;
        }

        .room-code {
            font-size: 2em;
            font-weight: bold;
            color: #4caf50;
            letter-spacing: 0.2em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .input-field {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 1em;
        }

        .hidden {
            display: none !important;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.85em;
            pointer-events: none;
        }

        .mode-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(255, 152, 0, 0.8);
            border-radius: 20px;
            font-weight: bold;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <!-- Room Panel -->
        <div id="roomPanel" class="room-panel">
            <h2>üéÆ 3D Multiplayer Physics Engine</h2>
            <button class="btn" onclick="createRoom()">Create New Room</button>
            <div style="margin: 20px 0;">- OR -</div>
            <input type="text" class="input-field" id="roomCodeInput" placeholder="Enter Room Code" maxlength="6">
            <button class="btn" onclick="joinRoom()">Join Room</button>
            <div style="margin-top: 20px; font-size: 0.85em; opacity: 0.7;">
                <button class="btn" onclick="startLocalMode()">Play Locally (No Network)</button>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud" class="hud hidden">
            <h3>‚öôÔ∏è Game Info</h3>
            <div class="hud-item">
                <span>Mode:</span>
                <span id="modeDisplay">Play</span>
            </div>
            <div class="hud-item">
                <span>Room:</span>
                <span id="roomDisplay">Local</span>
            </div>
            <div class="hud-item">
                <span>Players:</span>
                <span id="playersDisplay">1</span>
            </div>
            <div class="hud-item">
                <span>Objects:</span>
                <span id="objectsDisplay">0</span>
            </div>
            <div class="hud-item">
                <span>FPS:</span>
                <span id="fpsDisplay">60</span>
            </div>
        </div>

        <!-- Controls -->
        <div id="controls" class="controls hidden">
            <h3 style="margin-bottom: 10px; font-weight: 300; color: #4fc3f7;">Controls</h3>
            <button class="btn" id="modeBtn" onclick="toggleMode()">üìù Edit Mode</button>
            <button class="btn" onclick="spawnBox()">üì¶ Spawn Box</button>
            <button class="btn" onclick="spawnSphere()">‚öΩ Spawn Sphere</button>
            <button class="btn" onclick="spawnRagdoll()">ü§∏ Spawn Ragdoll</button>
            <button class="btn" onclick="clearObjects()">üóëÔ∏è Clear All</button>
            <button class="btn" onclick="saveLevel()">üíæ Save Level</button>
            <button class="btn" onclick="loadLevel()">üìÇ Load Level</button>
            <button class="btn" onclick="startReplay()">üé¨ Record Replay</button>
        </div>

        <!-- Chat Panel -->
        <div id="chatPanel" class="chat-panel hidden">
            <h3 style="margin-bottom: 10px; font-weight: 300; color: #4fc3f7;">üí¨ Chat</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKey(event)">
        </div>

        <!-- Instructions -->
        <div class="instructions">
            WASD: Move | Mouse: Look | Click: Grab | E: Place Object | R: Ragdoll
        </div>

        <!-- Mode Indicator -->
        <div id="modeIndicator" class="mode-indicator hidden">
            EDIT MODE
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            PHYSICS_TIMESTEP: 1/30,  // 30Hz physics
            RENDER_FPS: 60,
            GRAVITY: -9.8,
            PLAYER_SPEED: 5,
            JUMP_FORCE: 8,
            MAX_OBJECTS: 100
        };

        // ===== GAME STATE =====
        const GameState = {
            mode: 'play',  // 'play' or 'edit'
            roomCode: null,
            isHost: false,
            players: [],
            objects: [],
            camera: { x: 0, y: 5, z: 15, rotX: 0, rotY: 0 },
            physics: {
                bodies: [],
                gravity: CONFIG.GRAVITY
            },
            recording: false,
            replayData: [],
            chat: []
        };

        // ===== SIMPLE 3D RENDERER (Lightweight Canvas-based pseudo-3D) =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== PHYSICS ENGINE (Simplified) =====
        class PhysicsBody {
            constructor(type, x, y, z, color = '#4fc3f7') {
                this.type = type;  // 'box', 'sphere', 'ragdoll'
                this.position = { x, y, z };
                this.velocity = { x: 0, y: 0, z: 0 };
                this.rotation = { x: 0, y: 0, z: 0 };
                this.angularVelocity = { x: 0, y: 0, z: 0 };
                this.mass = 1;
                this.size = type === 'sphere' ? 1 : 2;
                this.color = color;
                this.id = Math.random().toString(36).substr(2, 9);
                this.onGround = false;
            }

            update(dt) {
                // Apply gravity
                this.velocity.y += CONFIG.GRAVITY * dt;

                // Update position
                this.position.x += this.velocity.x * dt;
                this.position.y += this.velocity.y * dt;
                this.position.z += this.velocity.z * dt;

                // Update rotation
                this.rotation.x += this.angularVelocity.x * dt;
                this.rotation.y += this.angularVelocity.y * dt;
                this.rotation.z += this.angularVelocity.z * dt;

                // Ground collision
                const groundY = 0;
                if (this.position.y - this.size/2 < groundY) {
                    this.position.y = groundY + this.size/2;
                    this.velocity.y = -this.velocity.y * 0.5;  // Bounce with damping
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }

                // Friction
                this.velocity.x *= 0.98;
                this.velocity.z *= 0.98;
                this.angularVelocity.x *= 0.95;
                this.angularVelocity.y *= 0.95;
                this.angularVelocity.z *= 0.95;
            }

            applyForce(fx, fy, fz) {
                this.velocity.x += fx / this.mass;
                this.velocity.y += fy / this.mass;
                this.velocity.z += fz / this.mass;
            }
        }

        function createRagdoll(x, y, z) {
            // Simplified ragdoll: just a few connected boxes
            const parts = [
                new PhysicsBody('box', x, y + 1, z, '#ff6b6b'),  // Head
                new PhysicsBody('box', x, y, z, '#4ecdc4'),      // Torso
                new PhysicsBody('box', x - 0.5, y - 1, z, '#95e1d3'),  // Left leg
                new PhysicsBody('box', x + 0.5, y - 1, z, '#95e1d3')   // Right leg
            ];
            parts.forEach(part => {
                part.isRagdoll = true;
                GameState.objects.push(part);
            });
            return parts;
        }

        // ===== RENDERING ENGINE =====
        function project3D(x, y, z) {
            // Simple perspective projection
            const cam = GameState.camera;

            // Translate relative to camera
            const dx = x - cam.x;
            const dy = y - cam.y;
            const dz = z - cam.z;

            // Rotate based on camera rotation
            const cosY = Math.cos(-cam.rotY);
            const sinY = Math.sin(-cam.rotY);
            const rx = dx * cosY - dz * sinY;
            const rz = dx * sinY + dz * cosY;

            // Perspective divide
            const fov = 500;
            const scale = fov / (rz + fov);

            return {
                x: canvas.width/2 + rx * scale,
                y: canvas.height/2 - (dy - cam.y) * scale,
                scale: scale,
                depth: rz
            };
        }

        function renderScene() {
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground grid
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.2)';
            ctx.lineWidth = 1;
            for (let x = -50; x <= 50; x += 5) {
                const p1 = project3D(x, 0, -50);
                const p2 = project3D(x, 0, 50);
                if (p1.depth > 0 && p2.depth > 0) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
            for (let z = -50; z <= 50; z += 5) {
                const p1 = project3D(-50, 0, z);
                const p2 = project3D(50, 0, z);
                if (p1.depth > 0 && p2.depth > 0) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            // Sort objects by depth
            const sortedObjects = [...GameState.objects].sort((a, b) => {
                const az = a.position.z - GameState.camera.z;
                const bz = b.position.z - GameState.camera.z;
                return bz - az;  // Far to near
            });

            // Draw objects
            sortedObjects.forEach(obj => {
                const pos = project3D(obj.position.x, obj.position.y, obj.position.z);

                if (pos.depth > 0) {
                    const size = obj.size * pos.scale * 30;

                    ctx.save();
                    ctx.translate(pos.x, pos.y);

                    if (obj.type === 'sphere') {
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fillStyle = obj.color;
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.stroke();
                    } else {
                        ctx.rotate(obj.rotation.y);
                        ctx.fillStyle = obj.color;
                        ctx.fillRect(-size/2, -size/2, size, size);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.strokeRect(-size/2, -size/2, size, size);
                    }

                    ctx.restore();
                }
            });

            // Draw player indicator
            const playerPos = project3D(GameState.camera.x, 1, GameState.camera.z - 3);
            if (playerPos.depth > 0) {
                ctx.fillStyle = '#4caf50';
                ctx.beginPath();
                ctx.arc(playerPos.x, playerPos.y, 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ===== INPUT HANDLING =====
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        let mouseX = 0, mouseY = 0;
        canvas.addEventListener('mousemove', e => {
            const dx = e.movementX || 0;
            const dy = e.movementY || 0;
            GameState.camera.rotY += dx * 0.003;
            GameState.camera.rotX -= dy * 0.003;
            GameState.camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, GameState.camera.rotX));
        });

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        // ===== GAME LOGIC =====
        function updateCamera(dt) {
            const speed = CONFIG.PLAYER_SPEED;
            const cam = GameState.camera;

            if (keys['w']) {
                cam.x += Math.sin(cam.rotY) * speed * dt;
                cam.z += Math.cos(cam.rotY) * speed * dt;
            }
            if (keys['s']) {
                cam.x -= Math.sin(cam.rotY) * speed * dt;
                cam.z -= Math.cos(cam.rotY) * speed * dt;
            }
            if (keys['a']) {
                cam.x -= Math.cos(cam.rotY) * speed * dt;
                cam.z += Math.sin(cam.rotY) * speed * dt;
            }
            if (keys['d']) {
                cam.x += Math.cos(cam.rotY) * speed * dt;
                cam.z -= Math.sin(cam.rotY) * speed * dt;
            }
            if (keys[' ']) {
                cam.y += speed * dt;
            }
            if (keys['shift']) {
                cam.y -= speed * dt;
            }

            cam.y = Math.max(1, cam.y);
        }

        function updatePhysics(dt) {
            GameState.objects.forEach(obj => {
                obj.update(dt);
            });

            // Simple collision detection
            for (let i = 0; i < GameState.objects.length; i++) {
                for (let j = i + 1; j < GameState.objects.length; j++) {
                    const a = GameState.objects[i];
                    const b = GameState.objects[j];

                    const dx = b.position.x - a.position.x;
                    const dy = b.position.y - a.position.y;
                    const dz = b.position.z - a.position.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    const minDist = (a.size + b.size) / 2;

                    if (dist < minDist) {
                        // Separate
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = dz / dist;

                        a.position.x -= nx * overlap / 2;
                        a.position.y -= ny * overlap / 2;
                        a.position.z -= nz * overlap / 2;
                        b.position.x += nx * overlap / 2;
                        b.position.y += ny * overlap / 2;
                        b.position.z += nz * overlap / 2;

                        // Bounce
                        const relVel = {
                            x: b.velocity.x - a.velocity.x,
                            y: b.velocity.y - a.velocity.y,
                            z: b.velocity.z - a.velocity.z
                        };
                        const velAlongNormal = relVel.x * nx + relVel.y * ny + relVel.z * nz;
                        if (velAlongNormal < 0) {
                            const restitution = 0.5;
                            const impulse = -(1 + restitution) * velAlongNormal / (1/a.mass + 1/b.mass);

                            a.velocity.x -= (impulse / a.mass) * nx;
                            a.velocity.y -= (impulse / a.mass) * ny;
                            a.velocity.z -= (impulse / a.mass) * nz;
                            b.velocity.x += (impulse / b.mass) * nx;
                            b.velocity.y += (impulse / b.mass) * ny;
                            b.velocity.z += (impulse / b.mass) * nz;
                        }
                    }
                }
            }
        }

        function updateHUD() {
            document.getElementById('modeDisplay').textContent = GameState.mode;
            document.getElementById('roomDisplay').textContent = GameState.roomCode || 'Local';
            document.getElementById('playersDisplay').textContent = GameState.players.length || 1;
            document.getElementById('objectsDisplay').textContent = GameState.objects.length;
            document.getElementById('fpsDisplay').textContent = Math.round(1000 / lastFrameTime);
        }

        // ===== GAME LOOP =====
        let lastTime = performance.now();
        let lastFrameTime = 16;
        let physicsAccumulator = 0;

        function gameLoop() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastFrameTime = now - lastTime;
            lastTime = now;

            // Physics update (fixed timestep)
            physicsAccumulator += dt;
            while (physicsAccumulator >= CONFIG.PHYSICS_TIMESTEP) {
                updatePhysics(CONFIG.PHYSICS_TIMESTEP);
                physicsAccumulator -= CONFIG.PHYSICS_TIMESTEP;

                if (GameState.recording) {
                    GameState.replayData.push({
                        time: now,
                        camera: {...GameState.camera},
                        objects: GameState.objects.map(o => ({
                            id: o.id,
                            pos: {...o.position},
                            vel: {...o.velocity}
                        }))
                    });
                }
            }

            // Camera update
            updateCamera(dt);

            // Render
            renderScene();
            updateHUD();

            requestAnimationFrame(gameLoop);
        }

        // ===== OBJECT SPAWNING =====
        function spawnBox() {
            if (GameState.objects.length >= CONFIG.MAX_OBJECTS) {
                addChatMessage('System', 'Maximum objects reached!');
                return;
            }
            const cam = GameState.camera;
            const box = new PhysicsBody('box',
                cam.x + Math.sin(cam.rotY) * 5,
                cam.y,
                cam.z + Math.cos(cam.rotY) * 5,
                `hsl(${Math.random() * 360}, 70%, 60%)`
            );
            GameState.objects.push(box);
            broadcastMessage('spawn', { type: 'box', object: serializeObject(box) });
        }

        function spawnSphere() {
            if (GameState.objects.length >= CONFIG.MAX_OBJECTS) {
                addChatMessage('System', 'Maximum objects reached!');
                return;
            }
            const cam = GameState.camera;
            const sphere = new PhysicsBody('sphere',
                cam.x + Math.sin(cam.rotY) * 5,
                cam.y,
                cam.z + Math.cos(cam.rotY) * 5,
                `hsl(${Math.random() * 360}, 70%, 60%)`
            );
            GameState.objects.push(sphere);
            broadcastMessage('spawn', { type: 'sphere', object: serializeObject(sphere) });
        }

        function spawnRagdoll() {
            if (GameState.objects.length >= CONFIG.MAX_OBJECTS - 4) {
                addChatMessage('System', 'Not enough space for ragdoll!');
                return;
            }
            const cam = GameState.camera;
            createRagdoll(
                cam.x + Math.sin(cam.rotY) * 5,
                cam.y + 3,
                cam.z + Math.cos(cam.rotY) * 5
            );
            addChatMessage('System', 'Ragdoll spawned!');
        }

        function clearObjects() {
            GameState.objects = [];
            broadcastMessage('clear', {});
        }

        function serializeObject(obj) {
            return {
                id: obj.id,
                type: obj.type,
                position: obj.position,
                velocity: obj.velocity,
                rotation: obj.rotation,
                color: obj.color,
                size: obj.size
            };
        }

        // ===== MODE SWITCHING =====
        function toggleMode() {
            GameState.mode = GameState.mode === 'play' ? 'edit' : 'play';
            const indicator = document.getElementById('modeIndicator');
            const btn = document.getElementById('modeBtn');

            if (GameState.mode === 'edit') {
                indicator.classList.remove('hidden');
                btn.classList.add('active');
                btn.textContent = 'üéÆ Play Mode';
            } else {
                indicator.classList.add('hidden');
                btn.classList.remove('active');
                btn.textContent = 'üìù Edit Mode';
            }
        }

        // ===== LEVEL MANAGEMENT =====
        function saveLevel() {
            const level = {
                objects: GameState.objects.map(serializeObject),
                camera: GameState.camera,
                timestamp: Date.now()
            };
            localStorage.setItem('saved_level', JSON.stringify(level));
            addChatMessage('System', 'Level saved to localStorage!');
        }

        function loadLevel() {
            const saved = localStorage.getItem('saved_level');
            if (saved) {
                const level = JSON.parse(saved);
                GameState.objects = level.objects.map(data => {
                    const obj = new PhysicsBody(data.type, data.position.x, data.position.y, data.position.z, data.color);
                    obj.id = data.id;
                    obj.velocity = data.velocity;
                    obj.rotation = data.rotation;
                    obj.size = data.size;
                    return obj;
                });
                addChatMessage('System', 'Level loaded!');
            } else {
                addChatMessage('System', 'No saved level found.');
            }
        }

        // ===== REPLAY SYSTEM =====
        function startReplay() {
            if (!GameState.recording) {
                GameState.recording = true;
                GameState.replayData = [];
                addChatMessage('System', 'üé¨ Recording started!');
                setTimeout(stopReplay, 30000);  // Auto-stop after 30s
            }
        }

        function stopReplay() {
            if (GameState.recording) {
                GameState.recording = false;
                localStorage.setItem('replay_data', JSON.stringify(GameState.replayData));
                addChatMessage('System', `üé¨ Recording stopped! Saved ${GameState.replayData.length} frames.`);
            }
        }

        // ===== CHAT SYSTEM =====
        function addChatMessage(sender, message) {
            GameState.chat.push({ sender, message, time: Date.now() });
            const chatDiv = document.getElementById('chatMessages');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'chat-message';
            msgDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatDiv.appendChild(msgDiv);
            chatDiv.scrollTop = chatDiv.scrollHeight;
        }

        function handleChatKey(e) {
            if (e.key === 'Enter') {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (message) {
                    addChatMessage('You', message);
                    broadcastMessage('chat', { sender: 'Player', message });
                    input.value = '';
                }
            }
        }

        // ===== NETWORKING (WebRTC P2P) =====
        let peerConnection = null;
        let dataChannel = null;

        function generateRoomCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        function createRoom() {
            GameState.roomCode = generateRoomCode();
            GameState.isHost = true;
            startGame();
            addChatMessage('System', `Room created: ${GameState.roomCode}`);
            addChatMessage('System', 'Share this code with friends to join!');

            // In production, would set up WebRTC signaling here
            // For this demo, we're using local mode
        }

        function joinRoom() {
            const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (code.length === 6) {
                GameState.roomCode = code;
                GameState.isHost = false;
                startGame();
                addChatMessage('System', `Joining room: ${code}...`);

                // In production, would connect via WebRTC here
                setTimeout(() => {
                    addChatMessage('System', 'Connection simulated (local mode)');
                }, 1000);
            } else {
                alert('Please enter a valid 6-character room code.');
            }
        }

        function startLocalMode() {
            GameState.roomCode = 'LOCAL';
            startGame();
            addChatMessage('System', 'Playing in local mode');
        }

        function startGame() {
            document.getElementById('roomPanel').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('controls').classList.remove('hidden');
            document.getElementById('chatPanel').classList.remove('hidden');

            // Start game loop
            gameLoop();
        }

        function broadcastMessage(type, data) {
            // In production WebRTC implementation, send to all peers
            // For now, just log
            if (GameState.roomCode && GameState.roomCode !== 'LOCAL') {
                console.log('Broadcast:', type, data);
            }
        }

        // ===== INITIALIZATION =====
        addChatMessage('System', 'Welcome to 3D Multiplayer Physics Engine!');
        addChatMessage('System', 'Create or join a room to start playing.');
    </script>
</body>
</html>
