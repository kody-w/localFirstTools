<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEVIATHAN v4 Smoke Test</title>
    <style>
        body { font-family: monospace; background: #111; color: #0f0; padding: 20px; }
        #status { font-size: 24px; font-weight: bold; margin-bottom: 20px; }
        .pass { color: #0f0; }
        .fail { color: #f00; }
        .pending { color: #ff0; }
        #logs { border: 1px solid #333; padding: 10px; height: 300px; overflow-y: auto; background: #000; }
        iframe { width: 800px; height: 600px; border: 1px solid #333; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>LEVIATHAN v4 Smoke Test</h1>
    <div id="status" class="pending">RUNNING...</div>
    <div id="logs"></div>
    <iframe id="game-frame" src="leviv4.html"></iframe>

    <script>
        const logs = document.getElementById('logs');
        const status = document.getElementById('status');
        const iframe = document.getElementById('game-frame');

        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            div.style.color = type === 'error' ? '#f00' : (type === 'success' ? '#0f0' : '#ccc');
            logs.appendChild(div);
            logs.scrollTop = logs.scrollHeight;
            console.log(msg);
        }

        function fail(msg) {
            log(msg, 'error');
            status.textContent = 'FAILED';
            status.className = 'fail';
        }

        function pass(msg) {
            log(msg, 'success');
            status.textContent = 'PASSED';
            status.className = 'pass';
        }

        iframe.onload = () => {
            log('Iframe loaded. Starting tests...');
            runTests();
        };

        async function runTests() {
            try {
                const win = iframe.contentWindow;
                
                // Test 1: Check global variables
                log('Test 1: Checking global variables...');
                if (!win.BioPhone) throw new Error('BioPhone object not found');
                if (!win.NexusHub) throw new Error('NexusHub object not found');
                log('Global variables found.', 'success');

                // Test 2: Check BioPhone initialization
                log('Test 2: Checking BioPhone initialization...');
                await waitFor(() => win.BioPhone.active === true, 5000, 'BioPhone activation');
                log('BioPhone is active.', 'success');

                // Test 3: Check Boot Sequence
                log('Test 3: Checking Boot Sequence...');
                // We expect bootPhase to advance
                await waitFor(() => win.BioPhone.bootPhase > 0, 5000, 'Boot phase advancement');
                log('Boot sequence started.', 'success');

                // Test 4: Check Nexus Entry (might take a while due to boot sequence)
                log('Test 4: Waiting for Nexus Entry (this may take ~10s)...');
                // We can speed it up by forcing skip if available
                if (win.BioPhone.skipRequested === false) {
                    log('Attempting to skip boot sequence...');
                    win.BioPhone.skipRequested = true;
                    win.BioPhone.completeBoot();
                }
                
                await waitFor(() => win.NexusHub.active === true, 10000, 'NexusHub activation');
                log('NexusHub is active.', 'success');

                // Test 5: Check Scene Rendering
                log('Test 5: Checking Three.js Scene...');
                if (!win.NexusHub.scene) throw new Error('NexusHub scene is null');
                if (win.NexusHub.scene.children.length === 0) throw new Error('Scene is empty');
                log(`Scene has ${win.NexusHub.scene.children.length} objects.`, 'success');

                pass('All smoke tests passed!');

            } catch (e) {
                fail(e.message);
            }
        }

        function waitFor(conditionFn, timeout, name) {
            return new Promise((resolve, reject) => {
                const start = Date.now();
                const interval = setInterval(() => {
                    if (conditionFn()) {
                        clearInterval(interval);
                        resolve();
                    } else if (Date.now() - start > timeout) {
                        clearInterval(interval);
                        reject(new Error(`Timeout waiting for ${name}`));
                    }
                }, 100);
            });
        }
    </script>
</body>
</html>