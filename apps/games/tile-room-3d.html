<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tiling Project Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        #info h3 {
            margin: 0 0 10px 0;
            color: #667eea;
        }
        #info div {
            margin: 5px 0;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        .highlight {
            color: #ffd700;
            font-weight: bold;
        }
        #data-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        #data-controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        #data-controls button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        #file-input {
            display: none;
        }
        #json-editor {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(20px);
            z-index: 1000;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
        }
        #json-editor h3 {
            color: #667eea;
            margin-top: 0;
        }
        #json-editor textarea {
            width: 100%;
            height: 400px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #667eea;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        #json-editor button {
            margin: 10px 5px 0 0;
            padding: 8px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #json-editor button:hover {
            background: #764ba2;
        }
        #json-editor button.cancel {
            background: #666;
        }
        #json-editor button.cancel:hover {
            background: #888;
        }
        .preset-button {
            background: #4a5568 !important;
            font-size: 12px !important;
            margin: 3px 0 !important;
        }
        .preset-button:hover {
            background: #2d3748 !important;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">
        <h3>üè† <span id="project-name">Tiling Project 3D</span></h3>
        <div>Room: <span class="highlight" id="room-dimensions">15' √ó 18'</span></div>
        <div>Floor Area: <span class="highlight" id="floor-area">270 sq ft</span></div>
        <div>Total Tiles: <span class="highlight" id="total-tiles">285.12 sq ft</span></div>
        <div>Tile Boxes: <span class="highlight" id="tile-boxes">20 boxes</span></div>
        <div>Labor Time: <span class="highlight" id="labor-time">52 hours</span></div>
        <div>Waste Factor: <span class="highlight" id="waste-factor">5.6%</span></div>
    </div>
    <div id="controls">
        Use mouse to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click tiles to highlight
    </div>
    
    <div id="data-controls">
        <button onclick="exportData()">üì• Export JSON</button>
        <button onclick="document.getElementById('file-input').click()">üì§ Import JSON</button>
        <button onclick="showJsonEditor()">‚úèÔ∏è Edit Data</button>
        <hr style="border: 1px solid #444; margin: 10px 0;">
        <button class="preset-button" onclick="loadPreset('bathroom')">üöø Bathroom Preset</button>
        <button class="preset-button" onclick="loadPreset('kitchen')">üç≥ Kitchen Preset</button>
        <button class="preset-button" onclick="loadPreset('large')">üè¢ Large Room Preset</button>
        <input type="file" id="file-input" accept=".json" onchange="importData(event)">
    </div>

    <div id="json-editor">
        <h3>Edit Project Data</h3>
        <textarea id="json-textarea"></textarea>
        <div>
            <button onclick="applyJsonData()">Apply Changes</button>
            <button class="cancel" onclick="hideJsonEditor()">Cancel</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Project data structure
        let projectData = {
            projectName: "Tiling Project 3D",
            room: {
                width: 15,
                length: 18,
                height: 8
            },
            tiles: {
                totalNeeded: 285.12,
                boxCount: 20,
                tileSize: 1,
                pattern: "grid",
                colors: ["#e0e0e0", "#d0d0d0", "#c0c0c0"]
            },
            labor: {
                hours: 52,
                workers: 1
            },
            metadata: {
                createdDate: new Date().toISOString(),
                lastModified: new Date().toISOString(),
                version: "1.0"
            }
        };

        // Preset configurations
        const presets = {
            bathroom: {
                projectName: "Bathroom Renovation",
                room: { width: 8, length: 10, height: 8 },
                tiles: { totalNeeded: 85, boxCount: 6, tileSize: 0.5, pattern: "grid", colors: ["#ffffff", "#f0f0f0", "#e8e8e8"] },
                labor: { hours: 16, workers: 1 }
            },
            kitchen: {
                projectName: "Kitchen Floor",
                room: { width: 12, length: 14, height: 9 },
                tiles: { totalNeeded: 175, boxCount: 13, tileSize: 1.5, pattern: "diagonal", colors: ["#8b7355", "#a0826d", "#bc9a6a"] },
                labor: { hours: 28, workers: 2 }
            },
            large: {
                projectName: "Commercial Space",
                room: { width: 30, length: 40, height: 12 },
                tiles: { totalNeeded: 1250, boxCount: 88, tileSize: 2, pattern: "grid", colors: ["#333333", "#444444", "#555555"] },
                labor: { hours: 120, workers: 3 }
            }
        };

        // Three.js scene variables
        let scene, camera, renderer, roomGroup, tileGroup, boxGroup;
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x764ba2, 100, 500);
            
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            const container = document.getElementById('canvas-container');
            container.innerHTML = '';
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -15;
            directionalLight.shadow.camera.right = 15;
            directionalLight.shadow.camera.top = 15;
            directionalLight.shadow.camera.bottom = -15;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x667eea, 0.5);
            pointLight.position.set(-5, 5, -5);
            scene.add(pointLight);
        }

        // Build 3D scene from data
        function buildScene() {
            // Clear existing room
            if (roomGroup) {
                scene.remove(roomGroup);
            }

            const scale = 0.5;
            const roomWidth = projectData.room.width * scale;
            const roomDepth = projectData.room.length * scale;
            const roomHeight = projectData.room.height * scale;

            // Create room group
            roomGroup = new THREE.Group();

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf0f0f0,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            roomGroup.add(floor);

            // Create tile grid
            const tileSize = projectData.tiles.tileSize * scale;
            const tilesX = Math.floor(roomWidth / tileSize);
            const tilesZ = Math.floor(roomDepth / tileSize);
            const tileThickness = 0.05;
            
            tileGroup = new THREE.Group();
            
            for (let x = 0; x < tilesX; x++) {
                for (let z = 0; z < tilesZ; z++) {
                    const tileGeometry = new THREE.BoxGeometry(
                        tileSize * 0.95,
                        tileThickness,
                        tileSize * 0.95
                    );
                    
                    const colorHex = parseInt(projectData.tiles.colors[(x + z) % projectData.tiles.colors.length].replace('#', '0x'));
                    const tileMaterial = new THREE.MeshPhongMaterial({
                        color: colorHex,
                        specular: 0x222222,
                        shininess: 30
                    });
                    
                    const tile = new THREE.Mesh(tileGeometry, tileMaterial);
                    tile.position.set(
                        -roomWidth/2 + tileSize/2 + x * tileSize,
                        tileThickness/2,
                        -roomDepth/2 + tileSize/2 + z * tileSize
                    );
                    tile.castShadow = true;
                    tile.receiveShadow = true;
                    tileGroup.add(tile);
                }
            }
            roomGroup.add(tileGroup);

            // Walls
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8b7355,
                transparent: true,
                opacity: 0.3
            });

            // Back wall
            const backWallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.z = -roomDepth / 2;
            backWall.position.y = roomHeight / 2;
            roomGroup.add(backWall);

            // Front wall
            const frontWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            frontWall.position.z = roomDepth / 2;
            frontWall.position.y = roomHeight / 2;
            frontWall.rotation.y = Math.PI;
            roomGroup.add(frontWall);

            // Left wall
            const sideWallGeometry = new THREE.PlaneGeometry(roomDepth, roomHeight);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.x = -roomWidth / 2;
            leftWall.position.y = roomHeight / 2;
            leftWall.rotation.y = Math.PI / 2;
            roomGroup.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.x = roomWidth / 2;
            rightWall.position.y = roomHeight / 2;
            rightWall.rotation.y = -Math.PI / 2;
            roomGroup.add(rightWall);

            // Tile boxes
            boxGroup = new THREE.Group();
            const boxGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.6);
            const boxMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8b4513
            });
            
            const boxCount = projectData.tiles.boxCount;
            const maxStack = 5;
            
            for (let i = 0; i < boxCount; i++) {
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                const stackRow = Math.floor(i / maxStack);
                const stackCol = i % maxStack;
                box.position.set(
                    roomWidth/2 + 1.5,
                    0.15 + stackRow * 0.31,
                    -roomDepth/2 + 1 + stackCol * 0.65
                );
                box.castShadow = true;
                boxGroup.add(box);
            }
            
            roomGroup.add(boxGroup);

            // Measurement lines
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            
            // Width measurement
            const widthPoints = [];
            widthPoints.push(new THREE.Vector3(-roomWidth/2, 0.01, roomDepth/2 + 0.5));
            widthPoints.push(new THREE.Vector3(roomWidth/2, 0.01, roomDepth/2 + 0.5));
            const widthGeometry = new THREE.BufferGeometry().setFromPoints(widthPoints);
            const widthLine = new THREE.Line(widthGeometry, lineMaterial);
            roomGroup.add(widthLine);

            // Depth measurement
            const depthPoints = [];
            depthPoints.push(new THREE.Vector3(roomWidth/2 + 0.5, 0.01, -roomDepth/2));
            depthPoints.push(new THREE.Vector3(roomWidth/2 + 0.5, 0.01, roomDepth/2));
            const depthGeometry = new THREE.BufferGeometry().setFromPoints(depthPoints);
            const depthLine = new THREE.Line(depthGeometry, lineMaterial);
            roomGroup.add(depthLine);

            scene.add(roomGroup);

            // Set camera position based on room size
            const maxDimension = Math.max(roomWidth, roomDepth);
            camera.position.set(maxDimension * 1.5, maxDimension * 1.2, maxDimension * 1.5);
            camera.lookAt(0, 0, 0);
        }

        // Update UI with data
        function updateUI() {
            document.getElementById('project-name').textContent = projectData.projectName;
            document.getElementById('room-dimensions').textContent = `${projectData.room.width}' √ó ${projectData.room.length}'`;
            document.getElementById('floor-area').textContent = `${projectData.room.width * projectData.room.length} sq ft`;
            document.getElementById('total-tiles').textContent = `${projectData.tiles.totalNeeded} sq ft`;
            document.getElementById('tile-boxes').textContent = `${projectData.tiles.boxCount} boxes`;
            document.getElementById('labor-time').textContent = `${projectData.labor.hours} hours`;
            
            const floorArea = projectData.room.width * projectData.room.length;
            const wasteFactor = ((projectData.tiles.totalNeeded - floorArea) / floorArea * 100).toFixed(1);
            document.getElementById('waste-factor').textContent = `${wasteFactor}%`;
        }

        // Export data as JSON
        function exportData() {
            projectData.metadata.lastModified = new Date().toISOString();
            const dataStr = JSON.stringify(projectData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportName = `${projectData.projectName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportName);
            linkElement.click();
        }

        // Import data from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        projectData = { ...projectData, ...importedData };
                        projectData.metadata.lastModified = new Date().toISOString();
                        updateUI();
                        buildScene();
                    } catch (error) {
                        alert('Invalid JSON file. Please check the file format.');
                        console.error(error);
                    }
                };
                reader.readAsText(file);
            }
        }

        // Show JSON editor
        function showJsonEditor() {
            document.getElementById('json-textarea').value = JSON.stringify(projectData, null, 2);
            document.getElementById('json-editor').style.display = 'block';
        }

        // Hide JSON editor
        function hideJsonEditor() {
            document.getElementById('json-editor').style.display = 'none';
        }

        // Apply JSON data from editor
        function applyJsonData() {
            try {
                const newData = JSON.parse(document.getElementById('json-textarea').value);
                projectData = { ...projectData, ...newData };
                projectData.metadata.lastModified = new Date().toISOString();
                updateUI();
                buildScene();
                hideJsonEditor();
            } catch (error) {
                alert('Invalid JSON format. Please check your syntax.');
                console.error(error);
            }
        }

        // Load preset configuration
        function loadPreset(presetName) {
            if (presets[presetName]) {
                projectData = {
                    ...presets[presetName],
                    metadata: {
                        createdDate: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        version: "1.0"
                    }
                };
                updateUI();
                buildScene();
            }
        }

        // Mouse controls
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - window.innerWidth / 2) / window.innerWidth * 2;
            mouseY = (event.clientY - window.innerHeight / 2) / window.innerHeight * 2;
        });

        // Zoom controls
        document.addEventListener('wheel', (event) => {
            if (camera) {
                camera.position.multiplyScalar(1 + event.deltaY * 0.001);
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (roomGroup) {
                // Smooth camera rotation
                targetRotationY = mouseX * Math.PI * 0.5;
                targetRotationX = mouseY * Math.PI * 0.25;
                
                roomGroup.rotation.y += (targetRotationY - roomGroup.rotation.y) * 0.05;
                roomGroup.rotation.x += (targetRotationX - roomGroup.rotation.x) * 0.05;

                // Floating animation for boxes
                if (boxGroup) {
                    boxGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'BoxGeometry') {
                            child.position.y += Math.sin(Date.now() * 0.001 + index) * 0.001;
                        }
                    });
                }
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Initialize everything
        initScene();
        buildScene();
        updateUI();
        animate();
    </script>
</body>
</html>