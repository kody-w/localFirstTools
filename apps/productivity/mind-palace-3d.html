<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Palace 3D - Walk Through Your Ideas</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Crosshair */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 200;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        .controls-hint {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.6;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls-hint kbd {
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            margin: 0 2px;
        }

        .data-controls {
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            background: rgba(100, 100, 255, 0.3);
            border: 1px solid rgba(100, 100, 255, 0.5);
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .data-controls button:hover {
            background: rgba(100, 100, 255, 0.5);
            transform: translateY(-1px);
        }

        /* Room Info Panel */
        .room-info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 16px 24px;
            border-radius: 12px;
            text-align: center;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 200;
            min-width: 300px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .room-info.visible {
            opacity: 1;
        }

        .room-info h2 {
            font-size: 20px;
            margin-bottom: 6px;
            color: #fff;
        }

        .room-info p {
            font-size: 14px;
            color: #aaa;
        }

        .room-info .connections {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }

        /* Edit Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #1a1a24;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            margin-bottom: 20px;
            font-size: 22px;
            color: #fff;
        }

        .modal label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #aaa;
        }

        .modal input,
        .modal textarea,
        .modal select {
            width: 100%;
            padding: 12px;
            margin-bottom: 16px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .modal textarea {
            min-height: 80px;
            resize: vertical;
        }

        .modal input:focus,
        .modal textarea:focus,
        .modal select:focus {
            outline: none;
            border-color: rgba(100, 150, 255, 0.5);
            background: rgba(255, 255, 255, 0.12);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.8);
            color: white;
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 1);
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .minimap canvas {
            width: 100%;
            height: 100%;
        }

        /* Color Picker */
        .color-options {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Connection selector */
        .connection-list {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 16px;
        }

        .connection-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .connection-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .connection-item input {
            width: auto;
            margin: 0;
            margin-right: 10px;
        }

        .connection-item span {
            flex: 1;
        }

        .connection-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        /* Start Screen */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }

        .start-screen.hidden {
            display: none;
        }

        .start-screen h1 {
            font-size: 48px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-screen .subtitle {
            font-size: 18px;
            color: #888;
            margin-bottom: 40px;
        }

        .start-screen .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            max-width: 800px;
            margin-bottom: 40px;
        }

        .feature {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .feature-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .feature h3 {
            font-size: 16px;
            margin-bottom: 6px;
        }

        .feature p {
            font-size: 13px;
            color: #888;
        }

        .start-button {
            padding: 16px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
        }

        .start-hint {
            margin-top: 20px;
            font-size: 13px;
            color: #666;
        }

        /* Locked pointer state */
        body.pointer-locked .controls-hint {
            opacity: 0.5;
        }

        /* Hidden file input */
        #importFile {
            display: none;
        }

        /* Tooltip for objects */
        .object-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 300;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .object-tooltip.visible {
            display: block;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .ui-overlay {
                flex-direction: column;
                gap: 10px;
            }

            .controls-hint {
                font-size: 11px;
                padding: 10px 12px;
            }

            .minimap {
                width: 120px;
                height: 120px;
            }

            .start-screen h1 {
                font-size: 32px;
            }

            .start-screen .features {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <h1>Mind Palace 3D</h1>
        <p class="subtitle">Walk through your ideas like a museum</p>

        <div class="features">
            <div class="feature">
                <div class="feature-icon">üèõÔ∏è</div>
                <h3>Spatial Memory</h3>
                <p>Ideas become rooms, connections become hallways</p>
            </div>
            <div class="feature">
                <div class="feature-icon">üö∂</div>
                <h3>First-Person Exploration</h3>
                <p>Walk through your mind map in 3D</p>
            </div>
            <div class="feature">
                <div class="feature-icon">üîó</div>
                <h3>Connected Thinking</h3>
                <p>Link rooms to visualize relationships</p>
            </div>
            <div class="feature">
                <div class="feature-icon">üíæ</div>
                <h3>Local-First</h3>
                <p>Your palace is stored locally, export anytime</p>
            </div>
        </div>

        <button class="start-button" onclick="enterPalace()">Enter Your Palace</button>
        <p class="start-hint">Click to lock pointer, ESC to unlock. WASD to move, mouse to look.</p>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-container"></div>

    <div class="crosshair"></div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <div class="controls-hint">
            <kbd>WASD</kbd> Move &nbsp;|&nbsp;
            <kbd>Mouse</kbd> Look &nbsp;|&nbsp;
            <kbd>E</kbd> Edit Room &nbsp;|&nbsp;
            <kbd>N</kbd> New Room &nbsp;|&nbsp;
            <kbd>ESC</kbd> Unlock
        </div>
        <div class="data-controls">
            <button onclick="openNewRoomModal()">+ New Room</button>
            <button onclick="exportData()">Export</button>
            <button onclick="document.getElementById('importFile').click()">Import</button>
        </div>
    </div>
    <input type="file" id="importFile" accept=".json" onchange="importData(event)">

    <!-- Room Info -->
    <div class="room-info" id="roomInfo">
        <h2 id="roomTitle">Room Name</h2>
        <p id="roomDescription">Room description</p>
        <div class="connections" id="roomConnections"></div>
    </div>

    <!-- Minimap -->
    <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>

    <!-- Object Tooltip -->
    <div class="object-tooltip" id="objectTooltip"></div>

    <!-- Edit Modal -->
    <div class="modal-overlay" id="editModal">
        <div class="modal">
            <h2 id="modalTitle">Edit Room</h2>

            <label>Room Name</label>
            <input type="text" id="roomNameInput" placeholder="e.g., Project Ideas">

            <label>Description</label>
            <textarea id="roomDescInput" placeholder="What does this room represent?"></textarea>

            <label>Room Color</label>
            <div class="color-options" id="colorOptions"></div>

            <label>Connect to Rooms</label>
            <div class="connection-list" id="connectionList"></div>

            <div class="modal-buttons">
                <button class="btn-danger" id="deleteRoomBtn" onclick="deleteCurrentRoom()">Delete</button>
                <button class="btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn-primary" onclick="saveRoom()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // THREE.JS INLINE (Minimal implementation for self-contained app)
        // ============================================

        // Since we can't use external CDN, we'll create a simplified 3D engine
        // This is a custom lightweight implementation

        const APP_NAME = 'mind-palace-3d';

        // Room colors palette
        const ROOM_COLORS = [
            { name: 'Indigo', hex: '#6366f1', rgb: [0.39, 0.4, 0.95] },
            { name: 'Purple', hex: '#8b5cf6', rgb: [0.55, 0.36, 0.96] },
            { name: 'Pink', hex: '#ec4899', rgb: [0.93, 0.28, 0.6] },
            { name: 'Red', hex: '#ef4444', rgb: [0.94, 0.27, 0.27] },
            { name: 'Orange', hex: '#f97316', rgb: [0.98, 0.45, 0.09] },
            { name: 'Amber', hex: '#f59e0b', rgb: [0.96, 0.62, 0.04] },
            { name: 'Green', hex: '#22c55e', rgb: [0.13, 0.77, 0.37] },
            { name: 'Teal', hex: '#14b8a6', rgb: [0.08, 0.72, 0.65] },
            { name: 'Cyan', hex: '#06b6d4', rgb: [0.02, 0.71, 0.83] },
            { name: 'Blue', hex: '#3b82f6', rgb: [0.23, 0.51, 0.96] }
        ];

        // Default mind palace data
        const defaultPalaceData = {
            rooms: [
                {
                    id: 'lobby',
                    name: 'The Lobby',
                    description: 'Your central hub - where all ideas begin',
                    x: 0, y: 0, z: 0,
                    color: 0,
                    connections: ['ideas', 'projects'],
                    objects: [
                        { type: 'pedestal', label: 'Welcome', x: 0, z: 2 }
                    ]
                },
                {
                    id: 'ideas',
                    name: 'Idea Chamber',
                    description: 'Raw concepts and brainstorms',
                    x: 30, y: 0, z: 0,
                    color: 1,
                    connections: ['lobby'],
                    objects: []
                },
                {
                    id: 'projects',
                    name: 'Project Vault',
                    description: 'Active works in progress',
                    x: 0, y: 0, z: 30,
                    color: 4,
                    connections: ['lobby'],
                    objects: []
                }
            ],
            lastVisited: 'lobby',
            created: Date.now()
        };

        // Load data
        let palaceData = JSON.parse(localStorage.getItem(APP_NAME)) || defaultPalaceData;

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(palaceData));
        }

        function exportData() {
            const dataStr = JSON.stringify(palaceData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.rooms && Array.isArray(imported.rooms)) {
                        palaceData = imported;
                        saveData();
                        location.reload();
                    } else {
                        alert('Invalid palace data format');
                    }
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        // ============================================
        // WebGL 3D Engine
        // ============================================

        let canvas, gl;
        let camera = { x: 0, y: 1.7, z: 5, rx: 0, ry: 0 };
        let velocity = { x: 0, z: 0 };
        let keys = {};
        let isPointerLocked = false;
        let currentRoom = null;
        let editingRoom = null;

        const ROOM_SIZE = 12;
        const WALL_HEIGHT = 4;
        const HALLWAY_WIDTH = 3;
        const HALLWAY_LENGTH = 8;

        // Matrices
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ]);
        }

        function mat4LookAt(eye, target, up) {
            const zx = eye[0] - target[0], zy = eye[1] - target[1], zz = eye[2] - target[2];
            const zl = Math.sqrt(zx*zx + zy*zy + zz*zz);
            const z = [zx/zl, zy/zl, zz/zl];

            const xx = up[1]*z[2] - up[2]*z[1];
            const xy = up[2]*z[0] - up[0]*z[2];
            const xz = up[0]*z[1] - up[1]*z[0];
            const xl = Math.sqrt(xx*xx + xy*xy + xz*xz);
            const x = [xx/xl, xy/xl, xz/xl];

            const y = [z[1]*x[2] - z[2]*x[1], z[2]*x[0] - z[0]*x[2], z[0]*x[1] - z[1]*x[0]];

            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -(x[0]*eye[0] + x[1]*eye[1] + x[2]*eye[2]),
                -(y[0]*eye[0] + y[1]*eye[1] + y[2]*eye[2]),
                -(z[0]*eye[0] + z[1]*eye[1] + z[2]*eye[2]),
                1
            ]);
        }

        function mat4Multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] =
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        // Shader sources
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec3 aColor;

            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform mat4 uModel;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vPosition;

            void main() {
                vec4 worldPos = uModel * vec4(aPosition, 1.0);
                gl_Position = uProjection * uView * worldPos;
                vColor = aColor;
                vNormal = mat3(uModel) * aNormal;
                vPosition = worldPos.xyz;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;

            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vPosition;

            uniform vec3 uLightPos;
            uniform vec3 uCameraPos;
            uniform float uAmbient;
            uniform float uFogDensity;
            uniform vec3 uFogColor;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPos - vPosition);

                float diff = max(dot(normal, lightDir), 0.0);
                vec3 lighting = vColor * (uAmbient + diff * 0.6);

                // Fog
                float dist = length(uCameraPos - vPosition);
                float fog = 1.0 - exp(-uFogDensity * dist);
                vec3 finalColor = mix(lighting, uFogColor, fog);

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Geometry builders
        function createCube(w, h, d, color) {
            const hw = w/2, hh = h/2, hd = d/2;
            const c = color;

            // Positions, normals, colors for each face
            const vertices = [];
            const normals = [];
            const colors = [];

            // Front
            vertices.push(-hw,-hh,hd, hw,-hh,hd, hw,hh,hd, -hw,-hh,hd, hw,hh,hd, -hw,hh,hd);
            for(let i=0;i<6;i++) { normals.push(0,0,1); colors.push(...c); }

            // Back
            vertices.push(hw,-hh,-hd, -hw,-hh,-hd, -hw,hh,-hd, hw,-hh,-hd, -hw,hh,-hd, hw,hh,-hd);
            for(let i=0;i<6;i++) { normals.push(0,0,-1); colors.push(...c); }

            // Right
            vertices.push(hw,-hh,hd, hw,-hh,-hd, hw,hh,-hd, hw,-hh,hd, hw,hh,-hd, hw,hh,hd);
            for(let i=0;i<6;i++) { normals.push(1,0,0); colors.push(...c); }

            // Left
            vertices.push(-hw,-hh,-hd, -hw,-hh,hd, -hw,hh,hd, -hw,-hh,-hd, -hw,hh,hd, -hw,hh,-hd);
            for(let i=0;i<6;i++) { normals.push(-1,0,0); colors.push(...c); }

            // Top
            vertices.push(-hw,hh,hd, hw,hh,hd, hw,hh,-hd, -hw,hh,hd, hw,hh,-hd, -hw,hh,-hd);
            for(let i=0;i<6;i++) { normals.push(0,1,0); colors.push(...c); }

            // Bottom
            vertices.push(-hw,-hh,-hd, hw,-hh,-hd, hw,-hh,hd, -hw,-hh,-hd, hw,-hh,hd, -hw,-hh,hd);
            for(let i=0;i<6;i++) { normals.push(0,-1,0); colors.push(...c); }

            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), colors: new Float32Array(colors) };
        }

        function createFloor(w, d, color) {
            const hw = w/2, hd = d/2;
            return {
                vertices: new Float32Array([
                    -hw, 0, hd,  hw, 0, hd,  hw, 0, -hd,
                    -hw, 0, hd,  hw, 0, -hd,  -hw, 0, -hd
                ]),
                normals: new Float32Array([0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0]),
                colors: new Float32Array([...color,...color,...color,...color,...color,...color])
            };
        }

        function createWall(w, h, color) {
            const hw = w/2, hh = h/2;
            return {
                vertices: new Float32Array([
                    -hw, 0, 0,  hw, 0, 0,  hw, h, 0,
                    -hw, 0, 0,  hw, h, 0,  -hw, h, 0
                ]),
                normals: new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]),
                colors: new Float32Array([...color,...color,...color,...color,...color,...color])
            };
        }

        let meshes = [];
        let shaderProgram;
        let projectionMatrix;

        function initWebGL() {
            canvas = document.createElement('canvas');
            document.getElementById('canvas-container').appendChild(canvas);

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported');
                return;
            }

            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);

            // Compile shaders
            const vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertexShaderSource);
            gl.compileShader(vertShader);

            const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragmentShaderSource);
            gl.compileShader(fragShader);

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

            // Get attribute/uniform locations
            shaderProgram.aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            shaderProgram.aNormal = gl.getAttribLocation(shaderProgram, 'aNormal');
            shaderProgram.aColor = gl.getAttribLocation(shaderProgram, 'aColor');
            shaderProgram.uProjection = gl.getUniformLocation(shaderProgram, 'uProjection');
            shaderProgram.uView = gl.getUniformLocation(shaderProgram, 'uView');
            shaderProgram.uModel = gl.getUniformLocation(shaderProgram, 'uModel');
            shaderProgram.uLightPos = gl.getUniformLocation(shaderProgram, 'uLightPos');
            shaderProgram.uCameraPos = gl.getUniformLocation(shaderProgram, 'uCameraPos');
            shaderProgram.uAmbient = gl.getUniformLocation(shaderProgram, 'uAmbient');
            shaderProgram.uFogDensity = gl.getUniformLocation(shaderProgram, 'uFogDensity');
            shaderProgram.uFogColor = gl.getUniformLocation(shaderProgram, 'uFogColor');

            gl.enableVertexAttribArray(shaderProgram.aPosition);
            gl.enableVertexAttribArray(shaderProgram.aNormal);
            gl.enableVertexAttribArray(shaderProgram.aColor);

            // Set projection
            projectionMatrix = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 200);
            gl.uniformMatrix4fv(shaderProgram.uProjection, false, projectionMatrix);

            // Light and fog
            gl.uniform3f(shaderProgram.uLightPos, 0, 20, 0);
            gl.uniform1f(shaderProgram.uAmbient, 0.3);
            gl.uniform1f(shaderProgram.uFogDensity, 0.015);
            gl.uniform3f(shaderProgram.uFogColor, 0.04, 0.04, 0.06);

            buildPalaceGeometry();
        }

        function createMesh(geometry, x, y, z) {
            const mesh = {
                vertexBuffer: gl.createBuffer(),
                normalBuffer: gl.createBuffer(),
                colorBuffer: gl.createBuffer(),
                vertexCount: geometry.vertices.length / 3,
                position: [x || 0, y || 0, z || 0]
            };

            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.vertices, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.normals, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.colors, gl.STATIC_DRAW);

            return mesh;
        }

        function buildPalaceGeometry() {
            meshes = [];

            const floorColor = [0.08, 0.08, 0.1];
            const wallBaseColor = [0.12, 0.12, 0.15];

            palaceData.rooms.forEach(room => {
                const roomColor = ROOM_COLORS[room.color || 0].rgb;
                const wallColor = roomColor.map(c => c * 0.4);

                // Floor
                meshes.push(createMesh(createFloor(ROOM_SIZE, ROOM_SIZE, floorColor), room.x, 0, room.z));

                // Ceiling glow
                const ceilingColor = roomColor.map(c => c * 0.15);
                meshes.push(createMesh(createFloor(ROOM_SIZE, ROOM_SIZE, ceilingColor), room.x, WALL_HEIGHT, room.z));

                // Determine which walls have doorways
                const doorways = { north: false, south: false, east: false, west: false };

                room.connections.forEach(connId => {
                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (!connRoom) return;

                    const dx = connRoom.x - room.x;
                    const dz = connRoom.z - room.z;

                    if (Math.abs(dx) > Math.abs(dz)) {
                        if (dx > 0) doorways.east = true;
                        else doorways.west = true;
                    } else {
                        if (dz > 0) doorways.south = true;
                        else doorways.north = true;
                    }
                });

                // Build walls with or without doorways
                const hs = ROOM_SIZE / 2;
                const dw = HALLWAY_WIDTH / 2;

                // North wall (negative Z)
                if (!doorways.north) {
                    meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor),
                        room.x, 0, room.z - hs, 0));
                } else {
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x - (hs + dw) / 2, 0, room.z - hs, 0));
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x + (hs + dw) / 2, 0, room.z - hs, 0));
                }

                // South wall (positive Z)
                if (!doorways.south) {
                    meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor),
                        room.x, 0, room.z + hs, Math.PI));
                } else {
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x - (hs + dw) / 2, 0, room.z + hs, Math.PI));
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x + (hs + dw) / 2, 0, room.z + hs, Math.PI));
                }

                // East wall (positive X)
                if (!doorways.east) {
                    meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor),
                        room.x + hs, 0, room.z, -Math.PI / 2));
                } else {
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x + hs, 0, room.z - (hs + dw) / 2, -Math.PI / 2));
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x + hs, 0, room.z + (hs + dw) / 2, -Math.PI / 2));
                }

                // West wall (negative X)
                if (!doorways.west) {
                    meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor),
                        room.x - hs, 0, room.z, Math.PI / 2));
                } else {
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x - hs, 0, room.z - (hs + dw) / 2, Math.PI / 2));
                    meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor),
                        room.x - hs, 0, room.z + (hs + dw) / 2, Math.PI / 2));
                }

                // Room center marker (glowing pedestal)
                const pedestalColor = roomColor;
                meshes.push(createMesh(createCube(0.8, 0.1, 0.8, pedestalColor), room.x, 0.05, room.z));
                meshes.push(createMesh(createCube(0.4, 0.6, 0.4, pedestalColor.map(c => c * 0.7)), room.x, 0.35, room.z));
            });

            // Build hallways between connected rooms
            const builtHallways = new Set();

            palaceData.rooms.forEach(room => {
                room.connections.forEach(connId => {
                    const hallwayKey = [room.id, connId].sort().join('-');
                    if (builtHallways.has(hallwayKey)) return;
                    builtHallways.add(hallwayKey);

                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (!connRoom) return;

                    const color1 = ROOM_COLORS[room.color || 0].rgb;
                    const color2 = ROOM_COLORS[connRoom.color || 0].rgb;
                    const hallwayColor = color1.map((c, i) => (c + color2[i]) / 2 * 0.3);

                    // Calculate hallway position and orientation
                    const mx = (room.x + connRoom.x) / 2;
                    const mz = (room.z + connRoom.z) / 2;
                    const dx = connRoom.x - room.x;
                    const dz = connRoom.z - room.z;
                    const length = Math.sqrt(dx * dx + dz * dz) - ROOM_SIZE;
                    const angle = Math.atan2(dx, dz);

                    // Hallway floor
                    meshes.push(createMeshWithTransform(
                        createFloor(HALLWAY_WIDTH, length, floorColor),
                        mx, 0, mz, angle
                    ));

                    // Hallway ceiling
                    meshes.push(createMeshWithTransform(
                        createFloor(HALLWAY_WIDTH, length, hallwayColor),
                        mx, WALL_HEIGHT, mz, angle
                    ));

                    // Hallway walls
                    meshes.push(createMeshWithTransform(
                        createWall(length, WALL_HEIGHT, hallwayColor),
                        mx + Math.cos(angle) * HALLWAY_WIDTH / 2, 0, mz - Math.sin(angle) * HALLWAY_WIDTH / 2,
                        angle + Math.PI / 2
                    ));
                    meshes.push(createMeshWithTransform(
                        createWall(length, WALL_HEIGHT, hallwayColor),
                        mx - Math.cos(angle) * HALLWAY_WIDTH / 2, 0, mz + Math.sin(angle) * HALLWAY_WIDTH / 2,
                        angle - Math.PI / 2
                    ));
                });
            });
        }

        function createMeshWithTransform(geometry, x, y, z, rotation) {
            const mesh = createMesh(geometry, 0, 0, 0);
            mesh.position = [x, y, z];
            mesh.rotation = rotation || 0;
            return mesh;
        }

        function getModelMatrix(mesh) {
            const cos = Math.cos(mesh.rotation || 0);
            const sin = Math.sin(mesh.rotation || 0);
            const [tx, ty, tz] = mesh.position;

            return new Float32Array([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                tx, ty, tz, 1
            ]);
        }

        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.04, 0.04, 0.06, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Calculate view direction
            const lookX = camera.x + Math.sin(camera.ry) * Math.cos(camera.rx);
            const lookY = camera.y + Math.sin(camera.rx);
            const lookZ = camera.z + Math.cos(camera.ry) * Math.cos(camera.rx);

            const viewMatrix = mat4LookAt(
                [camera.x, camera.y, camera.z],
                [lookX, lookY, lookZ],
                [0, 1, 0]
            );

            gl.uniformMatrix4fv(shaderProgram.uView, false, viewMatrix);
            gl.uniform3f(shaderProgram.uCameraPos, camera.x, camera.y, camera.z);

            meshes.forEach(mesh => {
                gl.uniformMatrix4fv(shaderProgram.uModel, false, getModelMatrix(mesh));

                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                gl.vertexAttribPointer(shaderProgram.aPosition, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                gl.vertexAttribPointer(shaderProgram.aNormal, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
                gl.vertexAttribPointer(shaderProgram.aColor, 3, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.TRIANGLES, 0, mesh.vertexCount);
            });
        }

        // ============================================
        // Movement & Controls
        // ============================================

        function updateMovement() {
            if (!isPointerLocked) return;

            const speed = 0.15;
            const friction = 0.85;

            let moveX = 0, moveZ = 0;

            if (keys['w'] || keys['arrowup']) moveZ -= 1;
            if (keys['s'] || keys['arrowdown']) moveZ += 1;
            if (keys['a'] || keys['arrowleft']) moveX -= 1;
            if (keys['d'] || keys['arrowright']) moveX += 1;

            // Rotate movement direction by camera yaw
            const sin = Math.sin(camera.ry);
            const cos = Math.cos(camera.ry);

            velocity.x += (moveX * cos - moveZ * sin) * speed;
            velocity.z += (moveX * sin + moveZ * cos) * speed;

            velocity.x *= friction;
            velocity.z *= friction;

            // Simple collision (stay within bounds)
            const newX = camera.x + velocity.x;
            const newZ = camera.z + velocity.z;

            // Check if new position is valid (inside a room or hallway)
            if (isValidPosition(newX, newZ)) {
                camera.x = newX;
                camera.z = newZ;
            } else {
                // Try sliding along walls
                if (isValidPosition(newX, camera.z)) {
                    camera.x = newX;
                } else if (isValidPosition(camera.x, newZ)) {
                    camera.z = newZ;
                }
                velocity.x *= 0.5;
                velocity.z *= 0.5;
            }

            // Update current room
            updateCurrentRoom();
        }

        function isValidPosition(x, z) {
            const margin = 0.5;

            // Check rooms
            for (const room of palaceData.rooms) {
                const hs = ROOM_SIZE / 2 - margin;
                if (x >= room.x - hs && x <= room.x + hs &&
                    z >= room.z - hs && z <= room.z + hs) {
                    return true;
                }
            }

            // Check hallways
            const builtHallways = new Set();
            for (const room of palaceData.rooms) {
                for (const connId of room.connections) {
                    const hallwayKey = [room.id, connId].sort().join('-');
                    if (builtHallways.has(hallwayKey)) continue;
                    builtHallways.add(hallwayKey);

                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (!connRoom) continue;

                    // Check if point is in hallway
                    const mx = (room.x + connRoom.x) / 2;
                    const mz = (room.z + connRoom.z) / 2;
                    const dx = connRoom.x - room.x;
                    const dz = connRoom.z - room.z;
                    const length = Math.sqrt(dx * dx + dz * dz);

                    // Transform point to hallway local space
                    const angle = Math.atan2(dx, dz);
                    const cos = Math.cos(-angle);
                    const sin = Math.sin(-angle);
                    const localX = (x - mx) * cos - (z - mz) * sin;
                    const localZ = (x - mx) * sin + (z - mz) * cos;

                    const hw = HALLWAY_WIDTH / 2 - margin;
                    const hl = length / 2;

                    if (Math.abs(localX) <= hw && Math.abs(localZ) <= hl) {
                        return true;
                    }
                }
            }

            return false;
        }

        function updateCurrentRoom() {
            let closest = null;
            let closestDist = Infinity;

            palaceData.rooms.forEach(room => {
                const dist = Math.sqrt((camera.x - room.x) ** 2 + (camera.z - room.z) ** 2);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = room;
                }
            });

            const roomInfo = document.getElementById('roomInfo');

            if (closest && closestDist < ROOM_SIZE / 2 + 1) {
                if (currentRoom !== closest) {
                    currentRoom = closest;
                    palaceData.lastVisited = closest.id;
                    saveData();
                }

                document.getElementById('roomTitle').textContent = closest.name;
                document.getElementById('roomDescription').textContent = closest.description;

                const connections = closest.connections
                    .map(id => palaceData.rooms.find(r => r.id === id)?.name)
                    .filter(Boolean);

                document.getElementById('roomConnections').textContent =
                    connections.length ? `Connected to: ${connections.join(', ')}` : '';

                roomInfo.classList.add('visible');
            } else {
                roomInfo.classList.remove('visible');
                currentRoom = null;
            }
        }

        // ============================================
        // Minimap
        // ============================================

        function updateMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            const ctx = minimapCanvas.getContext('2d');

            minimapCanvas.width = 180;
            minimapCanvas.height = 180;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, 180, 180);

            // Calculate bounds
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            palaceData.rooms.forEach(room => {
                minX = Math.min(minX, room.x);
                maxX = Math.max(maxX, room.x);
                minZ = Math.min(minZ, room.z);
                maxZ = Math.max(maxZ, room.z);
            });

            const padding = 30;
            const rangeX = Math.max(maxX - minX, 1);
            const rangeZ = Math.max(maxZ - minZ, 1);
            const scale = Math.min((180 - padding * 2) / rangeX, (180 - padding * 2) / rangeZ, 3);

            const offsetX = 90 - (minX + maxX) / 2 * scale;
            const offsetZ = 90 - (minZ + maxZ) / 2 * scale;

            // Draw connections
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;

            const drawnConnections = new Set();
            palaceData.rooms.forEach(room => {
                room.connections.forEach(connId => {
                    const key = [room.id, connId].sort().join('-');
                    if (drawnConnections.has(key)) return;
                    drawnConnections.add(key);

                    const conn = palaceData.rooms.find(r => r.id === connId);
                    if (!conn) return;

                    ctx.beginPath();
                    ctx.moveTo(room.x * scale + offsetX, room.z * scale + offsetZ);
                    ctx.lineTo(conn.x * scale + offsetX, conn.z * scale + offsetZ);
                    ctx.stroke();
                });
            });

            // Draw rooms
            palaceData.rooms.forEach(room => {
                const color = ROOM_COLORS[room.color || 0].hex;
                const x = room.x * scale + offsetX;
                const z = room.z * scale + offsetZ;
                const size = ROOM_SIZE * scale / 2;

                ctx.fillStyle = room === currentRoom ? color : color + '80';
                ctx.fillRect(x - size/2, z - size/2, size, size);

                if (room === currentRoom) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - size/2, z - size/2, size, size);
                }
            });

            // Draw player
            const px = camera.x * scale + offsetX;
            const pz = camera.z * scale + offsetZ;

            ctx.save();
            ctx.translate(px, pz);
            ctx.rotate(-camera.ry);

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(-4, 4);
            ctx.lineTo(4, 4);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // ============================================
        // Room Editing
        // ============================================

        let selectedColor = 0;

        function openNewRoomModal() {
            editingRoom = null;
            document.getElementById('modalTitle').textContent = 'Create New Room';
            document.getElementById('roomNameInput').value = '';
            document.getElementById('roomDescInput').value = '';
            document.getElementById('deleteRoomBtn').style.display = 'none';
            selectedColor = Math.floor(Math.random() * ROOM_COLORS.length);

            renderColorOptions();
            renderConnectionList();

            document.getElementById('editModal').classList.add('active');
            document.exitPointerLock();
        }

        function openEditModal() {
            if (!currentRoom) return;

            editingRoom = currentRoom;
            document.getElementById('modalTitle').textContent = 'Edit Room';
            document.getElementById('roomNameInput').value = currentRoom.name;
            document.getElementById('roomDescInput').value = currentRoom.description;
            document.getElementById('deleteRoomBtn').style.display = palaceData.rooms.length > 1 ? 'block' : 'none';
            selectedColor = currentRoom.color || 0;

            renderColorOptions();
            renderConnectionList();

            document.getElementById('editModal').classList.add('active');
            document.exitPointerLock();
        }

        function renderColorOptions() {
            const container = document.getElementById('colorOptions');
            container.innerHTML = '';

            ROOM_COLORS.forEach((color, i) => {
                const div = document.createElement('div');
                div.className = 'color-option' + (i === selectedColor ? ' selected' : '');
                div.style.background = color.hex;
                div.onclick = () => {
                    selectedColor = i;
                    renderColorOptions();
                };
                container.appendChild(div);
            });
        }

        function renderConnectionList() {
            const container = document.getElementById('connectionList');
            container.innerHTML = '';

            const currentConnections = editingRoom ? editingRoom.connections : [];

            palaceData.rooms.forEach(room => {
                if (editingRoom && room.id === editingRoom.id) return;

                const div = document.createElement('div');
                div.className = 'connection-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = currentConnections.includes(room.id);
                checkbox.id = `conn-${room.id}`;

                const colorDot = document.createElement('div');
                colorDot.className = 'connection-color';
                colorDot.style.background = ROOM_COLORS[room.color || 0].hex;

                const label = document.createElement('span');
                label.textContent = room.name;

                div.appendChild(checkbox);
                div.appendChild(colorDot);
                div.appendChild(label);
                div.onclick = (e) => {
                    if (e.target !== checkbox) checkbox.checked = !checkbox.checked;
                };

                container.appendChild(div);
            });
        }

        function closeModal() {
            document.getElementById('editModal').classList.remove('active');
            editingRoom = null;
        }

        function saveRoom() {
            const name = document.getElementById('roomNameInput').value.trim();
            const description = document.getElementById('roomDescInput').value.trim();

            if (!name) {
                alert('Please enter a room name');
                return;
            }

            // Gather connections
            const connections = [];
            palaceData.rooms.forEach(room => {
                const checkbox = document.getElementById(`conn-${room.id}`);
                if (checkbox && checkbox.checked) {
                    connections.push(room.id);
                }
            });

            if (editingRoom) {
                // Update existing room
                editingRoom.name = name;
                editingRoom.description = description;
                editingRoom.color = selectedColor;

                // Update connections (bidirectional)
                const oldConnections = [...editingRoom.connections];

                // Remove old connections
                oldConnections.forEach(connId => {
                    if (!connections.includes(connId)) {
                        const connRoom = palaceData.rooms.find(r => r.id === connId);
                        if (connRoom) {
                            connRoom.connections = connRoom.connections.filter(id => id !== editingRoom.id);
                        }
                    }
                });

                // Add new connections
                connections.forEach(connId => {
                    if (!oldConnections.includes(connId)) {
                        const connRoom = palaceData.rooms.find(r => r.id === connId);
                        if (connRoom && !connRoom.connections.includes(editingRoom.id)) {
                            connRoom.connections.push(editingRoom.id);
                        }
                    }
                });

                editingRoom.connections = connections;
            } else {
                // Create new room
                const id = 'room-' + Date.now();

                // Find position for new room
                let newX = 0, newZ = 0;

                if (connections.length > 0) {
                    // Place near first connected room
                    const connRoom = palaceData.rooms.find(r => r.id === connections[0]);
                    if (connRoom) {
                        // Find an available direction
                        const directions = [
                            { x: ROOM_SIZE + HALLWAY_LENGTH, z: 0 },
                            { x: -ROOM_SIZE - HALLWAY_LENGTH, z: 0 },
                            { x: 0, z: ROOM_SIZE + HALLWAY_LENGTH },
                            { x: 0, z: -ROOM_SIZE - HALLWAY_LENGTH }
                        ];

                        for (const dir of directions) {
                            const testX = connRoom.x + dir.x;
                            const testZ = connRoom.z + dir.z;

                            const occupied = palaceData.rooms.some(r =>
                                Math.abs(r.x - testX) < ROOM_SIZE && Math.abs(r.z - testZ) < ROOM_SIZE
                            );

                            if (!occupied) {
                                newX = testX;
                                newZ = testZ;
                                break;
                            }
                        }
                    }
                } else {
                    // Place at camera position (rounded to grid)
                    newX = Math.round(camera.x / (ROOM_SIZE + HALLWAY_LENGTH)) * (ROOM_SIZE + HALLWAY_LENGTH);
                    newZ = Math.round(camera.z / (ROOM_SIZE + HALLWAY_LENGTH)) * (ROOM_SIZE + HALLWAY_LENGTH);
                }

                const newRoom = {
                    id,
                    name,
                    description,
                    x: newX,
                    y: 0,
                    z: newZ,
                    color: selectedColor,
                    connections,
                    objects: []
                };

                palaceData.rooms.push(newRoom);

                // Add reverse connections
                connections.forEach(connId => {
                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (connRoom && !connRoom.connections.includes(id)) {
                        connRoom.connections.push(id);
                    }
                });
            }

            saveData();
            buildPalaceGeometry();
            closeModal();
        }

        function deleteCurrentRoom() {
            if (!editingRoom || palaceData.rooms.length <= 1) return;

            if (!confirm(`Delete "${editingRoom.name}"? This cannot be undone.`)) return;

            // Remove connections from other rooms
            palaceData.rooms.forEach(room => {
                room.connections = room.connections.filter(id => id !== editingRoom.id);
            });

            // Remove room
            palaceData.rooms = palaceData.rooms.filter(r => r.id !== editingRoom.id);

            // Teleport player to first room if needed
            if (currentRoom === editingRoom) {
                const firstRoom = palaceData.rooms[0];
                camera.x = firstRoom.x;
                camera.z = firstRoom.z;
            }

            saveData();
            buildPalaceGeometry();
            closeModal();
        }

        // ============================================
        // Event Handlers
        // ============================================

        function enterPalace() {
            document.getElementById('startScreen').classList.add('hidden');

            // Position player at last visited room
            const startRoom = palaceData.rooms.find(r => r.id === palaceData.lastVisited) || palaceData.rooms[0];
            camera.x = startRoom.x;
            camera.z = startRoom.z + 3;
            camera.ry = Math.PI;

            // Start animation loop
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            updateMovement();
            render();
            updateMinimap();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key.toLowerCase() === 'e' && isPointerLocked) {
                openEditModal();
            }

            if (e.key.toLowerCase() === 'n' && isPointerLocked) {
                openNewRoomModal();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;

            camera.ry -= e.movementX * 0.002;
            camera.rx -= e.movementY * 0.002;
            camera.rx = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, camera.rx));
        });

        document.addEventListener('click', (e) => {
            if (!document.getElementById('startScreen').classList.contains('hidden')) return;
            if (document.getElementById('editModal').classList.contains('active')) return;

            if (!isPointerLocked) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
            document.body.classList.toggle('pointer-locked', isPointerLocked);
        });

        window.addEventListener('resize', () => {
            if (!canvas) return;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            projectionMatrix = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 200);
            gl.uniformMatrix4fv(shaderProgram.uProjection, false, projectionMatrix);
        });

        // Initialize
        initWebGL();
    </script>
</body>
</html>