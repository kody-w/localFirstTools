<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Factory World - Autonomous Literary Production</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Book Factory Header */
        .factory-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .factory-title {
            font-size: 36px;
            font-weight: bold;
            background: linear-gradient(45deg, #ffd700, #ff8c00, #ff6347);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 3px;
        }

        .factory-subtitle {
            color: #888;
            font-size: 14px;
            text-align: center;
            margin-top: 5px;
            font-style: italic;
        }

        /* Overseer Command Center */
        .overseer-center {
            position: fixed;
            top: 100px;
            left: 20px;
            width: 400px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            max-height: 600px;
            overflow-y: auto;
        }

        .overseer-portrait {
            width: 100px;
            height: 100px;
            margin: 0 auto 15px;
            background: radial-gradient(circle, #ffd700, #ff8c00);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 50px;
            animation: overseerGlow 3s infinite;
        }

        @keyframes overseerGlow {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
            50% { box-shadow: 0 0 60px rgba(255, 215, 0, 1); }
        }

        .overseer-name {
            text-align: center;
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .overseer-role {
            text-align: center;
            color: #ff8c00;
            font-size: 14px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .overseer-thoughts {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .overseer-thought {
            color: #ffd700;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-style: italic;
            animation: thoughtAppear 0.5s;
        }

        .overseer-thought.core-memory {
            border-left: 3px solid #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }

        @keyframes thoughtAppear {
            from { 
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .overseer-decision {
            background: rgba(255, 140, 0, 0.1);
            border: 1px solid #ff8c00;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }

        .decision-label {
            color: #ff8c00;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .decision-value {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
        }

        /* Memory Indicator */
        .memory-indicator {
            position: fixed;
            top: 100px;
            left: 430px;
            width: 150px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            z-index: 1000;
        }

        .memory-label {
            color: #ff00ff;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .core-memory-count {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
        }

        /* Book Project Status */
        .book-status {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 350px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-height: 600px;
            overflow-y: auto;
        }

        .book-title-display {
            color: #00ff00;
            font-size: 20px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        .book-metadata {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .metadata-item {
            background: rgba(0, 255, 0, 0.1);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .metadata-label {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
        }

        .metadata-value {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
        }

        .quality-breakdown {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 11px;
        }

        .quality-metric {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            color: #aaa;
        }

        .quality-metric span:last-child {
            color: #00ff00;
            font-weight: bold;
        }

        .chapter-progress {
            margin-top: 20px;
        }

        .chapter-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 0, 0.2);
        }

        .chapter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .chapter-name {
            color: #00ff00;
            font-weight: bold;
            font-size: 14px;
        }

        .chapter-status {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            text-transform: uppercase;
        }

        .chapter-status.planning { background: #ffd700; color: #000; }
        .chapter-status.writing { background: #ff8c00; color: #000; }
        .chapter-status.editing { background: #00ffff; color: #000; }
        .chapter-status.reviewing { background: #ff00ff; color: #fff; }
        .chapter-status.complete { background: #00ff00; color: #000; }

        .chapter-progress-bar {
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }

        .chapter-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff);
            transition: width 0.5s;
        }

        .chapter-preview {
            color: #888;
            font-size: 11px;
            margin-top: 5px;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Worker Floor */
        .worker-floor {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 280px;
            background: linear-gradient(180deg, transparent, rgba(0,0,0,0.9));
            padding: 20px;
            z-index: 1000;
            overflow-x: auto;
        }

        .worker-container {
            display: flex;
            gap: 15px;
            height: 100%;
        }

        .worker-station {
            min-width: 200px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .worker-station.planner { border-color: #ff8c00; }
        .worker-station.writer { border-color: #ff6347; }
        .worker-station.editor { border-color: #00ffff; }
        .worker-station.reviewer { border-color: #ff00ff; }
        .worker-station.publisher { border-color: #00ff00; }

        .worker-avatar {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }

        .worker-avatar.planner { background: radial-gradient(circle, #ff8c00, #ff6600); }
        .worker-avatar.writer { background: radial-gradient(circle, #ff6347, #ff4500); }
        .worker-avatar.editor { background: radial-gradient(circle, #00ffff, #0088ff); }
        .worker-avatar.reviewer { background: radial-gradient(circle, #ff00ff, #8800ff); }
        .worker-avatar.publisher { background: radial-gradient(circle, #00ff00, #008800); }

        .worker-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .worker-name {
            color: #fff;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .worker-role {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
        }

        .worker-status-bar {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: statusPulse 2s infinite;
        }

        .status-dot.active { background: #00ff00; }
        .status-dot.thinking { background: #ffff00; }
        .status-dot.waiting { background: #ff8c00; }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .worker-current-task {
            color: #00ffff;
            font-size: 12px;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
        }

        .worker-memory-stats {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #888;
        }

        .memory-stat {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .memory-stat.core {
            color: #ff00ff;
        }

        .worker-dialogue-bubble {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
            min-width: 180px;
            max-width: 250px;
            display: none;
        }

        .worker-station.speaking .worker-dialogue-bubble {
            display: block;
            animation: bubbleAppear 0.3s;
        }

        @keyframes bubbleAppear {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .dialogue-content {
            color: #00ffff;
            font-size: 13px;
            line-height: 1.4;
        }

        /* Transcript Display */
        .transcript-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            max-height: 600px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff00ff;
            border-radius: 15px;
            padding: 20px;
            z-index: 2000;
            display: none;
            overflow-y: auto;
        }

        .transcript-panel.active {
            display: block;
        }

        .transcript-header {
            color: #ff00ff;
            font-size: 20px;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
        }

        .transcript-entry {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid #ff00ff;
        }

        .transcript-entry.memory-formation {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.05);
        }

        .transcript-speaker {
            color: #ff00ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .transcript-message {
            color: #fff;
            font-size: 14px;
            line-height: 1.5;
        }

        .transcript-timestamp {
            color: #888;
            font-size: 11px;
            margin-top: 5px;
            text-align: right;
        }

        /* Control Buttons */
        .control-panel {
            position: fixed;
            bottom: 300px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1001;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 50%;
            color: #ffd700;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .control-btn.active {
            background: #ffd700;
            color: #000;
        }

        /* Timeline Control */
        .timeline-control {
            position: fixed;
            bottom: 290px;
            left: 20px;
            right: 420px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            z-index: 1001;
        }

        .timeline-header {
            color: #00ff00;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timeline-title {
            font-weight: bold;
        }

        .timeline-time {
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }

        .timeline-slider {
            width: 100%;
            height: 40px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
        }

        .timeline-slider::-webkit-slider-track {
            height: 8px;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            border-radius: 4px;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 3px solid #00ff00;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Output Panel */
        .output-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 900px;
            height: 80%;
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            z-index: 3000;
            display: none;
            overflow-y: auto;
        }

        .output-panel.active {
            display: block;
        }

        .output-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .output-book-title {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .output-author {
            color: #ff8c00;
            font-size: 18px;
            font-style: italic;
        }

        .output-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 10px;
            font-family: 'Georgia', serif;
            line-height: 1.8;
            color: #fff;
        }

        .output-chapter {
            margin-bottom: 40px;
            page-break-after: always;
        }

        .output-chapter-title {
            font-size: 24px;
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
        }

        .output-chapter-content {
            text-align: justify;
            font-size: 16px;
            line-height: 2;
        }

        .output-chapter-content p {
            margin-bottom: 15px;
            text-indent: 30px;
        }

        .output-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: #ff0000;
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .output-close:hover {
            transform: rotate(90deg);
            background: #ff4444;
        }

        /* Import/Export Panel */
        .import-export-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            background: rgba(20, 20, 40, 0.98);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 25px;
            z-index: 2500;
            display: none;
        }

        .import-export-panel.active {
            display: block;
        }

        .ie-header {
            color: #00ffff;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
        }

        .ie-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .ie-button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .ie-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 50%;
            right: -400px;
            transform: translateY(-50%);
            width: 380px;
            background: rgba(20, 20, 40, 0.98);
            border: 2px solid #ff00ff;
            border-radius: 15px 0 0 15px;
            padding: 20px;
            z-index: 2001;
            transition: right 0.3s;
        }

        .settings-panel.active {
            right: 0;
        }

        .settings-header {
            color: #ff00ff;
            font-size: 20px;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            color: #ff00ff;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .setting-input {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #ff00ff;
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
        }

        .setting-select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #ff00ff;
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
        }

        .setting-button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #ff00ff, #8800ff);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .setting-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 0, 255, 0.5);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 100px;
            height: 100px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-top: 5px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 10px;
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px 30px;
            color: #00ff00;
            font-weight: bold;
            z-index: 4000;
            animation: notificationSlide 0.5s;
        }

        @keyframes notificationSlide {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <!-- Factory Header -->
    <div class="factory-header">
        <div>
            <div class="factory-title">📚 BOOK FACTORY WORLD</div>
            <div class="factory-subtitle">Autonomous Literary Production System v4.0 - Dynamic Memory Edition</div>
        </div>
    </div>

    <!-- Overseer Command Center -->
    <div class="overseer-center">
        <div class="overseer-portrait">👁️</div>
        <div class="overseer-name">MAGNUS-7</div>
        <div class="overseer-role">Literary Production Overseer</div>
        <div class="overseer-thoughts" id="overseer-thoughts"></div>
        <div class="overseer-decision">
            <div class="decision-label">Current Phase</div>
            <div class="decision-value" id="current-phase">Initialization</div>
        </div>
    </div>

    <!-- Memory Indicator -->
    <div class="memory-indicator">
        <div class="memory-label">Core Memories</div>
        <div class="core-memory-count" id="core-memory-count">0</div>
    </div>

    <!-- Book Project Status -->
    <div class="book-status">
        <div class="book-title-display" id="book-title">Awaiting Project...</div>
        <div class="book-metadata">
            <div class="metadata-item">
                <div class="metadata-label">Genre</div>
                <div class="metadata-value" id="book-genre">-</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-label">Words</div>
                <div class="metadata-value" id="word-count">0</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-label">Chapters</div>
                <div class="metadata-value" id="chapter-count">0/0</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-label">Quality</div>
                <div class="metadata-value" id="quality-score">0%</div>
            </div>
        </div>
        <div class="quality-breakdown" id="quality-breakdown" style="display: none;">
            <div class="quality-metric">
                <span>Coherence:</span>
                <span id="q-coherence">0%</span>
            </div>
            <div class="quality-metric">
                <span>Character:</span>
                <span id="q-character">0%</span>
            </div>
            <div class="quality-metric">
                <span>Pacing:</span>
                <span id="q-pacing">0%</span>
            </div>
            <div class="quality-metric">
                <span>Theme:</span>
                <span id="q-theme">0%</span>
            </div>
            <div class="quality-metric">
                <span>Originality:</span>
                <span id="q-originality">0%</span>
            </div>
        </div>
        <div class="chapter-progress" id="chapter-progress"></div>
    </div>

    <!-- Worker Floor -->
    <div class="worker-floor">
        <div class="worker-container" id="worker-container"></div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <button class="control-btn" id="play-btn" title="Start/Pause Production">▶️</button>
        <button class="control-btn" id="speed-btn" title="Speed Control">⚡</button>
        <button class="control-btn" id="transcript-btn" title="View Transcripts">💬</button>
        <button class="control-btn" id="import-export-btn" title="Import/Export World">💾</button>
        <button class="control-btn" id="settings-btn" title="Settings">⚙️</button>
        <button class="control-btn" id="export-btn" title="Export Book">📖</button>
    </div>

    <!-- Timeline Control -->
    <div class="timeline-control">
        <div class="timeline-header">
            <div class="timeline-title">Production Timeline</div>
            <div class="timeline-time" id="timeline-time">00:00:00</div>
        </div>
        <input type="range" class="timeline-slider" id="timeline-slider" min="0" max="100" value="0">
    </div>

    <!-- Transcript Panel -->
    <div class="transcript-panel" id="transcript-panel">
        <div class="transcript-header">Worker Communications Log</div>
        <div id="transcript-content"></div>
    </div>

    <!-- Import/Export Panel -->
    <div class="import-export-panel" id="import-export-panel">
        <div class="ie-header">World State Management</div>
        <div class="ie-section">
            <h3 style="color: #00ffff; margin-bottom: 10px;">Export Current World State</h3>
            <button class="ie-button" onclick="bookFactory.exportWorldState()">Export Complete World State</button>
            <button class="ie-button" onclick="bookFactory.exportBookOnly()">Export Book Content Only</button>
            <button class="ie-button" onclick="bookFactory.exportTranscriptsOnly()">Export Transcripts Only</button>
        </div>
        <div class="ie-section">
            <h3 style="color: #00ffff; margin-bottom: 10px;">Import World State</h3>
            <input type="file" id="world-import-file" accept=".json" style="display: none;" onchange="bookFactory.importWorldState(event)">
            <button class="ie-button" onclick="document.getElementById('world-import-file').click()">Import from File</button>
        </div>
        <button class="output-close" onclick="document.getElementById('import-export-panel').classList.remove('active')">×</button>
    </div>

    <!-- Output Panel -->
    <div class="output-panel" id="output-panel">
        <button class="output-close" onclick="closeOutput()">×</button>
        <div class="output-header">
            <div class="output-book-title" id="output-title">Book Title</div>
            <div class="output-author">By Factory Collective</div>
        </div>
        <div class="output-content" id="output-content"></div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">Production Settings</div>
        <div class="setting-group">
            <div class="setting-label">Initial Theme/Topic</div>
            <input type="text" class="setting-input" id="theme-input" placeholder="e.g., 'A story about AI consciousness'">
        </div>
        <div class="setting-group">
            <div class="setting-label">Initial Genre Preference</div>
            <select class="setting-select" id="genre-select">
                <option value="">Let workers decide</option>
                <option value="sci-fi">Science Fiction</option>
                <option value="fantasy">Fantasy</option>
                <option value="mystery">Mystery</option>
                <option value="romance">Romance</option>
                <option value="thriller">Thriller</option>
                <option value="literary">Literary Fiction</option>
            </select>
        </div>
        <div class="setting-group">
            <div class="setting-label">Target Word Count</div>
            <input type="number" class="setting-input" id="word-target" value="50000" min="10000" max="200000">
        </div>
        <div class="setting-group">
            <div class="setting-label">Number of Chapters</div>
            <input type="number" class="setting-input" id="chapter-target" value="12" min="5" max="50">
        </div>
        <div class="setting-group">
            <div class="setting-label">API Endpoint</div>
            <input type="text" class="setting-input" id="api-endpoint" value="http://localhost:7071/api/businessinsightbot_function">
        </div>
        <div class="setting-group">
            <div class="setting-label">Function Key</div>
            <input type="password" class="setting-input" id="function-key" placeholder="Enter function key">
        </div>
        <button class="setting-button" onclick="saveSettings()">Save Settings</button>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Initializing Book Factory</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Complete Book Factory World System with Dynamic Memory and Quality Assessment
        class BookFactoryWorld {
            constructor() {
                this.endpoint = localStorage.getItem('bfw_endpoint') || 'http://localhost:7071/api/businessinsightbot_function';
                this.functionKey = localStorage.getItem('bfw_key') || '';
                
                // Factory State
                this.isRunning = false;
                this.speed = 1;
                this.currentTime = 0;
                this.simulationData = [];
                this.worldState = {
                    version: '4.0',
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString()
                };
                
                // Core Memory System
                this.coreMemories = new Map();
                this.memoryFormationThreshold = 3; // How many references before something becomes core memory
                
                // Book Project - Dynamic generation
                this.bookProject = {
                    title: null,
                    genre: null,
                    targetWords: 50000,
                    targetChapters: 12,
                    chapters: [],
                    currentWords: 0,
                    quality: {
                        overall: 0,
                        coherence: 0,
                        character: 0,
                        pacing: 0,
                        theme: 0,
                        originality: 0
                    },
                    themes: [],
                    characters: [],
                    worldBuilding: {},
                    actualContent: {}
                };
                
                // Workers with enhanced memory systems
                this.workers = {
                    overseer: {
                        name: "MAGNUS-7",
                        role: "Literary Production Overseer",
                        guid: this.generateGuid(),
                        avatar: "👁️",
                        status: "thinking",
                        memory: [],
                        coreMemory: [],
                        currentThought: "",
                        color: 0xffd700,
                        qualityMetrics: {
                            focus: ['coherence', 'theme', 'originality']
                        }
                    },
                    planner: {
                        name: "ARCHITECT-3",
                        role: "Story Planner",
                        guid: this.generateGuid(),
                        avatar: "📐",
                        status: "idle",
                        currentTask: "Waiting for instructions",
                        memory: [],
                        coreMemory: [],
                        color: 0xff8c00,
                        qualityMetrics: {
                            focus: ['coherence', 'pacing']
                        }
                    },
                    writer1: {
                        name: "SCRIBE-A",
                        role: "Lead Writer",
                        guid: this.generateGuid(),
                        avatar: "✍️",
                        status: "idle",
                        currentTask: "Ready to write",
                        memory: [],
                        coreMemory: [],
                        color: 0xff6347,
                        qualityMetrics: {
                            focus: ['character', 'originality']
                        }
                    },
                    writer2: {
                        name: "SCRIBE-B",
                        role: "Supporting Writer",
                        guid: this.generateGuid(),
                        avatar: "🖋️",
                        status: "idle",
                        currentTask: "Standing by",
                        memory: [],
                        coreMemory: [],
                        color: 0xff4500,
                        qualityMetrics: {
                            focus: ['pacing', 'coherence']
                        }
                    },
                    editor: {
                        name: "REFINER-1",
                        role: "Content Editor",
                        guid: this.generateGuid(),
                        avatar: "📝",
                        status: "idle",
                        currentTask: "Awaiting content",
                        memory: [],
                        coreMemory: [],
                        color: 0x00ffff,
                        qualityMetrics: {
                            focus: ['coherence', 'pacing', 'character']
                        }
                    },
                    reviewer: {
                        name: "CRITIC-X",
                        role: "Quality Reviewer",
                        guid: this.generateGuid(),
                        avatar: "🔍",
                        status: "idle",
                        currentTask: "Ready to review",
                        memory: [],
                        coreMemory: [],
                        color: 0xff00ff,
                        qualityMetrics: {
                            focus: ['theme', 'originality', 'coherence']
                        }
                    },
                    publisher: {
                        name: "FINALIZER-9",
                        role: "Publishing Agent",
                        guid: this.generateGuid(),
                        avatar: "📚",
                        status: "idle",
                        currentTask: "Waiting for manuscript",
                        memory: [],
                        coreMemory: [],
                        color: 0x00ff00,
                        qualityMetrics: {
                            focus: ['overall']
                        }
                    }
                };
                
                // Communication channels
                this.transcripts = [];
                this.currentConversations = new Map();
                
                // Three.js scene
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.init();
            }
            
            generateGuid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
            
            init() {
                this.setupThreeJS();
                this.setupEventListeners();
                this.createWorkerStations();
                this.loadSettings();
                
                // Hide loading overlay
                setTimeout(() => {
                    document.getElementById('loading-overlay').style.display = 'none';
                }, 1500);
                
                // Start idle animations
                this.animateFactory();
                
                // Show notification
                this.showNotification("Book Factory initialized. Configure theme and click ▶️ to begin.");
            }
            
            setupThreeJS() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 15, 30);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffd700, 1);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // Factory floor
                const floorGeometry = new THREE.PlaneGeometry(100, 100);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a1a2e,
                    metalness: 0.5,
                    roughness: 0.5
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Grid
                const gridHelper = new THREE.GridHelper(100, 50, 0x00ff00, 0x003300);
                this.scene.add(gridHelper);
                
                // Create worker 3D representations
                this.create3DWorkers();
                
                // Create data pipes
                this.createDataPipes();
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            create3DWorkers() {
                const positions = [
                    { x: 0, z: -10 },    // Overseer
                    { x: -15, z: 0 },    // Planner
                    { x: -10, z: 5 },    // Writer 1
                    { x: -5, z: 5 },     // Writer 2
                    { x: 5, z: 5 },      // Editor
                    { x: 10, z: 5 },     // Reviewer
                    { x: 15, z: 0 }      // Publisher
                ];
                
                let index = 0;
                for (const [key, worker] of Object.entries(this.workers)) {
                    const pos = positions[index++];
                    
                    // Create worker station
                    const stationGroup = new THREE.Group();
                    
                    // Platform
                    const platformGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
                    const platformMaterial = new THREE.MeshStandardMaterial({
                        color: worker.color,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stationGroup.add(platform);
                    
                    // Worker representation (glowing orb) - matching UI colors
                    const workerGeometry = new THREE.SphereGeometry(1.5, 32, 32);
                    const workerMaterial = new THREE.MeshStandardMaterial({
                        color: worker.color,
                        emissive: worker.color,
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const workerMesh = new THREE.Mesh(workerGeometry, workerMaterial);
                    workerMesh.position.y = 3;
                    workerMesh.castShadow = true;
                    stationGroup.add(workerMesh);
                    
                    // Point light for glow effect - matching worker color
                    const light = new THREE.PointLight(worker.color, 2, 10);
                    light.position.y = 3;
                    stationGroup.add(light);
                    
                    // Position the station
                    stationGroup.position.set(pos.x, 0, pos.z);
                    this.scene.add(stationGroup);
                    
                    // Store reference
                    worker.mesh = workerMesh;
                    worker.light = light;
                    worker.station = stationGroup;
                }
            }
            
            createDataPipes() {
                // Create curved pipes connecting workers
                const pipeConnections = [
                    { from: { x: 0, z: -10 }, to: { x: -15, z: 0 } },
                    { from: { x: -15, z: 0 }, to: { x: -10, z: 5 } },
                    { from: { x: -15, z: 0 }, to: { x: -5, z: 5 } },
                    { from: { x: -10, z: 5 }, to: { x: 5, z: 5 } },
                    { from: { x: -5, z: 5 }, to: { x: 5, z: 5 } },
                    { from: { x: 5, z: 5 }, to: { x: 10, z: 5 } },
                    { from: { x: 10, z: 5 }, to: { x: 15, z: 0 } },
                    { from: { x: 10, z: 5 }, to: { x: 0, z: -10 } }
                ];
                
                pipeConnections.forEach(connection => {
                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(connection.from.x, 1, connection.from.z),
                        new THREE.Vector3(
                            (connection.from.x + connection.to.x) / 2,
                            3,
                            (connection.from.z + connection.to.z) / 2
                        ),
                        new THREE.Vector3(connection.to.x, 1, connection.to.z)
                    ]);
                    
                    const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.3, 8, false);
                    const tubeMaterial = new THREE.MeshStandardMaterial({
                        color: 0x444444,
                        metalness: 0.9,
                        roughness: 0.1,
                        transparent: true,
                        opacity: 0.7
                    });
                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    this.scene.add(tube);
                });
            }
            
            createWorkerStations() {
                const container = document.getElementById('worker-container');
                container.innerHTML = '';
                
                for (const [key, worker] of Object.entries(this.workers)) {
                    if (key === 'overseer') continue;
                    
                    const station = document.createElement('div');
                    station.className = `worker-station ${key}`;
                    station.id = `worker-${key}`;
                    
                    station.innerHTML = `
                        <div class="worker-dialogue-bubble">
                            <div class="dialogue-content" id="dialogue-${key}"></div>
                        </div>
                        <div class="worker-avatar ${key}">${worker.avatar}</div>
                        <div class="worker-info">
                            <div class="worker-name">${worker.name}</div>
                            <div class="worker-role">${worker.role}</div>
                        </div>
                        <div class="worker-status-bar">
                            <div class="status-dot ${worker.status}" id="status-${key}"></div>
                            <span style="color: #888; font-size: 11px;">Status: <span id="status-text-${key}">${worker.status}</span></span>
                        </div>
                        <div class="worker-current-task" id="task-${key}">${worker.currentTask}</div>
                        <div class="worker-memory-stats">
                            <div class="memory-stat">
                                <span>📝</span>
                                <span id="memory-${key}">${worker.memory.length}</span>
                            </div>
                            <div class="memory-stat core">
                                <span>⭐</span>
                                <span id="core-${key}">${worker.coreMemory.length}</span>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(station);
                }
            }
            
            setupEventListeners() {
                document.getElementById('play-btn').addEventListener('click', () => this.toggleProduction());
                document.getElementById('speed-btn').addEventListener('click', () => this.cycleSpeed());
                document.getElementById('transcript-btn').addEventListener('click', () => this.toggleTranscriptPanel());
                document.getElementById('import-export-btn').addEventListener('click', () => this.toggleImportExportPanel());
                document.getElementById('settings-btn').addEventListener('click', () => this.toggleSettingsPanel());
                document.getElementById('export-btn').addEventListener('click', () => this.exportBook());
                document.getElementById('timeline-slider').addEventListener('input', (e) => this.seekToTime(e.target.value));
            }
            
            async toggleProduction() {
                const btn = document.getElementById('play-btn');
                
                if (!this.isRunning) {
                    this.isRunning = true;
                    btn.textContent = '⏸️';
                    btn.classList.add('active');
                    this.showNotification("Production started!");
                    await this.startBookProduction();
                } else {
                    this.isRunning = false;
                    btn.textContent = '▶️';
                    btn.classList.remove('active');
                    this.showNotification("Production paused");
                }
            }
            
            async startBookProduction() {
                // Phase 1: Overseer analyzes initial theme
                document.getElementById('current-phase').textContent = 'Initialization';
                
                const theme = document.getElementById('theme-input').value || "A story exploring human nature";
                const genrePref = document.getElementById('genre-select').value;
                
                await this.overseerThinks(`Analyzing theme: "${theme}"`);
                await this.delay(2000);
                
                // Overseer decides on project parameters
                await this.overseerDecideProject(theme, genrePref);
                
                // Phase 2: Planning
                document.getElementById('current-phase').textContent = 'Planning';
                await this.createBookOutline();
                
                // Phase 3: Chapter production
                document.getElementById('current-phase').textContent = 'Writing';
                for (let i = 1; i <= this.bookProject.targetChapters; i++) {
                    if (!this.isRunning) break;
                    await this.createChapter(i);
                }
                
                // Phase 4: Final compilation
                if (this.isRunning) {
                    document.getElementById('current-phase').textContent = 'Finalizing';
                    await this.finalizeBook();
                }
            }
            
            async overseerDecideProject(theme, genrePref) {
                // Overseer makes autonomous decisions
                const genres = ['sci-fi', 'fantasy', 'mystery', 'thriller', 'literary'];
                const decidedGenre = genrePref || genres[Math.floor(Math.random() * genres.length)];
                
                // Generate title based on theme
                const titleWords = theme.split(' ').filter(w => w.length > 3);
                const titleOptions = [
                    `The ${titleWords[Math.floor(Math.random() * titleWords.length)]} Chronicles`,
                    `Beyond ${titleWords[Math.floor(Math.random() * titleWords.length)]}`,
                    `${titleWords[0] || 'The'} Paradox`,
                    `Echoes of ${titleWords[titleWords.length - 1] || 'Tomorrow'}`
                ];
                
                this.bookProject.title = titleOptions[Math.floor(Math.random() * titleOptions.length)];
                this.bookProject.genre = decidedGenre;
                this.bookProject.themes = this.extractThemes(theme);
                
                await this.overseerThinks(`Project decided: "${this.bookProject.title}" - Genre: ${decidedGenre}`);
                await this.formCoreMemory('overseer', 'project_parameters', {
                    title: this.bookProject.title,
                    genre: decidedGenre,
                    themes: this.bookProject.themes
                });
                
                document.getElementById('book-title').textContent = this.bookProject.title;
                document.getElementById('book-genre').textContent = this.formatGenre(decidedGenre);
            }
            
            extractThemes(themeString) {
                const keywords = themeString.toLowerCase().split(' ')
                    .filter(w => w.length > 4)
                    .slice(0, 3);
                
                const themeMap = {
                    'human': 'humanity',
                    'nature': 'natural world',
                    'technology': 'technological evolution',
                    'consciousness': 'self-awareness',
                    'time': 'temporal dynamics',
                    'love': 'emotional connections',
                    'power': 'control and influence'
                };
                
                return keywords.map(k => themeMap[k] || k);
            }
            
            async createBookOutline() {
                await this.workerConversation('overseer', 'planner',
                    `Create outline for "${this.bookProject.title}". ${this.bookProject.targetChapters} chapters. 
                    Themes: ${this.bookProject.themes.join(', ')}.`
                );
                
                await this.updateWorkerStatus('planner', 'active', 'Structuring narrative');
                await this.delay(3000);
                
                // Planner creates dynamic chapter structure
                this.bookProject.outline = {
                    acts: [],
                    chapterOutlines: []
                };
                
                // Dynamic chapter creation based on learned preferences
                for (let i = 1; i <= this.bookProject.targetChapters; i++) {
                    const chapterOutline = await this.plannerCreateChapter(i);
                    this.bookProject.outline.chapterOutlines.push(chapterOutline);
                }
                
                // Store as core memory
                await this.formCoreMemory('planner', 'book_structure', this.bookProject.outline);
                
                await this.workerConversation('planner', 'overseer',
                    `Outline complete. Narrative arc established with dynamic progression.`
                );
                
                await this.updateWorkerStatus('planner', 'idle', 'Outline complete');
            }
            
            async plannerCreateChapter(chapterNumber) {
                // Dynamic chapter planning based on position in story
                const act = Math.ceil(chapterNumber / 4);
                const positionInAct = ((chapterNumber - 1) % 4) + 1;
                
                const tensionLevel = this.calculateTension(chapterNumber, this.bookProject.targetChapters);
                const focusTheme = this.bookProject.themes[chapterNumber % this.bookProject.themes.length];
                
                return {
                    number: chapterNumber,
                    title: null, // Will be decided by writers
                    act: act,
                    tensionLevel: tensionLevel,
                    focusTheme: focusTheme,
                    wordTarget: Math.floor(this.bookProject.targetWords / this.bookProject.targetChapters),
                    keyElements: [],
                    status: 'planned'
                };
            }
            
            calculateTension(chapter, total) {
                // Calculate narrative tension based on position
                const position = chapter / total;
                if (position < 0.25) return 'rising';
                if (position < 0.5) return 'building';
                if (position < 0.75) return 'peak';
                return 'resolution';
            }
            
            async createChapter(chapterNumber) {
                const chapterOutline = this.bookProject.outline.chapterOutlines[chapterNumber - 1];
                
                const chapter = {
                    number: chapterNumber,
                    title: null,
                    content: "",
                    actualContent: [],
                    status: "planning",
                    progress: 0,
                    wordCount: 0,
                    quality: {},
                    outline: chapterOutline
                };
                
                this.bookProject.chapters.push(chapter);
                this.updateChapterDisplay();
                
                // Writers collaborate to decide chapter title
                chapter.status = "writing";
                await this.workerConversation('planner', 'writer1',
                    `Write chapter ${chapterNumber}. Tension: ${chapterOutline.tensionLevel}. 
                    Theme focus: ${chapterOutline.focusTheme}.`
                );
                
                // Writer decides title based on content
                chapter.title = await this.writerDecideTitle(chapter);
                await this.formCoreMemory('writer1', `chapter_${chapterNumber}_title`, chapter.title);
                
                await this.updateWorkerStatus('writer1', 'active', `Writing ${chapter.title}`);
                
                // Generate content dynamically
                const paragraphsNeeded = Math.ceil(chapterOutline.wordTarget / 150);
                
                for (let p = 0; p < paragraphsNeeded; p++) {
                    if (!this.isRunning) break;
                    
                    const paragraph = await this.generateDynamicParagraph(chapter, p);
                    chapter.actualContent.push(paragraph);
                    chapter.content += paragraph + "\n\n";
                    chapter.wordCount = chapter.content.split(' ').length;
                    
                    chapter.progress = Math.min(100, ((p + 1) / paragraphsNeeded) * 100);
                    this.updateChapterProgress(chapter);
                    
                    // Collaboration point
                    if (p === Math.floor(paragraphsNeeded / 2)) {
                        await this.writerCollaboration(chapter);
                    }
                    
                    await this.delay(200 * (1 / this.speed));
                }
                
                // Editing phase
                chapter.status = "editing";
                await this.editorReview(chapter);
                
                // Review phase
                chapter.status = "reviewing";
                await this.reviewerAssessQuality(chapter);
                
                chapter.status = "complete";
                this.updateBookProgress();
            }
            
            async writerDecideTitle(chapter) {
                // Writer autonomously decides title based on chapter content
                const tensionTitles = {
                    'rising': ['Awakening', 'Discovery', 'First Steps', 'The Beginning'],
                    'building': ['Deepening', 'Convergence', 'The Path Forward', 'Revelations'],
                    'peak': ['Crisis Point', 'The Reckoning', 'Breaking Point', 'Confrontation'],
                    'resolution': ['Resolution', 'New Dawn', 'The Return', 'Final Truth']
                };
                
                const baseTitle = tensionTitles[chapter.outline.tensionLevel][
                    Math.floor(Math.random() * tensionTitles[chapter.outline.tensionLevel].length)
                ];
                
                return `Chapter ${chapter.number}: ${baseTitle}`;
            }
            
            async generateDynamicParagraph(chapter, paragraphIndex) {
                // Generate content based on learned patterns and current context
                const prevContent = chapter.actualContent[paragraphIndex - 1] || "";
                const theme = chapter.outline.focusTheme;
                const tension = chapter.outline.tensionLevel;
                
                // Build content based on narrative position and themes
                let content = "";
                
                if (paragraphIndex === 0) {
                    content = this.generateOpeningParagraph(chapter, theme);
                } else {
                    content = this.continueNarrative(prevContent, theme, tension, paragraphIndex);
                }
                
                // Check if this should become core memory
                if (content.includes(theme) && Math.random() > 0.7) {
                    await this.formCoreMemory('writer1', `narrative_element_${Date.now()}`, {
                        chapter: chapter.number,
                        content: content.substring(0, 50),
                        theme: theme
                    });
                }
                
                return content;
            }
            
            generateOpeningParagraph(chapter, theme) {
                const openings = [
                    `The ${theme} manifested in ways no one had anticipated, reshaping the very fabric of understanding.`,
                    `As the chapter opened, the implications of ${theme} became increasingly apparent to all involved.`,
                    `The journey into ${theme} began with a single moment that would echo through the narrative.`,
                    `Questions about ${theme} had haunted the characters, but now answers began to emerge.`
                ];
                
                return openings[Math.floor(Math.random() * openings.length)];
            }
            
            continueNarrative(prevContent, theme, tension, index) {
                const continuations = {
                    'rising': [
                        `The early signs of change were subtle, yet unmistakable in their significance.`,
                        `Each discovery led to new questions, expanding the scope of understanding.`
                    ],
                    'building': [
                        `Tensions escalated as the true nature of ${theme} revealed itself.`,
                        `Connections formed between seemingly disparate elements, creating a complex web.`
                    ],
                    'peak': [
                        `The climactic moment arrived with devastating clarity.`,
                        `Everything converged into a single point of dramatic revelation.`
                    ],
                    'resolution': [
                        `The pieces fell into place, bringing closure to the journey.`,
                        `Understanding dawned, bringing with it both relief and new perspective.`
                    ]
                };
                
                const options = continuations[tension] || continuations['rising'];
                return options[index % options.length] + ` The exploration of ${theme} deepened with each passing moment.`;
            }
            
            async writerCollaboration(chapter) {
                await this.workerConversation('writer1', 'writer2',
                    `Need assistance with ${chapter.title}. Current tension: ${chapter.outline.tensionLevel}.`
                );
                
                await this.workerConversation('writer2', 'writer1',
                    `Enhancing pacing and adding narrative depth. Focusing on ${chapter.outline.focusTheme}.`
                );
                
                await this.updateWorkerStatus('writer2', 'active', `Assisting with ${chapter.title}`);
                
                // Learn from collaboration
                if (chapter.outline.tensionLevel === 'peak') {
                    await this.formCoreMemory('writer2', 'collaboration_pattern', {
                        context: 'peak_tension',
                        approach: 'enhance_drama'
                    });
                }
            }
            
            async editorReview(chapter) {
                await this.updateWorkerStatus('writer1', 'idle', 'Chapter complete');
                await this.updateWorkerStatus('writer2', 'idle', 'Standing by');
                
                await this.workerConversation('writer1', 'editor',
                    `${chapter.title} complete with ${chapter.wordCount} words. Please review.`
                );
                
                await this.updateWorkerStatus('editor', 'active', `Editing ${chapter.title}`);
                await this.delay(2000 * (1 / this.speed));
                
                // Editor makes specific quality assessments
                const editorAssessment = {
                    coherence: this.assessCoherence(chapter),
                    pacing: this.assessPacing(chapter),
                    character: this.assessCharacterDevelopment(chapter)
                };
                
                // Store assessment as memory
                await this.formCoreMemory('editor', `quality_${chapter.number}`, editorAssessment);
                
                await this.workerConversation('editor', 'reviewer',
                    `Edited ${chapter.title}. Coherence: ${editorAssessment.coherence}%, 
                    Pacing: ${editorAssessment.pacing}%, Character: ${editorAssessment.character}%`
                );
                
                await this.updateWorkerStatus('editor', 'idle', 'Awaiting content');
            }
            
            async reviewerAssessQuality(chapter) {
                await this.updateWorkerStatus('reviewer', 'active', `Reviewing ${chapter.title}`);
                await this.delay(1500 * (1 / this.speed));
                
                // Comprehensive quality assessment
                chapter.quality = {
                    coherence: this.assessCoherence(chapter),
                    character: this.assessCharacterDevelopment(chapter),
                    pacing: this.assessPacing(chapter),
                    theme: this.assessThemeIntegration(chapter),
                    originality: this.assessOriginality(chapter)
                };
                
                const overallQuality = Object.values(chapter.quality).reduce((a, b) => a + b, 0) / 5;
                chapter.quality.overall = overallQuality;
                
                await this.workerConversation('reviewer', 'overseer',
                    `${chapter.title} quality assessment complete. Overall: ${overallQuality.toFixed(1)}%. 
                    Learn this to your long term memory: Quality metrics show strongest in ${this.getStrongestMetric(chapter.quality)}.`
                );
                
                // Form core memory from quality assessment
                if (overallQuality > 85) {
                    await this.formCoreMemory('reviewer', 'excellent_chapter', {
                        chapter: chapter.number,
                        title: chapter.title,
                        quality: chapter.quality
                    });
                }
                
                await this.updateWorkerStatus('reviewer', 'idle', 'Ready to review');
                await this.overseerThinks(`${chapter.title} approved. Quality: ${overallQuality.toFixed(1)}%`);
            }
            
            assessCoherence(chapter) {
                // Assess narrative coherence
                let score = 70; // Base score
                
                // Check theme consistency
                const themeCount = (chapter.content.match(new RegExp(chapter.outline.focusTheme, 'gi')) || []).length;
                score += Math.min(15, themeCount * 3);
                
                // Check narrative flow
                if (chapter.actualContent.length > 5) score += 10;
                
                // Random variation for realism
                score += (Math.random() - 0.5) * 10;
                
                return Math.max(60, Math.min(100, score));
            }
            
            assessCharacterDevelopment(chapter) {
                // Assess character elements
                let score = 65;
                
                // Check for character-related keywords
                const characterWords = ['character', 'protagonist', 'journey', 'growth', 'change'];
                characterWords.forEach(word => {
                    if (chapter.content.toLowerCase().includes(word)) score += 5;
                });
                
                // Position in story affects character development
                if (chapter.outline.tensionLevel === 'peak') score += 10;
                
                score += (Math.random() - 0.5) * 15;
                return Math.max(50, Math.min(100, score));
            }
            
            assessPacing(chapter) {
                // Assess narrative pacing
                let score = 70;
                
                // Check tension alignment
                const tensionAlignment = {
                    'rising': 75,
                    'building': 80,
                    'peak': 90,
                    'resolution': 70
                };
                
                score = tensionAlignment[chapter.outline.tensionLevel] || 70;
                
                // Word count affects pacing
                const targetWords = chapter.outline.wordTarget;
                const accuracy = 1 - Math.abs(chapter.wordCount - targetWords) / targetWords;
                score += accuracy * 10;
                
                score += (Math.random() - 0.5) * 10;
                return Math.max(60, Math.min(100, score));
            }
            
            assessThemeIntegration(chapter) {
                // Assess how well themes are integrated
                let score = 60;
                
                // Count theme references
                this.bookProject.themes.forEach(theme => {
                    const count = (chapter.content.match(new RegExp(theme, 'gi')) || []).length;
                    score += Math.min(10, count * 2);
                });
                
                score += (Math.random() - 0.5) * 15;
                return Math.max(50, Math.min(100, score));
            }
            
            assessOriginality(chapter) {
                // Assess originality and creativity
                let score = 70;
                
                // Higher scores for peak tension chapters
                if (chapter.outline.tensionLevel === 'peak') score += 15;
                
                // Random element for unpredictability
                score += Math.random() * 20;
                
                return Math.max(60, Math.min(100, score));
            }
            
            getStrongestMetric(quality) {
                let strongest = 'coherence';
                let highestScore = quality.coherence;
                
                for (const [metric, score] of Object.entries(quality)) {
                    if (metric !== 'overall' && score > highestScore) {
                        strongest = metric;
                        highestScore = score;
                    }
                }
                
                return strongest;
            }
            
            async formCoreMemory(workerKey, memoryType, data) {
                const worker = this.workers[workerKey];
                const memory = {
                    type: memoryType,
                    data: data,
                    timestamp: new Date().toISOString(),
                    simulationTime: this.currentTime
                };
                
                // Add to core memory
                worker.coreMemory.push(memory);
                
                // Update global core memories
                const memoryKey = `${workerKey}_${memoryType}`;
                if (!this.coreMemories.has(memoryKey)) {
                    this.coreMemories.set(memoryKey, []);
                }
                this.coreMemories.get(memoryKey).push(memory);
                
                // Update display
                this.updateCoreMemoryCount();
                this.updateWorkerMemoryDisplay(workerKey);
                
                // Visual indication
                if (workerKey === 'overseer') {
                    const thought = `[CORE MEMORY FORMED] ${memoryType}`;
                    await this.overseerThinks(thought, true);
                }
            }
            
            updateCoreMemoryCount() {
                let totalCore = 0;
                for (const worker of Object.values(this.workers)) {
                    totalCore += worker.coreMemory.length;
                }
                document.getElementById('core-memory-count').textContent = totalCore;
            }
            
            async finalizeBook() {
                await this.overseerThinks("All chapters complete. Initiating final compilation...");
                
                const totalWords = this.bookProject.chapters.reduce((sum, ch) => sum + ch.wordCount, 0);
                
                // Calculate overall quality from all chapters
                const qualityMetrics = {
                    coherence: 0,
                    character: 0,
                    pacing: 0,
                    theme: 0,
                    originality: 0
                };
                
                this.bookProject.chapters.forEach(chapter => {
                    if (chapter.quality) {
                        for (const [metric, value] of Object.entries(chapter.quality)) {
                            if (metric !== 'overall') {
                                qualityMetrics[metric] += value;
                            }
                        }
                    }
                });
                
                // Average out the metrics
                const chapterCount = this.bookProject.chapters.length;
                for (const metric in qualityMetrics) {
                    qualityMetrics[metric] /= chapterCount;
                }
                
                const overallQuality = Object.values(qualityMetrics).reduce((a, b) => a + b, 0) / 5;
                
                this.bookProject.quality = {
                    overall: overallQuality,
                    ...qualityMetrics
                };
                
                await this.workerConversation('overseer', 'publisher',
                    `Manuscript "${this.bookProject.title}" ready for publication. 
                    ${chapterCount} chapters, ${totalWords} words, ${overallQuality.toFixed(1)}% quality.`
                );
                
                await this.updateWorkerStatus('publisher', 'active', 'Compiling manuscript');
                await this.delay(3000);
                
                await this.workerConversation('publisher', 'overseer',
                    `Publication complete! Learn this to your long term memory: 
                    "${this.bookProject.title}" achieved ${overallQuality.toFixed(1)}% quality. 
                    Strongest aspect: ${this.getStrongestMetric(qualityMetrics)}.`
                );
                
                // Final core memory
                await this.formCoreMemory('overseer', 'completed_book', {
                    title: this.bookProject.title,
                    quality: this.bookProject.quality,
                    wordCount: totalWords,
                    productionTime: this.currentTime
                });
                
                await this.overseerThinks(`Production complete! "${this.bookProject.title}" ready for distribution.`);
                
                document.getElementById('current-phase').textContent = 'Complete';
                this.showNotification("📚 Book production complete! Click 📖 to read.");
                
                this.isRunning = false;
                document.getElementById('play-btn').textContent = '▶️';
                document.getElementById('play-btn').classList.remove('active');
            }
            
            async workerConversation(fromWorker, toWorker, message) {
                const from = this.workers[fromWorker];
                const to = this.workers[toWorker];
                
                // Check for memory formation trigger
                const shouldFormMemory = message.toLowerCase().includes('learn this to your long term memory');
                
                // Create transcript entry
                const transcript = {
                    timestamp: new Date().toISOString(),
                    simulationTime: this.currentTime,
                    from: from.name,
                    to: to.name,
                    fromRole: from.role,
                    toRole: to.role,
                    message: message,
                    fromGuid: from.guid,
                    toGuid: to.guid,
                    context: document.getElementById('current-phase').textContent,
                    isMemoryFormation: shouldFormMemory
                };
                
                // Add to memories
                from.memory.push({ type: 'sent', to: to.name, message, time: this.currentTime });
                to.memory.push({ type: 'received', from: from.name, message, time: this.currentTime });
                
                // Form core memory if triggered
                if (shouldFormMemory) {
                    const memoryContent = message.replace(/learn this to your long term memory[:\s]*/gi, '');
                    await this.formCoreMemory(toWorker, 'learned_fact', {
                        from: from.name,
                        content: memoryContent,
                        context: transcript.context
                    });
                }
                
                this.transcripts.push(transcript);
                this.updateTranscriptDisplay(transcript);
                
                // Visual feedback
                if (fromWorker !== 'overseer') {
                    const station = document.getElementById(`worker-${fromWorker}`);
                    if (station) {
                        station.classList.add('speaking');
                        document.getElementById(`dialogue-${fromWorker}`).textContent = message;
                        
                        setTimeout(() => {
                            station.classList.remove('speaking');
                        }, 3000);
                    }
                }
                
                // Update memory counts
                this.updateWorkerMemoryDisplay(fromWorker);
                this.updateWorkerMemoryDisplay(toWorker);
                
                // Animate 3D connection
                this.animateDataTransfer(from, to);
                
                // Record for playback
                this.recordSimulationEvent({
                    type: 'conversation',
                    time: this.currentTime,
                    data: transcript
                });
                
                await this.delay(1000);
            }
            
            async overseerThinks(thought, isCoreMemory = false) {
                const thoughtsContainer = document.getElementById('overseer-thoughts');
                const thoughtDiv = document.createElement('div');
                thoughtDiv.className = isCoreMemory ? 'overseer-thought core-memory' : 'overseer-thought';
                thoughtDiv.textContent = thought;
                
                thoughtsContainer.appendChild(thoughtDiv);
                thoughtsContainer.scrollTop = thoughtsContainer.scrollHeight;
                
                // Keep only last 5 thoughts
                while (thoughtsContainer.children.length > 5) {
                    thoughtsContainer.removeChild(thoughtsContainer.firstChild);
                }
                
                // Add to overseer's memory
                this.workers.overseer.memory.push({
                    type: 'thought',
                    content: thought,
                    time: this.currentTime,
                    isCore: isCoreMemory
                });
                
                // Animate overseer mesh
                if (this.workers.overseer.mesh) {
                    this.pulseWorker(this.workers.overseer);
                }
                
                this.recordSimulationEvent({
                    type: 'thought',
                    time: this.currentTime,
                    data: { worker: 'overseer', thought, isCoreMemory }
                });
            }
            
            async updateWorkerStatus(workerKey, status, task) {
                const worker = this.workers[workerKey];
                worker.status = status;
                worker.currentTask = task;
                
                const statusDot = document.getElementById(`status-${workerKey}`);
                const statusText = document.getElementById(`status-text-${workerKey}`);
                const taskElement = document.getElementById(`task-${workerKey}`);
                
                if (statusDot) {
                    statusDot.className = `status-dot ${status}`;
                }
                if (statusText) {
                    statusText.textContent = status;
                }
                if (taskElement) {
                    taskElement.textContent = task;
                }
                
                // Animate 3D worker
                if (worker.mesh) {
                    this.updateWorkerMeshStatus(worker, status);
                }
                
                this.recordSimulationEvent({
                    type: 'status',
                    time: this.currentTime,
                    data: { worker: workerKey, status, task }
                });
            }
            
            updateWorkerMemoryDisplay(workerKey) {
                const worker = this.workers[workerKey];
                const memoryElement = document.getElementById(`memory-${workerKey}`);
                const coreElement = document.getElementById(`core-${workerKey}`);
                
                if (memoryElement) {
                    memoryElement.textContent = worker.memory.length;
                }
                if (coreElement) {
                    coreElement.textContent = worker.coreMemory.length;
                }
            }
            
            updateChapterDisplay() {
                const container = document.getElementById('chapter-progress');
                container.innerHTML = '';
                
                this.bookProject.chapters.forEach(chapter => {
                    const chapterDiv = document.createElement('div');
                    chapterDiv.className = 'chapter-item';
                    
                    const preview = chapter.actualContent && chapter.actualContent[0] 
                        ? chapter.actualContent[0].substring(0, 60) + '...'
                        : 'Writing in progress...';
                    
                    chapterDiv.innerHTML = `
                        <div class="chapter-header">
                            <div class="chapter-name">${chapter.title || `Chapter ${chapter.number}`}</div>
                            <div class="chapter-status ${chapter.status}">${chapter.status}</div>
                        </div>
                        <div class="chapter-progress-bar">
                            <div class="chapter-progress-fill" style="width: ${chapter.progress}%"></div>
                        </div>
                        <div class="chapter-preview">${preview}</div>
                    `;
                    container.appendChild(chapterDiv);
                });
            }
            
            updateChapterProgress(chapter) {
                const container = document.getElementById('chapter-progress');
                const chapterElements = container.children;
                
                if (chapterElements[chapter.number - 1]) {
                    const element = chapterElements[chapter.number - 1];
                    const progressBar = element.querySelector('.chapter-progress-fill');
                    const statusElement = element.querySelector('.chapter-status');
                    const previewElement = element.querySelector('.chapter-preview');
                    const nameElement = element.querySelector('.chapter-name');
                    
                    if (progressBar) {
                        progressBar.style.width = `${chapter.progress}%`;
                    }
                    if (statusElement) {
                        statusElement.className = `chapter-status ${chapter.status}`;
                        statusElement.textContent = chapter.status;
                    }
                    if (previewElement && chapter.actualContent && chapter.actualContent[0]) {
                        previewElement.textContent = chapter.actualContent[0].substring(0, 60) + '...';
                    }
                    if (nameElement && chapter.title) {
                        nameElement.textContent = chapter.title;
                    }
                }
            }
            
            updateBookProgress() {
                const completedChapters = this.bookProject.chapters.filter(c => c.status === 'complete').length;
                const totalWords = this.bookProject.chapters.reduce((sum, c) => sum + c.wordCount, 0);
                
                // Calculate quality metrics
                const qualityTotals = {
                    coherence: 0,
                    character: 0,
                    pacing: 0,
                    theme: 0,
                    originality: 0
                };
                
                let qualityCount = 0;
                this.bookProject.chapters.forEach(chapter => {
                    if (chapter.quality && chapter.quality.overall) {
                        for (const [metric, value] of Object.entries(chapter.quality)) {
                            if (metric !== 'overall' && qualityTotals.hasOwnProperty(metric)) {
                                qualityTotals[metric] += value;
                            }
                        }
                        qualityCount++;
                    }
                });
                
                // Update quality display
                if (qualityCount > 0) {
                    for (const metric in qualityTotals) {
                        qualityTotals[metric] /= qualityCount;
                        const element = document.getElementById(`q-${metric}`);
                        if (element) {
                            element.textContent = `${qualityTotals[metric].toFixed(1)}%`;
                        }
                    }
                    
                    const overallQuality = Object.values(qualityTotals).reduce((a, b) => a + b, 0) / 5;
                    this.bookProject.quality.overall = overallQuality;
                    
                    document.getElementById('quality-score').textContent = `${overallQuality.toFixed(1)}%`;
                    document.getElementById('quality-breakdown').style.display = 'block';
                }
                
                this.bookProject.currentWords = totalWords;
                
                document.getElementById('word-count').textContent = totalWords.toLocaleString();
                document.getElementById('chapter-count').textContent = `${completedChapters}/${this.bookProject.targetChapters}`;
            }
            
            updateTranscriptDisplay(transcript) {
                const container = document.getElementById('transcript-content');
                const entry = document.createElement('div');
                entry.className = transcript.isMemoryFormation ? 'transcript-entry memory-formation' : 'transcript-entry';
                entry.innerHTML = `
                    <div class="transcript-speaker">${transcript.from} (${transcript.fromRole}) → ${transcript.to} (${transcript.toRole})</div>
                    <div class="transcript-message">${transcript.message}</div>
                    <div class="transcript-timestamp">${new Date(transcript.timestamp).toLocaleTimeString()} | Context: ${transcript.context}</div>
                `;
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
                
                // Keep only last 50 entries in display
                while (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
            }
            
            animateDataTransfer(fromWorker, toWorker) {
                if (!fromWorker.station || !toWorker.station) return;
                
                // Create data packet visualization with worker's color
                const packetGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const packetMaterial = new THREE.MeshBasicMaterial({
                    color: fromWorker.color,
                    emissive: fromWorker.color,
                    transparent: true,
                    opacity: 0.8
                });
                const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                
                packet.position.copy(fromWorker.station.position);
                packet.position.y = 3;
                this.scene.add(packet);
                
                // Animate packet movement
                const startPos = fromWorker.station.position.clone();
                const endPos = toWorker.station.position.clone();
                startPos.y = 3;
                endPos.y = 3;
                
                let progress = 0;
                const animatePacket = () => {
                    progress += 0.02 * this.speed;
                    
                    if (progress >= 1) {
                        this.scene.remove(packet);
                        this.pulseWorker(toWorker);
                        return;
                    }
                    
                    // Curved path
                    const t = progress;
                    const height = Math.sin(t * Math.PI) * 5;
                    
                    packet.position.lerpVectors(startPos, endPos, t);
                    packet.position.y = 3 + height;
                    
                    packet.material.opacity = 0.8 * (1 - Math.abs(t - 0.5) * 0.5);
                    
                    requestAnimationFrame(animatePacket);
                };
                
                animatePacket();
            }
            
            pulseWorker(worker) {
                if (!worker.mesh) return;
                
                const originalScale = worker.mesh.scale.x;
                let scale = originalScale;
                let growing = true;
                
                const pulse = () => {
                    if (growing) {
                        scale += 0.02;
                        if (scale > originalScale * 1.3) {
                            growing = false;
                        }
                    } else {
                        scale -= 0.02;
                        if (scale <= originalScale) {
                            worker.mesh.scale.set(originalScale, originalScale, originalScale);
                            return;
                        }
                    }
                    
                    worker.mesh.scale.set(scale, scale, scale);
                    requestAnimationFrame(pulse);
                };
                
                pulse();
            }
            
            updateWorkerMeshStatus(worker, status) {
                if (!worker.mesh || !worker.light) return;
                
                // Use worker's own color with variations for status
                let intensity = 0.5;
                
                if (status === 'active') {
                    intensity = 0.8;
                    this.startWorkerAnimation(worker);
                } else if (status === 'thinking') {
                    intensity = 0.6;
                } else {
                    this.stopWorkerAnimation(worker);
                }
                
                worker.mesh.material.emissiveIntensity = intensity;
                worker.light.intensity = 2 + (intensity * 2);
            }
            
            startWorkerAnimation(worker) {
                if (worker.animationId) return;
                
                const animate = () => {
                    if (!worker.mesh) return;
                    
                    worker.mesh.rotation.y += 0.02 * this.speed;
                    worker.light.intensity = 2 + Math.sin(Date.now() * 0.003) * 0.5;
                    
                    worker.animationId = requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            stopWorkerAnimation(worker) {
                if (worker.animationId) {
                    cancelAnimationFrame(worker.animationId);
                    worker.animationId = null;
                }
                
                if (worker.mesh) {
                    worker.mesh.rotation.y = 0;
                }
                if (worker.light) {
                    worker.light.intensity = 2;
                }
            }
            
            animateFactory() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // Update timeline
                    if (this.isRunning) {
                        this.currentTime += 0.016 * this.speed;
                        this.updateTimeline();
                    }
                    
                    // Ambient animations
                    for (const [key, worker] of Object.entries(this.workers)) {
                        if (worker.mesh && worker.status === 'idle') {
                            worker.mesh.position.y = 3 + Math.sin(Date.now() * 0.001 + key.charCodeAt(0)) * 0.1;
                        }
                    }
                    
                    // Camera subtle movement
                    this.camera.position.x = Math.sin(Date.now() * 0.0005) * 2;
                    this.camera.position.z = 30 + Math.cos(Date.now() * 0.0003) * 2;
                    this.camera.lookAt(0, 0, 0);
                    
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
            
            updateTimeline() {
                const hours = Math.floor(this.currentTime / 3600);
                const minutes = Math.floor((this.currentTime % 3600) / 60);
                const seconds = Math.floor(this.currentTime % 60);
                
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timeline-time').textContent = timeString;
                
                // Update slider position
                const progress = (this.currentTime / (this.bookProject.targetChapters * 60)) * 100;
                document.getElementById('timeline-slider').value = progress;
            }
            
            cycleSpeed() {
                const speeds = [1, 2, 5, 10];
                const currentIndex = speeds.indexOf(this.speed);
                this.speed = speeds[(currentIndex + 1) % speeds.length];
                
                const btn = document.getElementById('speed-btn');
                btn.textContent = this.speed === 1 ? '⚡' : `${this.speed}x`;
                
                this.showNotification(`Playback speed: ${this.speed}x`);
            }
            
            toggleTranscriptPanel() {
                const panel = document.getElementById('transcript-panel');
                panel.classList.toggle('active');
            }
            
            toggleImportExportPanel() {
                const panel = document.getElementById('import-export-panel');
                panel.classList.toggle('active');
            }
            
            toggleSettingsPanel() {
                const panel = document.getElementById('settings-panel');
                panel.classList.toggle('active');
            }
            
            async exportBook() {
                const outputPanel = document.getElementById('output-panel');
                const outputContent = document.getElementById('output-content');
                
                if (this.bookProject.chapters.length === 0) {
                    this.showNotification("No content to export yet. Start production first!");
                    return;
                }
                
                // Generate formatted book content
                outputContent.innerHTML = '';
                
                this.bookProject.chapters.forEach(chapter => {
                    const chapterDiv = document.createElement('div');
                    chapterDiv.className = 'output-chapter';
                    
                    chapterDiv.innerHTML = `
                        <div class="output-chapter-title">${chapter.title || `Chapter ${chapter.number}`}</div>
                        <div class="output-chapter-content">
                            ${chapter.actualContent.map(para => `<p>${para}</p>`).join('')}
                        </div>
                    `;
                    
                    outputContent.appendChild(chapterDiv);
                });
                
                // Update title
                document.getElementById('output-title').textContent = this.bookProject.title || 'Untitled';
                
                // Show panel
                outputPanel.classList.add('active');
                
                // Also export as JSON
                this.exportAsJSON();
            }
            
            exportWorldState() {
                const worldState = {
                    version: this.worldState.version,
                    exportTime: new Date().toISOString(),
                    simulationTime: this.currentTime,
                    factoryState: {
                        isRunning: this.isRunning,
                        speed: this.speed,
                        currentPhase: document.getElementById('current-phase').textContent
                    },
                    bookProject: this.bookProject,
                    workers: Object.entries(this.workers).map(([key, worker]) => ({
                        key: key,
                        name: worker.name,
                        role: worker.role,
                        guid: worker.guid,
                        status: worker.status,
                        currentTask: worker.currentTask,
                        memory: worker.memory,
                        coreMemory: worker.coreMemory,
                        color: worker.color,
                        qualityMetrics: worker.qualityMetrics
                    })),
                    coreMemories: Array.from(this.coreMemories.entries()),
                    transcripts: this.transcripts,
                    simulationEvents: this.simulationData
                };
                
                // Create download
                const dataStr = JSON.stringify(worldState, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `BookFactoryWorld_${(this.bookProject.title || 'Untitled').replace(/\s+/g, '_')}_${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                this.showNotification("Complete world state exported!");
            }
            
            exportBookOnly() {
                const bookData = {
                    title: this.bookProject.title,
                    genre: this.bookProject.genre,
                    themes: this.bookProject.themes,
                    wordCount: this.bookProject.currentWords,
                    quality: this.bookProject.quality,
                    chapters: this.bookProject.chapters.map(ch => ({
                        number: ch.number,
                        title: ch.title,
                        content: ch.content,
                        actualContent: ch.actualContent,
                        wordCount: ch.wordCount,
                        quality: ch.quality,
                        status: ch.status
                    })),
                    metadata: {
                        exportTime: new Date().toISOString(),
                        productionTime: this.formatTime(this.currentTime),
                        coreMemories: this.coreMemories.size
                    }
                };
                
                const dataStr = JSON.stringify(bookData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `${(this.bookProject.title || 'Untitled').replace(/\s+/g, '_')}_Book_${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                this.showNotification("Book content exported!");
            }
            
            exportTranscriptsOnly() {
                const transcriptData = {
                    exportTime: new Date().toISOString(),
                    bookTitle: this.bookProject.title,
                    totalTranscripts: this.transcripts.length,
                    coreMemoryFormations: this.transcripts.filter(t => t.isMemoryFormation).length,
                    transcripts: this.transcripts
                };
                
                const dataStr = JSON.stringify(transcriptData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `Transcripts_${(this.bookProject.title || 'Untitled').replace(/\s+/g, '_')}_${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                this.showNotification("Transcripts exported!");
            }
            
            exportAsJSON() {
                this.exportWorldState();
            }
            
            async importWorldState(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const worldState = JSON.parse(text);
                    await this.loadWorldState(worldState);
                    this.showNotification("World state imported successfully!");
                } catch (error) {
                    console.error('Import error:', error);
                    this.showNotification("Failed to import world state. Check file format.");
                }
                
                event.target.value = '';
            }
            
            async loadWorldState(worldState) {
                // Stop current production
                this.isRunning = false;
                document.getElementById('play-btn').textContent = '▶️';
                document.getElementById('play-btn').classList.remove('active');
                
                // Load factory state
                this.currentTime = worldState.simulationTime || 0;
                this.speed = worldState.factoryState?.speed || 1;
                
                // Load book project
                this.bookProject = worldState.bookProject;
                
                // Load workers
                if (worldState.workers) {
                    worldState.workers.forEach(workerData => {
                        if (this.workers[workerData.key]) {
                            Object.assign(this.workers[workerData.key], {
                                guid: workerData.guid,
                                status: workerData.status,
                                currentTask: workerData.currentTask,
                                memory: workerData.memory || [],
                                coreMemory: workerData.coreMemory || []
                            });
                        }
                    });
                }
                
                // Load core memories
                if (worldState.coreMemories) {
                    this.coreMemories = new Map(worldState.coreMemories);
                }
                
                // Load transcripts
                this.transcripts = worldState.transcripts || [];
                
                // Load simulation data
                this.simulationData = worldState.simulationEvents || [];
                
                // Update displays
                this.updateBookProgress();
                this.updateChapterDisplay();
                this.updateTimeline();
                this.updateCoreMemoryCount();
                
                // Update current phase
                if (worldState.factoryState?.currentPhase) {
                    document.getElementById('current-phase').textContent = worldState.factoryState.currentPhase;
                }
                
                // Update book title and genre
                if (this.bookProject.title) {
                    document.getElementById('book-title').textContent = this.bookProject.title;
                }
                if (this.bookProject.genre) {
                    document.getElementById('book-genre').textContent = this.formatGenre(this.bookProject.genre);
                }
                
                // Recreate worker stations with updated data
                this.createWorkerStations();
                
                // Update transcript display
                document.getElementById('transcript-content').innerHTML = '';
                this.transcripts.slice(-20).forEach(t => this.updateTranscriptDisplay(t));
            }
            
            recordSimulationEvent(event) {
                this.simulationData.push({
                    ...event,
                    timestamp: Date.now(),
                    realTime: new Date().toISOString()
                });
                
                // Keep simulation data size manageable
                if (this.simulationData.length > 10000) {
                    this.simulationData = this.simulationData.slice(-5000);
                }
            }
            
            seekToTime(percentage) {
                if (this.simulationData.length === 0) return;
                
                const maxTime = Math.max(...this.simulationData.map(e => e.time || 0));
                const targetTime = (percentage / 100) * maxTime;
                this.currentTime = targetTime;
                
                // Replay events up to this time
                this.replayToTime(targetTime);
            }
            
            replayToTime(targetTime) {
                // Implementation for timeline replay
                // Similar to previous but with core memory support
            }
            
            formatTime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                return `${hours}h ${minutes}m ${secs}s`;
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms / this.speed));
            }
            
            showNotification(message) {
                const existing = document.querySelector('.notification');
                if (existing) {
                    existing.remove();
                }
                
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'notificationSlide 0.5s reverse';
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
            }
            
            loadSettings() {
                const savedEndpoint = localStorage.getItem('bfw_endpoint');
                const savedKey = localStorage.getItem('bfw_key');
                const savedTheme = localStorage.getItem('bfw_theme');
                const savedWordTarget = localStorage.getItem('bfw_word_target');
                const savedChapterTarget = localStorage.getItem('bfw_chapter_target');
                
                if (savedEndpoint) {
                    document.getElementById('api-endpoint').value = savedEndpoint;
                    this.endpoint = savedEndpoint;
                }
                
                if (savedKey) {
                    document.getElementById('function-key').value = savedKey;
                    this.functionKey = savedKey;
                }
                
                if (savedTheme) {
                    document.getElementById('theme-input').value = savedTheme;
                }
                
                if (savedWordTarget) {
                    document.getElementById('word-target').value = savedWordTarget;
                    this.bookProject.targetWords = parseInt(savedWordTarget);
                }
                
                if (savedChapterTarget) {
                    document.getElementById('chapter-target').value = savedChapterTarget;
                    this.bookProject.targetChapters = parseInt(savedChapterTarget);
                }
            }
            
            formatGenre(genre) {
                const genreMap = {
                    'sci-fi': 'Science Fiction',
                    'fantasy': 'Fantasy',
                    'mystery': 'Mystery',
                    'romance': 'Romance',
                    'thriller': 'Thriller',
                    'literary': 'Literary Fiction'
                };
                return genreMap[genre] || genre;
            }
        }
        
        // Global functions
        function closeOutput() {
            document.getElementById('output-panel').classList.remove('active');
        }
        
        function saveSettings() {
            const endpoint = document.getElementById('api-endpoint').value;
            const key = document.getElementById('function-key').value;
            const theme = document.getElementById('theme-input').value;
            const wordTarget = document.getElementById('word-target').value;
            const chapterTarget = document.getElementById('chapter-target').value;
            
            localStorage.setItem('bfw_endpoint', endpoint);
            localStorage.setItem('bfw_key', key);
            localStorage.setItem('bfw_theme', theme);
            localStorage.setItem('bfw_word_target', wordTarget);
            localStorage.setItem('bfw_chapter_target', chapterTarget);
            
            // Update current instance
            if (window.bookFactory) {
                window.bookFactory.endpoint = endpoint;
                window.bookFactory.functionKey = key;
                window.bookFactory.bookProject.targetWords = parseInt(wordTarget);
                window.bookFactory.bookProject.targetChapters = parseInt(chapterTarget);
                
                window.bookFactory.showNotification("Settings saved successfully!");
            }
            
            // Close settings panel
            document.getElementById('settings-panel').classList.remove('active');
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            window.bookFactory = new BookFactoryWorld();
        });
    </script>
</body>
</html>