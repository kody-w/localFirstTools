<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Narrative Multiverse - Reality-Bending Collaborative Story Engine</title>
    <style>
        /* ===== BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --text-muted: #606070;
            --border-color: #2a2a3a;
            --accent-gold: #d4af37;

            /* Perspective Colors */
            --detective-primary: #4a4a5a;
            --detective-secondary: #2a2a35;
            --detective-accent: #c0c0c0;

            --villain-primary: #8b0000;
            --villain-secondary: #3a0000;
            --villain-accent: #ff4444;

            --victim-primary: #1a3a5a;
            --victim-secondary: #0a1a2a;
            --victim-accent: #4db8ff;

            --journalist-primary: #f5f5dc;
            --journalist-secondary: #d4d4b8;
            --journalist-accent: #333333;

            --psychic-primary: #4a0080;
            --psychic-secondary: #2a0050;
            --psychic-accent: #bf80ff;

            --child-primary: #ffb3ba;
            --child-secondary: #ffe4e6;
            --child-accent: #ff6b6b;

            --ai-primary: #003300;
            --ai-secondary: #001a00;
            --ai-accent: #00ff00;

            --narrator-primary: #2a2520;
            --narrator-secondary: #1a1510;
            --narrator-accent: #d4af37;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ===== DATA CONTROLS ===== */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .data-controls button:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-gold);
        }

        /* ===== LANDING PAGE ===== */
        .landing-page {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: radial-gradient(ellipse at center, rgba(212, 175, 55, 0.1) 0%, transparent 50%);
        }

        .landing-page h1 {
            font-size: 3.5em;
            font-weight: 200;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent-gold), #fff, var(--accent-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .landing-page .tagline {
            font-size: 1.2em;
            color: var(--text-secondary);
            margin-bottom: 40px;
            text-align: center;
        }

        .menu-options {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            max-width: 800px;
        }

        .menu-btn {
            padding: 20px 40px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            font-size: 1.1em;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .menu-btn:hover {
            border-color: var(--accent-gold);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.2);
        }

        .menu-btn small {
            display: block;
            color: var(--text-muted);
            font-size: 0.75em;
            margin-top: 5px;
        }

        /* ===== SESSION SETUP ===== */
        .setup-page {
            min-height: 100vh;
            padding: 40px 20px;
            display: none;
        }

        .setup-page.active {
            display: block;
        }

        .setup-container {
            max-width: 900px;
            margin: 0 auto;
        }

        .setup-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .setup-header h2 {
            font-size: 2em;
            font-weight: 300;
            margin-bottom: 10px;
        }

        .setup-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .setup-section h3 {
            font-size: 1.2em;
            font-weight: 400;
            margin-bottom: 20px;
            color: var(--accent-gold);
        }

        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .scenario-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scenario-card:hover,
        .scenario-card.selected {
            border-color: var(--accent-gold);
        }

        .scenario-card.selected {
            background: rgba(212, 175, 55, 0.1);
        }

        .scenario-card h4 {
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .scenario-card p {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .perspective-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }

        .perspective-option {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .perspective-option:hover {
            border-color: var(--accent-gold);
        }

        .perspective-option.selected {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.1);
        }

        .perspective-option .icon {
            font-size: 2em;
            margin-bottom: 8px;
        }

        .perspective-option .name {
            font-weight: 500;
        }

        .perspective-option .desc {
            font-size: 0.75em;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .player-setup {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-input {
            flex: 1;
            min-width: 200px;
        }

        .player-input label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .player-input input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1em;
        }

        .player-input input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover,
        .mode-btn.selected {
            border-color: var(--accent-gold);
        }

        .mode-btn.selected {
            background: rgba(212, 175, 55, 0.1);
        }

        .start-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, var(--accent-gold), #b8960c);
            border: none;
            border-radius: 10px;
            color: #000;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.3);
        }

        .back-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .back-btn:hover {
            border-color: var(--accent-gold);
            color: var(--text-primary);
        }

        /* ===== MAIN WRITING INTERFACE ===== */
        .writing-page {
            display: none;
            height: 100vh;
        }

        .writing-page.active {
            display: flex;
        }

        /* Top Bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        .session-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .session-info .session-name {
            font-weight: 500;
            color: var(--accent-gold);
        }

        .session-info .player-count {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .session-info .time-elapsed {
            font-size: 0.9em;
            color: var(--text-muted);
        }

        .current-perspective {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 15px;
            border-radius: 20px;
            font-weight: 500;
        }

        .top-actions {
            display: flex;
            gap: 10px;
        }

        .top-actions button {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .top-actions button:hover {
            border-color: var(--accent-gold);
        }

        /* Main Content */
        .main-content {
            display: flex;
            margin-top: 50px;
            height: calc(100vh - 100px);
            width: 100%;
        }

        /* Writing Area */
        .writing-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            min-width: 0;
        }

        .story-display {
            flex: 1;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .story-event {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border-left: 4px solid var(--border-color);
        }

        .story-event .event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .story-event .perspective-tag {
            font-size: 0.8em;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: 500;
        }

        .story-event .timestamp {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .story-event .content {
            line-height: 1.6;
        }

        .reconciliation-notice {
            background: rgba(212, 175, 55, 0.1);
            border: 1px dashed var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .reconciliation-notice .twist-label {
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 8px;
        }

        .reconciliation-notice .twist-type {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .reconciliation-notice .twist-explanation {
            font-style: italic;
            line-height: 1.5;
        }

        .writing-input-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
        }

        .perspective-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .perspective-indicator .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .writing-input {
            width: 100%;
            min-height: 100px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            color: var(--text-primary);
            font-size: 1em;
            line-height: 1.6;
            resize: none;
            font-family: inherit;
        }

        .writing-input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .writing-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .char-count {
            font-size: 0.85em;
            color: var(--text-muted);
        }

        .submit-btn {
            padding: 10px 25px;
            background: var(--accent-gold);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3);
        }

        /* Side Panel */
        .side-panel {
            width: 400px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .panel-tab:hover {
            color: var(--text-primary);
        }

        .panel-tab.active {
            color: var(--accent-gold);
            border-bottom: 2px solid var(--accent-gold);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .panel-section {
            display: none;
        }

        .panel-section.active {
            display: block;
        }

        /* Perspectives Tab */
        .perspective-view {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .perspective-view .view-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .perspective-view .view-content {
            font-size: 0.9em;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* Timeline Tab */
        .timeline-container {
            position: relative;
            padding-left: 30px;
        }

        .timeline-line {
            position: absolute;
            left: 10px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-event {
            position: relative;
            margin-bottom: 20px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .timeline-event::before {
            content: '';
            position: absolute;
            left: -24px;
            top: 15px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-gold);
        }

        .timeline-event.reconciled::before {
            background: #00ff00;
        }

        .timeline-event .event-time {
            font-size: 0.75em;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .timeline-event .event-summary {
            font-size: 0.9em;
        }

        /* Characters Tab */
        .character-card {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .character-card .char-name {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .character-card .char-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .character-card .trait {
            font-size: 0.75em;
            padding: 3px 8px;
            background: var(--bg-secondary);
            border-radius: 10px;
            color: var(--text-secondary);
        }

        /* Reconciliations Tab */
        .reconciliation-item {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 3px solid var(--accent-gold);
        }

        .reconciliation-item .twist-name {
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 8px;
        }

        .reconciliation-item .contradiction {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .reconciliation-item .resolution {
            font-size: 0.9em;
            font-style: italic;
        }

        .reconciliation-item .votes {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.8em;
            color: var(--text-muted);
        }

        /* Votes Tab */
        .vote-card {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .vote-card .vote-question {
            font-weight: 500;
            margin-bottom: 12px;
        }

        .vote-options {
            display: flex;
            gap: 10px;
        }

        .vote-btn {
            flex: 1;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .vote-btn:hover {
            border-color: var(--accent-gold);
        }

        .vote-btn.accept:hover {
            background: rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
        }

        .vote-btn.reject:hover {
            background: rgba(255, 0, 0, 0.1);
            border-color: #ff0000;
        }

        .vote-results {
            margin-top: 10px;
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        /* Bottom Bar */
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .ai-notification {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-notification.active {
            color: var(--accent-gold);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .quick-actions {
            display: flex;
            gap: 10px;
        }

        .quick-action-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .quick-action-btn:hover {
            border-color: var(--accent-gold);
            color: var(--text-primary);
        }

        /* ===== EXPORT MODAL ===== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            margin-bottom: 20px;
            font-weight: 400;
        }

        .export-options {
            display: grid;
            gap: 15px;
        }

        .export-option {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-option:hover {
            border-color: var(--accent-gold);
        }

        .export-option h4 {
            margin-bottom: 8px;
        }

        .export-option p {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5em;
            cursor: pointer;
        }

        /* ===== PERSPECTIVE THEMES ===== */
        .theme-detective {
            --current-primary: var(--detective-primary);
            --current-secondary: var(--detective-secondary);
            --current-accent: var(--detective-accent);
        }

        .theme-detective .writing-area {
            background: linear-gradient(180deg, #1a1a1f 0%, #0a0a0f 100%);
        }

        .theme-detective .perspective-tag {
            background: var(--detective-primary);
            color: var(--detective-accent);
        }

        .theme-detective .story-event {
            border-left-color: var(--detective-accent);
        }

        .theme-villain {
            --current-primary: var(--villain-primary);
            --current-secondary: var(--villain-secondary);
            --current-accent: var(--villain-accent);
        }

        .theme-villain .writing-area {
            background: linear-gradient(180deg, #1a0a0a 0%, #0a0505 100%);
        }

        .theme-villain .perspective-tag {
            background: var(--villain-primary);
            color: var(--villain-accent);
        }

        .theme-villain .story-event {
            border-left-color: var(--villain-accent);
        }

        .theme-victim {
            --current-primary: var(--victim-primary);
            --current-secondary: var(--victim-secondary);
            --current-accent: var(--victim-accent);
        }

        .theme-victim .writing-area {
            background: linear-gradient(180deg, #0a1520 0%, #050a10 100%);
        }

        .theme-victim .perspective-tag {
            background: var(--victim-primary);
            color: var(--victim-accent);
        }

        .theme-victim .story-event {
            border-left-color: var(--victim-accent);
        }

        .theme-journalist {
            --current-primary: var(--journalist-primary);
            --current-secondary: var(--journalist-secondary);
            --current-accent: var(--journalist-accent);
        }

        .theme-journalist .writing-area {
            background: linear-gradient(180deg, #f5f5dc 0%, #e5e5cc 100%);
        }

        .theme-journalist .story-display,
        .theme-journalist .writing-input-container {
            background: #fff;
            color: #333;
        }

        .theme-journalist .writing-input {
            background: #f9f9f0;
            color: #333;
        }

        .theme-journalist .perspective-tag {
            background: #333;
            color: #f5f5dc;
        }

        .theme-psychic {
            --current-primary: var(--psychic-primary);
            --current-secondary: var(--psychic-secondary);
            --current-accent: var(--psychic-accent);
        }

        .theme-psychic .writing-area {
            background: linear-gradient(180deg, #1a0a2a 0%, #0a0510 100%);
        }

        .theme-psychic .perspective-tag {
            background: var(--psychic-primary);
            color: var(--psychic-accent);
        }

        .theme-psychic .story-event {
            border-left-color: var(--psychic-accent);
        }

        .theme-child {
            --current-primary: var(--child-primary);
            --current-secondary: var(--child-secondary);
            --current-accent: var(--child-accent);
        }

        .theme-child .writing-area {
            background: linear-gradient(180deg, #fff0f0 0%, #ffe0e0 100%);
        }

        .theme-child .story-display,
        .theme-child .writing-input-container {
            background: #fff;
            color: #333;
            border: 3px dashed #ffb3ba;
        }

        .theme-child .writing-input {
            background: #fff8f8;
            color: #333;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .theme-child .perspective-tag {
            background: var(--child-accent);
            color: #fff;
        }

        .theme-ai {
            --current-primary: var(--ai-primary);
            --current-secondary: var(--ai-secondary);
            --current-accent: var(--ai-accent);
        }

        .theme-ai .writing-area {
            background: linear-gradient(180deg, #001a00 0%, #000a00 100%);
        }

        .theme-ai .story-display {
            font-family: 'Courier New', monospace;
            background: #000;
            border-color: var(--ai-accent);
        }

        .theme-ai .perspective-tag {
            background: #000;
            color: var(--ai-accent);
            border: 1px solid var(--ai-accent);
        }

        .theme-ai .story-event {
            border-left-color: var(--ai-accent);
        }

        .theme-narrator {
            --current-primary: var(--narrator-primary);
            --current-secondary: var(--narrator-secondary);
            --current-accent: var(--narrator-accent);
        }

        .theme-narrator .writing-area {
            background: linear-gradient(180deg, #1a1510 0%, #0a0805 100%);
        }

        .theme-narrator .perspective-tag {
            background: var(--narrator-accent);
            color: #000;
        }

        .theme-narrator .story-event {
            border-left-color: var(--narrator-accent);
        }

        /* ===== PARTICLES EFFECT ===== */
        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--accent-gold);
            border-radius: 50%;
            opacity: 0;
            animation: particleFade 2s ease-out forwards;
        }

        @keyframes particleFade {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0) translateY(-100px);
            }
        }

        /* ===== TYPING INDICATOR ===== */
        .typing-indicators {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8em;
            color: var(--text-muted);
        }

        .typing-indicator .dots {
            display: flex;
            gap: 3px;
        }

        .typing-indicator .dot {
            width: 4px;
            height: 4px;
            background: currentColor;
            border-radius: 50%;
            animation: typingDot 1.4s infinite;
        }

        .typing-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingDot {
            0%, 60%, 100% { opacity: 0.3; }
            30% { opacity: 1; }
        }

        /* ===== TUTORIAL TOOLTIP ===== */
        .tooltip {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            z-index: 1001;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .tooltip h4 {
            color: var(--accent-gold);
            margin-bottom: 8px;
        }

        .tooltip p {
            font-size: 0.9em;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .tooltip .tip-close {
            margin-top: 10px;
            padding: 6px 12px;
            background: var(--accent-gold);
            border: none;
            border-radius: 4px;
            color: #000;
            cursor: pointer;
            font-size: 0.85em;
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 1024px) {
            .side-panel {
                width: 320px;
            }
        }

        @media (max-width: 768px) {
            .landing-page h1 {
                font-size: 2.2em;
            }

            .menu-btn {
                min-width: 100%;
            }

            .main-content {
                flex-direction: column;
            }

            .side-panel {
                width: 100%;
                height: 40vh;
                border-left: none;
                border-top: 1px solid var(--border-color);
            }

            .writing-area {
                height: 50vh;
            }

            .data-controls {
                flex-direction: column;
                gap: 5px;
            }

            .data-controls button {
                font-size: 11px;
                padding: 6px 10px;
            }

            .top-bar {
                flex-wrap: wrap;
                height: auto;
                padding: 10px;
            }

            .session-info {
                flex-wrap: wrap;
                gap: 10px;
            }

            .current-perspective {
                order: -1;
                width: 100%;
                justify-content: center;
            }

            .panel-tabs {
                overflow-x: auto;
            }

            .panel-tab {
                white-space: nowrap;
                padding: 10px 8px;
                font-size: 0.8em;
            }
        }

        @media (max-width: 480px) {
            .landing-page h1 {
                font-size: 1.8em;
            }

            .perspective-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .scenario-grid {
                grid-template-columns: 1fr;
            }

            .writing-input {
                min-height: 80px;
            }

            .quick-actions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Data</button>
        <button onclick="document.getElementById('importFile').click()">Import Data</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Particles Container -->
    <div class="particles-container" id="particles"></div>

    <!-- Landing Page -->
    <div class="landing-page" id="landingPage">
        <h1>NARRATIVE MULTIVERSE</h1>
        <p class="tagline">Reality-Bending Collaborative Story Engine</p>
        <div class="menu-options">
            <button class="menu-btn" onclick="showSetup('new')">
                New Session
                <small>Create a new collaborative story</small>
            </button>
            <button class="menu-btn" onclick="showSetup('join')">
                Join Session
                <small>Enter an existing story world</small>
            </button>
            <button class="menu-btn" onclick="loadSavedSession()">
                Continue Story
                <small>Resume your last session</small>
            </button>
            <button class="menu-btn" onclick="showTutorial()">
                How It Works
                <small>Learn the multiverse mechanics</small>
            </button>
        </div>
    </div>

    <!-- Setup Page -->
    <div class="setup-page" id="setupPage">
        <div class="setup-container">
            <button class="back-btn" onclick="showLanding()">&larr; Back</button>

            <div class="setup-header">
                <h2>Create Your Story Session</h2>
            </div>

            <div class="setup-section">
                <h3>Choose a Scenario</h3>
                <div class="scenario-grid" id="scenarioGrid">
                    <!-- Scenarios will be populated by JS -->
                </div>
            </div>

            <div class="setup-section">
                <h3>Select Your Perspective</h3>
                <div class="perspective-grid" id="perspectiveGrid">
                    <!-- Perspectives will be populated by JS -->
                </div>
            </div>

            <div class="setup-section">
                <h3>Player Setup</h3>
                <div class="player-setup">
                    <div class="player-input">
                        <label>Your Name</label>
                        <input type="text" id="playerName" placeholder="Enter your name">
                    </div>
                    <div class="player-input">
                        <label>Session Name</label>
                        <input type="text" id="sessionName" placeholder="Name this story session">
                    </div>
                </div>
            </div>

            <div class="setup-section">
                <h3>Game Mode</h3>
                <div class="mode-toggle">
                    <button class="mode-btn selected" data-mode="cooperative" onclick="selectMode(this)">
                        Cooperative
                        <small style="display:block; font-size:0.75em; color:var(--text-muted); margin-top:5px;">Work together to create a coherent story</small>
                    </button>
                    <button class="mode-btn" data-mode="competitive" onclick="selectMode(this)">
                        Competitive
                        <small style="display:block; font-size:0.75em; color:var(--text-muted); margin-top:5px;">Create contradictions for creative twists</small>
                    </button>
                    <button class="mode-btn" data-mode="educational" onclick="selectMode(this)">
                        Educational
                        <small style="display:block; font-size:0.75em; color:var(--text-muted); margin-top:5px;">Learn literary devices as you write</small>
                    </button>
                </div>
            </div>

            <button class="start-btn" onclick="startSession()">Begin Your Story</button>
        </div>
    </div>

    <!-- Writing Page -->
    <div class="writing-page" id="writingPage">
        <div class="top-bar">
            <div class="session-info">
                <span class="session-name" id="displaySessionName">Untitled Story</span>
                <span class="player-count" id="playerCount">1 writer</span>
                <span class="time-elapsed" id="timeElapsed">0:00</span>
            </div>
            <div class="current-perspective" id="currentPerspective">
                <span class="icon"></span>
                <span class="name"></span>
            </div>
            <div class="top-actions">
                <button onclick="openExportModal()">Export Story</button>
                <button onclick="endSession()">End Session</button>
            </div>
        </div>

        <div class="main-content">
            <div class="writing-area">
                <div class="story-display" id="storyDisplay">
                    <!-- Story events will be populated here -->
                </div>

                <div class="writing-input-container">
                    <div class="typing-indicators" id="typingIndicators">
                        <!-- Typing indicators for other players -->
                    </div>
                    <div class="perspective-indicator">
                        <span class="dot" id="perspectiveDot"></span>
                        <span id="perspectiveLabel">Writing as...</span>
                    </div>
                    <textarea class="writing-input" id="writingInput" placeholder="Continue the story from your perspective..."></textarea>
                    <div class="writing-actions">
                        <span class="char-count"><span id="charCount">0</span> characters</span>
                        <button class="submit-btn" onclick="submitEntry()">Add to Story</button>
                    </div>
                </div>
            </div>

            <div class="side-panel">
                <div class="panel-tabs">
                    <button class="panel-tab active" data-tab="perspectives" onclick="switchTab(this)">Perspectives</button>
                    <button class="panel-tab" data-tab="timeline" onclick="switchTab(this)">Timeline</button>
                    <button class="panel-tab" data-tab="characters" onclick="switchTab(this)">Characters</button>
                    <button class="panel-tab" data-tab="reconciliations" onclick="switchTab(this)">Twists</button>
                    <button class="panel-tab" data-tab="votes" onclick="switchTab(this)">Votes</button>
                </div>
                <div class="panel-content">
                    <div class="panel-section active" id="perspectivesSection">
                        <!-- Perspective views -->
                    </div>
                    <div class="panel-section" id="timelineSection">
                        <div class="timeline-container" id="timelineContainer">
                            <div class="timeline-line"></div>
                            <!-- Timeline events -->
                        </div>
                    </div>
                    <div class="panel-section" id="charactersSection">
                        <!-- Character cards -->
                    </div>
                    <div class="panel-section" id="reconciliationsSection">
                        <!-- Reconciliation history -->
                    </div>
                    <div class="panel-section" id="votesSection">
                        <!-- Active votes -->
                    </div>
                </div>
            </div>
        </div>

        <div class="bottom-bar">
            <div class="ai-notification" id="aiNotification">
                <span>AI Narrator ready</span>
            </div>
            <div class="quick-actions">
                <button class="quick-action-btn" onclick="insertTimeJump()">Time Jump</button>
                <button class="quick-action-btn" onclick="introduceCharacter()">New Character</button>
                <button class="quick-action-btn" onclick="triggerReconciliation()">Force Twist</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <h2>Export Your Story</h2>
            <div class="export-options">
                <div class="export-option" onclick="exportStory('interactive')">
                    <h4>Interactive Fiction</h4>
                    <p>Clickable HTML file where readers can switch between perspectives</p>
                </div>
                <div class="export-option" onclick="exportStory('splitscreen')">
                    <h4>Split-Screen Story</h4>
                    <p>Side-by-side comparison of all perspectives</p>
                </div>
                <div class="export-option" onclick="exportStory('timeline')">
                    <h4>Timeline View</h4>
                    <p>Chronological events with perspective filters</p>
                </div>
                <div class="export-option" onclick="exportStory('novel')">
                    <h4>Traditional Novel</h4>
                    <p>Linear narrative with footnotes for plot twists</p>
                </div>
                <div class="export-option" onclick="exportStory('json')">
                    <h4>Raw JSON Data</h4>
                    <p>Complete story data for backup or analysis</p>
                </div>
            </div>
            <button class="back-btn" style="margin-top:20px;" onclick="closeExportModal()">Cancel</button>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const APP_NAME = 'narrative-multiverse';

        // Perspective definitions
        const PERSPECTIVES = {
            detective: {
                name: 'Detective',
                icon: 'üîç',
                description: 'Sees clues, evidence, suspicious behavior',
                color: '#c0c0c0',
                bgColor: '#4a4a5a',
                transforms: {
                    neutral: 'suspicious',
                    positive: 'potentially deceptive',
                    negative: 'criminal'
                }
            },
            villain: {
                name: 'Villain',
                icon: 'üòà',
                description: 'Sees opportunities, weaknesses, escape routes',
                color: '#ff4444',
                bgColor: '#8b0000',
                transforms: {
                    neutral: 'exploitable',
                    positive: 'weakness to manipulate',
                    negative: 'threat to eliminate'
                }
            },
            victim: {
                name: 'Victim',
                icon: 'üò∞',
                description: 'Sees threats, danger signs, warnings',
                color: '#4db8ff',
                bgColor: '#1a3a5a',
                transforms: {
                    neutral: 'threatening',
                    positive: 'false safety',
                    negative: 'imminent danger'
                }
            },
            journalist: {
                name: 'Journalist',
                icon: 'üì∞',
                description: 'Sees headlines, public perception, context',
                color: '#333333',
                bgColor: '#f5f5dc',
                transforms: {
                    neutral: 'newsworthy angle',
                    positive: 'puff piece material',
                    negative: 'scandal'
                }
            },
            psychic: {
                name: 'Psychic',
                icon: 'üîÆ',
                description: 'Sees futures, timelines, supernatural elements',
                color: '#bf80ff',
                bgColor: '#4a0080',
                transforms: {
                    neutral: 'fated event',
                    positive: 'destiny fulfilled',
                    negative: 'dark premonition'
                }
            },
            child: {
                name: 'Child',
                icon: 'üë∂',
                description: 'Sees innocence, imagination, hidden truths',
                color: '#ff6b6b',
                bgColor: '#ffb3ba',
                transforms: {
                    neutral: 'magical adventure',
                    positive: 'fairy tale',
                    negative: 'scary monster'
                }
            },
            ai: {
                name: 'AI Observer',
                icon: 'ü§ñ',
                description: 'Sees data patterns, probabilities, system states',
                color: '#00ff00',
                bgColor: '#003300',
                transforms: {
                    neutral: 'data point',
                    positive: 'optimal outcome probability',
                    negative: 'system anomaly detected'
                }
            },
            narrator: {
                name: 'Narrator',
                icon: 'üìñ',
                description: 'Omniscient view (moderator role)',
                color: '#d4af37',
                bgColor: '#2a2520',
                transforms: {
                    neutral: 'objective observation',
                    positive: 'triumphant moment',
                    negative: 'tragic turn'
                }
            }
        };

        // Scenario definitions
        const SCENARIOS = {
            murder: {
                name: 'Murder Mystery',
                description: 'Uncover the truth in a web of lies',
                perspectives: ['detective', 'villain', 'victim', 'journalist', 'psychic'],
                startingPrompt: 'The body was discovered at midnight in the old mansion...'
            },
            heist: {
                name: 'Heist Gone Wrong',
                description: 'When the perfect plan falls apart',
                perspectives: ['villain', 'detective', 'journalist', 'ai', 'narrator'],
                startingPrompt: 'The vault door swung open, but what they found inside changed everything...'
            },
            timetravel: {
                name: 'Time Travel Paradox',
                description: 'Past, present, and future collide',
                perspectives: ['psychic', 'ai', 'narrator', 'child', 'detective'],
                startingPrompt: 'The temporal rift appeared without warning in the middle of the city...'
            },
            superhero: {
                name: 'Superhero Origin',
                description: 'When ordinary becomes extraordinary',
                perspectives: ['victim', 'villain', 'journalist', 'child', 'ai'],
                startingPrompt: 'No one knew that today would be the day the world changed forever...'
            },
            custom: {
                name: 'Custom Scenario',
                description: 'Create your own story from scratch',
                perspectives: Object.keys(PERSPECTIVES),
                startingPrompt: ''
            }
        };

        // Plot twist templates for AI reconciliation
        const PLOT_TWISTS = [
            {
                type: 'Twin Brother/Sister',
                pattern: 'location_contradiction',
                template: 'It turns out {character} has an identical twin who was at the other location all along.'
            },
            {
                type: 'Unreliable Narrator',
                pattern: 'perception_contradiction',
                template: 'What {perspective1} saw was a hallucination caused by {reason}. The truth is what {perspective2} witnessed.'
            },
            {
                type: 'Time Travel',
                pattern: 'temporal_contradiction',
                template: 'These events occurred at different points in time. {event1} happened in the past, while {event2} is from the future.'
            },
            {
                type: 'Conspiracy Cover-up',
                pattern: 'fact_contradiction',
                template: 'Powerful forces are manipulating the evidence. What {perspective1} knows has been hidden from {perspective2} by {conspirator}.'
            },
            {
                type: 'Memory Manipulation',
                pattern: 'memory_contradiction',
                template: "{character}'s memories have been altered. The truth lies somewhere between what they remember and what actually happened."
            },
            {
                type: 'Simulation/Dream',
                pattern: 'reality_contradiction',
                template: 'One of these realities is a simulation/dream. {perspective1} exists in the real world while {perspective2} is experiencing a constructed reality.'
            },
            {
                type: 'Supernatural Intervention',
                pattern: 'impossible_event',
                template: 'A supernatural force has altered reality itself, making both versions simultaneously true in different dimensions.'
            },
            {
                type: 'Mistaken Identity',
                pattern: 'identity_contradiction',
                template: '{character1} was actually {character2} in disguise. The real {character1} was elsewhere.'
            },
            {
                type: 'Parallel Universes',
                pattern: 'major_contradiction',
                template: 'A rift between parallel universes has merged two realities. Both events occurred, but in different dimensions now overlapping.'
            },
            {
                type: 'Shapeshifter',
                pattern: 'appearance_contradiction',
                template: 'A shapeshifter has been impersonating {character}, appearing differently to each observer.'
            }
        ];

        // ===== APPLICATION STATE =====
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{}');

        // Initialize default state
        if (!appData.sessions) appData.sessions = [];
        if (!appData.currentSession) appData.currentSession = null;
        if (!appData.settings) appData.settings = { tutorialShown: false };

        let sessionStartTime = null;
        let timeUpdateInterval = null;
        let currentTab = 'perspectives';
        let simulatedPlayers = [];

        // ===== DATA MANAGEMENT =====
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    appData = imported;
                    saveData();
                    alert('Data imported successfully! Reloading...');
                    location.reload();
                } catch (error) {
                    alert('Invalid JSON file. Please check the file format.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ===== NAVIGATION =====
        function showLanding() {
            document.getElementById('landingPage').style.display = 'flex';
            document.getElementById('setupPage').classList.remove('active');
            document.getElementById('writingPage').classList.remove('active');
        }

        function showSetup(type) {
            document.getElementById('landingPage').style.display = 'none';
            document.getElementById('setupPage').classList.add('active');
            populateScenarios();
            populatePerspectives();
        }

        function populateScenarios() {
            const grid = document.getElementById('scenarioGrid');
            grid.innerHTML = '';

            Object.entries(SCENARIOS).forEach(([key, scenario]) => {
                const card = document.createElement('div');
                card.className = 'scenario-card';
                card.dataset.scenario = key;
                card.onclick = () => selectScenario(card);
                card.innerHTML = `
                    <h4>${scenario.name}</h4>
                    <p>${scenario.description}</p>
                `;
                grid.appendChild(card);
            });
        }

        function populatePerspectives() {
            const grid = document.getElementById('perspectiveGrid');
            grid.innerHTML = '';

            Object.entries(PERSPECTIVES).forEach(([key, perspective]) => {
                const option = document.createElement('div');
                option.className = 'perspective-option';
                option.dataset.perspective = key;
                option.onclick = () => selectPerspective(option);
                option.innerHTML = `
                    <div class="icon">${perspective.icon}</div>
                    <div class="name">${perspective.name}</div>
                    <div class="desc">${perspective.description}</div>
                `;
                grid.appendChild(option);
            });
        }

        function selectScenario(card) {
            document.querySelectorAll('.scenario-card').forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
        }

        function selectPerspective(option) {
            document.querySelectorAll('.perspective-option').forEach(o => o.classList.remove('selected'));
            option.classList.add('selected');
        }

        function selectMode(btn) {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
        }

        // ===== SESSION MANAGEMENT =====
        function startSession() {
            const scenarioCard = document.querySelector('.scenario-card.selected');
            const perspectiveOption = document.querySelector('.perspective-option.selected');
            const modeBtn = document.querySelector('.mode-btn.selected');
            const playerName = document.getElementById('playerName').value.trim() || 'Anonymous Writer';
            const sessionName = document.getElementById('sessionName').value.trim() || 'Untitled Story';

            if (!scenarioCard || !perspectiveOption) {
                alert('Please select a scenario and perspective to continue.');
                return;
            }

            const scenarioKey = scenarioCard.dataset.scenario;
            const perspectiveKey = perspectiveOption.dataset.perspective;
            const mode = modeBtn ? modeBtn.dataset.mode : 'cooperative';
            const scenario = SCENARIOS[scenarioKey];

            // Create new session
            const session = {
                id: Date.now().toString(),
                name: sessionName,
                scenario: scenarioKey,
                mode: mode,
                startTime: new Date().toISOString(),
                players: [{
                    id: 'player1',
                    name: playerName,
                    perspective: perspectiveKey,
                    isLocal: true
                }],
                events: [],
                reconciliations: [],
                characters: [],
                votes: [],
                currentPerspective: perspectiveKey
            };

            // Add starting prompt if scenario has one
            if (scenario.startingPrompt) {
                session.events.push({
                    id: 'event_0',
                    timestamp: new Date().toISOString(),
                    type: 'narrative',
                    perspectives: {
                        narrator: scenario.startingPrompt
                    },
                    author: 'narrator'
                });
            }

            // Initialize simulated players for demo
            initializeSimulatedPlayers(session, scenario);

            appData.currentSession = session;
            appData.sessions.push(session);
            saveData();

            enterWritingMode(session);
        }

        function initializeSimulatedPlayers(session, scenario) {
            // Add 2-3 simulated players for demonstration
            const availablePerspectives = scenario.perspectives.filter(
                p => p !== session.currentPerspective
            );

            const numSimulated = Math.min(2, availablePerspectives.length);
            const names = ['Alex', 'Jordan', 'Casey', 'Morgan', 'Riley'];

            for (let i = 0; i < numSimulated; i++) {
                const perspective = availablePerspectives[i];
                session.players.push({
                    id: `simulated_${i}`,
                    name: names[i],
                    perspective: perspective,
                    isLocal: false,
                    isSimulated: true
                });
            }
        }

        function loadSavedSession() {
            if (appData.currentSession) {
                enterWritingMode(appData.currentSession);
            } else if (appData.sessions.length > 0) {
                appData.currentSession = appData.sessions[appData.sessions.length - 1];
                enterWritingMode(appData.currentSession);
            } else {
                alert('No saved sessions found. Start a new story!');
            }
        }

        function enterWritingMode(session) {
            document.getElementById('landingPage').style.display = 'none';
            document.getElementById('setupPage').classList.remove('active');
            document.getElementById('writingPage').classList.add('active');

            // Apply perspective theme
            const perspective = session.currentPerspective;
            document.body.className = `theme-${perspective}`;

            // Update UI
            updateSessionUI(session);
            renderStory(session);
            renderSidePanels(session);

            // Start time tracker
            sessionStartTime = new Date(session.startTime);
            startTimeTracker();

            // Show tutorial on first use
            if (!appData.settings.tutorialShown) {
                setTimeout(() => showTutorialTooltip(), 1000);
            }

            // Start simulated player activity
            startSimulatedActivity(session);
        }

        function updateSessionUI(session) {
            const perspective = PERSPECTIVES[session.currentPerspective];

            document.getElementById('displaySessionName').textContent = session.name;
            document.getElementById('playerCount').textContent = `${session.players.length} writers`;

            const perspectiveEl = document.getElementById('currentPerspective');
            perspectiveEl.innerHTML = `
                <span class="icon">${perspective.icon}</span>
                <span class="name">${perspective.name}</span>
            `;
            perspectiveEl.style.background = perspective.bgColor;
            perspectiveEl.style.color = perspective.color;

            const perspectiveDot = document.getElementById('perspectiveDot');
            perspectiveDot.style.background = perspective.color;
            document.getElementById('perspectiveLabel').textContent = `Writing as ${perspective.name}`;
        }

        function startTimeTracker() {
            if (timeUpdateInterval) clearInterval(timeUpdateInterval);

            timeUpdateInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timeElapsed').textContent =
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function endSession() {
            if (confirm('Are you sure you want to end this session?')) {
                if (timeUpdateInterval) clearInterval(timeUpdateInterval);
                appData.currentSession = null;
                saveData();
                showLanding();
            }
        }

        // ===== WRITING FUNCTIONALITY =====
        function renderStory(session) {
            const display = document.getElementById('storyDisplay');
            display.innerHTML = '';

            session.events.forEach((event, index) => {
                const eventEl = createEventElement(event, session);
                display.appendChild(eventEl);

                // Check if reconciliation follows this event
                const reconciliation = session.reconciliations.find(r => r.afterEventId === event.id);
                if (reconciliation) {
                    const reconEl = createReconciliationElement(reconciliation);
                    display.appendChild(reconEl);
                }
            });

            // Scroll to bottom
            display.scrollTop = display.scrollHeight;
        }

        function createEventElement(event, session) {
            const div = document.createElement('div');
            div.className = 'story-event';

            const perspective = PERSPECTIVES[event.author];
            const perspectiveText = event.perspectives[session.currentPerspective] ||
                                   event.perspectives[event.author] ||
                                   transformPerspective(event.perspectives[event.author], event.author, session.currentPerspective);

            div.style.borderLeftColor = perspective ? perspective.color : 'var(--border-color)';

            div.innerHTML = `
                <div class="event-header">
                    <span class="perspective-tag" style="background:${perspective?.bgColor || 'var(--bg-tertiary)'}; color:${perspective?.color || 'var(--text-primary)'}">
                        ${perspective?.icon || 'üìù'} ${perspective?.name || 'Unknown'}
                    </span>
                    <span class="timestamp">${formatTime(event.timestamp)}</span>
                </div>
                <div class="content">${perspectiveText}</div>
            `;

            return div;
        }

        function createReconciliationElement(reconciliation) {
            const div = document.createElement('div');
            div.className = 'reconciliation-notice';
            div.innerHTML = `
                <div class="twist-label">PLOT TWIST: ${reconciliation.twistType}</div>
                <div class="twist-type">Reconciling contradictions between perspectives</div>
                <div class="twist-explanation">${reconciliation.explanation}</div>
            `;
            return div;
        }

        function transformPerspective(originalText, fromPerspective, toPerspective) {
            if (!originalText) return '';
            if (fromPerspective === toPerspective) return originalText;

            const toPerspectiveDef = PERSPECTIVES[toPerspective];

            // Simple transformation based on perspective
            // In a full implementation, this would use NLP
            let transformed = originalText;

            // Add perspective-specific flavor
            const prefixes = {
                detective: '[Evidence suggests] ',
                villain: '[Opportunity noted] ',
                victim: '[Warning] ',
                journalist: '[BREAKING] ',
                psychic: '[Vision] ',
                child: '[Once upon a time...] ',
                ai: '[Analysis] ',
                narrator: ''
            };

            if (toPerspective !== 'narrator' && fromPerspective !== toPerspective) {
                transformed = prefixes[toPerspective] + transformed;
            }

            return transformed;
        }

        function formatTime(isoString) {
            const date = new Date(isoString);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Input handling
        document.getElementById('writingInput').addEventListener('input', function() {
            document.getElementById('charCount').textContent = this.value.length;
        });

        function submitEntry() {
            const input = document.getElementById('writingInput');
            const text = input.value.trim();

            if (!text) {
                alert('Please write something before submitting.');
                return;
            }

            const session = appData.currentSession;
            const perspective = session.currentPerspective;

            // Create event with perspective-specific content
            const event = {
                id: `event_${Date.now()}`,
                timestamp: new Date().toISOString(),
                type: 'narrative',
                perspectives: {
                    [perspective]: text
                },
                author: perspective
            };

            // Generate other perspective views
            Object.keys(PERSPECTIVES).forEach(p => {
                if (p !== perspective) {
                    event.perspectives[p] = transformPerspective(text, perspective, p);
                }
            });

            session.events.push(event);

            // Check for contradictions with recent events
            checkForContradictions(session, event);

            saveData();
            renderStory(session);
            renderSidePanels(session);

            // Clear input
            input.value = '';
            document.getElementById('charCount').textContent = '0';

            // Trigger particle effect
            triggerParticles();

            // Simulate other player responses after a delay
            simulatePlayerResponses(session);
        }

        // ===== AI RECONCILIATION ENGINE =====
        function checkForContradictions(session, newEvent) {
            // Look for potential contradictions in recent events
            const recentEvents = session.events.slice(-5);

            for (const event of recentEvents) {
                if (event.id === newEvent.id) continue;
                if (event.author === newEvent.author) continue;

                // Simple contradiction detection based on keywords
                const contradiction = detectContradiction(event, newEvent);
                if (contradiction) {
                    // Generate plot twist
                    const twist = generatePlotTwist(contradiction, event, newEvent);

                    // Create vote for reconciliation
                    createReconciliationVote(session, twist, event, newEvent);

                    // Notify user
                    showAINotification('Contradiction detected! A plot twist has been proposed.');
                    break;
                }
            }
        }

        function detectContradiction(event1, event2) {
            const text1 = Object.values(event1.perspectives)[0].toLowerCase();
            const text2 = Object.values(event2.perspectives)[0].toLowerCase();

            // Location contradictions
            const locationWords = ['entered', 'left', 'arrived', 'stayed', 'home', 'building', 'room'];
            const hasLocation1 = locationWords.some(w => text1.includes(w));
            const hasLocation2 = locationWords.some(w => text2.includes(w));

            if (hasLocation1 && hasLocation2) {
                if ((text1.includes('entered') && text2.includes('stayed')) ||
                    (text1.includes('left') && text2.includes('arrived'))) {
                    return { type: 'location_contradiction', text1, text2 };
                }
            }

            // Perception contradictions
            const perceptionWords = ['saw', 'heard', 'felt', 'noticed', 'observed'];
            const hasPerception1 = perceptionWords.some(w => text1.includes(w));
            const hasPerception2 = perceptionWords.some(w => text2.includes(w));

            if (hasPerception1 && hasPerception2) {
                // Different perceptions of same event
                if (text1.length > 50 && text2.length > 50) {
                    return { type: 'perception_contradiction', text1, text2 };
                }
            }

            // Random contradiction for demonstration (10% chance)
            if (Math.random() < 0.1 && session.events.length > 3) {
                return { type: 'random_narrative', text1, text2 };
            }

            return null;
        }

        function generatePlotTwist(contradiction, event1, event2) {
            // Find appropriate twist template
            let template = PLOT_TWISTS.find(t => t.pattern === contradiction.type) ||
                          PLOT_TWISTS[Math.floor(Math.random() * PLOT_TWISTS.length)];

            const perspective1 = PERSPECTIVES[event1.author];
            const perspective2 = PERSPECTIVES[event2.author];

            const explanation = template.template
                .replace('{character}', 'the mysterious figure')
                .replace('{character1}', 'the suspect')
                .replace('{character2}', 'an imposter')
                .replace('{perspective1}', perspective1.name)
                .replace('{perspective2}', perspective2.name)
                .replace('{event1}', 'the first event')
                .replace('{event2}', 'the second event')
                .replace('{reason}', 'extreme stress')
                .replace('{conspirator}', 'unknown forces');

            return {
                type: template.type,
                explanation: explanation,
                event1Id: event1.id,
                event2Id: event2.id,
                perspective1: event1.author,
                perspective2: event2.author
            };
        }

        function createReconciliationVote(session, twist, event1, event2) {
            const vote = {
                id: `vote_${Date.now()}`,
                type: 'reconciliation',
                twist: twist,
                event1Id: event1.id,
                event2Id: event2.id,
                votes: { accept: 0, reject: 0 },
                voters: [],
                status: 'active',
                timestamp: new Date().toISOString()
            };

            session.votes.push(vote);
            renderVotes(session);
        }

        function castVote(voteId, decision) {
            const session = appData.currentSession;
            const vote = session.votes.find(v => v.id === voteId);

            if (!vote || vote.voters.includes('player1')) return;

            vote.votes[decision]++;
            vote.voters.push('player1');

            // Check if vote is decided
            const totalVotes = vote.votes.accept + vote.votes.reject;
            if (totalVotes >= Math.ceil(session.players.length / 2)) {
                vote.status = vote.votes.accept > vote.votes.reject ? 'accepted' : 'rejected';

                if (vote.status === 'accepted') {
                    // Apply reconciliation
                    const reconciliation = {
                        id: `recon_${Date.now()}`,
                        afterEventId: vote.event2Id,
                        twistType: vote.twist.type,
                        explanation: vote.twist.explanation,
                        votes: { ...vote.votes },
                        timestamp: new Date().toISOString()
                    };
                    session.reconciliations.push(reconciliation);

                    showAINotification('Plot twist accepted! The story has been reconciled.');
                    triggerParticles();
                    renderStory(session);
                }
            }

            saveData();
            renderVotes(session);
        }

        // ===== SIMULATED MULTIPLAYER =====
        function startSimulatedActivity(session) {
            // Simulate typing indicators
            setInterval(() => {
                if (Math.random() < 0.3) {
                    showTypingIndicator(session);
                }
            }, 5000);
        }

        function showTypingIndicator(session) {
            const indicators = document.getElementById('typingIndicators');
            const simulatedPlayers = session.players.filter(p => p.isSimulated);

            if (simulatedPlayers.length === 0) return;

            const player = simulatedPlayers[Math.floor(Math.random() * simulatedPlayers.length)];
            const perspective = PERSPECTIVES[player.perspective];

            indicators.innerHTML = `
                <div class="typing-indicator" style="color:${perspective.color}">
                    <span>${player.name} (${perspective.name})</span>
                    <div class="dots">
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                </div>
            `;

            setTimeout(() => {
                indicators.innerHTML = '';
            }, 3000);
        }

        function simulatePlayerResponses(session) {
            const simulatedPlayers = session.players.filter(p => p.isSimulated);

            simulatedPlayers.forEach(player => {
                if (Math.random() < 0.4) {
                    const delay = 3000 + Math.random() * 5000;
                    setTimeout(() => {
                        addSimulatedEntry(session, player);
                    }, delay);
                }
            });
        }

        function addSimulatedEntry(session, player) {
            const responses = [
                "Something moved in the shadows...",
                "The evidence doesn't add up.",
                "I sense a disturbance in the timeline.",
                "This changes everything we thought we knew.",
                "There's more to this story than meets the eye.",
                "The plot thickens considerably.",
                "An unexpected development has occurred.",
                "Patterns are emerging from the chaos."
            ];

            const text = responses[Math.floor(Math.random() * responses.length)];
            const perspective = player.perspective;

            const event = {
                id: `event_${Date.now()}_sim`,
                timestamp: new Date().toISOString(),
                type: 'narrative',
                perspectives: {
                    [perspective]: text
                },
                author: perspective,
                playerName: player.name
            };

            // Generate other perspective views
            Object.keys(PERSPECTIVES).forEach(p => {
                if (p !== perspective) {
                    event.perspectives[p] = transformPerspective(text, perspective, p);
                }
            });

            session.events.push(event);
            saveData();
            renderStory(session);
            renderSidePanels(session);
        }

        // ===== SIDE PANELS =====
        function renderSidePanels(session) {
            renderPerspectives(session);
            renderTimeline(session);
            renderCharacters(session);
            renderReconciliations(session);
            renderVotes(session);
        }

        function switchTab(tab) {
            const tabName = tab.dataset.tab;

            document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));

            tab.classList.add('active');
            document.getElementById(`${tabName}Section`).classList.add('active');
        }

        function renderPerspectives(session) {
            const section = document.getElementById('perspectivesSection');
            section.innerHTML = '';

            const lastEvent = session.events[session.events.length - 1];
            if (!lastEvent) {
                section.innerHTML = '<p style="color:var(--text-muted)">No events yet. Start writing!</p>';
                return;
            }

            Object.entries(PERSPECTIVES).forEach(([key, perspective]) => {
                if (!lastEvent.perspectives[key]) return;

                const view = document.createElement('div');
                view.className = 'perspective-view';
                view.innerHTML = `
                    <div class="view-header" style="color:${perspective.color}">
                        ${perspective.icon} ${perspective.name}
                    </div>
                    <div class="view-content">${lastEvent.perspectives[key]}</div>
                `;
                section.appendChild(view);
            });
        }

        function renderTimeline(session) {
            const container = document.getElementById('timelineContainer');
            container.innerHTML = '<div class="timeline-line"></div>';

            session.events.forEach((event, index) => {
                const perspective = PERSPECTIVES[event.author];
                const eventEl = document.createElement('div');
                eventEl.className = 'timeline-event';

                const hasReconciliation = session.reconciliations.some(r => r.afterEventId === event.id);
                if (hasReconciliation) eventEl.classList.add('reconciled');

                const summary = Object.values(event.perspectives)[0].substring(0, 50) + '...';

                eventEl.innerHTML = `
                    <div class="event-time">${formatTime(event.timestamp)} - ${perspective?.name || 'Unknown'}</div>
                    <div class="event-summary">${summary}</div>
                `;
                container.appendChild(eventEl);
            });
        }

        function renderCharacters(session) {
            const section = document.getElementById('charactersSection');

            // Extract characters from text (simple approach)
            const allText = session.events.map(e => Object.values(e.perspectives).join(' ')).join(' ');
            const characterHints = ['suspect', 'victim', 'detective', 'stranger', 'figure', 'person', 'man', 'woman'];

            const foundCharacters = characterHints.filter(c =>
                allText.toLowerCase().includes(c)
            );

            if (foundCharacters.length === 0) {
                section.innerHTML = '<p style="color:var(--text-muted)">Characters will appear as the story develops.</p>';
                return;
            }

            section.innerHTML = foundCharacters.map(char => `
                <div class="character-card">
                    <div class="char-name">${char.charAt(0).toUpperCase() + char.slice(1)}</div>
                    <div class="char-traits">
                        <span class="trait">Mentioned in story</span>
                    </div>
                </div>
            `).join('');
        }

        function renderReconciliations(session) {
            const section = document.getElementById('reconciliationsSection');

            if (session.reconciliations.length === 0) {
                section.innerHTML = '<p style="color:var(--text-muted)">No plot twists yet. Keep writing to create contradictions!</p>';
                return;
            }

            section.innerHTML = session.reconciliations.map(recon => `
                <div class="reconciliation-item">
                    <div class="twist-name">${recon.twistType}</div>
                    <div class="resolution">${recon.explanation}</div>
                    <div class="votes">
                        <span>Accepted: ${recon.votes.accept}</span>
                        <span>Rejected: ${recon.votes.reject}</span>
                    </div>
                </div>
            `).join('');
        }

        function renderVotes(session) {
            const section = document.getElementById('votesSection');
            const activeVotes = session.votes.filter(v => v.status === 'active');

            if (activeVotes.length === 0) {
                section.innerHTML = '<p style="color:var(--text-muted)">No active votes. Contradictions will trigger votes!</p>';
                return;
            }

            section.innerHTML = activeVotes.map(vote => `
                <div class="vote-card">
                    <div class="vote-question">Accept plot twist: ${vote.twist.type}?</div>
                    <p style="font-size:0.9em; color:var(--text-secondary); margin-bottom:12px;">
                        ${vote.twist.explanation}
                    </p>
                    <div class="vote-options">
                        <button class="vote-btn accept" onclick="castVote('${vote.id}', 'accept')">
                            Accept (${vote.votes.accept})
                        </button>
                        <button class="vote-btn reject" onclick="castVote('${vote.id}', 'reject')">
                            Reject (${vote.votes.reject})
                        </button>
                    </div>
                </div>
            `).join('');
        }

        // ===== QUICK ACTIONS =====
        function insertTimeJump() {
            const session = appData.currentSession;
            const timeJumps = [
                'Three hours later...',
                'The next morning...',
                'Meanwhile, in another part of the city...',
                'Looking back on that fateful moment...',
                'Years from now, they would remember this day...'
            ];

            const text = timeJumps[Math.floor(Math.random() * timeJumps.length)];

            const event = {
                id: `event_${Date.now()}`,
                timestamp: new Date().toISOString(),
                type: 'time_jump',
                perspectives: { narrator: text },
                author: 'narrator'
            };

            session.events.push(event);
            saveData();
            renderStory(session);
        }

        function introduceCharacter() {
            const input = document.getElementById('writingInput');
            const characterPrompts = [
                'A mysterious stranger appeared...',
                'Someone new entered the scene...',
                'An unexpected ally emerged...',
                'A figure from the past returned...'
            ];
            input.value = characterPrompts[Math.floor(Math.random() * characterPrompts.length)];
            document.getElementById('charCount').textContent = input.value.length;
        }

        function triggerReconciliation() {
            const session = appData.currentSession;
            if (session.events.length < 2) {
                alert('Need at least 2 events to create a contradiction.');
                return;
            }

            // Force a random plot twist
            const event1 = session.events[session.events.length - 2];
            const event2 = session.events[session.events.length - 1];

            const twist = generatePlotTwist(
                { type: 'random_narrative' },
                event1,
                event2
            );

            createReconciliationVote(session, twist, event1, event2);
            showAINotification('A plot twist has been proposed!');
        }

        // ===== EXPORT FUNCTIONALITY =====
        function openExportModal() {
            document.getElementById('exportModal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function exportStory(format) {
            const session = appData.currentSession;
            if (!session) {
                alert('No active session to export.');
                return;
            }

            let content, filename, mimeType;

            switch (format) {
                case 'interactive':
                    content = generateInteractiveHTML(session);
                    filename = `${session.name.replace(/\s+/g, '-')}-interactive.html`;
                    mimeType = 'text/html';
                    break;
                case 'splitscreen':
                    content = generateSplitScreenHTML(session);
                    filename = `${session.name.replace(/\s+/g, '-')}-splitscreen.html`;
                    mimeType = 'text/html';
                    break;
                case 'timeline':
                    content = generateTimelineHTML(session);
                    filename = `${session.name.replace(/\s+/g, '-')}-timeline.html`;
                    mimeType = 'text/html';
                    break;
                case 'novel':
                    content = generateNovelText(session);
                    filename = `${session.name.replace(/\s+/g, '-')}-novel.txt`;
                    mimeType = 'text/plain';
                    break;
                case 'json':
                    content = JSON.stringify(session, null, 2);
                    filename = `${session.name.replace(/\s+/g, '-')}-data.json`;
                    mimeType = 'application/json';
                    break;
            }

            downloadFile(content, filename, mimeType);
            closeExportModal();
        }

        function generateInteractiveHTML(session) {
            const perspectiveButtons = Object.entries(PERSPECTIVES).map(([key, p]) =>
                `<button onclick="showPerspective('${key}')" style="background:${p.bgColor};color:${p.color};border:none;padding:10px 20px;margin:5px;border-radius:5px;cursor:pointer;">${p.icon} ${p.name}</button>`
            ).join('');

            const events = session.events.map(event => {
                const perspectiveContents = Object.entries(event.perspectives).map(([key, text]) =>
                    `<div class="perspective-content" data-perspective="${key}" style="display:none;padding:15px;background:#1a1a25;margin:10px 0;border-radius:8px;border-left:4px solid ${PERSPECTIVES[key]?.color || '#666'}"><strong>${PERSPECTIVES[key]?.icon || ''} ${PERSPECTIVES[key]?.name || key}:</strong><br>${text}</div>`
                ).join('');
                return `<div class="event">${perspectiveContents}</div>`;
            }).join('');

            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${session.name} - Interactive Story</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #0a0a0f; color: #fff; padding: 40px; max-width: 800px; margin: 0 auto; }
        h1 { text-align: center; color: #d4af37; }
        .controls { text-align: center; margin: 30px 0; }
        .event { margin: 20px 0; }
    </style>
</head>
<body>
    <h1>${session.name}</h1>
    <p style="text-align:center;color:#666;">Click a perspective to view the story through their eyes</p>
    <div class="controls">${perspectiveButtons}</div>
    <div id="story">${events}</div>
    <script>
        let currentPerspective = 'narrator';
        function showPerspective(p) {
            currentPerspective = p;
            document.querySelectorAll('.perspective-content').forEach(el => {
                el.style.display = el.dataset.perspective === p ? 'block' : 'none';
            });
        }
        showPerspective('narrator');
    </script>
</body>
</html>`;
        }

        function generateSplitScreenHTML(session) {
            const perspectives = [...new Set(session.events.map(e => e.author))];
            const columns = perspectives.map(p => {
                const perspective = PERSPECTIVES[p];
                const events = session.events.filter(e => e.author === p).map(e =>
                    `<div style="padding:10px;background:#1a1a25;margin:10px 0;border-radius:5px;">${e.perspectives[p]}</div>`
                ).join('');
                return `<div style="flex:1;padding:15px;border-right:1px solid #333;"><h3 style="color:${perspective?.color || '#fff'}">${perspective?.icon || ''} ${perspective?.name || p}</h3>${events}</div>`;
            }).join('');

            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${session.name} - Split Screen View</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #0a0a0f; color: #fff; margin: 0; }
        h1 { text-align: center; padding: 20px; color: #d4af37; margin: 0; background: #12121a; }
        .container { display: flex; min-height: calc(100vh - 80px); }
    </style>
</head>
<body>
    <h1>${session.name}</h1>
    <div class="container">${columns}</div>
</body>
</html>`;
        }

        function generateTimelineHTML(session) {
            const timelineEvents = session.events.map((event, i) => {
                const perspective = PERSPECTIVES[event.author];
                const text = event.perspectives[event.author];
                const hasReconciliation = session.reconciliations.find(r => r.afterEventId === event.id);

                let html = `<div style="display:flex;margin:20px 0;">
                    <div style="width:100px;text-align:right;padding-right:20px;color:#666;">${formatTime(event.timestamp)}</div>
                    <div style="width:20px;position:relative;">
                        <div style="width:12px;height:12px;background:${perspective?.color || '#666'};border-radius:50%;position:absolute;left:4px;"></div>
                        <div style="width:2px;height:100%;background:#333;position:absolute;left:9px;top:12px;"></div>
                    </div>
                    <div style="flex:1;padding-left:20px;">
                        <strong style="color:${perspective?.color || '#fff'}">${perspective?.icon || ''} ${perspective?.name || 'Unknown'}</strong>
                        <p style="margin:5px 0;color:#ccc;">${text}</p>
                    </div>
                </div>`;

                if (hasReconciliation) {
                    html += `<div style="margin:10px 0 10px 140px;padding:15px;background:rgba(212,175,55,0.1);border:1px dashed #d4af37;border-radius:8px;">
                        <strong style="color:#d4af37;">PLOT TWIST: ${hasReconciliation.twistType}</strong>
                        <p style="font-style:italic;margin:5px 0;">${hasReconciliation.explanation}</p>
                    </div>`;
                }

                return html;
            }).join('');

            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${session.name} - Timeline View</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #0a0a0f; color: #fff; padding: 40px; max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: #d4af37; margin-bottom: 40px; }
    </style>
</head>
<body>
    <h1>${session.name}</h1>
    ${timelineEvents}
</body>
</html>`;
        }

        function generateNovelText(session) {
            let text = `${session.name.toUpperCase()}\n`;
            text += `${'='.repeat(session.name.length)}\n\n`;
            text += `A Collaborative Story\n`;
            text += `Created: ${new Date(session.startTime).toLocaleDateString()}\n\n`;
            text += `---\n\n`;

            session.events.forEach((event, i) => {
                const perspective = PERSPECTIVES[event.author];
                text += event.perspectives[event.author] + '\n\n';

                const reconciliation = session.reconciliations.find(r => r.afterEventId === event.id);
                if (reconciliation) {
                    text += `[PLOT TWIST: ${reconciliation.twistType}]\n`;
                    text += `${reconciliation.explanation}\n\n`;
                }
            });

            text += `---\n\n`;
            text += `PERSPECTIVE NOTES:\n\n`;

            Object.entries(PERSPECTIVES).forEach(([key, p]) => {
                text += `${p.icon} ${p.name}: ${p.description}\n`;
            });

            return text;
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // ===== VISUAL EFFECTS =====
        function triggerParticles() {
            const container = document.getElementById('particles');
            const colors = ['#d4af37', '#fff', '#8338ec', '#06ffa5'];

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = (50 + Math.random() * 30) + '%';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.animationDelay = (Math.random() * 0.5) + 's';
                container.appendChild(particle);

                setTimeout(() => particle.remove(), 2000);
            }
        }

        function showAINotification(message) {
            const notification = document.getElementById('aiNotification');
            notification.classList.add('active');
            notification.innerHTML = `<span>${message}</span>`;

            setTimeout(() => {
                notification.classList.remove('active');
                notification.innerHTML = '<span>AI Narrator ready</span>';
            }, 5000);
        }

        // ===== TUTORIAL =====
        function showTutorial() {
            alert(`NARRATIVE MULTIVERSE - How It Works

1. CHOOSE YOUR PERSPECTIVE
   Each player sees the story through a unique lens:
   - Detective: Sees clues and evidence
   - Villain: Sees opportunities and weaknesses
   - Victim: Sees threats and danger
   - And more...

2. WRITE COLLABORATIVELY
   Write your part of the story. Other players write from their perspectives simultaneously.

3. AI RECONCILIATION
   When perspectives contradict, the AI generates plot twists to make both versions true:
   - Twin siblings
   - Time travel
   - Unreliable narrators
   - Parallel universes

4. VOTE ON TWISTS
   Players vote to accept or reject AI suggestions.

5. EXPORT YOUR STORY
   Download as interactive fiction, split-screen view, timeline, or traditional novel.

Start writing to experience the multiverse!`);
        }

        function showTutorialTooltip() {
            appData.settings.tutorialShown = true;
            saveData();
        }

        // ===== KEYBOARD SHORTCUTS =====
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + Enter to submit
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                if (document.getElementById('writingPage').classList.contains('active')) {
                    submitEntry();
                }
            }
            // Escape to close modal
            if (e.key === 'Escape') {
                closeExportModal();
            }
        });

        // ===== INITIALIZATION =====
        function init() {
            // Check for saved session
            if (appData.currentSession && appData.sessions.length > 0) {
                // Could auto-resume, but let user choose
            }
        }

        init();
    </script>
</body>
</html>
