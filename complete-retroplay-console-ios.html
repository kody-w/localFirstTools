<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>RetroPlay Mobile</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Poppins:wght@400;600&display=swap');

        :root {
            --console-color: #8ca5ac;
            --console-dark: #566366;
            --console-light: #b8c7cc;
            --screen-color: #8bac0f;
            --button-color: #2f3335;
            --button-shadow: #1a1c1d;
            --accent-color: #e42c64;
            --text-color: #181c1f;
            --menu-bg: rgba(240, 240, 240, 0.95);
            --action-button-color: #e42c64;
            --action-button-shadow: #a52147;
            --header-height: 60px; /* Header height for status bar */
            --controls-height: 180px; /* Controls area height */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: fixed;
            display: flex;
            flex-direction: column;
            color: var(--text-color);
        }

        /* App header */
        .app-header {
            width: 100%;
            height: var(--header-height);
            background-color: #333;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 15px;
            position: relative;
            z-index: 10;
        }

        .app-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            padding: 10px 0;
            margin-left: 5px;
        }

        /* Game area */
        .game-container {
            flex: 1;
            width: 100%;
            background-color: #222;
            position: relative;
            overflow: hidden;
        }

        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--screen-color);
            overflow: hidden;
        }

        .screen-content {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Controls styling */
        .controls-container {
            width: 100%;
            height: var(--controls-height);
            background-color: #e9e9e9;
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .d-pad {
            width: 140px;
            height: 140px;
            position: relative;
            margin-left: 10px;
        }

        .d-pad-button {
            position: absolute;
            width: 45px;
            height: 45px;
            background-color: var(--button-color);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 0 var(--button-shadow);
            user-select: none;
        }

        .d-pad-center {
            top: 47.5px;
            left: 47.5px;
            width: 45px;
            height: 45px;
            background-color: var(--button-color);
            border-radius: 8px;
            z-index: 0;
        }

        .d-pad-up {
            top: 0;
            left: 47.5px;
        }

        .d-pad-right {
            top: 47.5px;
            right: 0;
        }

        .d-pad-down {
            bottom: 0;
            left: 47.5px;
        }

        .d-pad-left {
            top: 47.5px;
            left: 0;
        }

        .d-pad-button:active,
        .d-pad-button.active {
            transform: translateY(4px);
            box-shadow: 0 0 0 var(--button-shadow);
        }

        .action-buttons {
            width: 140px;
            height: 140px;
            position: relative;
            margin-right: 10px;
        }

        .action-button {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: var(--action-button-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            box-shadow: 0 4px 0 var(--action-button-shadow);
            user-select: none;
        }

        .button-a {
            top: 10px;
            right: 0;
        }

        .button-b {
            bottom: 10px;
            left: 0;
        }

        .action-button:active,
        .action-button.active {
            transform: translateY(4px);
            box-shadow: 0 0 0 var(--action-button-shadow);
        }

        .system-controls {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 15px;
        }

        .system-button {
            min-width: 80px;
            height: 25px;
            background-color: var(--button-color);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #fff;
            box-shadow: 0 3px 0 var(--button-shadow);
            padding: 0 10px;
        }

        .system-button:active,
        .system-button.active {
            transform: translateY(3px);
            box-shadow: 0 0 0 var(--button-shadow);
        }

        /* Game menu */
        .game-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--menu-bg);
            display: none;
            flex-direction: column;
            z-index: 1000;
            padding-top: var(--header-height);
        }

        .menu-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            position: sticky;
            top: var(--header-height);
            background-color: white;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .menu-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            color: var(--text-color);
        }

        .close-menu {
            font-size: 24px;
            color: var(--text-color);
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            width: 100%;
            padding: 15px;
            overflow-y: auto;
            flex: 1;
        }

        .game-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .game-card:active {
            transform: translateY(-3px);
            box-shadow: 0 7px 10px rgba(0, 0, 0, 0.15);
        }

        .game-icon {
            width: 60px;
            height: 60px;
            background-color: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
        }

        .game-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-align: center;
            margin-bottom: 8px;
        }

        .game-description {
            font-size: 12px;
            text-align: center;
            color: #666;
        }

        .app-store-section {
            width: 100%;
            padding: 15px;
            border-top: 2px solid #ddd;
            background-color: white;
        }

        .store-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .upload-game {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
        }

        .browse-github {
            background-color: #333;
        }

        .file-input {
            display: none;
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 3000;
        }

        .loading-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            margin-bottom: 20px;
            text-align: center;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* GitHub browser */
        .github-browser {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--menu-bg);
            display: none;
            flex-direction: column;
            z-index: 1500;
            padding-top: var(--header-height);
        }

        .browser-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            position: sticky;
            top: var(--header-height);
            background-color: white;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .repo-info {
            margin: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .file-list {
            list-style-type: none;
            padding: 0 15px;
            overflow-y: auto;
            flex: 1;
        }

        .file-list li {
            margin-bottom: 10px;
        }

        .file-link {
            display: block;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 8px;
            color: #333;
            text-decoration: none;
        }

        /* Overlay/Modal */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 20px;
        }

        .modal-content {
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
        }

        .confirm-button {
            background-color: var(--accent-color);
            color: white;
        }

        .cancel-button {
            background-color: #ddd;
        }

        /* iPhone X and newer safe area */
        @supports (padding: max(0px)) {
            body {
                padding-top: max(0px, env(safe-area-inset-top));
                padding-bottom: max(0px, env(safe-area-inset-bottom));
            }
        }

        /* Landscape orientation adjustments */
        @media screen and (orientation: landscape) {
            .app-header {
                height: auto;
                padding: 5px 15px;
            }
            
            .controls-container {
                position: absolute;
                top: 0;
                right: 0;
                width: 25%;
                height: 100%;
                flex-direction: column;
                justify-content: center;
                gap: 20px;
                background-color: rgba(233, 233, 233, 0.9);
                z-index: 5;
            }
            
            .game-container {
                position: relative;
                width: 100%;
                height: calc(100% - var(--header-height));
            }
            
            .game-screen {
                width: 75%;
                height: 100%;
            }
            
            .d-pad, .action-buttons {
                transform: scale(0.8);
                margin: 0;
            }
            
            .system-controls {
                position: relative;
                top: 0;
                left: 0;
                transform: none;
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
        }

        /* iPhone SE/mini support */
        @media screen and (max-height: 670px) {
            .controls-container {
                height: 160px;
            }
            
            .d-pad, .action-buttons {
                transform: scale(0.85);
            }
            
            .system-controls {
                transform: translate(-50%, -50%) scale(0.9);
            }
            
            .app-header {
                height: 50px;
            }
            
            :root {
                --header-height: 50px;
                --controls-height: 160px;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loading-screen">
        <div class="loading-text">LOADING GAMES</div>
        <div class="loading-spinner"></div>
    </div>

    <div class="app-header">
        <div class="app-title">RetroPlay</div>
    </div>

    <div class="game-container">
        <div class="game-screen">
            <div class="screen-content" id="game-display">
                <!-- Game will be displayed here -->
            </div>
        </div>
    </div>

    <div class="controls-container">
        <div class="d-pad">
            <div class="d-pad-center"></div>
            <div class="d-pad-button d-pad-up" id="d-up">▲</div>
            <div class="d-pad-button d-pad-right" id="d-right">▶</div>
            <div class="d-pad-button d-pad-down" id="d-down">▼</div>
            <div class="d-pad-button d-pad-left" id="d-left">◀</div>
        </div>
        
        <div class="system-controls">
            <div class="system-button" id="btn-select">SELECT</div>
            <div class="system-button" id="btn-start">START</div>
        </div>
        
        <div class="action-buttons">
            <div class="action-button button-a" id="btn-a">A</div>
            <div class="action-button button-b" id="btn-b">B</div>
        </div>
    </div>

    <div class="game-menu" id="game-menu">
        <div class="menu-header">
            <h1 class="menu-title">RetroPlay Games</h1>
            <button class="close-menu" id="close-menu">✕</button>
        </div>
        <div class="games-grid" id="games-grid">
            <!-- Games will be inserted here -->
        </div>
        <div class="app-store-section">
            <div class="store-header">
                <h2 class="menu-title">Add Games</h2>
                <div>
                    <button class="upload-game" id="upload-game-btn">+ Upload</button>
                    <button class="upload-game browse-github" id="browse-github-btn">GitHub</button>
                </div>
                <input type="file" id="file-input" class="file-input" accept=".json">
            </div>
        </div>
    </div>

    <div class="github-browser" id="github-browser">
        <div class="browser-header">
            <h1 class="menu-title">GitHub Games</h1>
            <button class="close-menu" id="close-github">✕</button>
        </div>
        <div class="repo-info" id="repo-info">
            <h2>Game Repository</h2>
            <p>Browse available game files</p>
        </div>
        <ul class="file-list" id="file-list">
            <!-- Files will be listed here -->
            <li><div class="loading">Loading repository files...</div></li>
        </ul>
    </div>

    <div class="overlay" id="overlay">
        <div class="modal" id="modal">
            <div class="modal-header">
                <h3>Export Game</h3>
                <button class="close-modal" id="close-modal">✕</button>
            </div>
            <div class="modal-content">
                <p>Do you want to export the current game as a JSON file?</p>
            </div>
            <div class="modal-actions">
                <button class="modal-button cancel-button" id="cancel-export">Cancel</button>
                <button class="modal-button confirm-button" id="confirm-export">Export</button>
            </div>
        </div>
    </div>

    <script>
        // Main System Class
        class RetroConsole {
            constructor() {
                // GitHub repository information
                this.REPO_OWNER = 'kody-w';
                this.REPO_NAME = 'localFirstTools';
                this.BRANCH = 'main';
                
                this.gameLibrary = {};
                this.currentGame = null;
                this.gameRunning = false;
                this.gameLoop = null;
                this.gameDisplay = document.getElementById('game-display');
                
                // Initialize viewport dimensions
                this.updateViewportDimensions();
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Initialize loading screen
                this.loadingScreen = document.getElementById('loading-screen');
                
                // Fix for iOS Safari overscroll behavior
                document.body.addEventListener('touchmove', function(e) {
                    if (e.target.closest('.games-grid, .file-list') === null) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Load games from GitHub repository
                this.fetchAndLoadGames().then(() => {
                    // Hide loading screen when games are loaded
                    this.loadingScreen.style.display = 'none';
                    // Display main menu
                    this.displayMainMenu();
                }).catch(error => {
                    console.error('Error loading games:', error);
                    // Hide loading screen and show error message
                    this.loadingScreen.style.display = 'none';
                    // Load default games as fallback
                    this.loadDefaultGames();
                    this.displayMainMenu();
                });
            }

            updateViewportDimensions() {
                // Get the game container dimensions
                const gameContainer = document.querySelector('.game-container');
                this.viewportWidth = gameContainer.clientWidth;
                this.viewportHeight = gameContainer.clientHeight;
                
                // In landscape orientation, adjust for the controls on the right
                if (window.innerWidth > window.innerHeight) {
                    this.viewportWidth = gameContainer.clientWidth * 0.75;
                }
                
                console.log(`Viewport dimensions: ${this.viewportWidth}x${this.viewportHeight}`);
            }

            setupEventListeners() {
                // Menu Controls
                document.getElementById('btn-start').addEventListener('click', () => {
                    document.getElementById('game-menu').style.display = 'flex';
                    this.loadGameList();
                });
                
                document.getElementById('close-menu').addEventListener('click', () => {
                    document.getElementById('game-menu').style.display = 'none';
                });

                // GitHub Browser
                document.getElementById('browse-github-btn').addEventListener('click', () => {
                    document.getElementById('github-browser').style.display = 'flex';
                    this.loadGitHubFiles();
                });
                
                document.getElementById('close-github').addEventListener('click', () => {
                    document.getElementById('github-browser').style.display = 'none';
                });

                // Upload Game
                document.getElementById('upload-game-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                
                document.getElementById('file-input').addEventListener('change', (event) => {
                    this.handleFileUpload(event);
                });

                // Export Game
                document.getElementById('btn-select').addEventListener('click', () => {
                    if (this.currentGame) {
                        document.getElementById('overlay').style.display = 'flex';
                    }
                });
                
                document.getElementById('close-modal').addEventListener('click', () => {
                    document.getElementById('overlay').style.display = 'none';
                });
                
                document.getElementById('cancel-export').addEventListener('click', () => {
                    document.getElementById('overlay').style.display = 'none';
                });
                
                document.getElementById('confirm-export').addEventListener('click', () => {
                    this.exportCurrentGame();
                    document.getElementById('overlay').style.display = 'none';
                });

                // Game Controls - Touch/Click with improved mobile handling
                const controls = {
                    up: document.getElementById('d-up'),
                    right: document.getElementById('d-right'),
                    down: document.getElementById('d-down'),
                    left: document.getElementById('d-left'),
                    a: document.getElementById('btn-a'),
                    b: document.getElementById('btn-b')
                };

                // Add touch/click event listeners for controls
                Object.entries(controls).forEach(([key, element]) => {
                    // For mobile devices, use touchstart/touchend
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.handleButtonPress(key);
                        element.classList.add('active');
                    }, { passive: false });
                    
                    element.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.handleButtonRelease(key);
                        element.classList.remove('active');
                    }, { passive: false });
                    
                    // For desktop/testing, use mousedown/mouseup
                    element.addEventListener('mousedown', () => {
                        this.handleButtonPress(key);
                        element.classList.add('active');
                    });
                    
                    element.addEventListener('mouseup', () => {
                        this.handleButtonRelease(key);
                        element.classList.remove('active');
                    });
                    
                    // Handle touch move outside the button (for better mobile UX)
                    element.addEventListener('touchmove', (e) => {
                        const touch = e.touches[0];
                        const elementRect = element.getBoundingClientRect();
                        
                        // Check if touch moved outside the element
                        if (
                            touch.clientX < elementRect.left || 
                            touch.clientX > elementRect.right || 
                            touch.clientY < elementRect.top || 
                            touch.clientY > elementRect.bottom
                        ) {
                            this.handleButtonRelease(key);
                            element.classList.remove('active');
                        }
                    });
                });

                // Add keyboard event listeners
                document.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });
                
                document.addEventListener('keyup', (e) => {
                    this.handleKeyUp(e);
                });
                
                // Handle orientation change
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.updateViewportDimensions();
                        
                        // Force refresh the game screen on orientation change
                        if (this.currentGame && this.currentGame.render) {
                            this.currentGame.render();
                        }
                    }, 300);
                });
                
                // Handle resize
                window.addEventListener('resize', () => {
                    this.updateViewportDimensions();
                    
                    // Force refresh the game screen on resize
                    if (this.currentGame && this.currentGame.render) {
                        this.currentGame.render();
                    }
                });
                
                // Prevent zooming on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, { passive: false });
            }

            async fetchAndLoadGames() {
                try {
                    // First, specifically check for snake-2.0-complete.json
                    try {
                        const snakeGameUrl = `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/snake-2.0-complete.json`;
                        const snakeGameResponse = await fetch(snakeGameUrl);
                        
                        if (snakeGameResponse.ok) {
                            console.log('Found snake-2.0-complete.json, loading...');
                            const gameData = await snakeGameResponse.json();
                            const game = this.processGameData(gameData);
                            if (game) {
                                this.gameLibrary[game.id] = game;
                                console.log(`Successfully loaded snake game: ${game.name}`);
                            }
                        }
                    } catch (error) {
                        console.error('Error loading snake-2.0-complete.json:', error);
                    }

                    // GitHub API URL for repository contents (to get all files in root directory)
                    const apiUrl = `https://api.github.com/repos/${this.REPO_OWNER}/${this.REPO_NAME}/contents?ref=${this.BRANCH}`;
                    
                    // Fetch the repository contents
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const contents = await response.json();
                    
                    // Filter for JSON files (potential game cartridges)
                    const jsonFiles = contents.filter(item => 
                        item.type === 'file' && 
                        item.name.endsWith('.json') && 
                        item.name !== 'snake-2.0-complete.json' && // Skip snake game if already loaded
                        !item.name.startsWith('.')
                    );
                    
                    console.log(`Found ${jsonFiles.length} potential game cartridges`);
                    
                    // Load each game cartridge
                    for (const file of jsonFiles) {
                        try {
                            const fileUrl = `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/${file.name}`;
                            const gameResponse = await fetch(fileUrl);
                            
                            if (!gameResponse.ok) {
                                console.error(`Error fetching game cartridge ${file.name}: ${gameResponse.status}`);
                                continue;
                            }
                            
                            const gameData = await gameResponse.json();
                            const game = this.processGameData(gameData);
                            
                            if (game) {
                                this.gameLibrary[game.id] = game;
                                console.log(`Successfully loaded game: ${game.name}`);
                            }
                            
                        } catch (error) {
                            console.error(`Error processing game cartridge ${file.name}:`, error);
                        }
                    }
                    
                    const loadedGamesCount = Object.keys(this.gameLibrary).length;
                    console.log(`Successfully loaded ${loadedGamesCount} games in total`);
                    
                    // If no valid games were loaded, fall back to default games
                    if (loadedGamesCount === 0) {
                        console.log('No valid game cartridges found. Loading default games.');
                        this.loadDefaultGames();
                    }
                    
                } catch (error) {
                    console.error('Error fetching repository contents:', error);
                    // Fall back to default games if there's an error
                    this.loadDefaultGames();
                    throw error;
                }
            }

            // Process game data from JSON and convert it to a playable game object
            processGameData(gameData) {
                try {
                    // Validate that it has the minimum required properties
                    if (!gameData.id || !gameData.name || !gameData.gameData || !gameData.initializeCode) {
                        console.error(`Invalid game cartridge: Missing required properties`);
                        return null;
                    }
                    
                    // Reconstruct the game object from serialized functions
                    const game = {
                        id: gameData.id,
                        name: gameData.name,
                        description: gameData.description || "No description provided",
                        icon: gameData.icon || "🎮",
                        gameData: gameData.gameData,
                        
                        // Convert function strings back to actual functions
                        initialize: new Function('return ' + gameData.initializeCode)(),
                        update: gameData.updateCode ? new Function('return ' + gameData.updateCode)() : null,
                        render: gameData.renderCode ? new Function('return ' + gameData.renderCode)() : null,
                        handleInput: gameData.handleInputCode ? new Function('return ' + gameData.handleInputCode)() : null,
                        cleanup: gameData.cleanupCode ? new Function('return ' + gameData.cleanupCode)() : null
                    };
                    
                    // Add any additional functions
                    if (gameData.additionalFunctions) {
                        for (const key in gameData.additionalFunctions) {
                            try {
                                game[key] = new Function('return ' + gameData.additionalFunctions[key])();
                            } catch (error) {
                                console.error(`Error processing additional function '${key}':`, error);
                            }
                        }
                    }
                    
                    return game;
                } catch (error) {
                    console.error('Error processing game cartridge:', error);
                    return null;
                }
            }

            // Load GitHub Files for browser
            async loadGitHubFiles() {
                const fileList = document.getElementById('file-list');
                fileList.innerHTML = '<li><div class="loading">Loading repository files...</div></li>';
                
                try {
                    // GitHub API URL for repository contents
                    const apiUrl = `https://api.github.com/repos/${this.REPO_OWNER}/${this.REPO_NAME}/git/trees/${this.BRANCH}?recursive=1`;
                    
                    // Fetch the repository data
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Filter for JSON files
                    const jsonFiles = data.tree
                        .filter(item => item.type === 'blob' && 
                               item.path.endsWith('.json'))
                        .map(item => {
                            return {
                                path: item.path,
                                url: `https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/blob/${this.BRANCH}/${item.path}`,
                                raw_url: `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/${item.path}`
                            };
                        });
                    
                    // Display files
                    if (jsonFiles.length > 0) {
                        fileList.innerHTML = '';
                        
                        jsonFiles.forEach(file => {
                            const listItem = document.createElement('li');
                            const fileName = file.path.split('/').pop();
                            
                            listItem.innerHTML = `
                                <div class="file-link" data-raw-url="${file.raw_url}" data-path="${file.path}">
                                    ${file.path}
                                </div>
                            `;
                            
                            listItem.querySelector('.file-link').addEventListener('click', async () => {
                                await this.loadGameFromGitHub(file.raw_url, fileName);
                            });
                            
                            fileList.appendChild(listItem);
                        });
                    } else {
                        fileList.innerHTML = '<li><div class="error-message">No JSON game files found in the repository.</div></li>';
                    }
                    
                } catch (error) {
                    console.error("Error fetching repository:", error);
                    fileList.innerHTML = `
                        <li>
                            <div class="error-message">
                                <strong>Error:</strong> ${error.message}
                            </div>
                            <p>Could not load repository data.</p>
                        </li>
                    `;
                }
            }

            // Load game from GitHub
            async loadGameFromGitHub(url, fileName) {
                try {
                    // Show loading screen
                    this.loadingScreen.style.display = 'flex';
                    
                    // Fetch the JSON content
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch game (${response.status})`);
                    }
                    
                    const gameData = await response.json();
                    
                    // Process the game data
                    const game = this.processGameData(gameData);
                    
                    if (game) {
                        // Add to library
                        this.gameLibrary[game.id] = game;
                        
                        // Close GitHub browser
                        document.getElementById('github-browser').style.display = 'none';
                        
                        // Close game menu if open
                        document.getElementById('game-menu').style.display = 'none';
                        
                        // Hide loading screen
                        this.loadingScreen.style.display = 'none';
                        
                        // Load the game
                        this.loadGame(game.id);
                        
                        console.log(`Successfully loaded game from GitHub: ${game.name}`);
                    } else {
                        throw new Error('Invalid game cartridge format');
                    }
                } catch (error) {
                    console.error('Error loading game from GitHub:', error);
                    this.loadingScreen.style.display = 'none';
                    alert(`Error loading game: ${error.message}`);
                }
            }

            handleKeyDown(e) {
                // Visual feedback - add active class to button
                const updateButtonVisuals = (buttonId, isActive) => {
                    const element = document.getElementById(buttonId);
                    if (element) {
                        if (isActive) {
                            element.classList.add('active');
                        } else {
                            element.classList.remove('active');
                        }
                    }
                };

                // Map keyboard keys to buttons
                switch (e.key) {
                    case 'ArrowUp':
                        updateButtonVisuals('d-up', true);
                        this.handleButtonPress('up');
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        updateButtonVisuals('d-right', true);
                        this.handleButtonPress('right');
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        updateButtonVisuals('d-down', true);
                        this.handleButtonPress('down');
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        updateButtonVisuals('d-left', true);
                        this.handleButtonPress('left');
                        e.preventDefault();
                        break;
                    case 'z':
                    case 'Z':
                        updateButtonVisuals('btn-a', true);
                        this.handleButtonPress('a');
                        e.preventDefault();
                        break;
                    case 'x':
                    case 'X':
                        updateButtonVisuals('btn-b', true);
                        this.handleButtonPress('b');
                        e.preventDefault();
                        break;
                    case 'Enter':
                        updateButtonVisuals('btn-start', true);
                        document.getElementById('game-menu').style.display = 'flex';
                        this.loadGameList();
                        e.preventDefault();
                        break;
                    case 'Shift':
                        updateButtonVisuals('btn-select', true);
                        if (this.currentGame) {
                            document.getElementById('overlay').style.display = 'flex';
                        }
                        e.preventDefault();
                        break;
                }
            }

            handleKeyUp(e) {
                // Visual feedback - remove active class from button
                const updateButtonVisuals = (buttonId, isActive) => {
                    const element = document.getElementById(buttonId);
                    if (element) {
                        if (isActive) {
                            element.classList.add('active');
                        } else {
                            element.classList.remove('active');
                        }
                    }
                };

                // Map keyboard keys to buttons
                switch (e.key) {
                    case 'ArrowUp':
                        updateButtonVisuals('d-up', false);
                        this.handleButtonRelease('up');
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        updateButtonVisuals('d-right', false);
                        this.handleButtonRelease('right');
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        updateButtonVisuals('d-down', false);
                        this.handleButtonRelease('down');
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        updateButtonVisuals('d-left', false);
                        this.handleButtonRelease('left');
                        e.preventDefault();
                        break;
                    case 'z':
                    case 'Z':
                        updateButtonVisuals('btn-a', false);
                        this.handleButtonRelease('a');
                        e.preventDefault();
                        break;
                    case 'x':
                    case 'X':
                        updateButtonVisuals('btn-b', false);
                        this.handleButtonRelease('b');
                        e.preventDefault();
                        break;
                    case 'Enter':
                        updateButtonVisuals('btn-start', false);
                        e.preventDefault();
                        break;
                    case 'Shift':
                        updateButtonVisuals('btn-select', false);
                        e.preventDefault();
                        break;
                }
            }

            handleButtonPress(button) {
                if (this.currentGame && this.gameRunning && this.currentGame.handleInput) {
                    this.currentGame.handleInput(button, true);
                }
            }

            handleButtonRelease(button) {
                if (this.currentGame && this.gameRunning && this.currentGame.handleInput) {
                    this.currentGame.handleInput(button, false);
                }
            }

            loadDefaultGames() {
                console.log('Loading default games as fallback');
                
                // Snake Game - Mobile Optimized
                this.gameLibrary['mobile-snake'] = {
                    id: 'mobile-snake',
                    name: 'Snake',
                    description: 'Classic snake game',
                    icon: '🐍',
                    gameData: {
                        backgroundColor: '#8bac0f',
                        snakeColor: '#223344',
                        foodColor: '#e42c64',
                        gridSize: 15
                    },
                    initialize: function(display) {
                        this.display = display;
                        this.canvas = document.createElement('canvas');
                        
                        // Make the canvas fill its container
                        this.canvas.style.width = '100%';
                        this.canvas.style.height = '100%';
                        this.canvas.style.display = 'block';
                        
                        display.appendChild(this.canvas);
                        
                        // Set canvas resolution based on parent container
                        this.resizeGame();
                        
                        this.ctx = this.canvas.getContext('2d');
                        
                        // Game state
                        this.resetGame();
                        
                        // Handle window resize
                        window.addEventListener('resize', () => this.resizeGame());
                        window.addEventListener('orientationchange', () => {
                            setTimeout(() => this.resizeGame(), 300);
                        });
                        
                        this.render();
                    },
                    
                    resizeGame: function() {
                        // Get the display dimensions
                        const displayRect = this.canvas.parentElement.getBoundingClientRect();
                        
                        // Set canvas dimensions to match container size
                        this.canvas.width = displayRect.width;
                        this.canvas.height = displayRect.height;
                        
                        // Calculate cell size to fit the grid
                        this.cellSize = Math.min(
                            Math.floor(this.canvas.width / this.gameData.gridSize),
                            Math.floor(this.canvas.height / this.gameData.gridSize)
                        );
                        
                        // If game was already running, update grid positions
                        if (this.snake && this.food) {
                            this.render();
                        }
                    },
                    
                    resetGame: function() {
                        // Initialize snake
                        this.snake = [
                            { x: Math.floor(this.gameData.gridSize / 2), y: Math.floor(this.gameData.gridSize / 2) }
                        ];
                        
                        // Direction (right, left, up, down)
                        this.direction = 'right';
                        this.nextDirection = 'right';
                        
                        // Initialize food
                        this.food = this.generateFood();
                        
                        // Game state
                        this.score = 0;
                        this.gameOver = false;
                        this.paused = false;
                        
                        // Game speed (ms between moves)
                        this.speed = 200;
                        this.lastMoveTime = 0;
                    },
                    
                    generateFood: function() {
                        // Generate food at random position, not occupied by snake
                        let foodPosition;
                        do {
                            foodPosition = {
                                x: Math.floor(Math.random() * this.gameData.gridSize),
                                y: Math.floor(Math.random() * this.gameData.gridSize)
                            };
                        } while (this.snake.some(segment => 
                            segment.x === foodPosition.x && segment.y === foodPosition.y));
                        
                        return foodPosition;
                    },
                    
                    handleInput: function(button, isPressed) {
                        if (isPressed) {
                            // Change direction
                            switch(button) {
                                case 'up':
                                    if (this.direction !== 'down') this.nextDirection = 'up';
                                    break;
                                case 'right':
                                    if (this.direction !== 'left') this.nextDirection = 'right';
                                    break;
                                case 'down':
                                    if (this.direction !== 'up') this.nextDirection = 'down';
                                    break;
                                case 'left':
                                    if (this.direction !== 'right') this.nextDirection = 'left';
                                    break;
                                case 'a':
                                    if (this.gameOver) {
                                        this.resetGame();
                                    }
                                    break;
                                case 'b':
                                    this.paused = !this.paused;
                                    break;
                            }
                        }
                    },
                    
                    update: function(deltaTime) {
                        if (this.gameOver || this.paused) return;
                        
                        // Update the game at specific intervals
                        this.lastMoveTime += deltaTime;
                        if (this.lastMoveTime < this.speed) return;
                        
                        this.lastMoveTime = 0;
                        
                        // Update direction
                        this.direction = this.nextDirection;
                        
                        // Calculate new head position
                        const head = Object.assign({}, this.snake[0]); // Clone head
                        
                        switch(this.direction) {
                            case 'up': head.y--; break;
                            case 'right': head.x++; break;
                            case 'down': head.y++; break;
                            case 'left': head.x--; break;
                        }
                        
                        // Check for collision with walls
                        if (head.x < 0 || head.x >= this.gameData.gridSize || 
                            head.y < 0 || head.y >= this.gameData.gridSize) {
                            this.gameOver = true;
                            return;
                        }
                        
                        // Check for collision with self
                        if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                            this.gameOver = true;
                            return;
                        }
                        
                        // Add new head
                        this.snake.unshift(head);
                        
                        // Check for food
                        if (head.x === this.food.x && head.y === this.food.y) {
                            // Increment score
                            this.score++;
                            
                            // Generate new food
                            this.food = this.generateFood();
                            
                            // Increase speed slightly (min 80ms)
                            this.speed = Math.max(80, this.speed - 5);
                        } else {
                            // Remove tail
                            this.snake.pop();
                        }
                    },
                    
                    render: function() {
                        // Calculate grid offset to center it
                        const gridWidth = this.gameData.gridSize * this.cellSize;
                        const gridHeight = this.gameData.gridSize * this.cellSize;
                        
                        const offsetX = (this.canvas.width - gridWidth) / 2;
                        const offsetY = (this.canvas.height - gridHeight) / 2;
                        
                        // Clear canvas
                        this.ctx.fillStyle = this.gameData.backgroundColor;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Draw grid background
                        this.ctx.fillStyle = '#a9c246';
                        this.ctx.fillRect(offsetX, offsetY, gridWidth, gridHeight);
                        
                        // Draw snake
                        this.ctx.fillStyle = this.gameData.snakeColor;
                        this.snake.forEach(segment => {
                            this.ctx.fillRect(
                                offsetX + segment.x * this.cellSize, 
                                offsetY + segment.y * this.cellSize, 
                                this.cellSize, this.cellSize
                            );
                        });
                        
                        // Draw food
                        this.ctx.fillStyle = this.gameData.foodColor;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            offsetX + this.food.x * this.cellSize + this.cellSize / 2,
                            offsetY + this.food.y * this.cellSize + this.cellSize / 2,
                            this.cellSize / 2,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.fill();
                        
                        // Draw score
                        this.ctx.fillStyle = 'black';
                        this.ctx.font = 'bold 16px Poppins';
                        this.ctx.textAlign = 'left';
                        this.ctx.textBaseline = 'top';
                        this.ctx.fillText(`SCORE: ${this.score}`, 10, 10);
                        
                        // Draw length
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`LENGTH: ${this.snake.length}`, this.canvas.width / 2, 10);
                        
                        // Draw time/status
                        this.ctx.textAlign = 'right';
                        if (this.paused) {
                            this.ctx.fillText('PAUSED', this.canvas.width - 10, 10);
                        }
                        
                        // Draw game over message
                        if (this.gameOver) {
                            const fontSize = Math.max(16, Math.min(24, this.canvas.width / 15));
                            
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = `bold ${fontSize}px Poppins`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - fontSize);
                            this.ctx.fillText(`SCORE: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2);
                            
                            this.ctx.font = `bold ${fontSize * 0.7}px Poppins`;
                            this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + fontSize * 1.5);
                        }
                    },
                    
                    cleanup: function() {
                        if (this.canvas && this.canvas.parentNode) {
                            this.canvas.parentNode.removeChild(this.canvas);
                        }
                    }
                };

                // Simple Pong Game - Mobile Optimized version
                this.gameLibrary['simple-pong'] = {
                    id: 'simple-pong',
                    name: 'Simple Pong',
                    description: 'Classic ping pong game',
                    icon: '🏓',
                    gameData: {
                        backgroundColor: '#8bac0f',
                        paddleSpeed: 6,
                        initialBallSpeed: 3
                    },
                    initialize: function(display) {
                        this.display = display;
                        this.canvas = document.createElement('canvas');
                        this.canvas.style.width = '100%';
                        this.canvas.style.height = '100%';
                        this.canvas.style.display = 'block';
                        
                        display.appendChild(this.canvas);
                        
                        // Set canvas resolution
                        this.resizeGame();
                        
                        this.ctx = this.canvas.getContext('2d');
                        
                        // Game state
                        this.resetGameState();
                        
                        // Handle window resize
                        window.addEventListener('resize', () => this.resizeGame());
                        window.addEventListener('orientationchange', () => {
                            setTimeout(() => this.resizeGame(), 300);
                        });
                        
                        this.render();
                    },
                    
                    resizeGame: function() {
                        // Get the actual display dimensions
                        const displayRect = this.canvas.parentElement.getBoundingClientRect();
                        
                        // Set canvas resolution
                        this.canvas.width = displayRect.width;
                        this.canvas.height = displayRect.height;
                        
                        // If game was already initialized, update all positions
                        if (this.leftPaddle) {
                            this.resetGameState();
                        }
                    },
                    
                    resetGameState: function() {
                        // Calculate game element dimensions based on canvas size
                        this.paddleWidth = Math.floor(this.canvas.width * 0.03);
                        this.paddleHeight = Math.floor(this.canvas.height * 0.18);
                        this.ballSize = Math.floor(this.canvas.width * 0.03);
                        
                        this.leftPaddle = {
                            x: this.canvas.width * 0.07,
                            y: this.canvas.height / 2 - this.paddleHeight / 2,
                            width: this.paddleWidth,
                            height: this.paddleHeight,
                            dy: 0,
                            score: 0
                        };
                        
                        this.rightPaddle = {
                            x: this.canvas.width * 0.93 - this.paddleWidth,
                            y: this.canvas.height / 2 - this.paddleHeight / 2,
                            width: this.paddleWidth,
                            height: this.paddleHeight,
                            dy: 0,
                            score: 0
                        };
                        
                        this.resetBall();
                        
                        this.gameOver = false;
                        this.winningScore = 5;
                        this.winner = null;
                        
                        // AI control for right paddle
                        this.aiEnabled = true;
                        this.aiReactionTime = 0.05;
                    },
                    
                    resetBall: function() {
                        this.ball = {
                            x: this.canvas.width / 2,
                            y: this.canvas.height / 2,
                            width: this.ballSize,
                            height: this.ballSize,
                            dx: this.gameData.initialBallSpeed * (Math.random() > 0.5 ? 1 : -1),
                            dy: this.gameData.initialBallSpeed * (Math.random() > 0.5 ? 1 : -1) * 0.5
                        };
                    },
                    
                    handleInput: function(button, isPressed) {
                        switch(button) {
                            case 'up':
                                this.leftPaddle.dy = isPressed ? -this.gameData.paddleSpeed : 0;
                                break;
                            case 'down':
                                this.leftPaddle.dy = isPressed ? this.gameData.paddleSpeed : 0;
                                break;
                            case 'a':
                                if (isPressed && this.gameOver) {
                                    this.resetGameState();
                                }
                                break;
                            case 'b':
                                if (isPressed) {
                                    this.aiEnabled = !this.aiEnabled;
                                }
                                break;
                        }
                    },
                    
                    update: function() {
                        if (this.gameOver) return;
                        
                        // Update left paddle position
                        this.leftPaddle.y += this.leftPaddle.dy;
                        
                        // Keep paddle within bounds
                        if (this.leftPaddle.y < 0) {
                            this.leftPaddle.y = 0;
                        } else if (this.leftPaddle.y + this.leftPaddle.height > this.canvas.height) {
                            this.leftPaddle.y = this.canvas.height - this.leftPaddle.height;
                        }
                        
                        // AI for right paddle
                        if (this.aiEnabled) {
                            const targetY = this.ball.y - this.rightPaddle.height / 2;
                            
                            // Add some reaction delay and imperfection to AI
                            if (Math.random() > this.aiReactionTime) {
                                if (targetY < this.rightPaddle.y - 5) {
                                    this.rightPaddle.dy = -this.gameData.paddleSpeed;
                                } else if (targetY > this.rightPaddle.y + 5) {
                                    this.rightPaddle.dy = this.gameData.paddleSpeed;
                                } else {
                                    this.rightPaddle.dy = 0;
                                }
                            }
                        }
                        
                        // Update right paddle position
                        this.rightPaddle.y += this.rightPaddle.dy;
                        
                        // Keep paddle within bounds
                        if (this.rightPaddle.y < 0) {
                            this.rightPaddle.y = 0;
                        } else if (this.rightPaddle.y + this.rightPaddle.height > this.canvas.height) {
                            this.rightPaddle.y = this.canvas.height - this.rightPaddle.height;
                        }
                        
                        // Update ball position
                        this.ball.x += this.ball.dx;
                        this.ball.y += this.ball.dy;
                        
                        // Ball collision with top and bottom
                        if (this.ball.y <= 0 || this.ball.y + this.ball.height >= this.canvas.height) {
                            this.ball.dy = -this.ball.dy;
                            
                            // Ensure it doesn't get stuck at the edge
                            if (this.ball.y <= 0) {
                                this.ball.y = 1;
                            } else {
                                this.ball.y = this.canvas.height - this.ball.height - 1;
                            }
                        }
                        
                        // Ball collision with paddles
                        if (this.checkCollision(this.ball, this.leftPaddle)) {
                            this.ball.dx = Math.abs(this.ball.dx) + 0.2; // Increase speed slightly
                            
                            // Change angle based on where the ball hits the paddle
                            const hitPosition = (this.ball.y - this.leftPaddle.y) / this.leftPaddle.height;
                            this.ball.dy = 5 * (hitPosition - 0.5); // -2.5 to 2.5
                            
                            // Ensure ball doesn't get stuck inside paddle
                            this.ball.x = this.leftPaddle.x + this.leftPaddle.width + 1;
                        }
                        
                        if (this.checkCollision(this.ball, this.rightPaddle)) {
                            this.ball.dx = -Math.abs(this.ball.dx) - 0.2; // Increase speed slightly
                            
                            // Change angle based on where the ball hits the paddle
                            const hitPosition = (this.ball.y - this.rightPaddle.y) / this.rightPaddle.height;
                            this.ball.dy = 5 * (hitPosition - 0.5); // -2.5 to 2.5
                            
                            // Ensure ball doesn't get stuck inside paddle
                            this.ball.x = this.rightPaddle.x - this.ball.width - 1;
                        }
                        
                        // Ball out of bounds - scoring
                        if (this.ball.x < 0) {
                            // Right player scores
                            this.rightPaddle.score++;
                            this.resetBall();
                            
                            if (this.rightPaddle.score >= this.winningScore) {
                                this.gameOver = true;
                                this.winner = 'right';
                            }
                        } else if (this.ball.x + this.ball.width > this.canvas.width) {
                            // Left player scores
                            this.leftPaddle.score++;
                            this.resetBall();
                            
                            if (this.leftPaddle.score >= this.winningScore) {
                                this.gameOver = true;
                                this.winner = 'left';
                            }
                        }
                    },
                    
                    render: function() {
                        // Clear canvas
                        this.ctx.fillStyle = this.gameData.backgroundColor;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Draw center line
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.canvas.width / 2, 0);
                        this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
                        this.ctx.strokeStyle = '#333';
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                        
                        // Draw paddles
                        this.ctx.fillStyle = '#223344';
                        this.ctx.fillRect(this.leftPaddle.x, this.leftPaddle.y, this.leftPaddle.width, this.leftPaddle.height);
                        this.ctx.fillRect(this.rightPaddle.x, this.rightPaddle.y, this.rightPaddle.width, this.rightPaddle.height);
                        
                        // Draw ball
                        this.ctx.fillStyle = '#e42c64';
                        this.ctx.fillRect(this.ball.x, this.ball.y, this.ball.width, this.ball.height);
                        
                        // Calculate font size based on canvas dimensions
                        const scoreFontSize = Math.max(16, Math.floor(this.canvas.width * 0.05));
                        const smallFontSize = Math.max(8, Math.floor(this.canvas.width * 0.025));
                        
                        // Draw scores
                        this.ctx.fillStyle = '#333';
                        this.ctx.font = `${scoreFontSize}px "Press Start 2P"`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'top';
                        this.ctx.fillText(this.leftPaddle.score.toString(), this.canvas.width / 4, 10);
                        this.ctx.fillText(this.rightPaddle.score.toString(), 3 * this.canvas.width / 4, 10);
                        
                        // Draw AI status
                        this.ctx.font = `${smallFontSize}px "Press Start 2P"`;
                        this.ctx.fillText(this.aiEnabled ? "AI: ON" : "AI: OFF", this.canvas.width / 2, this.canvas.height - 25);
                        
                        // Draw touch controls reminder
                        this.ctx.font = `${Math.floor(smallFontSize * 0.8)}px "Press Start 2P"`;
                        this.ctx.fillText("SWIPE UP/DOWN", this.canvas.width / 2, this.canvas.height - 45);
                        
                        // Draw game over message if game is over
                        if (this.gameOver) {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = `${Math.max(16, this.canvas.width * 0.04)}px "Press Start 2P"`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            
                            const winnerText = this.winner === 'left' ? "YOU WIN!" : "AI WINS!";
                            this.ctx.fillText(winnerText, this.canvas.width / 2, this.canvas.height / 2 - 20);
                            
                            this.ctx.font = `${Math.max(10, this.canvas.width * 0.025)}px "Press Start 2P"`;
                            this.ctx.fillText("PRESS A TO RESTART", this.canvas.width / 2, this.canvas.height / 2 + 20);
                        }
                    },
                    
                    checkCollision: function(rect1, rect2) {
                        return rect1.x < rect2.x + rect2.width &&
                               rect1.x + rect1.width > rect2.x &&
                               rect1.y < rect2.y + rect2.height &&
                               rect1.y + rect1.height > rect2.y;
                    },
                    
                    cleanup: function() {
                        if (this.canvas && this.canvas.parentNode) {
                            this.canvas.parentNode.removeChild(this.canvas);
                        }
                    }
                };
            }

            displayMainMenu() {
                // Clear the game display
                this.gameDisplay.innerHTML = '';
                
                // Create menu content
                const menuContent = document.createElement('div');
                menuContent.style.width = '100%';
                menuContent.style.height = '100%';
                menuContent.style.display = 'flex';
                menuContent.style.flexDirection = 'column';
                menuContent.style.justifyContent = 'center';
                menuContent.style.alignItems = 'center';
                menuContent.style.color = 'black';
                menuContent.style.textAlign = 'center';
                menuContent.style.fontFamily = '"Press Start 2P", cursive';
                menuContent.style.padding = '20px';
                
                menuContent.innerHTML = `
                    <h2 style="font-size: 24px; margin-bottom: 30px;">RetroPlay</h2>
                    <p style="font-size: 14px; margin-bottom: 15px;">Press START to open games</p>
                    <p style="font-size: 14px;">Use D-Pad to navigate</p>
                    <div style="margin-top: 40px; font-size: 60px;">🎮</div>
                `;
                
                this.gameDisplay.appendChild(menuContent);
            }

            loadGameList() {
                const gamesGrid = document.getElementById('games-grid');
                gamesGrid.innerHTML = '';
                
                Object.values(this.gameLibrary).forEach(game => {
                    const gameCard = document.createElement('div');
                    gameCard.className = 'game-card';
                    gameCard.dataset.gameId = game.id;
                    
                    gameCard.innerHTML = `
                        <div class="game-icon">${game.icon || '🎮'}</div>
                        <div class="game-name">${game.name}</div>
                        <div class="game-description">${game.description}</div>
                    `;
                    
                    gameCard.addEventListener('click', () => {
                        this.loadGame(game.id);
                        document.getElementById('game-menu').style.display = 'none';
                    });
                    
                    gamesGrid.appendChild(gameCard);
                });
            }

            loadGame(gameId) {
                // Stop any current game
                if (this.currentGame) {
                    clearInterval(this.gameLoop);
                    this.gameRunning = false;
                    
                    if (this.currentGame.cleanup) {
                        this.currentGame.cleanup();
                    }
                }
                
                // Clear the display
                this.gameDisplay.innerHTML = '';
                
                // Initialize the new game
                this.currentGame = this.gameLibrary[gameId];
                if (this.currentGame) {
                    this.currentGame.initialize(this.gameDisplay);
                    
                    let lastTime = performance.now();
                    this.gameRunning = true;
                    
                    // Set up game loop
                    this.gameLoop = setInterval(() => {
                        const currentTime = performance.now();
                        const deltaTime = currentTime - lastTime;
                        
                        if (this.currentGame.update) {
                            this.currentGame.update(deltaTime);
                        }
                        
                        if (this.currentGame.render) {
                            this.currentGame.render();
                        }
                        
                        lastTime = currentTime;
                    }, 1000 / 60); // 60 FPS
                }
            }

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameData = JSON.parse(e.target.result);
                        const game = this.processGameData(gameData);
                        
                        if (game) {
                            // Add the game to the library
                            this.gameLibrary[game.id] = game;
                            
                            // Refresh the game list
                            this.loadGameList();
                            
                            alert(`Game "${game.name}" has been loaded successfully!`);
                        } else {
                            alert('Invalid game format. Please try a different file.');
                        }
                    } catch (error) {
                        alert(`Error loading game: ${error.message}`);
                        console.error(error);
                    }
                };
                
                reader.readAsText(file);
                
                // Reset the input value so the same file can be loaded again if needed
                event.target.value = '';
            }

            exportCurrentGame() {
                if (!this.currentGame) return;
                
                // Create a full copy of the game object including all functionality
                const gameExport = {
                    id: this.currentGame.id,
                    name: this.currentGame.name,
                    description: this.currentGame.description,
                    icon: this.currentGame.icon,
                    gameData: this.currentGame.gameData,
                    
                    // Serialize game logic functions as strings
                    initializeCode: this.currentGame.initialize.toString(),
                    updateCode: this.currentGame.update ? this.currentGame.update.toString() : null,
                    renderCode: this.currentGame.render ? this.currentGame.render.toString() : null,
                    handleInputCode: this.currentGame.handleInput ? this.currentGame.handleInput.toString() : null,
                    cleanupCode: this.currentGame.cleanup ? this.currentGame.cleanup.toString() : null,
                    
                    // Additional game-specific functions, also serialized as strings
                    additionalFunctions: {}
                };
                
                // Extract any additional functions from the game
                for (const key in this.currentGame) {
                    if (typeof this.currentGame[key] === 'function' && 
                        !['initialize', 'update', 'render', 'handleInput', 'cleanup'].includes(key)) {
                        gameExport.additionalFunctions[key] = this.currentGame[key].toString();
                    }
                }
                
                // Convert to JSON
                const gameJson = JSON.stringify(gameExport, null, 2);
                
                // Create a downloadable file
                const blob = new Blob([gameJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create a link and trigger the download
                const a = document.createElement('a');
                a.href = url;
                a.download = `${gameExport.id}.json`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // Preloaded GitHub game files - representing the game cartridges available in the repo
        const PRELOADED_GAMES = [
            {
                name: "snake-2.0-complete.json",
                path: "snake-2.0-complete.json",
                raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/snake-2.0-complete.json`
            },
            {
                name: "tetris-game.json",
                path: "tetris-game.json",
                raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/tetris-game.json`
            },
            {
                name: "breakout-game.json",
                path: "breakout-game.json",
                raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/breakout-game.json`
            },
            {
                name: "flappy-bird.json", 
                path: "flappy-bird.json",
                raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/flappy-bird.json`
            },
            {
                name: "space-invaders.json",
                path: "space-invaders.json",
                raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/space-invaders.json`
            }
        ];

        // Add method to RetroConsole prototype to load GitHub file list
        RetroConsole.prototype.loadGitHubFiles = function() {
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            
            // Use the preloaded list of game files
            PRELOADED_GAMES.forEach(file => {
                const listItem = document.createElement('li');
                
                listItem.innerHTML = `
                    <div class="file-link" data-raw-url="${file.raw_url}" data-path="${file.path}">
                        ${file.name}
                    </div>
                `;
                
                listItem.querySelector('.file-link').addEventListener('click', async () => {
                    await this.loadGameFromGitHub(file.raw_url, file.name);
                });
                
                fileList.appendChild(listItem);
            });
        };

        // Initialize the RetroConsole on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Prevent browser overscroll behavior
            document.body.addEventListener('touchmove', function(e) {
                if (e.target.closest('.games-grid, .file-list') === null) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent double tap to zoom
            document.addEventListener('touchend', function(e) {
                const now = Date.now();
                const lastTouch = this.lastTouch || now + 1;
                const delta = now - lastTouch;
                if (delta < 500 && delta > 0) {
                    e.preventDefault();
                }
                this.lastTouch = now;
            }, { passive: false });
            
            // Initialize console
            const retroConsole = new RetroConsole();
            
            // On initial load and orientation change, scroll to top
            window.scrollTo(0, 0);
            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    window.scrollTo(0, 0);
                }, 100);
            });
        });
    </script>
</body>
</html>