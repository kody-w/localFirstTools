<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RetroPlay Console</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Poppins:wght@400;600&display=swap');

        :root {
            --console-color: #8ca5ac;
            --console-dark: #566366;
            --console-light: #b8c7cc;
            --screen-color: #8bac0f;
            --button-color: #2f3335;
            --button-shadow: #1a1c1d;
            --accent-color: #e42c64;
            --text-color: #181c1f;
            --menu-bg: rgba(240, 240, 240, 0.95);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #e0e8ec, #c4d4db);
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            overflow: hidden;
            color: var(--text-color);
            touch-action: manipulation;
            position: fixed;
        }

        .mobile-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
        }

        .retro-console {
            position: relative;
            width: 100%;
            max-width: 400px;
            background-color: var(--console-color);
            border-radius: 12px 12px 30px 12px;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.3),
                inset 0 -5px 20px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 0 0 auto;
        }

        .brand-name {
            position: absolute;
            top: 10px;
            left: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--console-dark);
            letter-spacing: -0.5px;
        }

        .brand-logo {
            position: absolute;
            top: 26px;
            left: 22px;
            width: 50px;
            height: 8px;
            background: var(--console-dark);
            border-radius: 4px;
        }

        .screen-container {
            position: relative;
            width: 100%;
            aspect-ratio: 10/9;
            margin-top: 40px;
            background-color: var(--console-dark);
            border-radius: 8px 8px 20px 8px;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .power-indicator {
            position: absolute;
            top: 10px;
            left: 15px;
            width: 8px;
            height: 8px;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 5px var(--accent-color);
        }

        .power-text {
            position: absolute;
            top: 9px;
            left: 26px;
            font-size: 8px;
            color: var(--console-light);
        }

        .game-screen {
            width: 100%;
            height: 100%;
            background-color: var(--screen-color);
            border: 4px solid var(--text-color);
            border-radius: 3px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .screen-content {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .controls-container {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            max-width: 400px;
            padding: 0 10px;
        }

        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .d-pad-button {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: var(--button-color);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            color: white;
            font-size: 18px;
        }

        .d-pad-center {
            top: 40px;
            left: 40px;
            width: 40px;
            height: 40px;
            background-color: var(--button-color);
            border-radius: 5px;
            z-index: 0;
        }

        .d-pad-up {
            top: 0;
            left: 40px;
        }

        .d-pad-right {
            top: 40px;
            right: 0;
        }

        .d-pad-down {
            bottom: 0;
            left: 40px;
        }

        .d-pad-left {
            top: 40px;
            left: 0;
        }

        .d-pad-button:active,
        .d-pad-button.active {
            background-color: #444;
            transform: scale(0.95);
        }

        .action-buttons {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .action-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: var(--accent-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            user-select: none;
        }

        .button-a {
            top: 15px;
            right: 0;
        }

        .button-b {
            bottom: 15px;
            left: 0;
        }

        .action-button:active,
        .action-button.active {
            background-color: #c92554;
            transform: scale(0.95);
        }

        .start-select-buttons {
            position: absolute;
            bottom: 10px;
            width: 100%;
            height: 40px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .system-button {
            width: 80px;
            height: 20px;
            background-color: var(--button-color);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #fff;
        }

        .system-button:active,
        .system-button.active {
            background-color: #444;
            transform: scale(0.95);
        }

        .game-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--menu-bg);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }

        .menu-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .menu-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            color: var(--text-color);
        }

        .close-menu {
            font-size: 24px;
            color: var(--text-color);
            background: none;
            border: none;
            padding: 10px;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 800px;
        }

        .game-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .game-card:active {
            transform: translateY(-2px);
            box-shadow: 0 5px 8px rgba(0, 0, 0, 0.15);
        }

        .game-icon {
            width: 60px;
            height: 60px;
            background-color: #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-size: 36px;
        }

        .game-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-align: center;
            margin-bottom: 8px;
        }

        .game-description {
            font-size: 12px;
            text-align: center;
            color: #666;
        }

        .app-store-section {
            width: 100%;
            max-width: 800px;
            margin-top: 20px;
            border-top: 2px solid #ddd;
            padding-top: 20px;
        }

        .store-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .upload-game {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
        }

        .upload-game:active {
            background-color: #c92554;
        }

        .file-input {
            display: none;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            width: 300px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 20px;
        }

        .modal-content {
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
        }

        .confirm-button {
            background-color: var(--accent-color);
            color: white;
        }

        .cancel-button {
            background-color: #ddd;
        }

        .github-browser {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--menu-bg);
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
            z-index: 1500;
        }
        
        .browser-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            max-width: 800px;
        }
        
        .repo-info {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
            width: 100%;
            max-width: 800px;
        }
        
        .file-list {
            list-style-type: none;
            padding: 0;
            width: 100%;
            max-width: 800px;
        }
        
        .file-list li {
            margin-bottom: 10px;
        }
        
        .file-link {
            display: block;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
            color: #333;
            text-decoration: none;
        }
        
        .file-link:active {
            background-color: #e8e8e8;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 3000;
        }

        .loading-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }

        .keyboard-controls {
            display: none; /* Hide keyboard controls on mobile */
        }

        .repository-link {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: var(--accent-color);
            border-radius: 5px;
            color: white;
            text-decoration: none;
            font-size: 12px;
            z-index: 100;
        }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .browse-github {
            background-color: #333;
            margin-top: 10px;
            width: 100%;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Orientation check */
        @media screen and (max-height: 500px) and (orientation: landscape) {
            .mobile-container {
                flex-direction: row;
                padding: 5px;
            }
            
            .retro-console {
                height: 100%;
                width: 40%;
                max-width: none;
                padding: 10px;
                border-radius: 12px;
            }
            
            .screen-container {
                margin-top: 30px;
                aspect-ratio: auto;
                height: calc(100% - 40px);
            }
            
            .controls-container {
                height: 100%;
                width: 60%;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                margin-top: 0;
                gap: 10px;
            }
            
            .start-select-buttons {
                position: relative;
                bottom: auto;
                margin-top: 10px;
            }
        }
        
        /* Prevent text selection */
        body, button, .d-pad-button, .action-button, .system-button {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Fullscreen mode */
        .fullscreen-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 5px;
            width: 36px;
            height: 36px;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body ontouchstart="">
    <div class="loading-screen" id="loading-screen">
        <div class="loading-text">LOADING GAMES</div>
        <div class="loading-spinner"></div>
    </div>

    <button class="fullscreen-button" id="fullscreen-button">â›¶</button>

    <div class="mobile-container">
        <div class="retro-console">
            <div class="brand-name">RetroPlay</div>
            <div class="brand-logo"></div>
            <div class="screen-container">
                <div class="power-indicator"></div>
                <div class="power-text">POWER</div>
                <div class="game-screen">
                    <div class="screen-content" id="game-display">
                        <!-- Game will be displayed here -->
                    </div>
                </div>
            </div>
            <div class="start-select-buttons">
                <div class="system-button" id="btn-select">SELECT</div>
                <div class="system-button" id="btn-start">START</div>
            </div>
        </div>

        <div class="controls-container">
            <div class="d-pad">
                <div class="d-pad-center"></div>
                <div class="d-pad-button d-pad-up" id="d-up">â–²</div>
                <div class="d-pad-button d-pad-right" id="d-right">â–¶</div>
                <div class="d-pad-button d-pad-down" id="d-down">â–¼</div>
                <div class="d-pad-button d-pad-left" id="d-left">â—€</div>
            </div>
            <div class="action-buttons">
                <div class="action-button button-a" id="btn-a">A</div>
                <div class="action-button button-b" id="btn-b">B</div>
            </div>
        </div>
    </div>

    <div class="game-menu" id="game-menu">
        <div class="menu-header">
            <h1 class="menu-title">RetroPlay Store</h1>
            <button class="close-menu" id="close-menu">âœ•</button>
        </div>
        <div class="games-grid" id="games-grid">
            <!-- Games will be inserted here -->
        </div>
        <div class="app-store-section">
            <div class="store-header">
                <h2 class="menu-title">Add Games</h2>
                <div class="button-container">
                    <button class="upload-game" id="upload-game-btn">+ Upload Game</button>
                    <button class="upload-game browse-github" id="browse-github-btn">Browse GitHub</button>
                </div>
                <input type="file" id="file-input" class="file-input" accept=".json">
            </div>
        </div>
    </div>

    <div class="github-browser" id="github-browser">
        <div class="browser-header">
            <h1 class="menu-title">GitHub Browser</h1>
            <button class="close-menu" id="close-github">âœ•</button>
        </div>
        <div class="repo-info" id="repo-info">
            <h2>kody-w/localFirstTools</h2>
            <p>Browse JSON game files</p>
        </div>
        <ul class="file-list" id="file-list">
            <!-- Files will be listed here -->
            <li><div class="loading">Loading repository files...</div></li>
        </ul>
    </div>

    <div class="overlay" id="overlay">
        <div class="modal" id="modal">
            <div class="modal-header">
                <h3>Export Game</h3>
                <button class="close-modal" id="close-modal">âœ•</button>
            </div>
            <div class="modal-content">
                <p>Do you want to export the current game as a JSON file?</p>
            </div>
            <div class="modal-actions">
                <button class="modal-button cancel-button" id="cancel-export">Cancel</button>
                <button class="modal-button confirm-button" id="confirm-export">Export</button>
            </div>
        </div>
    </div>

    <script>
        // Main System Class
        class RetroConsole {
            constructor() {
                // GitHub repository information
                this.REPO_OWNER = 'kody-w';
                this.REPO_NAME = 'localFirstTools';
                this.BRANCH = 'main';
                
                this.gameLibrary = {};
                this.currentGame = null;
                this.gameRunning = false;
                this.gameLoop = null;
                this.gameDisplay = document.getElementById('game-display');
                this.setupEventListeners();
                
                // Initialize loading screen
                this.loadingScreen = document.getElementById('loading-screen');
                
                // Show loading screen briefly while loading default games
                this.loadingScreen.style.display = 'flex';
                
                // Load only default games on startup - no GitHub fetching
                setTimeout(() => {
                    this.loadDefaultGames();
                    this.loadingScreen.style.display = 'none';
                    this.displayMainMenu();
                }, 500); // Brief delay for loading animation
                
                // Handle fullscreen
                this.setupFullscreenSupport();
            }
            
            setupFullscreenSupport() {
                const fullscreenButton = document.getElementById('fullscreen-button');
                fullscreenButton.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.error(`Error attempting to enable fullscreen: ${err.message}`);
                        });
                        fullscreenButton.textContent = "â¤“";
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                            fullscreenButton.textContent = "â›¶";
                        }
                    }
                });
                
                // Update button icon when fullscreen changes
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) {
                        fullscreenButton.textContent = "â¤“";
                    } else {
                        fullscreenButton.textContent = "â›¶";
                    }
                });
                
                // Lock screen orientation if supported
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        screen.orientation.lock('portrait').catch(e => {
                            console.log('Orientation lock not supported on this device');
                        });
                    } catch (e) {
                        console.log('Orientation API not fully supported');
                    }
                }
            }

            setupEventListeners() {
                // Menu Controls
                document.getElementById('btn-start').addEventListener('click', () => {
                    document.getElementById('game-menu').style.display = 'flex';
                    this.loadGameList();
                });
                
                document.getElementById('close-menu').addEventListener('click', () => {
                    document.getElementById('game-menu').style.display = 'none';
                });

                // GitHub Browser
                document.getElementById('browse-github-btn').addEventListener('click', () => {
                    document.getElementById('github-browser').style.display = 'flex';
                    
                    // Show loading indication in the file list
                    const fileList = document.getElementById('file-list');
                    fileList.innerHTML = '<li><div class="loading">Loading repository files...</div></li>';
                    
                    // Now fetch GitHub games when this button is clicked
                    this.fetchAndLoadGames(true).then(() => {
                        // After successful fetch, load the GitHub files listing
                        this.loadGitHubFiles();
                    }).catch(error => {
                        console.error('Error fetching games from GitHub:', error);
                        fileList.innerHTML = '<li><div class="error-message">Failed to load games from GitHub. Please try again later.</div></li>';
                    });
                });
                
                document.getElementById('close-github').addEventListener('click', () => {
                    document.getElementById('github-browser').style.display = 'none';
                });

                // Upload Game
                document.getElementById('upload-game-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                
                document.getElementById('file-input').addEventListener('change', (event) => {
                    this.handleFileUpload(event);
                });

                // Export Game
                document.getElementById('btn-select').addEventListener('click', () => {
                    if (this.currentGame) {
                        document.getElementById('overlay').style.display = 'flex';
                    }
                });
                
                document.getElementById('close-modal').addEventListener('click', () => {
                    document.getElementById('overlay').style.display = 'none';
                });
                
                document.getElementById('cancel-export').addEventListener('click', () => {
                    document.getElementById('overlay').style.display = 'none';
                });
                
                document.getElementById('confirm-export').addEventListener('click', () => {
                    this.exportCurrentGame();
                    document.getElementById('overlay').style.display = 'none';
                });

                // Game Controls - Touch controls
                const controls = {
                    up: document.getElementById('d-up'),
                    right: document.getElementById('d-right'),
                    down: document.getElementById('d-down'),
                    left: document.getElementById('d-left'),
                    a: document.getElementById('btn-a'),
                    b: document.getElementById('btn-b')
                };

                // Improved mobile touch controls
                Object.entries(controls).forEach(([key, element]) => {
                    // Touch events with better handling
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.handleButtonPress(key);
                        element.classList.add('active');
                    }, { passive: false });
                    
                    element.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.handleButtonRelease(key);
                        element.classList.remove('active');
                    }, { passive: false });
                    
                    element.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        this.handleButtonRelease(key);
                        element.classList.remove('active');
                    }, { passive: false });
                    
                    // Mouse events as fallback
                    element.addEventListener('mousedown', () => {
                        this.handleButtonPress(key);
                        element.classList.add('active');
                    });
                    
                    element.addEventListener('mouseup', () => {
                        this.handleButtonRelease(key);
                        element.classList.remove('active');
                    });
                    
                    element.addEventListener('mouseleave', () => {
                        this.handleButtonRelease(key);
                        element.classList.remove('active');
                    });
                });

                // Add keyboard event listeners for testing on desktop
                document.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });
                
                document.addEventListener('keyup', (e) => {
                    this.handleKeyUp(e);
                });
                
                // Prevent page scrolling when touching game controls
                document.querySelectorAll('.d-pad-button, .action-button, .system-button').forEach(button => {
                    button.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                    }, { passive: false });
                });
                
                // Prevent context menu on long press
                document.addEventListener('contextmenu', (e) => {
                    if (e.target.closest('.d-pad-button, .action-button, .system-button, .game-card, .file-link')) {
                        e.preventDefault();
                        return false;
                    }
                });
            }

async fetchAndLoadGames(forGitHubBrowser = false) {
    try {
        // First, specifically check for snake-2.0-complete.json
        try {
            const snakeGameUrl = `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/snake-2.0-complete.json`;
            const snakeGameResponse = await fetch(snakeGameUrl);
            
            if (snakeGameResponse.ok) {
                console.log('Found snake-2.0-complete.json, loading...');
                const gameData = await snakeGameResponse.json();
                const game = this.processGameData(gameData);
                if (game) {
                    this.gameLibrary[game.id] = game;
                    console.log(`Successfully loaded snake game: ${game.name}`);
                }
            }
        } catch (error) {
            console.error('Error loading snake-2.0-complete.json:', error);
        }

// GitHub API URL for repository contents (to get all files in root directory)
const apiUrl = `https://api.github.com/repos/${this.REPO_OWNER}/${this.REPO_NAME}/contents?ref=${this.BRANCH}`;

// Fetch the repository contents
const response = await fetch(apiUrl);

if (!response.ok) {
    throw new Error(`GitHub API error: ${response.status}`);
}

const contents = await response.json();

// Filter for JSON files (potential game cartridges)
const jsonFiles = contents.filter(item => 
    item.type === 'file' && 
    item.name.endsWith('.json') && 
    item.name !== 'snake-2.0-complete.json' && // Skip snake game if already loaded
    !item.name.startsWith('.')
);

console.log(`Found ${jsonFiles.length} potential game cartridges`);

// Load each game cartridge
for (const file of jsonFiles) {
    try {
        const fileUrl = `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/${file.name}`;
        const gameResponse = await fetch(fileUrl);
        
        if (!gameResponse.ok) {
            console.error(`Error fetching game cartridge ${file.name}: ${gameResponse.status}`);
            continue;
        }
        
        const gameData = await gameResponse.json();
        const game = this.processGameData(gameData);
        
        if (game) {
            this.gameLibrary[game.id] = game;
            console.log(`Successfully loaded game: ${game.name}`);
        }
        
    } catch (error) {
        console.error(`Error processing game cartridge ${file.name}:`, error);
    }
}

const loadedGamesCount = Object.keys(this.gameLibrary).length;
console.log(`Successfully loaded ${loadedGamesCount} games in total`);

// If no valid games were loaded, fall back to default games
if (loadedGamesCount === 0 && !forGitHubBrowser) {
    console.log('No valid game cartridges found. Loading default games.');
    this.loadDefaultGames();
}

// If we're only fetching for GitHub browser, we're done
if (forGitHubBrowser) {
    return;
}

} catch (error) {
console.error('Error fetching repository contents:', error);
// Fall back to default games if there's an error
if (!forGitHubBrowser) {
    this.loadDefaultGames();
}
throw error;
}
}

// Process game data from JSON and convert it to a playable game object
processGameData(gameData) {
try {
// Validate that it has the minimum required properties
if (!gameData.id || !gameData.name || !gameData.gameData || !gameData.initializeCode) {
    console.error(`Invalid game cartridge: Missing required properties`);
    return null;
}

// Reconstruct the game object from serialized functions
const game = {
    id: gameData.id,
    name: gameData.name,
    description: gameData.description || "No description provided",
    icon: gameData.icon || "ðŸŽ®",
    gameData: gameData.gameData,
    
    // Convert function strings back to actual functions
    initialize: new Function('return ' + gameData.initializeCode)(),
    update: gameData.updateCode ? new Function('return ' + gameData.updateCode)() : null,
    render: gameData.renderCode ? new Function('return ' + gameData.renderCode)() : null,
    handleInput: gameData.handleInputCode ? new Function('return ' + gameData.handleInputCode)() : null,
    cleanup: gameData.cleanupCode ? new Function('return ' + gameData.cleanupCode)() : null
};

// Add any additional functions
if (gameData.additionalFunctions) {
    for (const key in gameData.additionalFunctions) {
        try {
            game[key] = new Function('return ' + gameData.additionalFunctions[key])();
        } catch (error) {
            console.error(`Error processing additional function '${key}':`, error);
        }
    }
}

return game;
} catch (error) {
console.error('Error processing game cartridge:', error);
return null;
}
}

// Load GitHub Files for browser - simplified for mobile
async loadGitHubFiles() {
const fileList = document.getElementById('file-list');
fileList.innerHTML = '<li><div class="loading">Loading repository files...</div></li>';

try {
// Use preloaded game files instead of API call for better mobile performance
const PRELOADED_GAMES = [
    {
        name: "snake-2.0-complete.json",
        path: "snake-2.0-complete.json",
        raw_url: `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/snake-2.0-complete.json`
    },
    {
        name: "tetris-game.json",
        path: "tetris-game.json",
        raw_url: `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/tetris-game.json`
    },
    {
        name: "breakout-game.json",
        path: "breakout-game.json",
        raw_url: `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/breakout-game.json`
    },
    {
        name: "flappy-bird.json", 
        path: "flappy-bird.json",
        raw_url: `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/flappy-bird.json`
    },
    {
        name: "space-invaders.json",
        path: "space-invaders.json",
        raw_url: `https://raw.githubusercontent.com/${this.REPO_OWNER}/${this.REPO_NAME}/${this.BRANCH}/space-invaders.json`
    }
];

// Display files
if (PRELOADED_GAMES.length > 0) {
    fileList.innerHTML = '';
    
    PRELOADED_GAMES.forEach(file => {
        const listItem = document.createElement('li');
        
        listItem.innerHTML = `
            <div class="file-link" data-raw-url="${file.raw_url}" data-path="${file.path}">
                ${file.name}
            </div>
        `;
        
        listItem.querySelector('.file-link').addEventListener('click', async () => {
            this.loadingScreen.style.display = 'flex';
            await this.loadGameFromGitHub(file.raw_url, file.name);
        });
        
        fileList.appendChild(listItem);
    });
} else {
    fileList.innerHTML = '<li><div class="error-message">No JSON game files found in the repository.</div></li>';
}

} catch (error) {
console.error("Error loading repository:", error);
fileList.innerHTML = `
    <li>
        <div class="error-message">
            <strong>Error:</strong> ${error.message}
        </div>
        <p>Could not load repository data.</p>
    </li>
`;
}
}

// Load game from GitHub
async loadGameFromGitHub(url, fileName) {
try {
// Fetch the JSON content
const response = await fetch(url);
if (!response.ok) {
    throw new Error(`Failed to fetch game (${response.status})`);
}

const gameData = await response.json();

// Process the game data
const game = this.processGameData(gameData);

if (game) {
    // Add to library
    this.gameLibrary[game.id] = game;
    
    // Close GitHub browser
    document.getElementById('github-browser').style.display = 'none';
    
    // Close game menu if open
    document.getElementById('game-menu').style.display = 'none';
    
    // Hide loading screen
    this.loadingScreen.style.display = 'none';
    
    // Load the game
    this.loadGame(game.id);
    
    console.log(`Successfully loaded game from GitHub: ${game.name}`);
} else {
    throw new Error('Invalid game cartridge format');
}
} catch (error) {
console.error('Error loading game from GitHub:', error);
this.loadingScreen.style.display = 'none';
alert(`Error loading game: ${error.message}`);
}
}

handleKeyDown(e) {
// Visual feedback - add active class to button
const updateButtonVisuals = (buttonId, isActive) => {
const element = document.getElementById(buttonId);
if (element) {
    if (isActive) {
        element.classList.add('active');
    } else {
        element.classList.remove('active');
    }
}
};

// Map keyboard keys to buttons
switch (e.key) {
case 'ArrowUp':
    updateButtonVisuals('d-up', true);
    this.handleButtonPress('up');
    e.preventDefault();
    break;
case 'ArrowRight':
    updateButtonVisuals('d-right', true);
    this.handleButtonPress('right');
    e.preventDefault();
    break;
case 'ArrowDown':
    updateButtonVisuals('d-down', true);
    this.handleButtonPress('down');
    e.preventDefault();
    break;
case 'ArrowLeft':
    updateButtonVisuals('d-left', true);
    this.handleButtonPress('left');
    e.preventDefault();
    break;
case 'z':
case 'Z':
    updateButtonVisuals('btn-a', true);
    this.handleButtonPress('a');
    e.preventDefault();
    break;
case 'x':
case 'X':
    updateButtonVisuals('btn-b', true);
    this.handleButtonPress('b');
    e.preventDefault();
    break;
case 'Enter':
    updateButtonVisuals('btn-start', true);
    document.getElementById('game-menu').style.display = 'flex';
    this.loadGameList();
    e.preventDefault();
    break;
case 'Shift':
    updateButtonVisuals('btn-select', true);
    if (this.currentGame) {
        document.getElementById('overlay').style.display = 'flex';
    }
    e.preventDefault();
    break;
}
}

handleKeyUp(e) {
// Visual feedback - remove active class from button
const updateButtonVisuals = (buttonId, isActive) => {
const element = document.getElementById(buttonId);
if (element) {
    if (isActive) {
        element.classList.add('active');
    } else {
        element.classList.remove('active');
    }
}
};

// Map keyboard keys to buttons
switch (e.key) {
case 'ArrowUp':
    updateButtonVisuals('d-up', false);
    this.handleButtonRelease('up');
    e.preventDefault();
    break;
case 'ArrowRight':
    updateButtonVisuals('d-right', false);
    this.handleButtonRelease('right');
    e.preventDefault();
    break;
case 'ArrowDown':
    updateButtonVisuals('d-down', false);
    this.handleButtonRelease('down');
    e.preventDefault();
    break;
case 'ArrowLeft':
    updateButtonVisuals('d-left', false);
    this.handleButtonRelease('left');
    e.preventDefault();
    break;
case 'z':
case 'Z':
    updateButtonVisuals('btn-a', false);
    this.handleButtonRelease('a');
    e.preventDefault();
    break;
case 'x':
case 'X':
    updateButtonVisuals('btn-b', false);
    this.handleButtonRelease('b');
    e.preventDefault();
    break;
case 'Enter':
    updateButtonVisuals('btn-start', false);
    e.preventDefault();
    break;
case 'Shift':
    updateButtonVisuals('btn-select', false);
    e.preventDefault();
    break;
}
}

handleButtonPress(button) {
if (this.currentGame && this.gameRunning && this.currentGame.handleInput) {
this.currentGame.handleInput(button, true);
}
}

handleButtonRelease(button) {
if (this.currentGame && this.gameRunning && this.currentGame.handleInput) {
this.currentGame.handleInput(button, false);
}
}

loadDefaultGames() {
console.log('Loading default games as fallback');

// Simple Pong Game - Mobile optimized
this.gameLibrary['simple-pong'] = {
id: 'simple-pong',
name: 'Simple Pong',
description: 'Classic ping pong game',
icon: 'ðŸ“',
gameData: {
    width: 280,
    height: 248,
    paddleWidth: 10,
    paddleHeight: 50,
    ballSize: 8,
    paddleSpeed: 5,
    initialBallSpeed: 3,
    backgroundColor: '#8bac0f'
},
initialize: function(display) {
    this.display = display;
    this.canvas = document.createElement('canvas');
    
    // Make canvas responsive to container size
    const updateCanvasSize = () => {
        const container = display.getBoundingClientRect();
        const aspectRatio = this.gameData.width / this.gameData.height;
        
        if (container.width / container.height > aspectRatio) {
            // Container is wider than needed
            this.canvas.height = container.height;
            this.canvas.width = container.height * aspectRatio;
        } else {
            // Container is taller than needed
            this.canvas.width = container.width;
            this.canvas.height = container.width / aspectRatio;
        }
        
        // Update scaling factors for input handling
        this.scaleX = this.canvas.width / this.gameData.width;
        this.scaleY = this.canvas.height / this.gameData.height;
        
        // Render after resize
        if (this.gameInitialized) {
            this.render();
        }
    };
    
    // Set initial canvas size
    updateCanvasSize();
    
    // Add resize listener
    window.addEventListener('resize', updateCanvasSize);
    this.resizeListener = updateCanvasSize;
    
    display.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    
    // Game state
    this.leftPaddle = {
        x: 20,
        y: this.gameData.height / 2 - this.gameData.paddleHeight / 2,
        width: this.gameData.paddleWidth,
        height: this.gameData.paddleHeight,
        dy: 0,
        score: 0
    };
    
    this.rightPaddle = {
        x: this.gameData.width - 20 - this.gameData.paddleWidth,
        y: this.gameData.height / 2 - this.gameData.paddleHeight / 2,
        width: this.gameData.paddleWidth,
        height: this.gameData.paddleHeight,
        dy: 0,
        score: 0
    };
    
    this.ball = {
        x: this.gameData.width / 2,
        y: this.gameData.height / 2,
        width: this.gameData.ballSize,
        height: this.gameData.ballSize,
        dx: this.gameData.initialBallSpeed * (Math.random() > 0.5 ? 1 : -1),
        dy: this.gameData.initialBallSpeed * (Math.random() > 0.5 ? 1 : -1)
    };
    
    this.gameOver = false;
    this.winningScore = 5;
    this.winner = null;
    
    // AI control for right paddle (single player mode)
    this.aiEnabled = true;
    this.aiReactionTime = 0.05; // Lower is faster reaction
    
    this.gameInitialized = true;
    this.render();
},

handleInput: function(button, isPressed) {
    switch(button) {
        case 'up':
            this.leftPaddle.dy = isPressed ? -this.gameData.paddleSpeed : 0;
            break;
        case 'down':
            this.leftPaddle.dy = isPressed ? this.gameData.paddleSpeed : 0;
            break;
        case 'a':
            if (isPressed && this.gameOver) {
                this.restart();
            }
            break;
        case 'b':
            if (isPressed) {
                this.aiEnabled = !this.aiEnabled;
            }
            break;
    }
},

update: function() {
    if (this.gameOver) return;
    
    // Update left paddle position
    this.leftPaddle.y += this.leftPaddle.dy;
    
    // Keep paddle within bounds
    if (this.leftPaddle.y < 0) {
        this.leftPaddle.y = 0;
    } else if (this.leftPaddle.y + this.leftPaddle.height > this.gameData.height) {
        this.leftPaddle.y = this.gameData.height - this.leftPaddle.height;
    }
    
    // AI for right paddle
    if (this.aiEnabled) {
        const targetY = this.ball.y - this.rightPaddle.height / 2;
        
        // Add some reaction delay and imperfection to AI
        if (Math.random() > this.aiReactionTime) {
            if (targetY < this.rightPaddle.y - 5) {
                this.rightPaddle.dy = -this.gameData.paddleSpeed;
            } else if (targetY > this.rightPaddle.y + 5) {
                this.rightPaddle.dy = this.gameData.paddleSpeed;
            } else {
                this.rightPaddle.dy = 0;
            }
        }
    }
    
    // Update right paddle position
    this.rightPaddle.y += this.rightPaddle.dy;
    
    // Keep paddle within bounds
    if (this.rightPaddle.y < 0) {
        this.rightPaddle.y = 0;
    } else if (this.rightPaddle.y + this.rightPaddle.height > this.gameData.height) {
        this.rightPaddle.y = this.gameData.height - this.rightPaddle.height;
    }
    
    // Update ball position
    this.ball.x += this.ball.dx;
    this.ball.y += this.ball.dy;
    
    // Ball collision with top and bottom
    if (this.ball.y <= 0 || this.ball.y + this.ball.height >= this.gameData.height) {
        this.ball.dy = -this.ball.dy;
    }
    
    // Ball collision with paddles
    if (this.checkCollision(this.ball, this.leftPaddle)) {
        this.ball.dx = Math.abs(this.ball.dx) + 0.2; // Increase speed slightly
        
        // Change angle based on where the ball hits the paddle
        const hitPosition = (this.ball.y - this.leftPaddle.y) / this.leftPaddle.height;
        this.ball.dy = 5 * (hitPosition - 0.5); // -2.5 to 2.5
    }
    
    if (this.checkCollision(this.ball, this.rightPaddle)) {
        this.ball.dx = -Math.abs(this.ball.dx) - 0.2; // Increase speed slightly
        
        // Change angle based on where the ball hits the paddle
        const hitPosition = (this.ball.y - this.rightPaddle.y) / this.rightPaddle.height;
        this.ball.dy = 5 * (hitPosition - 0.5); // -2.5 to 2.5
    }
    
    // Ball out of bounds - scoring
    if (this.ball.x < 0) {
        // Right player scores
        this.rightPaddle.score++;
        this.resetBall();
        
        if (this.rightPaddle.score >= this.winningScore) {
            this.gameOver = true;
            this.winner = 'right';
        }
    } else if (this.ball.x + this.ball.width > this.gameData.width) {
        // Left player scores
        this.leftPaddle.score++;
        this.resetBall();
        
        if (this.leftPaddle.score >= this.winningScore) {
            this.gameOver = true;
            this.winner = 'left';
        }
    }
},

render: function() {
    // Apply scaling to fill the canvas
    this.ctx.save();
    
    // Clear and fill background
    this.ctx.fillStyle = this.gameData.backgroundColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Set scaling to maintain aspect ratio
    this.ctx.scale(this.scaleX, this.scaleY);
    
    // Draw center line
    this.ctx.setLineDash([5, 5]);
    this.ctx.beginPath();
    this.ctx.moveTo(this.gameData.width / 2, 0);
    this.ctx.lineTo(this.gameData.width / 2, this.gameData.height);
    this.ctx.strokeStyle = '#333';
    this.ctx.stroke();
    this.ctx.setLineDash([]);
    
    // Draw paddles
    this.ctx.fillStyle = '#223344';
    this.ctx.fillRect(this.leftPaddle.x, this.leftPaddle.y, this.leftPaddle.width, this.leftPaddle.height);
    this.ctx.fillRect(this.rightPaddle.x, this.rightPaddle.y, this.rightPaddle.width, this.rightPaddle.height);
    
    // Draw ball
    this.ctx.fillStyle = '#e42c64';
    this.ctx.fillRect(this.ball.x, this.ball.y, this.ball.width, this.ball.height);
    
    // Use a smaller, mobile-friendly font
    const defaultFont = "16px 'Press Start 2P'";
    
    // Draw scores
    this.ctx.fillStyle = '#333';
    this.ctx.font = defaultFont;
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'top';
    this.ctx.fillText(this.leftPaddle.score.toString(), this.gameData.width / 4, 10);
    this.ctx.fillText(this.rightPaddle.score.toString(), 3 * this.gameData.width / 4, 10);
    
    // Draw AI status
    this.ctx.font = "8px 'Press Start 2P'";
    this.ctx.fillText(this.aiEnabled ? "AI: ON" : "AI: OFF", this.gameData.width / 2, this.gameData.height - 20);
    
    // Draw game over message if game is over
    if (this.gameOver) {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, this.gameData.width, this.gameData.height);
        
        this.ctx.fillStyle = 'white';
        this.ctx.font = "16px 'Press Start 2P'";
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        const winnerText = this.winner === 'left' ? "YOU WIN!" : "AI WINS!";
        this.ctx.fillText(winnerText, this.gameData.width / 2, this.gameData.height / 2 - 20);
        
        this.ctx.font = "10px 'Press Start 2P'";
        this.ctx.fillText("PRESS A TO RESTART", this.gameData.width / 2, this.gameData.height / 2 + 20);
    }
    
    this.ctx.restore();
},

checkCollision: function(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
},

resetBall: function() {
    this.ball.x = this.gameData.width / 2;
    this.ball.y = this.gameData.height / 2;
    
    // Randomize direction, but ensure it's not too vertical
    const horizontalDirection = Math.random() > 0.5 ? 1 : -1;
    const verticalComponent = (Math.random() - 0.5) * 2; // -1 to 1
    
    this.ball.dx = this.gameData.initialBallSpeed * horizontalDirection;
    this.ball.dy = this.gameData.initialBallSpeed * verticalComponent * 0.5; // Reduce vertical speed
},

restart: function() {
    this.leftPaddle.score = 0;
    this.rightPaddle.score = 0;
    this.gameOver = false;
    this.winner = null;
    this.resetBall();
},

cleanup: function() {
    if (this.canvas && this.canvas.parentNode) {
        this.canvas.parentNode.removeChild(this.canvas);
    }
    
    // Remove resize listener
    if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
    }
}
};

// Mobile-optimized maze game
this.gameLibrary['mini-maze'] = {
id: 'mini-maze',
name: 'Mini Maze',
description: 'Navigate the maze to the exit',
icon: 'ðŸ§©',
gameData: {
    width: 280,
    height: 248,
    backgroundColor: '#8bac0f',
    wallColor: '#223344',
    playerColor: '#e42c64',
    exitColor: '#4CAF50',
    cellSize: 20
},
initialize: function(display) {
    this.display = display;
    this.canvas = document.createElement('canvas');
    
    // Make canvas responsive
    const updateCanvasSize = () => {
        const container = display.getBoundingClientRect();
        const aspectRatio = this.gameData.width / this.gameData.height;
        
        if (container.width / container.height > aspectRatio) {
            this.canvas.height = container.height;
            this.canvas.width = container.height * aspectRatio;
        } else {
            this.canvas.width = container.width;
            this.canvas.height = container.width / aspectRatio;
        }
        
        this.scaleX = this.canvas.width / this.gameData.width;
        this.scaleY = this.canvas.height / this.gameData.height;
        
        if (this.gameInitialized) {
            this.render();
        }
    };
    
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);
    this.resizeListener = updateCanvasSize;
    
    display.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    
    // Define a simple maze layout (0 = empty, 1 = wall, 2 = exit)
    this.maze = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];
    
    // Find the player starting position
    this.player = { x: 1, y: 1 };
    
    // Find the exit position
    this.exit = { x: 1, y: 11 }; // Hardcoded for this simple maze
    
    this.gameWon = false;
    this.moveQueue = [];
    this.lastMoveTime = 0; // For touch input rate limiting
    
    this.gameInitialized = true;
    this.render();
},

handleInput: function(button, isPressed) { if (isPressed && !this.gameWon) {
                // For mobile, implement a throttle to avoid excessive input
                const now = Date.now();
                if (now - this.lastMoveTime < 100) {
                    return; // Throttle rapid inputs
                }
                this.lastMoveTime = now;
                
                switch(button) {
                    case 'up':
                        this.moveQueue.push('up');
                        break;
                    case 'right':
                        this.moveQueue.push('right');
                        break;
                    case 'down':
                        this.moveQueue.push('down');
                        break;
                    case 'left':
                        this.moveQueue.push('left');
                        break;
                    case 'a':
                        if (this.gameWon) {
                            this.restart();
                        }
                        break;
                }
            }
        },
        
        update: function() {
            if (this.gameWon) return;
            
            // Process move queue
            if (this.moveQueue.length > 0) {
                const move = this.moveQueue.shift();
                
                // Calculate new position
                let newX = this.player.x;
                let newY = this.player.y;
                
                switch(move) {
                    case 'up': newY--; break;
                    case 'right': newX++; break;
                    case 'down': newY++; break;
                    case 'left': newX--; break;
                }
                
                // Check if the move is valid (not a wall)
                if (this.maze[newY] && this.maze[newY][newX] !== 1) {
                    this.player.x = newX;
                    this.player.y = newY;
                    
                    // Check if player reached the exit
                    if (this.player.x === this.exit.x && this.player.y === this.exit.y) {
                        this.gameWon = true;
                    }
                }
            }
        },
        
        render: function() {
            // Apply scaling to fill the canvas
            this.ctx.save();
            
            // Clear canvas
            this.ctx.fillStyle = this.gameData.backgroundColor;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            // Set scaling to maintain aspect ratio
            this.ctx.scale(this.scaleX, this.scaleY);
            
            // Calculate offsets to center the maze
            const offsetX = (this.gameData.width - this.maze[0].length * this.gameData.cellSize) / 2;
            const offsetY = (this.gameData.height - this.maze.length * this.gameData.cellSize) / 2;
            
            // Draw maze
            for (let y = 0; y < this.maze.length; y++) {
                for (let x = 0; x < this.maze[y].length; x++) {
                    const cellX = offsetX + x * this.gameData.cellSize;
                    const cellY = offsetY + y * this.gameData.cellSize;
                    
                    if (this.maze[y][x] === 1) {
                        // Draw wall
                        this.ctx.fillStyle = this.gameData.wallColor;
                        this.ctx.fillRect(cellX, cellY, this.gameData.cellSize, this.gameData.cellSize);
                    } else if (x === this.exit.x && y === this.exit.y) {
                        // Draw exit
                        this.ctx.fillStyle = this.gameData.exitColor;
                        this.ctx.fillRect(cellX, cellY, this.gameData.cellSize, this.gameData.cellSize);
                    }
                }
            }
            
            // Draw player
            const playerX = offsetX + this.player.x * this.gameData.cellSize;
            const playerY = offsetY + this.player.y * this.gameData.cellSize;
            this.ctx.fillStyle = this.gameData.playerColor;
            this.ctx.beginPath();
            this.ctx.arc(
                playerX + this.gameData.cellSize / 2,
                playerY + this.gameData.cellSize / 2,
                this.gameData.cellSize / 3,
                0,
                Math.PI * 2
            );
            this.ctx.fill();
            
            // Draw game won message
            if (this.gameWon) {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.gameData.width, this.gameData.height);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = "16px 'Press Start 2P'";
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('YOU WIN!', this.gameData.width / 2, this.gameData.height / 2 - 20);
                
                this.ctx.font = "10px 'Press Start 2P'";
                this.ctx.fillText('PRESS A TO RESTART', this.gameData.width / 2, this.gameData.height / 2 + 20);
            }
            
            this.ctx.restore();
        },
        
        restart: function() {
            this.player = { x: 1, y: 1 };
            this.gameWon = false;
            this.moveQueue = [];
        },
        
        cleanup: function() {
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            
            // Remove resize listener
            if (this.resizeListener) {
                window.removeEventListener('resize', this.resizeListener);
            }
        }
    };
}

displayMainMenu() {
    // Clear the game display
    this.gameDisplay.innerHTML = '';
    
    // Create menu content
    const menuContent = document.createElement('div');
    menuContent.style.width = '100%';
    menuContent.style.height = '100%';
    menuContent.style.display = 'flex';
    menuContent.style.flexDirection = 'column';
    menuContent.style.justifyContent = 'center';
    menuContent.style.alignItems = 'center';
    menuContent.style.color = 'black';
    menuContent.style.textAlign = 'center';
    menuContent.style.fontFamily = '"Press Start 2P", cursive';
    
    menuContent.innerHTML = `
        <h2 style="font-size: 14px; margin-bottom: 20px;">RetroPlay</h2>
        <p style="font-size: 10px; margin-bottom: 10px;">Press START to open game library</p>
        <p style="font-size: 10px;">Use D-Pad to navigate</p>
    `;
    
    this.gameDisplay.appendChild(menuContent);
}

loadGameList() {
    const gamesGrid = document.getElementById('games-grid');
    gamesGrid.innerHTML = '';
    
    Object.values(this.gameLibrary).forEach(game => {
        const gameCard = document.createElement('div');
        gameCard.className = 'game-card';
        gameCard.dataset.gameId = game.id;
        
        gameCard.innerHTML = `
            <div class="game-icon">${game.icon || 'ðŸŽ®'}</div>
            <div class="game-name">${game.name}</div>
            <div class="game-description">${game.description}</div>
        `;
        
        gameCard.addEventListener('click', () => {
            this.loadGame(game.id);
            document.getElementById('game-menu').style.display = 'none';
        });
        
        gamesGrid.appendChild(gameCard);
    });
}

loadGame(gameId) {
    // Show loading screen while initializing game
    this.loadingScreen.style.display = 'flex';
    
    // Small delay to allow loading screen to render
    setTimeout(() => {
        // Stop any current game
        if (this.currentGame) {
            clearInterval(this.gameLoop);
            this.gameRunning = false;
            
            if (this.currentGame.cleanup) {
                this.currentGame.cleanup();
            }
        }
        
        // Clear the display
        this.gameDisplay.innerHTML = '';
        
        // Initialize the new game
        this.currentGame = this.gameLibrary[gameId];
        if (this.currentGame) {
            // Initialize with requestAnimationFrame for better performance
            this.currentGame.initialize(this.gameDisplay);
            
            let lastTime = performance.now();
            this.gameRunning = true;
            
            // Set up game loop with requestAnimationFrame for smoother gameplay
            const gameLoop = (timestamp) => {
                if (!this.gameRunning) return;
                
                const deltaTime = timestamp - lastTime;
                
                if (this.currentGame.update) {
                    this.currentGame.update(deltaTime);
                }
                
                if (this.currentGame.render) {
                    this.currentGame.render();
                }
                
                lastTime = timestamp;
                requestAnimationFrame(gameLoop);
            };
            
            // Start the game loop
            this.animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // Hide loading screen
        this.loadingScreen.style.display = 'none';
    }, 100);
}

handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Show loading screen
    this.loadingScreen.style.display = 'flex';
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const gameData = JSON.parse(e.target.result);
            const game = this.processGameData(gameData);
            
            if (game) {
                // Add the game to the library
                this.gameLibrary[game.id] = game;
                
                // Refresh the game list
                this.loadGameList();
                
                // Hide loading screen
                this.loadingScreen.style.display = 'none';
                
                alert(`Game "${game.name}" has been loaded successfully!`);
            } else {
                this.loadingScreen.style.display = 'none';
                alert('Invalid game cartridge format. Please try a different file.');
            }
        } catch (error) {
            this.loadingScreen.style.display = 'none';
            alert(`Error loading game: ${error.message}`);
            console.error(error);
        }
    };
    
    reader.readAsText(file);
    
    // Reset the input value so the same file can be loaded again if needed
    event.target.value = '';
}

exportCurrentGame() {
    if (!this.currentGame) return;
    
    // Show loading screen during export
    this.loadingScreen.style.display = 'flex';
    
    // Create a full copy of the game object including all functionality
    const gameExport = {
        id: this.currentGame.id,
        name: this.currentGame.name,
        description: this.currentGame.description,
        icon: this.currentGame.icon,
        gameData: this.currentGame.gameData,
        
        // Serialize game logic functions as strings
        initializeCode: this.currentGame.initialize.toString(),
        updateCode: this.currentGame.update ? this.currentGame.update.toString() : null,
        renderCode: this.currentGame.render ? this.currentGame.render.toString() : null,
        handleInputCode: this.currentGame.handleInput ? this.currentGame.handleInput.toString() : null,
        cleanupCode: this.currentGame.cleanup ? this.currentGame.cleanup.toString() : null,
        
        // Additional game-specific functions, also serialized as strings
        additionalFunctions: {}
    };
    
    // Extract any additional functions from the game
    for (const key in this.currentGame) {
        if (typeof this.currentGame[key] === 'function' && 
            !['initialize', 'update', 'render', 'handleInput', 'cleanup'].includes(key)) {
            gameExport.additionalFunctions[key] = this.currentGame[key].toString();
        }
    }
    
    // Convert to JSON
    const gameJson = JSON.stringify(gameExport, null, 2);
    
    // Create a downloadable file
    const blob = new Blob([gameJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    // Create a link and trigger the download
    const a = document.createElement('a');
    a.href = url;
    a.download = `${gameExport.id}.json`;
    document.body.appendChild(a);
    a.click();
    
    // Clean up
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Hide loading screen
    this.loadingScreen.style.display = 'none';
}
}

// Preloaded GitHub game files for mobile-optimized performance
const PRELOADED_GAMES = [
    {
        name: "snake-2.0-complete.json",
        path: "snake-2.0-complete.json",
        raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/snake-2.0-complete.json`
    },
    {
        name: "tetris-game.json",
        path: "tetris-game.json",
        raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/tetris-game.json`
    },
    {
        name: "breakout-game.json",
        path: "breakout-game.json",
        raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/breakout-game.json`
    },
    {
        name: "flappy-bird.json", 
        path: "flappy-bird.json",
        raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/flappy-bird.json`
    },
    {
        name: "space-invaders.json",
        path: "space-invaders.json",
        raw_url: `https://raw.githubusercontent.com/kody-w/localFirstTools/main/space-invaders.json`
    }
];

// Initialize the RetroConsole
document.addEventListener('DOMContentLoaded', () => {
    // Prevent default touch behavior like scrolling
    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('.d-pad-button, .action-button, .system-button')) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Prevent zooming on double tap
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, { passive: false });
    
    // Create the console
    const retroConsole = new RetroConsole();
});
    </script>
</body>
</html>