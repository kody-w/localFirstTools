<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Drone Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        
        #canvas {
            display: block;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            display: flex;
            gap: 20px;
            align-items: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        button {
            background: #00ff88;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc66;
            transform: scale(1.05);
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .stat-label {
            color: #00ff88;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <div class="stat"><span class="stat-label">Altitude:</span> <span id="altitude">0</span>m</div>
        <div class="stat"><span class="stat-label">Speed:</span> <span id="speed">0</span>m/s</div>
        <div class="stat"><span class="stat-label">Battery:</span> <span id="battery">100</span>%</div>
        <div class="stat"><span class="stat-label">Mode:</span> <span id="mode">Autonomous</span></div>
    </div>
    
    <div id="controls">
        <button id="toggleMode">Switch to Manual</button>
        <button id="resetDrone">Reset Position</button>
        <div style="color: #888; font-size: 12px;">Manual Mode: Use Arrow Keys</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
        
        // Camera setup - Isometric view
        const aspect = window.innerWidth / window.innerHeight;
        const d = 50;
        const camera = new THREE.OrthographicCamera(
            -d * aspect, d * aspect, d, -d, 1, 1000
        );
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87CEEB);
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(300, 300);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a8c3a });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Create environment
        function createTree(x, z) {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(8, 8, 6);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 18;
            foliage.castShadow = true;
            group.add(foliage);
            
            group.position.set(x, 0, z);
            return group;
        }
        
        function createBuilding(x, z, height) {
            const width = 10 + Math.random() * 10;
            const depth = 10 + Math.random() * 10;
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.6, 0.3, 0.6)
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            return building;
        }
        
        // Add trees
        for (let i = 0; i < 15; i++) {
            const x = (Math.random() - 0.5) * 250;
            const z = (Math.random() - 0.5) * 250;
            if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                scene.add(createTree(x, z));
            }
        }
        
        // Add buildings
        for (let i = 0; i < 8; i++) {
            const x = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            const height = 20 + Math.random() * 40;
            if (Math.abs(x) > 40 || Math.abs(z) > 40) {
                scene.add(createBuilding(x, z, height));
            }
        }
        
        // Create drone
        class Drone {
            constructor() {
                this.group = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(4, 1, 4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.castShadow = true;
                this.group.add(this.body);
                
                // Propellers
                this.propellers = [];
                const propellerPositions = [
                    [-2, 0.5, -2], [2, 0.5, -2],
                    [-2, 0.5, 2], [2, 0.5, 2]
                ];
                
                propellerPositions.forEach(pos => {
                    const propGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
                    const propMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const propeller = new THREE.Mesh(propGeometry, propMaterial);
                    propeller.rotation.z = Math.PI / 2;
                    propeller.position.set(...pos);
                    propeller.castShadow = true;
                    this.propellers.push(propeller);
                    this.group.add(propeller);
                });
                
                // Light
                const light = new THREE.PointLight(0x00ff00, 1, 10);
                light.position.y = -0.5;
                this.group.add(light);
                
                // Position and physics
                this.group.position.set(0, 20, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.targetPosition = new THREE.Vector3(0, 20, 0);
                this.isManual = false;
                this.battery = 100;
                
                scene.add(this.group);
            }
            
            update(deltaTime) {
                // Rotate propellers
                this.propellers.forEach(prop => {
                    prop.rotation.y += deltaTime * 50;
                });
                
                // Battery drain
                this.battery = Math.max(0, this.battery - deltaTime * 0.5);
                
                if (!this.isManual) {
                    // Autonomous flight
                    const time = Date.now() * 0.001;
                    
                    // Create a smooth flight path
                    this.targetPosition.x = Math.sin(time * 0.3) * 50;
                    this.targetPosition.z = Math.cos(time * 0.2) * 50;
                    this.targetPosition.y = 20 + Math.sin(time * 0.5) * 10;
                    
                    // Move towards target
                    const direction = new THREE.Vector3().subVectors(this.targetPosition, this.group.position);
                    const distance = direction.length();
                    
                    if (distance > 0.1) {
                        direction.normalize();
                        this.velocity.lerp(direction.multiplyScalar(10), deltaTime * 2);
                    }
                }
                
                // Apply velocity
                this.group.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Tilt based on velocity
                this.group.rotation.z = this.velocity.x * 0.02;
                this.group.rotation.x = -this.velocity.z * 0.02;
                
                // Damping
                this.velocity.multiplyScalar(0.98);
                
                // Keep within bounds
                this.group.position.clamp(
                    new THREE.Vector3(-100, 5, -100),
                    new THREE.Vector3(100, 50, 100)
                );
            }
            
            setManualControl(vx, vy, vz) {
                if (this.isManual) {
                    this.velocity.x += vx;
                    this.velocity.y += vy;
                    this.velocity.z += vz;
                }
            }
            
            reset() {
                this.group.position.set(0, 20, 0);
                this.velocity.set(0, 0, 0);
                this.battery = 100;
            }
        }
        
        const drone = new Drone();
        
        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        
        // UI Controls
        const toggleModeBtn = document.getElementById('toggleMode');
        const resetBtn = document.getElementById('resetDrone');
        const modeDisplay = document.getElementById('mode');
        
        toggleModeBtn.addEventListener('click', () => {
            drone.isManual = !drone.isManual;
            toggleModeBtn.textContent = drone.isManual ? 'Switch to Autonomous' : 'Switch to Manual';
            modeDisplay.textContent = drone.isManual ? 'Manual' : 'Autonomous';
        });
        
        resetBtn.addEventListener('click', () => {
            drone.reset();
        });
        
        // Animation loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (deltaTime > 0 && deltaTime < 0.1) {
                // Manual controls
                if (drone.isManual) {
                    if (keys['ArrowUp']) drone.setManualControl(0, 0, -1);
                    if (keys['ArrowDown']) drone.setManualControl(0, 0, 1);
                    if (keys['ArrowLeft']) drone.setManualControl(-1, 0, 0);
                    if (keys['ArrowRight']) drone.setManualControl(1, 0, 0);
                    if (keys[' ']) drone.setManualControl(0, 1, 0);
                    if (keys['Shift']) drone.setManualControl(0, -1, 0);
                }
                
                drone.update(deltaTime);
                
                // Update UI
                document.getElementById('altitude').textContent = drone.group.position.y.toFixed(1);
                document.getElementById('speed').textContent = drone.velocity.length().toFixed(1);
                document.getElementById('battery').textContent = drone.battery.toFixed(0);
                
                // Camera follow with smooth damping
                const cameraTarget = new THREE.Vector3(
                    drone.group.position.x * 0.3,
                    0,
                    drone.group.position.z * 0.3
                );
                camera.position.x = 100 + cameraTarget.x;
                camera.position.z = 100 + cameraTarget.z;
                camera.lookAt(cameraTarget);
            }
            
            renderer.render(scene, camera);
        }
        
        animate(0);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>