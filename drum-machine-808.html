<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>808s Production Suite - Auto-Play Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: linear-gradient(180deg, #0a0a0a 0%, #1a0010 100%);
            padding-bottom: 120px;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid #ff0066;
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #ff0066, #ff9900, #ff0066);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 200%;
            animation: gradient 3s ease infinite;
            margin-bottom: 10px;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .tabs {
            display: flex;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, #ff0066, #ff3366);
            border-color: #ff0066;
            box-shadow: 0 4px 20px rgba(255, 0, 100, 0.5);
        }

        .content {
            flex: 1;
            padding: 20px;
            display: none;
        }

        .content.active {
            display: block;
        }

        .master-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-top: 2px solid #ff0066;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            z-index: 1000;
        }

        button {
            background: linear-gradient(135deg, #ff0066, #ff3366);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 0, 100, 0.3);
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 100, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 8px;
        }

        input[type="range"] {
            width: 150px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ff0066;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 5px;
        }

        .progress-bar {
            height: 20px;
            background: linear-gradient(90deg, #ff0066, #ff9900);
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s ease;
            position: relative;
        }

        .progress-time {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #fff;
        }

        /* Song Info Display */
        .song-info {
            text-align: center;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            max-width: 600px;
        }

        .song-info h2 {
            color: #ff9900;
            margin-bottom: 10px;
        }

        .current-section {
            font-size: 1.2em;
            margin: 10px 0;
            color: #ff0066;
        }

        .lyrics-display {
            min-height: 60px;
            font-size: 1.5em;
            margin: 20px 0;
            line-height: 1.4;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            animation: lyricsGlow 2s ease-in-out infinite;
        }

        @keyframes lyricsGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; text-shadow: 2px 2px 8px rgba(255, 0, 100, 0.8); }
        }

        /* Drum Machine Styles */
        .drum-machine {
            max-width: 1200px;
            margin: 0 auto;
        }

        .sequencer {
            display: grid;
            gap: 10px;
            margin-bottom: 30px;
        }

        .track {
            display: grid;
            grid-template-columns: 100px repeat(16, 1fr);
            gap: 5px;
            align-items: center;
        }

        .track-label {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }

        .step {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .step:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .step.active {
            background: linear-gradient(135deg, #ff0066, #ff3366);
            border-color: #ff0066;
            box-shadow: 0 0 10px rgba(255, 0, 100, 0.7);
        }

        .step.playing {
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .current-step {
            border-color: #ffff00 !important;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8) !important;
        }

        /* Synthesizer Styles */
        .synth-container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid rgba(255, 0, 100, 0.3);
        }

        .keyboard {
            margin: 30px auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            position: relative;
            width: fit-content;
        }

        .keyboard-container {
            position: relative;
            height: 150px;
            width: 560px;
            margin: 0 auto;
        }

        .key {
            cursor: pointer;
            transition: all 0.1s ease;
            user-select: none;
            position: absolute;
        }

        .white-key {
            width: 50px;
            height: 150px;
            background: linear-gradient(to bottom, #fff, #eee);
            border: 1px solid #ccc;
            border-radius: 0 0 5px 5px;
            z-index: 1;
        }

        .white-key:hover {
            background: linear-gradient(to bottom, #f0f0f0, #ddd);
        }

        .white-key.active {
            background: linear-gradient(to bottom, #ff9999, #ff6666);
            transform: translateY(2px);
        }

        .black-key {
            width: 35px;
            height: 100px;
            background: linear-gradient(to bottom, #333, #000);
            border-radius: 0 0 3px 3px;
            z-index: 2;
        }

        .black-key:hover {
            background: linear-gradient(to bottom, #444, #111);
        }

        .black-key.active {
            background: linear-gradient(to bottom, #cc0000, #990000);
            transform: translateY(2px);
        }

        .synth-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .synth-control {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .synth-control h3 {
            margin-bottom: 10px;
            color: #ff9900;
            font-size: 14px;
            text-transform: uppercase;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .preset-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(135deg, #9900ff, #cc00ff);
        }

        /* Sampler Styles */
        .sampler-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .sample-pads {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .sample-pad {
            aspect-ratio: 1;
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.2), rgba(255, 0, 100, 0.1));
            border: 3px solid #ff0066;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .sample-pad:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 100, 0.5);
        }

        .sample-pad.active {
            background: linear-gradient(135deg, #ff0066, #ff3366);
            animation: padPulse 0.3s ease;
        }

        @keyframes padPulse {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        .pad-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .pad-name {
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* Effects Rack */
        .effects-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .effect-unit {
            background: rgba(30, 30, 40, 0.9);
            border: 2px solid rgba(255, 100, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .effect-unit h3 {
            color: #ff9900;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .effect-knob {
            width: 80px;
            height: 80px;
            margin: 10px auto;
            background: radial-gradient(circle at 30% 30%, #666, #333);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .effect-knob::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 40px;
            background: #ff0066;
            left: 50%;
            top: 10%;
            transform: translateX(-50%);
            border-radius: 2px;
        }

        .effect-toggle {
            display: inline-block;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
            margin-top: 10px;
        }

        .effect-toggle.active {
            background: #ff0066;
        }

        .effect-toggle::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
        }

        .effect-toggle.active::after {
            transform: translateX(30px);
        }

        /* File controls */
        .file-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            background: linear-gradient(135deg, #0066ff, #0099ff);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 100, 255, 0.3);
            display: inline-block;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 100, 255, 0.5);
        }

        .status {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .recording {
            color: #ff0066;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Vocoder Section */
        .vocoder-container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid rgba(0, 255, 100, 0.3);
        }

        .vocoder-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .mic-button {
            background: linear-gradient(135deg, #00ff66, #00cc55);
            padding: 30px;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mic-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 255, 100, 0.5);
        }

        .mic-button.active {
            background: linear-gradient(135deg, #ff0066, #cc0055);
            animation: micPulse 1s infinite;
        }

        @keyframes micPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        /* Auto-play Controls */
        .auto-play-controls {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .auto-play-btn {
            background: linear-gradient(135deg, #00ff66, #00cc55);
            font-size: 1.2em;
            padding: 15px 30px;
            margin: 10px;
        }

        .auto-play-btn.playing {
            background: linear-gradient(135deg, #ff6600, #ff3300);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>808s PRODUCTION SUITE</h1>
            <p>Complete Music Production Environment with Auto-Play</p>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="drums">DRUM MACHINE</div>
            <div class="tab" data-tab="synth">SYNTHESIZER</div>
            <div class="tab" data-tab="sampler">SAMPLER</div>
            <div class="tab" data-tab="effects">EFFECTS</div>
            <div class="tab" data-tab="vocoder">VOCODER</div>
            <div class="tab" data-tab="autoplay">AUTO-PLAY</div>
        </div>

        <!-- Song Info Display -->
        <div class="song-info">
            <h2 id="songTitle">No Song Loaded</h2>
            <div class="current-section" id="currentSection">Ready to Play</div>
            <div class="lyrics-display" id="lyricsDisplay"></div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <span class="progress-time" id="progressTime">0:00 / 0:00</span>
                </div>
            </div>
        </div>

        <!-- Drum Machine Section -->
        <div class="content active" id="drums">
            <div class="drum-machine">
                <div class="file-controls">
                    <button id="clearDrumBtn">CLEAR</button>
                    <button id="randomizeBtn">🎲 RANDOMIZE</button>
                    <button id="exportDrumBtn">💾 EXPORT PATTERN</button>
                    <label for="importDrumPattern" class="file-label">📂 IMPORT PATTERN</label>
                    <input type="file" id="importDrumPattern" accept=".json">
                </div>
                <div class="sequencer" id="drumSequencer"></div>
            </div>
        </div>

        <!-- Synthesizer Section -->
        <div class="content" id="synth">
            <div class="synth-container">
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="lead">LEAD</button>
                    <button class="preset-btn" data-preset="bass">BASS</button>
                    <button class="preset-btn" data-preset="pad">PAD</button>
                    <button class="preset-btn" data-preset="arp">ARPEGGIO</button>
                </div>
                
                <div class="synth-controls">
                    <div class="synth-control">
                        <h3>Oscillator</h3>
                        <select id="waveform">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="sawtooth" selected>Sawtooth</option>
                            <option value="triangle">Triangle</option>
                        </select>
                    </div>
                    <div class="synth-control">
                        <h3>Filter Cutoff</h3>
                        <input type="range" id="filterCutoff" min="20" max="20000" value="2000">
                        <span id="filterCutoffValue">2000</span>
                    </div>
                    <div class="synth-control">
                        <h3>Resonance</h3>
                        <input type="range" id="filterResonance" min="0" max="30" value="5">
                        <span id="filterResonanceValue">5</span>
                    </div>
                    <div class="synth-control">
                        <h3>Attack</h3>
                        <input type="range" id="synthAttack" min="0" max="2" step="0.01" value="0.01">
                        <span id="synthAttackValue">0.01</span>
                    </div>
                    <div class="synth-control">
                        <h3>Decay</h3>
                        <input type="range" id="synthDecay" min="0" max="2" step="0.01" value="0.3">
                        <span id="synthDecayValue">0.3</span>
                    </div>
                    <div class="synth-control">
                        <h3>Sustain</h3>
                        <input type="range" id="synthSustain" min="0" max="1" step="0.01" value="0.5">
                        <span id="synthSustainValue">0.5</span>
                    </div>
                    <div class="synth-control">
                        <h3>Release</h3>
                        <input type="range" id="synthRelease" min="0" max="5" step="0.01" value="0.8">
                        <span id="synthReleaseValue">0.8</span>
                    </div>
                    <div class="synth-control">
                        <h3>Portamento</h3>
                        <input type="range" id="portamento" min="0" max="1" step="0.01" value="0">
                        <span id="portamentoValue">0</span>
                    </div>
                </div>
                
                <div class="keyboard">
                    <div class="keyboard-container" id="keyboardContainer"></div>
                </div>
            </div>
        </div>

        <!-- Sampler Section -->
        <div class="content" id="sampler">
            <div class="sampler-container">
                <h2 style="text-align: center; margin-bottom: 30px;">MPC-STYLE SAMPLER</h2>
                <div class="sample-pads" id="samplePads"></div>
                <div class="file-controls">
                    <label for="loadSample" class="file-label">📁 LOAD SAMPLE</label>
                    <input type="file" id="loadSample" accept="audio/*">
                    <button id="clearSamplesBtn">CLEAR ALL</button>
                </div>
            </div>
        </div>

        <!-- Effects Section -->
        <div class="content" id="effects">
            <div class="effects-container">
                <h2 style="text-align: center; margin-bottom: 30px;">EFFECTS RACK</h2>
                <div class="effects-grid">
                    <div class="effect-unit">
                        <h3>AUTO-TUNE</h3>
                        <div class="effect-knob" id="autotuneKnob"></div>
                        <p>Amount: <span id="autotuneAmount">50</span>%</p>
                        <div class="effect-toggle" id="autotuneToggle"></div>
                    </div>
                    <div class="effect-unit">
                        <h3>REVERB</h3>
                        <div class="effect-knob" id="reverbKnob"></div>
                        <p>Room Size: <span id="reverbAmount">30</span>%</p>
                        <div class="effect-toggle" id="reverbToggle"></div>
                    </div>
                    <div class="effect-unit">
                        <h3>DELAY</h3>
                        <div class="effect-knob" id="delayKnob"></div>
                        <p>Time: <span id="delayAmount">25</span>%</p>
                        <div class="effect-toggle" id="delayToggle"></div>
                    </div>
                    <div class="effect-unit">
                        <h3>DISTORTION</h3>
                        <div class="effect-knob" id="distortionKnob"></div>
                        <p>Drive: <span id="distortionAmount">0</span>%</p>
                        <div class="effect-toggle" id="distortionToggle"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Vocoder Section -->
        <div class="content" id="vocoder">
            <div class="vocoder-container">
                <h2 style="text-align: center; margin-bottom: 30px;">VOCODER / VOICE PROCESSOR</h2>
                <div class="mic-button" id="micButton">🎤</div>
                <div class="vocoder-controls">
                    <div class="synth-control">
                        <h3>Carrier Frequency</h3>
                        <input type="range" id="carrierFreq" min="80" max="800" value="220">
                        <span id="carrierFreqValue">220</span>
                    </div>
                    <div class="synth-control">
                        <h3>Modulation</h3>
                        <input type="range" id="vocoderMod" min="0" max="100" value="50">
                        <span id="vocoderModValue">50</span>
                    </div>
                    <div class="synth-control">
                        <h3>Bands</h3>
                        <input type="range" id="vocoderBands" min="4" max="32" value="16">
                        <span id="vocoderBandsValue">16</span>
                    </div>
                    <div class="synth-control">
                        <h3>Robot Voice</h3>
                        <div class="effect-toggle" id="robotToggle"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Auto-Play Section -->
        <div class="content" id="autoplay">
            <div class="auto-play-controls">
                <h2>AUTO-PLAY SONG MODE</h2>
                <p>Load a complete song project with automated sequences</p>
                <button class="auto-play-btn" id="loadDemoSongBtn">🎵 LOAD DEMO SONG</button>
                <button class="auto-play-btn" id="autoPlayBtn">▶ START AUTO-PLAY</button>
                <div style="margin-top: 20px;">
                    <label for="importAutoSong" class="file-label">📂 IMPORT AUTO-PLAY SONG</label>
                    <input type="file" id="importAutoSong" accept=".json">
                </div>
            </div>
        </div>

        <!-- Master Controls -->
        <div class="master-controls">
            <button id="playBtn">▶ PLAY</button>
            <button id="stopBtn">■ STOP</button>
            <button id="recordBtn">🔴 RECORD</button>
            <div class="control-group">
                <label>BPM:</label>
                <input type="range" id="tempoSlider" min="60" max="200" value="120">
                <span id="tempoValue">120</span>
            </div>
            <div class="control-group">
                <label>MASTER:</label>
                <input type="range" id="masterVolume" min="0" max="100" value="80">
                <span id="masterVolumeValue">80</span>%
            </div>
            <button id="exportProjectBtn">💾 EXPORT PROJECT</button>
            <label for="importProject" class="file-label">📂 IMPORT PROJECT</label>
            <input type="file" id="importProject" accept=".json">
            <button id="downloadBtn" style="display: none;">💿 DOWNLOAD</button>
        </div>

        <div class="status" id="status">Welcome to 808s Production Suite! Ready to create music.</div>
    </div>

    <script>
        // Global audio context and variables
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let isPlaying = false;
        let currentStep = 0;
        let intervalId = null;
        let tempo = 120;
        let recorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordedBlob = null;
        let masterGain = audioContext.createGain();
        masterGain.gain.value = 0.8;
        masterGain.connect(audioContext.destination);

        // Auto-play variables
        let isAutoPlaying = false;
        let autoPlayData = null;
        let autoPlayStartTime = null;
        let scheduledEvents = [];
        let currentBar = 0;
        let currentSongSection = '';
        let speechQueue = [];

        // Effects nodes
        let reverbNode = null;
        let delayNode = null;
        let distortionNode = null;
        let autotuneNode = null;

        // Note frequencies mapping
        const noteFrequencies = {
            "C1": 32.70, "C#1": 34.65, "D1": 36.71, "D#1": 38.89, "E1": 41.20, "F1": 43.65, "F#1": 46.25, "G1": 49.00, "G#1": 51.91, "A1": 55.00, "A#1": 58.27, "B1": 61.74,
            "C2": 65.41, "C#2": 69.30, "D2": 73.42, "D#2": 77.78, "E2": 82.41, "F2": 87.31, "F#2": 92.50, "G2": 98.00, "G#2": 103.83, "A2": 110.00, "A#2": 116.54, "B2": 123.47,
            "C3": 130.81, "C#3": 138.59, "D3": 146.83, "D#3": 155.56, "E3": 164.81, "F3": 174.61, "F#3": 185.00, "G3": 196.00, "G#3": 207.65, "A3": 220.00, "A#3": 233.08, "B3": 246.94,
            "C4": 261.63, "C#4": 277.18, "D4": 293.66, "D#4": 311.13, "E4": 329.63, "F4": 349.23, "F#4": 369.99, "G4": 392.00, "G#4": 415.30, "A4": 440.00, "A#4": 466.16, "B4": 493.88
        };

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });

        // Drum Machine Pattern
        const drumPattern = {
            kick: new Array(16).fill(false),
            snare: new Array(16).fill(false),
            hihat: new Array(16).fill(false),
            openhat: new Array(16).fill(false),
            clap: new Array(16).fill(false),
            crash: new Array(16).fill(false),
            tom: new Array(16).fill(false),
            rim: new Array(16).fill(false)
        };

        // Drum synthesis functions
        const drums = {
            kick: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.setValueAtTime(150, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                gain.gain.setValueAtTime(1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.5);
            },
            
            snare: () => {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                
                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(1, audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                const osc = audioContext.createOscillator();
                osc.frequency.value = 200;
                
                const oscGain = audioContext.createGain();
                oscGain.gain.setValueAtTime(0.7, audioContext.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(masterGain);
                
                osc.connect(oscGain);
                oscGain.connect(masterGain);
                
                noise.start(audioContext.currentTime);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            },
            
            hihat: () => {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;
                
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                noise.start(audioContext.currentTime);
            },
            
            openhat: () => {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000;
                
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                noise.start(audioContext.currentTime);
            },
            
            clap: () => {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.03, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const noise = audioContext.createBufferSource();
                        noise.buffer = noiseBuffer;
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.value = 1500;
                        filter.Q.value = 1;
                        
                        const gain = audioContext.createGain();
                        gain.gain.setValueAtTime(0.5, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.03);
                        
                        noise.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);
                        
                        noise.start(audioContext.currentTime);
                    }, i * 30);
                }
            },
            
            crash: () => {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 3000;
                
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.5, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                noise.start(audioContext.currentTime);
            },
            
            tom: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.setValueAtTime(250, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.8, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.3);
            },
            
            rim: () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.value = 800;
                gain.gain.setValueAtTime(0.5, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.05);
            }
        };

        // Create drum sequencer UI
        function createDrumSequencer() {
            const sequencer = document.getElementById('drumSequencer');
            sequencer.innerHTML = '';
            const trackNames = Object.keys(drumPattern);
            
            trackNames.forEach(track => {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'track';
                
                const label = document.createElement('div');
                label.className = 'track-label';
                label.textContent = track.toUpperCase();
                trackDiv.appendChild(label);
                
                for (let i = 0; i < 16; i++) {
                    const step = document.createElement('div');
                    step.className = 'step';
                    step.dataset.track = track;
                    step.dataset.step = i;
                    
                    if (drumPattern[track][i]) {
                        step.classList.add('active');
                    }
                    
                    step.addEventListener('click', () => {
                        drumPattern[track][i] = !drumPattern[track][i];
                        step.classList.toggle('active');
                    });
                    
                    trackDiv.appendChild(step);
                }
                
                sequencer.appendChild(trackDiv);
            });
        }

        // Synthesizer setup
        let synthOscillator = null;
        let synthFilter = null;
        let synthGain = null;
        let synthParams = {
            waveform: 'sawtooth',
            filterCutoff: 2000,
            filterResonance: 5,
            attack: 0.01,
            decay: 0.3,
            sustain: 0.5,
            release: 0.8,
            portamento: 0
        };

        // Create keyboard with proper layout
        function createKeyboard() {
            const container = document.getElementById('keyboardContainer');
            container.innerHTML = '';
            
            // Define key positions
            const whiteKeys = [
                { note: 'C', freq: 261.63, pos: 0 },
                { note: 'D', freq: 293.66, pos: 55 },
                { note: 'E', freq: 329.63, pos: 110 },
                { note: 'F', freq: 349.23, pos: 165 },
                { note: 'G', freq: 392.00, pos: 220 },
                { note: 'A', freq: 440.00, pos: 275 },
                { note: 'B', freq: 493.88, pos: 330 },
                { note: 'C2', freq: 523.25, pos: 385 }
            ];
            
            const blackKeys = [
                { note: 'C#', freq: 277.18, pos: 40 },
                { note: 'D#', freq: 311.13, pos: 95 },
                { note: 'F#', freq: 369.99, pos: 205 },
                { note: 'G#', freq: 415.30, pos: 260 },
                { note: 'A#', freq: 466.16, pos: 315 }
            ];
            
            // Create white keys
            whiteKeys.forEach(keyData => {
                const key = document.createElement('div');
                key.className = 'key white-key';
                key.dataset.freq = keyData.freq;
                key.dataset.note = keyData.note;
                key.style.left = keyData.pos + 'px';
                
                container.appendChild(key);
                
                key.addEventListener('mousedown', () => playSynthNote(keyData.freq, key));
                key.addEventListener('mouseup', () => stopSynthNote(key));
                key.addEventListener('mouseleave', () => stopSynthNote(key));
                key.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    playSynthNote(keyData.freq, key);
                });
                key.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    stopSynthNote(key);
                });
            });
            
            // Create black keys
            blackKeys.forEach(keyData => {
                const key = document.createElement('div');
                key.className = 'key black-key';
                key.dataset.freq = keyData.freq;
                key.dataset.note = keyData.note;
                key.style.left = keyData.pos + 'px';
                
                container.appendChild(key);
                
                key.addEventListener('mousedown', () => playSynthNote(keyData.freq, key));
                key.addEventListener('mouseup', () => stopSynthNote(key));
                key.addEventListener('mouseleave', () => stopSynthNote(key));
                key.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    playSynthNote(keyData.freq, key);
                });
                key.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    stopSynthNote(key);
                });
            });
        }

        function playSynthNote(frequency, keyElement, velocity = 1, duration = null) {
            if (keyElement) keyElement.classList.add('active');
            
            const osc = audioContext.createOscillator();
            const filter = audioContext.createBiquadFilter();
            const gain = audioContext.createGain();
            
            osc.type = synthParams.waveform;
            osc.frequency.value = frequency;
            
            filter.type = 'lowpass';
            filter.frequency.value = synthParams.filterCutoff;
            filter.Q.value = synthParams.filterResonance;
            
            // ADSR envelope
            const now = audioContext.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(velocity, now + synthParams.attack);
            gain.gain.linearRampToValueAtTime(synthParams.sustain * velocity, now + synthParams.attack + synthParams.decay);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc.start();
            
            if (duration) {
                // Auto stop after duration
                setTimeout(() => {
                    const stopTime = audioContext.currentTime;
                    gain.gain.cancelScheduledValues(stopTime);
                    gain.gain.setValueAtTime(gain.gain.value, stopTime);
                    gain.gain.linearRampToValueAtTime(0, stopTime + synthParams.release);
                    osc.stop(stopTime + synthParams.release);
                    if (keyElement) keyElement.classList.remove('active');
                }, duration * 1000);
            } else {
                // Store for manual stop
                synthOscillator = osc;
                synthGain = gain;
            }
            
            return { osc, gain };
        }

        function stopSynthNote(keyElement) {
            if (keyElement) keyElement.classList.remove('active');
            
            if (synthOscillator && synthGain) {
                const now = audioContext.currentTime;
                synthGain.gain.cancelScheduledValues(now);
                synthGain.gain.setValueAtTime(synthGain.gain.value, now);
                synthGain.gain.linearRampToValueAtTime(0, now + synthParams.release);
                
                synthOscillator.stop(now + synthParams.release);
                synthOscillator = null;
                synthGain = null;
            }
        }

        // Synth control listeners with value display
        document.getElementById('waveform').addEventListener('change', (e) => {
            synthParams.waveform = e.target.value;
        });

        document.getElementById('filterCutoff').addEventListener('input', (e) => {
            synthParams.filterCutoff = parseFloat(e.target.value);
            document.getElementById('filterCutoffValue').textContent = Math.round(synthParams.filterCutoff);
        });

        document.getElementById('filterResonance').addEventListener('input', (e) => {
            synthParams.filterResonance = parseFloat(e.target.value);
            document.getElementById('filterResonanceValue').textContent = synthParams.filterResonance;
        });

        document.getElementById('synthAttack').addEventListener('input', (e) => {
            synthParams.attack = parseFloat(e.target.value);
            document.getElementById('synthAttackValue').textContent = synthParams.attack.toFixed(2);
        });

        document.getElementById('synthDecay').addEventListener('input', (e) => {
            synthParams.decay = parseFloat(e.target.value);
            document.getElementById('synthDecayValue').textContent = synthParams.decay.toFixed(2);
        });

        document.getElementById('synthSustain').addEventListener('input', (e) => {
            synthParams.sustain = parseFloat(e.target.value);
            document.getElementById('synthSustainValue').textContent = synthParams.sustain.toFixed(2);
        });

        document.getElementById('synthRelease').addEventListener('input', (e) => {
            synthParams.release = parseFloat(e.target.value);
            document.getElementById('synthReleaseValue').textContent = synthParams.release.toFixed(2);
        });

        document.getElementById('portamento').addEventListener('input', (e) => {
            synthParams.portamento = parseFloat(e.target.value);
            document.getElementById('portamentoValue').textContent = synthParams.portamento.toFixed(2);
        });

        // Preset buttons
        const presets = {
            lead: { waveform: 'sawtooth', filterCutoff: 2000, filterResonance: 10, attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.3, portamento: 0 },
            bass: { waveform: 'square', filterCutoff: 500, filterResonance: 15, attack: 0.01, decay: 0.2, sustain: 0.7, release: 0.5, portamento: 0.1 },
            pad: { waveform: 'triangle', filterCutoff: 1000, filterResonance: 5, attack: 0.5, decay: 0.5, sustain: 0.6, release: 1.5, portamento: 0 },
            arp: { waveform: 'square', filterCutoff: 3000, filterResonance: 20, attack: 0.001, decay: 0.05, sustain: 0.3, release: 0.1, portamento: 0 }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = presets[btn.dataset.preset];
                Object.assign(synthParams, preset);
                
                // Update UI
                document.getElementById('waveform').value = preset.waveform;
                document.getElementById('filterCutoff').value = preset.filterCutoff;
                document.getElementById('filterResonance').value = preset.filterResonance;
                document.getElementById('synthAttack').value = preset.attack;
                document.getElementById('synthDecay').value = preset.decay;
                document.getElementById('synthSustain').value = preset.sustain;
                document.getElementById('synthRelease').value = preset.release;
                document.getElementById('portamento').value = preset.portamento;
                
                // Update displays
                document.getElementById('filterCutoffValue').textContent = Math.round(preset.filterCutoff);
                document.getElementById('filterResonanceValue').textContent = preset.filterResonance;
                document.getElementById('synthAttackValue').textContent = preset.attack.toFixed(2);
                document.getElementById('synthDecayValue').textContent = preset.decay.toFixed(2);
                document.getElementById('synthSustainValue').textContent = preset.sustain.toFixed(2);
                document.getElementById('synthReleaseValue').textContent = preset.release.toFixed(2);
                document.getElementById('portamentoValue').textContent = preset.portamento.toFixed(2);
            });
        });

        // Sampler setup
        const samples = new Array(16).fill(null);
        let currentPadIndex = 0;

        function createSamplePads() {
            const container = document.getElementById('samplePads');
            container.innerHTML = '';
            
            for (let i = 0; i < 16; i++) {
                const pad = document.createElement('div');
                pad.className = 'sample-pad';
                pad.dataset.index = i;
                
                const number = document.createElement('div');
                number.className = 'pad-number';
                number.textContent = i + 1;
                
                const name = document.createElement('div');
                name.className = 'pad-name';
                name.textContent = 'EMPTY';
                
                pad.appendChild(number);
                pad.appendChild(name);
                
                pad.addEventListener('click', () => playSample(i, pad));
                
                container.appendChild(pad);
            }
        }

        function playSample(index, padElement) {
            if (samples[index]) {
                padElement.classList.add('active');
                
                const source = audioContext.createBufferSource();
                source.buffer = samples[index];
                source.connect(masterGain);
                source.start();
                
                setTimeout(() => padElement.classList.remove('active'), 300);
            }
        }

        document.getElementById('loadSample').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                samples[currentPadIndex] = audioBuffer;
                
                const pad = document.querySelector(`[data-index="${currentPadIndex}"]`);
                const name = pad.querySelector('.pad-name');
                name.textContent = file.name.substring(0, 8).toUpperCase();
                
                currentPadIndex = (currentPadIndex + 1) % 16;
                updateStatus(`Sample loaded to pad ${currentPadIndex}`);
            }
        });

        document.getElementById('clearSamplesBtn').addEventListener('click', () => {
            samples.fill(null);
            document.querySelectorAll('.pad-name').forEach(name => {
                name.textContent = 'EMPTY';
            });
            currentPadIndex = 0;
            updateStatus('All samples cleared');
        });

        // Effects setup
        function setupEffects() {
            // Create reverb using convolver
            reverbNode = audioContext.createConvolver();
            const reverbTime = 2;
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * reverbTime;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }
            }
            
            reverbNode.buffer = impulse;
            
            // Create delay
            delayNode = audioContext.createDelay(2);
            delayNode.delayTime.value = 0.25;
            
            const delayFeedback = audioContext.createGain();
            delayFeedback.gain.value = 0.3;
            
            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayNode);
            
            // Create distortion
            distortionNode = audioContext.createWaveShaper();
            
            function makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }
            
            distortionNode.curve = makeDistortionCurve(0);
            distortionNode.oversample = '4x';
        }

        // Effect controls
        const effectToggles = {
            autotune: false,
            reverb: false,
            delay: false,
            distortion: false
        };

        document.querySelectorAll('.effect-toggle').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
                const effectName = toggle.id.replace('Toggle', '');
                effectToggles[effectName] = !effectToggles[effectName];
            });
        });

        // Vocoder setup
        let micStream = null;
        let vocoderActive = false;

        document.getElementById('micButton').addEventListener('click', async () => {
            const micButton = document.getElementById('micButton');
            
            if (!vocoderActive) {
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micButton.classList.add('active');
                    vocoderActive = true;
                    updateStatus('Vocoder active - speak into your microphone!');
                    
                    // Setup vocoder processing here
                    const source = audioContext.createMediaStreamSource(micStream);
                    // Add vocoder processing chain
                    
                } catch (err) {
                    updateStatus('Error accessing microphone: ' + err.message);
                }
            } else {
                if (micStream) {
                    micStream.getTracks().forEach(track => track.stop());
                }
                micButton.classList.remove('active');
                vocoderActive = false;
                updateStatus('Vocoder stopped');
            }
        });

        // Vocoder control listeners
        document.getElementById('carrierFreq').addEventListener('input', (e) => {
            document.getElementById('carrierFreqValue').textContent = e.target.value;
        });

        document.getElementById('vocoderMod').addEventListener('input', (e) => {
            document.getElementById('vocoderModValue').textContent = e.target.value;
        });

        document.getElementById('vocoderBands').addEventListener('input', (e) => {
            document.getElementById('vocoderBandsValue').textContent = e.target.value;
        });

        // Synthesized speech/vocals function
        function speakText(text, settings = {}) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.pitch = settings.pitch || 1;
                utterance.rate = settings.rate || 0.8;
                utterance.volume = settings.volume || 1;
                
                // Add vocoder-like effect by manipulating voice
                if (settings.robotEffect) {
                    utterance.pitch = 0.6;
                    utterance.rate = 0.7;
                }
                
                // Queue the speech
                speechSynthesis.speak(utterance);
                
                return utterance;
            } else {
                console.warn('Speech synthesis not supported');
            }
        }

        // Auto-play functions
        function scheduleAutoPlayNote(time, note, duration, velocity, instrument = 'bass') {
            const frequency = noteFrequencies[note];
            if (!frequency) return;
            
            setTimeout(() => {
                // Apply synth preset based on instrument
                if (instrument === 'bass') {
                    Object.assign(synthParams, presets.bass);
                } else if (instrument === 'lead') {
                    Object.assign(synthParams, presets.lead);
                }
                
                // Find the key element
                const keyElement = document.querySelector(`[data-note="${note.replace(/\d+/, '')}"]`);
                playSynthNote(frequency, keyElement, velocity, duration);
            }, time * 1000);
        }

        function scheduleVocals(vocalData, startTime) {
            if (!vocalData.lyrics) return;
            
            vocalData.lyrics.forEach(lyric => {
                setTimeout(() => {
                    document.getElementById('lyricsDisplay').textContent = lyric.text;
                    speakText(lyric.text, vocalData.vocoderSettings);
                }, (startTime + lyric.time) * 1000);
            });
        }

        function updateDrumPattern(patterns) {
            Object.keys(patterns).forEach(track => {
                if (drumPattern[track]) {
                    drumPattern[track] = [...patterns[track]];
                }
            });
            createDrumSequencer();
        }

        function startAutoPlay() {
            if (!autoPlayData || !autoPlayData.automatedSequence) {
                updateStatus('No auto-play song loaded!');
                return;
            }
            
            isAutoPlaying = true;
            autoPlayStartTime = Date.now();
            currentBar = 0;
            
            // Set tempo
            tempo = autoPlayData.tempo;
            document.getElementById('tempoSlider').value = tempo;
            document.getElementById('tempoValue').textContent = tempo;
            
            // Update song info
            document.getElementById('songTitle').textContent = autoPlayData.songTitle || 'Auto-Play Song';
            document.getElementById('autoPlayBtn').textContent = '⏹ STOP AUTO-PLAY';
            document.getElementById('autoPlayBtn').classList.add('playing');
            
            const barDuration = (60 / tempo) * 4; // seconds per bar
            const totalDuration = autoPlayData.totalBars * barDuration;
            
            // Schedule drum sequences
            autoPlayData.automatedSequence.drumSequences.forEach(section => {
                setTimeout(() => {
                    updateDrumPattern(section.patterns);
                    currentSongSection = section.section;
                    document.getElementById('currentSection').textContent = `Section: ${section.section.toUpperCase()}`;
                }, section.startBar * barDuration * 1000);
            });
            
            // Schedule synth sequences
            autoPlayData.automatedSequence.synthSequences.forEach(section => {
                const sectionStartTime = section.startBar * barDuration;
                section.notes.forEach(note => {
                    scheduleAutoPlayNote(
                        sectionStartTime + note.time,
                        note.note,
                        note.duration,
                        note.velocity,
                        section.instrument
                    );
                });
            });
            
            // Schedule vocal sequences
            autoPlayData.automatedSequence.vocalSequences.forEach(section => {
                const sectionStartTime = section.startBar * barDuration;
                scheduleVocals(section, sectionStartTime);
            });
            
            // Schedule sample triggers
            if (autoPlayData.automatedSequence.sampleTriggers) {
                autoPlayData.automatedSequence.sampleTriggers.forEach(trigger => {
                    setTimeout(() => {
                        const pad = document.querySelector(`[data-index="${trigger.padIndex}"]`);
                        if (pad && samples[trigger.padIndex]) {
                            playSample(trigger.padIndex, pad);
                        }
                    }, trigger.time * 1000);
                });
            }
            
            // Schedule effect automation
            if (autoPlayData.automatedSequence.effectAutomation) {
                autoPlayData.automatedSequence.effectAutomation.forEach(automation => {
                    setTimeout(() => {
                        // Update effects
                        Object.keys(automation.effects).forEach(effect => {
                            effectToggles[effect] = automation.effects[effect];
                            const toggle = document.getElementById(`${effect}Toggle`);
                            if (toggle) {
                                if (automation.effects[effect]) {
                                    toggle.classList.add('active');
                                } else {
                                    toggle.classList.remove('active');
                                }
                            }
                        });
                        
                        // Update settings
                        if (automation.settings) {
                            if (automation.settings.autotuneAmount) {
                                document.getElementById('autotuneAmount').textContent = automation.settings.autotuneAmount;
                            }
                            if (automation.settings.reverbAmount) {
                                document.getElementById('reverbAmount').textContent = automation.settings.reverbAmount;
                            }
                            if (automation.settings.delayAmount) {
                                document.getElementById('delayAmount').textContent = automation.settings.delayAmount;
                            }
                            if (automation.settings.filterCutoff) {
                                synthParams.filterCutoff = automation.settings.filterCutoff;
                                document.getElementById('filterCutoff').value = automation.settings.filterCutoff;
                                document.getElementById('filterCutoffValue').textContent = Math.round(automation.settings.filterCutoff);
                            }
                        }
                    }, automation.time * 1000);
                });
            }
            
            // Start regular playback
            start();
            
            // Update progress bar
            const progressInterval = setInterval(() => {
                if (!isAutoPlaying) {
                    clearInterval(progressInterval);
                    return;
                }
                
                const elapsed = (Date.now() - autoPlayStartTime) / 1000;
                const progress = (elapsed / totalDuration) * 100;
                document.getElementById('progressBar').style.width = progress + '%';
                
                const minutes = Math.floor(elapsed / 60);
                const seconds = Math.floor(elapsed % 60);
                const totalMinutes = Math.floor(totalDuration / 60);
                const totalSeconds = Math.floor(totalDuration % 60);
                
                document.getElementById('progressTime').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
                
                if (elapsed >= totalDuration) {
                    stopAutoPlay();
                }
            }, 100);
        }

        function stopAutoPlay() {
            isAutoPlaying = false;
            stop();
            
            document.getElementById('autoPlayBtn').textContent = '▶ START AUTO-PLAY';
            document.getElementById('autoPlayBtn').classList.remove('playing');
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('lyricsDisplay').textContent = '';
            document.getElementById('currentSection').textContent = 'Ready to Play';
            
            // Stop any ongoing speech
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
        }

        // Playback functions
        function playStep() {
            document.querySelectorAll('.current-step').forEach(el => {
                el.classList.remove('current-step');
            });
            
            document.querySelectorAll(`[data-step="${currentStep}"]`).forEach(el => {
                el.classList.add('current-step');
            });
            
            Object.keys(drumPattern).forEach(track => {
                if (drumPattern[track][currentStep]) {
                    drums[track]();
                    const stepEl = document.querySelector(`[data-track="${track}"][data-step="${currentStep}"]`);
                    if (stepEl) {
                        stepEl.classList.add('playing');
                        setTimeout(() => stepEl.classList.remove('playing'), 200);
                    }
                }
            });
            
            currentStep = (currentStep + 1) % 16;
        }

        function start() {
            if (!isPlaying) {
                isPlaying = true;
                const interval = 60000 / (tempo * 4);
                intervalId = setInterval(playStep, interval);
                document.getElementById('playBtn').textContent = '⏸ PAUSE';
            }
        }

        function stop() {
            isPlaying = false;
            currentStep = 0;
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
            document.getElementById('playBtn').textContent = '▶ PLAY';
            document.querySelectorAll('.current-step').forEach(el => {
                el.classList.remove('current-step');
            });
        }

        // Recording functions
        async function startRecording() {
            const stream = audioContext.createMediaStreamDestination();
            masterGain.connect(stream);
            
            recorder = new MediaRecorder(stream.stream);
            recordedChunks = [];
            
            recorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            recorder.onstop = () => {
                recordedBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                document.getElementById('downloadBtn').style.display = 'inline-block';
                updateStatus('Recording saved! Click "Download" to save the file.');
            };
            
            recorder.start();
            isRecording = true;
            document.getElementById('recordBtn').textContent = '⏹ STOP';
            updateStatus('Recording...', true);
        }

        function stopRecording() {
            if (recorder && isRecording) {
                recorder.stop();
                isRecording = false;
                document.getElementById('recordBtn').textContent = '🔴 RECORD';
            }
        }

        function downloadRecording() {
            if (recordedBlob) {
                const url = URL.createObjectURL(recordedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `808s-production-${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Export/Import functions
        async function exportProject() {
            // Gather all data
            const sampleMetadata = samples.map((sample, index) => {
                if (sample) {
                    const pad = document.querySelector(`[data-index="${index}"]`);
                    const name = pad.querySelector('.pad-name').textContent;
                    return {
                        index: index,
                        name: name,
                        hasData: true
                    };
                }
                return null;
            });

            const projectData = {
                version: '3.0',
                timestamp: new Date().toISOString(),
                tempo: tempo,
                masterVolume: document.getElementById('masterVolume').value,
                drumPattern: drumPattern,
                synthParams: synthParams,
                sampleMetadata: sampleMetadata,
                effects: effectToggles,
                effectSettings: {
                    autotune: document.getElementById('autotuneAmount').textContent,
                    reverb: document.getElementById('reverbAmount').textContent,
                    delay: document.getElementById('delayAmount').textContent,
                    distortion: document.getElementById('distortionAmount').textContent
                },
                vocoderSettings: {
                    carrierFreq: document.getElementById('carrierFreq').value,
                    modulation: document.getElementById('vocoderMod').value,
                    bands: document.getElementById('vocoderBands').value,
                    robotVoice: document.getElementById('robotToggle').classList.contains('active')
                }
            };

            // If there's a recorded audio blob, convert it to base64 and include it
            if (recordedBlob) {
                const reader = new FileReader();
                reader.onloadend = () => {
                    projectData.recordedAudio = reader.result;
                    
                    const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `808s-complete-project-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    updateStatus('Complete project exported with audio!');
                };
                reader.readAsDataURL(recordedBlob);
            } else {
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `808s-project-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                updateStatus('Project settings exported!');
            }
        }

        async function importProject(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Check if it's an auto-play song
                    if (data.automatedSequence) {
                        autoPlayData = data;
                        updateStatus('Auto-play song loaded! Go to AUTO-PLAY tab to start.');
                        document.getElementById('songTitle').textContent = data.songTitle || 'Auto-Play Song Loaded';
                        return;
                    }
                    
                    // Regular project import
                    if (data.tempo) {
                        tempo = data.tempo;
                        document.getElementById('tempoSlider').value = tempo;
                        document.getElementById('tempoValue').textContent = tempo;
                    }
                    
                    if (data.masterVolume) {
                        document.getElementById('masterVolume').value = data.masterVolume;
                        document.getElementById('masterVolumeValue').textContent = data.masterVolume;
                        masterGain.gain.value = data.masterVolume / 100;
                    }
                    
                    if (data.drumPattern) {
                        Object.keys(drumPattern).forEach(track => {
                            drumPattern[track].fill(false);
                        });
                        
                        Object.keys(data.drumPattern).forEach(track => {
                            if (drumPattern[track]) {
                                drumPattern[track] = data.drumPattern[track];
                            }
                        });
                        
                        createDrumSequencer();
                    }
                    
                    if (data.synthParams) {
                        Object.assign(synthParams, data.synthParams);
                        document.getElementById('waveform').value = synthParams.waveform;
                        document.getElementById('filterCutoff').value = synthParams.filterCutoff;
                        document.getElementById('filterResonance').value = synthParams.filterResonance;
                        document.getElementById('synthAttack').value = synthParams.attack;
                        document.getElementById('synthDecay').value = synthParams.decay;
                        document.getElementById('synthSustain').value = synthParams.sustain;
                        document.getElementById('synthRelease').value = synthParams.release;
                        document.getElementById('portamento').value = synthParams.portamento || 0;
                        
                        // Update displays
                        document.getElementById('filterCutoffValue').textContent = Math.round(synthParams.filterCutoff);
                        document.getElementById('filterResonanceValue').textContent = synthParams.filterResonance;
                        document.getElementById('synthAttackValue').textContent = synthParams.attack.toFixed(2);
                        document.getElementById('synthDecayValue').textContent = synthParams.decay.toFixed(2);
                        document.getElementById('synthSustainValue').textContent = synthParams.sustain.toFixed(2);
                        document.getElementById('synthReleaseValue').textContent = synthParams.release.toFixed(2);
                        document.getElementById('portamentoValue').textContent = (synthParams.portamento || 0).toFixed(2);
                    }
                    
                    if (data.sampleMetadata) {
                        document.querySelectorAll('.pad-name').forEach(name => {
                            name.textContent = 'EMPTY';
                        });
                        
                        data.sampleMetadata.forEach(meta => {
                            if (meta && meta.hasData) {
                                const pad = document.querySelector(`[data-index="${meta.index}"]`);
                                if (pad) {
                                    const name = pad.querySelector('.pad-name');
                                    name.textContent = meta.name;
                                }
                            }
                        });
                    }
                    
                    if (data.effects) {
                        Object.keys(data.effects).forEach(effect => {
                            const toggle = document.getElementById(`${effect}Toggle`);
                            if (toggle) {
                                effectToggles[effect] = data.effects[effect];
                                if (data.effects[effect]) {
                                    toggle.classList.add('active');
                                } else {
                                    toggle.classList.remove('active');
                                }
                            }
                        });
                    }
                    
                    if (data.effectSettings) {
                        document.getElementById('autotuneAmount').textContent = data.effectSettings.autotune;
                        document.getElementById('reverbAmount').textContent = data.effectSettings.reverb;
                        document.getElementById('delayAmount').textContent = data.effectSettings.delay;
                        document.getElementById('distortionAmount').textContent = data.effectSettings.distortion;
                    }
                    
                    if (data.vocoderSettings) {
                        document.getElementById('carrierFreq').value = data.vocoderSettings.carrierFreq;
                        document.getElementById('vocoderMod').value = data.vocoderSettings.modulation;
                        document.getElementById('vocoderBands').value = data.vocoderSettings.bands;
                        document.getElementById('carrierFreqValue').textContent = data.vocoderSettings.carrierFreq;
                        document.getElementById('vocoderModValue').textContent = data.vocoderSettings.modulation;
                        document.getElementById('vocoderBandsValue').textContent = data.vocoderSettings.bands;
                        
                        const robotToggle = document.getElementById('robotToggle');
                        if (data.vocoderSettings.robotVoice) {
                            robotToggle.classList.add('active');
                        } else {
                            robotToggle.classList.remove('active');
                        }
                    }
                    
                    // Restore recorded audio if present
                    if (data.recordedAudio) {
                        const response = await fetch(data.recordedAudio);
                        recordedBlob = await response.blob();
                        document.getElementById('downloadBtn').style.display = 'inline-block';
                        updateStatus('Project imported successfully with recorded audio!');
                    } else {
                        updateStatus('Project imported successfully!');
                    }
                    
                } catch (error) {
                    updateStatus('Error importing project: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Drum pattern functions
        function exportDrumPattern() {
            const data = {
                tempo: tempo,
                pattern: drumPattern,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `drum-pattern-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            updateStatus('Drum pattern exported successfully!');
        }

        function importDrumPattern(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.tempo) {
                        tempo = data.tempo;
                        document.getElementById('tempoSlider').value = tempo;
                        document.getElementById('tempoValue').textContent = tempo;
                    }
                    
                    if (data.pattern) {
                        Object.keys(data.pattern).forEach(track => {
                            if (drumPattern[track]) {
                                drumPattern[track] = data.pattern[track];
                            }
                        });
                        createDrumSequencer();
                    }
                    
                    updateStatus('Drum pattern imported successfully!');
                } catch (error) {
                    updateStatus('Error importing pattern: Invalid file format');
                }
            };
            reader.readAsText(file);
        }

        function clearDrumPattern() {
            Object.keys(drumPattern).forEach(track => {
                drumPattern[track].fill(false);
            });
            createDrumSequencer();
            updateStatus('Drum pattern cleared');
        }

        function randomizeDrumPattern() {
            // Create a musically sensible random pattern
            Object.keys(drumPattern).forEach(track => {
                drumPattern[track] = drumPattern[track].map((_, i) => {
                    switch(track) {
                        case 'kick':
                            return i % 4 === 0 || (Math.random() > 0.7 && i % 2 === 0);
                        case 'snare':
                            return i % 8 === 4 || (Math.random() > 0.8 && i === 12);
                        case 'hihat':
                            return Math.random() > 0.3;
                        case 'openhat':
                            return Math.random() > 0.85 && i % 2 === 1;
                        case 'clap':
                            return i % 8 === 4 && Math.random() > 0.5;
                        case 'crash':
                            return i === 0 && Math.random() > 0.7;
                        case 'tom':
                            return Math.random() > 0.9;
                        case 'rim':
                            return Math.random() > 0.8 && i % 2 === 1;
                        default:
                            return false;
                    }
                });
            });
            createDrumSequencer();
            updateStatus('Random drum pattern generated!');
        }

        function updateStatus(message, isRecording = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = isRecording ? 'status recording' : 'status';
        }

        // Load demo song
        function loadDemoSong() {
            autoPlayData = {
                "version": "3.0",
                "timestamp": new Date().toISOString(),
                "tempo": 80,
                "masterVolume": "85",
                "songTitle": "Digital Heartbreak (Demo)",
                "totalBars": 48,
                "timeSignature": "4/4",
                "automatedSequence": {
                    "drumSequences": [
                        {
                            "section": "intro",
                            "startBar": 0,
                            "endBar": 4,
                            "patterns": {
                                "kick": [true, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false],
                                "snare": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "hihat": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "openhat": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "clap": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "crash": [true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "tom": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "rim": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false]
                            }
                        },
                        {
                            "section": "verse1",
                            "startBar": 4,
                            "endBar": 12,
                            "patterns": {
                                "kick": [true, false, false, false, true, false, false, false, true, false, false, false, true, false, true, false],
                                "snare": [false, false, false, false, true, false, false, false, false, false, false, false, true, false, false, false],
                                "hihat": [true, true, false, true, true, true, false, true, true, true, false, true, true, true, false, true],
                                "openhat": [false, false, true, false, false, false, true, false, false, false, true, false, false, false, false, false],
                                "clap": [false, false, false, false, true, false, false, false, false, false, false, false, true, false, false, false],
                                "crash": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "tom": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "rim": [false, true, false, false, false, true, false, false, false, true, false, false, false, true, false, false]
                            }
                        },
                        {
                            "section": "chorus",
                            "startBar": 16,
                            "endBar": 24,
                            "patterns": {
                                "kick": [true, false, false, true, true, false, false, false, true, false, false, true, true, false, true, false],
                                "snare": [false, false, false, false, true, false, false, true, false, false, false, false, true, false, false, false],
                                "hihat": [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true],
                                "openhat": [false, false, false, false, false, false, true, false, false, false, false, false, false, false, true, false],
                                "clap": [false, false, false, false, true, false, false, true, false, false, false, false, true, false, false, true],
                                "crash": [true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false],
                                "tom": [false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false],
                                "rim": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false]
                            }
                        }
                    ],
                    "synthSequences": [
                        {
                            "section": "verse1_bass",
                            "startBar": 4,
                            "endBar": 12,
                            "instrument": "bass",
                            "notes": [
                                {"time": 0, "note": "C2", "duration": 1.0, "velocity": 0.8},
                                {"time": 1, "note": "C2", "duration": 0.5, "velocity": 0.7},
                                {"time": 2, "note": "G1", "duration": 1.0, "velocity": 0.8},
                                {"time": 3, "note": "G1", "duration": 0.5, "velocity": 0.7},
                                {"time": 4, "note": "A#1", "duration": 1.0, "velocity": 0.8},
                                {"time": 5, "note": "A#1", "duration": 0.5, "velocity": 0.7},
                                {"time": 6, "note": "F1", "duration": 1.0, "velocity": 0.8},
                                {"time": 7, "note": "F1", "duration": 0.5, "velocity": 0.7}
                            ]
                        },
                        {
                            "section": "chorus_lead",
                            "startBar": 16,
                            "endBar": 24,
                            "instrument": "lead",
                            "notes": [
                                {"time": 0, "note": "C4", "duration": 0.5, "velocity": 0.6},
                                {"time": 0.75, "note": "D#4", "duration": 0.5, "velocity": 0.6},
                                {"time": 1.5, "note": "F4", "duration": 0.75, "velocity": 0.7},
                                {"time": 2.5, "note": "G4", "duration": 1.0, "velocity": 0.8},
                                {"time": 4, "note": "F4", "duration": 0.5, "velocity": 0.7},
                                {"time": 4.75, "note": "D#4", "duration": 0.5, "velocity": 0.6},
                                {"time": 5.5, "note": "C4", "duration": 0.75, "velocity": 0.6},
                                {"time": 6.5, "note": "A#3", "duration": 1.0, "velocity": 0.8}
                            ]
                        }
                    ],
                    "vocalSequences": [
                        {
                            "section": "intro_vocal",
                            "startBar": 2,
                            "endBar": 4,
                            "type": "speech",
                            "lyrics": [
                                {"time": 0, "text": "Yeah...", "duration": 1},
                                {"time": 1.5, "text": "Oh...", "duration": 1}
                            ],
                            "vocoderSettings": {
                                "pitch": 0.8,
                                "rate": 0.7,
                                "robotEffect": true
                            }
                        },
                        {
                            "section": "verse1_vocal",
                            "startBar": 4,
                            "endBar": 12,
                            "type": "speech",
                            "lyrics": [
                                {"time": 0, "text": "Lost in the city lights", "duration": 2},
                                {"time": 2.5, "text": "Can't find my way back home", "duration": 2},
                                {"time": 5, "text": "Digital love gone cold", "duration": 2},
                                {"time": 7.5, "text": "Now I'm all alone", "duration": 2}
                            ],
                            "vocoderSettings": {
                                "pitch": 0.9,
                                "rate": 0.8,
                                "robotEffect": true
                            }
                        },
                        {
                            "section": "chorus_vocal",
                            "startBar": 16,
                            "endBar": 24,
                            "type": "speech",
                            "lyrics": [
                                {"time": 0, "text": "Eight oh eight heartbreak", "duration": 1.5},
                                {"time": 2, "text": "Can't escape this pain", "duration": 1.5},
                                {"time": 4, "text": "Eight oh eight heartbreak", "duration": 1.5},
                                {"time": 6, "text": "Driving me insane", "duration": 1.5}
                            ],
                            "vocoderSettings": {
                                "pitch": 1.0,
                                "rate": 0.9,
                                "robotEffect": true
                            }
                        }
                    ],
                    "effectAutomation": [
                        {
                            "time": 0,
                            "effects": {
                                "autotune": true,
                                "reverb": true,
                                "delay": false,
                                "distortion": false
                            },
                            "settings": {
                                "autotuneAmount": "50",
                                "reverbAmount": "30",
                                "delayAmount": "0",
                                "filterCutoff": 500
                            }
                        },
                        {
                            "time": 16,
                            "effects": {
                                "autotune": true,
                                "reverb": true,
                                "delay": true,
                                "distortion": false
                            },
                            "settings": {
                                "autotuneAmount": "75",
                                "reverbAmount": "45",
                                "delayAmount": "30",
                                "filterCutoff": 1500
                            }
                        }
                    ]
                }
            };
            
            updateStatus('Demo song loaded! Click "START AUTO-PLAY" to begin.');
            document.getElementById('songTitle').textContent = 'Digital Heartbreak (Demo)';
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            if (isPlaying) {
                stop();
            } else {
                start();
            }
        });

        document.getElementById('stopBtn').addEventListener('click', stop);

        document.getElementById('recordBtn').addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        document.getElementById('downloadBtn').addEventListener('click', downloadRecording);

        document.getElementById('clearDrumBtn').addEventListener('click', clearDrumPattern);
        document.getElementById('randomizeBtn').addEventListener('click', randomizeDrumPattern);
        document.getElementById('exportDrumBtn').addEventListener('click', exportDrumPattern);
        
        document.getElementById('importDrumPattern').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importDrumPattern(e.target.files[0]);
            }
        });

        document.getElementById('exportProjectBtn').addEventListener('click', exportProject);
        
        document.getElementById('importProject').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importProject(e.target.files[0]);
            }
        });

        document.getElementById('importAutoSong').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importProject(e.target.files[0]);
            }
        });

        document.getElementById('loadDemoSongBtn').addEventListener('click', loadDemoSong);

        document.getElementById('autoPlayBtn').addEventListener('click', () => {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        });

        document.getElementById('tempoSlider').addEventListener('input', (e) => {
            tempo = parseInt(e.target.value);
            document.getElementById('tempoValue').textContent = tempo;
            
            if (isPlaying) {
                stop();
                start();
            }
        });

        document.getElementById('masterVolume').addEventListener('input', (e) => {
            const value = parseInt(e.target.value) / 100;
            masterGain.gain.value = value;
            document.getElementById('masterVolumeValue').textContent = e.target.value;
        });

        // Initialize
        createDrumSequencer();
        createKeyboard();
        createSamplePads();
        setupEffects();

        // Set default drum pattern
        drumPattern.kick[0] = true;
        drumPattern.kick[4] = true;
        drumPattern.kick[8] = true;
        drumPattern.kick[12] = true;
        drumPattern.snare[4] = true;
        drumPattern.snare[12] = true;
        drumPattern.hihat[2] = true;
        drumPattern.hihat[6] = true;
        drumPattern.hihat[10] = true;
        drumPattern.hihat[14] = true;

        createDrumSequencer();

        updateStatus('Welcome to 808s Production Suite! Start creating or load a demo song.');
    </script>
</body>
</html>