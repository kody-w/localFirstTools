<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>NASCAR Wrong Way Racing - Daytona Chaos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            touch-action: none;
        }

        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #ff6600;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }

        #speed {
            font-size: 48px;
            color: #ffcc00;
            display: block;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 3px solid #ff6600;
            font-size: 20px;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }

        #crashes {
            color: #ff6600;
            font-weight: bold;
        }

        #lap {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 3px solid #00ff00;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        #wrongWayWarning {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: #ff0000;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            animation: flash 0.5s infinite;
            pointer-events: none;
        }

        @keyframes flash {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            pointer-events: auto;
            border: 4px solid #ff6600;
            box-shadow: 0 0 40px rgba(255, 102, 0, 0.8);
        }

        #gameOver h1 {
            color: #ff6600;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
        }

        button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: #ff8833;
            transform: scale(1.05);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            border: 2px solid #ffcc00;
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            pointer-events: none;
            display: none;
        }

        @media (max-width: 768px), (orientation: portrait) {
            #mobileControls {
                display: block;
                pointer-events: auto;
            }
            
            #instructions {
                display: none;
            }
            
            #score {
                font-size: 16px;
                padding: 10px 15px;
            }
            
            #lap {
                font-size: 18px;
                padding: 10px 15px;
            }
            
            #speedometer {
                font-size: 16px;
                padding: 15px;
                bottom: 220px;
            }
            
            #speed {
                font-size: 32px;
            }
            
            #wrongWayWarning {
                font-size: 36px;
            }
        }

        .control-button {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .control-button:active {
            background: rgba(255, 102, 0, 0.5);
            transform: scale(0.95);
        }

        #leftBtn {
            width: 80px;
            height: 80px;
            bottom: 60px;
            left: 20px;
        }

        #rightBtn {
            width: 80px;
            height: 80px;
            bottom: 60px;
            left: 120px;
        }

        #gasBtn {
            width: 100px;
            height: 100px;
            bottom: 50px;
            right: 20px;
        }

        #brakeBtn {
            width: 60px;
            height: 60px;
            bottom: 20px;
            right: 140px;
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.6);
        }

        #brakeBtn:active {
            background: rgba(255, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameUI">
        <div id="wrongWayWarning">‚ö†Ô∏è WRONG WAY! ‚ö†Ô∏è</div>
        <div id="score">
            Score: <span id="scoreValue">0</span><br>
            Crashes: <span id="crashes">0</span><br>
            Near Misses: <span id="nearMisses">0</span>
        </div>
        <div id="lap">
            LAP <span id="lapNumber">1</span> / 10<br>
            <span style="font-size: 16px; color: #ffcc00;">WRONG WAY!</span>
        </div>
        <div id="speedometer">
            <span id="speed">0</span>
            MPH
        </div>
        <div id="instructions">
            <span style="color: #ff6600;">üèÅ DAYTONA DESTRUCTION üèÅ</span><br>
            Arrow Keys/WASD + Space to brake<br>
            Cause maximum chaos!
        </div>
        <div id="mobileControls">
            <div id="leftBtn" class="control-button">‚Üê</div>
            <div id="rightBtn" class="control-button">‚Üí</div>
            <div id="gasBtn" class="control-button">GAS</div>
            <div id="brakeBtn" class="control-button">!</div>
        </div>
        <div id="gameOver">
            <h1>RACE DESTROYED!</h1>
            <p style="color: #ff6600; font-style: italic;">"The Intimidator" lived up to his name!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Total Crashes: <span id="finalCrashes">0</span></p>
            <button onclick="location.reload()">Race Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87CEEB);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x808080);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // Track parameters
        const TRACK_WIDTH = 50;
        const TRACK_LENGTH = 400;
        const TURN_RADIUS = 120;
        
        // Create banked oval track
        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Track material
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x00aa00 });
            
            // Create track segments
            const segments = 64;
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const nextAngle = ((i + 1) / segments) * Math.PI * 2;
                
                // Calculate positions
                let x1, z1, x2, z2, y = 0, rotation = 0, banking = 0;
                
                if (angle < Math.PI * 0.25 || angle > Math.PI * 1.75) {
                    // Front straight
                    x1 = TRACK_LENGTH / 2;
                    x2 = TRACK_LENGTH / 2;
                    z1 = Math.sin(angle) * TURN_RADIUS;
                    z2 = Math.sin(nextAngle) * TURN_RADIUS;
                    rotation = 0;
                } else if (angle < Math.PI * 0.75) {
                    // Turn 1
                    x1 = Math.cos(angle - Math.PI * 0.25) * TURN_RADIUS + TRACK_LENGTH / 2;
                    x2 = Math.cos(nextAngle - Math.PI * 0.25) * TURN_RADIUS + TRACK_LENGTH / 2;
                    z1 = Math.sin(angle - Math.PI * 0.25) * TURN_RADIUS;
                    z2 = Math.sin(nextAngle - Math.PI * 0.25) * TURN_RADIUS;
                    rotation = angle - Math.PI * 0.25;
                    banking = 0.3;
                    y = Math.abs(Math.sin(angle * 2)) * 5;
                } else if (angle < Math.PI * 1.25) {
                    // Back straight
                    x1 = -TRACK_LENGTH / 2;
                    x2 = -TRACK_LENGTH / 2;
                    z1 = -Math.sin(angle) * TURN_RADIUS;
                    z2 = -Math.sin(nextAngle) * TURN_RADIUS;
                    rotation = Math.PI;
                } else {
                    // Turn 2
                    x1 = -Math.cos(angle - Math.PI * 1.25) * TURN_RADIUS - TRACK_LENGTH / 2;
                    x2 = -Math.cos(nextAngle - Math.PI * 1.25) * TURN_RADIUS - TRACK_LENGTH / 2;
                    z1 = -Math.sin(angle - Math.PI * 1.25) * TURN_RADIUS;
                    z2 = -Math.sin(nextAngle - Math.PI * 1.25) * TURN_RADIUS;
                    rotation = angle - Math.PI * 1.25 + Math.PI;
                    banking = -0.3;
                    y = Math.abs(Math.sin(angle * 2)) * 5;
                }
                
                // Create track segment
                const segmentGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, TURN_RADIUS * Math.PI * 2 / segments);
                const segment = new THREE.Mesh(segmentGeometry, trackMaterial);
                segment.position.x = (x1 + x2) / 2;
                segment.position.z = (z1 + z2) / 2;
                segment.position.y = y;
                segment.rotation.x = -Math.PI / 2;
                segment.rotation.z = banking;
                segment.lookAt(x2, y, z2);
                segment.rotateX(-Math.PI / 2);
                segment.receiveShadow = true;
                trackGroup.add(segment);
                
                // Add lane lines
                if (i % 4 === 0) {
                    for (let lane = -1; lane <= 1; lane++) {
                        if (lane === 0) continue;
                        const lineGeometry = new THREE.PlaneGeometry(1, TURN_RADIUS * Math.PI * 2 / segments);
                        const line = new THREE.Mesh(lineGeometry, lineMaterial);
                        line.position.x = (x1 + x2) / 2 + Math.sin(rotation) * lane * TRACK_WIDTH / 3;
                        line.position.z = (z1 + z2) / 2 + Math.cos(rotation) * lane * TRACK_WIDTH / 3;
                        line.position.y = y + 0.1;
                        line.rotation.x = -Math.PI / 2;
                        line.rotation.z = banking;
                        line.lookAt(x2 + Math.sin(rotation) * lane * TRACK_WIDTH / 3, y, z2 + Math.cos(rotation) * lane * TRACK_WIDTH / 3);
                        line.rotateX(-Math.PI / 2);
                        trackGroup.add(line);
                    }
                }
            }
            
            // Infield
            const infieldGeometry = new THREE.PlaneGeometry(TRACK_LENGTH, TURN_RADIUS * 2);
            const infield = new THREE.Mesh(infieldGeometry, grassMaterial);
            infield.rotation.x = -Math.PI / 2;
            infield.position.y = -0.5;
            infield.receiveShadow = true;
            trackGroup.add(infield);
            
            // Walls
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const wallHeight = 5;
            
            // Create walls around track
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const wallGeometry = new THREE.BoxGeometry(2, wallHeight, TURN_RADIUS * Math.PI * 2 / segments);
                
                // Outer wall
                const outerWall = new THREE.Mesh(wallGeometry, wallMaterial);
                let x, z;
                if (angle < Math.PI * 0.25 || angle > Math.PI * 1.75) {
                    x = TRACK_LENGTH / 2 + TRACK_WIDTH / 2 + 2;
                    z = Math.sin(angle) * TURN_RADIUS;
                } else if (angle < Math.PI * 0.75) {
                    x = Math.cos(angle - Math.PI * 0.25) * (TURN_RADIUS + TRACK_WIDTH / 2 + 2) + TRACK_LENGTH / 2;
                    z = Math.sin(angle - Math.PI * 0.25) * (TURN_RADIUS + TRACK_WIDTH / 2 + 2);
                } else if (angle < Math.PI * 1.25) {
                    x = -TRACK_LENGTH / 2 - TRACK_WIDTH / 2 - 2;
                    z = -Math.sin(angle) * TURN_RADIUS;
                } else {
                    x = -Math.cos(angle - Math.PI * 1.25) * (TURN_RADIUS + TRACK_WIDTH / 2 + 2) - TRACK_LENGTH / 2;
                    z = -Math.sin(angle - Math.PI * 1.25) * (TURN_RADIUS + TRACK_WIDTH / 2 + 2);
                }
                outerWall.position.set(x, wallHeight / 2, z);
                outerWall.lookAt(0, wallHeight / 2, 0);
                outerWall.castShadow = true;
                trackGroup.add(outerWall);
            }
            
            return trackGroup;
        }
        
        const track = createTrack();
        scene.add(track);

        // Simple car creation function
        function createCar(color, number, isPlayer = false) {
            const carGroup = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.BoxGeometry(4, 2, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            body.receiveShadow = true;
            carGroup.add(body);
            
            // Roof
            const roofGeometry = new THREE.BoxGeometry(3.5, 1.5, 6);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.y = 2.5;
            roof.castShadow = true;
            carGroup.add(roof);
            
            // Windshield
            const windshieldGeometry = new THREE.PlaneGeometry(3, 1.2);
            const windshieldMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4444ff, 
                transparent: true, 
                opacity: 0.7 
            });
            const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
            windshield.position.set(0, 2.5, 3);
            windshield.rotation.x = -0.3;
            carGroup.add(windshield);
            
            // Spoiler
            const spoilerGeometry = new THREE.BoxGeometry(3.5, 0.8, 0.3);
            const spoilerMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
            spoiler.position.set(0, 3, -3.5);
            spoiler.castShadow = true;
            carGroup.add(spoiler);
            
            // Number decals - simple colored boxes for now
            const numberGeometry = new THREE.BoxGeometry(2, 2, 0.1);
            const numberMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const leftNumber = new THREE.Mesh(numberGeometry, numberMaterial);
            leftNumber.position.set(-2.05, 1.5, 0);
            carGroup.add(leftNumber);
            
            const rightNumber = new THREE.Mesh(numberGeometry, numberMaterial);
            rightNumber.position.set(2.05, 1.5, 0);
            carGroup.add(rightNumber);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.4, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            
            const wheelPositions = [
                [-1.8, 0.4, 2.5],
                [1.8, 0.4, 2.5],
                [-1.8, 0.4, -2.5],
                [1.8, 0.4, -2.5]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...pos);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
            });
            
            // Headlights for player
            if (isPlayer) {
                const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                const headlightGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
                
                const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                leftHeadlight.position.set(-1.2, 0.8, 4.01);
                carGroup.add(leftHeadlight);
                
                const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                rightHeadlight.position.set(1.2, 0.8, 4.01);
                carGroup.add(rightHeadlight);
            }
            
            return carGroup;
        }

        // Car class
        class RaceCar {
            constructor(number, color, x, z, isPlayer = false) {
                this.number = number;
                this.isPlayer = isPlayer;
                this.crashed = false;
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.angularVelocity = 0;
                this.speed = isPlayer ? 0 : 170 + Math.random() * 30;
                this.targetSpeed = this.speed;
                this.trackPosition = 0;
                this.laneOffset = (Math.random() - 0.5) * 20;
                
                this.group = createCar(color, number, isPlayer);
                this.group.position.set(x, 0, z);
                if (isPlayer) {
                    this.group.rotation.y = Math.PI; // Face backwards
                }
                scene.add(this.group);
            }
            
            update(deltaTime) {
                if (this.crashed) {
                    this.velocity.y -= 20 * deltaTime;
                    this.group.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    this.group.rotation.y += this.angularVelocity * deltaTime;
                    this.group.rotation.x += this.angularVelocity * 0.5 * deltaTime;
                    this.group.rotation.z += this.angularVelocity * 0.3 * deltaTime;
                    this.angularVelocity *= 0.95;
                    
                    if (this.group.position.y < -20) {
                        scene.remove(this.group);
                        return false;
                    }
                }
                return true;
            }
            
            crash(force) {
                if (this.crashed) return;
                this.crashed = true;
                this.velocity.x = force.x * 30;
                this.velocity.y = 20 + Math.random() * 10;
                this.velocity.z = force.z * 30;
                this.angularVelocity = (Math.random() - 0.5) * 10;
            }
        }

        // NASCAR colors
        const carColors = [
            { num: '48', color: 0x0066ff },
            { num: '24', color: 0xff0000 },
            { num: '88', color: 0x00aa00 },
            { num: '18', color: 0xffaa00 },
            { num: '20', color: 0xffa500 },
            { num: '99', color: 0x0000ff },
            { num: '14', color: 0xff6600 },
            { num: '2', color: 0x0099ff },
            { num: '11', color: 0xff0000 },
            { num: '17', color: 0xffff00 }
        ];

        // Player car
        const playerCar = new RaceCar('3', 0x000000, 0, 0, true);
        let playerSpeed = 0;
        let playerSteering = 0;

        // AI cars
        const raceCars = [];
        
        // Create initial pack
        function spawnPack() {
            const packSize = 6;
            const startZ = -TURN_RADIUS - 100;
            
            for (let i = 0; i < packSize; i++) {
                const row = Math.floor(i / 3);
                const col = i % 3;
                const carData = carColors[i % carColors.length];
                
                const car = new RaceCar(
                    carData.num,
                    carData.color,
                    TRACK_LENGTH/2 + (col - 1) * 12,
                    startZ - row * 15
                );
                car.trackPosition = Math.PI * 2 - 0.5; // Start them coming around turn
                raceCars.push(car);
            }
        }

        // Game variables
        let score = 0;
        let crashes = 0;
        let nearMisses = 0;
        let gameRunning = true;
        let playerLap = 1;
        let playerTrackPosition = 0;

        // Controls
        const keys = {};
        const touches = {
            left: false,
            right: false,
            gas: false,
            brake: false
        };

        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Mobile controls
        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const gasBtn = document.getElementById('gasBtn');
            const brakeBtn = document.getElementById('brakeBtn');

            leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touches.left = true; });
            leftBtn.addEventListener('touchend', () => touches.left = false);
            
            rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touches.right = true; });
            rightBtn.addEventListener('touchend', () => touches.right = false);
            
            gasBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touches.gas = true; });
            gasBtn.addEventListener('touchend', () => touches.gas = false);
            
            brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touches.brake = true; });
            brakeBtn.addEventListener('touchend', () => touches.brake = false);
        }

        setupMobileControls();

        // Collision detection
        function checkCollision(car1, car2) {
            const dist = car1.group.position.distanceTo(car2.group.position);
            return dist < 10;
        }

        // Create crash effect
        function createCrashEffect(position) {
            const particleCount = 30;
            
            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 2 + 0.5;
                const geometry = new THREE.BoxGeometry(size, size, size);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.5) 
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 40,
                    Math.random() * 30,
                    (Math.random() - 0.5) * 40
                );
                
                scene.add(particle);
                
                // Animate
                let lifetime = 2;
                const animate = () => {
                    lifetime -= 0.02;
                    if (lifetime <= 0) {
                        scene.remove(particle);
                        return;
                    }
                    particle.position.add(velocity.clone().multiplyScalar(0.02));
                    velocity.y -= 0.8;
                    particle.rotation.x += 0.1;
                    particle.rotation.y += 0.1;
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        // Update track position
        function getTrackPositionFromCoords(x, z) {
            // Calculate angle around track
            if (Math.abs(x) > TRACK_LENGTH / 2 - 20) {
                // On a straight
                if (x > 0) {
                    // Front straight
                    const progress = (z + TURN_RADIUS) / (TURN_RADIUS * 2);
                    return progress * Math.PI * 0.5;
                } else {
                    // Back straight
                    const progress = (TURN_RADIUS - z) / (TURN_RADIUS * 2);
                    return Math.PI + progress * Math.PI * 0.5;
                }
            } else {
                // In a turn
                if (z > 0) {
                    // Turn 1
                    const angle = Math.atan2(z, x - TRACK_LENGTH/2);
                    return Math.PI * 0.25 + (angle + Math.PI/2) * 0.5;
                } else {
                    // Turn 2
                    const angle = Math.atan2(-z, -x - TRACK_LENGTH/2);
                    return Math.PI * 1.25 + (angle + Math.PI/2) * 0.5;
                }
            }
        }

        function getCoordsFromTrackPosition(position, laneOffset = 0) {
            const angle = position % (Math.PI * 2);
            let x, z, rotation;
            
            if (angle < Math.PI * 0.25 || angle > Math.PI * 1.75) {
                // Front straight
                x = TRACK_LENGTH / 2 + laneOffset;
                z = Math.sin(angle * 4) * TURN_RADIUS;
                rotation = 0;
            } else if (angle < Math.PI * 0.75) {
                // Turn 1
                const turnAngle = (angle - Math.PI * 0.25) * 2;
                x = Math.cos(turnAngle) * (TURN_RADIUS - laneOffset) + TRACK_LENGTH / 2;
                z = Math.sin(turnAngle) * (TURN_RADIUS - laneOffset);
                rotation = turnAngle + Math.PI / 2;
            } else if (angle < Math.PI * 1.25) {
                // Back straight
                x = -TRACK_LENGTH / 2 - laneOffset;
                z = -Math.sin(angle * 4) * TURN_RADIUS;
                rotation = Math.PI;
            } else {
                // Turn 2
                const turnAngle = (angle - Math.PI * 1.25) * 2;
                x = -Math.cos(turnAngle) * (TURN_RADIUS + laneOffset) - TRACK_LENGTH / 2;
                z = -Math.sin(turnAngle) * (TURN_RADIUS + laneOffset);
                rotation = -turnAngle - Math.PI / 2;
            }
            
            return { x, z, rotation };
        }

        // Main game loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameRunning) return;
            
            const deltaTime = 0.016;
            
            // Update player controls
            if (keys['arrowup'] || keys['w'] || touches.gas) {
                playerSpeed = Math.min(playerSpeed + 2, 200);
            } else {
                playerSpeed = Math.max(playerSpeed - 1, 0);
            }
            
            if (keys['arrowleft'] || keys['a'] || touches.left) {
                playerSteering = Math.min(playerSteering + 0.05, 0.4);
            } else if (keys['arrowright'] || keys['d'] || touches.right) {
                playerSteering = Math.max(playerSteering - 0.05, -0.4);
            } else {
                playerSteering *= 0.9;
            }
            
            if (keys[' '] || touches.brake) {
                playerSpeed = Math.max(playerSpeed - 4, 0);
            }
            
            // Update player position (WRONG WAY)
            if (!playerCar.crashed) {
                // Move backwards around track
                playerTrackPosition -= playerSpeed * deltaTime * 0.002;
                if (playerTrackPosition < 0) {
                    playerTrackPosition += Math.PI * 2;
                    playerLap++;
                    score += 1000;
                }
                
                // Get position on track with steering offset
                const laneOffset = playerSteering * 15;
                const pos = getCoordsFromTrackPosition(playerTrackPosition, laneOffset);
                
                playerCar.group.position.x = pos.x;
                playerCar.group.position.z = pos.z;
                playerCar.group.rotation.y = pos.rotation + Math.PI; // Face backwards
                
                // Banking in turns
                const angle = playerTrackPosition % (Math.PI * 2);
                if ((angle > Math.PI * 0.25 && angle < Math.PI * 0.75) || 
                    (angle > Math.PI * 1.25 && angle < Math.PI * 1.75)) {
                    playerCar.group.position.y = 3;
                    playerCar.group.rotation.z = playerSteering * 0.3;
                } else {
                    playerCar.group.position.y = 0;
                    playerCar.group.rotation.z = 0;
                }
            }
            
            // Update AI cars
            for (let i = raceCars.length - 1; i >= 0; i--) {
                const car = raceCars[i];
                
                if (!car.crashed) {
                    // Move forward around track
                    car.trackPosition += car.speed * deltaTime * 0.002;
                    if (car.trackPosition > Math.PI * 2) {
                        car.trackPosition -= Math.PI * 2;
                    }
                    
                    // AI avoidance
                    const playerDist = car.group.position.distanceTo(playerCar.group.position);
                    if (playerDist < 50 && !playerCar.crashed) {
                        // Try to dodge
                        const dodge = Math.sign(car.laneOffset) || 1;
                        car.laneOffset = dodge * 20;
                        car.speed = Math.max(car.speed - 20, 140);
                    } else {
                        // Return to racing line
                        car.laneOffset *= 0.95;
                        car.speed += (car.targetSpeed - car.speed) * 0.02;
                    }
                    
                    // Get position on track
                    const pos = getCoordsFromTrackPosition(car.trackPosition, car.laneOffset);
                    car.group.position.x = pos.x;
                    car.group.position.z = pos.z;
                    car.group.rotation.y = pos.rotation;
                    
                    // Banking
                    const angle = car.trackPosition % (Math.PI * 2);
                    if ((angle > Math.PI * 0.25 && angle < Math.PI * 0.75) || 
                        (angle > Math.PI * 1.25 && angle < Math.PI * 1.75)) {
                        car.group.position.y = 3;
                        car.group.rotation.z = -Math.sign(car.laneOffset) * 0.2;
                    } else {
                        car.group.position.y = 0;
                        car.group.rotation.z = 0;
                    }
                    
                    // Check collision
                    if (checkCollision(playerCar, car) && !playerCar.crashed) {
                        const force = playerCar.group.position.clone().sub(car.group.position).normalize();
                        car.crash(force);
                        createCrashEffect(car.group.position);
                        score += 300;
                        crashes++;
                        
                        // Chain reaction
                        for (const otherCar of raceCars) {
                            if (otherCar !== car && !otherCar.crashed) {
                                const dist = car.group.position.distanceTo(otherCar.group.position);
                                if (dist < 20) {
                                    const chainForce = car.group.position.clone().sub(otherCar.group.position).normalize();
                                    otherCar.crash(chainForce);
                                    createCrashEffect(otherCar.group.position);
                                    score += 150;
                                }
                            }
                        }
                        
                        // Camera shake
                        camera.position.x += (Math.random() - 0.5) * 10;
                        camera.position.y += (Math.random() - 0.5) * 10;
                        camera.position.z += (Math.random() - 0.5) * 10;
                    }
                    
                    // Near miss
                    if (playerDist < 15 && !car.wasCounted && !playerCar.crashed) {
                        car.wasCounted = true;
                        nearMisses++;
                        score += 50;
                    }
                }
                
                if (!car.update(deltaTime)) {
                    raceCars.splice(i, 1);
                }
            }
            
            // Spawn new cars
            if (raceCars.length < 10 && Math.random() < 0.02) {
                const carData = carColors[Math.floor(Math.random() * carColors.length)];
                const spawnPos = getCoordsFromTrackPosition(playerTrackPosition + Math.PI, (Math.random() - 0.5) * 20);
                const car = new RaceCar(
                    carData.num,
                    carData.color,
                    spawnPos.x,
                    spawnPos.z
                );
                car.trackPosition = playerTrackPosition + Math.PI;
                raceCars.push(car);
            }
            
            // Camera follow
            const cameraDistance = 30 + playerSpeed * 0.1;
            const cameraHeight = 15 + playerSpeed * 0.05;
            
            const cameraAngle = playerCar.group.rotation.y + Math.PI;
            camera.position.x = playerCar.group.position.x + Math.sin(cameraAngle) * cameraDistance;
            camera.position.y = playerCar.group.position.y + cameraHeight;
            camera.position.z = playerCar.group.position.z + Math.cos(cameraAngle) * cameraDistance;
            
            camera.lookAt(
                playerCar.group.position.x,
                playerCar.group.position.y + 2,
                playerCar.group.position.z
            );
            
            // Update UI
            document.getElementById('speed').textContent = Math.floor(playerSpeed);
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('crashes').textContent = crashes;
            document.getElementById('nearMisses').textContent = nearMisses;
            document.getElementById('lapNumber').textContent = playerLap;
            
            // Update player car
            playerCar.update(deltaTime);
            
            // Check game over
            if (playerCar.crashed) {
                gameOver();
            }
            
            // Render
            renderer.render(scene, camera);
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalCrashes').textContent = crashes;
            document.getElementById('wrongWayWarning').style.display = 'none';
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start game
        spawnPack();
        animate();
    </script>
</body>
</html>