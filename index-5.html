<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defender - Xbox Controller Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(to bottom, #000000, #0a0a1a);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: white;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #000000 100%);
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .stat {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }

        .stat-label {
            color: #00ffff;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #ffffff;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .title {
            font-size: 72px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 30px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        .subtitle {
            font-size: 24px;
            color: #ffffff;
            margin-bottom: 50px;
            text-align: center;
        }

        .controls {
            background: rgba(0, 100, 100, 0.3);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            margin: 20px;
            max-width: 600px;
        }

        .control-item {
            font-size: 20px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-button {
            background: #00ffff;
            color: #000;
            padding: 8px 16px;
            border-radius: 5px;
            font-weight: bold;
            min-width: 120px;
            text-align: center;
        }

        .button {
            background: linear-gradient(to bottom, #00ffff, #0088ff);
            color: #000;
            border: none;
            padding: 20px 50px;
            font-size: 28px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            text-transform: uppercase;
            box-shadow: 0 0 20px #00ffff;
            transition: all 0.3s;
            animation: buttonPulse 2s ease-in-out infinite;
        }

        @keyframes buttonPulse {
            0%, 100% { box-shadow: 0 0 20px #00ffff; }
            50% { box-shadow: 0 0 40px #00ffff, 0 0 60px #00ffff; }
        }

        .button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px #00ffff;
        }

        .score-display {
            font-size: 48px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            margin: 20px 0;
        }

        .wave-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 96px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 30px #00ffff;
            pointer-events: none;
            animation: waveZoom 2s ease-out forwards;
            z-index: 50;
        }

        @keyframes waveZoom {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        .hidden {
            display: none !important;
        }

        #healthBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 15px;
            overflow: hidden;
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff6600, #00ff00);
            transition: width 0.3s;
            box-shadow: 0 0 20px #00ff00;
        }

        .combo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            pointer-events: none;
            animation: comboFloat 1s ease-out forwards;
            z-index: 50;
        }

        @keyframes comboFloat {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -200%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="stat">
            <div class="stat-label">SCORE</div>
            <div class="stat-value" id="scoreDisplay">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">WAVE</div>
            <div class="stat-value" id="waveDisplay">1</div>
        </div>
        <div class="stat">
            <div class="stat-label">COMBO</div>
            <div class="stat-value" id="comboDisplay">0</div>
        </div>
    </div>

    <div id="healthBar">
        <div id="healthFill" style="width: 100%;"></div>
    </div>

    <div id="startScreen">
        <div class="title">SPACE DEFENDER</div>
        <div class="subtitle">Protect Earth from the alien invasion!</div>
        <div class="controls">
            <div class="control-item">
                <div class="control-button">Left Stick</div>
                <span>Move Ship</span>
            </div>
            <div class="control-item">
                <div class="control-button">Right Trigger</div>
                <span>Shoot</span>
            </div>
            <div class="control-item">
                <div class="control-button">A Button</div>
                <span>Special Weapon</span>
            </div>
            <div class="control-item">
                <div class="control-button">B Button</div>
                <span>Shield Boost</span>
            </div>
        </div>
        <button class="button" onclick="startGame()">START GAME</button>
    </div>

    <div id="gameOverScreen" class="hidden">
        <div class="title">GAME OVER</div>
        <div class="score-display">FINAL SCORE: <span id="finalScore">0</span></div>
        <div class="subtitle">You survived <span id="finalWave">0</span> waves</div>
        <button class="button" onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game state
        let gameRunning = false;
        let score = 0;
        let wave = 1;
        let combo = 0;
        let comboTimer = 0;
        let lastTime = 0;

        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: 40,
            height: 40,
            speed: 6,
            health: 100,
            maxHealth: 100,
            vx: 0,
            vy: 0,
            shootCooldown: 0,
            specialCooldown: 0,
            shieldCooldown: 0,
            hasShield: false,
            shieldDuration: 0
        };

        // Arrays for game objects
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerUps = [];
        let enemyBullets = [];

        // Gamepad state
        let gamepad = null;
        let gamepadIndex = null;

        // Audio context for sound effects
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Sound effects
        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function shootSound() {
            playSound(300, 0.1, 'square');
        }

        function explosionSound() {
            playSound(100, 0.3, 'sawtooth');
        }

        function powerUpSound() {
            playSound(800, 0.2, 'sine');
        }

        function hitSound() {
            playSound(150, 0.2, 'triangle');
        }

        // Gamepad detection
        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad);
            gamepad = e.gamepad;
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected');
            gamepad = null;
            gamepadIndex = null;
        });

        function getGamepad() {
            const gamepads = navigator.getGamepads();
            if (gamepadIndex !== null && gamepads[gamepadIndex]) {
                return gamepads[gamepadIndex];
            }
            for (let gp of gamepads) {
                if (gp) return gp;
            }
            return null;
        }

        // Particle system
        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Bullet class
        function createBullet(x, y, vx = 0, vy = -12) {
            bullets.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                width: 4,
                height: 15,
                damage: 25
            });
        }

        // Enemy class
        function createEnemy(x, y, type = 'basic') {
            const enemyTypes = {
                basic: {
                    width: 30,
                    height: 30,
                    speed: 2,
                    health: 50,
                    color: '#ff0000',
                    score: 100,
                    shootChance: 0.01
                },
                fast: {
                    width: 25,
                    height: 25,
                    speed: 4,
                    health: 30,
                    color: '#ff9900',
                    score: 150,
                    shootChance: 0.02
                },
                tank: {
                    width: 45,
                    height: 45,
                    speed: 1,
                    health: 150,
                    color: '#9900ff',
                    score: 300,
                    shootChance: 0.005
                },
                zigzag: {
                    width: 28,
                    height: 28,
                    speed: 3,
                    health: 40,
                    color: '#00ff00',
                    score: 200,
                    shootChance: 0.015,
                    pattern: 'zigzag'
                }
            };

            const template = enemyTypes[type];
            enemies.push({
                x: x,
                y: y,
                ...template,
                maxHealth: template.health,
                direction: Math.random() > 0.5 ? 1 : -1,
                phase: 0
            });
        }

        // Power-up class
        function createPowerUp(x, y) {
            const types = ['health', 'rapid', 'shield'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x,
                y: y,
                width: 25,
                height: 25,
                type: type,
                vy: 2,
                rotation: 0
            });
        }

        // Spawn wave of enemies
        function spawnWave() {
            const enemiesPerWave = 5 + wave * 2;
            const enemyTypes = ['basic', 'fast', 'tank', 'zigzag'];
            
            for (let i = 0; i < enemiesPerWave; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = -50 - i * 60;
                
                let type = 'basic';
                if (wave > 2) {
                    type = enemyTypes[Math.floor(Math.random() * Math.min(wave - 1, enemyTypes.length))];
                }
                
                createEnemy(x, y, type);
            }

            // Show wave indicator
            const waveDiv = document.createElement('div');
            waveDiv.className = 'wave-indicator';
            waveDiv.textContent = `WAVE ${wave}`;
            document.body.appendChild(waveDiv);
            setTimeout(() => waveDiv.remove(), 2000);
        }

        // Update player
        function updatePlayer(deltaTime) {
            const gp = getGamepad();
            
            if (gp) {
                // Left stick movement
                const deadzone = 0.15;
                const lx = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
                const ly = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;
                
                player.vx = lx * player.speed;
                player.vy = ly * player.speed;
                
                // Right trigger for shooting (RT is usually axes[5] or buttons[7])
                const rtValue = gp.buttons[7] ? gp.buttons[7].value : 0;
                if (rtValue > 0.3 && player.shootCooldown <= 0) {
                    createBullet(player.x, player.y - 20);
                    shootSound();
                    player.shootCooldown = 0.15;
                }
                
                // A button (button 0) for special attack
                if (gp.buttons[0] && gp.buttons[0].pressed && player.specialCooldown <= 0) {
                    // Triple shot
                    createBullet(player.x - 15, player.y - 20, -2, -12);
                    createBullet(player.x, player.y - 20, 0, -12);
                    createBullet(player.x + 15, player.y - 20, 2, -12);
                    shootSound();
                    powerUpSound();
                    player.specialCooldown = 2;
                }
                
                // B button (button 1) for shield
                if (gp.buttons[1] && gp.buttons[1].pressed && player.shieldCooldown <= 0) {
                    player.hasShield = true;
                    player.shieldDuration = 3;
                    player.shieldCooldown = 10;
                    powerUpSound();
                }
            }

            // Update player position
            player.x += player.vx;
            player.y += player.vy;

            // Boundary checking
            player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));

            // Update cooldowns
            player.shootCooldown = Math.max(0, player.shootCooldown - deltaTime);
            player.specialCooldown = Math.max(0, player.specialCooldown - deltaTime);
            player.shieldCooldown = Math.max(0, player.shieldCooldown - deltaTime);
            player.shieldDuration = Math.max(0, player.shieldDuration - deltaTime);
            
            if (player.shieldDuration <= 0) {
                player.hasShield = false;
            }
        }

        // Update bullets
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                return bullet.y > -20;
            });
        }

        // Update enemy bullets
        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.y += bullet.vy;
                
                // Check collision with player
                if (!player.hasShield &&
                    bullet.x > player.x - player.width / 2 &&
                    bullet.x < player.x + player.width / 2 &&
                    bullet.y > player.y - player.height / 2 &&
                    bullet.y < player.y + player.height / 2) {
                    player.health -= 10;
                    hitSound();
                    createParticles(bullet.x, bullet.y, 10, '#ff0000');
                    updateHealthBar();
                    combo = 0;
                    return false;
                }
                
                return bullet.y < canvas.height + 20;
            });
        }

        // Update enemies
        function updateEnemies(deltaTime) {
            enemies = enemies.filter(enemy => {
                enemy.y += enemy.speed;
                
                // Movement patterns
                if (enemy.pattern === 'zigzag') {
                    enemy.phase += deltaTime * 3;
                    enemy.x += Math.sin(enemy.phase) * 2;
                } else {
                    enemy.x += enemy.direction * 0.5;
                    if (enemy.x < 50 || enemy.x > canvas.width - 50) {
                        enemy.direction *= -1;
                    }
                }

                // Enemy shooting
                if (Math.random() < enemy.shootChance) {
                    enemyBullets.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        vy: 5,
                        width: 6,
                        height: 12
                    });
                }

                // Check collision with bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    if (bullet.x > enemy.x - enemy.width / 2 &&
                        bullet.x < enemy.x + enemy.width / 2 &&
                        bullet.y > enemy.y - enemy.height / 2 &&
                        bullet.y < enemy.y + enemy.height / 2) {
                        enemy.health -= bullet.damage;
                        bullets.splice(i, 1);
                        createParticles(bullet.x, bullet.y, 5, enemy.color);
                        hitSound();
                        
                        if (enemy.health <= 0) {
                            explosionSound();
                            createParticles(enemy.x, enemy.y, 20, enemy.color);
                            score += enemy.score * (1 + combo * 0.1);
                            combo++;
                            comboTimer = 3;
                            
                            if (combo > 5 && combo % 5 === 0) {
                                showCombo(combo);
                            }
                            
                            // Chance to drop power-up
                            if (Math.random() < 0.15) {
                                createPowerUp(enemy.x, enemy.y);
                            }
                            
                            updateScore();
                            return false;
                        }
                    }
                }

                // Check collision with player
                if (!player.hasShield &&
                    Math.abs(enemy.x - player.x) < (enemy.width + player.width) / 2 &&
                    Math.abs(enemy.y - player.y) < (enemy.height + player.height) / 2) {
                    player.health -= 30;
                    hitSound();
                    createParticles(enemy.x, enemy.y, 15, '#ff0000');
                    updateHealthBar();
                    combo = 0;
                    enemy.health = 0;
                    return false;
                }

                return enemy.y < canvas.height + 50;
            });

            // Spawn new wave when all enemies are gone
            if (enemies.length === 0) {
                wave++;
                document.getElementById('waveDisplay').textContent = wave;
                spawnWave();
            }
        }

        // Update power-ups
        function updatePowerUps() {
            powerUps = powerUps.filter(powerUp => {
                powerUp.y += powerUp.vy;
                powerUp.rotation += 0.05;

                // Check collision with player
                if (Math.abs(powerUp.x - player.x) < (powerUp.width + player.width) / 2 &&
                    Math.abs(powerUp.y - player.y) < (powerUp.height + player.height) / 2) {
                    powerUpSound();
                    
                    switch(powerUp.type) {
                        case 'health':
                            player.health = Math.min(player.maxHealth, player.health + 30);
                            break;
                        case 'rapid':
                            player.shootCooldown = -2; // Negative for bonus shots
                            break;
                        case 'shield':
                            player.hasShield = true;
                            player.shieldDuration = 5;
                            break;
                    }
                    
                    createParticles(powerUp.x, powerUp.y, 15, '#ffff00');
                    updateHealthBar();
                    return false;
                }

                return powerUp.y < canvas.height + 50;
            });
        }

        // Update particles
        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                particle.vy += 0.2; // Gravity
                return particle.life > 0;
            });
        }

        // Update combo timer
        function updateCombo(deltaTime) {
            if (comboTimer > 0) {
                comboTimer -= deltaTime;
                if (comboTimer <= 0) {
                    combo = 0;
                }
            }
            document.getElementById('comboDisplay').textContent = combo;
        }

        // Show combo text
        function showCombo(comboCount) {
            const comboDiv = document.createElement('div');
            comboDiv.className = 'combo';
            comboDiv.textContent = `${comboCount}X COMBO!`;
            document.body.appendChild(comboDiv);
            setTimeout(() => comboDiv.remove(), 1000);
        }

        // Draw player
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Shield effect
            if (player.hasShield) {
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Ship body
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-15, 15);
            ctx.lineTo(0, 10);
            ctx.lineTo(15, 15);
            ctx.closePath();
            ctx.fill();
            
            // Ship cockpit
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, -5, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Engine glow
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.arc(-8, 15, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(8, 15, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        // Draw bullets
        function drawBullets() {
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 10;
            
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x - bullet.width / 2, bullet.y - bullet.height / 2, bullet.width, bullet.height);
            });
            
            ctx.shadowBlur = 0;
        }

        // Draw enemy bullets
        function drawEnemyBullets() {
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            
            enemyBullets.forEach(bullet => {
                ctx.fillRect(bullet.x - bullet.width / 2, bullet.y - bullet.height / 2, bullet.width, bullet.height);
            });
            
            ctx.shadowBlur = 0;
        }

        // Draw enemies
        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // Enemy body
                ctx.fillStyle = enemy.color;
                ctx.shadowColor = enemy.color;
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.moveTo(0, -enemy.height / 2);
                ctx.lineTo(enemy.width / 2, enemy.height / 2);
                ctx.lineTo(0, enemy.height / 3);
                ctx.lineTo(-enemy.width / 2, enemy.height / 2);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                const barWidth = enemy.width * 0.8;
                const barHeight = 4;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(-barWidth / 2, -enemy.height / 2 - 10, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
                ctx.fillRect(-barWidth / 2, -enemy.height / 2 - 10, barWidth * healthPercent, barHeight);
                
                ctx.restore();
            });
        }

        // Draw power-ups
        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                ctx.save();
                ctx.translate(powerUp.x, powerUp.y);
                ctx.rotate(powerUp.rotation);
                
                const colors = {
                    health: '#00ff00',
                    rapid: '#ffff00',
                    shield: '#00ffff'
                };
                
                ctx.fillStyle = colors[powerUp.type];
                ctx.shadowColor = colors[powerUp.type];
                ctx.shadowBlur = 20;
                
                // Draw power-up icon
                ctx.beginPath();
                ctx.arc(0, 0, powerUp.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const icons = {
                    health: '+',
                    rapid: '⚡',
                    shield: '◆'
                };
                
                ctx.fillText(icons[powerUp.type], 0, 0);
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Draw stars background
        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                speed: Math.random() * 2 + 0.5
            });
        }

        function drawStars() {
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Update score display
        function updateScore() {
            document.getElementById('scoreDisplay').textContent = Math.floor(score);
        }

        // Update health bar
        function updateHealthBar() {
            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            
            if (player.health <= 0) {
                gameOver();
            }
        }

        // Game loop
        function gameLoop(currentTime) {
            if (!gameRunning) return;

            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw and update
            drawStars();
            updatePlayer(deltaTime);
            updateBullets();
            updateEnemyBullets();
            updateEnemies(deltaTime);
            updatePowerUps();
            updateParticles();
            updateCombo(deltaTime);

            drawParticles();
            drawEnemyBullets();
            drawBullets();
            drawEnemies();
            drawPowerUps();
            drawPlayer();

            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            gameRunning = true;
            score = 0;
            wave = 1;
            combo = 0;
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            bullets = [];
            enemies = [];
            particles = [];
            powerUps = [];
            enemyBullets = [];
            
            updateScore();
            updateHealthBar();
            document.getElementById('waveDisplay').textContent = wave;
            
            spawnWave();
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = Math.floor(score);
            document.getElementById('finalWave').textContent = wave;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            explosionSound();
            createParticles(player.x, player.y, 50, '#ff0000');
        }

        // Restart game
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        }

        // Keyboard controls as backup
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ' && player.shootCooldown <= 0) {
                createBullet(player.x, player.y - 20);
                shootSound();
                player.shootCooldown = 0.15;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Update player with keyboard if no gamepad
        function updatePlayerKeyboard() {
            if (!getGamepad()) {
                if (keys['ArrowLeft'] || keys['a']) player.vx = -player.speed;
                else if (keys['ArrowRight'] || keys['d']) player.vx = player.speed;
                else player.vx = 0;
                
                if (keys['ArrowUp'] || keys['w']) player.vy = -player.speed;
                else if (keys['ArrowDown'] || keys['s']) player.vy = player.speed;
                else player.vy = 0;
            }
        }

        // Add keyboard update to the updatePlayer function
        const originalUpdatePlayer = updatePlayer;
        updatePlayer = function(deltaTime) {
            updatePlayerKeyboard();
            originalUpdatePlayer(deltaTime);
        };

        // Initialize
        console.log('Space Defender loaded! Connect your Xbox controller and press START GAME');
    </script>
</body>
</html>