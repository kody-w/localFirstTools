{
  "id": "puzzle-blocks",
  "name": "Puzzle Blocks",
  "description": "Arrange falling blocks to clear lines",
  "icon": "üß©",
  "gameData": {
    "boardWidth": 10,
    "boardHeight": 20,
    "backgroundColor": "#8bac0f",
    "blockColors": [
      "#e42c64",
      "#f49900",
      "#0a84ff",
      "#9a28d7",
      "#38c5fe",
      "#63d34c",
      "#ffbc00"
    ]
  },
  "initializeCode": "function(display) {\n  this.display = display;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = 280;\n  this.canvas.height = 248;\n  display.appendChild(this.canvas);\n  this.ctx = this.canvas.getContext('2d');\n  \n  this.width = this.gameData.boardWidth;\n  this.height = this.gameData.boardHeight;\n  this.cellSize = Math.min(\n      this.canvas.width / (this.width + 6),\n      this.canvas.height / this.height\n  );\n  this.boardOffsetX = (this.canvas.width - this.width * this.cellSize) / 2;\n  this.boardOffsetY = (this.canvas.height - this.height * this.cellSize) / 2;\n  \n  // Block shapes\n  this.shapes = [\n      // I\n      [\n          [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:2, y:0}],\n          [{x:1, y:-1}, {x:1, y:0}, {x:1, y:1}, {x:1, y:2}],\n          [{x:-1, y:1}, {x:0, y:1}, {x:1, y:1}, {x:2, y:1}],\n          [{x:0, y:-1}, {x:0, y:0}, {x:0, y:1}, {x:0, y:2}]\n      ],\n      // J\n      [\n          [{x:-1, y:-1}, {x:-1, y:0}, {x:0, y:0}, {x:1, y:0}],\n          [{x:0, y:-1}, {x:1, y:-1}, {x:0, y:0}, {x:0, y:1}],\n          [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:1, y:1}],\n          [{x:0, y:-1}, {x:0, y:0}, {x:-1, y:1}, {x:0, y:1}]\n      ],\n      // L\n      [\n          [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:1, y:-1}],\n          [{x:0, y:-1}, {x:0, y:0}, {x:0, y:1}, {x:1, y:1}],\n          [{x:-1, y:1}, {x:-1, y:0}, {x:0, y:0}, {x:1, y:0}],\n          [{x:-1, y:-1}, {x:0, y:-1}, {x:0, y:0}, {x:0, y:1}]\n      ],\n      // O\n      [\n          [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}],\n          [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}],\n          [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}],\n          [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}]\n      ],\n      // S\n      [\n          [{x:-1, y:0}, {x:0, y:0}, {x:0, y:-1}, {x:1, y:-1}],\n          [{x:0, y:-1}, {x:0, y:0}, {x:1, y:0}, {x:1, y:1}],\n          [{x:-1, y:1}, {x:0, y:1}, {x:0, y:0}, {x:1, y:0}],\n          [{x:-1, y:-1}, {x:-1, y:0}, {x:0, y:0}, {x:0, y:1}]\n      ],\n      // T\n      [\n          [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:0, y:-1}],\n          [{x:0, y:-1}, {x:0, y:0}, {x:0, y:1}, {x:1, y:0}],\n          [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:0, y:1}],\n          [{x:-1, y:0}, {x:0, y:-1}, {x:0, y:0}, {x:0, y:1}]\n      ],\n      // Z\n      [\n          [{x:-1, y:-1}, {x:0, y:-1}, {x:0, y:0}, {x:1, y:0}],\n          [{x:1, y:-1}, {x:0, y:0}, {x:1, y:0}, {x:0, y:1}],\n          [{x:-1, y:0}, {x:0, y:0}, {x:0, y:1}, {x:1, y:1}],\n          [{x:0, y:-1}, {x:-1, y:0}, {x:0, y:0}, {x:-1, y:1}]\n      ]\n  ];\n  \n  // Game state\n  this.board = Array(this.height).fill().map(() => Array(this.width).fill(null));\n  this.currentPiece = null;\n  this.currentX = 0;\n  this.currentY = 0;\n  this.currentRotation = 0;\n  this.nextPiece = null;\n  this.score = 0;\n  this.level = 1;\n  this.linesCleared = 0;\n  this.gameOver = false;\n  \n  // Add a game state to control start screen\n  this.gameState = 'start'; // 'start', 'playing', 'game-over'\n  \n  // Timing and speed\n  this.initialSpeed = 150; // Time in milliseconds between automatic drops\n  this.speed = this.initialSpeed;\n  this.lastUpdateTime = 0;\n  \n  // Input handling\n  this.keyState = {\n      left: false,\n      right: false,\n      down: false\n  };\n  this.keyRepeatDelay = 200; // Initial delay before key repeat (ms)\n  this.keyRepeatInterval = 100; // Interval for key repeats (ms)\n  this.keyTimer = null;\n  \n  // Draw start screen initially\n  this.render();\n}",
  "updateCode": "function() {\n  // Don't update if we're in the start screen\n  if (this.gameState === 'start') {\n    return;\n  }\n  \n  // Don't update if the game is over\n  if (this.gameOver) {\n    this.gameState = 'game-over';\n    return;\n  }\n  \n  // Get current time\n  const now = Date.now();\n  \n  // Check if enough time has passed for automatic drop\n  if (!this.lastUpdateTime) {\n    this.lastUpdateTime = now;\n  }\n  \n  if (now - this.lastUpdateTime >= this.speed) {\n    // Move the piece down automatically\n    this.moveDown();\n    this.lastUpdateTime = now;\n  }\n}",
  "renderCode": "function() {\n  // Clear canvas\n  this.ctx.fillStyle = this.gameData.backgroundColor;\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Start screen\n  if (this.gameState === 'start') {\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    this.ctx.fillStyle = 'white';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.font = '16px \"Press Start 2P\"';\n    this.ctx.fillText('PUZZLE BLOCKS', this.canvas.width/2, this.canvas.height/2 - 40);\n    \n    this.ctx.font = '10px \"Press Start 2P\"';\n    this.ctx.fillText('PRESS START TO PLAY', this.canvas.width/2, this.canvas.height/2);\n    \n    // Draw controls instructions\n    this.ctx.font = '8px \"Press Start 2P\"';\n    this.ctx.fillText('‚Üê ‚Üí : MOVE', this.canvas.width/2, this.canvas.height/2 + 30);\n    this.ctx.fillText('‚Üë / A : ROTATE', this.canvas.width/2, this.canvas.height/2 + 45);\n    this.ctx.fillText('‚Üì : DROP', this.canvas.width/2, this.canvas.height/2 + 60);\n    this.ctx.fillText('B : HARD DROP', this.canvas.width/2, this.canvas.height/2 + 75);\n    \n    return;\n  }\n  \n  // Draw game board border\n  this.ctx.strokeStyle = '#222222';\n  this.ctx.lineWidth = 2;\n  this.ctx.strokeRect(\n      this.boardOffsetX - 1,\n      this.boardOffsetY - 1,\n      this.width * this.cellSize + 2,\n      this.height * this.cellSize + 2\n  );\n  \n  // Draw board\n  for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n          if (this.board[y][x] !== null) {\n              this.drawBlock(\n                  x,\n                  y,\n                  this.gameData.blockColors[this.board[y][x]]\n              );\n          }\n      }\n  }\n  \n  // Draw current piece\n  if (this.currentPiece !== null) {\n      const shape = this.shapes[this.currentPiece][this.currentRotation];\n      for (let i = 0; i < shape.length; i++) {\n          const x = this.currentX + shape[i].x;\n          const y = this.currentY + shape[i].y;\n          \n          if (y >= 0) { // Only draw if the block is visible on the board\n              this.drawBlock(\n                  x,\n                  y,\n                  this.gameData.blockColors[this.currentPiece]\n              );\n          }\n      }\n      \n      // Draw ghost piece (preview of where the piece will land)\n      let ghostY = this.currentY;\n      while (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, ghostY + 1)) {\n          ghostY++;\n      }\n      \n      if (ghostY !== this.currentY) {\n          for (let i = 0; i < shape.length; i++) {\n              const x = this.currentX + shape[i].x;\n              const y = ghostY + shape[i].y;\n              \n              if (y >= 0) { // Only draw if the block is visible on the board\n                  this.drawGhostBlock(\n                      x,\n                      y,\n                      this.gameData.blockColors[this.currentPiece]\n                  );\n              }\n          }\n      }\n  }\n  \n  // Draw next piece preview\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n  this.ctx.fillRect(\n      this.boardOffsetX + this.width * this.cellSize + 10,\n      this.boardOffsetY,\n      80,\n      60\n  );\n  \n  this.ctx.fillStyle = 'white';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'top';\n  this.ctx.font = '10px \"Press Start 2P\"';\n  this.ctx.fillText(\n      'NEXT',\n      this.boardOffsetX + this.width * this.cellSize + 50,\n      this.boardOffsetY + 5\n  );\n  \n  if (this.nextPiece !== null) {\n      const shape = this.shapes[this.nextPiece][0];\n      const previewOffsetX = this.boardOffsetX + this.width * this.cellSize + 40;\n      const previewOffsetY = this.boardOffsetY + 25;\n      \n      for (let i = 0; i < shape.length; i++) {\n          this.ctx.fillStyle = this.gameData.blockColors[this.nextPiece];\n          this.ctx.fillRect(\n              previewOffsetX + shape[i].x * (this.cellSize * 0.7),\n              previewOffsetY + shape[i].y * (this.cellSize * 0.7),\n              this.cellSize * 0.7,\n              this.cellSize * 0.7\n          );\n          \n          this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n          this.ctx.lineWidth = 1;\n          this.ctx.strokeRect(\n              previewOffsetX + shape[i].x * (this.cellSize * 0.7),\n              previewOffsetY + shape[i].y * (this.cellSize * 0.7),\n              this.cellSize * 0.7,\n              this.cellSize * 0.7\n          );\n      }\n  }\n  \n  // Draw score, level, and lines\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n  this.ctx.fillRect(\n      this.boardOffsetX + this.width * this.cellSize + 10,\n      this.boardOffsetY + 70,\n      80,\n      90\n  );\n  \n  this.ctx.fillStyle = 'white';\n  this.ctx.textAlign = 'left';\n  this.ctx.textBaseline = 'top';\n  this.ctx.font = '10px \"Press Start 2P\"';\n  \n  this.ctx.fillText(\n      'SCORE',\n      this.boardOffsetX + this.width * this.cellSize + 15,\n      this.boardOffsetY + 75\n  );\n  this.ctx.fillText(\n      this.score.toString(),\n      this.boardOffsetX + this.width * this.cellSize + 15,\n      this.boardOffsetY + 90\n  );\n  \n  this.ctx.fillText(\n      'LEVEL',\n      this.boardOffsetX + this.width * this.cellSize + 15,\n      this.boardOffsetY + 110\n  );\n  this.ctx.fillText(\n      this.level.toString(),\n      this.boardOffsetX + this.width * this.cellSize + 15,\n      this.boardOffsetY + 125\n  );\n  \n  this.ctx.fillText(\n      'LINES',\n      this.boardOffsetX + this.width * this.cellSize + 15,\n      this.boardOffsetY + 145\n  );\n  this.ctx.fillText(\n      this.linesCleared.toString(),\n      this.boardOffsetX + this.width * this.cellSize + 15,\n      this.boardOffsetY + 160\n  );\n  \n  // Draw game over message\n  if (this.gameState === 'game-over') {\n      this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n      this.ctx.fillRect(\n          this.boardOffsetX,\n          this.boardOffsetY + this.height * this.cellSize / 2 - 40,\n          this.width * this.cellSize,\n          80\n      );\n      \n      this.ctx.fillStyle = 'white';\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.font = '16px \"Press Start 2P\"';\n      this.ctx.fillText(\n          'GAME OVER',\n          this.boardOffsetX + this.width * this.cellSize / 2,\n          this.boardOffsetY + this.height * this.cellSize / 2 - 15\n      );\n      \n      this.ctx.font = '10px \"Press Start 2P\"';\n      this.ctx.fillText(\n          'PRESS A TO RESTART',\n          this.boardOffsetX + this.width * this.cellSize / 2,\n          this.boardOffsetY + this.height * this.cellSize / 2 + 15\n      );\n  }\n}",
  "handleInputCode": "function(button, isPressed) {\n  // Handle start screen input\n  if (this.gameState === 'start' && isPressed) {\n    if (button === 'start' || button === 'a') {\n      this.startGame();\n      return;\n    }\n  }\n  \n  // Handle game over screen input\n  if (this.gameState === 'game-over') {\n    if (button === 'a' && isPressed) {\n      this.restart();\n      return;\n    }\n  }\n  \n  // Only process input if we're playing\n  if (this.gameState !== 'playing') {\n    return;\n  }\n  \n  switch(button) {\n    case 'left':\n      this.keyState.left = isPressed;\n      if (isPressed) {\n        this.moveLeft();\n        // Start key repeat after delay\n        clearTimeout(this.keyTimer);\n        this.keyTimer = setTimeout(() => {\n          const repeatFunc = () => {\n            if (this.keyState.left) {\n              this.moveLeft();\n              this.keyTimer = setTimeout(repeatFunc, this.keyRepeatInterval);\n            }\n          };\n          repeatFunc();\n        }, this.keyRepeatDelay);\n      }\n      break;\n      \n    case 'right':\n      this.keyState.right = isPressed;\n      if (isPressed) {\n        this.moveRight();\n        // Start key repeat after delay\n        clearTimeout(this.keyTimer);\n        this.keyTimer = setTimeout(() => {\n          const repeatFunc = () => {\n            if (this.keyState.right) {\n              this.moveRight();\n              this.keyTimer = setTimeout(repeatFunc, this.keyRepeatInterval);\n            }\n          };\n          repeatFunc();\n        }, this.keyRepeatDelay);\n      }\n      break;\n      \n    case 'down':\n      this.keyState.down = isPressed;\n      if (isPressed) {\n        this.moveDown();\n        // Start key repeat after delay\n        clearTimeout(this.keyTimer);\n        this.keyTimer = setTimeout(() => {\n          const repeatFunc = () => {\n            if (this.keyState.down) {\n              this.moveDown();\n              this.keyTimer = setTimeout(repeatFunc, this.keyRepeatInterval);\n            }\n          };\n          repeatFunc();\n        }, this.keyRepeatDelay);\n      }\n      break;\n      \n    case 'up':\n      if (isPressed) {\n        this.rotate();\n      }\n      break;\n      \n    case 'a':\n      if (isPressed) {\n        this.rotate();\n      }\n      break;\n      \n    case 'b':\n      if (isPressed) {\n        this.hardDrop();\n      }\n      break;\n  }\n}",
  "cleanupCode": "function() {\n  if (this.canvas && this.canvas.parentNode) {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n  \n  clearTimeout(this.keyTimer);\n}",
  "additionalFunctions": {
    "startGame": "function() {\n  // Initialize board\n  this.board = Array(this.height).fill().map(() => Array(this.width).fill(null));\n  \n  // Init game state\n  this.score = 0;\n  this.level = 1;\n  this.linesCleared = 0;\n  this.gameOver = false;\n  this.speed = this.initialSpeed;\n  this.lastUpdateTime = Date.now();\n  \n  // Set up the first piece\n  this.generateNextPiece();\n  this.spawnPiece();\n  \n  // Change state to playing\n  this.gameState = 'playing';\n}",
    "drawBlock": "function(x, y, color) {\n  const pixelX = this.boardOffsetX + x * this.cellSize;\n  const pixelY = this.boardOffsetY + y * this.cellSize;\n  \n  // Fill\n  this.ctx.fillStyle = color;\n  this.ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);\n  \n  // Highlight\n  this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n  this.ctx.beginPath();\n  this.ctx.moveTo(pixelX, pixelY);\n  this.ctx.lineTo(pixelX + this.cellSize, pixelY);\n  this.ctx.lineTo(pixelX, pixelY + this.cellSize);\n  this.ctx.closePath();\n  this.ctx.fill();\n  \n  // Shadow\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n  this.ctx.beginPath();\n  this.ctx.moveTo(pixelX + this.cellSize, pixelY);\n  this.ctx.lineTo(pixelX + this.cellSize, pixelY + this.cellSize);\n  this.ctx.lineTo(pixelX, pixelY + this.cellSize);\n  this.ctx.closePath();\n  this.ctx.fill();\n  \n  // Border\n  this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n  this.ctx.lineWidth = 1;\n  this.ctx.strokeRect(pixelX, pixelY, this.cellSize, this.cellSize);\n}",
    "drawGhostBlock": "function(x, y, color) {\n  const pixelX = this.boardOffsetX + x * this.cellSize;\n  const pixelY = this.boardOffsetY + y * this.cellSize;\n  \n  // Draw outline\n  this.ctx.strokeStyle = color;\n  this.ctx.lineWidth = 2;\n  this.ctx.strokeRect(\n      pixelX + 2,\n      pixelY + 2,\n      this.cellSize - 4,\n      this.cellSize - 4\n  );\n}",
    "generateNextPiece": "function() {\n  this.nextPiece = Math.floor(Math.random() * this.shapes.length);\n}",
    "spawnPiece": "function() {\n  if (this.nextPiece === null) {\n      this.generateNextPiece();\n  }\n  \n  this.currentPiece = this.nextPiece;\n  this.currentRotation = 0;\n  this.currentX = Math.floor(this.width / 2) - 1;\n  this.currentY = 0;\n  \n  this.generateNextPiece();\n  \n  // Check if the new piece immediately collides (game over)\n  if (this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, this.currentY)) {\n      this.gameOver = true;\n  }\n}",
    "moveLeft": "function() {\n  if (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX - 1, this.currentY)) {\n      this.currentX--;\n  }\n}",
    "moveRight": "function() {\n  if (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX + 1, this.currentY)) {\n      this.currentX++;\n  }\n}",
    "moveDown": "function() {\n  if (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, this.currentY + 1)) {\n      this.currentY++;\n  } else {\n      this.lockPiece();\n      this.clearLines();\n      this.spawnPiece();\n  }\n}",
    "hardDrop": "function() {\n  while (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, this.currentY + 1)) {\n      this.currentY++;\n  }\n  this.lockPiece();\n  this.clearLines();\n  this.spawnPiece();\n}",
    "rotate": "function() {\n  const nextRotation = (this.currentRotation + 1) % 4;\n  \n  // Try normal rotation\n  if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX, this.currentY)) {\n      this.currentRotation = nextRotation;\n      return;\n  }\n  \n  // Try wall kick - left\n  if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX - 1, this.currentY)) {\n      this.currentRotation = nextRotation;\n      this.currentX--;\n      return;\n  }\n  \n  // Try wall kick - right\n  if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX + 1, this.currentY)) {\n      this.currentRotation = nextRotation;\n      this.currentX++;\n      return;\n  }\n  \n  // Try wall kick - up (for I piece mostly)\n  if (!this.checkCollision(this.currentPiece, nextRotation, this.if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX, this.currentY - 1)) {\n      this.currentRotation = nextRotation;\n      this.currentY--;\n      return;\n  }\n}",
    "checkCollision": "function(piece, rotation, x, y) {\n  const shape = this.shapes[piece][rotation];\n  \n  for (let i = 0; i < shape.length; i++) {\n      const blockX = x + shape[i].x;\n      const blockY = y + shape[i].y;\n      \n      // Check if out of bounds\n      if (blockX < 0 || blockX >= this.width || blockY >= this.height) {\n          return true;\n      }\n      \n      // Check if overlaps with existing blocks on the board\n      if (blockY >= 0 && this.board[blockY][blockX] !== null) {\n          return true;\n      }\n  }\n  \n  return false;\n}",
    "lockPiece": "function() {\n  const shape = this.shapes[this.currentPiece][this.currentRotation];\n  \n  for (let i = 0; i < shape.length; i++) {\n      const blockX = this.currentX + shape[i].x;\n      const blockY = this.currentY + shape[i].y;\n      \n      if (blockY >= 0) { // Only place on the board if visible\n          this.board[blockY][blockX] = this.currentPiece;\n      }\n  }\n  \n  // Add points for placing a piece\n  this.score += 10;\n}",
    "clearLines": "function() {\n  let linesCleared = 0;\n  \n  for (let y = this.height - 1; y >= 0; y--) {\n      let isLineFull = true;\n      \n      for (let x = 0; x < this.width; x++) {\n          if (this.board[y][x] === null) {\n              isLineFull = false;\n              break;\n          }\n      }\n      \n      if (isLineFull) {\n          // Remove the line\n          for (let yy = y; yy > 0; yy--) {\n              for (let x = 0; x < this.width; x++) {\n                  this.board[yy][x] = this.board[yy - 1][x];\n              }\n          }\n          \n          // Clear the top line\n          for (let x = 0; x < this.width; x++) {\n              this.board[0][x] = null;\n          }\n          \n          // Since we removed a line, we need to check the same position again\n          y++;\n          linesCleared++;\n      }\n  }\n  \n  if (linesCleared > 0) {\n      // Add points for clearing lines (more points for clearing multiple lines at once)\n      const points = [0, 100, 300, 500, 800];\n      this.score += points[linesCleared];\n      \n      this.linesCleared += linesCleared;\n      \n      // Increase level every 10 lines and adjust speed more gradually\n      const newLevel = Math.floor(this.linesCleared / 10) + 1;\n      if (newLevel > this.level) {\n          this.level = newLevel;\n          \n          // Calculate new drop speed - more gradual increase\n          // Each level, decrease speed by 10ms\n          this.speed = Math.max(50, this.initialSpeed - (this.level - 1) * 10);\n      }\n  }\n}",
    "restart": "function() {\n  // Reset to start screen\n  this.gameState = 'start';\n}"
  }
}