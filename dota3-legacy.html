<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOTA 3: LEGACY</title>
    <meta name="description" content="DOTA 3 Legacy - A browser-based MOBA-style game with 24 playable heroes, abilities, items, and team battles">
    <meta name="theme-color" content="#050508">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Rajdhani:wght@500;700&display=swap');

        :root {
            /* Design Tokens */
            --color-bg-dark: #050508;
            --color-glass: rgba(10, 15, 25, 0.85);
            --color-glass-light: rgba(20, 30, 45, 0.7);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-border-hover: rgba(255, 255, 255, 0.3);

            --accent-radiant: #00ff88;
            --accent-radiant-glow: rgba(0, 255, 136, 0.4);
            --accent-dire: #ff3c3c;
            --accent-dire-glow: rgba(255, 60, 60, 0.4);

            --text-main: #ffffff;
            --text-muted: #8899aa;

            --font-main: 'Outfit', sans-serif;
            --font-display: 'Rajdhani', sans-serif;

            --z-ui-base: 100;
            --z-ui-overlay: 200;
            --z-tooltip: 300;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-drag: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--color-bg-dark);
            color: var(--text-main);
            font-family: var(--font-main);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI OVERLAYS --- */

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: var(--z-ui-base);
        }

        .score-board {
            display: flex;
            align-items: center;
            gap: 40px;
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        .score-radiant {
            color: var(--accent-radiant);
        }

        .score-dire {
            color: var(--accent-dire);
        }

        .game-time {
            color: #fff;
            font-variant-numeric: tabular-nums;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            font-size: 20px;
        }

        /* Bottom HUD */
        .hud-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95) 20%, transparent);
            z-index: var(--z-ui-base);
            pointer-events: none;
            /* Let clicks pass through empty space */
        }

        /* Portrait & Stats (Left) */
        .character-panel {
            width: 300px;
            height: 110px;
            display: flex;
            background: var(--color-glass);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .character-panel:hover {
            transform: translateY(-2px);
            border-color: var(--color-border-hover);
        }

        .portrait {
            width: 90px;
            background: #111;
            position: relative;
            overflow: hidden;
        }

        .portrait canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .stats-area {
            flex: 1;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .unit-name {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-transform: uppercase;
        }

        .unit-level {
            font-size: 12px;
            color: #ffd700;
            margin-left: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-val {
            color: #fff;
            font-weight: 600;
        }

        /* Center Skills & Health */
        .center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        .bars-container {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bar-wrap {
            width: 100%;
            height: 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hp-fill {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.4);
        }

        .mp-fill {
            background: linear-gradient(90deg, #3498db, #2980b9);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.4);
        }

        .bar-text {
            position: absolute;
            width: 100%;
            top: 0;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            line-height: 14px;
            text-shadow: 0 1px 2px #000;
            opacity: 0.8;
        }

        .ability-bar {
            display: flex;
            gap: 8px;
        }

        .ability-slot {
            width: 64px;
            height: 64px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .ability-slot:hover {
            border-color: #fff;
            transform: translateY(-2px);
        }

        .ability-slot:active {
            transform: scale(0.95);
        }

        .ability-icon {
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .hotkey {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 1px 2px #000;
        }

        .mana-cost {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #3498db;
            font-weight: 700;
        }

        .cooldown-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.85);
            transition: height linear;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        /* Minimap (Right) */
        .right-panel {
            width: 220px;
            height: 220px;
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            position: relative;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .right-panel canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Floating Combat Text */
        .damage-number {
            position: absolute;
            font-family: var(--font-display);
            font-weight: 800;
            font-size: 24px;
            pointer-events: none;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            animation: floatUp 1s ease-out forwards;
            z-index: var(--z-ui-overlay);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            50% {
                transform: translateY(-30px) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translateY(-60px) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes fadeInLeft {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .dmg-crit {
            color: #ff3c3c;
            font-size: 32px;
        }

        .dmg-physical {
            color: #ffffff;
        }

        .dmg-magic {
            color: #a450ff;
        }

        /* Notification Toast */
        .notification-toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--accent-radiant);
            padding: 10px 30px;
            border-radius: 4px;
            color: #fff;
            font-family: var(--font-display);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .notification-toast.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <!-- HERO SELECTION SCREEN -->
    <div id="hero-select" style="position:fixed;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,#0a0a12 0%,#1a1a2e 50%,#0f0f1a 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000;">
        <h1 style="font-family:var(--font-display);font-size:64px;color:#00ff88;margin-bottom:10px;text-shadow:0 0 30px rgba(0,255,136,0.5);">DOTA 3: LEGACY</h1>
        <p style="color:#8899aa;margin-bottom:40px;font-size:18px;">Choose Your Hero</p>
        <div id="hero-grid" style="display:flex;gap:30px;flex-wrap:wrap;justify-content:center;max-width:900px;">
            <!-- Heroes populated by JS -->
        </div>
        <p style="color:#556677;margin-top:40px;font-size:14px;">Click a hero to begin</p>
    </div>

    <div id="game-container"></div>

    <!-- UI Layer -->
    <div class="top-bar">
        <div class="score-board">
            <span class="score-radiant" id="score-radiant">0</span>
            <span class="game-time" id="game-time">00:00</span>
            <span class="score-dire" id="score-dire">0</span>
        </div>
        <!-- ROUND 1: Data Export/Import Buttons -->
        <div class="data-buttons" style="position:absolute;right:20px;top:15px;pointer-events:auto;display:flex;gap:8px;">
            <button onclick="exportGameData()" style="background:var(--accent-radiant);border:none;padding:6px 14px;border-radius:4px;cursor:pointer;font-size:12px;font-weight:600;color:#000;">Export</button>
            <label style="background:#3498db;padding:6px 14px;border-radius:4px;cursor:pointer;font-size:12px;font-weight:600;color:#fff;">
                Import
                <input type="file" accept=".json" onchange="importGameData(this.files[0])" style="display:none;">
            </label>
        </div>
    </div>

    <!-- Central Notification -->
    <div id="notification" class="notification-toast" role="status" aria-live="polite" aria-atomic="true">WELCOME TO DOTA 3 LEGACY</div>

    <!-- Kill Feed -->
    <div id="kill-feed" style="position:fixed;top:80px;right:20px;width:260px;max-height:200px;overflow:hidden;z-index:200;pointer-events:none;"></div>

    <!-- ROUND 10: Match Statistics Panel (Tab to toggle) -->
    <div id="match-stats-panel" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:600px;max-height:80vh;background:linear-gradient(135deg,rgba(20,25,35,0.98),rgba(15,20,30,0.98));border:2px solid #334455;border-radius:12px;padding:20px;display:none;z-index:350;overflow-y:auto;">
        <h2 style="text-align:center;font-family:var(--font-display);color:#ffd700;margin-bottom:20px;font-size:24px;">üìä MATCH STATISTICS</h2>
        <div style="display:flex;justify-content:space-between;margin-bottom:15px;">
            <div id="radiant-stats" style="flex:1;margin-right:10px;padding:10px;background:rgba(0,255,136,0.1);border-radius:8px;border:1px solid #00ff88;">
                <h3 style="color:#00ff88;margin-bottom:10px;text-align:center;">RADIANT</h3>
                <div id="radiant-heroes-stats"></div>
            </div>
            <div id="dire-stats" style="flex:1;margin-left:10px;padding:10px;background:rgba(255,60,60,0.1);border-radius:8px;border:1px solid #ff3c3c;">
                <h3 style="color:#ff3c3c;margin-bottom:10px;text-align:center;">DIRE</h3>
                <div id="dire-heroes-stats"></div>
            </div>
        </div>
        <div id="player-detailed-stats" style="margin-top:15px;padding:15px;background:rgba(255,215,0,0.1);border-radius:8px;border:1px solid #ffd700;">
            <h3 style="color:#ffd700;margin-bottom:10px;text-align:center;">YOUR STATS</h3>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;text-align:center;">
                <div><span style="color:#888;">Damage Dealt</span><br><span id="stat-damage-dealt" style="color:#fff;font-size:18px;">0</span></div>
                <div><span style="color:#888;">Damage Taken</span><br><span id="stat-damage-taken" style="color:#fff;font-size:18px;">0</span></div>
                <div><span style="color:#888;">Healing Done</span><br><span id="stat-healing" style="color:#fff;font-size:18px;">0</span></div>
                <div><span style="color:#888;">Gold Earned</span><br><span id="stat-gold-earned" style="color:#fff;font-size:18px;">0</span></div>
                <div><span style="color:#888;">Creeps Killed</span><br><span id="stat-creeps-killed" style="color:#fff;font-size:18px;">0</span></div>
                <div><span style="color:#888;">Abilities Used</span><br><span id="stat-abilities-used" style="color:#fff;font-size:18px;">0</span></div>
            </div>
        </div>
        <p style="text-align:center;color:#667788;margin-top:15px;font-size:12px;">Press TAB to close</p>
    </div>

    <!-- ROUND 2: Pause Overlay -->
    <div id="pause-overlay" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:400;">
        <h1 style="font-family:var(--font-display);font-size:48px;color:#fff;margin-bottom:10px;">PAUSED</h1>
        <p style="color:#8899aa;margin-bottom:30px;">Press ESC to resume</p>
        <button onclick="togglePause()" style="padding:12px 30px;font-size:16px;background:var(--accent-radiant);border:none;border-radius:6px;cursor:pointer;color:#000;font-weight:600;">Resume Game</button>
    </div>

    <!-- ROUND 2: Respawn Timer -->
    <span id="respawn-timer" style="position:absolute;top:70px;left:50%;transform:translateX(-50%);color:#ff3c3c;font-family:var(--font-display);font-size:24px;display:none;z-index:200;"></span>

    <!-- ROUND 11: Controls Help Button -->
    <div id="help-button" style="position:fixed;top:10px;left:10px;z-index:150;">
        <button onclick="toggleHelp()" style="background:var(--color-glass);border:1px solid var(--color-border);border-radius:50%;width:36px;height:36px;cursor:pointer;color:#8899aa;font-size:18px;font-weight:bold;backdrop-filter:blur(10px);transition:all 0.2s;">?</button>
    </div>
    <div id="help-panel" style="position:fixed;top:50px;left:10px;background:var(--color-glass);border:1px solid var(--color-border);border-radius:12px;padding:15px;display:none;z-index:300;min-width:220px;backdrop-filter:blur(10px);">
        <h3 style="margin:0 0 12px 0;font-family:var(--font-display);color:#ffd700;font-size:16px;">Controls</h3>
        <div style="display:flex;flex-direction:column;gap:6px;font-size:12px;color:#8899aa;">
            <div><span style="color:#00ff88;font-weight:600;">Right-Click</span> - Move</div>
            <div><span style="color:#00ff88;font-weight:600;">Q/W/E/R</span> - Abilities</div>
            <div><span style="color:#00ff88;font-weight:600;">1-6</span> - Use Active Items</div>
            <div><span style="color:#00ff88;font-weight:600;">B</span> - Toggle Shop</div>
            <div><span style="color:#00ff88;font-weight:600;">Tab</span> - Match Stats</div>
            <div><span style="color:#00ff88;font-weight:600;">G</span> - Ping Minimap</div>
            <div><span style="color:#00ff88;font-weight:600;">F5</span> - Quick-Buy</div>
            <div><span style="color:#00ff88;font-weight:600;">ESC</span> - Pause Menu</div>
            <div><span style="color:#00ff88;font-weight:600;">H</span> - Toggle This Help</div>
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.1);">
                <span style="color:#888;">Shift+Click</span> in shop to add to quick-buy
            </div>
        </div>
    </div>

    <!-- ROUND 9: Item Shop Panel -->
    <div id="shop-panel" style="position:fixed;left:20px;top:50%;transform:translateY(-50%);background:var(--color-glass);border:1px solid var(--color-border);border-radius:12px;padding:15px;display:none;z-index:300;min-width:200px;backdrop-filter:blur(10px);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
            <h3 style="margin:0;font-family:var(--font-display);color:#ffd700;">SHOP</h3>
            <span style="color:#8899aa;font-size:12px;">[B] to close</span>
        </div>
        <div id="shop-items" style="display:flex;flex-direction:column;gap:8px;"></div>
    </div>

    <!-- ROUND 10: Quick-buy panel -->
    <div id="quickbuy-panel" style="position:fixed;right:20px;bottom:120px;background:rgba(20,25,35,0.9);border:1px solid #ffd700;border-radius:8px;padding:10px;z-index:200;min-width:150px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <span style="color:#ffd700;font-size:12px;font-weight:600;">QUICK BUY</span>
            <span id="quickbuy-total" style="color:#888;font-size:11px;">0g</span>
        </div>
        <div id="quickbuy-items" style="display:flex;gap:4px;flex-wrap:wrap;min-height:30px;"></div>
        <div style="display:flex;gap:4px;margin-top:8px;">
            <button onclick="buyQuickBuyItems()" style="flex:1;padding:4px 8px;background:#ffd700;border:none;border-radius:4px;color:#000;font-size:11px;cursor:pointer;font-weight:600;">BUY [F5]</button>
            <button onclick="clearQuickBuy()" style="padding:4px 8px;background:#444;border:none;border-radius:4px;color:#fff;font-size:11px;cursor:pointer;">Clear</button>
        </div>
        <p style="color:#556;font-size:9px;margin:4px 0 0 0;text-align:center;">Shift+click to add items</p>
    </div>

    <!-- ROUND 9: Inventory display -->
    <div id="inventory-panel" style="position:absolute;left:330px;bottom:25px;display:flex;gap:4px;z-index:100;pointer-events:none;">
        <!-- Filled by JS -->
    </div>

    <div class="hud-container">
        <!-- Character Stats -->
        <div class="character-panel">
            <div class="portrait" id="portrait-container">
                <!-- 3D Portrait Canvas appended here -->
            </div>
            <div class="stats-area">
                <div>
                    <span class="unit-name">Void Walker</span><span class="unit-level">Lvl 1</span>
                </div>
                <div style="margin-top: 8px;">
                    <div class="stat-row"><span>Damage</span><span class="stat-val" id="stat-dmg">45</span></div>
                    <div class="stat-row"><span>Armor</span><span class="stat-val" id="stat-armor">3</span></div>
                    <!-- ROUND 8: Gold display -->
                    <div class="stat-row"><span style="color: #ffd700;">Gold</span><span class="stat-val" id="stat-gold" style="color: #ffd700;">0</span></div>
                </div>
            </div>
        </div>

        <!-- Skills -->
        <div class="center-panel">
            <div class="bars-container">
                <div class="bar-wrap">
                    <div class="bar-fill hp-fill" id="hp-bar" style="width: 100%"></div>
                    <div class="bar-text" id="hp-text">1200 / 1200</div>
                </div>
                <div class="bar-wrap">
                    <div class="bar-fill mp-fill" id="mp-bar" style="width: 100%"></div>
                    <div class="bar-text" id="mp-text">600 / 600</div>
                </div>
                <!-- ROUND 7: XP Bar -->
                <div class="bar-wrap" style="height: 10px;">
                    <div class="bar-fill" id="xp-bar" style="width: 0%; background: linear-gradient(90deg, #ffd700, #ffaa00); box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);"></div>
                    <div class="bar-text" id="xp-text" style="font-size: 8px; line-height: 10px;">0 / 100 XP</div>
                </div>
            </div>

            <div class="ability-bar">
                <!-- ROUND 5: Added onclick for mobile touch support -->
                <div class="ability-slot" id="ab-q" onclick="castAbility('q')">
                    <span class="hotkey">Q</span>
                    <div class="ability-icon">üåÄ</div>
                    <span class="mana-cost">60</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-w" onclick="castAbility('w')">
                    <span class="hotkey">W</span>
                    <div class="ability-icon">‚ö°</div>
                    <span class="mana-cost">40</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-e" onclick="castAbility('e')">
                    <span class="hotkey">E</span>
                    <div class="ability-icon">üõ°Ô∏è</div>
                    <span class="mana-cost">80</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-r" onclick="castAbility('r')">
                    <span class="hotkey">R</span>
                    <div class="ability-icon">‚òÑÔ∏è</div>
                    <span class="mana-cost">150</span>
                    <div class="cooldown-mask"></div>
                </div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="right-panel">
            <canvas id="minimap-canvas" role="img" aria-label="Game minimap showing player and enemy positions"></canvas>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        // --- GAME ENGINE ---

        // Constants
        const TEAM_RADIANT = 'radiant';
        const TEAM_DIRE = 'dire';
        const COLOR_RADIANT = 0x00ff88;
        const COLOR_DIRE = 0xff3c3c;

        // ============================================
        // FULL HERO ROSTER - 24 PLAYABLE HEROES
        // ============================================
        const HERO_DEFS = {
            // === STRENGTH HEROES ===
            axe: {
                name: 'Axe',
                color: 0xcc2222,
                icon: 'ü™ì',
                attr: 'strength',
                description: 'Berserker warrior who forces enemies to attack him',
                stats: { hp: 1800, mp: 400, damage: 45, armor: 6, speed: 0.22, critChance: 0.10 },
                abilities: {
                    q: { name: 'Berserker Call', cd: 10, cost: 80, icon: 'üì¢', desc: 'Taunt enemies, gain armor' },
                    w: { name: 'Battle Hunger', cd: 8, cost: 60, icon: 'üò§', desc: 'DoT until they kill' },
                    e: { name: 'Counter Helix', cd: 0, cost: 0, icon: 'üåÄ', desc: 'Spin on hit, damage all' },
                    r: { name: 'Culling Blade', cd: 50, cost: 150, icon: '‚öîÔ∏è', desc: 'Execute low HP enemies' }
                }
            },
            pudge: {
                name: 'Pudge',
                color: 0x556b2f,
                icon: 'ü™ù',
                attr: 'strength',
                description: 'The Butcher drags victims with his hook',
                stats: { hp: 2000, mp: 350, damage: 40, armor: 4, speed: 0.18, critChance: 0.05 },
                abilities: {
                    q: { name: 'Meat Hook', cd: 12, cost: 100, icon: 'ü™ù', desc: 'Hook and drag enemy' },
                    w: { name: 'Rot', cd: 0, cost: 0, icon: '‚ò†Ô∏è', desc: 'Toggle AOE damage' },
                    e: { name: 'Flesh Heap', cd: 0, cost: 0, icon: 'üí™', desc: 'Gain STR from kills' },
                    r: { name: 'Dismember', cd: 25, cost: 120, icon: 'ü¶∑', desc: 'Channel, devour enemy' }
                }
            },
            earthshaker: {
                name: 'Earthshaker',
                color: 0xd2691e,
                icon: 'üî®',
                attr: 'strength',
                description: 'Master of earthquakes and fissures',
                stats: { hp: 1600, mp: 500, damage: 38, armor: 5, speed: 0.20, critChance: 0.08 },
                abilities: {
                    q: { name: 'Fissure', cd: 15, cost: 120, icon: 'üåã', desc: 'Line stun, block path' },
                    w: { name: 'Enchant Totem', cd: 5, cost: 40, icon: 'ü™Ñ', desc: 'Next hit deals 3x dmg' },
                    e: { name: 'Aftershock', cd: 0, cost: 0, icon: 'üí•', desc: 'Stun after each spell' },
                    r: { name: 'Echo Slam', cd: 100, cost: 200, icon: 'üîä', desc: 'Massive AOE, more enemies = more dmg' }
                }
            },
            sven: {
                name: 'Sven',
                color: 0x4169e1,
                icon: '‚öîÔ∏è',
                attr: 'strength',
                description: 'Rogue Knight with massive cleave damage',
                stats: { hp: 1700, mp: 450, damage: 55, armor: 5, speed: 0.24, critChance: 0.12 },
                abilities: {
                    q: { name: 'Storm Hammer', cd: 12, cost: 100, icon: 'üî®', desc: 'Throw hammer, stun AOE' },
                    w: { name: 'Great Cleave', cd: 0, cost: 0, icon: 'üåä', desc: 'Attacks hit in cone' },
                    e: { name: 'Warcry', cd: 20, cost: 60, icon: 'üì£', desc: 'Team armor + speed' },
                    r: { name: "God's Strength", cd: 80, cost: 150, icon: 'üëä', desc: 'Triple damage for 25s' }
                }
            },
            centaur: {
                name: 'Centaur',
                color: 0x8b4513,
                icon: 'üê¥',
                attr: 'strength',
                description: 'Massive beast that stomps and charges',
                stats: { hp: 2200, mp: 300, damage: 42, armor: 7, speed: 0.20, critChance: 0.05 },
                abilities: {
                    q: { name: 'Hoof Stomp', cd: 15, cost: 100, icon: 'ü¶∂', desc: 'Stomp, stun around' },
                    w: { name: 'Double Edge', cd: 5, cost: 0, icon: 'üó°Ô∏è', desc: 'Massive dmg, hurts self' },
                    e: { name: 'Retaliate', cd: 0, cost: 0, icon: 'üõ°Ô∏è', desc: 'Return damage when hit' },
                    r: { name: 'Stampede', cd: 90, cost: 150, icon: 'üèÉ', desc: 'Team haste + stun on hit' }
                }
            },
            tidehunter: {
                name: 'Tidehunter',
                color: 0x20b2aa,
                icon: 'üêô',
                attr: 'strength',
                description: 'Ocean terror with devastating ultimate',
                stats: { hp: 1900, mp: 400, damage: 35, armor: 6, speed: 0.19, critChance: 0.05 },
                abilities: {
                    q: { name: 'Gush', cd: 10, cost: 80, icon: 'üí¶', desc: 'Slow and armor reduce' },
                    w: { name: 'Kraken Shell', cd: 0, cost: 0, icon: 'üêö', desc: 'Block damage, dispel' },
                    e: { name: 'Anchor Smash', cd: 6, cost: 40, icon: '‚öì', desc: 'AOE damage + reduce dmg' },
                    r: { name: 'Ravage', cd: 120, cost: 250, icon: 'üåä', desc: 'Massive AOE stun wave' }
                }
            },
            // === AGILITY HEROES ===
            phantom_assassin: {
                name: 'Phantom Assassin',
                color: 0x4b0082,
                icon: 'üó°Ô∏è',
                attr: 'agility',
                description: 'Deadly assassin with devastating crits',
                stats: { hp: 1100, mp: 450, damage: 55, armor: 3, speed: 0.30, critChance: 0.20 },
                abilities: {
                    q: { name: 'Stifling Dagger', cd: 6, cost: 40, icon: 'üó°Ô∏è', desc: 'Throw slow dagger' },
                    w: { name: 'Phantom Strike', cd: 8, cost: 60, icon: '‚ö°', desc: 'Blink to target, attack speed' },
                    e: { name: 'Blur', cd: 0, cost: 0, icon: 'üëª', desc: '35% evasion' },
                    r: { name: 'Coup de Grace', cd: 0, cost: 0, icon: 'üíÄ', desc: '450% crit chance' }
                }
            },
            juggernaut: {
                name: 'Juggernaut',
                color: 0xff4500,
                icon: '‚öîÔ∏è',
                attr: 'agility',
                description: 'Spinning swordmaster with healing ward',
                stats: { hp: 1200, mp: 500, damage: 50, armor: 4, speed: 0.28, critChance: 0.18 },
                abilities: {
                    q: { name: 'Blade Fury', cd: 20, cost: 80, icon: 'üåÄ', desc: 'Spin, spell immune, damage' },
                    w: { name: 'Healing Ward', cd: 45, cost: 100, icon: 'üíö', desc: 'Ward heals team' },
                    e: { name: 'Blade Dance', cd: 0, cost: 0, icon: 'üíÉ', desc: '35% crit chance' },
                    r: { name: 'Omnislash', cd: 100, cost: 180, icon: '‚öîÔ∏è', desc: 'Invuln, bounce slashes' }
                }
            },
            antimage: {
                name: 'Anti-Mage',
                color: 0x00ced1,
                icon: 'üîÆ',
                attr: 'agility',
                description: 'Mage hunter who burns mana',
                stats: { hp: 1000, mp: 400, damage: 48, armor: 3, speed: 0.32, critChance: 0.10 },
                abilities: {
                    q: { name: 'Mana Break', cd: 0, cost: 0, icon: 'üí´', desc: 'Attacks burn mana' },
                    w: { name: 'Blink', cd: 5, cost: 30, icon: '‚ö°', desc: 'Short teleport' },
                    e: { name: 'Counterspell', cd: 12, cost: 50, icon: 'üõ°Ô∏è', desc: 'Reflect spells' },
                    r: { name: 'Mana Void', cd: 60, cost: 100, icon: 'üí•', desc: 'Explode missing mana' }
                }
            },
            drow_ranger: {
                name: 'Drow Ranger',
                color: 0x87ceeb,
                icon: 'üèπ',
                attr: 'agility',
                description: 'Frost archer who silences enemies',
                stats: { hp: 950, mp: 450, damage: 52, armor: 2, speed: 0.26, critChance: 0.12 },
                abilities: {
                    q: { name: 'Frost Arrows', cd: 0, cost: 10, icon: '‚ùÑÔ∏è', desc: 'Toggle slow arrows' },
                    w: { name: 'Gust', cd: 14, cost: 80, icon: 'üí®', desc: 'Silence and push back' },
                    e: { name: 'Multishot', cd: 20, cost: 60, icon: 'üéØ', desc: 'Fire arrows in cone' },
                    r: { name: 'Marksmanship', cd: 0, cost: 0, icon: 'üèπ', desc: 'Massive agility bonus' }
                }
            },
            faceless_void: {
                name: 'Faceless Void',
                color: 0x483d8b,
                icon: '‚è∞',
                attr: 'agility',
                description: 'Time-bending carry who stops time',
                stats: { hp: 1100, mp: 400, damage: 50, armor: 3, speed: 0.28, critChance: 0.15 },
                abilities: {
                    q: { name: 'Time Walk', cd: 6, cost: 40, icon: 'üö∂', desc: 'Dash, undo recent damage' },
                    w: { name: 'Time Dilation', cd: 16, cost: 60, icon: '‚è±Ô∏è', desc: 'Freeze enemy cooldowns' },
                    e: { name: 'Time Lock', cd: 0, cost: 0, icon: 'üîí', desc: 'Chance to bash + dmg' },
                    r: { name: 'Chronosphere', cd: 120, cost: 200, icon: '‚è∞', desc: 'Freeze time in AOE' }
                }
            },
            spectre: {
                name: 'Spectre',
                color: 0x9932cc,
                icon: 'üëª',
                attr: 'agility',
                description: 'Ghost who haunts all enemies at once',
                stats: { hp: 1150, mp: 350, damage: 48, armor: 4, speed: 0.26, critChance: 0.10 },
                abilities: {
                    q: { name: 'Spectral Dagger', cd: 16, cost: 100, icon: 'üó°Ô∏è', desc: 'Slow path, phase through' },
                    w: { name: 'Desolate', cd: 0, cost: 0, icon: 'üíî', desc: 'Bonus dmg if alone' },
                    e: { name: 'Dispersion', cd: 0, cost: 0, icon: 'üîÑ', desc: 'Reflect damage taken' },
                    r: { name: 'Haunt', cd: 140, cost: 200, icon: 'üëª', desc: 'Illusion at every enemy' }
                }
            },
            // === INTELLIGENCE HEROES ===
            crystal_maiden: {
                name: 'Crystal Maiden',
                color: 0x00bfff,
                icon: '‚ùÑÔ∏è',
                attr: 'intelligence',
                description: 'Frost mage who freezes and provides mana',
                stats: { hp: 850, mp: 700, damage: 28, armor: 1, speed: 0.18, critChance: 0.05 },
                abilities: {
                    q: { name: 'Crystal Nova', cd: 10, cost: 80, icon: '‚ùÑÔ∏è', desc: 'AOE slow and damage' },
                    w: { name: 'Frostbite', cd: 9, cost: 70, icon: 'ü•∂', desc: 'Root and damage' },
                    e: { name: 'Arcane Aura', cd: 0, cost: 0, icon: 'üíô', desc: 'Team mana regen' },
                    r: { name: 'Freezing Field', cd: 90, cost: 250, icon: 'üå®Ô∏è', desc: 'Channel massive AOE' }
                }
            },
            lion: {
                name: 'Lion',
                color: 0x8b0000,
                icon: 'ü¶Å',
                attr: 'intelligence',
                description: 'Demon Witch with devastating finger',
                stats: { hp: 900, mp: 650, damage: 32, armor: 2, speed: 0.22, critChance: 0.05 },
                abilities: {
                    q: { name: 'Earth Spike', cd: 10, cost: 90, icon: 'üåã', desc: 'Line stun' },
                    w: { name: 'Hex', cd: 16, cost: 100, icon: 'üê∏', desc: 'Turn enemy to frog' },
                    e: { name: 'Mana Drain', cd: 10, cost: 0, icon: 'üíß', desc: 'Steal mana' },
                    r: { name: 'Finger of Death', cd: 60, cost: 200, icon: 'üëÜ', desc: 'Massive single damage' }
                }
            },
            invoker: {
                name: 'Invoker',
                color: 0xffd700,
                icon: 'üåü',
                attr: 'intelligence',
                description: 'Arsenal mage with 10 spells',
                stats: { hp: 1000, mp: 800, damage: 35, armor: 2, speed: 0.24, critChance: 0.08 },
                abilities: {
                    q: { name: 'Sun Strike', cd: 25, cost: 120, icon: '‚òÄÔ∏è', desc: 'Global delayed damage' },
                    w: { name: 'Tornado', cd: 20, cost: 100, icon: 'üå™Ô∏è', desc: 'Lift and disable' },
                    e: { name: 'Cold Snap', cd: 16, cost: 80, icon: '‚ùÑÔ∏è', desc: 'Mini-stun on damage' },
                    r: { name: 'Deafening Blast', cd: 40, cost: 180, icon: 'üí®', desc: 'Knockback and disarm' }
                }
            },
            lina: {
                name: 'Lina',
                color: 0xff6347,
                icon: 'üî•',
                attr: 'intelligence',
                description: 'Fiery sorceress with rapid attacks',
                stats: { hp: 900, mp: 700, damage: 38, armor: 1, speed: 0.26, critChance: 0.08 },
                abilities: {
                    q: { name: 'Dragon Slave', cd: 8, cost: 90, icon: 'üêâ', desc: 'Fire wave damage' },
                    w: { name: 'Light Strike', cd: 10, cost: 100, icon: '‚ö°', desc: 'Delayed AOE stun' },
                    e: { name: 'Fiery Soul', cd: 0, cost: 0, icon: 'üíÉ', desc: 'Stacking attack speed' },
                    r: { name: 'Laguna Blade', cd: 50, cost: 250, icon: '‚ö°', desc: 'Massive single target' }
                }
            },
            shadow_shaman: {
                name: 'Shadow Shaman',
                color: 0x32cd32,
                icon: 'üêç',
                attr: 'intelligence',
                description: 'Hex master with serpent wards',
                stats: { hp: 950, mp: 600, damage: 34, armor: 2, speed: 0.22, critChance: 0.05 },
                abilities: {
                    q: { name: 'Ether Shock', cd: 8, cost: 80, icon: '‚ö°', desc: 'Chain lightning' },
                    w: { name: 'Hex', cd: 12, cost: 90, icon: 'üêî', desc: 'Turn to chicken' },
                    e: { name: 'Shackles', cd: 14, cost: 100, icon: '‚õìÔ∏è', desc: 'Channel, hold enemy' },
                    r: { name: 'Mass Serpent', cd: 100, cost: 200, icon: 'üêç', desc: 'Summon 8 wards' }
                }
            },
            zeus: {
                name: 'Zeus',
                color: 0x1e90ff,
                icon: '‚ö°',
                attr: 'intelligence',
                description: 'Lord of Lightning, global ult',
                stats: { hp: 850, mp: 750, damage: 40, armor: 1, speed: 0.24, critChance: 0.05 },
                abilities: {
                    q: { name: 'Arc Lightning', cd: 1.5, cost: 40, icon: '‚ö°', desc: 'Bouncing lightning' },
                    w: { name: 'Lightning Bolt', cd: 6, cost: 80, icon: 'üå©Ô∏è', desc: 'Single target nuke' },
                    e: { name: 'Static Field', cd: 0, cost: 0, icon: 'üí´', desc: 'Spells deal %HP' },
                    r: { name: "Thundergod's Wrath", cd: 90, cost: 300, icon: 'üå©Ô∏è', desc: 'Hit all enemies globally' }
                }
            },
            necrophos: {
                name: 'Necrophos',
                color: 0x228b22,
                icon: 'üíÄ',
                attr: 'intelligence',
                description: 'Plague bringer who grows stronger from death',
                stats: { hp: 1100, mp: 600, damage: 32, armor: 3, speed: 0.22, critChance: 0.05 },
                abilities: {
                    q: { name: 'Death Pulse', cd: 6, cost: 80, icon: 'üíö', desc: 'Heal allies, damage enemies' },
                    w: { name: 'Ghost Shroud', cd: 18, cost: 60, icon: 'üëª', desc: 'Ethereal, amplify healing' },
                    e: { name: 'Heartstopper', cd: 0, cost: 0, icon: 'üíî', desc: 'Aura %HP damage' },
                    r: { name: "Reaper's Scythe", cd: 80, cost: 200, icon: 'üíÄ', desc: 'Execute based on missing HP' }
                }
            },
            // === UNIVERSAL/SPECIAL HEROES ===
            voidwalker: {
                name: 'Void Walker',
                color: 0x00ff88,
                icon: 'üåÄ',
                attr: 'agility',
                description: 'Agile assassin with blink and burst damage',
                stats: { hp: 1200, mp: 600, damage: 45, armor: 3, speed: 0.28, critChance: 0.15 },
                abilities: {
                    q: { name: 'Void Bolt', cd: 2, cost: 60, icon: 'üåÄ', desc: 'Fire energy projectile' },
                    w: { name: 'Blink', cd: 5, cost: 40, icon: '‚ö°', desc: 'Dash forward' },
                    e: { name: 'Void Shield', cd: 12, cost: 80, icon: 'üõ°Ô∏è', desc: 'Absorb damage' },
                    r: { name: 'Void Nova', cd: 40, cost: 150, icon: 'üí•', desc: 'Massive AOE damage' }
                }
            },
            ironclad: {
                name: 'Iron Clad',
                color: 0xccaa44,
                icon: 'üõ°Ô∏è',
                attr: 'strength',
                description: 'Durable tank with high armor and crowd control',
                stats: { hp: 1800, mp: 400, damage: 35, armor: 8, speed: 0.18, critChance: 0.05 },
                abilities: {
                    q: { name: 'Shield Slam', cd: 3, cost: 50, icon: 'üõ°Ô∏è', desc: 'Stun nearby enemies' },
                    w: { name: 'Charge', cd: 8, cost: 60, icon: 'üêÇ', desc: 'Rush forward' },
                    e: { name: 'Fortify', cd: 15, cost: 100, icon: 'üè∞', desc: 'Triple armor briefly' },
                    r: { name: 'Earthquake', cd: 50, cost: 200, icon: 'üåã', desc: 'Ground slam AOE' }
                }
            },
            pyromancer: {
                name: 'Pyromancer',
                color: 0xff6622,
                icon: 'üî•',
                attr: 'intelligence',
                description: 'Glass cannon mage with powerful fire spells',
                stats: { hp: 900, mp: 800, damage: 30, armor: 1, speed: 0.22, critChance: 0.08 },
                abilities: {
                    q: { name: 'Fireball', cd: 1.5, cost: 40, icon: 'üî•', desc: 'Fast fire projectile' },
                    w: { name: 'Flame Dash', cd: 6, cost: 50, icon: 'üí®', desc: 'Leave fire trail' },
                    e: { name: 'Ignite', cd: 10, cost: 70, icon: 'üå°Ô∏è', desc: 'Burn enemies over time' },
                    r: { name: 'Inferno', cd: 35, cost: 180, icon: '‚òÄÔ∏è', desc: 'Rain fire from sky' }
                }
            },
            shadowblade: {
                name: 'Shadow Blade',
                color: 0x8844ff,
                icon: 'üó°Ô∏è',
                attr: 'agility',
                description: 'Stealth assassin with high crit damage',
                stats: { hp: 1000, mp: 500, damage: 60, armor: 2, speed: 0.30, critChance: 0.25 },
                abilities: {
                    q: { name: 'Shadow Strike', cd: 2, cost: 45, icon: 'üó°Ô∏è', desc: 'Teleport to target' },
                    w: { name: 'Vanish', cd: 10, cost: 80, icon: 'üëÅÔ∏è', desc: 'Become invisible' },
                    e: { name: 'Poison Blade', cd: 8, cost: 55, icon: '‚ò†Ô∏è', desc: 'Next hit poisons' },
                    r: { name: 'Death Mark', cd: 45, cost: 160, icon: 'üíÄ', desc: 'Execute low HP targets' }
                }
            }
        };

        let selectedHeroType = null;

        // LANE DEFINITIONS - Top, Mid, Bot
        // Map layout: Radiant base at (-45,-45), Dire base at (45,45)
        // Top lane: goes up left side, then across top to Dire
        // Mid lane: diagonal through center
        // Bot lane: goes across bottom, then up right side to Dire
        const LANES = {
            top: {
                radiantSpawn: { x: -42, z: -38 },  // Near left side
                direSpawn: { x: 38, z: 42 },       // Near top side from Dire
                waypoints: {
                    radiant: [{ x: -42, z: 0 }, { x: -42, z: 35 }, { x: 0, z: 42 }, { x: 35, z: 42 }],
                    dire: [{ x: 0, z: 42 }, { x: -35, z: 42 }, { x: -42, z: 0 }, { x: -42, z: -35 }]
                },
                towers: {
                    radiant: [{ x: -42, z: -25 }, { x: -42, z: 10 }],
                    dire: [{ x: 10, z: 42 }, { x: 25, z: 42 }]
                }
            },
            mid: {
                radiantSpawn: { x: -38, z: -38 },  // Center path from Radiant
                direSpawn: { x: 38, z: 38 },       // Center path from Dire
                waypoints: {
                    radiant: [{ x: -20, z: -20 }, { x: 0, z: 0 }, { x: 20, z: 20 }],
                    dire: [{ x: 20, z: 20 }, { x: 0, z: 0 }, { x: -20, z: -20 }]
                },
                towers: {
                    radiant: [{ x: -28, z: -28 }, { x: -15, z: -15 }],
                    dire: [{ x: 15, z: 15 }, { x: 28, z: 28 }]
                }
            },
            bot: {
                radiantSpawn: { x: -38, z: -42 },  // Near bottom side
                direSpawn: { x: 42, z: 38 },       // Near right side from Dire
                waypoints: {
                    radiant: [{ x: 0, z: -42 }, { x: 35, z: -42 }, { x: 42, z: 0 }, { x: 42, z: 35 }],
                    dire: [{ x: 42, z: 0 }, { x: 42, z: -35 }, { x: 0, z: -42 }, { x: -35, z: -42 }]
                },
                towers: {
                    radiant: [{ x: -25, z: -42 }, { x: 10, z: -42 }],
                    dire: [{ x: 42, z: -10 }, { x: 42, z: 25 }]
                }
            }
        };

        // ============================================
        // 3D MODEL BUILDER SYSTEM
        // ============================================

        // Detailed body part definitions for heroes
        const HERO_MODELS = {
            voidwalker: {
                scale: 1.0,
                bodyParts: [
                    // Torso
                    { name: 'torso', shape: 'box', width: 0.6, height: 0.9, depth: 0.4, color: '#00ff88', position: [0, 1.2, 0], emissive: '#004422', shininess: 60 },
                    // Chest plate
                    { name: 'chestPlate', shape: 'box', width: 0.65, height: 0.5, depth: 0.15, color: '#00aa66', position: [0, 1.4, 0.2], shininess: 80 },
                    // Head
                    { name: 'head', shape: 'sphere', size: 0.25, color: '#00ff88', position: [0, 2.0, 0], emissive: '#004422', shininess: 70 },
                    // Visor/eyes
                    { name: 'visor', shape: 'box', width: 0.3, height: 0.08, depth: 0.1, color: '#00ffff', position: [0, 2.0, 0.2], emissive: '#00ffff', shininess: 100 },
                    // Shoulders
                    { name: 'shoulderL', shape: 'box', width: 0.25, height: 0.2, depth: 0.25, color: '#00cc66', position: [-0.45, 1.5, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.25, height: 0.2, depth: 0.25, color: '#00cc66', position: [0.45, 1.5, 0], shininess: 50 },
                    // Arms
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#00dd77', position: [-0.45, 1.0, 0], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#00dd77', position: [0.45, 1.0, 0], shininess: 40 },
                    // Hands with blade effects
                    { name: 'handL', shape: 'box', width: 0.12, height: 0.15, depth: 0.08, color: '#00ffaa', position: [-0.45, 0.6, 0], shininess: 60 },
                    { name: 'handR', shape: 'box', width: 0.12, height: 0.15, depth: 0.08, color: '#00ffaa', position: [0.45, 0.6, 0], shininess: 60 },
                    // Blades
                    { name: 'bladeL', shape: 'box', width: 0.03, height: 0.5, depth: 0.15, color: '#00ffff', position: [-0.45, 0.3, 0.1], emissive: '#00cccc', shininess: 100 },
                    { name: 'bladeR', shape: 'box', width: 0.03, height: 0.5, depth: 0.15, color: '#00ffff', position: [0.45, 0.3, 0.1], emissive: '#00cccc', shininess: 100 },
                    // Legs
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#00bb66', position: [-0.2, 0.35, 0], shininess: 40 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#00bb66', position: [0.2, 0.35, 0], shininess: 40 },
                    // Feet
                    { name: 'footL', shape: 'box', width: 0.12, height: 0.08, depth: 0.2, color: '#008855', position: [-0.2, 0.04, 0.05], shininess: 30 },
                    { name: 'footR', shape: 'box', width: 0.12, height: 0.08, depth: 0.2, color: '#008855', position: [0.2, 0.04, 0.05], shininess: 30 },
                    // Energy core
                    { name: 'core', shape: 'sphere', size: 0.15, color: '#00ffff', position: [0, 1.2, 0], emissive: '#00ffff', shininess: 100 },
                    // Cape/cloak effect
                    { name: 'cape', shape: 'box', width: 0.5, height: 0.8, depth: 0.05, color: '#006644', position: [0, 1.0, -0.25], shininess: 20 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            ironclad: {
                scale: 1.2,
                bodyParts: [
                    // Massive torso
                    { name: 'torso', shape: 'box', width: 1.0, height: 1.2, depth: 0.7, color: '#ccaa44', position: [0, 1.4, 0], shininess: 70 },
                    // Chest armor
                    { name: 'chestArmor', shape: 'box', width: 1.1, height: 0.6, depth: 0.2, color: '#ddbb55', position: [0, 1.6, 0.35], shininess: 90 },
                    // Head with helmet
                    { name: 'helmet', shape: 'box', width: 0.5, height: 0.45, depth: 0.45, color: '#bb9933', position: [0, 2.3, 0], shininess: 80 },
                    { name: 'visor', shape: 'box', width: 0.35, height: 0.12, depth: 0.1, color: '#ffdd00', position: [0, 2.25, 0.25], emissive: '#ffaa00', shininess: 100 },
                    // Horns
                    { name: 'hornL', shape: 'cone', size: 0.08, height: 0.3, color: '#aa8822', position: [-0.25, 2.5, -0.1], rotation: [0, 0, -0.3], shininess: 60 },
                    { name: 'hornR', shape: 'cone', size: 0.08, height: 0.3, color: '#aa8822', position: [0.25, 2.5, -0.1], rotation: [0, 0, 0.3], shininess: 60 },
                    // Massive shoulders
                    { name: 'shoulderL', shape: 'box', width: 0.5, height: 0.4, depth: 0.4, color: '#ccaa44', position: [-0.8, 1.7, 0], shininess: 70 },
                    { name: 'shoulderR', shape: 'box', width: 0.5, height: 0.4, depth: 0.4, color: '#ccaa44', position: [0.8, 1.7, 0], shininess: 70 },
                    // Shoulder spikes
                    { name: 'spikeL', shape: 'cone', size: 0.1, height: 0.25, color: '#ffcc00', position: [-0.9, 1.95, 0], emissive: '#aa8800', shininess: 80 },
                    { name: 'spikeR', shape: 'cone', size: 0.1, height: 0.25, color: '#ffcc00', position: [0.9, 1.95, 0], emissive: '#aa8800', shininess: 80 },
                    // Arms
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.2, height: 0.8, color: '#bb9944', position: [-0.7, 1.0, 0], shininess: 50 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.2, height: 0.8, color: '#bb9944', position: [0.7, 1.0, 0], shininess: 50 },
                    // Shield on left arm
                    { name: 'shield', shape: 'box', width: 0.6, height: 0.8, depth: 0.1, color: '#ddcc66', position: [-0.9, 0.8, 0.2], emissive: '#554400', shininess: 90 },
                    // Hammer in right hand
                    { name: 'hammerHandle', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.05, height: 0.7, color: '#885522', position: [0.7, 0.5, 0.15], shininess: 30 },
                    { name: 'hammerHead', shape: 'box', width: 0.3, height: 0.25, depth: 0.2, color: '#ccaa44', position: [0.7, 0.15, 0.15], emissive: '#665522', shininess: 80 },
                    // Legs
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.2, height: 0.9, color: '#aa8833', position: [-0.3, 0.45, 0], shininess: 50 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.2, height: 0.9, color: '#aa8833', position: [0.3, 0.45, 0], shininess: 50 },
                    // Boots
                    { name: 'bootL', shape: 'box', width: 0.22, height: 0.15, depth: 0.3, color: '#775522', position: [-0.3, 0.07, 0.05], shininess: 40 },
                    { name: 'bootR', shape: 'box', width: 0.22, height: 0.15, depth: 0.3, color: '#775522', position: [0.3, 0.07, 0.05], shininess: 40 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            pyromancer: {
                scale: 0.9,
                bodyParts: [
                    // Robed torso
                    { name: 'robe', shape: 'cone', size: 0.4, height: 1.2, color: '#ff6622', position: [0, 0.6, 0], shininess: 30 },
                    // Upper body
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.6, depth: 0.35, color: '#dd5511', position: [0, 1.4, 0], shininess: 40 },
                    // Flame trim
                    { name: 'flameTrim', shape: 'box', width: 0.55, height: 0.1, depth: 0.4, color: '#ff8800', position: [0, 1.1, 0], emissive: '#ff4400', shininess: 60 },
                    // Head
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#ffaa66', position: [0, 1.9, 0], shininess: 50 },
                    // Hood
                    { name: 'hood', shape: 'box', width: 0.35, height: 0.25, depth: 0.3, color: '#cc4400', position: [0, 2.0, -0.05], shininess: 25 },
                    // Eyes (glowing)
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#ffff00', position: [-0.08, 1.92, 0.15], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#ffff00', position: [0.08, 1.92, 0.15], emissive: '#ffaa00', shininess: 100 },
                    // Arms with sleeves
                    { name: 'sleeveL', shape: 'cone', size: 0.15, height: 0.5, color: '#dd5511', position: [-0.4, 1.2, 0], rotation: [0, 0, 0.5], shininess: 30 },
                    { name: 'sleeveR', shape: 'cone', size: 0.15, height: 0.5, color: '#dd5511', position: [0.4, 1.2, 0], rotation: [0, 0, -0.5], shininess: 30 },
                    // Hands
                    { name: 'handL', shape: 'sphere', size: 0.08, color: '#ffaa66', position: [-0.55, 0.95, 0.1], shininess: 40 },
                    { name: 'handR', shape: 'sphere', size: 0.08, color: '#ffaa66', position: [0.55, 0.95, 0.1], shininess: 40 },
                    // Staff
                    { name: 'staff', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.04, height: 1.8, color: '#442200', position: [0.6, 1.0, 0.1], shininess: 40 },
                    { name: 'staffOrb', shape: 'sphere', size: 0.12, color: '#ff4400', position: [0.6, 1.95, 0.1], emissive: '#ff2200', shininess: 100 },
                    // Fire effects around orb
                    { name: 'flame1', shape: 'cone', size: 0.06, height: 0.15, color: '#ffaa00', position: [0.6, 2.1, 0.1], emissive: '#ff6600', shininess: 80 },
                    { name: 'flame2', shape: 'cone', size: 0.05, height: 0.12, color: '#ffcc00', position: [0.55, 2.05, 0.15], emissive: '#ff8800', shininess: 80 },
                    { name: 'flame3', shape: 'cone', size: 0.05, height: 0.12, color: '#ffcc00', position: [0.65, 2.05, 0.05], emissive: '#ff8800', shininess: 80 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            shadowblade: {
                scale: 0.95,
                bodyParts: [
                    // Lean torso
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.8, depth: 0.3, color: '#8844ff', position: [0, 1.3, 0], emissive: '#220066', shininess: 50 },
                    // Chest armor (light)
                    { name: 'chest', shape: 'box', width: 0.45, height: 0.4, depth: 0.15, color: '#6633cc', position: [0, 1.5, 0.15], shininess: 70 },
                    // Head with mask
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#9955ff', position: [0, 2.0, 0], shininess: 50 },
                    { name: 'mask', shape: 'box', width: 0.25, height: 0.15, depth: 0.12, color: '#333333', position: [0, 1.95, 0.12], shininess: 30 },
                    { name: 'eyes', shape: 'box', width: 0.2, height: 0.04, depth: 0.05, color: '#ff00ff', position: [0, 2.0, 0.18], emissive: '#cc00cc', shininess: 100 },
                    // Hood
                    { name: 'hood', shape: 'cone', size: 0.25, height: 0.3, color: '#442288', position: [0, 2.15, -0.05], shininess: 25 },
                    // Shoulders (spiked)
                    { name: 'shoulderL', shape: 'box', width: 0.2, height: 0.15, depth: 0.2, color: '#6633cc', position: [-0.4, 1.55, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.2, height: 0.15, depth: 0.2, color: '#6633cc', position: [0.4, 1.55, 0], shininess: 50 },
                    // Arms
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.6, color: '#7744dd', position: [-0.4, 1.0, 0], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.6, color: '#7744dd', position: [0.4, 1.0, 0], shininess: 40 },
                    // Daggers
                    { name: 'daggerL', shape: 'box', width: 0.02, height: 0.4, depth: 0.06, color: '#aaaaaa', position: [-0.4, 0.55, 0.1], emissive: '#444444', shininess: 100 },
                    { name: 'daggerR', shape: 'box', width: 0.02, height: 0.4, depth: 0.06, color: '#aaaaaa', position: [0.4, 0.55, 0.1], emissive: '#444444', shininess: 100 },
                    // Dagger glow
                    { name: 'poisonL', shape: 'sphere', size: 0.03, color: '#00ff00', position: [-0.4, 0.35, 0.1], emissive: '#00cc00', shininess: 100 },
                    { name: 'poisonR', shape: 'sphere', size: 0.03, color: '#00ff00', position: [0.4, 0.35, 0.1], emissive: '#00cc00', shininess: 100 },
                    // Legs
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.7, color: '#6633cc', position: [-0.18, 0.35, 0], shininess: 40 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.7, color: '#6633cc', position: [0.18, 0.35, 0], shininess: 40 },
                    // Boots
                    { name: 'bootL', shape: 'box', width: 0.1, height: 0.08, depth: 0.18, color: '#332255', position: [-0.18, 0.04, 0.03], shininess: 30 },
                    { name: 'bootR', shape: 'box', width: 0.1, height: 0.08, depth: 0.18, color: '#332255', position: [0.18, 0.04, 0.03], shininess: 30 },
                    // Cloak
                    { name: 'cloak', shape: 'box', width: 0.6, height: 1.0, depth: 0.05, color: '#221144', position: [0, 1.0, -0.2], shininess: 15 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            // === STRENGTH HERO MODELS ===
            axe: {
                scale: 1.3,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 1.0, height: 1.0, depth: 0.6, color: '#cc2222', position: [0, 1.3, 0], shininess: 50 },
                    { name: 'belly', shape: 'sphere', size: 0.45, color: '#aa1111', position: [0, 1.0, 0.1], shininess: 40 },
                    { name: 'head', shape: 'sphere', size: 0.3, color: '#cc4444', position: [0, 2.0, 0], shininess: 50 },
                    { name: 'helmet', shape: 'box', width: 0.4, height: 0.25, depth: 0.35, color: '#884400', position: [0, 2.15, 0], shininess: 70 },
                    { name: 'hornL', shape: 'cone', size: 0.08, height: 0.3, color: '#aa6600', position: [-0.2, 2.3, 0], rotation: [0, 0, -0.4], shininess: 60 },
                    { name: 'hornR', shape: 'cone', size: 0.08, height: 0.3, color: '#aa6600', position: [0.2, 2.3, 0], rotation: [0, 0, 0.4], shininess: 60 },
                    { name: 'shoulderL', shape: 'sphere', size: 0.25, color: '#992222', position: [-0.6, 1.6, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'sphere', size: 0.25, color: '#992222', position: [0.6, 1.6, 0], shininess: 50 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.7, color: '#cc4444', position: [-0.6, 1.0, 0], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.7, color: '#cc4444', position: [0.6, 1.0, 0], shininess: 40 },
                    { name: 'axeHandle', shape: 'cylinder', radiusTop: 0.04, radiusBottom: 0.04, height: 1.2, color: '#553311', position: [0.7, 0.8, 0.2], rotation: [0.3, 0, 0], shininess: 30 },
                    { name: 'axeBlade', shape: 'box', width: 0.5, height: 0.6, depth: 0.08, color: '#888888', position: [0.7, 1.5, 0.3], emissive: '#ff2200', shininess: 90 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.18, height: 0.8, color: '#aa2222', position: [-0.25, 0.4, 0], shininess: 40 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.18, height: 0.8, color: '#aa2222', position: [0.25, 0.4, 0], shininess: 40 },
                    { name: 'bootL', shape: 'box', width: 0.18, height: 0.12, depth: 0.25, color: '#663311', position: [-0.25, 0.06, 0.03], shininess: 30 },
                    { name: 'bootR', shape: 'box', width: 0.18, height: 0.12, depth: 0.25, color: '#663311', position: [0.25, 0.06, 0.03], shininess: 30 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            pudge: {
                scale: 1.4,
                bodyParts: [
                    { name: 'belly', shape: 'sphere', size: 0.8, color: '#556b2f', position: [0, 1.0, 0], shininess: 30 },
                    { name: 'torso', shape: 'box', width: 0.9, height: 0.6, depth: 0.5, color: '#4a5f29', position: [0, 1.6, 0], shininess: 35 },
                    { name: 'head', shape: 'sphere', size: 0.35, color: '#667744', position: [0, 2.1, 0], shininess: 40 },
                    { name: 'jaw', shape: 'box', width: 0.3, height: 0.15, depth: 0.2, color: '#556633', position: [0, 1.95, 0.2], shininess: 35 },
                    { name: 'eyeL', shape: 'sphere', size: 0.06, color: '#ffff00', position: [-0.12, 2.15, 0.25], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.06, color: '#ffff00', position: [0.12, 2.15, 0.25], emissive: '#ffaa00', shininess: 100 },
                    { name: 'stitchV', shape: 'box', width: 0.02, height: 0.4, depth: 0.01, color: '#333333', position: [0, 1.0, 0.75], shininess: 20 },
                    { name: 'stitchH', shape: 'box', width: 0.5, height: 0.02, depth: 0.01, color: '#333333', position: [0, 1.1, 0.7], shininess: 20 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.2, height: 0.8, color: '#5a6f34', position: [-0.7, 1.2, 0], shininess: 35 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.2, height: 0.8, color: '#5a6f34', position: [0.7, 1.2, 0], shininess: 35 },
                    { name: 'hookHandle', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.03, height: 0.6, color: '#442211', position: [0.8, 0.7, 0.2], shininess: 30 },
                    { name: 'hook', shape: 'cone', size: 0.15, height: 0.4, color: '#888888', position: [0.8, 0.35, 0.3], rotation: [1.57, 0, 0], emissive: '#333333', shininess: 90 },
                    { name: 'cleaver', shape: 'box', width: 0.35, height: 0.5, depth: 0.05, color: '#777777', position: [-0.75, 0.6, 0.15], emissive: '#441111', shininess: 80 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.2, height: 0.6, color: '#4a5929', position: [-0.3, 0.3, 0], shininess: 30 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.2, height: 0.6, color: '#4a5929', position: [0.3, 0.3, 0], shininess: 30 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            earthshaker: {
                scale: 1.2,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.8, height: 1.0, depth: 0.5, color: '#d2691e', position: [0, 1.3, 0], shininess: 50 },
                    { name: 'chest', shape: 'box', width: 0.7, height: 0.4, depth: 0.2, color: '#b8860b', position: [0, 1.5, 0.25], shininess: 60 },
                    { name: 'head', shape: 'sphere', size: 0.28, color: '#cd853f', position: [0, 2.0, 0], shininess: 50 },
                    { name: 'hornL', shape: 'cone', size: 0.06, height: 0.25, color: '#8b4513', position: [-0.15, 2.2, 0], rotation: [0, 0, -0.3], shininess: 40 },
                    { name: 'hornR', shape: 'cone', size: 0.06, height: 0.25, color: '#8b4513', position: [0.15, 2.2, 0], rotation: [0, 0, 0.3], shininess: 40 },
                    { name: 'shoulderL', shape: 'box', width: 0.35, height: 0.25, depth: 0.3, color: '#a0522d', position: [-0.55, 1.55, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.35, height: 0.25, depth: 0.3, color: '#a0522d', position: [0.55, 1.55, 0], shininess: 50 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.13, height: 0.7, color: '#cd853f', position: [-0.55, 1.0, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.13, height: 0.7, color: '#cd853f', position: [0.55, 1.0, 0], shininess: 45 },
                    { name: 'totemHandle', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 1.5, color: '#8b4513', position: [0.6, 1.0, 0.15], shininess: 35 },
                    { name: 'totemHead', shape: 'box', width: 0.35, height: 0.5, depth: 0.2, color: '#654321', position: [0.6, 1.85, 0.15], emissive: '#ff6600', shininess: 60 },
                    { name: 'totemGlow', shape: 'sphere', size: 0.1, color: '#ff8800', position: [0.6, 2.0, 0.25], emissive: '#ff4400', shininess: 100 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.8, color: '#b8860b', position: [-0.22, 0.4, 0], shininess: 45 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.8, color: '#b8860b', position: [0.22, 0.4, 0], shininess: 45 },
                    { name: 'hoofL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.1, color: '#4a3520', position: [-0.22, 0.05, 0], shininess: 30 },
                    { name: 'hoofR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.1, color: '#4a3520', position: [0.22, 0.05, 0], shininess: 30 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            sven: {
                scale: 1.25,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.85, height: 1.0, depth: 0.5, color: '#4169e1', position: [0, 1.3, 0], shininess: 70 },
                    { name: 'chestArmor', shape: 'box', width: 0.9, height: 0.5, depth: 0.2, color: '#1e3a8a', position: [0, 1.55, 0.25], emissive: '#112255', shininess: 85 },
                    { name: 'helmet', shape: 'box', width: 0.4, height: 0.4, depth: 0.4, color: '#1e40af', position: [0, 2.1, 0], shininess: 80 },
                    { name: 'visor', shape: 'box', width: 0.25, height: 0.08, depth: 0.1, color: '#ff4444', position: [0, 2.05, 0.22], emissive: '#ff2222', shininess: 100 },
                    { name: 'hornL', shape: 'box', width: 0.08, height: 0.3, depth: 0.08, color: '#3b82f6', position: [-0.18, 2.35, -0.05], rotation: [0, 0, -0.2], shininess: 70 },
                    { name: 'hornR', shape: 'box', width: 0.08, height: 0.3, depth: 0.08, color: '#3b82f6', position: [0.18, 2.35, -0.05], rotation: [0, 0, 0.2], shininess: 70 },
                    { name: 'shoulderL', shape: 'box', width: 0.4, height: 0.3, depth: 0.35, color: '#2563eb', position: [-0.6, 1.55, 0], shininess: 75 },
                    { name: 'shoulderR', shape: 'box', width: 0.4, height: 0.3, depth: 0.35, color: '#2563eb', position: [0.6, 1.55, 0], shininess: 75 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.13, height: 0.7, color: '#3b82f6', position: [-0.55, 1.0, 0], shininess: 60 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.13, height: 0.7, color: '#3b82f6', position: [0.55, 1.0, 0], shininess: 60 },
                    { name: 'swordHandle', shape: 'cylinder', radiusTop: 0.04, radiusBottom: 0.05, height: 0.4, color: '#8b4513', position: [0.6, 0.5, 0.15], shininess: 40 },
                    { name: 'swordBlade', shape: 'box', width: 0.15, height: 1.2, depth: 0.04, color: '#c0c0c0', position: [0.6, 1.3, 0.15], emissive: '#4488ff', shininess: 100 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.8, color: '#1e3a8a', position: [-0.22, 0.4, 0], shininess: 60 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.8, color: '#1e3a8a', position: [0.22, 0.4, 0], shininess: 60 },
                    { name: 'bootL', shape: 'box', width: 0.16, height: 0.12, depth: 0.24, color: '#1e40af', position: [-0.22, 0.06, 0.03], shininess: 50 },
                    { name: 'bootR', shape: 'box', width: 0.16, height: 0.12, depth: 0.24, color: '#1e40af', position: [0.22, 0.06, 0.03], shininess: 50 },
                    { name: 'cape', shape: 'box', width: 0.7, height: 1.0, depth: 0.04, color: '#dc2626', position: [0, 1.1, -0.28], shininess: 25 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            centaur: {
                scale: 1.4,
                bodyParts: [
                    { name: 'horseBody', shape: 'box', width: 0.8, height: 0.6, depth: 1.4, color: '#8b4513', position: [0, 0.8, -0.2], shininess: 40 },
                    { name: 'humanTorso', shape: 'box', width: 0.7, height: 0.9, depth: 0.4, color: '#a0522d', position: [0, 1.7, 0.4], shininess: 45 },
                    { name: 'head', shape: 'sphere', size: 0.3, color: '#cd853f', position: [0, 2.35, 0.4], shininess: 50 },
                    { name: 'hornL', shape: 'cone', size: 0.1, height: 0.4, color: '#654321', position: [-0.2, 2.6, 0.35], rotation: [0.3, 0, -0.3], shininess: 50 },
                    { name: 'hornR', shape: 'cone', size: 0.1, height: 0.4, color: '#654321', position: [0.2, 2.6, 0.35], rotation: [0.3, 0, 0.3], shininess: 50 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.8, color: '#a0522d', position: [-0.5, 1.4, 0.4], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.8, color: '#a0522d', position: [0.5, 1.4, 0.4], shininess: 40 },
                    { name: 'axe', shape: 'box', width: 0.5, height: 0.7, depth: 0.06, color: '#808080', position: [0.6, 1.0, 0.5], emissive: '#332211', shininess: 80 },
                    { name: 'legFL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#8b4513', position: [-0.3, 0.35, 0.4], shininess: 35 },
                    { name: 'legFR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#8b4513', position: [0.3, 0.35, 0.4], shininess: 35 },
                    { name: 'legBL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#8b4513', position: [-0.3, 0.35, -0.6], shininess: 35 },
                    { name: 'legBR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#8b4513', position: [0.3, 0.35, -0.6], shininess: 35 },
                    { name: 'tail', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.08, height: 0.6, color: '#4a3520', position: [0, 0.7, -0.95], rotation: [1.2, 0, 0], shininess: 30 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            tidehunter: {
                scale: 1.3,
                bodyParts: [
                    { name: 'body', shape: 'sphere', size: 0.7, color: '#20b2aa', position: [0, 1.1, 0], shininess: 60 },
                    { name: 'shell', shape: 'sphere', size: 0.65, color: '#008b8b', position: [0, 1.15, -0.15], shininess: 70 },
                    { name: 'head', shape: 'sphere', size: 0.35, color: '#40e0d0', position: [0, 1.9, 0.1], shininess: 55 },
                    { name: 'eyeL', shape: 'sphere', size: 0.08, color: '#ffff00', position: [-0.15, 2.0, 0.25], emissive: '#ccaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.08, color: '#ffff00', position: [0.15, 2.0, 0.25], emissive: '#ccaa00', shininess: 100 },
                    { name: 'finTop', shape: 'box', width: 0.05, height: 0.4, depth: 0.3, color: '#2f4f4f', position: [0, 2.2, -0.1], shininess: 50 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.18, height: 0.8, color: '#48d1cc', position: [-0.6, 1.1, 0], shininess: 50 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.18, height: 0.8, color: '#48d1cc', position: [0.6, 1.1, 0], shininess: 50 },
                    { name: 'anchor', shape: 'box', width: 0.4, height: 0.8, depth: 0.1, color: '#696969', position: [0.7, 0.8, 0.2], emissive: '#333333', shininess: 80 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.18, height: 0.6, color: '#3cb371', position: [-0.25, 0.3, 0], shininess: 45 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.18, height: 0.6, color: '#3cb371', position: [0.25, 0.3, 0], shininess: 45 },
                    { name: 'tentacle1', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.06, height: 0.4, color: '#5f9ea0', position: [-0.4, 1.5, -0.3], rotation: [0.5, 0, -0.3], shininess: 40 },
                    { name: 'tentacle2', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.06, height: 0.4, color: '#5f9ea0', position: [0.4, 1.5, -0.3], rotation: [0.5, 0, 0.3], shininess: 40 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            // === AGILITY HERO MODELS ===
            phantom_assassin: {
                scale: 0.95,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.45, height: 0.75, depth: 0.28, color: '#4b0082', position: [0, 1.3, 0], emissive: '#220044', shininess: 55 },
                    { name: 'chest', shape: 'box', width: 0.4, height: 0.35, depth: 0.12, color: '#6a0dad', position: [0, 1.5, 0.14], shininess: 70 },
                    { name: 'head', shape: 'sphere', size: 0.18, color: '#dda0dd', position: [0, 1.95, 0], shininess: 50 },
                    { name: 'mask', shape: 'box', width: 0.2, height: 0.12, depth: 0.1, color: '#2e0854', position: [0, 1.92, 0.1], shininess: 60 },
                    { name: 'veil', shape: 'box', width: 0.3, height: 0.25, depth: 0.02, color: '#1a0033', position: [0, 1.85, -0.1], shininess: 20 },
                    { name: 'shoulderL', shape: 'box', width: 0.18, height: 0.12, depth: 0.15, color: '#5c005c', position: [-0.35, 1.5, 0], shininess: 55 },
                    { name: 'shoulderR', shape: 'box', width: 0.18, height: 0.12, depth: 0.15, color: '#5c005c', position: [0.35, 1.5, 0], shininess: 55 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.55, color: '#6b21a8', position: [-0.35, 1.0, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.55, color: '#6b21a8', position: [0.35, 1.0, 0], shininess: 45 },
                    { name: 'bladeL', shape: 'box', width: 0.02, height: 0.6, depth: 0.12, color: '#c0c0c0', position: [-0.38, 0.5, 0.08], emissive: '#4400aa', shininess: 100 },
                    { name: 'bladeR', shape: 'box', width: 0.02, height: 0.6, depth: 0.12, color: '#c0c0c0', position: [0.38, 0.5, 0.08], emissive: '#4400aa', shininess: 100 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.09, height: 0.65, color: '#4b0082', position: [-0.15, 0.32, 0], shininess: 45 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.09, height: 0.65, color: '#4b0082', position: [0.15, 0.32, 0], shininess: 45 },
                    { name: 'cape', shape: 'box', width: 0.55, height: 0.9, depth: 0.03, color: '#1a0033', position: [0, 1.0, -0.18], shininess: 15 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            juggernaut: {
                scale: 1.05,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.55, height: 0.8, depth: 0.35, color: '#ff4500', position: [0, 1.25, 0], shininess: 55 },
                    { name: 'chest', shape: 'box', width: 0.5, height: 0.4, depth: 0.15, color: '#cc3300', position: [0, 1.45, 0.18], shininess: 65 },
                    { name: 'mask', shape: 'box', width: 0.28, height: 0.35, depth: 0.25, color: '#ff6600', position: [0, 1.95, 0], emissive: '#331100', shininess: 75 },
                    { name: 'maskSlot', shape: 'box', width: 0.2, height: 0.06, depth: 0.05, color: '#111111', position: [0, 1.95, 0.14], shininess: 30 },
                    { name: 'shoulderL', shape: 'box', width: 0.22, height: 0.18, depth: 0.2, color: '#cc2200', position: [-0.42, 1.48, 0], shininess: 60 },
                    { name: 'shoulderR', shape: 'box', width: 0.22, height: 0.18, depth: 0.2, color: '#cc2200', position: [0.42, 1.48, 0], shininess: 60 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.09, height: 0.6, color: '#dd6644', position: [-0.4, 0.95, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.09, height: 0.6, color: '#dd6644', position: [0.4, 0.95, 0], shininess: 45 },
                    { name: 'katanaHandle', shape: 'cylinder', radiusTop: 0.025, radiusBottom: 0.03, height: 0.3, color: '#442211', position: [0.45, 0.55, 0.12], shininess: 35 },
                    { name: 'katanaBlade', shape: 'box', width: 0.04, height: 0.9, depth: 0.02, color: '#e0e0e0', position: [0.45, 1.1, 0.12], emissive: '#ff4400', shininess: 100 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.09, radiusBottom: 0.11, height: 0.7, color: '#aa3300', position: [-0.18, 0.35, 0], shininess: 50 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.09, radiusBottom: 0.11, height: 0.7, color: '#aa3300', position: [0.18, 0.35, 0], shininess: 50 },
                    { name: 'sashL', shape: 'box', width: 0.08, height: 0.5, depth: 0.02, color: '#ffffff', position: [-0.25, 0.9, 0.2], rotation: [0, 0, 0.2], shininess: 25 },
                    { name: 'sashR', shape: 'box', width: 0.08, height: 0.5, depth: 0.02, color: '#ffffff', position: [0.25, 0.9, 0.2], rotation: [0, 0, -0.2], shininess: 25 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            antimage: {
                scale: 1.0,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.8, depth: 0.32, color: '#00ced1', position: [0, 1.25, 0], emissive: '#004444', shininess: 55 },
                    { name: 'chest', shape: 'box', width: 0.45, height: 0.35, depth: 0.12, color: '#008b8b', position: [0, 1.48, 0.16], shininess: 65 },
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#5f9ea0', position: [0, 1.92, 0], shininess: 50 },
                    { name: 'earL', shape: 'cone', size: 0.06, height: 0.2, color: '#20b2aa', position: [-0.15, 2.05, 0], rotation: [0, 0, -0.3], shininess: 45 },
                    { name: 'earR', shape: 'cone', size: 0.06, height: 0.2, color: '#20b2aa', position: [0.15, 2.05, 0], rotation: [0, 0, 0.3], shininess: 45 },
                    { name: 'shoulderL', shape: 'box', width: 0.2, height: 0.15, depth: 0.18, color: '#008080', position: [-0.38, 1.5, 0], shininess: 55 },
                    { name: 'shoulderR', shape: 'box', width: 0.2, height: 0.15, depth: 0.18, color: '#008080', position: [0.38, 1.5, 0], shininess: 55 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.58, color: '#40e0d0', position: [-0.38, 0.98, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.58, color: '#40e0d0', position: [0.38, 0.98, 0], shininess: 45 },
                    { name: 'glaiveL', shape: 'box', width: 0.04, height: 0.55, depth: 0.2, color: '#00ffff', position: [-0.42, 0.5, 0.1], emissive: '#00aaaa', shininess: 100 },
                    { name: 'glaiveR', shape: 'box', width: 0.04, height: 0.55, depth: 0.2, color: '#00ffff', position: [0.42, 0.5, 0.1], emissive: '#00aaaa', shininess: 100 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.68, color: '#008b8b', position: [-0.16, 0.34, 0], shininess: 48 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.68, color: '#008b8b', position: [0.16, 0.34, 0], shininess: 48 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            drow_ranger: {
                scale: 0.95,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.42, height: 0.72, depth: 0.28, color: '#87ceeb', position: [0, 1.28, 0], emissive: '#223344', shininess: 50 },
                    { name: 'chest', shape: 'box', width: 0.38, height: 0.3, depth: 0.1, color: '#4682b4', position: [0, 1.48, 0.14], shininess: 60 },
                    { name: 'head', shape: 'sphere', size: 0.18, color: '#b0e0e6', position: [0, 1.9, 0], shininess: 50 },
                    { name: 'hair', shape: 'box', width: 0.25, height: 0.35, depth: 0.15, color: '#e6e6fa', position: [0, 1.85, -0.08], shininess: 25 },
                    { name: 'hood', shape: 'cone', size: 0.22, height: 0.25, color: '#2f4f4f', position: [0, 2.0, -0.02], shininess: 30 },
                    { name: 'shoulderL', shape: 'box', width: 0.15, height: 0.1, depth: 0.12, color: '#5f9ea0', position: [-0.32, 1.48, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.15, height: 0.1, depth: 0.12, color: '#5f9ea0', position: [0.32, 1.48, 0], shininess: 50 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.55, color: '#add8e6', position: [-0.32, 0.98, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.55, color: '#add8e6', position: [0.32, 0.98, 0], shininess: 45 },
                    { name: 'bowGrip', shape: 'cylinder', radiusTop: 0.02, radiusBottom: 0.02, height: 0.8, color: '#4a3520', position: [-0.38, 1.1, 0.15], rotation: [0.2, 0, 0], shininess: 35 },
                    { name: 'bowTop', shape: 'cylinder', radiusTop: 0.015, radiusBottom: 0.02, height: 0.4, color: '#4a3520', position: [-0.38, 1.55, 0.2], rotation: [0.8, 0, 0], shininess: 35 },
                    { name: 'quiver', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.5, color: '#8b4513', position: [0.2, 1.2, -0.2], shininess: 35 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.09, height: 0.65, color: '#4682b4', position: [-0.14, 0.32, 0], shininess: 45 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.09, height: 0.65, color: '#4682b4', position: [0.14, 0.32, 0], shininess: 45 },
                    { name: 'cape', shape: 'box', width: 0.48, height: 0.85, depth: 0.03, color: '#1a1a2e', position: [0, 0.95, -0.16], shininess: 18 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            faceless_void: {
                scale: 1.05,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.55, height: 0.85, depth: 0.38, color: '#483d8b', position: [0, 1.28, 0], emissive: '#1a1a3a', shininess: 60 },
                    { name: 'chest', shape: 'box', width: 0.5, height: 0.4, depth: 0.15, color: '#6a5acd', position: [0, 1.5, 0.18], shininess: 70 },
                    { name: 'head', shape: 'sphere', size: 0.24, color: '#7b68ee', position: [0, 2.0, 0], shininess: 55 },
                    { name: 'face', shape: 'box', width: 0.18, height: 0.15, depth: 0.08, color: '#191970', position: [0, 1.98, 0.15], emissive: '#0000ff', shininess: 80 },
                    { name: 'shoulderL', shape: 'box', width: 0.22, height: 0.18, depth: 0.2, color: '#4b0082', position: [-0.42, 1.52, 0], shininess: 55 },
                    { name: 'shoulderR', shape: 'box', width: 0.22, height: 0.18, depth: 0.2, color: '#4b0082', position: [0.42, 1.52, 0], shininess: 55 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.62, color: '#6a5acd', position: [-0.42, 0.98, 0], shininess: 50 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.62, color: '#6a5acd', position: [0.42, 0.98, 0], shininess: 50 },
                    { name: 'maceHandle', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.04, height: 0.6, color: '#2f2f4f', position: [0.48, 0.6, 0.12], shininess: 40 },
                    { name: 'maceHead', shape: 'sphere', size: 0.15, color: '#9370db', position: [0.48, 0.25, 0.12], emissive: '#4400aa', shininess: 90 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#483d8b', position: [-0.18, 0.35, 0], shininess: 50 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#483d8b', position: [0.18, 0.35, 0], shininess: 50 },
                    { name: 'timeAura', shape: 'sphere', size: 0.08, color: '#00ffff', position: [0, 1.5, 0], emissive: '#00ffff', shininess: 100 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            spectre: {
                scale: 1.0,
                bodyParts: [
                    { name: 'body', shape: 'cone', size: 0.5, height: 1.3, color: '#9932cc', position: [0, 0.8, 0], emissive: '#330066', shininess: 40 },
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.6, depth: 0.3, color: '#8b008b', position: [0, 1.5, 0], emissive: '#220033', shininess: 50 },
                    { name: 'head', shape: 'sphere', size: 0.22, color: '#da70d6', position: [0, 1.95, 0], emissive: '#440066', shininess: 55 },
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#ff00ff', position: [-0.08, 1.98, 0.15], emissive: '#ff00ff', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#ff00ff', position: [0.08, 1.98, 0.15], emissive: '#ff00ff', shininess: 100 },
                    { name: 'hornL', shape: 'cone', size: 0.05, height: 0.25, color: '#800080', position: [-0.15, 2.15, 0], rotation: [0, 0, -0.3], emissive: '#330033', shininess: 50 },
                    { name: 'hornR', shape: 'cone', size: 0.05, height: 0.25, color: '#800080', position: [0.15, 2.15, 0], rotation: [0, 0, 0.3], emissive: '#330033', shininess: 50 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#ba55d3', position: [-0.35, 1.2, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#ba55d3', position: [0.35, 1.2, 0], shininess: 45 },
                    { name: 'bladeL', shape: 'box', width: 0.03, height: 0.5, depth: 0.15, color: '#ff00ff', position: [-0.38, 0.7, 0.1], emissive: '#cc00cc', shininess: 100 },
                    { name: 'bladeR', shape: 'box', width: 0.03, height: 0.5, depth: 0.15, color: '#ff00ff', position: [0.38, 0.7, 0.1], emissive: '#cc00cc', shininess: 100 },
                    { name: 'aura1', shape: 'sphere', size: 0.6, color: '#330033', position: [0, 1.2, 0], emissive: '#220022', shininess: 20 },
                    { name: 'wisp1', shape: 'sphere', size: 0.05, color: '#ee82ee', position: [-0.5, 1.0, 0.3], emissive: '#cc44cc', shininess: 80 },
                    { name: 'wisp2', shape: 'sphere', size: 0.05, color: '#ee82ee', position: [0.5, 1.3, -0.2], emissive: '#cc44cc', shininess: 80 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            // === INTELLIGENCE HERO MODELS ===
            crystal_maiden: {
                scale: 0.9,
                bodyParts: [
                    { name: 'robe', shape: 'cone', size: 0.45, height: 1.2, color: '#00bfff', position: [0, 0.6, 0], shininess: 35 },
                    { name: 'torso', shape: 'box', width: 0.4, height: 0.55, depth: 0.28, color: '#87ceeb', position: [0, 1.4, 0], shininess: 50 },
                    { name: 'chest', shape: 'box', width: 0.35, height: 0.25, depth: 0.1, color: '#add8e6', position: [0, 1.55, 0.14], shininess: 60 },
                    { name: 'head', shape: 'sphere', size: 0.18, color: '#e0ffff', position: [0, 1.88, 0], shininess: 50 },
                    { name: 'hair', shape: 'box', width: 0.28, height: 0.4, depth: 0.18, color: '#f0f8ff', position: [0, 1.78, -0.05], shininess: 30 },
                    { name: 'crown', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.15, height: 0.08, color: '#4169e1', position: [0, 2.0, 0], emissive: '#0066cc', shininess: 80 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.5, color: '#b0e0e6', position: [-0.3, 1.15, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.5, color: '#b0e0e6', position: [0.3, 1.15, 0], shininess: 45 },
                    { name: 'staff', shape: 'cylinder', radiusTop: 0.025, radiusBottom: 0.03, height: 1.5, color: '#4682b4', position: [0.35, 1.0, 0.1], shininess: 45 },
                    { name: 'staffCrystal', shape: 'octahedron', size: 0.12, color: '#00ffff', position: [0.35, 1.8, 0.1], emissive: '#00cccc', shininess: 100 },
                    { name: 'iceAura1', shape: 'sphere', size: 0.04, color: '#e0ffff', position: [-0.4, 1.5, 0.2], emissive: '#aaddff', shininess: 90 },
                    { name: 'iceAura2', shape: 'sphere', size: 0.04, color: '#e0ffff', position: [0.15, 1.7, 0.3], emissive: '#aaddff', shininess: 90 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            lion: {
                scale: 1.0,
                bodyParts: [
                    { name: 'robe', shape: 'cone', size: 0.42, height: 1.1, color: '#8b0000', position: [0, 0.55, 0], shininess: 30 },
                    { name: 'torso', shape: 'box', width: 0.48, height: 0.6, depth: 0.32, color: '#a52a2a', position: [0, 1.35, 0], shininess: 45 },
                    { name: 'head', shape: 'sphere', size: 0.22, color: '#cd5c5c', position: [0, 1.9, 0], shininess: 48 },
                    { name: 'hornL', shape: 'cone', size: 0.06, height: 0.2, color: '#4a0000', position: [-0.12, 2.1, 0], rotation: [0, 0, -0.25], emissive: '#220000', shininess: 55 },
                    { name: 'hornR', shape: 'cone', size: 0.06, height: 0.2, color: '#4a0000', position: [0.12, 2.1, 0], rotation: [0, 0, 0.25], emissive: '#220000', shininess: 55 },
                    { name: 'eyeL', shape: 'sphere', size: 0.035, color: '#ffff00', position: [-0.08, 1.93, 0.16], emissive: '#ff8800', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.035, color: '#ffff00', position: [0.08, 1.93, 0.16], emissive: '#ff8800', shininess: 100 },
                    { name: 'demonArmL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.12, height: 0.6, color: '#8b0000', position: [-0.38, 1.05, 0], emissive: '#330000', shininess: 50 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#b22222', position: [0.35, 1.08, 0], shininess: 45 },
                    { name: 'clawL', shape: 'cone', size: 0.1, height: 0.18, color: '#2f0000', position: [-0.4, 0.68, 0.08], rotation: [1.57, 0, 0], emissive: '#110000', shininess: 60 },
                    { name: 'staff', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.04, height: 1.4, color: '#4a0000', position: [0.4, 0.95, 0.1], shininess: 40 },
                    { name: 'staffSkull', shape: 'sphere', size: 0.1, color: '#dcdcdc', position: [0.4, 1.7, 0.1], shininess: 55 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            invoker: {
                scale: 1.0,
                bodyParts: [
                    { name: 'robe', shape: 'cone', size: 0.45, height: 1.15, color: '#ffd700', position: [0, 0.58, 0], emissive: '#442200', shininess: 40 },
                    { name: 'torso', shape: 'box', width: 0.45, height: 0.58, depth: 0.3, color: '#daa520', position: [0, 1.38, 0], shininess: 55 },
                    { name: 'chest', shape: 'box', width: 0.4, height: 0.28, depth: 0.12, color: '#b8860b', position: [0, 1.55, 0.15], shininess: 65 },
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#ffe4b5', position: [0, 1.9, 0], shininess: 50 },
                    { name: 'hair', shape: 'box', width: 0.3, height: 0.35, depth: 0.2, color: '#f5f5dc', position: [0, 1.85, -0.05], shininess: 28 },
                    { name: 'orbQuas', shape: 'sphere', size: 0.08, color: '#00ffff', position: [-0.35, 1.8, 0.2], emissive: '#00cccc', shininess: 100 },
                    { name: 'orbWex', shape: 'sphere', size: 0.08, color: '#ff00ff', position: [0, 2.1, 0.15], emissive: '#cc00cc', shininess: 100 },
                    { name: 'orbExort', shape: 'sphere', size: 0.08, color: '#ff6600', position: [0.35, 1.8, 0.2], emissive: '#cc4400', shininess: 100 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.055, radiusBottom: 0.07, height: 0.52, color: '#f0e68c', position: [-0.32, 1.1, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.055, radiusBottom: 0.07, height: 0.52, color: '#f0e68c', position: [0.32, 1.1, 0], shininess: 45 },
                    { name: 'cape', shape: 'box', width: 0.55, height: 0.9, depth: 0.04, color: '#8b0000', position: [0, 1.0, -0.18], shininess: 22 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            lina: {
                scale: 0.95,
                bodyParts: [
                    { name: 'dress', shape: 'cone', size: 0.4, height: 1.0, color: '#ff6347', position: [0, 0.5, 0], emissive: '#441100', shininess: 35 },
                    { name: 'torso', shape: 'box', width: 0.38, height: 0.52, depth: 0.26, color: '#ff4500', position: [0, 1.32, 0], shininess: 50 },
                    { name: 'head', shape: 'sphere', size: 0.17, color: '#ffa07a', position: [0, 1.82, 0], shininess: 48 },
                    { name: 'fireHair1', shape: 'cone', size: 0.15, height: 0.35, color: '#ff4500', position: [0, 2.0, -0.05], emissive: '#ff2200', shininess: 70 },
                    { name: 'fireHair2', shape: 'cone', size: 0.12, height: 0.3, color: '#ff6600', position: [-0.12, 1.98, 0], rotation: [0, 0, -0.3], emissive: '#ff4400', shininess: 70 },
                    { name: 'fireHair3', shape: 'cone', size: 0.12, height: 0.3, color: '#ff6600', position: [0.12, 1.98, 0], rotation: [0, 0, 0.3], emissive: '#ff4400', shininess: 70 },
                    { name: 'eyeL', shape: 'sphere', size: 0.03, color: '#ffff00', position: [-0.06, 1.85, 0.12], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.03, color: '#ffff00', position: [0.06, 1.85, 0.12], emissive: '#ffaa00', shininess: 100 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.045, radiusBottom: 0.06, height: 0.48, color: '#fa8072', position: [-0.28, 1.08, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.045, radiusBottom: 0.06, height: 0.48, color: '#fa8072', position: [0.28, 1.08, 0], shininess: 45 },
                    { name: 'fireballL', shape: 'sphere', size: 0.08, color: '#ff4400', position: [-0.32, 0.75, 0.12], emissive: '#ff2200', shininess: 100 },
                    { name: 'fireballR', shape: 'sphere', size: 0.08, color: '#ff4400', position: [0.32, 0.75, 0.12], emissive: '#ff2200', shininess: 100 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            shadow_shaman: {
                scale: 0.95,
                bodyParts: [
                    { name: 'robe', shape: 'cone', size: 0.4, height: 1.0, color: '#32cd32', position: [0, 0.5, 0], emissive: '#113311', shininess: 32 },
                    { name: 'torso', shape: 'box', width: 0.42, height: 0.55, depth: 0.28, color: '#228b22', position: [0, 1.32, 0], shininess: 45 },
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#3cb371', position: [0, 1.85, 0], shininess: 48 },
                    { name: 'mask', shape: 'box', width: 0.25, height: 0.18, depth: 0.12, color: '#8b4513', position: [0, 1.82, 0.1], shininess: 55 },
                    { name: 'feather1', shape: 'box', width: 0.03, height: 0.25, depth: 0.02, color: '#ff4500', position: [-0.1, 2.05, 0], rotation: [0, 0, -0.2], shininess: 30 },
                    { name: 'feather2', shape: 'box', width: 0.03, height: 0.3, depth: 0.02, color: '#ffd700', position: [0, 2.1, 0], shininess: 30 },
                    { name: 'feather3', shape: 'box', width: 0.03, height: 0.25, depth: 0.02, color: '#ff4500', position: [0.1, 2.05, 0], rotation: [0, 0, 0.2], shininess: 30 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.5, color: '#2e8b57', position: [-0.3, 1.05, 0], shininess: 42 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.5, color: '#2e8b57', position: [0.3, 1.05, 0], shininess: 42 },
                    { name: 'staff', shape: 'cylinder', radiusTop: 0.025, radiusBottom: 0.035, height: 1.3, color: '#654321', position: [0.35, 0.9, 0.1], shininess: 38 },
                    { name: 'staffHead', shape: 'sphere', size: 0.1, color: '#00ff00', position: [0.35, 1.6, 0.1], emissive: '#00cc00', shininess: 90 },
                    { name: 'serpent', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.05, height: 0.3, color: '#006400', position: [-0.35, 0.7, 0.1], rotation: [0.5, 0, 0], emissive: '#003300', shininess: 50 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            zeus: {
                scale: 1.0,
                bodyParts: [
                    { name: 'robe', shape: 'cone', size: 0.42, height: 1.05, color: '#1e90ff', position: [0, 0.52, 0], emissive: '#0a1a4a', shininess: 38 },
                    { name: 'torso', shape: 'box', width: 0.45, height: 0.58, depth: 0.3, color: '#4169e1', position: [0, 1.35, 0], shininess: 52 },
                    { name: 'belt', shape: 'box', width: 0.48, height: 0.1, depth: 0.32, color: '#ffd700', position: [0, 1.08, 0], emissive: '#aa8800', shininess: 75 },
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#f5deb3', position: [0, 1.88, 0], shininess: 48 },
                    { name: 'beard', shape: 'cone', size: 0.15, height: 0.25, color: '#ffffff', position: [0, 1.72, 0.1], shininess: 25 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#f5deb3', position: [-0.32, 1.08, 0], shininess: 45 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#f5deb3', position: [0.32, 1.08, 0], shininess: 45 },
                    { name: 'lightning1', shape: 'box', width: 0.03, height: 0.5, depth: 0.02, color: '#00ffff', position: [0.38, 0.6, 0.1], rotation: [0, 0, 0.15], emissive: '#00ffff', shininess: 100 },
                    { name: 'lightning2', shape: 'box', width: 0.03, height: 0.35, depth: 0.02, color: '#ffff00', position: [0.42, 0.4, 0.12], rotation: [0, 0, -0.2], emissive: '#ffff00', shininess: 100 },
                    { name: 'aura', shape: 'sphere', size: 0.5, color: '#0000aa', position: [0, 1.3, 0], emissive: '#0000ff', shininess: 30 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            necrophos: {
                scale: 1.0,
                bodyParts: [
                    { name: 'robe', shape: 'cone', size: 0.45, height: 1.15, color: '#228b22', position: [0, 0.58, 0], emissive: '#0a2a0a', shininess: 32 },
                    { name: 'torso', shape: 'box', width: 0.48, height: 0.6, depth: 0.32, color: '#2e8b57', position: [0, 1.38, 0], shininess: 45 },
                    { name: 'shoulderL', shape: 'box', width: 0.2, height: 0.18, depth: 0.18, color: '#006400', position: [-0.38, 1.55, 0], emissive: '#002200', shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.2, height: 0.18, depth: 0.18, color: '#006400', position: [0.38, 1.55, 0], emissive: '#002200', shininess: 50 },
                    { name: 'head', shape: 'sphere', size: 0.22, color: '#3cb371', position: [0, 1.9, 0], emissive: '#112211', shininess: 50 },
                    { name: 'hood', shape: 'cone', size: 0.25, height: 0.25, color: '#006400', position: [0, 2.0, -0.05], shininess: 28 },
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#00ff00', position: [-0.08, 1.92, 0.15], emissive: '#00ff00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#00ff00', position: [0.08, 1.92, 0.15], emissive: '#00ff00', shininess: 100 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#228b22', position: [-0.35, 1.08, 0], shininess: 42 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.55, color: '#228b22', position: [0.35, 1.08, 0], shininess: 42 },
                    { name: 'scytheHandle', shape: 'cylinder', radiusTop: 0.025, radiusBottom: 0.03, height: 1.5, color: '#3d2b1f', position: [0.4, 1.0, 0.1], shininess: 35 },
                    { name: 'scytheBlade', shape: 'box', width: 0.5, height: 0.06, depth: 0.02, color: '#808080', position: [0.15, 1.8, 0.1], rotation: [0, 0, -0.5], emissive: '#00ff00', shininess: 90 },
                    { name: 'plague1', shape: 'sphere', size: 0.05, color: '#32cd32', position: [-0.4, 1.2, 0.25], emissive: '#00aa00', shininess: 80 },
                    { name: 'plague2', shape: 'sphere', size: 0.05, color: '#32cd32', position: [0.2, 1.6, 0.3], emissive: '#00aa00', shininess: 80 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            }
        };

        // Detailed creep models
        const CREEP_MODELS = {
            melee_radiant: {
                scale: 0.5,
                bodyParts: [
                    { name: 'body', shape: 'sphere', size: 0.35, color: '#00ff88', position: [0, 0.4, 0], emissive: '#004422', shininess: 50 },
                    { name: 'eye', shape: 'sphere', size: 0.08, color: '#ffffff', position: [0, 0.5, 0.25], emissive: '#00ffff', shininess: 100 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.25, color: '#00dd77', position: [-0.3, 0.35, 0], rotation: [0, 0, 0.5], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.25, color: '#00dd77', position: [0.3, 0.35, 0], rotation: [0, 0, -0.5], shininess: 40 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.2, color: '#00bb66', position: [-0.15, 0.1, 0], shininess: 30 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.2, color: '#00bb66', position: [0.15, 0.1, 0], shininess: 30 }
                ]
            },
            melee_dire: {
                scale: 0.5,
                bodyParts: [
                    { name: 'body', shape: 'box', width: 0.4, height: 0.4, depth: 0.4, color: '#ff3c3c', position: [0, 0.4, 0], emissive: '#441111', shininess: 50 },
                    { name: 'spike1', shape: 'cone', size: 0.05, height: 0.15, color: '#ff5555', position: [0, 0.65, 0], emissive: '#cc2222', shininess: 60 },
                    { name: 'spike2', shape: 'cone', size: 0.04, height: 0.1, color: '#ff5555', position: [-0.15, 0.6, 0.1], rotation: [0.3, 0, -0.3], shininess: 60 },
                    { name: 'spike3', shape: 'cone', size: 0.04, height: 0.1, color: '#ff5555', position: [0.15, 0.6, 0.1], rotation: [0.3, 0, 0.3], shininess: 60 },
                    { name: 'eye', shape: 'sphere', size: 0.06, color: '#ffff00', position: [0, 0.45, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'legL', shape: 'box', width: 0.1, height: 0.25, depth: 0.1, color: '#cc2222', position: [-0.12, 0.12, 0], shininess: 30 },
                    { name: 'legR', shape: 'box', width: 0.1, height: 0.25, depth: 0.1, color: '#cc2222', position: [0.12, 0.12, 0], shininess: 30 }
                ]
            },
            ranged_radiant: {
                scale: 0.45,
                bodyParts: [
                    { name: 'body', shape: 'octahedron', size: 0.3, color: '#00ffaa', position: [0, 0.5, 0], emissive: '#005544', shininess: 70 },
                    { name: 'core', shape: 'sphere', size: 0.12, color: '#00ffff', position: [0, 0.5, 0], emissive: '#00cccc', shininess: 100 },
                    { name: 'orbiter1', shape: 'sphere', size: 0.05, color: '#88ffff', position: [0.25, 0.5, 0], emissive: '#44cccc', shininess: 80 },
                    { name: 'orbiter2', shape: 'sphere', size: 0.05, color: '#88ffff', position: [-0.25, 0.5, 0], emissive: '#44cccc', shininess: 80 },
                    { name: 'tail', shape: 'cone', size: 0.08, height: 0.2, color: '#00dd88', position: [0, 0.25, 0], rotation: [3.14, 0, 0], shininess: 50 }
                ]
            },
            ranged_dire: {
                scale: 0.45,
                bodyParts: [
                    { name: 'body', shape: 'octahedron', size: 0.3, color: '#ff6666', position: [0, 0.5, 0], emissive: '#552222', shininess: 70 },
                    { name: 'core', shape: 'sphere', size: 0.12, color: '#ff4444', position: [0, 0.5, 0], emissive: '#cc2222', shininess: 100 },
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#ffff00', position: [-0.1, 0.55, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#ffff00', position: [0.1, 0.55, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'wing1', shape: 'box', width: 0.25, height: 0.02, depth: 0.15, color: '#cc4444', position: [-0.2, 0.5, -0.1], rotation: [0, 0, -0.3], shininess: 40 },
                    { name: 'wing2', shape: 'box', width: 0.25, height: 0.02, depth: 0.15, color: '#cc4444', position: [0.2, 0.5, -0.1], rotation: [0, 0, 0.3], shininess: 40 }
                ]
            },
            siege_radiant: {
                scale: 0.8,
                bodyParts: [
                    { name: 'hull', shape: 'box', width: 0.8, height: 0.5, depth: 1.0, color: '#00cc66', position: [0, 0.35, 0], shininess: 60 },
                    { name: 'turret', shape: 'cylinder', radiusTop: 0.2, radiusBottom: 0.25, height: 0.3, color: '#00aa55', position: [0, 0.65, 0], shininess: 50 },
                    { name: 'cannon', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.5, color: '#008844', position: [0, 0.7, 0.35], rotation: [1.3, 0, 0], shininess: 70 },
                    { name: 'cannonTip', shape: 'sphere', size: 0.08, color: '#00ffff', position: [0, 0.55, 0.55], emissive: '#00aaaa', shininess: 100 },
                    { name: 'trackL', shape: 'box', width: 0.15, height: 0.2, depth: 1.1, color: '#006633', position: [-0.45, 0.1, 0], shininess: 30 },
                    { name: 'trackR', shape: 'box', width: 0.15, height: 0.2, depth: 1.1, color: '#006633', position: [0.45, 0.1, 0], shininess: 30 },
                    { name: 'antenna', shape: 'cylinder', radiusTop: 0.02, radiusBottom: 0.02, height: 0.3, color: '#00ff88', position: [0.2, 0.9, -0.2], shininess: 50 },
                    { name: 'light', shape: 'sphere', size: 0.04, color: '#00ff00', position: [0.2, 1.05, -0.2], emissive: '#00ff00', shininess: 100 }
                ]
            },
            siege_dire: {
                scale: 0.8,
                bodyParts: [
                    { name: 'hull', shape: 'box', width: 0.8, height: 0.5, depth: 1.0, color: '#cc3333', position: [0, 0.35, 0], shininess: 60 },
                    { name: 'turret', shape: 'box', width: 0.4, height: 0.35, depth: 0.4, color: '#aa2222', position: [0, 0.65, 0], shininess: 50 },
                    { name: 'cannon', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#881111', position: [0, 0.7, 0.4], rotation: [1.2, 0, 0], shininess: 70 },
                    { name: 'muzzle', shape: 'cone', size: 0.1, height: 0.15, color: '#ff4400', position: [0, 0.5, 0.65], rotation: [1.57, 0, 0], emissive: '#cc2200', shininess: 80 },
                    { name: 'trackL', shape: 'box', width: 0.15, height: 0.25, depth: 1.1, color: '#661111', position: [-0.45, 0.12, 0], shininess: 30 },
                    { name: 'trackR', shape: 'box', width: 0.15, height: 0.25, depth: 1.1, color: '#661111', position: [0.45, 0.12, 0], shininess: 30 },
                    { name: 'spike1', shape: 'cone', size: 0.06, height: 0.2, color: '#ff5555', position: [-0.3, 0.85, -0.3], emissive: '#cc2222', shininess: 60 },
                    { name: 'spike2', shape: 'cone', size: 0.06, height: 0.2, color: '#ff5555', position: [0.3, 0.85, -0.3], emissive: '#cc2222', shininess: 60 }
                ]
            }
        };

        // === ENHANCED TOWER AND STRUCTURE MODELS ===
        const STRUCTURE_MODELS = {
            // === RADIANT TOWER - High-tech crystal defense tower ===
            tower_radiant: {
                scale: 1.0,
                bodyParts: [
                    // Foundation
                    { name: 'foundation', shape: 'cylinder', radiusTop: 1.8, radiusBottom: 2.2, height: 0.4, color: '#1a2a3a', position: [0, 0.2, 0], shininess: 40 },
                    { name: 'baseRing', shape: 'cylinder', radiusTop: 2.0, radiusBottom: 2.0, height: 0.1, color: '#00ffff', position: [0, 0.08, 0], emissive: '#00cccc', shininess: 100 },
                    // Core pillar
                    { name: 'corePillar', shape: 'cylinder', radiusTop: 0.9, radiusBottom: 1.2, height: 3.5, color: '#2a3a4a', position: [0, 2.15, 0], shininess: 50 },
                    { name: 'armorPlate1', shape: 'box', width: 0.2, height: 2.8, depth: 1.3, color: '#3a4a5a', position: [0.95, 1.9, 0], shininess: 45 },
                    { name: 'armorPlate2', shape: 'box', width: 0.2, height: 2.8, depth: 1.3, color: '#3a4a5a', position: [-0.95, 1.9, 0], shininess: 45 },
                    { name: 'armorPlate3', shape: 'box', width: 1.3, height: 2.8, depth: 0.2, color: '#3a4a5a', position: [0, 1.9, 0.95], shininess: 45 },
                    { name: 'armorPlate4', shape: 'box', width: 1.3, height: 2.8, depth: 0.2, color: '#3a4a5a', position: [0, 1.9, -0.95], shininess: 45 },
                    // Energy core
                    { name: 'energyCore', shape: 'sphere', size: 0.55, color: '#00ffff', position: [0, 2.2, 0], emissive: '#00ffff', shininess: 100 },
                    // Turret base
                    { name: 'turretBase', shape: 'cylinder', radiusTop: 0.7, radiusBottom: 0.85, height: 0.7, color: '#4a5a6a', position: [0, 4.3, 0], shininess: 55 },
                    { name: 'turretHead', shape: 'box', width: 1.4, height: 0.85, depth: 1.1, color: '#3a4a5a', position: [0, 5.0, 0], shininess: 50 },
                    // Cannons
                    { name: 'cannonL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.14, height: 1.8, color: '#2a3a4a', position: [-0.42, 5.0, 1.1], rotation: [1.3, 0, 0], shininess: 60 },
                    { name: 'cannonR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.14, height: 1.8, color: '#2a3a4a', position: [0.42, 5.0, 1.1], rotation: [1.3, 0, 0], shininess: 60 },
                    { name: 'muzzleL', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.12, height: 0.2, color: '#00ffff', position: [-0.42, 5.35, 1.9], rotation: [1.3, 0, 0], emissive: '#00ffff', shininess: 100 },
                    { name: 'muzzleR', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.12, height: 0.2, color: '#00ffff', position: [0.42, 5.35, 1.9], rotation: [1.3, 0, 0], emissive: '#00ffff', shininess: 100 },
                    // Sensor array
                    { name: 'sensorArray', shape: 'sphere', size: 0.35, color: '#00ff88', position: [0, 5.7, 0], emissive: '#00ff00', shininess: 100 },
                    { name: 'sensorDish', shape: 'cone', size: 0.42, height: 0.28, color: '#5a6a7a', position: [0, 5.95, 0], rotation: [3.14, 0, 0], shininess: 70 },
                    // Shield emitters
                    { name: 'shieldEmit1', shape: 'sphere', size: 0.14, color: '#00ff88', position: [1.25, 3.5, 0], emissive: '#00ff88', shininess: 100 },
                    { name: 'shieldEmit2', shape: 'sphere', size: 0.14, color: '#00ff88', position: [-1.25, 3.5, 0], emissive: '#00ff88', shininess: 100 },
                    { name: 'shieldEmit3', shape: 'sphere', size: 0.14, color: '#00ff88', position: [0, 3.5, 1.25], emissive: '#00ff88', shininess: 100 },
                    { name: 'shieldEmit4', shape: 'sphere', size: 0.14, color: '#00ff88', position: [0, 3.5, -1.25], emissive: '#00ff88', shininess: 100 },
                    // Status lights
                    { name: 'statusLight1', shape: 'sphere', size: 0.08, color: '#00ff00', position: [0.55, 4.8, 0.55], emissive: '#00ff00', shininess: 100 },
                    { name: 'statusLight2', shape: 'sphere', size: 0.08, color: '#00ff00', position: [-0.55, 4.8, 0.55], emissive: '#00ff00', shininess: 100 }
                ]
            },

            // === DIRE TOWER - Corrupted organic bio-tower ===
            tower_dire: {
                scale: 1.0,
                bodyParts: [
                    // Root mass foundation
                    { name: 'rootMass', shape: 'cylinder', radiusTop: 1.4, radiusBottom: 2.5, height: 0.7, color: '#2a1a1a', position: [0, 0.35, 0], shininess: 20 },
                    { name: 'corruptionRing', shape: 'cylinder', radiusTop: 2.2, radiusBottom: 2.2, height: 0.12, color: '#ff4444', position: [0, 0.14, 0], emissive: '#ff0000', shininess: 90 },
                    // Spinal column
                    { name: 'spinalColumn', shape: 'cylinder', radiusTop: 0.55, radiusBottom: 1.0, height: 4.2, color: '#3a2a2a', position: [0, 2.8, 0], shininess: 25 },
                    // Rib cage
                    { name: 'ribCage1', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.1, height: 1.8, color: '#4a3a3a', position: [0.85, 1.75, 0], rotation: [0, 0, -0.7], shininess: 28 },
                    { name: 'ribCage2', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.1, height: 1.8, color: '#4a3a3a', position: [-0.85, 1.75, 0], rotation: [0, 0, 0.7], shininess: 28 },
                    { name: 'ribCage3', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.1, height: 1.8, color: '#4a3a3a', position: [0, 1.75, 0.85], rotation: [0.7, 0, 0], shininess: 28 },
                    { name: 'ribCage4', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.1, height: 1.8, color: '#4a3a3a', position: [0, 1.75, -0.85], rotation: [-0.7, 0, 0], shininess: 28 },
                    // Heart core
                    { name: 'heartCore', shape: 'sphere', size: 0.7, color: '#ff2222', position: [0, 2.8, 0], emissive: '#ff0000', shininess: 100 },
                    // Vein pulses
                    { name: 'veinPulse1', shape: 'cylinder', radiusTop: 0.035, radiusBottom: 0.055, height: 2.1, color: '#ff4444', position: [0.42, 2.1, 0.42], emissive: '#ff2222', shininess: 80 },
                    { name: 'veinPulse2', shape: 'cylinder', radiusTop: 0.035, radiusBottom: 0.055, height: 2.1, color: '#ff4444', position: [-0.42, 2.1, -0.42], emissive: '#ff2222', shininess: 80 },
                    // Head crest
                    { name: 'headCrest', shape: 'cone', size: 1.05, height: 1.4, color: '#4a2a2a', position: [0, 5.25, 0], rotation: [3.14, 0, 0], shininess: 30 },
                    // Eye socket and ball
                    { name: 'eyeSocket', shape: 'sphere', size: 0.42, color: '#1a0a0a', position: [0, 4.9, 0.55], shininess: 15 },
                    { name: 'eyeBall', shape: 'sphere', size: 0.35, color: '#ffff00', position: [0, 4.9, 0.7], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyePupil', shape: 'sphere', size: 0.14, color: '#000000', position: [0, 4.9, 0.88], shininess: 50 },
                    // Tendrils
                    { name: 'tendril1', shape: 'cylinder', radiusTop: 0.055, radiusBottom: 0.14, height: 2.1, color: '#5a3a3a', position: [1.05, 4.2, 0], rotation: [0, 0, -1.05], shininess: 22 },
                    { name: 'tendril2', shape: 'cylinder', radiusTop: 0.055, radiusBottom: 0.14, height: 2.1, color: '#5a3a3a', position: [-1.05, 4.2, 0], rotation: [0, 0, 1.05], shininess: 22 },
                    { name: 'tendril3', shape: 'cylinder', radiusTop: 0.055, radiusBottom: 0.14, height: 2.1, color: '#5a3a3a', position: [0, 4.2, 1.05], rotation: [1.05, 0, 0], shininess: 22 },
                    // Spine protrusions
                    { name: 'spineSpike1', shape: 'cone', size: 0.1, height: 0.55, color: '#3a2a2a', position: [0.63, 3.85, 0], rotation: [0, 0, -0.78], shininess: 35 },
                    { name: 'spineSpike2', shape: 'cone', size: 0.1, height: 0.55, color: '#3a2a2a', position: [-0.63, 3.85, 0], rotation: [0, 0, 0.78], shininess: 35 },
                    { name: 'spineSpike3', shape: 'cone', size: 0.1, height: 0.55, color: '#3a2a2a', position: [0, 3.85, 0.63], rotation: [0.78, 0, 0], shininess: 35 },
                    // Acid sacs
                    { name: 'acidSac1', shape: 'sphere', size: 0.24, color: '#88ff44', position: [0.7, 3.15, 0.35], emissive: '#44ff00', shininess: 90 },
                    { name: 'acidSac2', shape: 'sphere', size: 0.24, color: '#88ff44', position: [-0.7, 3.15, -0.35], emissive: '#44ff00', shininess: 90 }
                ]
            },

            // === RADIANT ANCIENT - High-tech Command Nexus ===
            base_radiant: {
                scale: 1.5,
                bodyParts: [
                    // Foundation
                    { name: 'foundationRing', shape: 'cylinder', radiusTop: 5.6, radiusBottom: 6.3, height: 0.55, color: '#1a2a3a', position: [0, 0.27, 0], shininess: 40 },
                    { name: 'energyMoat', shape: 'cylinder', radiusTop: 5.25, radiusBottom: 5.25, height: 0.14, color: '#00ffff', position: [0, 0.14, 0], emissive: '#00cccc', shininess: 100 },
                    // Primary base
                    { name: 'primaryBase', shape: 'cylinder', radiusTop: 3.5, radiusBottom: 4.2, height: 2.1, color: '#2a3a4a', position: [0, 1.6, 0], shininess: 45 },
                    // Data rings
                    { name: 'dataRing1', shape: 'cylinder', radiusTop: 3.85, radiusBottom: 3.85, height: 0.14, color: '#00ff88', position: [0, 1.4, 0], emissive: '#00ff88', shininess: 100 },
                    { name: 'dataRing2', shape: 'cylinder', radiusTop: 3.15, radiusBottom: 3.15, height: 0.1, color: '#00ffff', position: [0, 2.1, 0], emissive: '#00ffff', shininess: 100 },
                    // Core spire
                    { name: 'coreSpire', shape: 'cylinder', radiusTop: 1.05, radiusBottom: 2.1, height: 5.6, color: '#3a4a5a', position: [0, 5.45, 0], shininess: 50 },
                    // Quantum core
                    { name: 'quantumCore', shape: 'octahedron', size: 1.75, color: '#00ffff', position: [0, 9.8, 0], emissive: '#00ffff', shininess: 100 },
                    // Support pylons
                    { name: 'supportPylon1', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.55, height: 7.0, color: '#4a5a6a', position: [2.8, 4.05, 0], rotation: [0, 0, -0.26], shininess: 55 },
                    { name: 'supportPylon2', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.55, height: 7.0, color: '#4a5a6a', position: [-2.8, 4.05, 0], rotation: [0, 0, 0.26], shininess: 55 },
                    { name: 'supportPylon3', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.55, height: 7.0, color: '#4a5a6a', position: [0, 4.05, 2.8], rotation: [0.26, 0, 0], shininess: 55 },
                    { name: 'supportPylon4', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.55, height: 7.0, color: '#4a5a6a', position: [0, 4.05, -2.8], rotation: [-0.26, 0, 0], shininess: 55 },
                    // Pylon orbs
                    { name: 'pylonOrb1', shape: 'sphere', size: 0.42, color: '#00ffff', position: [3.85, 7.7, 0], emissive: '#00ffff', shininess: 100 },
                    { name: 'pylonOrb2', shape: 'sphere', size: 0.42, color: '#00ffff', position: [-3.85, 7.7, 0], emissive: '#00ffff', shininess: 100 },
                    { name: 'pylonOrb3', shape: 'sphere', size: 0.42, color: '#00ffff', position: [0, 7.7, 3.85], emissive: '#00ffff', shininess: 100 },
                    { name: 'pylonOrb4', shape: 'sphere', size: 0.42, color: '#00ffff', position: [0, 7.7, -3.85], emissive: '#00ffff', shininess: 100 },
                    // Holo displays
                    { name: 'holoDisplay1', shape: 'box', width: 2.1, height: 1.4, depth: 0.07, color: '#00ff88', position: [0, 3.5, 3.85], emissive: '#00ff88', shininess: 90 },
                    { name: 'holoDisplay2', shape: 'box', width: 2.1, height: 1.4, depth: 0.07, color: '#00ff88', position: [3.85, 3.5, 0], rotation: [0, 1.57, 0], emissive: '#00ff88', shininess: 90 },
                    // Shield generators
                    { name: 'shieldGen1', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 1.4, color: '#5a6a7a', position: [4.2, 1.26, 4.2], shininess: 50 },
                    { name: 'shieldGen2', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 1.4, color: '#5a6a7a', position: [-4.2, 1.26, 4.2], shininess: 50 },
                    { name: 'shieldGen3', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 1.4, color: '#5a6a7a', position: [4.2, 1.26, -4.2], shininess: 50 },
                    { name: 'shieldGen4', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 1.4, color: '#5a6a7a', position: [-4.2, 1.26, -4.2], shininess: 50 },
                    // Shield emitters
                    { name: 'shieldEmit1', shape: 'sphere', size: 0.28, color: '#00ff88', position: [4.2, 2.1, 4.2], emissive: '#00ff88', shininess: 100 },
                    { name: 'shieldEmit2', shape: 'sphere', size: 0.28, color: '#00ff88', position: [-4.2, 2.1, 4.2], emissive: '#00ff88', shininess: 100 },
                    { name: 'shieldEmit3', shape: 'sphere', size: 0.28, color: '#00ff88', position: [4.2, 2.1, -4.2], emissive: '#00ff88', shininess: 100 },
                    { name: 'shieldEmit4', shape: 'sphere', size: 0.28, color: '#00ff88', position: [-4.2, 2.1, -4.2], emissive: '#00ff88', shininess: 100 },
                    // Beacon
                    { name: 'beaconSpire', shape: 'cylinder', radiusTop: 0.07, radiusBottom: 0.14, height: 2.8, color: '#5a6a7a', position: [0, 13.3, 0], shininess: 55 },
                    { name: 'beaconLight', shape: 'sphere', size: 0.28, color: '#ffffff', position: [0, 14.84, 0], emissive: '#ffffff', shininess: 100 }
                ]
            },

            // === DIRE ANCIENT - Corruption Heart ===
            base_dire: {
                scale: 1.5,
                bodyParts: [
                    // Corruption spread
                    { name: 'corruptionSpread', shape: 'cylinder', radiusTop: 8.4, radiusBottom: 9.8, height: 0.21, color: '#1a0a0a', position: [0, 0.1, 0], shininess: 15 },
                    // Root mass
                    { name: 'rootMass', shape: 'cylinder', radiusTop: 4.2, radiusBottom: 5.6, height: 1.4, color: '#2a1a1a', position: [0, 0.7, 0], shininess: 20 },
                    { name: 'corruptionVeins', shape: 'cylinder', radiusTop: 4.9, radiusBottom: 4.9, height: 0.21, color: '#ff2222', position: [0, 0.35, 0], emissive: '#ff0000', shininess: 90 },
                    // Heart chamber
                    { name: 'heartChamber', shape: 'sphere', size: 3.5, color: '#3a1a1a', position: [0, 4.2, 0], shininess: 25 },
                    { name: 'heartCore', shape: 'sphere', size: 2.45, color: '#ff0000', position: [0, 4.2, 0], emissive: '#ff0000', shininess: 100 },
                    { name: 'heartMembrane', shape: 'sphere', size: 2.94, color: '#ff4444', position: [0, 4.2, 0], emissive: '#ff2222', shininess: 80 },
                    // Spinal tower
                    { name: 'spinalTower', shape: 'cylinder', radiusTop: 0.7, radiusBottom: 1.75, height: 8.4, color: '#3a2a2a', position: [0, 9.8, 0], shininess: 25 },
                    // Crown tentacles
                    { name: 'crownTentacle1', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.42, height: 3.5, color: '#4a2a2a', position: [1.4, 13.3, 0], rotation: [0, 0, -0.52], shininess: 22 },
                    { name: 'crownTentacle2', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.42, height: 3.5, color: '#4a2a2a', position: [-1.4, 13.3, 0], rotation: [0, 0, 0.52], shininess: 22 },
                    { name: 'crownTentacle3', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.42, height: 3.5, color: '#4a2a2a', position: [0, 13.3, 1.4], rotation: [0.52, 0, 0], shininess: 22 },
                    { name: 'crownTentacle4', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.42, height: 3.5, color: '#4a2a2a', position: [0, 13.3, -1.4], rotation: [-0.52, 0, 0], shininess: 22 },
                    // Eye cluster
                    { name: 'eyeCluster', shape: 'sphere', size: 0.84, color: '#ffff00', position: [0, 15.4, 0], emissive: '#ffaa00', shininess: 100 },
                    { name: 'mainPupil', shape: 'sphere', size: 0.35, color: '#000000', position: [0, 15.54, 0.56], shininess: 50 },
                    // Side eyes
                    { name: 'sideEye1', shape: 'sphere', size: 0.28, color: '#ffaa00', position: [0.7, 15.05, 0.35], emissive: '#ff8800', shininess: 100 },
                    { name: 'sideEye2', shape: 'sphere', size: 0.28, color: '#ffaa00', position: [-0.7, 15.05, 0.35], emissive: '#ff8800', shininess: 100 },
                    // Organ pods
                    { name: 'organPod1', shape: 'sphere', size: 1.75, color: '#5a2a2a', position: [3.5, 2.8, 0], shininess: 25 },
                    { name: 'organPod2', shape: 'sphere', size: 1.75, color: '#5a2a2a', position: [-3.5, 2.8, 0], shininess: 25 },
                    { name: 'organPod3', shape: 'sphere', size: 1.75, color: '#5a2a2a', position: [0, 2.8, 3.5], shininess: 25 },
                    { name: 'organPod4', shape: 'sphere', size: 1.75, color: '#5a2a2a', position: [0, 2.8, -3.5], shininess: 25 },
                    // Pod glows
                    { name: 'podGlow1', shape: 'sphere', size: 1.05, color: '#88ff44', position: [3.5, 2.8, 0], emissive: '#44ff00', shininess: 100 },
                    { name: 'podGlow2', shape: 'sphere', size: 1.05, color: '#88ff44', position: [-3.5, 2.8, 0], emissive: '#44ff00', shininess: 100 },
                    { name: 'podGlow3', shape: 'sphere', size: 1.05, color: '#88ff44', position: [0, 2.8, 3.5], emissive: '#44ff00', shininess: 100 },
                    { name: 'podGlow4', shape: 'sphere', size: 1.05, color: '#88ff44', position: [0, 2.8, -3.5], emissive: '#44ff00', shininess: 100 },
                    // Arteries
                    { name: 'arteryMain1', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 4.2, color: '#ff4444', position: [2.45, 3.5, 0], rotation: [0, 0, 0.52], emissive: '#ff2222', shininess: 80 },
                    { name: 'arteryMain2', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 4.2, color: '#ff4444', position: [-2.45, 3.5, 0], rotation: [0, 0, -0.52], emissive: '#ff2222', shininess: 80 },
                    { name: 'arteryMain3', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 4.2, color: '#ff4444', position: [0, 3.5, 2.45], rotation: [-0.52, 0, 0], emissive: '#ff2222', shininess: 80 },
                    { name: 'arteryMain4', shape: 'cylinder', radiusTop: 0.21, radiusBottom: 0.35, height: 4.2, color: '#ff4444', position: [0, 3.5, -2.45], rotation: [0.52, 0, 0], emissive: '#ff2222', shininess: 80 },
                    // Spine protrusions
                    { name: 'spineSpike1', shape: 'cone', size: 0.28, height: 1.4, color: '#3a2a2a', position: [1.05, 8.4, 0], rotation: [0, 0, -1.05], shininess: 30 },
                    { name: 'spineSpike2', shape: 'cone', size: 0.28, height: 1.4, color: '#3a2a2a', position: [-1.05, 8.4, 0], rotation: [0, 0, 1.05], shininess: 30 },
                    { name: 'spineSpike3', shape: 'cone', size: 0.28, height: 1.4, color: '#3a2a2a', position: [0, 8.4, 1.05], rotation: [1.05, 0, 0], shininess: 30 },
                    { name: 'spineSpike4', shape: 'cone', size: 0.28, height: 1.4, color: '#3a2a2a', position: [0, 8.4, -1.05], rotation: [-1.05, 0, 0], shininess: 30 }
                ]
            }
        };

        // 3D Model Builder Function
        function buildModel(modelDef, teamColor = null) {
            const group = new THREE.Group();
            const scale = modelDef.scale || 1.0;

            modelDef.bodyParts.forEach(part => {
                let geometry;
                let color = teamColor || new THREE.Color(part.color);

                // Create geometry based on shape
                switch(part.shape) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            part.width || 1,
                            part.height || 1,
                            part.depth || 1
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(part.size || 0.5, 16, 16);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            part.radiusTop || 0.5,
                            part.radiusBottom || 0.5,
                            part.height || 1,
                            16
                        );
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(part.size || 0.5, part.height || 1, 16);
                        break;
                    case 'octahedron':
                        geometry = new THREE.OctahedronGeometry(part.size || 0.5);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }

                // Create material
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 1 - (part.shininess || 50) / 100,
                    metalness: (part.shininess || 50) / 200,
                    emissive: part.emissive ? new THREE.Color(part.emissive) : new THREE.Color(0x000000),
                    emissiveIntensity: part.emissive ? 0.5 : 0
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Set position
                if (part.position) {
                    mesh.position.set(
                        part.position[0] * scale,
                        part.position[1] * scale,
                        part.position[2] * scale
                    );
                }

                // Set rotation
                if (part.rotation) {
                    mesh.rotation.set(part.rotation[0], part.rotation[1], part.rotation[2]);
                }

                // Scale the mesh
                mesh.scale.multiplyScalar(scale);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = part.name;

                group.add(mesh);
            });

            return group;
        }

        // Animation System - Enhanced with limb movement
        const AnimationSystem = {
            animations: new Map(),

            // Register an entity for animation
            register(entity, animationType) {
                this.animations.set(entity, {
                    type: animationType,
                    phase: Math.random() * Math.PI * 2,
                    walkPhase: 0,
                    attackPhase: 0,
                    castPhase: 0,
                    isAttacking: false,
                    isCasting: false,
                    limbCache: null
                });
            },

            // Get limb meshes from model group (enhanced for creatures and structures)
            getLimbs(entity) {
                if (!entity.modelGroup) return null;
                const limbs = {
                    // Humanoid parts
                    armL: null, armR: null,
                    legL: null, legR: null,
                    head: null, weapon: null,
                    cape: null, staff: null,
                    // Creature parts
                    tail: null, tailTip: null,
                    wingL: null, wingR: null,
                    earL: null, earR: null,
                    snout: null, mane: null,
                    // Quadruped legs
                    legFL: null, legFR: null,
                    legBL: null, legBR: null,
                    // Structure parts
                    energyCore: null, heartCore: null,
                    sensorArray: null, eyeBall: null,
                    tendril1: null, tendril2: null, tendril3: null,
                    crystals: [], glowParts: []
                };
                entity.modelGroup.traverse(child => {
                    // Humanoid
                    if (child.name === 'armL' || child.name === 'sleeveL') limbs.armL = child;
                    if (child.name === 'armR' || child.name === 'sleeveR') limbs.armR = child;
                    if (child.name === 'legL') limbs.legL = child;
                    if (child.name === 'legR') limbs.legR = child;
                    if (child.name === 'head' || child.name === 'helmet') limbs.head = child;
                    if (child.name === 'bladeR' || child.name === 'hammerHead' || child.name === 'staff' || child.name === 'axeBlade') limbs.weapon = child;
                    if (child.name === 'cape') limbs.cape = child;
                    if (child.name === 'staffOrb') limbs.staff = child;
                    // Creature parts
                    if (child.name === 'tail' || child.name === 'tailBase') limbs.tail = child;
                    if (child.name === 'tailTip' || child.name === 'tailSpike') limbs.tailTip = child;
                    if (child.name === 'wingMembraneL' || child.name === 'wingArmL') limbs.wingL = child;
                    if (child.name === 'wingMembraneR' || child.name === 'wingArmR') limbs.wingR = child;
                    if (child.name === 'earL') limbs.earL = child;
                    if (child.name === 'earR') limbs.earR = child;
                    if (child.name === 'snout') limbs.snout = child;
                    if (child.name === 'mane') limbs.mane = child;
                    // Quadruped legs
                    if (child.name === 'legFL') limbs.legFL = child;
                    if (child.name === 'legFR') limbs.legFR = child;
                    if (child.name === 'legBL') limbs.legBL = child;
                    if (child.name === 'legBR') limbs.legBR = child;
                    // Structure parts
                    if (child.name === 'energyCore' || child.name === 'quantumCore' || child.name === 'runeCore') limbs.energyCore = child;
                    if (child.name === 'heartCore') limbs.heartCore = child;
                    if (child.name === 'sensorArray') limbs.sensorArray = child;
                    if (child.name === 'eyeBall') limbs.eyeBall = child;
                    if (child.name === 'tendril1') limbs.tendril1 = child;
                    if (child.name === 'tendril2') limbs.tendril2 = child;
                    if (child.name === 'tendril3') limbs.tendril3 = child;
                    // Collect crystals and glowing parts
                    if (child.name && child.name.includes('crystal')) limbs.crystals.push(child);
                    if (child.name && (child.name.includes('Glow') || child.name.includes('Emit'))) limbs.glowParts.push(child);
                });
                return limbs;
            },

            // Update all animations
            update(dt) {
                this.animations.forEach((anim, entity) => {
                    if (!entity || entity.dead || !entity.mesh) return;

                    anim.phase += dt * 2;

                    // Cache limbs for performance
                    if (!anim.limbCache && entity.modelGroup) {
                        anim.limbCache = this.getLimbs(entity);
                    }

                    // Idle animation (breathing/bobbing)
                    const breathe = 1 + Math.sin(anim.phase) * 0.03;
                    const bob = Math.sin(anim.phase * 1.5) * 0.05;

                    // Apply idle animation
                    if (entity.modelGroup) {
                        entity.modelGroup.scale.y = breathe;
                        entity.modelGroup.position.y = bob;

                        const limbs = anim.limbCache;

                        // Walk animation with limb movement
                        if (entity.isMoving) {
                            anim.walkPhase += dt * 12;
                            const walkBob = Math.abs(Math.sin(anim.walkPhase)) * 0.1;
                            const walkTilt = Math.sin(anim.walkPhase) * 0.05;
                            entity.modelGroup.position.y += walkBob;
                            entity.modelGroup.rotation.z = walkTilt;

                            // Animate limbs during walk
                            if (limbs) {
                                const legSwing = Math.sin(anim.walkPhase) * 0.4;
                                const armSwing = Math.sin(anim.walkPhase) * 0.3;

                                if (limbs.legL) limbs.legL.rotation.x = legSwing;
                                if (limbs.legR) limbs.legR.rotation.x = -legSwing;
                                if (limbs.armL) limbs.armL.rotation.x = -armSwing;
                                if (limbs.armR) limbs.armR.rotation.x = armSwing;

                                // Cape flow
                                if (limbs.cape) {
                                    limbs.cape.rotation.x = Math.sin(anim.walkPhase * 0.5) * 0.15 + 0.1;
                                }
                            }
                        } else {
                            entity.modelGroup.rotation.z *= 0.9;
                            // Return limbs to rest
                            if (limbs) {
                                if (limbs.legL) limbs.legL.rotation.x *= 0.9;
                                if (limbs.legR) limbs.legR.rotation.x *= 0.9;
                                if (limbs.armL) limbs.armL.rotation.x *= 0.9;
                                if (limbs.armR) limbs.armR.rotation.x *= 0.9;
                            }
                        }

                        // Attack animation with weapon swing
                        if (anim.isAttacking) {
                            anim.attackPhase += dt * 15;
                            const attackLean = Math.sin(anim.attackPhase) * 0.2;
                            entity.modelGroup.rotation.x = attackLean;

                            // Weapon and arm swing
                            if (limbs) {
                                const swingArc = Math.sin(anim.attackPhase * 2) * 1.2;
                                if (limbs.armR) limbs.armR.rotation.x = -swingArc;
                                if (limbs.weapon) limbs.weapon.rotation.x = -swingArc * 0.5;
                            }

                            if (anim.attackPhase > Math.PI) {
                                anim.isAttacking = false;
                                anim.attackPhase = 0;
                            }
                        } else {
                            entity.modelGroup.rotation.x *= 0.9;
                        }

                        // Cast animation (arms raised, staff glow)
                        if (anim.isCasting) {
                            anim.castPhase += dt * 10;
                            if (limbs) {
                                const raiseAmt = Math.sin(anim.castPhase) * 0.8;
                                if (limbs.armL) limbs.armL.rotation.x = -raiseAmt - 0.5;
                                if (limbs.armR) limbs.armR.rotation.x = -raiseAmt - 0.5;
                                if (limbs.staff) {
                                    limbs.staff.material.emissiveIntensity = 0.5 + Math.sin(anim.castPhase * 3) * 0.5;
                                }
                            }
                            if (anim.castPhase > Math.PI) {
                                anim.isCasting = false;
                                anim.castPhase = 0;
                            }
                        }

                        // Head look (subtle idle movement)
                        if (limbs && limbs.head) {
                            limbs.head.rotation.y = Math.sin(anim.phase * 0.5) * 0.1;
                        }

                        // === CREATURE-SPECIFIC ANIMATIONS ===
                        if (anim.type === 'creature' && limbs) {
                            // Tail wagging animation
                            if (limbs.tail) {
                                limbs.tail.rotation.y = Math.sin(anim.phase * 2) * 0.3;
                                limbs.tail.rotation.z = Math.sin(anim.phase * 1.5) * 0.1;
                            }
                            if (limbs.tailTip) {
                                limbs.tailTip.rotation.y = Math.sin(anim.phase * 2.5) * 0.4;
                            }

                            // Wing flapping animation
                            if (limbs.wingL) {
                                limbs.wingL.rotation.z = Math.sin(anim.phase * 1.2) * 0.15 + 0.5;
                            }
                            if (limbs.wingR) {
                                limbs.wingR.rotation.z = -Math.sin(anim.phase * 1.2) * 0.15 - 0.5;
                            }

                            // Ear twitch
                            if (limbs.earL) {
                                limbs.earL.rotation.x = Math.sin(anim.phase * 3) * 0.1;
                            }
                            if (limbs.earR) {
                                limbs.earR.rotation.x = Math.sin(anim.phase * 3 + 0.5) * 0.1;
                            }

                            // Snout/head bob
                            if (limbs.snout) {
                                limbs.snout.rotation.x = Math.sin(anim.phase * 1.5) * 0.05;
                            }

                            // Mane flow
                            if (limbs.mane) {
                                limbs.mane.rotation.z = Math.sin(anim.phase * 0.8) * 0.08;
                            }

                            // Quadruped leg animation (when moving)
                            if (entity.isMoving) {
                                const quadLegSwing = Math.sin(anim.walkPhase) * 0.4;
                                if (limbs.legFL) limbs.legFL.rotation.x = quadLegSwing;
                                if (limbs.legFR) limbs.legFR.rotation.x = -quadLegSwing;
                                if (limbs.legBL) limbs.legBL.rotation.x = -quadLegSwing * 0.8;
                                if (limbs.legBR) limbs.legBR.rotation.x = quadLegSwing * 0.8;
                            } else {
                                // Subtle idle leg movement
                                if (limbs.legFL) limbs.legFL.rotation.x *= 0.95;
                                if (limbs.legFR) limbs.legFR.rotation.x *= 0.95;
                                if (limbs.legBL) limbs.legBL.rotation.x *= 0.95;
                                if (limbs.legBR) limbs.legBR.rotation.x *= 0.95;
                            }
                        }

                        // === STRUCTURE-SPECIFIC ANIMATIONS ===
                        if (anim.type === 'structure' && limbs) {
                            // Pulsing energy cores
                            if (limbs.energyCore) {
                                const pulseScale = 1 + Math.sin(anim.phase * 2) * 0.15;
                                limbs.energyCore.scale.setScalar(pulseScale);
                                if (limbs.energyCore.material) {
                                    limbs.energyCore.material.emissiveIntensity = 0.5 + Math.sin(anim.phase * 3) * 0.3;
                                }
                            }

                            // Heartbeat animation (for dire structures)
                            if (limbs.heartCore) {
                                // Heartbeat pattern: quick contract, slow expand
                                const heartPhase = anim.phase * 1.2;
                                const heartbeat = 1 + Math.pow(Math.sin(heartPhase), 12) * 0.2;
                                limbs.heartCore.scale.setScalar(heartbeat);
                                if (limbs.heartCore.material) {
                                    limbs.heartCore.material.emissiveIntensity = 0.8 + Math.pow(Math.sin(heartPhase), 12) * 0.7;
                                }
                            }

                            // Rotating sensor array
                            if (limbs.sensorArray) {
                                limbs.sensorArray.rotation.y += dt * 2;
                            }

                            // Tracking eyeball
                            if (limbs.eyeBall) {
                                limbs.eyeBall.rotation.y = Math.sin(anim.phase * 0.3) * 0.3;
                                limbs.eyeBall.rotation.x = Math.sin(anim.phase * 0.4) * 0.15;
                            }

                            // Waving tendrils
                            if (limbs.tendril1) {
                                limbs.tendril1.rotation.z = Math.sin(anim.phase * 0.5) * 0.15 - 1.05;
                            }
                            if (limbs.tendril2) {
                                limbs.tendril2.rotation.z = Math.sin(anim.phase * 0.5 + 1) * 0.15 + 1.05;
                            }
                            if (limbs.tendril3) {
                                limbs.tendril3.rotation.x = Math.sin(anim.phase * 0.5 + 2) * 0.15 + 1.05;
                            }

                            // Pulsing crystals
                            limbs.crystals.forEach((crystal, i) => {
                                const crystalPhase = anim.phase + i * 0.5;
                                if (crystal.material) {
                                    crystal.material.emissiveIntensity = 0.3 + Math.sin(crystalPhase * 2) * 0.2;
                                }
                            });

                            // Pulsing glow parts
                            limbs.glowParts.forEach((glow, i) => {
                                const glowPhase = anim.phase + i * 0.3;
                                if (glow.material) {
                                    glow.material.emissiveIntensity = 0.4 + Math.sin(glowPhase * 1.5) * 0.3;
                                }
                            });
                        }
                    }
                });
            },

            // Trigger attack animation
            triggerAttack(entity) {
                const anim = this.animations.get(entity);
                if (anim) {
                    anim.isAttacking = true;
                    anim.attackPhase = 0;
                }
            },

            // Trigger cast animation
            triggerCast(entity) {
                const anim = this.animations.get(entity);
                if (anim) {
                    anim.isCasting = true;
                    anim.castPhase = 0;
                }
            }
        };

        // Particle System for Effects
        const ParticleSystem = {
            particles: [],
            maxParticles: 500,

            createParticle(config) {
                if (this.particles.length >= this.maxParticles) {
                    // Remove oldest particle
                    const old = this.particles.shift();
                    if (old.mesh) scene.remove(old.mesh);
                }

                const geometry = new THREE.SphereGeometry(config.size || 0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: config.color || 0xffffff,
                    transparent: true,
                    opacity: config.opacity || 1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(config.x, config.y, config.z);
                scene.add(mesh);

                const particle = {
                    mesh,
                    vx: config.vx || 0,
                    vy: config.vy || 0,
                    vz: config.vz || 0,
                    gravity: config.gravity || 0,
                    life: config.life || 1,
                    decay: config.decay || 0.02,
                    scale: config.scale || 1,
                    scaleDecay: config.scaleDecay || 0
                };

                this.particles.push(particle);
                return particle;
            },

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Update position
                    p.mesh.position.x += p.vx * dt * 60;
                    p.mesh.position.y += p.vy * dt * 60;
                    p.mesh.position.z += p.vz * dt * 60;

                    // Apply gravity
                    p.vy -= p.gravity * dt;

                    // Update life and opacity
                    p.life -= p.decay;
                    p.mesh.material.opacity = p.life;

                    // Update scale
                    if (p.scaleDecay) {
                        p.scale -= p.scaleDecay;
                        p.mesh.scale.setScalar(Math.max(0.01, p.scale));
                    }

                    // Remove dead particles
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            },

            // Create ability effect bursts
            createBurst(pos, color, count, config = {}) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const speed = config.speed || 0.1;
                    this.createParticle({
                        x: pos.x,
                        y: pos.y + (config.yOffset || 0.5),
                        z: pos.z,
                        vx: Math.cos(angle) * speed * (0.5 + Math.random() * 0.5),
                        vy: (config.vy || 0.05) + Math.random() * 0.1,
                        vz: Math.sin(angle) * speed * (0.5 + Math.random() * 0.5),
                        color: color,
                        size: config.size || 0.1,
                        life: config.life || 1,
                        decay: config.decay || 0.03,
                        gravity: config.gravity || 0.003
                    });
                }
            },

            // Fire trail effect
            createFireTrail(pos, direction) {
                for (let i = 0; i < 3; i++) {
                    this.createParticle({
                        x: pos.x + (Math.random() - 0.5) * 0.3,
                        y: pos.y + 0.5,
                        z: pos.z + (Math.random() - 0.5) * 0.3,
                        vx: -direction.x * 0.02 + (Math.random() - 0.5) * 0.02,
                        vy: 0.03 + Math.random() * 0.02,
                        vz: -direction.z * 0.02 + (Math.random() - 0.5) * 0.02,
                        color: 0xff6600 + Math.floor(Math.random() * 0x003300),
                        size: 0.08 + Math.random() * 0.05,
                        life: 0.6,
                        decay: 0.04,
                        gravity: -0.001
                    });
                }
            },

            // Magic sparkles
            createSparkles(pos, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    this.createParticle({
                        x: pos.x + (Math.random() - 0.5) * 0.5,
                        y: pos.y + Math.random() * 1.5,
                        z: pos.z + (Math.random() - 0.5) * 0.5,
                        vx: (Math.random() - 0.5) * 0.02,
                        vy: 0.02 + Math.random() * 0.02,
                        vz: (Math.random() - 0.5) * 0.02,
                        color: color,
                        size: 0.04 + Math.random() * 0.03,
                        life: 0.8,
                        decay: 0.02,
                        gravity: -0.002
                    });
                }
            }
        };

        // Globals
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let entities = [];
        let player = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let gameTime = 0;
        let score = { radiant: 0, dire: 0 };
        let firstBlood = false; // Track if first blood has occurred
        let portraitScene, portraitCamera, portraitRenderer, portraitMesh;

        // ==========================================
        // R2: Vector3 Pool - Reduces GC pressure
        // Reusable temp vectors for per-frame calculations
        // ==========================================
        const VecPool = {
            _pool: [],
            _index: 0,
            _size: 20,

            init() {
                for (let i = 0; i < this._size; i++) {
                    this._pool.push(new THREE.Vector3());
                }
            },

            // Get a temp vector (resets each frame)
            get() {
                if (this._index >= this._size) {
                    // Expand pool if needed
                    this._pool.push(new THREE.Vector3());
                    this._size++;
                }
                return this._pool[this._index++];
            },

            // Reset pool index (call at start of each frame)
            reset() {
                this._index = 0;
            }
        };

        // Pre-allocated temp vectors for common operations
        const _tempVec1 = new THREE.Vector3();
        const _tempVec2 = new THREE.Vector3();
        const _tempVec3 = new THREE.Vector3();

        // ==========================================
        // R3: Spatial Grid - O(n) entity queries instead of O(n¬≤)
        // Divides map into cells for fast proximity lookups
        // ==========================================
        const SpatialGrid = {
            cellSize: 10,  // 10 unit cells for ~100x100 map
            grid: new Map(),

            // Rebuild grid each frame (call at start of update)
            rebuild() {
                this.grid.clear();
                for (let i = 0; i < entities.length; i++) {
                    const e = entities[i];
                    if (e.dead || !e.mesh) continue;

                    const cellX = Math.floor(e.mesh.position.x / this.cellSize);
                    const cellZ = Math.floor(e.mesh.position.z / this.cellSize);
                    const key = (cellX << 16) | (cellZ & 0xFFFF);

                    if (!this.grid.has(key)) {
                        this.grid.set(key, []);
                    }
                    this.grid.get(key).push(e);
                }
            },

            // Get entities within radius (checks 3x3 cells around point)
            getNearby(x, z, radius, excludeEntity = null) {
                const results = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const centerCellX = Math.floor(x / this.cellSize);
                const centerCellZ = Math.floor(z / this.cellSize);
                const radiusSq = radius * radius;

                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                        const key = ((centerCellX + dx) << 16) | ((centerCellZ + dz) & 0xFFFF);
                        const cell = this.grid.get(key);
                        if (!cell) continue;

                        for (let i = 0; i < cell.length; i++) {
                            const e = cell[i];
                            if (e === excludeEntity || e.dead) continue;

                            const ex = e.mesh.position.x;
                            const ez = e.mesh.position.z;
                            const distSq = (ex - x) * (ex - x) + (ez - z) * (ez - z);

                            if (distSq <= radiusSq) {
                                results.push({ entity: e, distSq: distSq });
                            }
                        }
                    }
                }
                return results;
            },

            // Fast nearest enemy lookup
            getNearestEnemy(x, z, range, myTeam) {
                const nearby = this.getNearby(x, z, range);
                let nearest = null;
                let nearestDistSq = range * range;

                for (let i = 0; i < nearby.length; i++) {
                    const { entity, distSq } = nearby[i];
                    if (entity.team !== myTeam && distSq < nearestDistSq) {
                        nearest = entity;
                        nearestDistSq = distSq;
                    }
                }
                return nearest;
            }
        };

        // ==========================================
        // KILL STREAK SYSTEM
        // ==========================================
        const KILL_STREAK_NAMES = {
            3: 'KILLING SPREE',
            4: 'DOMINATING',
            5: 'MEGA KILL',
            6: 'UNSTOPPABLE',
            7: 'WICKED SICK',
            8: 'MONSTER KILL',
            9: 'GODLIKE',
            10: 'BEYOND GODLIKE'
        };

        const KILL_STREAK_GOLD = {
            0: 0,    // No streak
            3: 150,  // Killing Spree
            4: 200,  // Dominating
            5: 250,  // Mega Kill
            6: 300,  // Unstoppable
            7: 350,  // Wicked Sick
            8: 400,  // Monster Kill
            9: 500,  // Godlike
            10: 600  // Beyond Godlike
        };

        function announceKillStreak(killer, streak) {
            if (!KILL_STREAK_NAMES[streak]) return;

            const name = KILL_STREAK_NAMES[streak];
            showMessage(`${killer.name || 'Player'} is ${name}!`, 3000);

            // Play streak sound
            AudioManager.playKillStreak && AudioManager.playKillStreak(streak);

            // Visual effect on killer
            if (killer.mesh) {
                createExplosion(killer.mesh.position, 0xffd700, 40);
            }
        }

        function announceFirstBlood(killer, victim) {
            if (firstBlood) return;
            firstBlood = true;

            showMessage('FIRST BLOOD!', 4000);
            AudioManager.playFirstBlood && AudioManager.playFirstBlood();

            // Bonus gold for first blood
            if (killer && killer.team === TEAM_RADIANT) {
                killer.gold = (killer.gold || 0) + 200;
                showGoldText(killer.mesh.position, 200);
            }
        }

        function calculateBountyGold(victim) {
            let baseGold = 200;

            // Bonus gold based on victim's level
            baseGold += (victim.level || 1) * 20;

            // Bonus gold based on victim's kill streak
            const streak = victim.killStreak || 0;
            const streakTier = Math.min(10, Math.max(0, streak));
            baseGold += KILL_STREAK_GOLD[streakTier >= 3 ? streakTier : 0] || 0;

            // Bonus gold based on victim's net worth (gold + item value)
            const netWorth = (victim.gold || 0) + ((victim.inventory || []).length * 500);
            baseGold += Math.floor(netWorth * 0.05); // 5% of net worth

            return baseGold;
        }

        function processHeroKill(killer, victim) {
            // R4: HitStop on hero kill for game feel impact
            if (typeof HitStop !== 'undefined') {
                HitStop.heavyHit(80);  // 80ms freeze on hero kill
            }
            if (typeof screenShake !== 'undefined') {
                screenShake.heavy();   // Heavy shake for kill confirm
            }

            // Track kill streak for killer
            killer.killStreak = (killer.killStreak || 0) + 1;
            killer.deaths = killer.deaths || 0;

            // Track deaths for victim
            victim.deaths = (victim.deaths || 0) + 1;

            // Calculate gold reward
            const bountyGold = calculateBountyGold(victim);
            killer.gold = (killer.gold || 0) + bountyGold;
            showGoldText(killer.mesh.position, bountyGold);

            // XP reward
            const bountyXP = 100 + ((victim.level || 1) * 50);
            killer.xp = (killer.xp || 0) + bountyXP;
            killer.checkLevelUp && killer.checkLevelUp();

            // First blood check
            if (!firstBlood) {
                announceFirstBlood(killer, victim);
            }

            // Kill streak announcement
            if (killer.killStreak >= 3) {
                announceKillStreak(killer, Math.min(10, killer.killStreak));
            }

            // End victim's kill streak
            if ((victim.killStreak || 0) >= 3) {
                const endMessage = `${killer.name || 'Enemy'} ended ${victim.name || 'Player'}'s killing spree!`;
                showMessage(endMessage, 2500);
            }
            victim.killStreak = 0;

            // Update kill feed
            killFeed.add(
                killer.name || (killer.team === TEAM_RADIANT ? 'Radiant Hero' : 'Dire Hero'),
                victim.name || (victim.team === TEAM_RADIANT ? 'Radiant Hero' : 'Dire Hero'),
                killer.team
            );
        }

        // ROUND 1: Data Persistence System
        const STORAGE_KEYS = {
            matchHistory: 'dota3_match_history',
            settings: 'dota3_settings'
        };

        const defaultSettings = {
            bloomEnabled: true,
            bloomStrength: 1.2,
            showDamageNumbers: true,
            soundEnabled: true  // ROUND 3: Enabled by default
        };

        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.settings);
                return saved ? { ...defaultSettings, ...JSON.parse(saved) } : { ...defaultSettings };
            } catch (e) {
                return { ...defaultSettings };
            }
        }

        function saveSettings(settings) {
            try {
                localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(settings));
            } catch (e) {
                console.warn('Failed to save settings:', e);
            }
        }

        function loadMatchHistory() {
            try {
                const data = localStorage.getItem(STORAGE_KEYS.matchHistory);
                return data ? JSON.parse(data) : { matches: [], bestKills: 0, totalPlayTime: 0 };
            } catch (e) {
                return { matches: [], bestKills: 0, totalPlayTime: 0 };
            }
        }

        function saveMatchResult() {
            if (!player) return;
            const history = loadMatchHistory();
            const matchResult = {
                date: new Date().toISOString(),
                radiantScore: score.radiant,
                direScore: score.dire,
                gameTime: Math.floor(gameTime),
                playerSurvived: !player.dead
            };

            history.matches.unshift(matchResult);
            history.matches = history.matches.slice(0, 20);
            history.bestKills = Math.max(history.bestKills, score.radiant);
            history.totalPlayTime += Math.floor(gameTime);

            try {
                localStorage.setItem(STORAGE_KEYS.matchHistory, JSON.stringify(history));
            } catch (e) {
                console.warn('Failed to save match:', e);
            }
        }

        function exportGameData() {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                matchHistory: loadMatchHistory(),
                settings: loadSettings()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dota3-legacy-save-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Data Exported');
        }

        function importGameData(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.version && data.matchHistory) {
                        localStorage.setItem(STORAGE_KEYS.matchHistory, JSON.stringify(data.matchHistory));
                        if (data.settings) {
                            localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(data.settings));
                        }
                        showMessage('Import Successful');
                    } else {
                        showMessage('Invalid Save File');
                    }
                } catch (err) {
                    showMessage('Import Failed');
                }
            };
            reader.readAsText(file);
        }

        // ROUND 1: Entity cleanup system
        function cleanupDeadEntities() {
            const before = entities.length;
            entities = entities.filter(e => !e.dead);
            // Cleanup runs silently - no log spam
        }

        let gameSettings = loadSettings();

        // ROUND 3: Web Audio Sound System
        const AudioManager = {
            ctx: null,
            masterGain: null,

            init() {
                if (this.ctx) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.connect(this.ctx.destination);
                    this.masterGain.gain.value = 0.25;
                } catch (e) { console.warn('Web Audio not supported'); }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },

            playHit(type = 'physical') {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                if (type === 'crit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(150, now + 0.15);
                } else {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(120 + Math.random() * 40, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                }
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            playCast(key) {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                const freqs = { q: [400, 1000], w: [1500, 100], e: [220, 220], r: [80, 40] };
                const f = freqs[key] || [400, 200];
                osc.type = key === 'r' ? 'sawtooth' : 'sine';
                osc.frequency.setValueAtTime(f[0], now);
                osc.frequency.exponentialRampToValueAtTime(f[1], now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + (key === 'r' ? 0.5 : 0.2));
                osc.start(now);
                osc.stop(now + (key === 'r' ? 0.5 : 0.2));
            },

            playUI(type) {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);

                if (type === 'notification') {
                    osc.frequency.setValueAtTime(523, now);
                    osc.frequency.setValueAtTime(659, now + 0.08);
                } else if (type === 'click') {
                    osc.frequency.setValueAtTime(800, now);
                }
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            // ROUND 5: Error sound for failed casts
            playError() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.setValueAtTime(100, now + 0.05);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // ROUND 9: Purchase sound (coin/cash register feel)
            playPurchase() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.setValueAtTime(1200, now + 0.05);
                osc.frequency.setValueAtTime(1600, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            // ROUND 9: Level up fanfare
            playLevelUp() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                // Ascending arpeggio
                [523, 659, 784, 1047].forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.frequency.setValueAtTime(freq, now + i * 0.08);
                    gain.gain.setValueAtTime(0.1, now + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.2);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.25);
                });
            },

            // ROUND 9: Gold pickup chime
            playGold() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(1500, now);
                osc.frequency.setValueAtTime(2000, now + 0.03);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.12);
            },

            // Rune powerup sound - magical ascending arpeggio
            playPowerup() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const notes = [523, 659, 784, 1047, 1319]; // C5-E6 arpeggio
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.frequency.setValueAtTime(freq, now + i * 0.07);
                    gain.gain.setValueAtTime(0, now + i * 0.07);
                    gain.gain.linearRampToValueAtTime(0.15, now + i * 0.07 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.07 + 0.25);
                    osc.start(now + i * 0.07);
                    osc.stop(now + i * 0.07 + 0.3);
                });
                // Shimmer effect
                const shimmer = this.ctx.createOscillator();
                const shimmerGain = this.ctx.createGain();
                shimmer.type = 'triangle';
                shimmer.connect(shimmerGain);
                shimmerGain.connect(this.masterGain);
                shimmer.frequency.setValueAtTime(2000, now);
                shimmer.frequency.linearRampToValueAtTime(4000, now + 0.4);
                shimmerGain.gain.setValueAtTime(0.05, now);
                shimmerGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                shimmer.start(now);
                shimmer.stop(now + 0.45);
            },

            // Death sound - descending tone
            playDeath(type = 'creep') {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                if (type === 'hero') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(60, now + 0.5);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                } else if (type === 'structure') {
                    // Big explosion sound
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                    gain.gain.setValueAtTime(0.35, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);
                    // Add rumble
                    const noise = this.ctx.createOscillator();
                    const noiseGain = this.ctx.createGain();
                    noise.type = 'square';
                    noise.connect(noiseGain);
                    noiseGain.connect(this.masterGain);
                    noise.frequency.setValueAtTime(40, now);
                    noiseGain.gain.setValueAtTime(0.15, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    noise.start(now);
                    noise.stop(now + 0.6);
                } else {
                    // Creep death - quick thud
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                }
            },

            // Tower attack sound
            playTowerShot() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(180, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                osc.start(now);
                osc.stop(now + 0.12);
            },

            // First Blood announcement sound - dramatic horn
            playFirstBlood() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                // Deep horn note
                const horn = this.ctx.createOscillator();
                const hornGain = this.ctx.createGain();
                horn.type = 'sawtooth';
                horn.connect(hornGain);
                hornGain.connect(this.masterGain);
                horn.frequency.setValueAtTime(110, now);
                horn.frequency.setValueAtTime(165, now + 0.3);
                horn.frequency.setValueAtTime(220, now + 0.6);
                hornGain.gain.setValueAtTime(0, now);
                hornGain.gain.linearRampToValueAtTime(0.25, now + 0.1);
                hornGain.gain.setValueAtTime(0.25, now + 0.8);
                hornGain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
                horn.start(now);
                horn.stop(now + 1.3);
                // Accompanying shimmer
                const shimmer = this.ctx.createOscillator();
                const shimGain = this.ctx.createGain();
                shimmer.type = 'sine';
                shimmer.connect(shimGain);
                shimGain.connect(this.masterGain);
                shimmer.frequency.setValueAtTime(880, now);
                shimmer.frequency.linearRampToValueAtTime(1760, now + 0.5);
                shimGain.gain.setValueAtTime(0.08, now + 0.2);
                shimGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                shimmer.start(now + 0.2);
                shimmer.stop(now + 0.9);
            },

            // Kill streak announcement - escalating intensity
            playKillStreak(streakLevel) {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const intensity = Math.min(1, (streakLevel - 2) / 8); // 0 to 1 based on streak
                const noteCount = Math.min(5, streakLevel - 1);

                // Ascending fanfare notes
                for (let i = 0; i < noteCount; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    const baseFreq = 220 + (streakLevel * 20);
                    osc.frequency.setValueAtTime(baseFreq * Math.pow(1.26, i), now + i * 0.08);
                    gain.gain.setValueAtTime(0, now + i * 0.08);
                    gain.gain.linearRampToValueAtTime(0.15 + intensity * 0.1, now + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.2);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.25);
                }

                // Power chord at the end for high streaks
                if (streakLevel >= 5) {
                    const chord = this.ctx.createOscillator();
                    const chordGain = this.ctx.createGain();
                    chord.type = 'sawtooth';
                    chord.connect(chordGain);
                    chordGain.connect(this.masterGain);
                    chord.frequency.setValueAtTime(440 + streakLevel * 30, now + noteCount * 0.08);
                    chordGain.gain.setValueAtTime(0.2 + intensity * 0.15, now + noteCount * 0.08);
                    chordGain.gain.exponentialRampToValueAtTime(0.01, now + noteCount * 0.08 + 0.5);
                    chord.start(now + noteCount * 0.08);
                    chord.stop(now + noteCount * 0.08 + 0.6);
                }
            },

            // Victory fanfare
            playVictory() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                // Triumphant ascending chord
                const notes = [523, 659, 784, 1047, 1319];
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.frequency.setValueAtTime(freq, now + i * 0.15);
                    gain.gain.setValueAtTime(0.15, now + i * 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.6);
                    osc.start(now + i * 0.15);
                    osc.stop(now + i * 0.15 + 0.7);
                });
            },

            // Defeat sound
            playDefeat() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                // Descending minor chord
                const notes = [392, 311, 261, 196];
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.frequency.setValueAtTime(freq, now + i * 0.2);
                    gain.gain.setValueAtTime(0.12, now + i * 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.2 + 0.5);
                    osc.start(now + i * 0.2);
                    osc.stop(now + i * 0.2 + 0.6);
                });
            },

            // Respawn sound
            playRespawn() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            },

            // Ability-specific sounds
            playAbility(type) {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                switch(type) {
                    case 'fire':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'ice':
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(2000, now);
                        osc.frequency.exponentialRampToValueAtTime(500, now + 0.2);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                        osc.start(now);
                        osc.stop(now + 0.25);
                        break;
                    case 'shadow':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(80, now);
                        osc.frequency.setValueAtTime(120, now + 0.1);
                        osc.frequency.setValueAtTime(60, now + 0.2);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'blink':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(1200, now);
                        osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                        osc.start(now);
                        osc.stop(now + 0.12);
                        break;
                    case 'buff':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.setValueAtTime(800, now + 0.08);
                        osc.frequency.setValueAtTime(1000, now + 0.16);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                        osc.start(now);
                        osc.stop(now + 0.25);
                        break;
                    default:
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                }
            }
        };

        // ROUND 2: Game State Management
        let gameState = 'playing'; // 'playing', 'paused', 'victory', 'defeat'
        let respawnTimer = 0;
        let isRespawning = false;
        let radiantBase = null;
        let direBase = null;

        // ROUND 4: Store interval IDs for cleanup
        let spawnIntervalId = null;
        let cleanupIntervalId = null;

        // ROUND 2: Performance - minimap throttling
        let lastMinimapUpdate = 0;
        const MINIMAP_UPDATE_INTERVAL = 200; // 5fps instead of 60fps

        // ROUND 2: Performance - UI value caching
        let cachedUI = { hp: -1, mp: -1 };

        // ROUND 9: Item Shop System - EXPANDED
        const ITEMS = {
            // === CONSUMABLES ===
            salve: { name: 'Healing Salve', cost: 100, icon: 'üíä', effect: 'heal', value: 300, desc: '+300 HP (instant)', category: 'consumable' },
            clarity: { name: 'Clarity', cost: 75, icon: 'üíß', effect: 'mana_restore', value: 200, desc: '+200 Mana (instant)', category: 'consumable' },
            flask: { name: 'Magic Flask', cost: 150, icon: 'üß™', effect: 'heal_both', value: 200, desc: '+200 HP & Mana', category: 'consumable' },
            tango: { name: 'Tango', cost: 50, icon: 'üåø', effect: 'heal_over_time', value: 150, duration: 10, desc: '+150 HP over 10s', category: 'consumable' },
            faerie: { name: 'Faerie Fire', cost: 65, icon: '‚ú®', effect: 'multi', values: { damage: 2, heal_instant: 85 }, desc: '+2 Dmg, Use: +85 HP', category: 'consumable' },
            smoke: { name: 'Smoke of Deceit', cost: 80, icon: 'üå´Ô∏è', effect: 'active_smoke', cooldown: 90, desc: 'Team stealth (dispels near enemies)', category: 'consumable', hasActive: true },
            dust: { name: 'Dust of Appearance', cost: 80, icon: 'üí´', effect: 'active_dust', cooldown: 30, desc: 'Reveal invisible units', category: 'consumable', hasActive: true },
            tp: { name: 'Town Portal Scroll', cost: 100, icon: 'üìú', effect: 'active_tp', cooldown: 80, desc: 'Teleport to allied structure', category: 'consumable', hasActive: true },
            observer: { name: 'Observer Ward', cost: 75, icon: 'üëÅÔ∏è', effect: 'place_ward', wardType: 'observer', desc: 'Place to reveal area (5 min)', category: 'consumable', hasActive: true },
            sentry: { name: 'Sentry Ward', cost: 100, icon: 'üîÆ', effect: 'place_ward', wardType: 'sentry', desc: 'Place to detect invisible (4 min)', category: 'consumable', hasActive: true },

            // === BASIC ITEMS ===
            boots: { name: 'Boots', cost: 300, icon: 'üë¢', effect: 'speed', value: 0.05, desc: '+20% Move Speed', category: 'basic' },
            blade: { name: 'Blade', cost: 400, icon: 'üó°Ô∏è', effect: 'damage', value: 15, desc: '+15 Damage', category: 'basic' },
            armor: { name: 'Chainmail', cost: 400, icon: 'üõ°Ô∏è', effect: 'armor', value: 3, desc: '+3 Armor', category: 'basic' },
            crystal: { name: 'Mana Crystal', cost: 250, icon: 'üíé', effect: 'mana', value: 150, desc: '+150 Max Mana', category: 'basic' },
            cloak: { name: 'Cloak', cost: 350, icon: 'üß•', effect: 'magic_resist', value: 0.15, desc: '+15% Magic Resist', category: 'basic' },
            gloves: { name: 'Attack Gloves', cost: 400, icon: 'üß§', effect: 'attack_speed', value: 0.2, desc: '+20% Attack Speed', category: 'basic' },
            ring: { name: 'Vitality Ring', cost: 300, icon: 'üíç', effect: 'hp', value: 200, desc: '+200 Max HP', category: 'basic' },
            pendant: { name: 'Sage Pendant', cost: 350, icon: 'üìø', effect: 'mana_regen', value: 2, desc: '+2 Mana/sec', category: 'basic' },
            circlet: { name: 'Circlet', cost: 175, icon: 'üí´', effect: 'multi', values: { damage: 2, hp: 50, mana: 50 }, desc: '+2 All Stats', category: 'basic' },
            branch: { name: 'Iron Branch', cost: 50, icon: 'üå≥', effect: 'multi', values: { damage: 1, hp: 25, mana: 25 }, desc: '+1 All Stats', category: 'basic' },
            orb: { name: 'Orb of Venom', cost: 250, icon: 'üü¢', effect: 'poison_attack', value: 3, desc: 'Attacks slow & poison (3 DPS)', category: 'basic' },
            windlace: { name: 'Wind Lace', cost: 225, icon: 'üå¨Ô∏è', effect: 'speed', value: 0.03, desc: '+15% Move Speed', category: 'basic' },
            buckler: { name: 'Buckler', cost: 350, icon: 'üî∞', effect: 'multi', values: { armor: 2, hp_regen: 1 }, desc: '+2 Armor, +1 HP/s', category: 'basic' },
            headdress: { name: 'Headdress', cost: 400, icon: 'üëí', effect: 'multi', values: { hp_regen: 3, aura_hp_regen: 1 }, desc: '+3 HP/s, Aura: +1 HP/s', category: 'basic' },
            soulring: { name: 'Soul Ring', cost: 500, icon: 'üíÄ', effect: 'active_soulring', cooldown: 25, desc: 'Active: -150 HP, +150 Mana', category: 'basic', hasActive: true },

            // === TIER 2 ITEMS ===
            powerboots: { name: 'Power Treads', cost: 900, icon: 'üëü', effect: 'multi', values: { speed: 0.08, damage: 10, attack_speed: 0.15 }, desc: '+Speed, +Dmg, +AS', category: 'tier2' },
            arcane: { name: 'Arcane Boots', cost: 1100, icon: 'üëû', effect: 'multi', values: { speed: 0.06, mana: 250, aura_mana_regen: 1 }, desc: '+Speed, +Mana, Aura: +1 MP/s', category: 'tier2' },
            phase: { name: 'Phase Boots', cost: 1000, icon: '‚ö°', effect: 'multi', values: { speed: 0.07, damage: 18, active_phase: true }, desc: '+Speed, +Dmg, Active: Phase', category: 'tier2', hasActive: true },
            broadsword: { name: 'Broadsword', cost: 1000, icon: '‚öîÔ∏è', effect: 'damage', value: 35, desc: '+35 Damage', category: 'tier2' },
            platemail: { name: 'Platemail', cost: 1000, icon: 'üõ°Ô∏è', effect: 'armor', value: 8, desc: '+8 Armor', category: 'tier2' },
            staffmana: { name: 'Staff of Wizardry', cost: 800, icon: 'ü™Ñ', effect: 'multi', values: { mana: 300, mana_regen: 3 }, desc: '+300 Mana, +3 MP/s', category: 'tier2' },
            vanguard: { name: 'Vanguard', cost: 1100, icon: 'üõ°Ô∏è', effect: 'multi', values: { hp: 300, armor: 5, block: 0.3 }, desc: '+HP, +Armor, 30% Block', category: 'tier2' },
            mask: { name: 'Mask of Death', cost: 800, icon: 'üé≠', effect: 'lifesteal', value: 0.15, desc: '15% Lifesteal', category: 'tier2' },
            forcestaff: { name: 'Force Staff', cost: 1400, icon: 'üîÆ', effect: 'active_force', cooldown: 18, desc: 'Active: Push target 8 units', category: 'tier2', hasActive: true },
            mekansm: { name: 'Mekansm', cost: 1500, icon: '‚öïÔ∏è', effect: 'active_heal_aoe', cooldown: 45, desc: 'Active: Heal 275 HP (AoE)', category: 'tier2', hasActive: true },
            crimsonguard: { name: 'Crimson Guard', cost: 1700, icon: 'üî¥', effect: 'multi', values: { hp: 350, armor: 6, block: 0.5 }, desc: '+HP, +Armor, 50% Block', category: 'tier2' },
            drum: { name: 'Drum of Endurance', cost: 1200, icon: 'ü•Å', effect: 'multi', values: { damage: 6, speed: 0.03, aura_attack_speed: 0.1 }, desc: '+Stats, Aura: +10% AS', category: 'tier2' },
            hood: { name: 'Hood of Defiance', cost: 1100, icon: 'üé≠', effect: 'multi', values: { magic_resist: 0.25, hp_regen: 4 }, desc: '+25% Magic Resist, +4 HP/s', category: 'tier2' },
            yasha: { name: 'Yasha', cost: 1500, icon: 'üåÄ', effect: 'multi', values: { damage: 15, attack_speed: 0.2, speed: 0.04 }, desc: '+Dmg, +AS, +Speed', category: 'tier2' },
            kaya: { name: 'Kaya', cost: 1500, icon: 'üîµ', effect: 'multi', values: { mana: 200, spell_amp: 0.1, mana_cost_reduce: 0.1 }, desc: '+Mana, +10% Spell Amp', category: 'tier2' },
            sange: { name: 'Sange', cost: 1500, icon: 'üî¥', effect: 'multi', values: { damage: 15, hp: 200, status_resist: 0.15 }, desc: '+Dmg, +HP, +Status Resist', category: 'tier2' },
            maelstrom: { name: 'Maelstrom', cost: 1700, icon: '‚ö°', effect: 'multi', values: { damage: 24, chain_lightning: 0.25 }, desc: '+Dmg, 25% Lightning Proc', category: 'tier2' },
            hyperstone: { name: 'Hyperstone', cost: 1800, icon: 'üí†', effect: 'attack_speed', value: 0.5, desc: '+50% Attack Speed', category: 'tier2' },
            mysticstaff: { name: 'Mystic Staff', cost: 2000, icon: 'üîØ', effect: 'multi', values: { mana: 500, mana_regen: 5 }, desc: '+500 Mana, +5 MP/s', category: 'tier2' },
            eaglehorn: { name: 'Eaglehorn', cost: 2200, icon: 'üèπ', effect: 'multi', values: { damage: 25, attack_speed: 0.25 }, desc: '+25 Dmg, +25% AS', category: 'tier2' },
            reaver: { name: 'Reaver', cost: 2200, icon: 'üó°Ô∏è', effect: 'multi', values: { damage: 30, hp: 300 }, desc: '+30 Dmg, +300 HP', category: 'tier2' },

            // === TIER 3 ITEMS (with actives) ===
            blink: { name: 'Blink Dagger', cost: 2000, icon: 'üó°Ô∏è', effect: 'active_blink', cooldown: 12, desc: 'Active: Blink 12 units', category: 'tier3', hasActive: true },
            bkb: { name: 'Black King Bar', cost: 2500, icon: 'üëë', effect: 'active_bkb', cooldown: 60, desc: 'Active: Magic Immunity 5s', category: 'tier3', hasActive: true },
            shadowblade: { name: 'Shadow Blade', cost: 2200, icon: 'üåë', effect: 'active_invis', cooldown: 20, desc: 'Active: Invisibility 4s', category: 'tier3', hasActive: true },
            desolator: { name: 'Desolator', cost: 2800, icon: '‚ö´', effect: 'multi', values: { damage: 50, armor_reduce: 5 }, desc: '+50 Dmg, -5 Enemy Armor', category: 'tier3' },
            satanic: { name: 'Satanic', cost: 3000, icon: 'üòà', effect: 'multi', values: { hp: 400, lifesteal: 0.25 }, desc: '+HP, 25% Lifesteal', category: 'tier3' },
            butterfly: { name: 'Butterfly', cost: 3500, icon: 'ü¶ã', effect: 'multi', values: { damage: 30, attack_speed: 0.35, evasion: 0.25 }, desc: '+Dmg, +AS, 25% Evasion', category: 'tier3' },
            daedalus: { name: 'Daedalus', cost: 3200, icon: 'üèπ', effect: 'multi', values: { damage: 80, crit_chance: 0.25, crit_mult: 0.75 }, desc: '+80 Dmg, 25% Crit', category: 'tier3' },
            heart: { name: 'Heart of Tarrasque', cost: 4000, icon: '‚ù§Ô∏è', effect: 'multi', values: { hp: 800, hp_regen: 10 }, desc: '+800 HP, +10 HP/s', category: 'tier3' },
            radiance: { name: 'Radiance', cost: 4500, icon: '‚òÄÔ∏è', effect: 'aura_damage', value: 40, desc: 'Burns enemies for 40 DPS', category: 'tier3' },
            divine: { name: 'Divine Rapier', cost: 5000, icon: '‚ö°', effect: 'damage', value: 300, desc: '+300 Damage (!)', category: 'tier3' },
            shivas: { name: "Shiva's Guard", cost: 3800, icon: '‚ùÑÔ∏è', effect: 'multi', values: { armor: 15, mana: 400, aura_slow: 0.15 }, desc: '+Armor, +Mana, Aura: Slow', category: 'tier3', hasActive: true },
            scythe: { name: 'Scythe of Vyse', cost: 4200, icon: 'üê∑', effect: 'active_hex', cooldown: 22, desc: 'Active: Hex enemy 3.5s', category: 'tier3', hasActive: true },
            orchid: { name: 'Orchid Malevolence', cost: 3200, icon: 'üå∫', effect: 'active_silence', cooldown: 18, desc: 'Active: Silence 5s, +30% Dmg', category: 'tier3', hasActive: true },
            abyssal: { name: 'Abyssal Blade', cost: 4500, icon: 'üî±', effect: 'multi', values: { damage: 55, hp: 300, stun_chance: 0.2 }, desc: '+Dmg, +HP, 20% Bash', category: 'tier3', hasActive: true },
            mjolnir: { name: 'Mjolnir', cost: 4200, icon: '‚ö°', effect: 'multi', values: { damage: 35, attack_speed: 0.5, chain_lightning: 0.3 }, desc: '+Dmg, +AS, 30% Lightning', category: 'tier3' },
            assault: { name: 'Assault Cuirass', cost: 4500, icon: 'üî©', effect: 'multi', values: { armor: 10, attack_speed: 0.3, aura_armor: 5 }, desc: '+Armor, +AS, Aura: +5 Armor', category: 'tier3' },
            linken: { name: "Linken's Sphere", cost: 3800, icon: 'üîÆ', effect: 'spellblock', cooldown: 12, desc: 'Block one targeted spell/12s', category: 'tier3' },
            skadi: { name: 'Eye of Skadi', cost: 4500, icon: 'üßä', effect: 'multi', values: { hp: 400, mana: 400, damage: 30, slow_attack: 0.3 }, desc: '+Stats, Attacks slow 30%', category: 'tier3' },
            nullifier: { name: 'Nullifier', cost: 3800, icon: '‚¨õ', effect: 'multi', values: { damage: 65, armor: 6, dispel: true }, desc: '+Dmg, +Armor, Dispels buffs', category: 'tier3', hasActive: true },
            silver: { name: 'Silver Edge', cost: 4000, icon: 'üåô', effect: 'multi', values: { damage: 50, attack_speed: 0.25, break: true }, desc: '+Dmg, +AS, Break passive', category: 'tier3', hasActive: true },

            // === TIER 4 ITEMS (Ultimate) ===
            bloodthorn: { name: 'Bloodthorn', cost: 5500, icon: 'üåπ', effect: 'multi', values: { damage: 70, attack_speed: 0.4, crit_chance: 0.2, silence_crit: true }, desc: '+Dmg, +AS, Crit on silenced', category: 'tier4', hasActive: true },
            octarine: { name: 'Octarine Core', cost: 5000, icon: 'üü£', effect: 'multi', values: { hp: 450, mana: 700, cooldown_reduce: 0.25, spell_lifesteal: 0.2 }, desc: '-25% CD, +20% Spell Lifesteal', category: 'tier4' },
            moonshard: { name: 'Moon Shard', cost: 4000, icon: 'üåô', effect: 'attack_speed', value: 0.8, desc: '+80% Attack Speed', category: 'tier4' },
            refresher: { name: 'Refresher Orb', cost: 5500, icon: 'üîÑ', effect: 'active_refresh', cooldown: 180, desc: 'Active: Reset all cooldowns', category: 'tier4', hasActive: true },
            aeon: { name: 'Aeon Disk', cost: 3500, icon: '‚≠ï', effect: 'active_combo_break', cooldown: 90, desc: 'Auto-dispel at <70% HP', category: 'tier4' },
            gleipnir: { name: 'Gleipnir', cost: 5000, icon: 'üï∏Ô∏è', effect: 'multi', values: { damage: 35, attack_speed: 0.4, chain_lightning: 0.35 }, desc: '+Dmg, +AS, Active: Root AoE', category: 'tier4', hasActive: true },
            overwhelming: { name: 'Overwhelming Blink', cost: 5500, icon: 'üí•', effect: 'active_blink_damage', cooldown: 15, desc: 'Blink + AoE slow & damage', category: 'tier4', hasActive: true },
            swift: { name: 'Swift Blink', cost: 5500, icon: 'üí®', effect: 'active_blink_as', cooldown: 15, desc: 'Blink + 40% AS for 5s', category: 'tier4', hasActive: true },
            arcane_blink: { name: 'Arcane Blink', cost: 5500, icon: 'üîÆ', effect: 'active_blink_cd', cooldown: 15, desc: 'Blink + 25% CD reduction 5s', category: 'tier4', hasActive: true },
            ethereal: { name: 'Ethereal Blade', cost: 4800, icon: 'üëª', effect: 'active_ethereal', cooldown: 20, desc: 'Target ethereal (no attack, +dmg)', category: 'tier4', hasActive: true },
            wind_waker: { name: 'Wind Waker', cost: 5500, icon: 'üå™Ô∏è', effect: 'active_tornado', cooldown: 30, desc: 'Active: Cyclone self or ally', category: 'tier4', hasActive: true }
        };

        // Item active ability cooldowns
        const itemCooldowns = {};

        let shopOpen = false;

        function toggleShop() {
            shopOpen = !shopOpen;
            const panel = document.getElementById('shop-panel');
            if (panel) {
                panel.style.display = shopOpen ? 'block' : 'none';
                if (shopOpen) renderShopItems();
            }
        }

        // ROUND 11: Help panel toggle
        let helpOpen = false;
        function toggleHelp() {
            helpOpen = !helpOpen;
            const panel = document.getElementById('help-panel');
            if (panel) {
                panel.style.display = helpOpen ? 'block' : 'none';
            }
        }

        function renderShopItems() {
            const container = document.getElementById('shop-items');
            if (!container || !player) return;

            container.innerHTML = '';
            for (const [id, item] of Object.entries(ITEMS)) {
                const canAfford = player.gold >= item.cost;
                const btn = document.createElement('button');
                btn.style.cssText = `
                    display:flex;align-items:center;gap:10px;padding:8px 12px;
                    background:${canAfford ? 'rgba(0,255,136,0.2)' : 'rgba(100,100,100,0.2)'};
                    border:1px solid ${canAfford ? '#00ff88' : '#555'};
                    border-radius:6px;cursor:${canAfford ? 'pointer' : 'not-allowed'};
                    color:${canAfford ? '#fff' : '#666'};font-size:12px;text-align:left;
                `;
                btn.innerHTML = `
                    <span style="font-size:20px;">${item.icon}</span>
                    <div style="flex:1;">
                        <div style="font-weight:600;">${item.name}</div>
                        <div style="font-size:10px;color:#8899aa;">${item.desc}</div>
                    </div>
                    <span style="color:#ffd700;font-weight:600;">${item.cost}g</span>
                `;
                // ROUND 10: Shift+click to add to quick-buy, regular click to buy
                btn.onclick = (e) => {
                    if (e.shiftKey) {
                        addToQuickBuy(id);
                    } else if (canAfford) {
                        buyItem(id);
                    }
                };
                container.appendChild(btn);
            }
        }

        // ROUND 10: Quick-buy system
        const quickBuyQueue = [];

        function addToQuickBuy(itemId) {
            const item = ITEMS[itemId];
            if (!item) return;

            quickBuyQueue.push(itemId);
            updateQuickBuyUI();
            showMessage(`Added ${item.name} to quick-buy`);
        }

        function updateQuickBuyUI() {
            const container = document.getElementById('quickbuy-items');
            const totalEl = document.getElementById('quickbuy-total');
            if (!container) return;

            container.innerHTML = '';
            let total = 0;

            quickBuyQueue.forEach((itemId, index) => {
                const item = ITEMS[itemId];
                if (!item) return;
                total += item.cost;

                const slot = document.createElement('div');
                slot.style.cssText = `
                    width:28px;height:28px;background:rgba(255,215,0,0.2);
                    border:1px solid #ffd700;border-radius:4px;display:flex;
                    align-items:center;justify-content:center;font-size:16px;
                    cursor:pointer;position:relative;
                `;
                slot.innerHTML = item.icon;
                slot.title = `${item.name} - ${item.cost}g (click to remove)`;
                slot.onclick = () => {
                    quickBuyQueue.splice(index, 1);
                    updateQuickBuyUI();
                };
                container.appendChild(slot);
            });

            if (totalEl) {
                totalEl.textContent = `${total}g`;
                totalEl.style.color = player && player.gold >= total ? '#00ff88' : '#ff3c3c';
            }
        }

        function buyQuickBuyItems() {
            if (!player || player.dead || quickBuyQueue.length === 0) return;

            let bought = 0;
            const itemsToBuy = [...quickBuyQueue]; // Copy array

            for (const itemId of itemsToBuy) {
                const item = ITEMS[itemId];
                if (item && player.gold >= item.cost) {
                    buyItem(itemId);
                    quickBuyQueue.splice(quickBuyQueue.indexOf(itemId), 1);
                    bought++;
                }
            }

            updateQuickBuyUI();

            if (bought > 0) {
                showMessage(`Bought ${bought} item${bought > 1 ? 's' : ''} from quick-buy!`);
            } else {
                showMessage('Not enough gold!');
                AudioManager.playError();
            }
        }

        function clearQuickBuy() {
            quickBuyQueue.length = 0;
            updateQuickBuyUI();
            showMessage('Quick-buy cleared');
        }

        function buyItem(itemId) {
            if (!player || player.dead) return;
            const item = ITEMS[itemId];
            if (!item || player.gold < item.cost) return;

            player.gold -= item.cost;
            applyItemEffect(item);

            // ROUND 9: Play purchase sound
            AudioManager.playPurchase();

            // Add to inventory display
            player.inventory = player.inventory || [];
            if (item.effect !== 'heal') { // Consumables don't go to inventory
                player.inventory.push(itemId);
                updateInventoryUI();
            }

            renderShopItems(); // Refresh shop
            showMessage(`Purchased ${item.name}!`);
        }

        function applyItemEffect(item) {
            if (!player) return;

            // Handle multi-effect items
            if (item.effect === 'multi' && item.values) {
                for (const [key, val] of Object.entries(item.values)) {
                    applySingleEffect(key, val);
                }
                return;
            }

            // Handle active items (just store, don't apply passive)
            if (item.hasActive) {
                player.activeItems = player.activeItems || [];
                player.activeItems.push(item);
                return;
            }

            // Handle single effect
            applySingleEffect(item.effect, item.value);
        }

        function applySingleEffect(effect, value) {
            if (!player) return;

            switch (effect) {
                case 'heal':
                    player.hp = Math.min(player.hp + value, player.maxHp);
                    createExplosion(player.mesh.position, 0x00ff00, 15);
                    break;
                case 'mana_restore':
                    player.mp = Math.min(player.mp + value, player.maxMp);
                    createExplosion(player.mesh.position, 0x0088ff, 15);
                    break;
                case 'heal_both':
                    player.hp = Math.min(player.hp + value, player.maxHp);
                    player.mp = Math.min(player.mp + value, player.maxMp);
                    createExplosion(player.mesh.position, 0x88ff88, 15);
                    break;
                case 'speed':
                    player.speed += value;
                    break;
                case 'damage':
                    player.damage += value;
                    player.updateLevelUI();
                    break;
                case 'armor':
                    player.armor += value;
                    player.updateLevelUI();
                    break;
                case 'mana':
                    player.maxMp += value;
                    player.mp += value;
                    break;
                case 'hp':
                    player.maxHp += value;
                    player.hp += value;
                    break;
                case 'magic_resist':
                    player.magicResist = (player.magicResist || 0) + value;
                    break;
                case 'attack_speed':
                    player.attackSpeed = (player.attackSpeed || 1) * (1 + value);
                    break;
                case 'mana_regen':
                    player.manaRegen = (player.manaRegen || 0) + value;
                    break;
                case 'hp_regen':
                    player.hpRegen = (player.hpRegen || 0) + value;
                    break;
                case 'lifesteal':
                    player.lifesteal = (player.lifesteal || 0) + value;
                    break;
                case 'evasion':
                    player.evasion = (player.evasion || 0) + value;
                    break;
                case 'block':
                    player.blockChance = (player.blockChance || 0) + value;
                    break;
                case 'crit_chance':
                    player.critChance = (player.critChance || 0) + value;
                    break;
                case 'crit_mult':
                    player.critMultiplier = (player.critMultiplier || 2) + value;
                    break;
                case 'armor_reduce':
                    player.armorReduction = (player.armorReduction || 0) + value;
                    break;
                case 'aura_damage':
                    player.radianceAura = value;
                    break;
                case 'spell_amp':
                    player.spellAmp = (player.spellAmp || 1) + value;
                    break;
                case 'cooldown_reduce':
                    player.cooldownMultiplier = (player.cooldownMultiplier || 1) * (1 - value);
                    break;
                case 'mana_cost_reduce':
                    player.manaCostMultiplier = (player.manaCostMultiplier || 1) * (1 - value);
                    break;
                case 'status_resist':
                    player.statusResist = (player.statusResist || 0) + value;
                    break;
                case 'chain_lightning':
                    player.chainLightningChance = (player.chainLightningChance || 0) + value;
                    break;
                case 'poison_attack':
                    player.poisonDPS = (player.poisonDPS || 0) + value;
                    break;
                case 'slow_attack':
                    player.attackSlow = (player.attackSlow || 0) + value;
                    break;
                case 'aura_armor':
                    player.auraArmor = (player.auraArmor || 0) + value;
                    break;
                case 'aura_attack_speed':
                    player.auraAttackSpeed = (player.auraAttackSpeed || 0) + value;
                    break;
                case 'aura_mana_regen':
                    player.auraManaRegen = (player.auraManaRegen || 0) + value;
                    break;
                case 'aura_hp_regen':
                    player.auraHpRegen = (player.auraHpRegen || 0) + value;
                    break;
                case 'aura_slow':
                    player.auraSlow = (player.auraSlow || 0) + value;
                    break;
                case 'stun_chance':
                    player.bashChance = (player.bashChance || 0) + value;
                    break;
                case 'spell_lifesteal':
                    player.spellLifesteal = (player.spellLifesteal || 0) + value;
                    break;
                case 'heal_instant':
                    player.hp = Math.min(player.hp + value, player.maxHp);
                    createExplosion(player.mesh.position, 0xffff00, 10);
                    break;
                case 'heal_over_time':
                    // Apply heal over time effect
                    const hotValue = value;
                    let hotTicks = 0;
                    const hotInterval = setInterval(() => {
                        if (player.dead || hotTicks >= 10) {
                            clearInterval(hotInterval);
                            return;
                        }
                        player.hp = Math.min(player.hp + hotValue / 10, player.maxHp);
                        hotTicks++;
                    }, 1000);
                    break;
            }
        }

        // Use active item (1-6 keys)
        function useActiveItem(slot) {
            if (!player || !player.activeItems || !player.activeItems[slot]) return;

            const item = player.activeItems[slot];
            const cooldownKey = `item_${slot}`;

            if (itemCooldowns[cooldownKey] && itemCooldowns[cooldownKey] > 0) {
                showMessage('Item on cooldown!');
                return;
            }

            switch (item.effect) {
                case 'active_blink':
                    player.performBlink(12, 0xffaa00);
                    break;
                case 'active_bkb':
                    player.magicImmune = true;
                    createShield(player, 0);
                    setTimeout(() => { player.magicImmune = false; }, 5000);
                    break;
                case 'active_invis':
                    player.invisible = true;
                    player.mesh.visible = false;
                    setTimeout(() => {
                        player.invisible = false;
                        player.mesh.visible = true;
                    }, 4000);
                    break;
            }

            itemCooldowns[cooldownKey] = item.cooldown;
            showMessage(`Used ${item.name}!`);
        }

        // ROUND 10: Use item from inventory by itemId
        function useItemActive(itemId, item) {
            if (!player || !item.hasActive) return;

            const cooldownKey = `inv_${itemId}`;

            if (itemCooldowns[cooldownKey] && itemCooldowns[cooldownKey] > 0) {
                showMessage('Item on cooldown!');
                AudioManager.playError();
                return;
            }

            switch (item.effect) {
                case 'active_blink':
                    player.performBlink(12, 0xffaa00);
                    AudioManager.playAbility('blink');
                    break;
                case 'active_bkb':
                    player.magicImmune = true;
                    createShield(player, 0);
                    AudioManager.playAbility('buff');
                    setTimeout(() => { player.magicImmune = false; }, 5000);
                    break;
                case 'active_invis':
                    player.invisible = true;
                    player.mesh.visible = false;
                    AudioManager.playAbility('shadow');
                    setTimeout(() => {
                        player.invisible = false;
                        player.mesh.visible = true;
                    }, 4000);
                    break;
                case 'place_ward':
                    placeWard(player.mesh.position, item.wardType);
                    // Remove ward from inventory after use
                    const idx = player.inventory.indexOf(itemId);
                    if (idx > -1) player.inventory.splice(idx, 1);
                    updateInventoryUI();
                    break;
            }

            if (item.cooldown) {
                itemCooldowns[cooldownKey] = item.cooldown;
            }
            showMessage(`Used ${item.name}!`);
        }

        // ROUND 10: Ward System
        const placedWards = [];

        function placeWard(position, type) {
            const wardColor = type === 'observer' ? 0x00ff88 : 0xff00ff;
            const wardDuration = type === 'observer' ? 300000 : 240000; // 5min / 4min
            const visionRadius = type === 'observer' ? 15 : 8;

            // Create ward mesh
            const wardGroup = new THREE.Group();

            // Ward stake
            const stake = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.1, 0.8, 8),
                new THREE.MeshStandardMaterial({ color: 0x664422 })
            );
            stake.position.y = 0.4;
            wardGroup.add(stake);

            // Ward crystal/eye
            const crystal = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.2),
                new THREE.MeshBasicMaterial({
                    color: wardColor,
                    transparent: true,
                    opacity: 0.8
                })
            );
            crystal.position.y = 0.9;
            wardGroup.add(crystal);

            // Vision ring (ground indicator)
            const visionRing = new THREE.Mesh(
                new THREE.RingGeometry(visionRadius - 0.2, visionRadius, 32),
                new THREE.MeshBasicMaterial({
                    color: wardColor,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                })
            );
            visionRing.rotation.x = -Math.PI / 2;
            visionRing.position.y = 0.05;
            wardGroup.add(visionRing);

            wardGroup.position.copy(position);
            scene.add(wardGroup);

            const ward = {
                type,
                position: position.clone(),
                group: wardGroup,
                crystal,
                visionRadius,
                team: player.team,
                createdAt: Date.now()
            };
            placedWards.push(ward);

            // Animate crystal rotation
            const animateWard = () => {
                if (!ward.group.parent) return;
                crystal.rotation.y += 0.02;
                crystal.position.y = 0.9 + Math.sin(Date.now() * 0.003) * 0.05;
                requestAnimationFrame(animateWard);
            };
            animateWard();

            // Remove ward after duration
            setTimeout(() => {
                scene.remove(wardGroup);
                const idx = placedWards.indexOf(ward);
                if (idx > -1) placedWards.splice(idx, 1);
                showMessage(`${type === 'observer' ? 'Observer' : 'Sentry'} ward expired`);
            }, wardDuration);

            // Play sound
            AudioManager.playUI();
            showMessage(`Placed ${type === 'observer' ? 'Observer' : 'Sentry'} Ward`);
        }

        // Draw wards on minimap
        function drawWardsOnMinimap(ctx, mapToScreen) {
            placedWards.forEach(ward => {
                const x = mapToScreen(ward.position.x);
                const z = mapToScreen(ward.position.z);

                // Ward icon
                ctx.fillStyle = ward.type === 'observer' ? '#00ff88' : '#ff00ff';
                ctx.beginPath();
                ctx.arc(x, z, 4, 0, Math.PI * 2);
                ctx.fill();

                // Vision radius indicator
                ctx.strokeStyle = ward.type === 'observer' ? 'rgba(0,255,136,0.2)' : 'rgba(255,0,255,0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                const radius = ward.visionRadius * 2.2; // Convert to minimap scale
                ctx.arc(x, z, radius, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function updateInventoryUI() {
            const container = document.getElementById('inventory-panel');
            if (!container || !player) return;

            container.innerHTML = '';
            (player.inventory || []).forEach(itemId => {
                const item = ITEMS[itemId];
                if (!item) return;
                const slot = document.createElement('div');
                slot.style.cssText = `
                    width:28px;height:28px;background:rgba(20,20,30,0.8);
                    border:1px solid #444;border-radius:4px;display:flex;
                    align-items:center;justify-content:center;font-size:16px;
                `;
                slot.textContent = item.icon;
                slot.title = item.name;
                container.appendChild(slot);
            });
        }

        // ROUND 2: Screen Shake System
        const screenShake = {
            intensity: 0,
            decay: 0.9,
            maxOffset: { x: 0, y: 0 },

            shake(amount, duration = 0.3) {
                this.intensity = Math.min(this.intensity + amount, 1.0);
                this.decay = Math.pow(0.01, 1 / (duration * 60));
            },

            update() {
                if (this.intensity > 0.01) {
                    const shakeAmount = this.intensity * 1.5;
                    this.maxOffset.x = (Math.random() - 0.5) * shakeAmount;
                    this.maxOffset.y = (Math.random() - 0.5) * shakeAmount * 0.5;
                    this.intensity *= this.decay;
                } else {
                    this.maxOffset.x = 0;
                    this.maxOffset.y = 0;
                    this.intensity = 0;
                }
                return this.maxOffset;
            },

            light() { this.shake(0.2, 0.15); },
            medium() { this.shake(0.4, 0.25); },
            heavy() { this.shake(0.7, 0.4); }
        };

        // ==========================================
        // CONSENSUS FEATURE 1: Hit-Stop System (FIXED R2)
        // Uses manual timeScale since THREE.Clock lacks it
        // ==========================================
        let gameTimeScale = 1.0; // Global time scale factor

        const HitStop = {
            active: false,
            duration: 0,
            realTimeElapsed: 0,

            // Trigger a hit-stop freeze frame
            trigger(ms = 50) {
                if (this.active) return;
                this.active = true;
                this.duration = ms;
                this.realTimeElapsed = 0;
                // Apply slow-motion via global timeScale
                gameTimeScale = 0.05;
            },

            // Trigger with screen shake for heavy impacts
            heavyHit(ms = 80) {
                this.trigger(ms);
                screenShake.heavy();
            },

            // Light hit for regular attacks
            lightHit(ms = 30) {
                this.trigger(ms);
                screenShake.light();
            },

            // Update using real time (not scaled dt)
            update(realDt) {
                if (!this.active) return;
                // Use real delta time to count down
                this.realTimeElapsed += realDt * 1000;
                if (this.realTimeElapsed >= this.duration) {
                    this.active = false;
                    gameTimeScale = 1.0; // Restore normal speed
                }
            },

            // Get current time scale for game loop
            getTimeScale() {
                return this.active ? gameTimeScale : 1.0;
            }
        };

        // ==========================================
        // CONSENSUS FEATURE 2: Timer Registry
        // Track all timeouts/intervals for cleanup
        // ==========================================
        const TimerRegistry = {
            timeouts: new Map(),
            intervals: new Map(),
            nextId: 0,

            // Tracked setTimeout
            setTimeout(callback, delay, context = 'global') {
                const id = this.nextId++;
                const timerId = window.setTimeout(() => {
                    callback();
                    this.timeouts.delete(id);
                }, delay);
                this.timeouts.set(id, { timerId, context });
                return id;
            },

            // Tracked setInterval
            setInterval(callback, delay, context = 'global') {
                const id = this.nextId++;
                const intervalId = window.setInterval(callback, delay);
                this.intervals.set(id, { intervalId, context });
                return id;
            },

            // Clear a specific timeout
            clearTimeout(id) {
                const entry = this.timeouts.get(id);
                if (entry) {
                    window.clearTimeout(entry.timerId);
                    this.timeouts.delete(id);
                }
            },

            // Clear a specific interval
            clearInterval(id) {
                const entry = this.intervals.get(id);
                if (entry) {
                    window.clearInterval(entry.intervalId);
                    this.intervals.delete(id);
                }
            },

            // Clear all timers for a specific entity/context
            clearForContext(context) {
                for (const [id, entry] of this.timeouts) {
                    if (entry.context === context) {
                        window.clearTimeout(entry.timerId);
                        this.timeouts.delete(id);
                    }
                }
                for (const [id, entry] of this.intervals) {
                    if (entry.context === context) {
                        window.clearInterval(entry.intervalId);
                        this.intervals.delete(id);
                    }
                }
            },

            // Clear all timers (on game end)
            clearAll() {
                for (const [, entry] of this.timeouts) {
                    window.clearTimeout(entry.timerId);
                }
                for (const [, entry] of this.intervals) {
                    window.clearInterval(entry.intervalId);
                }
                this.timeouts.clear();
                this.intervals.clear();
            },

            // Get count for debugging
            getStats() {
                return {
                    timeouts: this.timeouts.size,
                    intervals: this.intervals.size
                };
            }
        };

        function togglePause() {
            if (gameState === 'victory' || gameState === 'defeat') return;
            if (gameState === 'paused') {
                gameState = 'playing';
                clock.start();
                document.getElementById('pause-overlay').style.display = 'none';
            } else {
                gameState = 'paused';
                clock.stop();
                document.getElementById('pause-overlay').style.display = 'flex';
            }
        }

        function checkWinConditions() {
            if (gameState !== 'playing') return;

            if (direBase && direBase.dead) {
                endGame('victory');
            } else if (radiantBase && radiantBase.dead) {
                // ROUND 4: Actually trigger defeat when base is destroyed!
                endGame('defeat');
            }
            // Note: Player death triggers respawn (handled in die() method), not immediate defeat
        }

        function endGame(result) {
            gameState = result;
            saveMatchResult();

            // Play victory or defeat sound
            if (result === 'victory') {
                AudioManager.playVictory();
            } else {
                AudioManager.playDefeat();
            }

            // ROUND 4: Clear intervals to prevent memory leaks
            if (spawnIntervalId) { clearInterval(spawnIntervalId); spawnIntervalId = null; }
            if (cleanupIntervalId) { clearInterval(cleanupIntervalId); cleanupIntervalId = null; }

            // CONSENSUS: Clear all tracked timers
            TimerRegistry.clearAll();

            // CONSENSUS: Dispose explosion pool
            ExplosionPool.dispose();

            const overlay = document.createElement('div');
            overlay.id = 'game-over-overlay';
            overlay.style.cssText = `
                position:fixed;top:0;left:0;right:0;bottom:0;
                background:rgba(0,0,0,0.9);display:flex;flex-direction:column;
                justify-content:center;align-items:center;z-index:500;
            `;
            overlay.innerHTML = `
                <h1 style="font-family:var(--font-display);font-size:64px;margin:0;
                    color:${result === 'victory' ? '#00ff88' : '#ff3c3c'};
                    text-shadow:0 0 30px currentColor;">
                    ${result === 'victory' ? 'VICTORY' : 'DEFEAT'}
                </h1>
                <p style="color:#8899aa;font-size:20px;margin:20px 0;">
                    Time: ${document.getElementById('game-time').textContent} |
                    Score: ${score.radiant} - ${score.dire}
                </p>
                <button onclick="location.reload()" style="
                    padding:15px 40px;font-size:18px;background:var(--accent-radiant);
                    border:none;border-radius:8px;cursor:pointer;color:#000;font-weight:600;
                    margin-top:20px;">
                    Play Again
                </button>
            `;
            document.body.appendChild(overlay);
        }

        function respawnHero() {
            if (!player) return;
            isRespawning = false;
            player.dead = false;
            player.hp = player.maxHp;
            player.mp = player.maxMp;

            player.mesh.position.set(-40, 0, -40);
            player.targetPos.set(-40, 0, -40);
            scene.add(player.mesh);

            // Reset cooldowns
            for (let key in player.abilities) {
                player.abilities[key].currentCd = 0;
            }

            showMessage('Hero Respawned!');
            AudioManager.playRespawn();
            document.getElementById('respawn-timer').style.display = 'none';
        }

        // Visuals
        let floatingTexts = [];

        // --- CLASSES ---

        class FloatingText {
            constructor(text, x, y, z, color) {
                this.element = document.createElement('div');
                this.element.textContent = text;
                this.element.className = 'damage-number';
                this.element.style.color = color;
                document.body.appendChild(this.element);

                // Project 3D pos to 2D
                this.pos = new THREE.Vector3(x, y + 2, z);
                this.updatePosition();

                // Cleanup
                setTimeout(() => {
                    if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
                    const index = floatingTexts.indexOf(this);
                    if (index > -1) floatingTexts.splice(index, 1);
                }, 1000);
            }

            updatePosition() {
                const tempV = this.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * window.innerWidth;
                const y = (tempV.y * -.5 + .5) * window.innerHeight;
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
            }
        }

        class GameEntity {
            constructor(x, z, team, color) {
                this.team = team;
                this.color = color;
                this.hp = 100;
                this.maxHp = 100;
                this.dead = false;

                // ROUND 7: Combat stats
                this.armor = 0;          // Reduces physical damage
                this.attackSpeed = 1.0;  // Multiplier for attack cooldown
                this.damage = 10;        // Base damage
                this.critChance = 0;     // Chance to deal critical hit (0-1)
                this.critMultiplier = 2; // Damage multiplier on crit

                // Mesh
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);

                // ROUND 5: Add floating health bar above entity
                this.createHealthBar();

                // Physics
                this.targetPos = new THREE.Vector3(x, 0, z);
                this.speed = 0.1;
                this.radius = 0.5;
            }

            // ROUND 5: Create health bar above entity
            createHealthBar() {
                const barWidth = 1.2;
                const barHeight = 0.12;

                // Background (dark)
                const bgGeo = new THREE.PlaneGeometry(barWidth, barHeight);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
                this.healthBarBg = new THREE.Mesh(bgGeo, bgMat);
                this.healthBarBg.position.set(0, 2.5, 0);
                this.healthBarBg.rotation.x = -0.3; // Tilt towards camera
                this.mesh.add(this.healthBarBg);

                // Foreground (team colored)
                const fgGeo = new THREE.PlaneGeometry(barWidth * 0.98, barHeight * 0.7);
                const fgMat = new THREE.MeshBasicMaterial({
                    color: this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c,
                    side: THREE.DoubleSide
                });
                this.healthBarFg = new THREE.Mesh(fgGeo, fgMat);
                this.healthBarFg.position.set(0, 2.5, 0.01);
                this.healthBarFg.rotation.x = -0.3;
                this.mesh.add(this.healthBarFg);
            }

            // ROUND 5: Update health bar scale based on current HP
            updateHealthBar() {
                if (!this.healthBarFg) return;
                const ratio = Math.max(0, this.hp / this.maxHp);
                this.healthBarFg.scale.x = ratio;
                // Offset to keep bar left-aligned
                this.healthBarFg.position.x = -(1 - ratio) * 0.6;
            }

            // ROUND 7: Attack with crit chance - returns actual damage dealt
            performAttack(target, baseDamage = null) {
                if (!target || target.dead) return 0;

                let dmg = baseDamage || this.damage;
                let isCrit = false;

                // Roll for crit
                if (this.critChance > 0 && Math.random() < this.critChance) {
                    dmg *= this.critMultiplier;
                    isCrit = true;
                }

                target.takeDamage(dmg, isCrit ? 'crit' : 'physical', this);

                // R3: Show attack slash VFX - color based on crit or team
                if (typeof createSlashEffect === 'function') {
                    const slashColor = isCrit ? 0xffff00 :
                        (this.team === TEAM_RADIANT ? 0x00ffff : 0xff4444);
                    createSlashEffect(this, target, slashColor);
                }

                // ROUND 10: Track damage dealt for match stats
                if (this === player && typeof matchStats !== 'undefined') {
                    matchStats.trackDamageDealt(dmg);
                }

                return dmg;
            }

            // ROUND 7: Get attack interval based on attackSpeed
            getAttackInterval() {
                const baseInterval = 1.5; // seconds
                return baseInterval / this.attackSpeed;
            }

            update(dt) {
                if (this.dead) return;

                // Movement
                const dist = this.mesh.position.distanceTo(this.targetPos);
                if (dist > 0.1) {
                    // R3: Use VecPool instead of .clone() to reduce GC pressure
                    const dir = VecPool.get();
                    dir.copy(this.targetPos).sub(this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(this.speed));
                    this.mesh.lookAt(this.targetPos);

                    // Walk wobble
                    if (this.bodyMesh) {
                        this.bodyMesh.position.y = 0.5 + Math.sin(clock.getElapsedTime() * 10) * 0.05;
                    }
                }

                // ROUND 5: Update health bar
                this.updateHealthBar();
            }

            takeDamage(amt, type = 'physical', attacker = null) {
                // Track last attacker for kill feed
                if (attacker) this.lastAttacker = attacker;

                // ROUND 3: Play hit sound
                AudioManager.playHit(type);

                // ROUND 7: Apply armor reduction for physical damage
                // Formula: finalDamage = damage * (1 - armor * 0.06), min 20% damage
                if (type === 'physical' && this.armor > 0) {
                    const reduction = Math.min(0.8, this.armor * 0.06); // Cap at 80% reduction
                    amt = Math.max(1, amt * (1 - reduction));
                }

                // ROUND 3: Shield absorbs damage first
                if (this.shieldActive && this.shieldHealth > 0) {
                    const absorbed = Math.min(amt, this.shieldHealth);
                    this.shieldHealth -= absorbed;
                    amt -= absorbed;
                    spawnFloatingText(absorbed, this.mesh.position, '#00ff00'); // Green for shield

                    // Shield broken?
                    if (this.shieldHealth <= 0) {
                        this.shieldActive = false;
                        if (this.shieldMesh && this.mesh) {
                            this.mesh.remove(this.shieldMesh);
                        }
                        this.shieldMesh = null;
                        if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
                        showMessage('Shield Broken!');
                    }

                    if (amt <= 0) return; // All damage absorbed
                }

                this.hp -= amt;
                spawnFloatingText(amt, this.mesh.position, type === 'crit' ? '#ff3c3c' : '#fff');

                // CONSENSUS: Hit-stop for impactful hits
                if (type === 'crit' || amt > 100) {
                    HitStop.heavyHit(60);
                } else if (amt > 50) {
                    HitStop.lightHit(25);
                }

                // ROUND 2: Screen shake on damage
                if (this === player) {
                    screenShake.light();
                    // ROUND 10: Track damage taken for match stats
                    if (typeof matchStats !== 'undefined') {
                        matchStats.trackDamageTaken(amt);
                    }
                }

                // Flash
                if (this.bodyMesh) {
                    const oldInfo = this.bodyMesh.material.emissive.getHex();
                    this.bodyMesh.material.emissive.setHex(0xffffff);
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissive.setHex(oldInfo);
                    }, 100);
                }

                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                this.dead = true;

                // ROUND 6: Clear shield state on death
                if (this.shieldTimeout) {
                    clearTimeout(this.shieldTimeout);
                    this.shieldTimeout = null;
                }
                this.shieldActive = false;
                this.shieldHealth = 0;
                this.shieldMesh = null;

                // R4: Clear rune effect timers to prevent memory leaks
                if (this.invisTimeout) {
                    clearTimeout(this.invisTimeout);
                    this.invisTimeout = null;
                }
                if (this.arcaneTimeout) {
                    clearTimeout(this.arcaneTimeout);
                    this.arcaneTimeout = null;
                }
                if (this.regenInterval) {
                    clearInterval(this.regenInterval);
                    this.regenInterval = null;
                }
                // Reset rune effects
                this.isInvisible = false;
                this.cooldownMultiplier = 1;

                // ROUND 10: Enhanced death visual effect
                const deathPos = this.mesh.position.clone();
                const deathColor = this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c;
                const isHeroDeath = this instanceof Hero;
                if (typeof createDeathEffect !== 'undefined') {
                    createDeathEffect(deathPos, deathColor, isHeroDeath);
                }

                scene.remove(this.mesh);

                // Play death sound based on entity type
                if (this instanceof Structure) {
                    AudioManager.playDeath('structure');
                } else if (this instanceof Hero) {
                    AudioManager.playDeath('hero');
                } else {
                    AudioManager.playDeath('creep');
                }

                // Kill feed for heroes and structures
                if (this instanceof Hero || this instanceof Structure) {
                    const killerName = this.lastAttacker ?
                        (this.lastAttacker.heroType ? HERO_DEFS[this.lastAttacker.heroType]?.name || 'Hero' :
                         this.lastAttacker.type === 'tower' ? 'Tower' :
                         this.lastAttacker.type === 'base' ? 'Base' : 'Enemy') : 'Environment';
                    const victimName = this instanceof Hero ?
                        (this.heroType ? HERO_DEFS[this.heroType]?.name || 'Hero' : 'Hero') :
                        (this.type === 'tower' ? 'Tower' : 'Base');
                    const killerTeam = this.lastAttacker ? this.lastAttacker.team : (this.team === TEAM_RADIANT ? TEAM_DIRE : TEAM_RADIANT);

                    if (typeof killFeed !== 'undefined') {
                        killFeed.add(killerName, victimName, killerTeam);
                    }
                }

                if (this.team === TEAM_RADIANT) score.dire++;
                else score.radiant++;
                updateScoreBoard();

                // ROUND 2: Player respawn system
                if (this === player) {
                    isRespawning = true;
                    respawnTimer = Math.min(30, 5 + Math.floor(gameTime / 60) * 3); // 5s base + 3s per minute, max 30s
                    showMessage(`Respawning in ${respawnTimer}s`);
                    document.getElementById('respawn-timer').style.display = 'block';
                }
            }
        }

        class Hero extends GameEntity {
            constructor(x, z, team, heroType = 'voidwalker') {
                // Get hero definition
                const heroDef = HERO_DEFS[heroType] || HERO_DEFS.voidwalker;
                const heroColor = heroDef.color;

                super(x, z, team, heroColor);
                this.heroType = heroType;
                this.heroDef = heroDef;

                // Use hero-specific stats
                this.hp = heroDef.stats.hp;
                this.maxHp = heroDef.stats.hp;
                this.mp = heroDef.stats.mp;
                this.maxMp = heroDef.stats.mp;
                this.speed = heroDef.stats.speed;

                // Combat stats from hero definition
                this.damage = heroDef.stats.damage;
                this.armor = heroDef.stats.armor;
                this.critChance = heroDef.stats.critChance;
                this.critMultiplier = 2.0;
                this.attackSpeed = 1.2;

                // Leveling system
                this.level = 1;
                this.xp = 0;
                this.xpToLevel = 100;
                this.lastAttack = 0;

                // Gold system
                this.gold = 600; // Starting gold for items

                // Build detailed 3D model from HERO_MODELS
                const modelDef = HERO_MODELS[heroType] || HERO_MODELS.voidwalker;
                this.modelGroup = buildModel(modelDef);
                this.mesh.add(this.modelGroup);

                // Store reference to main body mesh for animations
                this.bodyMesh = this.modelGroup.children.find(c => c.name === 'torso') || this.modelGroup.children[0];

                // Pointer Ring with hero color
                const ringGeo = new THREE.RingGeometry(0.8, 0.9, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: heroColor, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.ring.rotation.x = -Math.PI / 2;
                this.ring.position.y = 0.05;
                this.mesh.add(this.ring);

                // Register for animations
                AnimationSystem.register(this, 'hero');

                // Movement tracking for animations
                this.isMoving = false;
                this.lastPosition = new THREE.Vector3(x, 0, z);

                // Setup abilities from hero definition
                this.abilities = {
                    q: { cd: heroDef.abilities.q.cd, currentCd: 0, cost: heroDef.abilities.q.cost },
                    w: { cd: heroDef.abilities.w.cd, currentCd: 0, cost: heroDef.abilities.w.cost },
                    e: { cd: heroDef.abilities.e.cd, currentCd: 0, cost: heroDef.abilities.e.cost },
                    r: { cd: heroDef.abilities.r.cd, currentCd: 0, cost: heroDef.abilities.r.cost }
                };
            }

            // ROUND 7: Add XP from kill
            gainXP(amount) {
                this.xp += amount;

                // Check for level up
                while (this.xp >= this.xpToLevel && this.level < 25) {
                    this.xp -= this.xpToLevel;
                    this.levelUp();
                }
            }

            // ROUND 7: Level up with stat growth
            levelUp() {
                this.level++;

                // Stat growth per level
                this.maxHp += 100;
                this.hp = Math.min(this.hp + 100, this.maxHp);
                this.maxMp += 50;
                this.mp = Math.min(this.mp + 50, this.maxMp);
                this.damage += 5;
                this.armor += 0.5;

                // R2 FIX: Linear XP curve (was exponential, made late-game impossible)
                // New curve: 100, 175, 250, 325... (+75 per level)
                this.xpToLevel = 100 + (this.level - 1) * 75;

                // Visual feedback
                showMessage(`LEVEL UP! Now Level ${this.level}`);
                createExplosion(this.mesh.position, 0xffd700, 30);
                // ROUND 10: Enhanced level up celebration particles
                if (typeof createLevelUpEffect !== 'undefined') {
                    createLevelUpEffect(this);
                }
                screenShake.medium();
                AudioManager.playLevelUp(); // ROUND 9: Level up sound

                // Update UI
                this.updateLevelUI();
            }

            updateLevelUI() {
                const levelEl = document.querySelector('.unit-level');
                if (levelEl) levelEl.textContent = `Lvl ${this.level}`;
                const dmgEl = document.getElementById('stat-dmg');
                if (dmgEl) dmgEl.textContent = Math.floor(this.damage);
                const armorEl = document.getElementById('stat-armor');
                if (armorEl) armorEl.textContent = this.armor.toFixed(1);
            }

            update(dt) {
                super.update(dt);
                // Mana regen
                if (this.mp < this.maxMp) this.mp += 0.2;

                // Update CD
                for (let key in this.abilities) {
                    if (this.abilities[key].currentCd > 0) {
                        this.abilities[key].currentCd -= dt;
                        updateCooldownUI(key, this.abilities[key].currentCd, this.abilities[key].cd);
                    }
                }

                // ROUND 7: Auto-attack nearby enemies
                const now = clock.getElapsedTime();
                if (now - this.lastAttack > this.getAttackInterval()) {
                    let nearestEnemy = null;
                    let minDist = 3; // Attack range

                    entities.forEach(e => {
                        if (e.team !== this.team && !e.dead && e.mesh) {
                            const d = this.mesh.position.distanceTo(e.mesh.position);
                            if (d < minDist) {
                                minDist = d;
                                nearestEnemy = e;
                            }
                        }
                    });

                    if (nearestEnemy) {
                        this.performAttack(nearestEnemy);
                        this.lastAttack = now;

                        // Weapon swing animation
                        if (this.weapon) {
                            this.weapon.rotation.x = -0.5;
                            setTimeout(() => {
                                if (this.weapon) this.weapon.rotation.x = 0;
                            }, 100);
                        }
                    }
                }

                updateHeroUI();

                // Update Floating Portrait
                if (portraitMesh) {
                    portraitMesh.rotation.y += 0.01;
                }
            }

            cast(key) {
                const ab = this.abilities[key];

                // ROUND 5: Failed cast feedback
                if (ab.currentCd > 0) {
                    AudioManager.playError();
                    flashAbilityError(key);
                    return;
                }
                if (this.mp < ab.cost) {
                    AudioManager.playError();
                    flashAbilityError(key);
                    showMessage('Not Enough Mana');
                    return;
                }

                this.mp -= ab.cost;

                // ROUND 8: Cooldown reduction at key levels (6, 12, 18)
                let cdMultiplier = 1.0;
                if (this.level >= 18) cdMultiplier = 0.7;
                else if (this.level >= 12) cdMultiplier = 0.8;
                else if (this.level >= 6) cdMultiplier = 0.9;
                ab.currentCd = ab.cd * cdMultiplier;

                // ROUND 3: Play cast sound
                AudioManager.playCast(key);

                // Trigger cast animation
                if (typeof AnimationSystem !== 'undefined') {
                    AnimationSystem.triggerCast(this);
                }

                // Ability power scaling with level (10% per level)
                const levelBonus = 1 + (this.level - 1) * 0.1;

                // Hero-specific ability implementations
                this.executeHeroAbility(key, levelBonus);

                // ROUND 10: Track ability use for match stats
                if (this === player && typeof matchStats !== 'undefined') {
                    matchStats.trackAbilityUse();
                }
            }

            executeHeroAbility(key, levelBonus) {
                const heroType = this.heroType;
                const pos = this.mesh.position.clone();
                const MAP_BOUNDARY = 48;

                // === VOID WALKER ABILITIES ===
                if (heroType === 'voidwalker') {
                    if (key === 'q') {
                        // Void Bolt - Energy projectile that burns mana
                        createProjectile(pos, mouse, Math.floor(80 * levelBonus), 0x00ff88);
                    }
                    if (key === 'w') {
                        // Blink - Short range teleport
                        this.performBlink(8, 0x00ffff);
                    }
                    if (key === 'e') {
                        // Counterspell - Magic shield that reflects damage
                        createShield(this, Math.floor(150 * levelBonus));
                        this.magicResist = 0.5; // 50% magic resist for 3 seconds
                        setTimeout(() => { this.magicResist = 0; }, 3000);
                    }
                    if (key === 'r') {
                        // Mana Void - AoE damage based on missing mana
                        createManaVoid(pos, Math.floor(300 * levelBonus));
                    }
                }

                // === IRON CLAD ABILITIES ===
                else if (heroType === 'ironclad') {
                    if (key === 'q') {
                        // Shield Slam - AoE stun around hero
                        createShieldSlam(pos, Math.floor(60 * levelBonus));
                    }
                    if (key === 'w') {
                        // Charge - Rush forward, knock back enemies
                        this.performCharge(10, Math.floor(80 * levelBonus));
                    }
                    if (key === 'e') {
                        // Fortify - Massive armor boost
                        this.armor += 20;
                        createShield(this, Math.floor(300 * levelBonus));
                        createExplosion(pos, 0x888888, 15);
                        setTimeout(() => { this.armor -= 20; }, 5000);
                    }
                    if (key === 'r') {
                        // Earthquake - Huge AoE damage and slow
                        createEarthquake(pos, Math.floor(350 * levelBonus));
                    }
                }

                // === PYROMANCER ABILITIES ===
                else if (heroType === 'pyromancer') {
                    if (key === 'q') {
                        // Fireball - Fast fire projectile
                        createFireball(pos, mouse, Math.floor(100 * levelBonus));
                    }
                    if (key === 'w') {
                        // Flame Dash - Leave fire trail
                        this.performFlameDash(6);
                    }
                    if (key === 'e') {
                        // Inferno - Ring of fire around self
                        createInferno(pos, Math.floor(40 * levelBonus));
                    }
                    if (key === 'r') {
                        // Meteor - Massive fire explosion at target
                        createMeteor(mouse, Math.floor(500 * levelBonus));
                    }
                }

                // === SHADOW BLADE ABILITIES ===
                else if (heroType === 'shadowblade') {
                    if (key === 'q') {
                        // Shadow Strike - Teleport to target and backstab
                        this.performShadowStrike(Math.floor(120 * levelBonus));
                    }
                    if (key === 'w') {
                        // Vanish - Become invisible
                        this.performVanish();
                    }
                    if (key === 'e') {
                        // Fan of Knives - Throw knives in cone
                        createFanOfKnives(pos, this.targetPos, Math.floor(70 * levelBonus));
                    }
                    if (key === 'r') {
                        // Death Mark - Mark enemy for death, bonus damage
                        createDeathMark(pos, Math.floor(400 * levelBonus));
                    }
                }

                // Fallback for unknown heroes
                else {
                    if (key === 'q') createProjectile(pos, mouse, Math.floor(80 * levelBonus));
                    if (key === 'w') this.performBlink(5, 0xffff00);
                    if (key === 'e') createShield(this, Math.floor(200 * levelBonus));
                    if (key === 'r') createUlt(pos, Math.floor(400 * levelBonus));
                }
            }

            performBlink(distance, color) {
                const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                const startPos = this.mesh.position.clone();
                const newPos = startPos.clone().add(dir.clone().multiplyScalar(distance));
                const MAP_BOUNDARY = 48;
                newPos.x = Math.max(-MAP_BOUNDARY, Math.min(MAP_BOUNDARY, newPos.x));
                newPos.z = Math.max(-MAP_BOUNDARY, Math.min(MAP_BOUNDARY, newPos.z));

                // Create afterimage trail
                for (let i = 1; i <= 5; i++) {
                    const t = i / 6;
                    const afterPos = startPos.clone().lerp(newPos, t);
                    const afterimage = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.3, 0.8, 4, 8),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 - t * 0.4 })
                    );
                    afterimage.position.copy(afterPos);
                    afterimage.position.y = 0.8;
                    scene.add(afterimage);
                    setTimeout(() => {
                        let fade = afterimage.material.opacity;
                        const fadeOut = () => {
                            fade -= 0.1;
                            afterimage.material.opacity = fade;
                            if (fade > 0) requestAnimationFrame(fadeOut);
                            else scene.remove(afterimage);
                        };
                        fadeOut();
                    }, i * 30);
                }

                this.mesh.position.copy(newPos);
                this.targetPos.copy(this.mesh.position);
                createExplosion(this.mesh.position, color, 15);
            }

            performCharge(distance, damage) {
                const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                const startPos = this.mesh.position.clone();
                const endPos = startPos.clone().add(dir.clone().multiplyScalar(distance));

                // Damage and knockback enemies along path
                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const toEnemy = e.mesh.position.clone().sub(startPos);
                        const proj = toEnemy.dot(dir);
                        if (proj > 0 && proj < distance) {
                            const perpDist = toEnemy.clone().sub(dir.clone().multiplyScalar(proj)).length();
                            if (perpDist < 2) {
                                e.takeDamage(damage, 'physical');
                                // Knockback
                                const knockDir = e.mesh.position.clone().sub(startPos).normalize();
                                e.mesh.position.add(knockDir.multiplyScalar(3));
                                createExplosion(e.mesh.position, 0xffaa00, 10);
                            }
                        }
                    }
                });

                this.mesh.position.copy(endPos);
                this.targetPos.copy(this.mesh.position);
                createExplosion(endPos, 0xffaa00, 20);
            }

            performFlameDash(distance) {
                const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                const startPos = this.mesh.position.clone();
                const endPos = startPos.clone().add(dir.clone().multiplyScalar(distance));

                // Create fire trail
                for (let i = 0; i < 10; i++) {
                    const t = i / 10;
                    const firePos = startPos.clone().lerp(endPos, t);
                    setTimeout(() => {
                        createFirePatch(firePos, 50, 3000);
                    }, i * 50);
                }

                this.mesh.position.copy(endPos);
                this.targetPos.copy(this.mesh.position);
            }

            performShadowStrike(damage) {
                // Find nearest enemy to teleport to
                let nearestEnemy = null;
                let minDist = 15;

                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            nearestEnemy = e;
                        }
                    }
                });

                if (nearestEnemy) {
                    const behindPos = nearestEnemy.mesh.position.clone();
                    const awayDir = behindPos.clone().sub(this.mesh.position).normalize();
                    behindPos.sub(awayDir.multiplyScalar(1.5));

                    createExplosion(this.mesh.position, 0x440066, 10);
                    this.mesh.position.copy(behindPos);
                    this.targetPos.copy(this.mesh.position);
                    createExplosion(this.mesh.position, 0x440066, 15);

                    // Backstab damage
                    nearestEnemy.takeDamage(damage * 1.5, 'physical');
                    showDamageNumber(nearestEnemy.mesh.position, damage * 1.5, true);
                }
            }

            performVanish() {
                this.invisible = true;
                this.mesh.visible = false;

                // Ghost trail effect
                const ghost = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.3, 0.8, 4, 8),
                    new THREE.MeshBasicMaterial({ color: 0x440066, transparent: true, opacity: 0.5 })
                );
                ghost.position.copy(this.mesh.position);
                ghost.position.y = 0.8;
                scene.add(ghost);

                let fadeTime = 1;
                const fadeGhost = () => {
                    fadeTime -= 0.05;
                    ghost.material.opacity = fadeTime * 0.5;
                    if (fadeTime > 0) requestAnimationFrame(fadeGhost);
                    else scene.remove(ghost);
                };
                fadeGhost();

                // Reveal after 4 seconds or on attack
                setTimeout(() => {
                    this.invisible = false;
                    this.mesh.visible = true;
                    createExplosion(this.mesh.position, 0x440066, 10);
                }, 4000);
            }
        }

        // === AI HERO CLASS ===
        class AIHero extends Hero {
            constructor(x, z, team, heroType = 'voidwalker') {
                super(x, z, team, heroType);
                this.isAI = true;
                this.aiState = 'idle'; // idle, farming, fighting, retreating, pushing
                this.aiTarget = null;
                this.lastAiThink = 0;
                this.aiThinkInterval = 0.5; // Think every 0.5 seconds
                this.assignedLane = 'mid';
                this.farmingJungle = false;
                this.retreatThreshold = 0.3; // Retreat when below 30% HP
                this.aggroRange = 12;
                this.lastAbilityUse = 0;
                this.abilityUseInterval = 3; // Use abilities every 3 seconds
            }

            update(dt) {
                if (this.dead) return;

                // Mana and HP regen
                if (this.mp < this.maxMp) this.mp += (this.manaRegen || 0.2);
                if (this.hp < this.maxHp) this.hp += (this.hpRegen || 0.5);

                // Update cooldowns
                for (let key in this.abilities) {
                    if (this.abilities[key].currentCd > 0) {
                        this.abilities[key].currentCd -= dt;
                    }
                }

                // AI thinking
                const now = clock.getElapsedTime();
                if (now - this.lastAiThink > this.aiThinkInterval) {
                    this.think();
                    this.lastAiThink = now;
                }

                // Execute current state
                this.executeState(dt);

                // Update health bar
                this.updateHealthBar();
            }

            think() {
                const hpPercent = this.hp / this.maxHp;

                // Check if should retreat
                if (hpPercent < this.retreatThreshold) {
                    this.aiState = 'retreating';
                    return;
                }

                // Find nearby threats and opportunities
                let nearestEnemy = null;
                let nearestEnemyDist = this.aggroRange;
                let nearestCreep = null;
                let nearestCreepDist = 15;

                entities.forEach(e => {
                    if (e.dead || !e.mesh) return;

                    const dist = this.mesh.position.distanceTo(e.mesh.position);

                    // Enemy heroes/creeps
                    if (e.team !== this.team && e.team !== 0) {
                        if (dist < nearestEnemyDist) {
                            nearestEnemy = e;
                            nearestEnemyDist = dist;
                        }
                    }

                    // Neutral creeps for farming
                    if (e.team === 0 && dist < nearestCreepDist) {
                        nearestCreep = e;
                        nearestCreepDist = dist;
                    }
                });

                // Decision making
                if (nearestEnemy && nearestEnemyDist < this.aggroRange) {
                    this.aiState = 'fighting';
                    this.aiTarget = nearestEnemy;
                } else if (nearestCreep && this.farmingJungle) {
                    this.aiState = 'farming';
                    this.aiTarget = nearestCreep;
                } else {
                    this.aiState = 'pushing';
                    this.aiTarget = null;
                }
            }

            executeState(dt) {
                switch (this.aiState) {
                    case 'fighting':
                        this.executeFighting(dt);
                        break;
                    case 'farming':
                        this.executeFarming(dt);
                        break;
                    case 'retreating':
                        this.executeRetreating(dt);
                        break;
                    case 'pushing':
                        this.executePushing(dt);
                        break;
                    default:
                        this.executeIdle(dt);
                }
            }

            executeFighting(dt) {
                if (!this.aiTarget || this.aiTarget.dead) {
                    this.aiState = 'idle';
                    return;
                }

                const dist = this.mesh.position.distanceTo(this.aiTarget.mesh.position);

                // Try to use abilities
                const now = clock.getElapsedTime();
                if (now - this.lastAbilityUse > this.abilityUseInterval) {
                    this.tryUseAbility();
                    this.lastAbilityUse = now;
                }

                // Attack if in range
                if (dist < 3) {
                    if (clock.getElapsedTime() - this.lastAttack > this.getAttackInterval()) {
                        this.performAttack(this.aiTarget);
                        this.lastAttack = clock.getElapsedTime();
                    }
                } else {
                    // Move towards target
                    this.targetPos.copy(this.aiTarget.mesh.position);
                    this.moveTowardsTarget(dt);
                }
            }

            executeFarming(dt) {
                if (!this.aiTarget || this.aiTarget.dead) {
                    this.aiState = 'idle';
                    return;
                }

                const dist = this.mesh.position.distanceTo(this.aiTarget.mesh.position);

                if (dist < 3) {
                    if (clock.getElapsedTime() - this.lastAttack > this.getAttackInterval()) {
                        this.performAttack(this.aiTarget);
                        this.lastAttack = clock.getElapsedTime();
                    }
                } else {
                    this.targetPos.copy(this.aiTarget.mesh.position);
                    this.moveTowardsTarget(dt);
                }
            }

            executeRetreating(dt) {
                // Move towards friendly base
                const basePos = this.team === TEAM_RADIANT ?
                    new THREE.Vector3(-45, 0, -45) :
                    new THREE.Vector3(45, 0, 45);

                this.targetPos.copy(basePos);
                this.moveTowardsTarget(dt);

                // Stop retreating when healed
                if (this.hp / this.maxHp > 0.7) {
                    this.aiState = 'idle';
                }
            }

            executePushing(dt) {
                // Move along assigned lane towards enemy base
                const lane = LANES[this.assignedLane];
                if (!lane) return;

                const waypoints = this.team === TEAM_RADIANT ? lane.waypoints.radiant : lane.waypoints.dire;

                if (waypoints && waypoints.length > 0) {
                    // Find nearest waypoint ahead
                    let targetWp = waypoints[waypoints.length - 1];
                    for (const wp of waypoints) {
                        const wpPos = new THREE.Vector3(wp.x, 0, wp.z);
                        if (this.mesh.position.distanceTo(wpPos) > 3) {
                            targetWp = wp;
                            break;
                        }
                    }

                    this.targetPos.set(targetWp.x, 0, targetWp.z);
                    this.moveTowardsTarget(dt);
                }
            }

            executeIdle(dt) {
                // Wander or push lane
                this.aiState = 'pushing';
            }

            moveTowardsTarget(dt) {
                // R3: Use VecPool instead of .clone()
                const direction = VecPool.get();
                direction.copy(this.targetPos).sub(this.mesh.position);
                const dist = direction.length();

                if (dist > 0.5) {
                    direction.normalize();
                    this.mesh.position.add(direction.multiplyScalar(this.speed * dt * 60));
                    this.mesh.rotation.y = Math.atan2(direction.x, direction.z);
                }
            }

            tryUseAbility() {
                // ROUND 10: Enhanced strategic ability usage
                const hpPercent = this.hp / this.maxHp;
                const mpPercent = this.mp / this.maxMp;

                // Count nearby enemies for group fight detection
                let nearbyEnemies = 0;
                let nearbyAllies = 0;
                let lowestEnemyHpPercent = 1;
                let lowestEnemy = null;

                entities.forEach(e => {
                    if (e.dead || !e.mesh) return;
                    const dist = this.mesh.position.distanceTo(e.mesh.position);
                    if (dist < 15) {
                        if (e.team !== this.team && e.team !== 0) {
                            nearbyEnemies++;
                            const eHpPct = e.hp / e.maxHp;
                            if (eHpPct < lowestEnemyHpPercent) {
                                lowestEnemyHpPercent = eHpPct;
                                lowestEnemy = e;
                            }
                        } else if (e.team === this.team && e !== this) {
                            nearbyAllies++;
                        }
                    }
                });

                // Defensive ability priority when low HP
                if (hpPercent < 0.4) {
                    // Try to use shield/defensive ability (E slot usually)
                    const ab = this.abilities['e'];
                    if (ab && ab.currentCd <= 0 && this.mp >= ab.cost) {
                        this.mp -= ab.cost;
                        ab.currentCd = ab.cd;
                        const levelBonus = 1 + (this.level - 1) * 0.1;
                        this.executeHeroAbility('e', levelBonus);
                        return;
                    }
                }

                // Ultimate ability for team fights or finishing low enemies
                const rAb = this.abilities['r'];
                if (rAb && rAb.currentCd <= 0 && this.mp >= rAb.cost) {
                    // Use ult if: enemy is low, or outnumbered in team fight
                    const shouldUlt = (lowestEnemyHpPercent < 0.3) ||
                                     (nearbyEnemies >= 2 && nearbyAllies >= 1) ||
                                     (hpPercent < 0.25);
                    if (shouldUlt && this.aiTarget) {
                        this.mp -= rAb.cost;
                        rAb.currentCd = rAb.cd;
                        const levelBonus = 1 + (this.level - 1) * 0.1;
                        // Target lowest HP enemy if possible
                        if (lowestEnemy) this.aiTarget = lowestEnemy;
                        this.executeHeroAbility('r', levelBonus);
                        return;
                    }
                }

                // Regular ability usage
                const abilityOrder = ['q', 'w']; // Q and W for damage
                for (const key of abilityOrder) {
                    const ab = this.abilities[key];
                    if (ab.currentCd <= 0 && this.mp >= ab.cost) {
                        // Only use if we have enough mana reserve (keep 30% for emergencies)
                        if (mpPercent > 0.3 || hpPercent > 0.7) {
                            this.mp -= ab.cost;
                            ab.currentCd = ab.cd;
                            const levelBonus = 1 + (this.level - 1) * 0.1;
                            this.executeHeroAbility(key, levelBonus);
                            return;
                        }
                    }
                }
            }

            // ROUND 10: Kiting behavior for ranged heroes
            executeKiting(dt, target) {
                if (!target || target.dead) return false;

                const dist = this.mesh.position.distanceTo(target.mesh.position);
                const attackRange = 3;
                const safeRange = 5;

                // If enemy is too close, back away while attacking
                if (dist < safeRange && dist > attackRange * 0.5) {
                    // Move away from target
                    const awayDir = this.mesh.position.clone().sub(target.mesh.position).normalize();
                    this.mesh.position.add(awayDir.multiplyScalar(this.speed * dt * 30));
                    this.mesh.rotation.y = Math.atan2(-awayDir.x, -awayDir.z);

                    // Attack while moving
                    if (clock.getElapsedTime() - this.lastAttack > this.getAttackInterval()) {
                        this.performAttack(target);
                        this.lastAttack = clock.getElapsedTime();
                    }
                    return true;
                }
                return false;
            }
        }

        // Store AI heroes
        const aiHeroes = [];

        function spawnAIHeroes() {
            // Spawn enemy AI heroes
            const enemyHeroTypes = ['ironclad', 'pyromancer', 'shadowblade'];
            const lanes = ['top', 'mid', 'bot'];

            enemyHeroTypes.forEach((heroType, i) => {
                const aiHero = new AIHero(40, 40 - i * 5, TEAM_DIRE, heroType);
                aiHero.assignedLane = lanes[i % 3];
                aiHero.farmingJungle = i === 2; // Last one farms jungle
                aiHeroes.push(aiHero);
                entities.push(aiHero);
                scene.add(aiHero.mesh);
            });

            // Spawn allied AI heroes (teammates)
            const allyHeroTypes = ['ironclad', 'pyromancer'];
            allyHeroTypes.forEach((heroType, i) => {
                const aiHero = new AIHero(-40, -40 + i * 5, TEAM_RADIANT, heroType);
                aiHero.assignedLane = lanes[(i + 1) % 3];
                aiHeroes.push(aiHero);
                entities.push(aiHero);
                scene.add(aiHero.mesh);
            });
        }

        class Creep extends GameEntity {
            constructor(x, z, team) {
                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                super(x, z, team, color);
                this.hp = 300;
                this.maxHp = 300;  // ROUND 6: Fix health bar display
                this.damage = 15;
                this.armor = 1;           // ROUND 7: Base armor
                this.attackSpeed = 1.0;   // ROUND 7: Normal attack speed
                this.speed = 0.12;
                this.lastAttack = 0;
                this.animTime = Math.random() * 10; // Offset animation phase
                this.isAttacking = false;
                this.xpReward = 25;       // ROUND 7: XP given on death
                this.attackRange = 2;     // ROUND 7: Melee range
                this.goldReward = 30;     // ROUND 8: Gold given on death

                // Build detailed 3D model from CREEP_MODELS
                const modelKey = `melee_${team === TEAM_RADIANT ? 'radiant' : 'dire'}`;
                const modelDef = CREEP_MODELS[modelKey];
                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup; // For animation compatibility
                } else {
                    // Fallback to simple geometry
                    const geo = team === TEAM_RADIANT ? new THREE.SphereGeometry(0.4) : new THREE.BoxGeometry(0.6, 0.6, 0.6);
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, emissive: color, emissiveIntensity: 0.1 });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = 0.5;
                    this.mesh.add(this.bodyMesh);
                }

                // Register with animation system
                if (typeof AnimationSystem !== 'undefined') {
                    AnimationSystem.register(this, 'creep');
                }

                // Spawn animation - pop in
                this.mesh.scale.set(0.1, 0.1, 0.1);
                this.spawnAnim();
            }

            spawnAnim() {
                let scale = 0.1;
                const grow = () => {
                    scale += 0.15;
                    if (scale >= 1) {
                        this.mesh.scale.set(1, 1, 1);
                        return;
                    }
                    // Bouncy overshoot
                    const overshoot = scale > 0.8 ? 1 + (1 - scale) * 0.5 : scale;
                    this.mesh.scale.set(overshoot, overshoot, overshoot);
                    requestAnimationFrame(grow);
                };
                grow();
            }

            update(dt) {
                if (this.dead) return;

                this.animTime += dt * 3;

                // Idle breathing animation
                if (this.bodyMesh) {
                    const breathe = 1 + Math.sin(this.animTime * 2) * 0.08;
                    const bob = 0.5 + Math.sin(this.animTime * 3) * 0.05;
                    this.bodyMesh.scale.set(breathe, 1 / breathe, breathe);
                    this.bodyMesh.position.y = bob;

                    // Rotation wobble when moving
                    const dist = this.mesh.position.distanceTo(this.targetPos);
                    if (dist > 0.2) {
                        this.bodyMesh.rotation.z = Math.sin(this.animTime * 8) * 0.15;
                        this.bodyMesh.rotation.x = Math.sin(this.animTime * 6) * 0.1;
                    } else {
                        this.bodyMesh.rotation.z *= 0.9;
                        this.bodyMesh.rotation.x *= 0.9;
                    }
                }

                // Collision avoidance with other creeps
                entities.forEach(e => {
                    if (e === this || e.dead || !(e instanceof Creep)) return;
                    const dist = this.mesh.position.distanceTo(e.mesh.position);
                    if (dist < 1.2 && dist > 0.01) {
                        // Push apart
                        const pushDir = this.mesh.position.clone().sub(e.mesh.position).normalize();
                        this.mesh.position.add(pushDir.multiplyScalar(0.05));
                    }
                });

                // AI
                let target = null;
                let minDist = 8;
                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    }
                });

                if (target) {
                    if (minDist < this.attackRange) {
                        // Attack - ROUND 7: Use attackSpeed
                        if (clock.getElapsedTime() - this.lastAttack > this.getAttackInterval()) {
                            this.performAttack(target);
                            this.lastAttack = clock.getElapsedTime();
                            this.attackAnim(target);
                        }
                    } else {
                        // Chase
                        this.targetPos.copy(target.mesh.position);
                        super.update(dt);
                    }
                } else {
                    // Lane logic - follow waypoints if available
                    if (this.waypoints && this.waypoints.length > 0) {
                        const wp = this.waypoints[0];
                        const wpPos = new THREE.Vector3(wp.x, 0, wp.z);
                        const distToWp = this.mesh.position.distanceTo(wpPos);

                        if (distToWp < 3) {
                            // Reached waypoint, move to next
                            this.waypoints.shift();
                        }
                        this.targetPos.copy(wpPos);
                    } else {
                        // No waypoints, head to enemy base
                        const dest = this.team === TEAM_RADIANT ? new THREE.Vector3(45, 0, 45) : new THREE.Vector3(-45, 0, -45);
                        this.targetPos.copy(dest);
                    }
                    super.update(dt);
                }
            }

            attackAnim(target) {
                if (!this.bodyMesh) return;
                // Squash and stretch attack
                const dir = target.mesh.position.clone().sub(this.mesh.position).normalize();
                const bumpOffset = dir.clone().multiplyScalar(0.5);

                // Wind up (squash)
                this.bodyMesh.scale.set(1.3, 0.7, 1.3);

                setTimeout(() => {
                    if (this.dead || !this.bodyMesh) return;
                    // Strike (stretch forward)
                    this.bodyMesh.scale.set(0.7, 1.4, 0.7);
                    this.mesh.position.add(bumpOffset);
                }, 50);

                setTimeout(() => {
                    if (this.dead || !this.bodyMesh) return;
                    // Return
                    this.bodyMesh.scale.set(1, 1, 1);
                    this.mesh.position.sub(bumpOffset);
                }, 150);
            }

            die() {
                if (this.dead) return;
                // Death animation before removal
                this.dead = true;

                // Clear shield state
                if (this.shieldTimeout) {
                    clearTimeout(this.shieldTimeout);
                    this.shieldTimeout = null;
                }
                this.shieldActive = false;

                // ROUND 7: Grant XP to player if enemy dies near player
                // ROUND 8: Also grant gold
                if (this.team === TEAM_DIRE && player && !player.dead) {
                    const distToPlayer = this.mesh.position.distanceTo(player.mesh.position);
                    if (distToPlayer < 15) { // XP/Gold range
                        player.gainXP(this.xpReward);
                        player.gold += this.goldReward;
                        // Show gold floating text
                        showGoldText(this.mesh.position, this.goldReward);
                        AudioManager.playGold(); // ROUND 9: Gold sound
                        // ROUND 10: Track gold and creep kill for match stats
                        if (typeof matchStats !== 'undefined') {
                            matchStats.trackGold(this.goldReward);
                            matchStats.trackCreepKill();
                        }
                    }
                }

                // Score
                if (this.team === TEAM_RADIANT) score.dire++;
                else score.radiant++;
                updateScoreBoard();

                // Death animation - shrink and spin
                let deathTime = 0;
                const deathAnim = () => {
                    deathTime += 0.05;
                    if (deathTime >= 1 || !this.mesh) {
                        scene.remove(this.mesh);
                        return;
                    }
                    const scale = 1 - deathTime;
                    this.mesh.scale.set(scale, scale * 0.5, scale);
                    this.mesh.rotation.y += 0.3;
                    this.mesh.position.y -= 0.05;
                    if (this.bodyMesh) {
                        this.bodyMesh.material.opacity = scale;
                        this.bodyMesh.material.transparent = true;
                    }
                    requestAnimationFrame(deathAnim);
                };
                deathAnim();

                // Particle burst on death
                createExplosion(this.mesh.position, this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c, 15);
            }
        }

        // ROUND 7: Ranged Creep - attacks from distance, lower HP
        class RangedCreep extends Creep {
            constructor(x, z, team) {
                super(x, z, team);
                this.hp = 200;
                this.maxHp = 200;
                this.damage = 20;
                this.armor = 0;
                this.attackRange = 6;      // Can attack from range
                this.attackSpeed = 0.8;    // Slower attack
                this.xpReward = 30;        // Slightly more XP
                this.goldReward = 40;      // ROUND 8: More gold for ranged

                // Build detailed ranged creep model
                if (this.modelGroup) {
                    this.mesh.remove(this.modelGroup);
                }
                if (this.bodyMesh && this.bodyMesh !== this.modelGroup) {
                    this.mesh.remove(this.bodyMesh);
                }

                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                const modelKey = `ranged_${team === TEAM_RADIANT ? 'radiant' : 'dire'}`;
                const modelDef = CREEP_MODELS[modelKey];

                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup;
                } else {
                    // Fallback
                    const geo = new THREE.OctahedronGeometry(0.35);
                    const mat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.5,
                        emissive: color,
                        emissiveIntensity: 0.3
                    });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = 0.6;
                    this.mesh.add(this.bodyMesh);
                }
            }

            attackAnim(target) {
                if (!this.bodyMesh || !target || !target.mesh) return;

                // Ranged attack - shoot projectile
                const start = this.mesh.position.clone();
                start.y = 0.6;
                const end = target.mesh.position.clone();
                end.y = 1;

                const color = this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c;

                // ROUND 10: Enhanced projectile with glow
                const projectile = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                projectile.position.copy(start);

                // Inner glow
                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25),
                    new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.4
                    })
                );
                projectile.add(glow);

                scene.add(projectile);

                // ROUND 10: Add particle trail
                if (typeof createProjectileTrail !== 'undefined') {
                    createProjectileTrail(projectile, color, 8);
                }

                const dir = end.clone().sub(start).normalize();
                let dist = 0;
                const maxDist = start.distanceTo(end);

                const moveProjectile = () => {
                    dist += 0.5;
                    projectile.position.add(dir.clone().multiplyScalar(0.5));
                    if (dist >= maxDist) {
                        scene.remove(projectile);
                        return;
                    }
                    requestAnimationFrame(moveProjectile);
                };
                moveProjectile();

                // Body pulse
                this.bodyMesh.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => {
                    if (this.bodyMesh) this.bodyMesh.scale.set(1, 1, 1);
                }, 100);
            }
        }

        // ROUND 7: Siege Creep - high HP, bonus damage to structures, slow
        class SiegeCreep extends Creep {
            constructor(x, z, team) {
                super(x, z, team);
                this.hp = 600;
                this.maxHp = 600;
                this.damage = 25;
                this.armor = 3;            // Armored
                this.attackRange = 3;      // Slightly longer range
                this.attackSpeed = 0.6;    // Slow attack
                this.speed = 0.08;         // Slow movement
                this.xpReward = 50;        // More XP
                this.goldReward = 60;      // ROUND 8: Most gold for siege
                this.structureDamageBonus = 2.0; // Double damage to structures

                // Build detailed siege creep model
                if (this.modelGroup) {
                    this.mesh.remove(this.modelGroup);
                }
                if (this.bodyMesh && this.bodyMesh !== this.modelGroup) {
                    this.mesh.remove(this.bodyMesh);
                }

                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                const modelKey = `siege_${team === TEAM_RADIANT ? 'radiant' : 'dire'}`;
                const modelDef = CREEP_MODELS[modelKey];

                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup;
                    // Find cannon part for animation
                    this.modelGroup.traverse(child => {
                        if (child.name === 'cannon' || child.name === 'barrel') {
                            this.cannon = child;
                        }
                    });
                } else {
                    // Fallback
                    const geo = new THREE.BoxGeometry(0.8, 0.5, 1.0);
                    const mat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.5,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = 0.4;
                    this.mesh.add(this.bodyMesh);

                    // Cannon on top
                    const cannonGeo = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 8);
                    const cannonMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 });
                    this.cannon = new THREE.Mesh(cannonGeo, cannonMat);
                    this.cannon.rotation.x = Math.PI / 2;
                    this.cannon.position.set(0, 0.6, 0.3);
                    this.mesh.add(this.cannon);
                }

                // Make health bar bigger
                if (this.healthBarBg) this.healthBarBg.scale.set(1.5, 1.5, 1);
                if (this.healthBarFg) this.healthBarFg.scale.set(1.5, 1.5, 1);
            }

            // Override performAttack to deal bonus damage to structures
            performAttack(target, baseDamage = null) {
                if (!target || target.dead) return 0;

                let dmg = baseDamage || this.damage;

                // Bonus damage to structures
                if (target instanceof Structure) {
                    dmg *= this.structureDamageBonus;
                }

                target.takeDamage(dmg, 'physical', this);
                return dmg;
            }

            attackAnim(target) {
                if (!this.bodyMesh || !this.cannon) return;

                // Cannon recoil
                this.cannon.position.z = 0.1;
                setTimeout(() => {
                    if (this.cannon) this.cannon.position.z = 0.3;
                }, 100);

                // Body shake
                const origY = this.bodyMesh.position.y;
                this.bodyMesh.position.y = origY - 0.1;
                setTimeout(() => {
                    if (this.bodyMesh) this.bodyMesh.position.y = origY;
                }, 50);

                // Muzzle flash
                if (target && target.mesh) {
                    createExplosion(this.mesh.position.clone().add(new THREE.Vector3(0, 0.6, 0.5)), 0xffaa00, 5);
                }
            }
        }

        class Structure extends GameEntity {
            constructor(x, z, type, team) {
                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                super(x, z, team, color);
                this.type = type;
                this.maxHp = type === 'base' ? 2500 : 1500;
                this.hp = this.maxHp;
                this.damage = 40;
                this.range = 10;
                this.lastAttack = 0;
                this.baseEmissive = 0.4;

                // Build detailed structure model from STRUCTURE_MODELS
                const teamStr = team === TEAM_RADIANT ? 'radiant' : 'dire';
                const modelKey = `${type}_${teamStr}`;
                const modelDef = STRUCTURE_MODELS[modelKey];

                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup;
                } else {
                    // Fallback to simple geometry
                    let geo;
                    if (type === 'base') geo = new THREE.ConeGeometry(3, 8, 6);
                    else geo = new THREE.CylinderGeometry(0.8, 1.2, 5, 8);

                    const mat = new THREE.MeshStandardMaterial({
                        color: color, roughness: 0.4,
                        emissive: color, emissiveIntensity: 0.4
                    });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = type === 'base' ? 4 : 2.5;
                    this.mesh.add(this.bodyMesh);
                }

                // Base Ring
                const ring = new THREE.Mesh(new THREE.TorusGeometry(2, 0.2, 8, 16), new THREE.MeshBasicMaterial({ color: color }));
                ring.rotation.x = -Math.PI / 2;
                this.mesh.add(ring);

                // Register with animation system for idle effects
                if (typeof AnimationSystem !== 'undefined') {
                    AnimationSystem.register(this, 'structure');
                }

                // Move health bar higher for structures
                if (this.healthBarBg) this.healthBarBg.position.y = type === 'base' ? 10 : 7;
                if (this.healthBarFg) this.healthBarFg.position.y = type === 'base' ? 10 : 7;

                // Make health bar bigger for structures
                if (this.healthBarBg) this.healthBarBg.scale.set(2, 2, 1);
                if (this.healthBarFg) this.healthBarFg.scale.set(2, 2, 1);
            }

            takeDamage(amt, type = 'physical') {
                // Call parent damage logic
                const oldHp = this.hp;
                super.takeDamage(amt, type);

                // Visual feedback - flash and shake
                if (this.bodyMesh && !this.dead) {
                    // Bright flash
                    this.bodyMesh.material.emissiveIntensity = 2;

                    // Shake effect
                    const shakeAmount = 0.3;
                    const origPos = this.bodyMesh.position.clone();
                    let shakeTime = 0;
                    const shake = () => {
                        shakeTime++;
                        if (shakeTime > 8) {
                            this.bodyMesh.position.copy(origPos);
                            this.bodyMesh.material.emissiveIntensity = this.baseEmissive;
                            return;
                        }
                        this.bodyMesh.position.x = origPos.x + (Math.random() - 0.5) * shakeAmount;
                        this.bodyMesh.position.z = origPos.z + (Math.random() - 0.5) * shakeAmount;
                        this.bodyMesh.material.emissiveIntensity *= 0.8;
                        requestAnimationFrame(shake);
                    };
                    shake();

                    // Damage particles
                    createExplosion(this.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), 0xffaa00, 8);
                }
            }

            update(dt) {
                if (this.dead) return;

                // Tower AI - R3: Use SpatialGrid for O(n) instead of O(n¬≤)
                if (clock.getElapsedTime() - this.lastAttack > 1.0) {
                    const target = SpatialGrid.getNearestEnemy(
                        this.mesh.position.x,
                        this.mesh.position.z,
                        this.range,
                        this.team
                    );

                    if (target) {
                        const minD = this.mesh.position.distanceTo(target.mesh.position);
                        target.takeDamage(this.damage, 'physical', this);
                        this.lastAttack = clock.getElapsedTime();
                        AudioManager.playTowerShot();
                        // Laser shot
                        const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, minD), new THREE.MeshBasicMaterial({ color: this.color }));
                        laser.geometry.rotateX(-Math.PI / 2);
                        laser.position.copy(this.mesh.position).add(new THREE.Vector3(0, 4, 0));
                        laser.lookAt(target.mesh.position);
                        laser.position.lerp(target.mesh.position, 0.5); // Center it
                        scene.add(laser);
                        setTimeout(() => scene.remove(laser), 100);
                    }
                }

                // ROUND 6: Update structure health bar
                this.updateHealthBar();
            }
        }

        // --- FX SYSTEMS ---
        // ROUND 8: Added damage parameter for level scaling
        // ROUND 9: Enhanced with trail effect
        function createProjectile(start, info, damage = 80) {
            // Shoots towards mouse - ROUND 9: Glowing core with outer shell
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.2),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            const outer = new THREE.Mesh(
                new THREE.SphereGeometry(0.35),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 })
            );
            const sphere = new THREE.Group();
            sphere.add(core);
            sphere.add(outer);
            sphere.position.copy(start);
            sphere.position.y = 1;
            scene.add(sphere);

            // Raycast for direction
            raycaster.setFromCamera(info, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            let targetPoint = new THREE.Vector3(info.x * 50, 0, info.y * 50); // Fallback
            for (let i of intersects) {
                if (i.object.geometry && i.object.geometry.type === 'PlaneGeometry') {
                    targetPoint = i.point;
                    break;
                }
            }

            const dir = targetPoint.sub(start).normalize();
            // R3: Pre-compute movement delta to avoid clone per frame
            const moveStep = dir.clone().multiplyScalar(0.8);
            let trailCounter = 0;

            let projectileAlive = true;
            const update = () => {
                if (!projectileAlive) return;

                sphere.position.add(moveStep);

                // ROUND 9: Spawn trail particles every 3 frames
                trailCounter++;
                if (trailCounter % 3 === 0) {
                    const trail = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15),
                        new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 })
                    );
                    trail.position.copy(sphere.position);
                    scene.add(trail);
                    // Fade out trail
                    let fade = 0.5;
                    const fadeTrail = () => {
                        fade -= 0.05;
                        trail.material.opacity = fade;
                        trail.scale.multiplyScalar(0.9);
                        if (fade > 0) requestAnimationFrame(fadeTrail);
                        else scene.remove(trail);
                    };
                    fadeTrail();
                }

                // Rotate outer shell for effect
                outer.rotation.x += 0.2;
                outer.rotation.y += 0.3;

                // ROUND 3: Actual hit detection!
                for (let i = 0; i < entities.length; i++) {
                    const e = entities[i];
                    if (!e || e.dead || e.team === TEAM_RADIANT || !e.mesh) continue;
                    const dist = sphere.position.distanceTo(e.mesh.position);
                    if (dist < 1.5) {
                        e.takeDamage(damage, 'magic'); // ROUND 8: Use scaled damage
                        scene.remove(sphere);
                        projectileAlive = false;
                        screenShake.light();
                        return;
                    }
                }

                if (sphere.position.length() > 60) {
                    scene.remove(sphere);
                    projectileAlive = false;
                } else {
                    requestAnimationFrame(update);
                }
            };
            update();
        }

        // ==========================================
        // CONSENSUS FEATURE 3: Explosion Pool
        // Reuses explosion objects for better performance
        // ==========================================
        const ExplosionPool = {
            pool: [],
            activeExplosions: [],
            maxPoolSize: 30,
            maxParticles: 50,

            // Pre-create explosion objects
            init() {
                for (let i = 0; i < 10; i++) {
                    this.pool.push(this._createExplosionObject());
                }
            },

            _createExplosionObject() {
                const geom = new THREE.BufferGeometry();
                const positions = new Float32Array(this.maxParticles * 3);
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.4,
                    transparent: true,
                    depthWrite: false
                });
                const points = new THREE.Points(geom, mat);
                points.visible = false;
                return {
                    points,
                    velocities: [],
                    frame: 0,
                    active: false,
                    count: 0
                };
            },

            // Get an explosion from pool or create new
            get() {
                let explosion = this.pool.pop();
                if (!explosion) {
                    if (this.activeExplosions.length < this.maxPoolSize) {
                        explosion = this._createExplosionObject();
                    } else {
                        // Recycle oldest active explosion
                        explosion = this.activeExplosions.shift();
                        this._reset(explosion);
                    }
                }
                return explosion;
            },

            // Return explosion to pool
            release(explosion) {
                this._reset(explosion);
                if (this.pool.length < this.maxPoolSize) {
                    this.pool.push(explosion);
                }
            },

            _reset(explosion) {
                explosion.active = false;
                explosion.frame = 0;
                explosion.points.visible = false;
                if (explosion.points.parent) {
                    scene.remove(explosion.points);
                }
            },

            // Spawn an explosion at position
            spawn(pos, color, count) {
                const explosion = this.get();
                const actualCount = Math.min(count, this.maxParticles);

                explosion.count = actualCount;
                explosion.frame = 0;
                explosion.active = true;
                explosion.velocities = [];

                const posAttr = explosion.points.geometry.attributes.position;
                for (let i = 0; i < actualCount; i++) {
                    posAttr.setXYZ(i, pos.x, pos.y, pos.z);
                    explosion.velocities.push({
                        x: (Math.random() - 0.5),
                        y: (Math.random() - 0.5) + 1,
                        z: (Math.random() - 0.5)
                    });
                }
                // Zero out unused particles
                for (let i = actualCount; i < this.maxParticles; i++) {
                    posAttr.setXYZ(i, 0, -1000, 0);
                }
                posAttr.needsUpdate = true;

                explosion.points.material.color.setHex(color);
                explosion.points.material.opacity = 1;
                explosion.points.visible = true;

                scene.add(explosion.points);
                this.activeExplosions.push(explosion);

                return explosion;
            },

            // Update all active explosions (call in game loop)
            update() {
                for (let i = this.activeExplosions.length - 1; i >= 0; i--) {
                    const exp = this.activeExplosions[i];
                    if (!exp.active) continue;

                    exp.frame++;
                    const posAttr = exp.points.geometry.attributes.position;

                    for (let j = 0; j < exp.count; j++) {
                        posAttr.setXYZ(j,
                            posAttr.getX(j) + exp.velocities[j].x * 0.2,
                            posAttr.getY(j) + exp.velocities[j].y * 0.2,
                            posAttr.getZ(j) + exp.velocities[j].z * 0.2
                        );
                        exp.velocities[j].y -= 0.05;
                    }
                    posAttr.needsUpdate = true;
                    exp.points.material.opacity -= 0.02;

                    if (exp.frame >= 50) {
                        this.activeExplosions.splice(i, 1);
                        this.release(exp);
                    }
                }
            },

            // Cleanup all (on game end)
            dispose() {
                this.activeExplosions.forEach(exp => {
                    if (exp.points.parent) scene.remove(exp.points);
                    exp.points.geometry.dispose();
                    exp.points.material.dispose();
                });
                this.pool.forEach(exp => {
                    exp.points.geometry.dispose();
                    exp.points.material.dispose();
                });
                this.activeExplosions = [];
                this.pool = [];
            }
        };

        // Wrapper function for backward compatibility
        function createExplosion(pos, color, count) {
            ExplosionPool.spawn(pos, color, count || 20);
        }

        // R3: Attack slash VFX for visual feedback
        function createSlashEffect(attacker, target, color = 0xffffff) {
            if (!attacker || !attacker.mesh || !target || !target.mesh) return;

            const startPos = attacker.mesh.position;
            const endPos = target.mesh.position;

            // Calculate direction to target
            const dir = VecPool.get();
            dir.copy(endPos).sub(startPos).normalize();

            // Create curved arc geometry
            const arcRadius = 1.2;
            const arcSegments = 8;
            const arcAngle = Math.PI * 0.6; // 108 degree arc

            const points = [];
            for (let i = 0; i <= arcSegments; i++) {
                const t = i / arcSegments;
                const angle = -arcAngle / 2 + arcAngle * t;
                const x = Math.sin(angle) * arcRadius;
                const y = 0.5 + Math.cos(angle) * arcRadius * 0.3; // Flatter arc
                const z = 0;
                points.push(new THREE.Vector3(x, y, z));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeo = new THREE.TubeGeometry(curve, 12, 0.08, 6, false);
            const tubeMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });

            const slashMesh = new THREE.Mesh(tubeGeo, tubeMat);

            // Position at midpoint between attacker and target
            const midPoint = VecPool.get();
            midPoint.copy(startPos).add(endPos).multiplyScalar(0.5);
            slashMesh.position.copy(midPoint);
            slashMesh.position.y = 1.0;

            // Rotate to face direction of attack
            slashMesh.rotation.y = Math.atan2(dir.x, dir.z);

            scene.add(slashMesh);

            // Animate slash - scale and fade
            let frame = 0;
            const maxFrames = 8;

            const animateSlash = () => {
                frame++;
                const progress = frame / maxFrames;

                // Scale up slightly
                slashMesh.scale.setScalar(1 + progress * 0.5);

                // Fade out
                tubeMat.opacity = 0.9 * (1 - progress);

                if (frame < maxFrames) {
                    requestAnimationFrame(animateSlash);
                } else {
                    scene.remove(slashMesh);
                    tubeGeo.dispose();
                    tubeMat.dispose();
                }
            };

            animateSlash();

            // Impact sparks at target position
            const sparkCount = 6;
            for (let i = 0; i < sparkCount; i++) {
                const sparkGeo = new THREE.SphereGeometry(0.05);
                const sparkMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const spark = new THREE.Mesh(sparkGeo, sparkMat);
                spark.position.copy(endPos);
                spark.position.y = 1;

                // Random velocity
                const vx = (Math.random() - 0.5) * 0.3;
                const vy = Math.random() * 0.2 + 0.1;
                const vz = (Math.random() - 0.5) * 0.3;

                scene.add(spark);

                let sparkFrame = 0;
                const animateSpark = () => {
                    sparkFrame++;
                    spark.position.x += vx;
                    spark.position.y += vy - sparkFrame * 0.02; // Gravity
                    spark.position.z += vz;
                    sparkMat.opacity = 1 - sparkFrame / 12;

                    if (sparkFrame < 12) {
                        requestAnimationFrame(animateSpark);
                    } else {
                        scene.remove(spark);
                        sparkGeo.dispose();
                        sparkMat.dispose();
                    }
                };
                animateSpark();
            }
        }

        // ROUND 10: Particle trail system for projectiles
        function createProjectileTrail(projectile, color, trailLength = 10) {
            const trail = {
                positions: [],
                meshes: [],
                maxLength: trailLength
            };

            const addTrailPoint = () => {
                if (!projectile.parent) {
                    // Cleanup trail when projectile is removed
                    trail.meshes.forEach(m => scene.remove(m));
                    return;
                }

                // Add new trail point
                const trailMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08),
                    new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                trailMesh.position.copy(projectile.position);
                scene.add(trailMesh);
                trail.meshes.push(trailMesh);

                // Fade and remove old trail points
                trail.meshes.forEach((m, i) => {
                    const age = trail.meshes.length - i;
                    const scale = 1 - (age / trail.maxLength);
                    m.scale.setScalar(Math.max(0.1, scale));
                    m.material.opacity = Math.max(0.1, 1 - (age / trail.maxLength));
                });

                // Remove oldest if exceeding max
                while (trail.meshes.length > trail.maxLength) {
                    scene.remove(trail.meshes.shift());
                }

                requestAnimationFrame(addTrailPoint);
            };

            addTrailPoint();
            return trail;
        }

        // ROUND 10: AoE indicator ring for abilities
        function createAoEIndicator(position, radius, color = 0xff0000, duration = 2000) {
            const ringGeo = new THREE.RingGeometry(radius - 0.1, radius, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(position);
            ring.position.y = 0.1;
            scene.add(ring);

            // Pulsing animation
            let frame = 0;
            const maxFrames = duration / 16;
            const pulse = () => {
                frame++;
                const pulseScale = 1 + Math.sin(frame * 0.3) * 0.1;
                ring.scale.setScalar(pulseScale);
                ringMat.opacity = 0.6 * (1 - frame / maxFrames);

                if (frame < maxFrames) {
                    requestAnimationFrame(pulse);
                } else {
                    scene.remove(ring);
                }
            };
            pulse();

            return ring;
        }

        // ROUND 10: Enhanced death effect with body parts flying
        function createDeathEffect(position, color, isHero = false) {
            const partCount = isHero ? 12 : 6;

            for (let i = 0; i < partCount; i++) {
                const size = isHero ? 0.2 + Math.random() * 0.3 : 0.1 + Math.random() * 0.15;
                const part = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.7,
                        metalness: 0.2
                    })
                );
                part.position.copy(position);
                part.position.y = 0.5 + Math.random() * 0.5;
                scene.add(part);

                const velocity = {
                    x: (Math.random() - 0.5) * 0.4,
                    y: 0.3 + Math.random() * 0.3,
                    z: (Math.random() - 0.5) * 0.4,
                    rotX: (Math.random() - 0.5) * 0.3,
                    rotZ: (Math.random() - 0.5) * 0.3
                };

                let frame = 0;
                const animate = () => {
                    frame++;
                    part.position.x += velocity.x;
                    part.position.y += velocity.y;
                    part.position.z += velocity.z;
                    velocity.y -= 0.015; // Gravity

                    part.rotation.x += velocity.rotX;
                    part.rotation.z += velocity.rotZ;

                    // Shrink over time
                    const scale = 1 - (frame / 60);
                    part.scale.setScalar(Math.max(0, scale));

                    if (frame < 60 && part.position.y > -0.5) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(part);
                    }
                };
                animate();
            }

            // Flash of light
            if (isHero) {
                const flash = new THREE.PointLight(color, 3, 10);
                flash.position.copy(position);
                flash.position.y = 1;
                scene.add(flash);

                let intensity = 3;
                const fadeLight = () => {
                    intensity -= 0.15;
                    flash.intensity = Math.max(0, intensity);
                    if (intensity > 0) {
                        requestAnimationFrame(fadeLight);
                    } else {
                        scene.remove(flash);
                    }
                };
                fadeLight();
            }
        }

        // ROUND 10: Level up celebration particles
        function createLevelUpEffect(entity) {
            if (!entity.mesh) return;

            const pos = entity.mesh.position.clone();

            // Rising golden particles in spiral
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 4;
                const delay = i * 30;

                setTimeout(() => {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1),
                        new THREE.MeshBasicMaterial({
                            color: 0xffd700,
                            transparent: true,
                            opacity: 1
                        })
                    );
                    particle.position.set(
                        pos.x + Math.cos(angle) * 0.5,
                        0.2,
                        pos.z + Math.sin(angle) * 0.5
                    );
                    scene.add(particle);

                    let frame = 0;
                    const rise = () => {
                        frame++;
                        particle.position.y += 0.1;
                        particle.position.x = pos.x + Math.cos(angle + frame * 0.1) * (0.5 + frame * 0.02);
                        particle.position.z = pos.z + Math.sin(angle + frame * 0.1) * (0.5 + frame * 0.02);
                        particle.material.opacity = 1 - (frame / 40);
                        particle.scale.setScalar(1 + frame * 0.02);

                        if (frame < 40) {
                            requestAnimationFrame(rise);
                        } else {
                            scene.remove(particle);
                        }
                    };
                    rise();
                }, delay);
            }

            // Golden ring expanding outward
            const ringGeo = new THREE.RingGeometry(0.1, 0.3, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(pos);
            ring.position.y = 0.1;
            scene.add(ring);

            let ringFrame = 0;
            const expandRing = () => {
                ringFrame++;
                const scale = 1 + ringFrame * 0.3;
                ring.scale.setScalar(scale);
                ringMat.opacity = 0.8 * (1 - ringFrame / 30);

                if (ringFrame < 30) {
                    requestAnimationFrame(expandRing);
                } else {
                    scene.remove(ring);
                }
            };
            expandRing();
        }

        // ROUND 10: Ability range indicator (shows when hovering ability)
        let abilityRangeIndicator = null;
        function showAbilityRange(range, color = 0x4488ff) {
            hideAbilityRange();

            if (!player || !player.mesh) return;

            const ringGeo = new THREE.RingGeometry(range - 0.1, range, 64);
            const ringMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            abilityRangeIndicator = new THREE.Mesh(ringGeo, ringMat);
            abilityRangeIndicator.rotation.x = -Math.PI / 2;
            abilityRangeIndicator.position.copy(player.mesh.position);
            abilityRangeIndicator.position.y = 0.05;
            scene.add(abilityRangeIndicator);
        }

        function hideAbilityRange() {
            if (abilityRangeIndicator) {
                scene.remove(abilityRangeIndicator);
                abilityRangeIndicator = null;
            }
        }

        function updateAbilityRangePosition() {
            if (abilityRangeIndicator && player && player.mesh) {
                abilityRangeIndicator.position.x = player.mesh.position.x;
                abilityRangeIndicator.position.z = player.mesh.position.z;
            }
        }

        // ROUND 8: Added shieldAmount parameter for level scaling
        // ROUND 9: Enhanced with pulsing glow and layered visuals
        function createShield(entity, shieldAmount = 200) {
            // ROUND 3: Shield now provides actual damage absorption
            entity.shieldHealth = shieldAmount;
            entity.shieldActive = true;

            // ROUND 9: Multi-layer shield with pulsing glow
            const shieldGroup = new THREE.Group();

            // Inner solid core
            const innerShield = new THREE.Mesh(
                new THREE.SphereGeometry(1.0, 24, 24),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.15
                })
            );
            shieldGroup.add(innerShield);

            // Wireframe layer
            const wireShield = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 16, 16),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                })
            );
            shieldGroup.add(wireShield);

            // Outer glow layer
            const outerGlow = new THREE.Mesh(
                new THREE.SphereGeometry(1.4, 16, 16),
                new THREE.MeshBasicMaterial({
                    color: 0x88ff88,
                    transparent: true,
                    opacity: 0.2
                })
            );
            shieldGroup.add(outerGlow);

            entity.mesh.add(shieldGroup);
            entity.shieldMesh = shieldGroup;

            // ROUND 9: Pulsing animation
            let pulsePhase = 0;
            let shieldAnimActive = true;
            const pulseShield = () => {
                if (!shieldAnimActive || !entity.shieldActive) return;

                pulsePhase += 0.15;
                const pulse = 0.5 + Math.sin(pulsePhase) * 0.2;
                const scale = 1 + Math.sin(pulsePhase * 0.5) * 0.05;

                wireShield.material.opacity = pulse;
                outerGlow.material.opacity = 0.1 + Math.sin(pulsePhase * 0.7) * 0.1;
                shieldGroup.scale.set(scale, scale, scale);

                // Rotate wireframe slowly
                wireShield.rotation.y += 0.02;
                wireShield.rotation.x += 0.01;

                requestAnimationFrame(pulseShield);
            };
            pulseShield();

            // ROUND 9: Shield spawn burst effect
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const spark = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 })
                );
                spark.position.set(Math.cos(angle) * 1.5, 0.5, Math.sin(angle) * 1.5);
                entity.mesh.add(spark);

                const sparkDir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                let sparkLife = 1;
                const animSpark = () => {
                    sparkLife -= 0.1;
                    spark.position.add(sparkDir.clone().multiplyScalar(0.1));
                    spark.material.opacity = sparkLife;
                    if (sparkLife > 0) requestAnimationFrame(animSpark);
                    else entity.mesh.remove(spark);
                };
                animSpark();
            }

            // Shield expires after 3 seconds OR when depleted
            entity.shieldTimeout = setTimeout(() => {
                if (entity.shieldActive) {
                    entity.shieldActive = false;
                    shieldAnimActive = false;
                    entity.shieldHealth = 0;
                    if (entity.shieldMesh && entity.mesh) {
                        entity.mesh.remove(entity.shieldMesh);
                    }
                    entity.shieldMesh = null;
                }
            }, 3000);
        }

        // ROUND 8: Added damage parameter for level scaling
        function createUlt(pos, damage = 400) {
            // Big Boom
            createExplosion(pos, 0xff00ff, 100);
            // ROUND 2: Heavy screen shake on ultimate
            screenShake.heavy();
            // ROUND 1: Guard against dead player
            if (!player || player.dead) return;
            // AOE Damage - R4: Use SpatialGrid for O(n) instead of O(n¬≤)
            const nearby = SpatialGrid.getNearby(pos.x, pos.z, 10);
            nearby.forEach(({entity}) => {
                if (!entity.dead && entity.team !== player.team) {
                    entity.takeDamage(damage, 'crit');
                }
            });
        }

        // === HERO-SPECIFIC ABILITY FUNCTIONS ===

        // Void Walker - Mana Void: AoE damage based on missing mana
        function createManaVoid(pos, damage) {
            if (!player) return;

            // ROUND 10: AoE indicator showing effect radius
            if (typeof createAoEIndicator !== 'undefined') {
                createAoEIndicator(pos, 8, 0x00ffff, 1500);
            }

            // Visual - swirling void effect
            const voidSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 })
            );
            voidSphere.position.copy(pos);
            voidSphere.position.y = 1;
            scene.add(voidSphere);

            let scale = 0.5;
            const expandVoid = () => {
                scale += 0.5;
                voidSphere.scale.set(scale, scale, scale);
                voidSphere.material.opacity -= 0.05;

                if (scale < 10) {
                    requestAnimationFrame(expandVoid);
                } else {
                    scene.remove(voidSphere);
                }

                // Damage enemies in expanding radius
                if (scale > 1 && scale < 8) {
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            const dist = e.mesh.position.distanceTo(pos);
                            if (dist < scale && dist > scale - 0.5) {
                                const bonusDamage = e.mp ? (e.maxMp - e.mp) * 0.5 : 0;
                                e.takeDamage(damage / 5 + bonusDamage, 'magical');
                            }
                        }
                    });
                }
            };
            expandVoid();

            createExplosion(pos, 0x00ffff, 30);
            screenShake.medium();
        }

        // Iron Clad - Shield Slam: AoE stun
        function createShieldSlam(pos, damage) {
            if (!player) return;

            // ROUND 10: AoE indicator for stun radius
            if (typeof createAoEIndicator !== 'undefined') {
                createAoEIndicator(pos, 5, 0xffaa00, 1000);
            }

            // Visual - shockwave ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.5, 1, 32),
                new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(pos);
            ring.position.y = 0.1;
            scene.add(ring);

            let ringScale = 1;
            const expandRing = () => {
                ringScale += 0.3;
                ring.scale.set(ringScale, ringScale, 1);
                ring.material.opacity -= 0.05;

                if (ring.material.opacity > 0) {
                    requestAnimationFrame(expandRing);
                } else {
                    scene.remove(ring);
                }
            };
            expandRing();

            // Damage and stun enemies - R4: Use SpatialGrid
            const nearby = SpatialGrid.getNearby(pos.x, pos.z, 5);
            nearby.forEach(({entity}) => {
                if (!entity.dead && entity.team !== player.team) {
                    entity.takeDamage(damage, 'physical');
                    entity.stunned = true;
                    entity.stunEndTime = clock.getElapsedTime() + 1.5;
                    createExplosion(entity.mesh.position, 0xffaa00, 5);
                }
            });

            screenShake.medium();
        }

        // Iron Clad - Earthquake: Large AoE damage and slow
        function createEarthquake(pos, damage) {
            if (!player) return;

            // Multiple shockwaves
            for (let wave = 0; wave < 3; wave++) {
                setTimeout(() => {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(1, 2, 32),
                        new THREE.MeshBasicMaterial({ color: 0x885522, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
                    );
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.copy(pos);
                    ring.position.y = 0.1;
                    scene.add(ring);

                    let ringScale = 1;
                    const expand = () => {
                        ringScale += 0.4;
                        ring.scale.set(ringScale, ringScale, 1);
                        ring.material.opacity -= 0.03;
                        if (ring.material.opacity > 0) requestAnimationFrame(expand);
                        else scene.remove(ring);
                    };
                    expand();

                    // Damage enemies - R4: Use SpatialGrid
                    const nearbyEq = SpatialGrid.getNearby(pos.x, pos.z, 12);
                    nearbyEq.forEach(({entity}) => {
                        if (!entity.dead && entity.team !== player.team) {
                            entity.takeDamage(damage / 3, 'physical');
                            entity.speed *= 0.5; // Slow
                            setTimeout(() => { if (entity) entity.speed *= 2; }, 3000);
                        }
                    });

                    screenShake.medium();
                }, wave * 300);
            }
        }

        // Pyromancer - Fireball: Fast fire projectile
        function createFireball(startPos, targetInfo, damage) {
            const projectile = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xff4400 })
            );
            projectile.position.copy(startPos);
            projectile.position.y = 1;

            // Add fire glow
            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.4 })
            );
            projectile.add(glow);

            scene.add(projectile);

            const direction = new THREE.Vector3(targetInfo.x, 0, targetInfo.z).sub(startPos).normalize();
            // R3: Pre-compute move step to avoid clone per frame
            const fireballMoveStep = direction.clone().multiplyScalar(0.8);
            let traveled = 0;

            const moveFireball = () => {
                if (!projectile.parent) return;

                projectile.position.add(fireballMoveStep);
                traveled += 0.8;

                // Fire trail particles
                if (Math.random() > 0.5) {
                    const trail = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15),
                        new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 })
                    );
                    trail.position.copy(projectile.position);
                    scene.add(trail);
                    setTimeout(() => scene.remove(trail), 200);
                }

                // Check collision - R4: Use SpatialGrid
                let hit = false;
                const nearbyFb = SpatialGrid.getNearby(projectile.position.x, projectile.position.z, 1.5);
                for (let i = 0; i < nearbyFb.length && !hit; i++) {
                    const entity = nearbyFb[i].entity;
                    if (!entity.dead && entity.team !== player.team) {
                        entity.takeDamage(damage, 'magical');
                        createExplosion(entity.mesh.position, 0xff4400, 15);
                        hit = true;
                    }
                }

                if (hit || traveled > 30) {
                    createExplosion(projectile.position, 0xff4400, 10);
                    scene.remove(projectile);
                } else {
                    requestAnimationFrame(moveFireball);
                }
            };
            moveFireball();
        }

        // Pyromancer - Inferno: Ring of fire
        function createInferno(pos, damagePerTick) {
            // ROUND 10: AoE indicator for fire ring radius
            if (typeof createAoEIndicator !== 'undefined') {
                createAoEIndicator(pos, 5, 0xff4400, 4000);
            }

            const fireRing = new THREE.Group();

            // Create ring of fire particles
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.3, 1, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 })
                );
                flame.position.set(Math.cos(angle) * 4, 0.5, Math.sin(angle) * 4);
                fireRing.add(flame);
            }

            fireRing.position.copy(pos);
            scene.add(fireRing);

            let duration = 0;
            const burnTick = () => {
                duration += 16;
                fireRing.rotation.y += 0.05;

                // Animate flames
                fireRing.children.forEach((flame, i) => {
                    flame.scale.y = 0.8 + Math.sin(duration * 0.01 + i) * 0.3;
                });

                // Damage enemies in ring - R4: Use SpatialGrid
                if (duration % 500 < 20) {
                    const nearbyRing = SpatialGrid.getNearby(pos.x, pos.z, 5);
                    nearbyRing.forEach(({entity, distSq}) => {
                        const dist = Math.sqrt(distSq);
                        if (!entity.dead && entity.team !== player.team && dist > 3) {
                            entity.takeDamage(damagePerTick, 'magical');
                        }
                    });
                }

                if (duration < 4000) {
                    requestAnimationFrame(burnTick);
                } else {
                    scene.remove(fireRing);
                }
            };
            burnTick();
        }

        // Pyromancer - Meteor: Massive fire explosion at target
        function createMeteor(targetInfo, damage) {
            const targetPos = new THREE.Vector3(targetInfo.x, 0, targetInfo.z);

            // Warning circle
            const warning = new THREE.Mesh(
                new THREE.CircleGeometry(5, 32),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 })
            );
            warning.rotation.x = -Math.PI / 2;
            warning.position.copy(targetPos);
            warning.position.y = 0.05;
            scene.add(warning);

            // Meteor falling
            const meteor = new THREE.Mesh(
                new THREE.SphereGeometry(2, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff4400 })
            );
            meteor.position.copy(targetPos);
            meteor.position.y = 30;
            scene.add(meteor);

            let fallProgress = 0;
            const fallMeteor = () => {
                fallProgress += 0.05;
                meteor.position.y = 30 - fallProgress * 30;
                warning.material.opacity = 0.3 + fallProgress * 0.3;

                if (fallProgress < 1) {
                    requestAnimationFrame(fallMeteor);
                } else {
                    // Impact
                    scene.remove(meteor);
                    scene.remove(warning);
                    createExplosion(targetPos, 0xff4400, 80);
                    screenShake.heavy();

                    // Damage in area - R4: Use SpatialGrid
                    const nearbyMeteor = SpatialGrid.getNearby(targetPos.x, targetPos.z, 6);
                    nearbyMeteor.forEach(({entity, distSq}) => {
                        const dist = Math.sqrt(distSq);
                        if (!entity.dead && entity.team !== player.team) {
                            entity.takeDamage(damage * (1 - dist / 12), 'magical');
                        }
                    });

                    // Leave burning ground
                    createFirePatch(targetPos, 30, 5000);
                }
            };
            setTimeout(fallMeteor, 100);
        }

        // Fire patch that damages over time
        function createFirePatch(pos, damagePerTick, duration) {
            const patch = new THREE.Mesh(
                new THREE.CircleGeometry(1.5, 16),
                new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.5 })
            );
            patch.rotation.x = -Math.PI / 2;
            patch.position.copy(pos);
            patch.position.y = 0.05;
            scene.add(patch);

            let elapsed = 0;
            const burnPatch = () => {
                elapsed += 100;
                patch.material.opacity = 0.5 * (1 - elapsed / duration);

                // Damage tick
                if (player) {
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            if (e.mesh.position.distanceTo(pos) < 1.5) {
                                e.takeDamage(damagePerTick, 'magical');
                            }
                        }
                    });
                }

                if (elapsed < duration) {
                    setTimeout(burnPatch, 100);
                } else {
                    scene.remove(patch);
                }
            };
            burnPatch();
        }

        // Shadow Blade - Fan of Knives
        function createFanOfKnives(startPos, targetPos, damage) {
            const dir = new THREE.Vector3(targetPos.x, 0, targetPos.z).sub(startPos).normalize();
            const baseAngle = Math.atan2(dir.x, dir.z);

            for (let i = -2; i <= 2; i++) {
                const angle = baseAngle + i * 0.3;
                const knifeDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                // R3: Pre-compute move step to avoid clone per frame
                const knifeMoveStep = knifeDir.clone().multiplyScalar(0.6);

                const knife = new THREE.Mesh(
                    new THREE.ConeGeometry(0.1, 0.5, 4),
                    new THREE.MeshBasicMaterial({ color: 0x888888 })
                );
                knife.position.copy(startPos);
                knife.position.y = 1;
                knife.rotation.x = Math.PI / 2;
                knife.rotation.z = -angle;
                scene.add(knife);

                let traveled = 0;
                const moveKnife = () => {
                    knife.position.add(knifeMoveStep);
                    traveled += 0.6;

                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            if (knife.position.distanceTo(e.mesh.position) < 1) {
                                e.takeDamage(damage, 'physical');
                                scene.remove(knife);
                                createExplosion(e.mesh.position, 0x440066, 5);
                            }
                        }
                    });

                    if (traveled < 15 && knife.parent) {
                        requestAnimationFrame(moveKnife);
                    } else if (knife.parent) {
                        scene.remove(knife);
                    }
                };
                moveKnife();
            }
        }

        // Shadow Blade - Death Mark: Mark enemy for bonus damage
        function createDeathMark(pos, damage) {
            if (!player) return;

            let nearestEnemy = null;
            let minDist = 15;

            entities.forEach(e => {
                if (e && !e.dead && e.team !== player.team && e.mesh) {
                    const d = e.mesh.position.distanceTo(pos);
                    if (d < minDist) {
                        minDist = d;
                        nearestEnemy = e;
                    }
                }
            });

            if (nearestEnemy) {
                // Mark visual
                const mark = new THREE.Mesh(
                    new THREE.RingGeometry(1, 1.3, 6),
                    new THREE.MeshBasicMaterial({ color: 0x660066, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                );
                mark.rotation.x = -Math.PI / 2;
                nearestEnemy.mesh.add(mark);

                nearestEnemy.deathMarked = true;

                // Damage after delay
                setTimeout(() => {
                    if (nearestEnemy && !nearestEnemy.dead) {
                        nearestEnemy.takeDamage(damage, 'physical');
                        createExplosion(nearestEnemy.mesh.position, 0x660066, 30);
                        nearestEnemy.mesh.remove(mark);
                        nearestEnemy.deathMarked = false;
                        screenShake.medium();
                    }
                }, 2000);
            }
        }

        // Show damage number floating text
        function showDamageNumber(pos, amount, isCrit = false) {
            const color = isCrit ? '#ff4444' : '#ffffff';
            new FloatingText(Math.round(amount), pos.x, pos.y + 1, pos.z, color);
        }

        // === JUNGLE CAMP SYSTEM ===
        const jungleCamps = [];

        const JUNGLE_CAMP_DEFS = [
            { x: -25, z: -5, tier: 'small', respawnTime: 60, creeps: ['wolf', 'wolf'] },
            { x: -15, z: -20, tier: 'medium', respawnTime: 75, creeps: ['ogre', 'ogre'] },
            { x: -30, z: 15, tier: 'large', respawnTime: 90, creeps: ['centaur', 'centaur'] },
            { x: 25, z: 5, tier: 'small', respawnTime: 60, creeps: ['satyr', 'satyr'] },
            { x: 15, z: 20, tier: 'medium', respawnTime: 75, creeps: ['troll', 'troll'] },
            { x: 30, z: -15, tier: 'large', respawnTime: 90, creeps: ['golem'] },
            { x: 0, z: 0, tier: 'ancient', respawnTime: 180, creeps: ['dragon'] } // Roshan equivalent
        ];

        const JUNGLE_CREEP_DEFS = {
            wolf: { hp: 200, damage: 20, gold: 25, xp: 30, color: 0x666666, size: 0.4 },
            satyr: { hp: 250, damage: 25, gold: 30, xp: 35, color: 0x884422, size: 0.45 },
            ogre: { hp: 400, damage: 35, gold: 45, xp: 50, color: 0x448844, size: 0.6 },
            troll: { hp: 350, damage: 40, gold: 50, xp: 55, color: 0x4444aa, size: 0.55 },
            centaur: { hp: 600, damage: 50, gold: 70, xp: 80, color: 0x884400, size: 0.7 },
            golem: { hp: 800, damage: 60, gold: 100, xp: 120, color: 0x555555, size: 0.9 },
            dragon: { hp: 5000, damage: 150, gold: 500, xp: 1000, color: 0xff4400, size: 2.0 }
        };

        // === DETAILED JUNGLE CREATURE MODELS ===
        const JUNGLE_CREATURE_MODELS = {
            // === WOLF - Pack beast with keen senses ===
            wolf: {
                scale: 0.5,
                bodyParts: [
                    { name: 'body', shape: 'box', width: 0.8, height: 0.6, depth: 1.4, color: '#4a4a50', position: [0, 0.7, 0], shininess: 30 },
                    { name: 'chest', shape: 'sphere', size: 0.4, color: '#5a5a60', position: [0, 0.75, 0.5], shininess: 35 },
                    { name: 'head', shape: 'box', width: 0.4, height: 0.35, depth: 0.5, color: '#555560', position: [0, 0.95, 0.9], shininess: 32 },
                    { name: 'snout', shape: 'box', width: 0.25, height: 0.2, depth: 0.35, color: '#4a4a55', position: [0, 0.88, 1.25], shininess: 28 },
                    { name: 'nose', shape: 'sphere', size: 0.06, color: '#1a1a1a', position: [0, 0.9, 1.45], shininess: 60 },
                    { name: 'eyeL', shape: 'sphere', size: 0.06, color: '#ffcc00', position: [-0.12, 1.0, 1.05], emissive: '#aa8800', shininess: 90 },
                    { name: 'eyeR', shape: 'sphere', size: 0.06, color: '#ffcc00', position: [0.12, 1.0, 1.05], emissive: '#aa8800', shininess: 90 },
                    { name: 'earL', shape: 'cone', size: 0.08, height: 0.2, color: '#555560', position: [-0.15, 1.2, 0.85], rotation: [0.3, 0, -0.3], shininess: 25 },
                    { name: 'earR', shape: 'cone', size: 0.08, height: 0.2, color: '#555560', position: [0.15, 1.2, 0.85], rotation: [0.3, 0, 0.3], shininess: 25 },
                    { name: 'mane', shape: 'sphere', size: 0.35, color: '#3a3a40', position: [0, 0.9, 0.6], shininess: 20 },
                    { name: 'legFL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.06, height: 0.5, color: '#4a4a50', position: [-0.25, 0.25, 0.4], shininess: 28 },
                    { name: 'legFR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.06, height: 0.5, color: '#4a4a50', position: [0.25, 0.25, 0.4], shininess: 28 },
                    { name: 'legBL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.06, height: 0.45, color: '#4a4a50', position: [-0.25, 0.22, -0.5], shininess: 28 },
                    { name: 'legBR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.06, height: 0.45, color: '#4a4a50', position: [0.25, 0.22, -0.5], shininess: 28 },
                    { name: 'tail', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.03, height: 0.5, color: '#4a4a50', position: [0, 0.75, -0.8], rotation: [-0.7, 0, 0], shininess: 25 }
                ]
            },

            // === SATYR - Woodland trickster with hooves ===
            satyr: {
                scale: 0.55,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.7, depth: 0.35, color: '#884422', position: [0, 1.1, 0], shininess: 35 },
                    { name: 'belly', shape: 'sphere', size: 0.25, color: '#996633', position: [0, 0.9, 0.1], shininess: 30 },
                    { name: 'head', shape: 'sphere', size: 0.25, color: '#773311', position: [0, 1.65, 0], shininess: 40 },
                    { name: 'snout', shape: 'box', width: 0.15, height: 0.12, depth: 0.15, color: '#663322', position: [0, 1.55, 0.18], shininess: 35 },
                    { name: 'eyeL', shape: 'sphere', size: 0.05, color: '#ff8800', position: [-0.1, 1.7, 0.15], emissive: '#cc4400', shininess: 90 },
                    { name: 'eyeR', shape: 'sphere', size: 0.05, color: '#ff8800', position: [0.1, 1.7, 0.15], emissive: '#cc4400', shininess: 90 },
                    { name: 'hornL', shape: 'cone', size: 0.06, height: 0.25, color: '#332211', position: [-0.12, 1.9, 0], rotation: [-0.3, 0, -0.4], shininess: 60 },
                    { name: 'hornR', shape: 'cone', size: 0.06, height: 0.25, color: '#332211', position: [0.12, 1.9, 0], rotation: [-0.3, 0, 0.4], shininess: 60 },
                    { name: 'earL', shape: 'box', width: 0.15, height: 0.06, depth: 0.04, color: '#884422', position: [-0.2, 1.7, 0], rotation: [0, 0, -0.3], shininess: 30 },
                    { name: 'earR', shape: 'box', width: 0.15, height: 0.06, depth: 0.04, color: '#884422', position: [0.2, 1.7, 0], rotation: [0, 0, 0.3], shininess: 30 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.45, color: '#885533', position: [-0.32, 1.0, 0], shininess: 32 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.45, color: '#885533', position: [0.32, 1.0, 0], shininess: 32 },
                    { name: 'handL', shape: 'sphere', size: 0.08, color: '#773311', position: [-0.32, 0.72, 0], shininess: 35 },
                    { name: 'handR', shape: 'sphere', size: 0.08, color: '#773311', position: [0.32, 0.72, 0], shininess: 35 },
                    { name: 'waist', shape: 'sphere', size: 0.2, color: '#663322', position: [0, 0.7, 0], shininess: 25 },
                    { name: 'furSkirt', shape: 'cone', size: 0.3, height: 0.35, color: '#553311', position: [0, 0.55, 0], shininess: 20 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.05, height: 0.5, color: '#553311', position: [-0.15, 0.25, 0], shininess: 25 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.05, height: 0.5, color: '#553311', position: [0.15, 0.25, 0], shininess: 25 },
                    { name: 'hoofL', shape: 'box', width: 0.08, height: 0.06, depth: 0.1, color: '#221111', position: [-0.15, 0.03, 0.02], shininess: 70 },
                    { name: 'hoofR', shape: 'box', width: 0.08, height: 0.06, depth: 0.1, color: '#221111', position: [0.15, 0.03, 0.02], shininess: 70 },
                    { name: 'pipe', shape: 'cylinder', radiusTop: 0.015, radiusBottom: 0.02, height: 0.2, color: '#aa8855', position: [0.35, 0.85, 0.1], rotation: [0, 0, 0.3], shininess: 45 }
                ]
            },

            // === OGRE - Hulking brute with massive fists ===
            ogre: {
                scale: 0.7,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 1.0, height: 1.2, depth: 0.8, color: '#448844', position: [0, 1.3, 0], shininess: 25 },
                    { name: 'belly', shape: 'sphere', size: 0.6, color: '#336633', position: [0, 1.0, 0.25], shininess: 20 },
                    { name: 'head', shape: 'sphere', size: 0.45, color: '#55aa55', position: [0, 2.2, 0], shininess: 30 },
                    { name: 'brow', shape: 'box', width: 0.5, height: 0.12, depth: 0.25, color: '#447744', position: [0, 2.35, 0.2], shininess: 25 },
                    { name: 'jaw', shape: 'box', width: 0.35, height: 0.2, depth: 0.25, color: '#448844', position: [0, 2.0, 0.25], shininess: 22 },
                    { name: 'eyeL', shape: 'sphere', size: 0.07, color: '#ff4400', position: [-0.15, 2.3, 0.35], emissive: '#ff2200', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.07, color: '#ff4400', position: [0.15, 2.3, 0.35], emissive: '#ff2200', shininess: 100 },
                    { name: 'tuskL', shape: 'cone', size: 0.06, height: 0.2, color: '#ccccaa', position: [-0.15, 2.0, 0.35], rotation: [0.3, 0, -0.2], shininess: 70 },
                    { name: 'tuskR', shape: 'cone', size: 0.06, height: 0.2, color: '#ccccaa', position: [0.15, 2.0, 0.35], rotation: [0.3, 0, 0.2], shininess: 70 },
                    { name: 'shoulderL', shape: 'sphere', size: 0.35, color: '#448844', position: [-0.7, 1.8, 0], shininess: 28 },
                    { name: 'shoulderR', shape: 'sphere', size: 0.35, color: '#448844', position: [0.7, 1.8, 0], shininess: 28 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.22, height: 0.9, color: '#336633', position: [-0.75, 1.1, 0], shininess: 22 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.22, height: 0.9, color: '#336633', position: [0.75, 1.1, 0], shininess: 22 },
                    { name: 'fistL', shape: 'sphere', size: 0.28, color: '#448844', position: [-0.75, 0.55, 0], shininess: 30 },
                    { name: 'fistR', shape: 'sphere', size: 0.28, color: '#448844', position: [0.75, 0.55, 0], shininess: 30 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.22, radiusBottom: 0.25, height: 0.75, color: '#336633', position: [-0.35, 0.38, 0], shininess: 20 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.22, radiusBottom: 0.25, height: 0.75, color: '#336633', position: [0.35, 0.38, 0], shininess: 20 },
                    { name: 'club', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.15, height: 0.8, color: '#553322', position: [0.85, 0.8, 0.3], rotation: [0.5, 0, 0.3], shininess: 25 },
                    { name: 'clubHead', shape: 'sphere', size: 0.2, color: '#442211', position: [1.0, 0.5, 0.5], shininess: 20 }
                ]
            },

            // === TROLL - Regenerating warrior with spear ===
            troll: {
                scale: 0.65,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 0.6, height: 0.9, depth: 0.4, color: '#4444aa', position: [0, 1.2, 0], shininess: 35 },
                    { name: 'chest', shape: 'sphere', size: 0.35, color: '#5555bb', position: [0, 1.4, 0.15], shininess: 38 },
                    { name: 'head', shape: 'sphere', size: 0.3, color: '#5555bb', position: [0, 1.9, 0], shininess: 40 },
                    { name: 'crest', shape: 'box', width: 0.08, height: 0.3, depth: 0.25, color: '#ff4400', position: [0, 2.15, 0], shininess: 50 },
                    { name: 'eyeL', shape: 'sphere', size: 0.06, color: '#ffff00', position: [-0.12, 1.95, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.06, color: '#ffff00', position: [0.12, 1.95, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'nose', shape: 'cone', size: 0.06, height: 0.15, color: '#4444aa', position: [0, 1.85, 0.28], rotation: [1.5, 0, 0], shininess: 35 },
                    { name: 'earL', shape: 'cone', size: 0.08, height: 0.18, color: '#5555bb', position: [-0.25, 1.95, 0], rotation: [0, 0, -1.2], shininess: 32 },
                    { name: 'earR', shape: 'cone', size: 0.08, height: 0.18, color: '#5555bb', position: [0.25, 1.95, 0], rotation: [0, 0, 1.2], shininess: 32 },
                    { name: 'shoulderL', shape: 'sphere', size: 0.18, color: '#4444aa', position: [-0.42, 1.5, 0], shininess: 35 },
                    { name: 'shoulderR', shape: 'sphere', size: 0.18, color: '#4444aa', position: [0.42, 1.5, 0], shininess: 35 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#5555bb', position: [-0.45, 1.0, 0], shininess: 32 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#5555bb', position: [0.45, 1.0, 0], shininess: 32 },
                    { name: 'handL', shape: 'sphere', size: 0.1, color: '#4444aa', position: [-0.45, 0.65, 0], shininess: 35 },
                    { name: 'handR', shape: 'sphere', size: 0.1, color: '#4444aa', position: [0.45, 0.65, 0], shininess: 35 },
                    { name: 'loincloth', shape: 'cone', size: 0.25, height: 0.3, color: '#553322', position: [0, 0.7, 0], shininess: 20 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.08, height: 0.6, color: '#4444aa', position: [-0.2, 0.3, 0], shininess: 32 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.08, height: 0.6, color: '#4444aa', position: [0.2, 0.3, 0], shininess: 32 },
                    { name: 'spearShaft', shape: 'cylinder', radiusTop: 0.025, radiusBottom: 0.025, height: 1.5, color: '#664422', position: [0.5, 1.1, 0.1], shininess: 30 },
                    { name: 'spearHead', shape: 'cone', size: 0.06, height: 0.2, color: '#888888', position: [0.5, 1.9, 0.1], emissive: '#444444', shininess: 80 }
                ]
            },

            // === CENTAUR - Powerful half-horse warrior ===
            centaur: {
                scale: 0.8,
                bodyParts: [
                    // Horse body
                    { name: 'horseBody', shape: 'box', width: 0.9, height: 0.7, depth: 1.6, color: '#884400', position: [0, 0.8, -0.3], shininess: 35 },
                    { name: 'horseBelly', shape: 'sphere', size: 0.45, color: '#773300', position: [0, 0.65, -0.2], shininess: 30 },
                    { name: 'horseChest', shape: 'sphere', size: 0.5, color: '#885500', position: [0, 0.9, 0.5], shininess: 38 },
                    { name: 'legFL', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.08, height: 0.7, color: '#773300', position: [-0.35, 0.35, 0.4], shininess: 30 },
                    { name: 'legFR', shape: 'cylinder', radiusTop: 0.12, radiusBottom: 0.08, height: 0.7, color: '#773300', position: [0.35, 0.35, 0.4], shininess: 30 },
                    { name: 'legBL', shape: 'cylinder', radiusTop: 0.14, radiusBottom: 0.08, height: 0.65, color: '#773300', position: [-0.35, 0.32, -1.0], shininess: 30 },
                    { name: 'legBR', shape: 'cylinder', radiusTop: 0.14, radiusBottom: 0.08, height: 0.65, color: '#773300', position: [0.35, 0.32, -1.0], shininess: 30 },
                    { name: 'hoofFL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.08, color: '#221100', position: [-0.35, 0.04, 0.4], shininess: 70 },
                    { name: 'hoofFR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.08, color: '#221100', position: [0.35, 0.04, 0.4], shininess: 70 },
                    { name: 'hoofBL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.08, color: '#221100', position: [-0.35, 0.04, -1.0], shininess: 70 },
                    { name: 'hoofBR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.08, color: '#221100', position: [0.35, 0.04, -1.0], shininess: 70 },
                    { name: 'tail', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.02, height: 0.6, color: '#442200', position: [0, 0.9, -1.4], rotation: [-0.8, 0, 0], shininess: 20 },
                    // Human torso
                    { name: 'humanTorso', shape: 'box', width: 0.55, height: 0.7, depth: 0.35, color: '#996644', position: [0, 1.65, 0.4], shininess: 40 },
                    { name: 'humanChest', shape: 'sphere', size: 0.32, color: '#aa7755', position: [0, 1.8, 0.5], shininess: 42 },
                    { name: 'head', shape: 'sphere', size: 0.22, color: '#aa7755', position: [0, 2.2, 0.45], shininess: 45 },
                    { name: 'hair', shape: 'sphere', size: 0.18, color: '#442200', position: [0, 2.35, 0.4], shininess: 25 },
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#ffaa00', position: [-0.08, 2.22, 0.6], emissive: '#cc6600', shininess: 90 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#ffaa00', position: [0.08, 2.22, 0.6], emissive: '#cc6600', shininess: 90 },
                    { name: 'beard', shape: 'cone', size: 0.12, height: 0.15, color: '#553311', position: [0, 2.05, 0.55], rotation: [3.14, 0, 0], shininess: 22 },
                    { name: 'shoulderL', shape: 'sphere', size: 0.15, color: '#885533', position: [-0.38, 1.9, 0.4], shininess: 38 },
                    { name: 'shoulderR', shape: 'sphere', size: 0.15, color: '#885533', position: [0.38, 1.9, 0.4], shininess: 38 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.5, color: '#996644', position: [-0.42, 1.5, 0.4], shininess: 35 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.5, color: '#996644', position: [0.42, 1.5, 0.4], shininess: 35 },
                    { name: 'fistL', shape: 'sphere', size: 0.1, color: '#aa7755', position: [-0.42, 1.2, 0.4], shininess: 40 },
                    { name: 'fistR', shape: 'sphere', size: 0.1, color: '#aa7755', position: [0.42, 1.2, 0.4], shininess: 40 },
                    { name: 'axeHandle', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.03, height: 0.9, color: '#553311', position: [0.5, 1.4, 0.5], rotation: [0.3, 0, 0.2], shininess: 28 },
                    { name: 'axeBlade', shape: 'box', width: 0.35, height: 0.5, depth: 0.05, color: '#888888', position: [0.6, 1.9, 0.6], rotation: [0, 0, 0.3], emissive: '#333333', shininess: 85 }
                ]
            },

            // === GOLEM - Ancient stone construct ===
            golem: {
                scale: 1.0,
                bodyParts: [
                    { name: 'torso', shape: 'box', width: 1.4, height: 1.6, depth: 1.0, color: '#5a5550', position: [0, 1.8, 0], shininess: 20 },
                    { name: 'chest', shape: 'box', width: 1.2, height: 0.8, depth: 0.5, color: '#4a4540', position: [0, 2.2, 0.4], shininess: 22 },
                    { name: 'runeCore', shape: 'sphere', size: 0.35, color: '#ff8844', position: [0, 2.0, 0.6], emissive: '#ff6622', shininess: 100 },
                    { name: 'head', shape: 'box', width: 0.7, height: 0.6, depth: 0.6, color: '#6a6560', position: [0, 3.0, 0], shininess: 25 },
                    { name: 'eyeL', shape: 'sphere', size: 0.1, color: '#ff4400', position: [-0.18, 3.1, 0.28], emissive: '#ff2200', shininess: 95 },
                    { name: 'eyeR', shape: 'sphere', size: 0.1, color: '#ff4400', position: [0.18, 3.1, 0.28], emissive: '#ff2200', shininess: 95 },
                    { name: 'shoulderL', shape: 'sphere', size: 0.5, color: '#5a5550', position: [-1.0, 2.5, 0], shininess: 18 },
                    { name: 'shoulderR', shape: 'sphere', size: 0.5, color: '#5a5550', position: [1.0, 2.5, 0], shininess: 18 },
                    { name: 'armUpperL', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.35, height: 1.0, color: '#4a4540', position: [-1.1, 1.8, 0], shininess: 20 },
                    { name: 'armUpperR', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.35, height: 1.0, color: '#4a4540', position: [1.1, 1.8, 0], shininess: 20 },
                    { name: 'elbowL', shape: 'sphere', size: 0.32, color: '#5a5550', position: [-1.1, 1.2, 0], shininess: 22 },
                    { name: 'elbowR', shape: 'sphere', size: 0.32, color: '#5a5550', position: [1.1, 1.2, 0], shininess: 22 },
                    { name: 'armLowerL', shape: 'cylinder', radiusTop: 0.25, radiusBottom: 0.32, height: 0.85, color: '#4a4540', position: [-1.1, 0.7, 0], shininess: 20 },
                    { name: 'armLowerR', shape: 'cylinder', radiusTop: 0.25, radiusBottom: 0.32, height: 0.85, color: '#4a4540', position: [1.1, 0.7, 0], shininess: 20 },
                    { name: 'fistL', shape: 'box', width: 0.5, height: 0.55, depth: 0.5, color: '#5a5550', position: [-1.1, 0.2, 0], shininess: 25 },
                    { name: 'fistR', shape: 'box', width: 0.5, height: 0.55, depth: 0.5, color: '#5a5550', position: [1.1, 0.2, 0], shininess: 25 },
                    { name: 'waist', shape: 'cylinder', radiusTop: 0.6, radiusBottom: 0.55, height: 0.4, color: '#4a4540', position: [0, 1.0, 0], shininess: 18 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.35, radiusBottom: 0.32, height: 0.9, color: '#5a5550', position: [-0.4, 0.45, 0], shininess: 20 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.35, radiusBottom: 0.32, height: 0.9, color: '#5a5550', position: [0.4, 0.45, 0], shininess: 20 },
                    { name: 'footL', shape: 'box', width: 0.5, height: 0.2, depth: 0.7, color: '#4a4540', position: [-0.4, 0.1, 0.05], shininess: 18 },
                    { name: 'footR', shape: 'box', width: 0.5, height: 0.2, depth: 0.7, color: '#4a4540', position: [0.4, 0.1, 0.05], shininess: 18 },
                    { name: 'crystalBack1', shape: 'cone', size: 0.2, height: 0.6, color: '#ffaa66', position: [-0.35, 2.8, -0.45], rotation: [-0.35, 0, -0.25], emissive: '#ff6622', shininess: 85 },
                    { name: 'crystalBack2', shape: 'cone', size: 0.18, height: 0.5, color: '#ffaa66', position: [0.35, 2.8, -0.45], rotation: [-0.35, 0, 0.25], emissive: '#ff6622', shininess: 85 },
                    { name: 'runeGlow1', shape: 'sphere', size: 0.08, color: '#ff8844', position: [-0.5, 1.7, 0.6], emissive: '#ff6622', shininess: 100 },
                    { name: 'runeGlow2', shape: 'sphere', size: 0.08, color: '#ff8844', position: [0.5, 1.7, 0.6], emissive: '#ff6622', shininess: 100 }
                ]
            },

            // === DRAGON - The Ancient Boss (Roshan equivalent) ===
            dragon: {
                scale: 2.0,
                bodyParts: [
                    // Head and neck
                    { name: 'headMain', shape: 'box', width: 0.6, height: 0.45, depth: 0.75, color: '#881100', position: [0, 1.8, 1.2], shininess: 45 },
                    { name: 'snout', shape: 'box', width: 0.38, height: 0.3, depth: 0.55, color: '#992200', position: [0, 1.72, 1.7], shininess: 42 },
                    { name: 'jawLower', shape: 'box', width: 0.32, height: 0.15, depth: 0.45, color: '#771100', position: [0, 1.55, 1.6], shininess: 40 },
                    { name: 'eyeL', shape: 'sphere', size: 0.09, color: '#ffaa00', position: [-0.22, 1.92, 1.4], emissive: '#ff8800', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.09, color: '#ffaa00', position: [0.22, 1.92, 1.4], emissive: '#ff8800', shininess: 100 },
                    { name: 'hornL', shape: 'cone', size: 0.1, height: 0.45, color: '#331100', position: [-0.25, 2.15, 1.0], rotation: [-0.5, 0, -0.4], shininess: 55 },
                    { name: 'hornR', shape: 'cone', size: 0.1, height: 0.45, color: '#331100', position: [0.25, 2.15, 1.0], rotation: [-0.5, 0, 0.4], shininess: 55 },
                    { name: 'crest', shape: 'box', width: 0.06, height: 0.28, depth: 0.45, color: '#cc2200', position: [0, 2.05, 0.9], shininess: 50 },
                    { name: 'neckSeg1', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.35, height: 0.55, color: '#882200', position: [0, 1.6, 0.7], rotation: [0.35, 0, 0], shininess: 40 },
                    { name: 'neckSeg2', shape: 'cylinder', radiusTop: 0.35, radiusBottom: 0.42, height: 0.55, color: '#772200', position: [0, 1.45, 0.2], rotation: [0.6, 0, 0], shininess: 38 },
                    // Body
                    { name: 'torso', shape: 'box', width: 1.0, height: 0.85, depth: 1.4, color: '#992211', position: [0, 1.0, -0.7], shininess: 35 },
                    { name: 'belly', shape: 'sphere', size: 0.55, color: '#aa3322', position: [0, 0.7, -0.5], shininess: 32 },
                    { name: 'backSpine1', shape: 'cone', size: 0.08, height: 0.25, color: '#661100', position: [0, 1.55, -0.3], shininess: 45 },
                    { name: 'backSpine2', shape: 'cone', size: 0.1, height: 0.3, color: '#661100', position: [0, 1.6, -0.7], shininess: 45 },
                    { name: 'backSpine3', shape: 'cone', size: 0.08, height: 0.25, color: '#661100', position: [0, 1.55, -1.1], shininess: 45 },
                    // Wings
                    { name: 'wingArmL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.12, height: 0.8, color: '#881100', position: [-0.6, 1.35, -0.5], rotation: [0, 0, 0.8], shininess: 38 },
                    { name: 'wingArmR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.12, height: 0.8, color: '#881100', position: [0.6, 1.35, -0.5], rotation: [0, 0, -0.8], shininess: 38 },
                    { name: 'wingMembraneL', shape: 'box', width: 1.6, height: 0.04, depth: 1.0, color: '#661100', position: [-1.3, 1.3, -0.6], rotation: [0, 0, 0.5], shininess: 25 },
                    { name: 'wingMembraneR', shape: 'box', width: 1.6, height: 0.04, depth: 1.0, color: '#661100', position: [1.3, 1.3, -0.6], rotation: [0, 0, -0.5], shininess: 25 },
                    // Legs
                    { name: 'legThighL', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.12, height: 0.55, color: '#882200', position: [-0.4, 0.55, 0], shininess: 35 },
                    { name: 'legThighR', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.12, height: 0.55, color: '#882200', position: [0.4, 0.55, 0], shininess: 35 },
                    { name: 'legShinL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.08, height: 0.35, color: '#772200', position: [-0.4, 0.18, 0.05], shininess: 32 },
                    { name: 'legShinR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.08, height: 0.35, color: '#772200', position: [0.4, 0.18, 0.05], shininess: 32 },
                    { name: 'legBackThighL', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.12, height: 0.55, color: '#882200', position: [-0.4, 0.55, -1.2], shininess: 35 },
                    { name: 'legBackThighR', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.12, height: 0.55, color: '#882200', position: [0.4, 0.55, -1.2], shininess: 35 },
                    { name: 'legBackShinL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.08, height: 0.35, color: '#772200', position: [-0.4, 0.18, -1.15], shininess: 32 },
                    { name: 'legBackShinR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.08, height: 0.35, color: '#772200', position: [0.4, 0.18, -1.15], shininess: 32 },
                    { name: 'clawFL', shape: 'cone', size: 0.06, height: 0.12, color: '#221100', position: [-0.4, 0.03, 0.12], rotation: [1.3, 0, 0], shininess: 70 },
                    { name: 'clawFR', shape: 'cone', size: 0.06, height: 0.12, color: '#221100', position: [0.4, 0.03, 0.12], rotation: [1.3, 0, 0], shininess: 70 },
                    { name: 'clawBL', shape: 'cone', size: 0.06, height: 0.12, color: '#221100', position: [-0.4, 0.03, -1.08], rotation: [1.3, 0, 0], shininess: 70 },
                    { name: 'clawBR', shape: 'cone', size: 0.06, height: 0.12, color: '#221100', position: [0.4, 0.03, -1.08], rotation: [1.3, 0, 0], shininess: 70 },
                    // Tail
                    { name: 'tailBase', shape: 'cylinder', radiusTop: 0.35, radiusBottom: 0.28, height: 0.7, color: '#882200', position: [0, 0.85, -1.7], rotation: [-0.35, 0, 0], shininess: 32 },
                    { name: 'tailMid', shape: 'cylinder', radiusTop: 0.28, radiusBottom: 0.18, height: 0.8, color: '#772200', position: [0, 0.65, -2.4], rotation: [-0.2, 0, 0], shininess: 30 },
                    { name: 'tailEnd', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.08, height: 0.7, color: '#661100', position: [0, 0.55, -3.0], rotation: [-0.1, 0, 0], shininess: 28 },
                    { name: 'tailSpike', shape: 'cone', size: 0.12, height: 0.35, color: '#441100', position: [0, 0.55, -3.5], rotation: [-1.57, 0, 0], shininess: 55 },
                    // Glowing core
                    { name: 'fireCore', shape: 'sphere', size: 0.25, color: '#ff4400', position: [0, 1.1, -0.3], emissive: '#ff2200', shininess: 100 },
                    { name: 'throatGlow', shape: 'sphere', size: 0.12, color: '#ffaa00', position: [0, 1.65, 1.5], emissive: '#ff6600', shininess: 100 }
                ]
            }
        };

        class JungleCreep extends GameEntity {
            constructor(x, z, creepType, campIndex) {
                const def = JUNGLE_CREEP_DEFS[creepType];
                super(x, z, 0, def.color); // Neutral team (0)
                this.creepType = creepType;
                this.campIndex = campIndex;
                this.hp = def.hp;
                this.maxHp = def.hp;
                this.damage = def.damage;
                this.goldReward = def.gold;
                this.xpReward = def.xp;
                this.attackRange = 2;
                this.speed = 0.08;
                this.lastAttack = 0;
                this.homePos = new THREE.Vector3(x, 0, z);
                this.leashRange = 10;

                // Build detailed model from JUNGLE_CREATURE_MODELS
                const modelDef = JUNGLE_CREATURE_MODELS[creepType];
                if (modelDef && modelDef.bodyParts) {
                    this.modelGroup = buildModel(modelDef.bodyParts, modelDef.scale || 1.0);
                    this.mesh.add(this.modelGroup);

                    // Register for animation
                    AnimationSystem.register(this, 'creature');
                } else {
                    // Fallback to simple geometry if no model defined
                    const size = def.size;
                    const bodyGeo = creepType === 'dragon' ?
                        new THREE.BoxGeometry(size * 2, size * 1.5, size * 3) :
                        new THREE.SphereGeometry(size, 8, 8);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: def.color,
                        roughness: 0.7,
                        emissive: def.color,
                        emissiveIntensity: 0.1
                    });
                    this.bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
                    this.bodyMesh.position.y = size;
                    this.mesh.add(this.bodyMesh);

                    // Eyes for fallback
                    const eyeGeo = new THREE.SphereGeometry(size * 0.2);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
                    eye1.position.set(-size * 0.3, size * 1.2, size * 0.4);
                    this.mesh.add(eye1);
                    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
                    eye2.position.set(size * 0.3, size * 1.2, size * 0.4);
                    this.mesh.add(eye2);
                }
            }

            update(dt) {
                if (this.dead) return;

                // Find nearby enemies to attack
                let target = null;
                let minDist = 6;

                entities.forEach(e => {
                    if (e.team !== 0 && !e.dead && e.mesh) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    }
                });

                // Check leash range
                const distFromHome = this.mesh.position.distanceTo(this.homePos);
                if (distFromHome > this.leashRange) {
                    // Return home
                    this.targetPos.copy(this.homePos);
                    this.hp = Math.min(this.hp + 5, this.maxHp); // Regen while returning
                    super.update(dt);
                    return;
                }

                if (target) {
                    if (minDist < this.attackRange) {
                        if (clock.getElapsedTime() - this.lastAttack > 1.0) {
                            target.takeDamage(this.damage, 'physical');
                            this.lastAttack = clock.getElapsedTime();
                            createExplosion(target.mesh.position, 0xff6600, 5);
                        }
                    } else {
                        this.targetPos.copy(target.mesh.position);
                        super.update(dt);
                    }
                }
            }

            die() {
                super.die();
                // Notify camp to start respawn timer
                if (jungleCamps[this.campIndex]) {
                    jungleCamps[this.campIndex].onCreepDeath(this);
                }
            }
        }

        class JungleCamp {
            constructor(def, index) {
                this.def = def;
                this.index = index;
                this.creeps = [];
                this.respawnTimer = 0;
                this.isCleared = false;

                this.spawn();
            }

            spawn() {
                this.creeps = [];
                this.isCleared = false;

                this.def.creeps.forEach((creepType, i) => {
                    const offset = i * 1.5 - (this.def.creeps.length - 1) * 0.75;
                    const creep = new JungleCreep(
                        this.def.x + offset,
                        this.def.z,
                        creepType,
                        this.index
                    );
                    this.creeps.push(creep);
                    entities.push(creep);
                    scene.add(creep.mesh);
                });
            }

            onCreepDeath(creep) {
                const idx = this.creeps.indexOf(creep);
                if (idx > -1) this.creeps.splice(idx, 1);

                if (this.creeps.length === 0) {
                    this.isCleared = true;
                    this.respawnTimer = this.def.respawnTime;
                }
            }

            update(dt) {
                if (this.isCleared && this.respawnTimer > 0) {
                    this.respawnTimer -= dt;
                    if (this.respawnTimer <= 0) {
                        this.spawn();
                    }
                }
            }
        }

        function initJungleCamps() {
            JUNGLE_CAMP_DEFS.forEach((def, i) => {
                jungleCamps.push(new JungleCamp(def, i));
            });
        }

        function updateJungleCamps(dt) {
            jungleCamps.forEach(camp => camp.update(dt));
        }

        // ==========================================
        // RUNE SYSTEM - Power-ups that spawn on map
        // ==========================================
        const RUNE_TYPES = {
            double_damage: {
                name: 'Double Damage',
                icon: '‚öîÔ∏è',
                color: 0xff4400,
                glowColor: 0xff6600,
                duration: 30,
                effect: (hero) => {
                    const originalDamage = hero.damage;
                    hero.damage *= 2;
                    hero.hasDDRune = true;
                    showMessage('DOUBLE DAMAGE! +100% damage for 30s');
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    setTimeout(() => {
                        hero.damage = originalDamage;
                        hero.hasDDRune = false;
                        showMessage('Double Damage expired');
                    }, 30000);
                }
            },
            haste: {
                name: 'Haste',
                icon: 'üí®',
                color: 0x00ffff,
                glowColor: 0x00aaff,
                duration: 20,
                effect: (hero) => {
                    const originalSpeed = hero.speed;
                    hero.speed *= 1.8;
                    hero.hasHasteRune = true;
                    showMessage('HASTE! +80% movement speed for 20s');
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    setTimeout(() => {
                        hero.speed = originalSpeed;
                        hero.hasHasteRune = false;
                        showMessage('Haste expired');
                    }, 20000);
                }
            },
            regeneration: {
                name: 'Regeneration',
                icon: 'üíö',
                color: 0x00ff00,
                glowColor: 0x44ff44,
                duration: 25,
                effect: (hero) => {
                    hero.hasRegenRune = true;
                    showMessage('REGENERATION! Full HP/MP restore over 25s');
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    let ticks = 0;
                    // R4: Store interval ID on hero so it can be cleared on death
                    if (hero.regenInterval) clearInterval(hero.regenInterval);
                    hero.regenInterval = setInterval(() => {
                        if (hero.dead || ticks >= 50) {
                            clearInterval(hero.regenInterval);
                            hero.regenInterval = null;
                            hero.hasRegenRune = false;
                            if (ticks >= 50) showMessage('Regeneration expired');
                            return;
                        }
                        hero.hp = Math.min(hero.hp + hero.maxHp * 0.02, hero.maxHp);
                        hero.mp = Math.min(hero.mp + hero.maxMp * 0.02, hero.maxMp);
                        ticks++;
                    }, 500);
                }
            },
            invisibility: {
                name: 'Invisibility',
                icon: 'üëª',
                color: 0x8844ff,
                glowColor: 0xaa66ff,
                duration: 30,
                effect: (hero) => {
                    hero.isInvisible = true;
                    hero.mesh.traverse(child => {
                        if (child.material) {
                            child.material.transparent = true;
                            child.material.opacity = 0.3;
                        }
                    });
                    showMessage('INVISIBILITY! Hidden for 30s (breaks on attack)');
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    hero.invisTimeout = setTimeout(() => {
                        hero.isInvisible = false;
                        hero.mesh.traverse(child => {
                            if (child.material) child.material.opacity = 1;
                        });
                        showMessage('Invisibility expired');
                    }, 30000);
                }
            },
            arcane: {
                name: 'Arcane',
                icon: 'üíú',
                color: 0xff00ff,
                glowColor: 0xff44ff,
                duration: 40,
                effect: (hero) => {
                    hero.hasArcaneRune = true;
                    hero.cooldownMultiplier = (hero.cooldownMultiplier || 1) * 0.5;
                    showMessage('ARCANE! 50% cooldown reduction for 40s');
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    // R4: Store timeout ID so it can be cleared on death
                    if (hero.arcaneTimeout) clearTimeout(hero.arcaneTimeout);
                    hero.arcaneTimeout = setTimeout(() => {
                        hero.cooldownMultiplier = (hero.cooldownMultiplier || 0.5) / 0.5;
                        hero.hasArcaneRune = false;
                        hero.arcaneTimeout = null;
                        showMessage('Arcane expired');
                    }, 40000);
                }
            },
            illusion: {
                name: 'Illusion',
                icon: 'üë•',
                color: 0x4488ff,
                glowColor: 0x66aaff,
                duration: 60,
                effect: (hero) => {
                    showMessage('ILLUSION! Creates 2 decoys');
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    // Create 2 illusion clones
                    for (let i = 0; i < 2; i++) {
                        const offsetAngle = (i / 2) * Math.PI * 2 + Math.PI / 4;
                        const offsetDist = 3;
                        const illusionX = hero.mesh.position.x + Math.cos(offsetAngle) * offsetDist;
                        const illusionZ = hero.mesh.position.z + Math.sin(offsetAngle) * offsetDist;

                        // Create illusion mesh (copy of hero)
                        const illusionGroup = new THREE.Group();
                        const illusionBody = new THREE.Mesh(
                            new THREE.SphereGeometry(0.6, 8, 6),
                            new THREE.MeshStandardMaterial({
                                color: hero.team === TEAM_RADIANT ? 0x00ff88 : 0xff4444,
                                transparent: true,
                                opacity: 0.5,
                                emissive: 0x4488ff,
                                emissiveIntensity: 0.3
                            })
                        );
                        illusionGroup.add(illusionBody);
                        illusionGroup.position.set(illusionX, 0.8, illusionZ);
                        scene.add(illusionGroup);

                        // Illusion wanders randomly then fades
                        let illusionLife = 60;
                        const illusionUpdate = setInterval(() => {
                            illusionLife--;
                            // Random movement
                            illusionGroup.position.x += (Math.random() - 0.5) * 0.2;
                            illusionGroup.position.z += (Math.random() - 0.5) * 0.2;

                            if (illusionLife <= 10) {
                                illusionBody.material.opacity = illusionLife / 20;
                            }
                            if (illusionLife <= 0) {
                                clearInterval(illusionUpdate);
                                scene.remove(illusionGroup);
                            }
                        }, 1000);
                    }
                }
            },
            bounty: {
                name: 'Bounty',
                icon: 'üí∞',
                color: 0xffd700,
                glowColor: 0xffaa00,
                duration: 0,
                effect: (hero) => {
                    const goldAmount = 100 + Math.floor(gameTime * 2); // Gold scales with game time
                    const xpAmount = 50 + Math.floor(gameTime);
                    hero.gold += goldAmount;
                    hero.xp += xpAmount;
                    hero.checkLevelUp();
                    showMessage(`BOUNTY! +${goldAmount} gold, +${xpAmount} XP`);
                    AudioManager.playGold && AudioManager.playGold();
                    showGoldText(hero.mesh.position, goldAmount);
                }
            },
            wisdom: {
                name: 'Wisdom',
                icon: 'üìñ',
                color: 0xffff00,
                glowColor: 0xffff88,
                duration: 0,
                effect: (hero) => {
                    const xpAmount = 200 + Math.floor(gameTime * 5);
                    hero.xp += xpAmount;
                    hero.checkLevelUp();
                    showMessage(`WISDOM! +${xpAmount} XP`);
                    AudioManager.playPowerup && AudioManager.playPowerup();
                    createExplosion(hero.mesh.position, 0xffff00, 30);
                }
            }
        };

        // Active runes on the map
        const activeRunes = [];
        const RUNE_SPAWN_POSITIONS = [
            { x: -15, z: 15 },   // Top rune spot
            { x: 15, z: -15 },   // Bottom rune spot
            { x: 0, z: 0 },      // Boss pit area (bounty/wisdom only)
            { x: -30, z: -30 },  // Radiant jungle
            { x: 30, z: 30 }     // Dire jungle
        ];
        const RUNE_SPAWN_INTERVAL = 120; // 2 minutes
        let lastRuneSpawn = 0;

        class Rune {
            constructor(x, z, type) {
                this.type = type;
                this.runeData = RUNE_TYPES[type];
                this.collected = false;

                // Create rune visual
                this.group = new THREE.Group();

                // Outer glow ring
                const ringGeo = new THREE.TorusGeometry(0.8, 0.1, 8, 16);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: this.runeData.color,
                    transparent: true,
                    opacity: 0.6
                });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.ring.rotation.x = Math.PI / 2;
                this.group.add(this.ring);

                // Central orb
                const orbGeo = new THREE.SphereGeometry(0.4, 16, 12);
                const orbMat = new THREE.MeshStandardMaterial({
                    color: this.runeData.color,
                    emissive: this.runeData.glowColor,
                    emissiveIntensity: 1.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                this.orb = new THREE.Mesh(orbGeo, orbMat);
                this.orb.position.y = 0.6;
                this.group.add(this.orb);

                // Inner crystal shape
                const crystalGeo = new THREE.OctahedronGeometry(0.25);
                const crystalMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                this.crystal = new THREE.Mesh(crystalGeo, crystalMat);
                this.crystal.position.y = 0.6;
                this.group.add(this.crystal);

                // Point light for glow effect
                this.light = new THREE.PointLight(this.runeData.color, 1.5, 8);
                this.light.position.y = 1;
                this.group.add(this.light);

                this.group.position.set(x, 0.1, z);
                scene.add(this.group);

                this.phase = Math.random() * Math.PI * 2;
                this.bobSpeed = 2 + Math.random();
            }

            update(dt) {
                if (this.collected) return;

                this.phase += dt * this.bobSpeed;

                // Bobbing animation
                this.orb.position.y = 0.6 + Math.sin(this.phase) * 0.15;
                this.crystal.position.y = 0.6 + Math.sin(this.phase) * 0.15;

                // Rotation
                this.ring.rotation.z += dt * 1.5;
                this.crystal.rotation.y += dt * 3;
                this.crystal.rotation.x += dt * 1.5;

                // Pulsing glow
                const pulse = 1 + Math.sin(this.phase * 2) * 0.3;
                this.orb.material.emissiveIntensity = pulse;
                this.light.intensity = 1 + Math.sin(this.phase * 2) * 0.5;

                // Check for hero pickup
                if (player && !player.dead) {
                    const dist = Math.hypot(
                        this.group.position.x - player.mesh.position.x,
                        this.group.position.z - player.mesh.position.z
                    );
                    if (dist < 2) {
                        this.collect(player);
                    }
                }
            }

            collect(hero) {
                if (this.collected) return;
                this.collected = true;

                // Apply rune effect
                this.runeData.effect(hero);

                // Collection animation
                const startY = this.group.position.y;
                let collectPhase = 0;
                const collectAnim = setInterval(() => {
                    collectPhase += 0.1;
                    this.group.position.y = startY + collectPhase * 2;
                    this.group.scale.setScalar(1 - collectPhase / 2);
                    this.orb.material.opacity = 1 - collectPhase / 2;
                    this.ring.material.opacity = 0.6 * (1 - collectPhase / 2);

                    if (collectPhase >= 1) {
                        clearInterval(collectAnim);
                        scene.remove(this.group);
                        const idx = activeRunes.indexOf(this);
                        if (idx !== -1) activeRunes.splice(idx, 1);
                    }
                }, 30);

                // Particle burst
                createExplosion(this.group.position, this.runeData.color, 25);
            }

            destroy() {
                scene.remove(this.group);
            }
        }

        function spawnRune(position, forcedType = null) {
            // Determine rune type
            let runeType;
            if (forcedType) {
                runeType = forcedType;
            } else {
                const types = Object.keys(RUNE_TYPES);
                // Bounty/wisdom more common at boss pit and jungle spots
                if (position.x === 0 && position.z === 0) {
                    runeType = Math.random() < 0.5 ? 'bounty' : 'wisdom';
                } else if (Math.abs(position.x) >= 25) {
                    runeType = Math.random() < 0.6 ? 'bounty' : types[Math.floor(Math.random() * types.length)];
                } else {
                    // Power runes at river spots
                    const powerRunes = ['double_damage', 'haste', 'regeneration', 'invisibility', 'arcane', 'illusion'];
                    runeType = powerRunes[Math.floor(Math.random() * powerRunes.length)];
                }
            }

            const rune = new Rune(position.x, position.z, runeType);
            activeRunes.push(rune);
            return rune;
        }

        function initRunes() {
            // Spawn initial bounty runes
            spawnRune(RUNE_SPAWN_POSITIONS[3], 'bounty'); // Radiant jungle
            spawnRune(RUNE_SPAWN_POSITIONS[4], 'bounty'); // Dire jungle
        }

        function updateRunes(dt) {
            // Update existing runes
            activeRunes.forEach(rune => rune.update(dt));

            // Spawn new runes periodically
            if (gameTime - lastRuneSpawn >= RUNE_SPAWN_INTERVAL) {
                lastRuneSpawn = gameTime;

                // Spawn power runes at river spots
                if (activeRunes.filter(r => r.group.position.x === -15).length === 0) {
                    spawnRune(RUNE_SPAWN_POSITIONS[0]);
                }
                if (activeRunes.filter(r => r.group.position.x === 15).length === 0) {
                    spawnRune(RUNE_SPAWN_POSITIONS[1]);
                }

                // Spawn bounty runes in jungles
                if (activeRunes.filter(r => r.group.position.x === -30).length === 0) {
                    spawnRune(RUNE_SPAWN_POSITIONS[3], 'bounty');
                }
                if (activeRunes.filter(r => r.group.position.x === 30).length === 0) {
                    spawnRune(RUNE_SPAWN_POSITIONS[4], 'bounty');
                }

                showMessage('Runes have spawned!');
            }
        }

        function spawnFloatingText(amt, pos, color) {
            // ROUND 1: Respect settings
            if (!gameSettings.showDamageNumbers) return;
            new FloatingText(Math.round(amt), pos.x, pos.y, pos.z, color);
        }

        // ROUND 8: Show gold gain floating text
        function showGoldText(pos, amount) {
            new FloatingText(`+${amount}g`, pos.x, pos.y + 1, pos.z, '#ffd700');
        }

        // Map details - trees, rocks, lanes
        // Environment decoration storage for animations
        const environmentObjects = {
            grass: [],
            fireflies: [],
            waterRipples: []
        };

        function createMapDetails() {
            // Lane paths (lighter ground) with stone texture effect
            const laneMat = new THREE.MeshStandardMaterial({ color: 0x3a4a3a, roughness: 0.6, metalness: 0.1 });

            // Mid lane (diagonal from Radiant to Dire)
            const midLane = new THREE.Mesh(new THREE.PlaneGeometry(8, 130), laneMat);
            midLane.rotation.x = -Math.PI / 2;
            midLane.rotation.z = Math.PI / 4;
            midLane.position.y = 0.01;
            scene.add(midLane);

            // Lane edge markers for mid lane
            createLaneEdgeMarkers(-46, -46, 46, 46, 20);

            // Top lane - left side (vertical) then top (horizontal)
            const topLane1 = new THREE.Mesh(new THREE.PlaneGeometry(6, 90), laneMat);
            topLane1.rotation.x = -Math.PI / 2;
            topLane1.position.set(-42, 0.01, 0);
            scene.add(topLane1);
            const topLane2 = new THREE.Mesh(new THREE.PlaneGeometry(90, 6), laneMat);
            topLane2.rotation.x = -Math.PI / 2;
            topLane2.position.set(0, 0.01, 42);
            scene.add(topLane2);

            // Bot lane - bottom (horizontal) then right side (vertical)
            const botLane1 = new THREE.Mesh(new THREE.PlaneGeometry(90, 6), laneMat);
            botLane1.rotation.x = -Math.PI / 2;
            botLane1.position.set(0, 0.01, -42);
            scene.add(botLane1);
            const botLane2 = new THREE.Mesh(new THREE.PlaneGeometry(6, 90), laneMat);
            botLane2.rotation.x = -Math.PI / 2;
            botLane2.position.set(42, 0.01, 0);
            scene.add(botLane2);

            // Trees (scattered around jungle areas) - more variety
            const treePositions = [
                [-30, -10], [-25, -20], [-15, -30], [-35, -25],
                [30, 10], [25, 20], [15, 30], [35, 25],
                [-10, 20], [-20, 30], [10, -20], [20, -30],
                [-30, 30], [30, -30], [-15, 15], [15, -15],
                [-28, -15], [-22, -25], [28, 15], [22, 25],
                [-18, 28], [18, -28], [-33, 18], [33, -18]
            ];

            treePositions.forEach(([x, z], i) => {
                const treeType = i % 3; // Variety of tree types
                createTree(x + (Math.random() - 0.5) * 5, z + (Math.random() - 0.5) * 5, treeType);
            });

            // Rocks
            const rockPositions = [
                [-20, -5], [20, 5], [-5, -25], [5, 25],
                [-35, 0], [35, 0], [0, -35], [0, 35],
                [-25, 15], [25, -15], [-12, -18], [12, 18]
            ];

            rockPositions.forEach(([x, z]) => {
                createRock(x + (Math.random() - 0.5) * 3, z + (Math.random() - 0.5) * 3);
            });

            // Grass patches throughout jungle
            createGrassPatches();

            // Shrubs and bushes
            createShrubs();

            // River (diagonal water through middle) with animated ripples
            const riverMat = new THREE.MeshStandardMaterial({
                color: 0x1a5a7a, roughness: 0.2, metalness: 0.6,
                emissive: 0x0a3a4a, emissiveIntensity: 0.4
            });
            const river = new THREE.Mesh(new THREE.PlaneGeometry(12, 120), riverMat);
            river.rotation.x = -Math.PI / 2;
            river.rotation.z = Math.PI / 4 + 0.3;
            river.position.y = 0.02;
            scene.add(river);

            // River banks (darker edges)
            createRiverBanks();

            // Fireflies in jungle areas
            createFireflies();

            // Base areas (team colored ground) with decorative rings
            const radiantBaseMat = new THREE.MeshStandardMaterial({
                color: 0x0a3a1a, roughness: 0.7,
                emissive: 0x002200, emissiveIntensity: 0.2
            });
            const radiantBase = new THREE.Mesh(new THREE.CircleGeometry(15, 24), radiantBaseMat);
            radiantBase.rotation.x = -Math.PI / 2;
            radiantBase.position.set(-45, 0.01, -45);
            scene.add(radiantBase);

            // Radiant decorative ring
            const radiantRing = new THREE.Mesh(
                new THREE.RingGeometry(14, 15.5, 24),
                new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 })
            );
            radiantRing.rotation.x = -Math.PI / 2;
            radiantRing.position.set(-45, 0.02, -45);
            scene.add(radiantRing);

            const direBaseMat = new THREE.MeshStandardMaterial({
                color: 0x3a0a0a, roughness: 0.7,
                emissive: 0x220000, emissiveIntensity: 0.2
            });
            const direBase = new THREE.Mesh(new THREE.CircleGeometry(15, 24), direBaseMat);
            direBase.rotation.x = -Math.PI / 2;
            direBase.position.set(45, 0.01, 45);
            scene.add(direBase);

            // Dire decorative ring
            const direRing = new THREE.Mesh(
                new THREE.RingGeometry(14, 15.5, 24),
                new THREE.MeshBasicMaterial({ color: 0xff3333, transparent: true, opacity: 0.3 })
            );
            direRing.rotation.x = -Math.PI / 2;
            direRing.position.set(45, 0.02, 45);
            scene.add(direRing);

            // Jungle camp markers
            createJungleCampAreas();

            // Rune spots
            createRuneSpots();

            // Boss pit (Dragon)
            createBossPit();

            // Secret shop areas
            createSecretShops();
        }

        function createLaneEdgeMarkers(x1, z1, x2, z2, count) {
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            for (let i = 0; i < count; i++) {
                const t = i / (count - 1);
                const x = x1 + (x2 - x1) * t;
                const z = z1 + (z2 - z1) * t;
                const marker = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.3), markerMat);
                marker.position.set(x + 3, 0.05, z + 3);
                scene.add(marker);
                const marker2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.3), markerMat);
                marker2.position.set(x - 3, 0.05, z - 3);
                scene.add(marker2);
            }
        }

        function createGrassPatches() {
            const grassPositions = [];
            // Generate grass in jungle areas (avoiding lanes)
            for (let i = 0; i < 150; i++) {
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                // Avoid lane areas and bases
                if (Math.abs(x) < 4 && Math.abs(z) < 4) continue;
                if (Math.abs(x + z) < 8) continue; // Mid lane
                if (Math.abs(x) > 40 && Math.abs(z) < 6) continue; // Side lanes
                if (Math.abs(z) > 40 && Math.abs(x) < 6) continue;
                if (x < -35 && z < -35) continue; // Radiant base
                if (x > 35 && z > 35) continue; // Dire base

                grassPositions.push([x, z]);
            }

            grassPositions.forEach(([x, z]) => {
                const grassGroup = new THREE.Group();
                const bladeCount = 3 + Math.floor(Math.random() * 4);

                for (let i = 0; i < bladeCount; i++) {
                    const height = 0.3 + Math.random() * 0.4;
                    const blade = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, height, 4),
                        new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(0.28 + Math.random() * 0.08, 0.6, 0.25),
                            roughness: 0.9
                        })
                    );
                    blade.position.set(
                        (Math.random() - 0.5) * 0.5,
                        height / 2,
                        (Math.random() - 0.5) * 0.5
                    );
                    blade.rotation.x = (Math.random() - 0.5) * 0.3;
                    blade.rotation.z = (Math.random() - 0.5) * 0.3;
                    grassGroup.add(blade);
                }

                grassGroup.position.set(x, 0, z);
                scene.add(grassGroup);
                environmentObjects.grass.push(grassGroup);
            });
        }

        function createShrubs() {
            const shrubPositions = [
                [-25, -8], [-18, -22], [25, 8], [18, 22],
                [-8, 25], [8, -25], [-32, 12], [32, -12],
                [-15, -15], [15, 15], [-28, 28], [28, -28]
            ];

            shrubPositions.forEach(([x, z]) => {
                const shrub = new THREE.Group();

                // Multiple small spheres for bush effect
                for (let i = 0; i < 5; i++) {
                    const size = 0.4 + Math.random() * 0.3;
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(size, 6, 6),
                        new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.5, 0.2),
                            roughness: 0.9
                        })
                    );
                    leaf.position.set(
                        (Math.random() - 0.5) * 1,
                        size * 0.8,
                        (Math.random() - 0.5) * 1
                    );
                    shrub.add(leaf);
                }

                shrub.position.set(x + (Math.random() - 0.5) * 3, 0, z + (Math.random() - 0.5) * 3);
                scene.add(shrub);
            });
        }

        function createRiverBanks() {
            const bankMat = new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.9 });

            // Create bank edges along the river
            for (let i = 0; i < 15; i++) {
                const t = (i / 14) * 2 - 1;
                const x = t * 42;
                const z = t * 42 + 8;

                const bank1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 1.5), bankMat);
                bank1.position.set(x + 5, 0.08, z);
                bank1.rotation.y = Math.PI / 4;
                scene.add(bank1);

                const bank2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 1.5), bankMat);
                bank2.position.set(x - 5, 0.08, z - 8);
                bank2.rotation.y = Math.PI / 4;
                scene.add(bank2);
            }
        }

        function createFireflies() {
            // Create glowing particles in jungle areas
            const fireflyPositions = [
                [-25, -15], [-20, -25], [25, 15], [20, 25],
                [-15, 25], [15, -25], [-30, 20], [30, -20],
                [-10, -10], [10, 10]
            ];

            fireflyPositions.forEach(([x, z]) => {
                for (let i = 0; i < 3; i++) {
                    const firefly = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshBasicMaterial({
                            color: 0xffff88,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    firefly.position.set(
                        x + (Math.random() - 0.5) * 5,
                        1 + Math.random() * 2,
                        z + (Math.random() - 0.5) * 5
                    );
                    firefly.userData.baseY = firefly.position.y;
                    firefly.userData.phase = Math.random() * Math.PI * 2;
                    firefly.userData.speed = 0.5 + Math.random() * 0.5;
                    scene.add(firefly);
                    environmentObjects.fireflies.push(firefly);
                }
            });
        }

        function createJungleCampAreas() {
            // Jungle camp ground markers
            const campPositions = [
                { x: -25, z: -5, color: 0x2a2a1a },  // Radiant jungle
                { x: -15, z: -20, color: 0x2a2a1a },
                { x: 25, z: 5, color: 0x2a1a1a },   // Dire jungle
                { x: 15, z: 20, color: 0x2a1a1a }
            ];

            campPositions.forEach(camp => {
                const campGround = new THREE.Mesh(
                    new THREE.CircleGeometry(4, 12),
                    new THREE.MeshStandardMaterial({
                        color: camp.color,
                        roughness: 0.85
                    })
                );
                campGround.rotation.x = -Math.PI / 2;
                campGround.position.set(camp.x, 0.015, camp.z);
                scene.add(campGround);

                // Bones/debris decoration
                for (let i = 0; i < 3; i++) {
                    const bone = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.03, 0.4, 6),
                        new THREE.MeshStandardMaterial({ color: 0xccccaa, roughness: 0.8 })
                    );
                    bone.position.set(
                        camp.x + (Math.random() - 0.5) * 4,
                        0.1,
                        camp.z + (Math.random() - 0.5) * 4
                    );
                    bone.rotation.set(Math.random(), Math.random(), Math.PI / 2);
                    scene.add(bone);
                }
            });
        }

        function createRuneSpots() {
            // Power rune spots near river
            const runePositions = [
                { x: -15, z: 15 },
                { x: 15, z: -15 }
            ];

            runePositions.forEach(pos => {
                // Glowing rune circle
                const runeCircle = new THREE.Mesh(
                    new THREE.RingGeometry(1.2, 1.5, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.5,
                        side: THREE.DoubleSide
                    })
                );
                runeCircle.rotation.x = -Math.PI / 2;
                runeCircle.position.set(pos.x, 0.03, pos.z);
                scene.add(runeCircle);

                // Inner glow
                const innerGlow = new THREE.Mesh(
                    new THREE.CircleGeometry(1, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0xff8800,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                innerGlow.rotation.x = -Math.PI / 2;
                innerGlow.position.set(pos.x, 0.025, pos.z);
                scene.add(innerGlow);
            });
        }

        // Boss Pit (Dragon Pit) at center of map
        function createBossPit() {
            // Dark pit ground
            const pitGround = new THREE.Mesh(
                new THREE.CircleGeometry(8, 24),
                new THREE.MeshStandardMaterial({
                    color: 0x1a0a0a,
                    roughness: 0.9,
                    emissive: 0x110000,
                    emissiveIntensity: 0.3
                })
            );
            pitGround.rotation.x = -Math.PI / 2;
            pitGround.position.set(0, 0.02, 0);
            scene.add(pitGround);

            // Lava ring around pit
            const lavaRing = new THREE.Mesh(
                new THREE.RingGeometry(7, 8.5, 24),
                new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                })
            );
            lavaRing.rotation.x = -Math.PI / 2;
            lavaRing.position.set(0, 0.025, 0);
            scene.add(lavaRing);
            environmentObjects.lavaRing = lavaRing;

            // Inner glow circle
            const innerGlow = new THREE.Mesh(
                new THREE.RingGeometry(5, 6, 24),
                new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                })
            );
            innerGlow.rotation.x = -Math.PI / 2;
            innerGlow.position.set(0, 0.03, 0);
            scene.add(innerGlow);
            environmentObjects.pitGlow = innerGlow;

            // Skull decorations around pit
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const skull = new THREE.Group();

                // Skull base
                const skullHead = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 6),
                    new THREE.MeshStandardMaterial({ color: 0xccbbaa, roughness: 0.8 })
                );
                skull.add(skullHead);

                // Eye sockets (dark)
                const eyeL = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                eyeL.position.set(-0.1, 0.05, 0.2);
                skull.add(eyeL);

                const eyeR = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                eyeR.position.set(0.1, 0.05, 0.2);
                skull.add(eyeR);

                skull.position.set(
                    Math.cos(angle) * 9,
                    0.2,
                    Math.sin(angle) * 9
                );
                skull.lookAt(0, 0.2, 0);
                scene.add(skull);
            }

            // Pit label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff4400';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('DRAGON PIT', 128, 40);

            const labelTexture = new THREE.CanvasTexture(canvas);
            const labelSprite = new THREE.Sprite(
                new THREE.SpriteMaterial({ map: labelTexture, transparent: true })
            );
            labelSprite.position.set(0, 4, -10);
            labelSprite.scale.set(8, 2, 1);
            scene.add(labelSprite);
        }

        // Secret Shop areas
        function createSecretShops() {
            const shopPositions = [
                { x: -35, z: 25, team: 'radiant' },  // Radiant secret shop
                { x: 35, z: -25, team: 'dire' }      // Dire secret shop
            ];

            shopPositions.forEach(shop => {
                // Shop platform
                const platform = new THREE.Mesh(
                    new THREE.CircleGeometry(3, 12),
                    new THREE.MeshStandardMaterial({
                        color: shop.team === 'radiant' ? 0x1a3a2a : 0x3a1a1a,
                        roughness: 0.6
                    })
                );
                platform.rotation.x = -Math.PI / 2;
                platform.position.set(shop.x, 0.02, shop.z);
                scene.add(platform);

                // Shop building (small hut)
                const hutGroup = new THREE.Group();

                // Hut base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1.5, 2),
                    new THREE.MeshStandardMaterial({
                        color: 0x4a3a2a,
                        roughness: 0.8
                    })
                );
                base.position.y = 0.75;
                hutGroup.add(base);

                // Roof
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(1.8, 1, 4),
                    new THREE.MeshStandardMaterial({
                        color: shop.team === 'radiant' ? 0x2a5a3a : 0x5a2a2a,
                        roughness: 0.7
                    })
                );
                roof.position.y = 2;
                roof.rotation.y = Math.PI / 4;
                hutGroup.add(roof);

                // Shop sign
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 2),
                    new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
                );
                signPost.position.set(1.5, 1, 0);
                hutGroup.add(signPost);

                const sign = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.6, 0.1),
                    new THREE.MeshStandardMaterial({
                        color: 0x2a1a0a,
                        emissive: shop.team === 'radiant' ? 0x004400 : 0x440000,
                        emissiveIntensity: 0.5
                    })
                );
                sign.position.set(1.5, 1.8, 0);
                hutGroup.add(sign);

                hutGroup.position.set(shop.x, 0, shop.z);
                scene.add(hutGroup);

                // Glowing aura
                const aura = new THREE.Mesh(
                    new THREE.RingGeometry(2.5, 3, 16),
                    new THREE.MeshBasicMaterial({
                        color: shop.team === 'radiant' ? 0x00ff88 : 0xff3333,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    })
                );
                aura.rotation.x = -Math.PI / 2;
                aura.position.set(shop.x, 0.03, shop.z);
                scene.add(aura);
            });
        }

        // Animate environment objects
        function updateEnvironment(dt) {
            const time = clock.getElapsedTime();

            // Animate grass swaying
            environmentObjects.grass.forEach((grass, i) => {
                grass.children.forEach((blade, j) => {
                    blade.rotation.z = Math.sin(time * 2 + i * 0.5 + j * 0.3) * 0.1;
                });
            });

            // Animate fireflies
            environmentObjects.fireflies.forEach((firefly, i) => {
                firefly.position.y = firefly.userData.baseY + Math.sin(time * firefly.userData.speed + firefly.userData.phase) * 0.5;
                firefly.position.x += Math.sin(time * 0.3 + i) * 0.01;
                firefly.position.z += Math.cos(time * 0.3 + i * 1.5) * 0.01;
                firefly.material.opacity = 0.5 + Math.sin(time * 3 + firefly.userData.phase) * 0.4;
            });

            // Animate boss pit lava glow
            if (environmentObjects.lavaRing) {
                environmentObjects.lavaRing.material.opacity = 0.4 + Math.sin(time * 2) * 0.2;
            }
            if (environmentObjects.pitGlow) {
                environmentObjects.pitGlow.material.opacity = 0.2 + Math.sin(time * 3 + 1) * 0.15;
            }
        }

        function createTree(x, z, treeType = 0) {
            const tree = new THREE.Group();

            // Tree type variations
            const treeConfigs = [
                { // Type 0: Standard tree
                    trunkHeight: 2, trunkRadius: [0.2, 0.3],
                    trunkColor: 0x4a3020, leafColor: 0x1a4a1a,
                    leafSize: 1.2, leafCount: 2
                },
                { // Type 1: Tall pine
                    trunkHeight: 3, trunkRadius: [0.15, 0.25],
                    trunkColor: 0x3a2515, leafColor: 0x0a3a0a,
                    leafSize: 0.8, leafCount: 3
                },
                { // Type 2: Wide oak
                    trunkHeight: 1.5, trunkRadius: [0.3, 0.4],
                    trunkColor: 0x5a4030, leafColor: 0x2a5a2a,
                    leafSize: 1.5, leafCount: 4
                }
            ];

            const config = treeConfigs[treeType % treeConfigs.length];

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(config.trunkRadius[0], config.trunkRadius[1], config.trunkHeight, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: config.trunkColor, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = config.trunkHeight / 2;
            tree.add(trunk);

            // Foliage based on tree type
            const leafMat = new THREE.MeshStandardMaterial({
                color: config.leafColor, roughness: 0.8,
                emissive: new THREE.Color(config.leafColor).multiplyScalar(0.3), emissiveIntensity: 0.15
            });

            if (treeType === 1) {
                // Pine tree - stacked cones
                for (let i = 0; i < config.leafCount; i++) {
                    const size = config.leafSize * (1 - i * 0.2);
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(size, size * 1.5, 6), leafMat);
                    cone.position.y = config.trunkHeight + i * 0.7;
                    tree.add(cone);
                }
            } else {
                // Regular tree - spherical foliage
                const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(config.leafSize, 6, 6), leafMat);
                leaf1.position.y = config.trunkHeight + 0.5;
                leaf1.scale.set(1, 0.8, 1);
                tree.add(leaf1);

                for (let i = 1; i < config.leafCount; i++) {
                    const angle = (i / config.leafCount) * Math.PI * 2;
                    const leaf = new THREE.Mesh(new THREE.SphereGeometry(config.leafSize * 0.6, 6, 6), leafMat);
                    leaf.position.set(
                        Math.cos(angle) * config.leafSize * 0.5,
                        config.trunkHeight + 0.8 + Math.random() * 0.5,
                        Math.sin(angle) * config.leafSize * 0.5
                    );
                    tree.add(leaf);
                }
            }

            tree.position.set(x, 0, z);
            tree.scale.setScalar(0.8 + Math.random() * 0.4);
            scene.add(tree);
        }

        function createRock(x, z) {
            const rockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.5, 0);
            const rockMat = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a, roughness: 0.9,
                flatShading: true
            });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, 0.3, z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.scale.set(1, 0.6, 1);
            scene.add(rock);
        }

        // --- CORE FUNCTIONS ---

        function init() {
            // ROUND 3: Initialize audio system
            AudioManager.init();

            // CONSENSUS: Initialize explosion pool
            ExplosionPool.init();

            // R2: Initialize vector pool
            VecPool.init();

            // Setup Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050508, 20, 80); // Distance fog for atmosphere

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 30, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Shadows ON
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Post Processing
            const renderPass = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404060, 0.6); // Blue-ish ambient
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -50;
            sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50;
            sun.shadow.camera.bottom = -50;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // Environment
            const gridHelper = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
            scene.add(gridHelper);

            // Visual Ground with procedural grass texture
            const planeGeo = new THREE.PlaneGeometry(200, 200, 50, 50);

            // Create procedural ground texture
            const groundCanvas = document.createElement('canvas');
            groundCanvas.width = 512;
            groundCanvas.height = 512;
            const gCtx = groundCanvas.getContext('2d');

            // Base grass color
            gCtx.fillStyle = '#1a2a1a';
            gCtx.fillRect(0, 0, 512, 512);

            // Add noise/grass texture variation
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const shade = Math.random() * 30;
                gCtx.fillStyle = `rgb(${26 + shade}, ${42 + shade}, ${26 + shade})`;
                gCtx.fillRect(x, y, 2, 3);
            }

            // Add dirt patches
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                gCtx.fillStyle = `rgba(60, 45, 30, ${0.2 + Math.random() * 0.2})`;
                gCtx.beginPath();
                gCtx.arc(x, y, 5 + Math.random() * 15, 0, Math.PI * 2);
                gCtx.fill();
            }

            // Add some lighter grass highlights
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                gCtx.fillStyle = `rgba(50, 80, 40, ${0.3 + Math.random() * 0.3})`;
                gCtx.fillRect(x, y, 1, 4);
            }

            const groundTexture = new THREE.CanvasTexture(groundCanvas);
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(8, 8);

            const planeMat = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create map details
            createMapDetails();

            // Initialize jungle camps
            initJungleCamps();

            // Initialize rune system
            initRunes();

            // LOGIC GROUND (Invisible, for reliable raycasting)
            const hitGeo = new THREE.PlaneGeometry(500, 500);
            const hitMat = new THREE.MeshBasicMaterial({ visible: false });
            window.hitPlane = new THREE.Mesh(hitGeo, hitMat); // Global for access
            window.hitPlane.rotation.x = -Math.PI / 2;
            scene.add(window.hitPlane);

            // Init Player with selected hero type
            player = new Hero(-42, -42, TEAM_RADIANT, selectedHeroType || 'voidwalker');
            entities.push(player);
            initPortrait();
            initMinimapClick();
            updateHeroUI(); // Update UI with hero-specific info

            // Structures - Bases
            radiantBase = new Structure(-45, -45, 'base', TEAM_RADIANT);
            direBase = new Structure(45, 45, 'base', TEAM_DIRE);
            entities.push(radiantBase);
            entities.push(direBase);

            // Towers for all 3 lanes
            for (const [laneName, lane] of Object.entries(LANES)) {
                // Radiant towers
                lane.towers.radiant.forEach(pos => {
                    entities.push(new Structure(pos.x, pos.z, 'tower', TEAM_RADIANT));
                });
                // Dire towers
                lane.towers.dire.forEach(pos => {
                    entities.push(new Structure(pos.x, pos.z, 'tower', TEAM_DIRE));
                });
            }

            // Inputs
            window.addEventListener('contextmenu', e => e.preventDefault()); // BLOCK RIGHT CLICK MENU
            window.addEventListener('mousedown', onMouseDown);
            // ROUND 5: Touch support for mobile
            window.addEventListener('touchstart', onTouchStart, { passive: false });

            // ROUND 1: Player death guards on keyboard
            // ROUND 2: Added Escape for pause
            // ROUND 9: Added B for shop
            window.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    togglePause();
                    return;
                }
                // ROUND 9: Shop toggle
                if (e.key.toLowerCase() === 'b') {
                    toggleShop();
                    return;
                }
                // ROUND 11: Help toggle
                if (e.key.toLowerCase() === 'h') {
                    toggleHelp();
                    return;
                }
                // ROUND 10: Toggle match stats with Tab
                if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleMatchStats();
                    return;
                }
                if (gameState !== 'playing') return;
                if (!player || player.dead) return;
                if (['q', 'w', 'e', 'r'].includes(e.key.toLowerCase())) player.cast(e.key.toLowerCase());
                // ROUND 10: Item hotkeys 1-6
                if (['1', '2', '3', '4', '5', '6'].includes(e.key)) {
                    const slotIndex = parseInt(e.key) - 1;
                    if (player.inventory && player.inventory[slotIndex]) {
                        const itemId = player.inventory[slotIndex];
                        const item = ITEMS[itemId];
                        if (item && item.hasActive) {
                            useItemActive(itemId, item);
                        }
                    }
                }
                // ROUND 10: F5 for quick-buy
                if (e.key === 'F5') {
                    e.preventDefault();
                    buyQuickBuyItems();
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // ROUND 10: Ability range indicator on hover
            const abilityRanges = { q: 10, w: 8, e: 5, r: 12 };
            ['q', 'w', 'e', 'r'].forEach(key => {
                const abilityEl = document.getElementById(`ab-${key}`);
                if (abilityEl) {
                    abilityEl.addEventListener('mouseenter', () => {
                        if (player && player.heroDef) {
                            const range = abilityRanges[key];
                            const abilityColor = key === 'r' ? 0xff4444 : 0x4488ff;
                            showAbilityRange(range, abilityColor);
                        }
                    });
                    abilityEl.addEventListener('mouseleave', () => {
                        hideAbilityRange();
                    });
                }
            });

            // Spawn AI Heroes
            spawnAIHeroes();

            // Start Loop
            spawnWave();
            // ROUND 4: Store interval IDs for cleanup on game end
            spawnIntervalId = setInterval(spawnWave, 30000);

            // ROUND 1: Save match on page unload
            window.addEventListener('beforeunload', saveMatchResult);

            // ROUND 1: Cleanup dead entities every 5 seconds
            // ROUND 4: Store interval ID for cleanup on game end
            cleanupIntervalId = setInterval(cleanupDeadEntities, 5000);

            animate();

            // Welcome msg
            setTimeout(() => document.getElementById('notification').classList.add('visible'), 500);
            setTimeout(() => document.getElementById('notification').classList.remove('visible'), 3000);
        }

        function updateMinimap() {
            const c = document.getElementById('minimap-canvas');
            if (!c) return;
            const ctx = c.getContext('2d');
            if (!ctx) return;

            c.width = 220; c.height = 220;
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, 220, 220);

            // Map Size 100x100 (-50 to 50) maps to 0-220
            const mapToScreen = (val) => (val + 50) * 2.2;

            // Draw all 3 lane paths on minimap
            ctx.strokeStyle = '#2a3a2a';
            ctx.lineWidth = 4;

            // Mid lane (diagonal from Radiant to Dire)
            ctx.beginPath();
            ctx.moveTo(mapToScreen(-42), mapToScreen(-42));
            ctx.lineTo(mapToScreen(42), mapToScreen(42));
            ctx.stroke();

            // Top lane (left side then across to Dire)
            ctx.beginPath();
            ctx.moveTo(mapToScreen(-42), mapToScreen(-42));
            ctx.lineTo(mapToScreen(-42), mapToScreen(42));  // Up left side
            ctx.lineTo(mapToScreen(42), mapToScreen(42));   // Across top to Dire
            ctx.stroke();

            // Bot lane (across bottom then up right side)
            ctx.beginPath();
            ctx.moveTo(mapToScreen(-42), mapToScreen(-42));
            ctx.lineTo(mapToScreen(42), mapToScreen(-42));  // Across bottom
            ctx.lineTo(mapToScreen(42), mapToScreen(42));   // Up right to Dire
            ctx.stroke();

            // Draw base indicators
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(mapToScreen(-45), mapToScreen(-45), 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff3c3c';
            ctx.beginPath();
            ctx.arc(mapToScreen(45), mapToScreen(45), 8, 0, Math.PI * 2);
            ctx.fill();

            entities.forEach(e => {
                // ROUND 1: Robust guards for entity state
                if (!e || e.dead || !e.mesh || !e.mesh.position) return;

                const x = mapToScreen(e.mesh.position.x);
                const z = mapToScreen(e.mesh.position.z);

                ctx.fillStyle = e.team === TEAM_RADIANT ? '#00ff88' : '#ff3c3c';

                // ROUND 8: Different shapes for different entity types
                if (e instanceof Structure) {
                    // Squares for structures, larger for bases
                    const size = e.type === 'base' ? 8 : 5;
                    ctx.fillStyle = e.team === TEAM_RADIANT ? '#00ffaa' : '#ff5555';
                    ctx.fillRect(x - size/2, z - size/2, size, size);
                    // Border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x - size/2, z - size/2, size, size);
                } else if (e instanceof Hero) {
                    // Triangle for hero
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.moveTo(x, z - 5);
                    ctx.lineTo(x - 4, z + 4);
                    ctx.lineTo(x + 4, z + 4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (e instanceof SiegeCreep) {
                    // Larger circle for siege
                    ctx.beginPath();
                    ctx.arc(x, z, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (e instanceof RangedCreep) {
                    // Diamond for ranged
                    ctx.beginPath();
                    ctx.moveTo(x, z - 2);
                    ctx.lineTo(x + 2, z);
                    ctx.lineTo(x, z + 2);
                    ctx.lineTo(x - 2, z);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Small circle for melee creeps
                    ctx.beginPath();
                    ctx.arc(x, z, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ROUND 8: Draw camera viewport rectangle
            if (player && player.mesh) {
                const camX = mapToScreen(player.mesh.position.x);
                const camZ = mapToScreen(player.mesh.position.z);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(camX - 30, camZ - 20, 60, 40);
            }

            // ROUND 10: Draw minimap pings
            if (typeof drawMinimapPings === 'function') {
                drawMinimapPings(ctx);
            }

            // ROUND 10: Draw wards on minimap
            if (typeof drawWardsOnMinimap === 'function') {
                drawWardsOnMinimap(ctx, mapToScreen);
            }
        }

        // ROUND 8: Minimap click-to-move
        // ROUND 10: Added ping system with Alt+click or G key
        const minimapPings = [];
        let pingKeyHeld = false;

        function initMinimapClick() {
            const c = document.getElementById('minimap-canvas');
            if (!c) return;

            // G key to enable ping mode
            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'g') pingKeyHeld = true;
            });
            window.addEventListener('keyup', (e) => {
                if (e.key.toLowerCase() === 'g') pingKeyHeld = false;
            });

            c.addEventListener('click', (e) => {
                if (gameState !== 'playing' || !player || player.dead) return;

                const rect = c.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickZ = e.clientY - rect.top;

                // Convert screen coords to world coords
                // Screen 0-220 maps to world -50 to 50
                const worldX = (clickX / 220) * 100 - 50;
                const worldZ = (clickZ / 220) * 100 - 50;

                // ROUND 10: Alt+click or G+click to ping
                if (e.altKey || pingKeyHeld) {
                    createPing(worldX, worldZ, clickX, clickZ);
                    return;
                }

                player.targetPos.set(worldX, 0, worldZ);

                // Visual feedback on minimap
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(clickX, clickZ, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ROUND 10: Ping system for communication
        function createPing(worldX, worldZ, minimapX, minimapZ) {
            // Play ping sound
            AudioManager.playUI();

            // Create 3D ping marker in world
            const pingMarker = new THREE.Group();

            // Vertical beam
            const beam = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.3, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 })
            );
            beam.position.y = 4;
            pingMarker.add(beam);

            // Ground ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(1.5, 2, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            pingMarker.add(ring);

            // Ping icon (exclamation mark using cones)
            const marker = new THREE.Mesh(
                new THREE.ConeGeometry(0.4, 1.2, 8),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            marker.position.y = 8.5;
            marker.rotation.x = Math.PI; // Point down
            pingMarker.add(marker);

            pingMarker.position.set(worldX, 0, worldZ);
            scene.add(pingMarker);

            // Store ping info for minimap animation
            const ping = {
                worldX, worldZ,
                minimapX, minimapZ,
                age: 0,
                marker: pingMarker
            };
            minimapPings.push(ping);

            // Animate ping
            let frame = 0;
            const animatePing = () => {
                frame++;
                ping.age = frame;

                // Pulsing effect
                const pulse = 1 + Math.sin(frame * 0.2) * 0.2;
                ring.scale.setScalar(pulse);

                // Fade out
                const fade = 1 - (frame / 180);
                beam.material.opacity = fade * 0.7;
                ring.material.opacity = fade * 0.6;
                marker.material.opacity = fade;

                if (frame < 180) {
                    requestAnimationFrame(animatePing);
                } else {
                    scene.remove(pingMarker);
                    const idx = minimapPings.indexOf(ping);
                    if (idx > -1) minimapPings.splice(idx, 1);
                }
            };
            animatePing();

            // Show message
            showMessage('üìç Ping!');
        }

        // Draw pings on minimap (called in updateMinimap)
        function drawMinimapPings(ctx) {
            minimapPings.forEach(ping => {
                const alpha = Math.max(0, 1 - (ping.age / 180));
                const pulse = 1 + Math.sin(ping.age * 0.2) * 0.3;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ping.minimapX, ping.minimapZ, 8 * pulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(ping.minimapX, ping.minimapZ, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Track wave number for siege creep spawning
        let waveNumber = 0;

        // Spawn creeps on a specific lane
        function spawnLaneCreeps(laneName) {
            const lane = LANES[laneName];
            if (!lane) return;

            // Spawn positions with slight offset to avoid stacking
            const radiantSpawn = lane.radiantSpawn;
            const direSpawn = lane.direSpawn;

            // Melee creeps (3 per lane per wave)
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const rCreep = new Creep(
                        radiantSpawn.x + (Math.random() - 0.5) * 2,
                        radiantSpawn.z + (Math.random() - 0.5) * 2,
                        TEAM_RADIANT
                    );
                    rCreep.lane = laneName;
                    rCreep.waypoints = [...lane.waypoints.radiant];
                    entities.push(rCreep);

                    const dCreep = new Creep(
                        direSpawn.x + (Math.random() - 0.5) * 2,
                        direSpawn.z + (Math.random() - 0.5) * 2,
                        TEAM_DIRE
                    );
                    dCreep.lane = laneName;
                    dCreep.waypoints = [...lane.waypoints.dire];
                    entities.push(dCreep);
                }, i * 400);
            }

            // Ranged creep (1 per lane)
            setTimeout(() => {
                const rRanged = new RangedCreep(radiantSpawn.x, radiantSpawn.z - 2, TEAM_RADIANT);
                rRanged.lane = laneName;
                rRanged.waypoints = [...lane.waypoints.radiant];
                entities.push(rRanged);

                const dRanged = new RangedCreep(direSpawn.x, direSpawn.z + 2, TEAM_DIRE);
                dRanged.lane = laneName;
                dRanged.waypoints = [...lane.waypoints.dire];
                entities.push(dRanged);
            }, 3 * 400);

            // Siege creep every 3rd wave
            if (waveNumber % 3 === 0) {
                setTimeout(() => {
                    const rSiege = new SiegeCreep(radiantSpawn.x - 2, radiantSpawn.z, TEAM_RADIANT);
                    rSiege.lane = laneName;
                    rSiege.waypoints = [...lane.waypoints.radiant];
                    entities.push(rSiege);

                    const dSiege = new SiegeCreep(direSpawn.x + 2, direSpawn.z, TEAM_DIRE);
                    dSiege.lane = laneName;
                    dSiege.waypoints = [...lane.waypoints.dire];
                    entities.push(dSiege);
                }, 4 * 400);
            }
        }

        function spawnWave() {
            waveNumber++;

            // Spawn creeps on all 3 lanes
            spawnLaneCreeps('top');
            spawnLaneCreeps('mid');
            spawnLaneCreeps('bot');

            if (waveNumber % 3 === 0) {
                showMessage("SIEGE WAVE - ALL LANES!");
            } else {
                showMessage("Creeps Spawning - All Lanes");
            }
        }

        function showMessage(text) {
            const n = document.getElementById('notification');
            n.textContent = text;
            n.classList.add('visible');
            // ROUND 3: Play notification sound
            AudioManager.playUI('notification');
            setTimeout(() => n.classList.remove('visible'), 2000);
        }

        // ROUND 5: Flash ability icon red on failed cast
        function flashAbilityError(key) {
            const slot = document.getElementById(`ab-${key}`);
            if (!slot) return;
            slot.style.boxShadow = '0 0 15px #ff3c3c, inset 0 0 20px rgba(255,60,60,0.5)';
            slot.style.borderColor = '#ff3c3c';
            setTimeout(() => {
                slot.style.boxShadow = '';
                slot.style.borderColor = '';
            }, 200);
        }

        function onMouseDown(e) {
            // ROUND 3: Resume audio context on user interaction
            AudioManager.resume();

            if (e.button === 0 || e.button === 2) { // Left or Right Click to move
                e.preventDefault();

                // Don't move if clicking on UI elements
                if (e.target.closest('.ability-slot') || e.target.closest('.data-buttons') || e.target.closest('.hud-container')) return;

                // ROUND 1: Player death guard
                if (gameState !== 'playing' || !player || player.dead) return;

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                // Intersect ONLY the hit plane for reliable movement
                const intersects = raycaster.intersectObject(window.hitPlane);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    player.targetPos.copy(point);

                    // Click Visual
                    const r = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.8 }));
                    r.rotation.x = -Math.PI / 2;
                    r.position.copy(point); r.position.y = 0.2;
                    scene.add(r);

                    // Tween out
                    let sc = 1;
                    const animClick = () => {
                        sc -= 0.05;
                        r.scale.set(sc, sc, sc);
                        r.material.opacity = sc;
                        if (sc > 0) requestAnimationFrame(animClick);
                        else scene.remove(r);
                    };
                    animClick();
                }
            }
        }

        // ROUND 5: Touch support for mobile movement
        function onTouchStart(e) {
            // Don't interfere with ability buttons
            if (e.target.closest('.ability-slot') || e.target.closest('.data-buttons')) return;

            e.preventDefault();
            AudioManager.resume();

            if (gameState !== 'playing' || !player || player.dead) return;

            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(window.hitPlane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                player.targetPos.copy(point);

                // Touch Visual (same as click)
                const r = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.8 }));
                r.rotation.x = -Math.PI / 2;
                r.position.copy(point); r.position.y = 0.2;
                scene.add(r);

                let sc = 1;
                const animTouch = () => {
                    sc -= 0.05;
                    r.scale.set(sc, sc, sc);
                    r.material.opacity = sc;
                    if (sc > 0) requestAnimationFrame(animTouch);
                    else scene.remove(r);
                };
                animTouch();
            }
        }

        // ROUND 5: Ability button tap handler for mobile
        function castAbility(key) {
            if (gameState !== 'playing' || !player || player.dead) return;
            player.cast(key);
        }

        function updateHeroUI() {
            // ROUND 1: Guard against null/dead player
            if (!player || player.dead) return;

            // Update hero name and ability icons from hero definition
            if (player.heroDef && !cachedUI.heroInit) {
                cachedUI.heroInit = true;
                const heroDef = player.heroDef;

                // Update hero name
                const nameEl = document.querySelector('.unit-name');
                if (nameEl) nameEl.textContent = heroDef.name;

                // Update ability icons
                for (const key of ['q', 'w', 'e', 'r']) {
                    const iconEl = document.querySelector(`#ab-${key} .ability-icon`);
                    const costEl = document.querySelector(`#ab-${key} .mana-cost`);
                    if (iconEl && heroDef.abilities[key]) {
                        iconEl.textContent = heroDef.abilities[key].icon;
                    }
                    if (costEl && heroDef.abilities[key]) {
                        costEl.textContent = heroDef.abilities[key].cost;
                    }
                }

                // Update stat display
                document.getElementById('stat-dmg').textContent = Math.floor(player.damage);
                document.getElementById('stat-armor').textContent = player.armor.toFixed(1);
                document.getElementById('stat-gold').textContent = player.gold;

                // Update HP/MP text
                document.getElementById('hp-text').textContent = `${player.hp} / ${player.maxHp}`;
                document.getElementById('mp-text').textContent = `${player.mp} / ${player.maxMp}`;
            }

            // ROUND 2: Performance - only update DOM when values change
            const hpFloor = Math.floor(player.hp);
            const mpFloor = Math.floor(player.mp);

            if (hpFloor !== cachedUI.hp) {
                cachedUI.hp = hpFloor;
                const hpPct = (player.hp / player.maxHp) * 100;
                const hpBar = document.getElementById('hp-bar');
                const hpText = document.getElementById('hp-text');
                if (hpBar) hpBar.style.width = hpPct + '%';
                if (hpText) hpText.textContent = hpFloor + ' / ' + player.maxHp;
            }

            if (mpFloor !== cachedUI.mp) {
                cachedUI.mp = mpFloor;
                const mpPct = (player.mp / player.maxMp) * 100;
                const mpBar = document.getElementById('mp-bar');
                const mpText = document.getElementById('mp-text');
                if (mpBar) mpBar.style.width = mpPct + '%';
                if (mpText) mpText.textContent = mpFloor + ' / ' + player.maxMp;
            }

            // ROUND 7: Update XP bar
            if (cachedUI.xp !== player.xp || cachedUI.level !== player.level) {
                cachedUI.xp = player.xp;
                cachedUI.level = player.level;
                const xpPct = (player.xp / player.xpToLevel) * 100;
                const xpBar = document.getElementById('xp-bar');
                const xpText = document.getElementById('xp-text');
                if (xpBar) xpBar.style.width = xpPct + '%';
                if (xpText) xpText.textContent = `${player.xp} / ${player.xpToLevel} XP`;
            }

            // ROUND 8: Update gold display
            if (cachedUI.gold !== player.gold) {
                cachedUI.gold = player.gold;
                const goldEl = document.getElementById('stat-gold');
                if (goldEl) goldEl.textContent = player.gold;
            }
        }

        function updateCooldownUI(key, current, max) {
            const el = document.querySelector(`#ab-${key} .cooldown-mask`);
            if (el) {
                const pct = (current / max) * 100;
                el.style.height = pct + '%';
                el.textContent = current > 0 ? Math.ceil(current) : '';
            }
        }

        function updateScoreBoard() {
            document.getElementById('score-radiant').textContent = score.radiant;
            document.getElementById('score-dire').textContent = score.dire;
        }

        // Kill Feed System
        const killFeed = {
            maxEntries: 5,
            entries: [],

            add(killer, victim, killerTeam) {
                const feed = document.getElementById('kill-feed');
                if (!feed) return;

                const entry = document.createElement('div');
                entry.style.cssText = `
                    display:flex;align-items:center;gap:8px;padding:6px 10px;
                    margin-bottom:4px;border-radius:4px;font-size:12px;
                    background:rgba(0,0,0,0.7);border-left:3px solid ${killerTeam === TEAM_RADIANT ? '#00ff88' : '#ff3c3c'};
                    animation:fadeInLeft 0.3s ease-out;
                `;
                entry.innerHTML = `
                    <span style="color:${killerTeam === TEAM_RADIANT ? '#00ff88' : '#ff3c3c'};font-weight:600;">${killer}</span>
                    <span style="color:#888;">killed</span>
                    <span style="color:${killerTeam === TEAM_RADIANT ? '#ff3c3c' : '#00ff88'};font-weight:600;">${victim}</span>
                `;

                feed.insertBefore(entry, feed.firstChild);
                this.entries.unshift(entry);

                // Remove old entries
                while (this.entries.length > this.maxEntries) {
                    const old = this.entries.pop();
                    old.style.animation = 'fadeOut 0.3s ease-out forwards';
                    setTimeout(() => old.remove(), 300);
                }

                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (this.entries.includes(entry)) {
                        entry.style.animation = 'fadeOut 0.5s ease-out forwards';
                        setTimeout(() => {
                            entry.remove();
                            const idx = this.entries.indexOf(entry);
                            if (idx > -1) this.entries.splice(idx, 1);
                        }, 500);
                    }
                }, 8000);
            }
        };

        // ROUND 10: Match Statistics Tracking System
        const matchStats = {
            damageDealt: 0,
            damageTaken: 0,
            healingDone: 0,
            goldEarned: 0,
            creepsKilled: 0,
            abilitiesUsed: 0,
            heroKills: 0,
            deaths: 0,
            assists: 0,

            reset() {
                this.damageDealt = 0;
                this.damageTaken = 0;
                this.healingDone = 0;
                this.goldEarned = 0;
                this.creepsKilled = 0;
                this.abilitiesUsed = 0;
                this.heroKills = 0;
                this.deaths = 0;
                this.assists = 0;
            },

            trackDamageDealt(amount) { this.damageDealt += Math.floor(amount); },
            trackDamageTaken(amount) { this.damageTaken += Math.floor(amount); },
            trackHealing(amount) { this.healingDone += Math.floor(amount); },
            trackGold(amount) { this.goldEarned += amount; },
            trackCreepKill() { this.creepsKilled++; },
            trackAbilityUse() { this.abilitiesUsed++; },
            trackHeroKill() { this.heroKills++; },
            trackDeath() { this.deaths++; }
        };

        let matchStatsOpen = false;

        function toggleMatchStats() {
            matchStatsOpen = !matchStatsOpen;
            const panel = document.getElementById('match-stats-panel');
            if (panel) {
                panel.style.display = matchStatsOpen ? 'block' : 'none';
                if (matchStatsOpen) updateMatchStatsUI();
            }
        }

        function updateMatchStatsUI() {
            // Update player detailed stats
            document.getElementById('stat-damage-dealt').textContent = matchStats.damageDealt.toLocaleString();
            document.getElementById('stat-damage-taken').textContent = matchStats.damageTaken.toLocaleString();
            document.getElementById('stat-healing').textContent = matchStats.healingDone.toLocaleString();
            document.getElementById('stat-gold-earned').textContent = matchStats.goldEarned.toLocaleString();
            document.getElementById('stat-creeps-killed').textContent = matchStats.creepsKilled;
            document.getElementById('stat-abilities-used').textContent = matchStats.abilitiesUsed;

            // Update team stats
            const radiantDiv = document.getElementById('radiant-heroes-stats');
            const direDiv = document.getElementById('dire-heroes-stats');
            if (!radiantDiv || !direDiv) return;

            radiantDiv.innerHTML = '';
            direDiv.innerHTML = '';

            entities.forEach(e => {
                if (!(e instanceof Hero) && !(e instanceof AIHero)) return;
                if (e.dead && !e.isAI) return;

                const heroName = e.heroDef ? e.heroDef.name : 'Hero';
                const kda = `${e.kills || 0}/${e.deaths || 0}/${e.assists || 0}`;
                const level = e.level || 1;
                const gold = e.gold || 0;
                const isPlayer = e === player;

                const row = document.createElement('div');
                row.style.cssText = `display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1);font-size:12px;${isPlayer ? 'background:rgba(255,215,0,0.2);padding:4px;border-radius:4px;' : ''}`;
                row.innerHTML = `
                    <span style="color:${isPlayer ? '#ffd700' : '#fff'};">${heroName}${isPlayer ? ' (You)' : ''}</span>
                    <span style="color:#888;">Lv${level}</span>
                    <span style="color:#00ff88;">${kda}</span>
                    <span style="color:#ffd700;">${gold}g</span>
                `;

                if (e.team === TEAM_RADIANT) {
                    radiantDiv.appendChild(row);
                } else {
                    direDiv.appendChild(row);
                }
            });
        }

        function initPortrait() {
            // Tiny separate scene for the 3D portrait
            const container = document.getElementById('portrait-container');
            if (!container) return;

            portraitScene = new THREE.Scene();
            portraitScene.background = new THREE.Color(0x111111);

            portraitCamera = new THREE.PerspectiveCamera(50, 90 / 110, 0.1, 100);
            portraitCamera.position.set(0, 0, 3);

            portraitRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            portraitRenderer.setSize(90, 110);
            container.appendChild(portraitRenderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(1, 1, 1);
            portraitScene.add(light);
            portraitScene.add(new THREE.AmbientLight(0x404040));

            // Copy hero mesh layout roughly
            const geo = new THREE.CylinderGeometry(0.6, 0.6, 2.2, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff88, roughness: 0.2 });
            portraitMesh = new THREE.Mesh(geo, mat);
            portraitScene.add(portraitMesh);
        }

        function animate() {
            requestAnimationFrame(animate);

            // ROUND 2: Handle pause state - still render but don't update
            if (gameState === 'paused') {
                composer.render();
                if (portraitRenderer) portraitRenderer.render(portraitScene, portraitCamera);
                return;
            }

            // R2: Reset vector pool each frame
            VecPool.reset();
            // R3: Rebuild spatial grid for O(n) entity queries
            SpatialGrid.rebuild();

            const rawDt = clock.getDelta();
            // R2 FIX: Apply HitStop time scaling
            HitStop.update(rawDt); // Update with real time
            const dt = rawDt * HitStop.getTimeScale(); // Scale game time
            gameTime += dt;

            // ROUND 2: Respawn timer countdown
            if (isRespawning && gameState === 'playing') {
                respawnTimer -= dt;
                const timerEl = document.getElementById('respawn-timer');
                if (timerEl) timerEl.textContent = `Respawn: ${Math.ceil(respawnTimer)}s`;
                if (respawnTimer <= 0) {
                    respawnHero();
                }
            }

            // ROUND 2: Check win conditions
            checkWinConditions();

            // Camera Follow with screen shake
            // R3: Use VecPool instead of clone + new Vector3
            if (player && !player.dead && player.mesh) {
                const shakeOffset = screenShake.update();
                const targetPos = VecPool.get();
                targetPos.copy(player.mesh.position);
                targetPos.x += shakeOffset.x;
                targetPos.y += 25 + shakeOffset.y;
                targetPos.z += 20;
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(player.mesh.position);
            }

            // Entities (only update when playing)
            if (gameState === 'playing') {
                entities.forEach(e => e.update(dt));

                // Passive gold income (1 gold per second)
                if (player && !player.dead) {
                    player.goldAccumulator = (player.goldAccumulator || 0) + dt;
                    if (player.goldAccumulator >= 1.0) {
                        player.gold += 1;
                        player.goldAccumulator -= 1.0;
                    }
                }

                // Update jungle camp respawn timers
                updateJungleCamps(dt);

                // Update rune system
                updateRunes(dt);

                // Update animation and particle systems
                if (typeof AnimationSystem !== 'undefined' && AnimationSystem.update) {
                    AnimationSystem.update(dt);
                }
                if (typeof ParticleSystem !== 'undefined' && ParticleSystem.update) {
                    ParticleSystem.update(dt);
                }

                // CONSENSUS: Update explosion pool
                ExplosionPool.update();

                // Update environment animations (grass, fireflies)
                if (typeof updateEnvironment === 'function') {
                    updateEnvironment(dt);
                }

                // ROUND 10: Update ability range indicator position
                if (typeof updateAbilityRangePosition === 'function') {
                    updateAbilityRangePosition();
                }
            }
            floatingTexts.forEach(t => t.updatePosition());

            // ROUND 2: Throttled minimap updates
            const now = performance.now();
            if (now - lastMinimapUpdate > MINIMAP_UPDATE_INTERVAL) {
                updateMinimap();
                lastMinimapUpdate = now;
            }

            composer.render();

            // Portrait Render
            if (portraitRenderer) {
                portraitRenderer.render(portraitScene, portraitCamera);
            }

            // Time
            const mins = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const secs = Math.floor(gameTime % 60).toString().padStart(2, '0');
            document.getElementById('game-time').textContent = `${mins}:${secs}`;
        }

        // Populate hero selection screen
        function initHeroSelect() {
            const grid = document.getElementById('hero-grid');
            grid.innerHTML = '';

            for (const [heroId, hero] of Object.entries(HERO_DEFS)) {
                const card = document.createElement('div');
                card.style.cssText = `
                    background: rgba(20,20,35,0.9);
                    border: 2px solid #333;
                    border-radius: 12px;
                    padding: 20px;
                    width: 180px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                `;
                card.innerHTML = `
                    <div style="font-size:48px;margin-bottom:10px;">${hero.icon}</div>
                    <h3 style="color:#${hero.color.toString(16).padStart(6,'0')};margin:0;font-family:var(--font-display);font-size:18px;">${hero.name}</h3>
                    <p style="color:#8899aa;font-size:11px;margin:8px 0;">${hero.description}</p>
                    <div style="font-size:10px;color:#667788;text-align:left;margin-top:10px;">
                        <div>HP: ${hero.stats.hp} | MP: ${hero.stats.mp}</div>
                        <div>DMG: ${hero.stats.damage} | ARM: ${hero.stats.armor}</div>
                    </div>
                `;

                card.onmouseenter = () => {
                    card.style.borderColor = `#${hero.color.toString(16).padStart(6,'0')}`;
                    card.style.boxShadow = `0 0 20px rgba(${(hero.color >> 16) & 255},${(hero.color >> 8) & 255},${hero.color & 255},0.4)`;
                    card.style.transform = 'scale(1.05)';
                };
                card.onmouseleave = () => {
                    card.style.borderColor = '#333';
                    card.style.boxShadow = 'none';
                    card.style.transform = 'scale(1)';
                };
                card.onclick = () => selectHero(heroId);

                grid.appendChild(card);
            }
        }

        function selectHero(heroId) {
            selectedHeroType = heroId;
            document.getElementById('hero-select').style.display = 'none';
            init();
        }

        // Start with hero selection
        initHeroSelect();
    </script>
</body>

</html>
