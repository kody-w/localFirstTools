<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOTA 3: LEGACY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Rajdhani:wght@500;700&display=swap');

        :root {
            /* Design Tokens */
            --color-bg-dark: #050508;
            --color-glass: rgba(10, 15, 25, 0.85);
            --color-glass-light: rgba(20, 30, 45, 0.7);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-border-hover: rgba(255, 255, 255, 0.3);

            --accent-radiant: #00ff88;
            --accent-radiant-glow: rgba(0, 255, 136, 0.4);
            --accent-dire: #ff3c3c;
            --accent-dire-glow: rgba(255, 60, 60, 0.4);

            --text-main: #ffffff;
            --text-muted: #8899aa;

            --font-main: 'Outfit', sans-serif;
            --font-display: 'Rajdhani', sans-serif;

            --z-ui-base: 100;
            --z-ui-overlay: 200;
            --z-tooltip: 300;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-drag: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--color-bg-dark);
            color: var(--text-main);
            font-family: var(--font-main);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI OVERLAYS --- */

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: var(--z-ui-base);
        }

        .score-board {
            display: flex;
            align-items: center;
            gap: 40px;
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        .score-radiant {
            color: var(--accent-radiant);
        }

        .score-dire {
            color: var(--accent-dire);
        }

        .game-time {
            color: #fff;
            font-variant-numeric: tabular-nums;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            font-size: 20px;
        }

        /* Bottom HUD */
        .hud-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95) 20%, transparent);
            z-index: var(--z-ui-base);
            pointer-events: none;
            /* Let clicks pass through empty space */
        }

        /* Portrait & Stats (Left) */
        .character-panel {
            width: 300px;
            height: 110px;
            display: flex;
            background: var(--color-glass);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .character-panel:hover {
            transform: translateY(-2px);
            border-color: var(--color-border-hover);
        }

        .portrait {
            width: 90px;
            background: #111;
            position: relative;
            overflow: hidden;
        }

        .portrait canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .stats-area {
            flex: 1;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .unit-name {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-transform: uppercase;
        }

        .unit-level {
            font-size: 12px;
            color: #ffd700;
            margin-left: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-val {
            color: #fff;
            font-weight: 600;
        }

        /* Center Skills & Health */
        .center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        .bars-container {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bar-wrap {
            width: 100%;
            height: 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hp-fill {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.4);
        }

        .mp-fill {
            background: linear-gradient(90deg, #3498db, #2980b9);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.4);
        }

        .bar-text {
            position: absolute;
            width: 100%;
            top: 0;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            line-height: 14px;
            text-shadow: 0 1px 2px #000;
            opacity: 0.8;
        }

        .ability-bar {
            display: flex;
            gap: 8px;
        }

        .ability-slot {
            width: 64px;
            height: 64px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .ability-slot:hover {
            border-color: #fff;
            transform: translateY(-2px);
        }

        .ability-slot:active {
            transform: scale(0.95);
        }

        .ability-icon {
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .hotkey {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 1px 2px #000;
        }

        .mana-cost {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #3498db;
            font-weight: 700;
        }

        .cooldown-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.85);
            transition: height linear;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        /* Minimap (Right) */
        .right-panel {
            width: 220px;
            height: 220px;
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            position: relative;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .right-panel canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Floating Combat Text */
        .damage-number {
            position: absolute;
            font-family: var(--font-display);
            font-weight: 800;
            font-size: 24px;
            pointer-events: none;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            animation: floatUp 1s ease-out forwards;
            z-index: var(--z-ui-overlay);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            50% {
                transform: translateY(-30px) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translateY(-60px) scale(0.8);
                opacity: 0;
            }
        }

        .dmg-crit {
            color: #ff3c3c;
            font-size: 32px;
        }

        .dmg-physical {
            color: #ffffff;
        }

        .dmg-magic {
            color: #a450ff;
        }

        /* Notification Toast */
        .notification-toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--accent-radiant);
            padding: 10px 30px;
            border-radius: 4px;
            color: #fff;
            font-family: var(--font-display);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .notification-toast.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <!-- HERO SELECTION SCREEN -->
    <div id="hero-select" style="position:fixed;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,#0a0a12 0%,#1a1a2e 50%,#0f0f1a 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000;">
        <h1 style="font-family:var(--font-display);font-size:64px;color:#00ff88;margin-bottom:10px;text-shadow:0 0 30px rgba(0,255,136,0.5);">DOTA 3: LEGACY</h1>
        <p style="color:#8899aa;margin-bottom:40px;font-size:18px;">Choose Your Hero</p>
        <div id="hero-grid" style="display:flex;gap:30px;flex-wrap:wrap;justify-content:center;max-width:900px;">
            <!-- Heroes populated by JS -->
        </div>
        <p style="color:#556677;margin-top:40px;font-size:14px;">Click a hero to begin</p>
    </div>

    <div id="game-container"></div>

    <!-- UI Layer -->
    <div class="top-bar">
        <div class="score-board">
            <span class="score-radiant" id="score-radiant">0</span>
            <span class="game-time" id="game-time">00:00</span>
            <span class="score-dire" id="score-dire">0</span>
        </div>
        <!-- ROUND 1: Data Export/Import Buttons -->
        <div class="data-buttons" style="position:absolute;right:20px;top:15px;pointer-events:auto;display:flex;gap:8px;">
            <button onclick="exportGameData()" style="background:var(--accent-radiant);border:none;padding:6px 14px;border-radius:4px;cursor:pointer;font-size:12px;font-weight:600;color:#000;">Export</button>
            <label style="background:#3498db;padding:6px 14px;border-radius:4px;cursor:pointer;font-size:12px;font-weight:600;color:#fff;">
                Import
                <input type="file" accept=".json" onchange="importGameData(this.files[0])" style="display:none;">
            </label>
        </div>
    </div>

    <!-- Central Notification -->
    <div id="notification" class="notification-toast">WELCOME TO DOTA 3 LEGACY</div>

    <!-- ROUND 2: Pause Overlay -->
    <div id="pause-overlay" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:400;">
        <h1 style="font-family:var(--font-display);font-size:48px;color:#fff;margin-bottom:10px;">PAUSED</h1>
        <p style="color:#8899aa;margin-bottom:30px;">Press ESC to resume</p>
        <button onclick="togglePause()" style="padding:12px 30px;font-size:16px;background:var(--accent-radiant);border:none;border-radius:6px;cursor:pointer;color:#000;font-weight:600;">Resume Game</button>
    </div>

    <!-- ROUND 2: Respawn Timer -->
    <span id="respawn-timer" style="position:absolute;top:70px;left:50%;transform:translateX(-50%);color:#ff3c3c;font-family:var(--font-display);font-size:24px;display:none;z-index:200;"></span>

    <!-- ROUND 9: Item Shop Panel -->
    <div id="shop-panel" style="position:fixed;left:20px;top:50%;transform:translateY(-50%);background:var(--color-glass);border:1px solid var(--color-border);border-radius:12px;padding:15px;display:none;z-index:300;min-width:200px;backdrop-filter:blur(10px);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
            <h3 style="margin:0;font-family:var(--font-display);color:#ffd700;">SHOP</h3>
            <span style="color:#8899aa;font-size:12px;">[B] to close</span>
        </div>
        <div id="shop-items" style="display:flex;flex-direction:column;gap:8px;"></div>
    </div>

    <!-- ROUND 9: Inventory display -->
    <div id="inventory-panel" style="position:absolute;left:330px;bottom:25px;display:flex;gap:4px;z-index:100;pointer-events:none;">
        <!-- Filled by JS -->
    </div>

    <div class="hud-container">
        <!-- Character Stats -->
        <div class="character-panel">
            <div class="portrait" id="portrait-container">
                <!-- 3D Portrait Canvas appended here -->
            </div>
            <div class="stats-area">
                <div>
                    <span class="unit-name">Void Walker</span><span class="unit-level">Lvl 1</span>
                </div>
                <div style="margin-top: 8px;">
                    <div class="stat-row"><span>Damage</span><span class="stat-val" id="stat-dmg">45</span></div>
                    <div class="stat-row"><span>Armor</span><span class="stat-val" id="stat-armor">3</span></div>
                    <!-- ROUND 8: Gold display -->
                    <div class="stat-row"><span style="color: #ffd700;">Gold</span><span class="stat-val" id="stat-gold" style="color: #ffd700;">0</span></div>
                </div>
            </div>
        </div>

        <!-- Skills -->
        <div class="center-panel">
            <div class="bars-container">
                <div class="bar-wrap">
                    <div class="bar-fill hp-fill" id="hp-bar" style="width: 100%"></div>
                    <div class="bar-text" id="hp-text">1200 / 1200</div>
                </div>
                <div class="bar-wrap">
                    <div class="bar-fill mp-fill" id="mp-bar" style="width: 100%"></div>
                    <div class="bar-text" id="mp-text">600 / 600</div>
                </div>
                <!-- ROUND 7: XP Bar -->
                <div class="bar-wrap" style="height: 10px;">
                    <div class="bar-fill" id="xp-bar" style="width: 0%; background: linear-gradient(90deg, #ffd700, #ffaa00); box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);"></div>
                    <div class="bar-text" id="xp-text" style="font-size: 8px; line-height: 10px;">0 / 100 XP</div>
                </div>
            </div>

            <div class="ability-bar">
                <!-- ROUND 5: Added onclick for mobile touch support -->
                <div class="ability-slot" id="ab-q" onclick="castAbility('q')">
                    <span class="hotkey">Q</span>
                    <div class="ability-icon">üåÄ</div>
                    <span class="mana-cost">60</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-w" onclick="castAbility('w')">
                    <span class="hotkey">W</span>
                    <div class="ability-icon">‚ö°</div>
                    <span class="mana-cost">40</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-e" onclick="castAbility('e')">
                    <span class="hotkey">E</span>
                    <div class="ability-icon">üõ°Ô∏è</div>
                    <span class="mana-cost">80</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-r" onclick="castAbility('r')">
                    <span class="hotkey">R</span>
                    <div class="ability-icon">‚òÑÔ∏è</div>
                    <span class="mana-cost">150</span>
                    <div class="cooldown-mask"></div>
                </div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="right-panel">
            <canvas id="minimap-canvas"></canvas>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        // --- GAME ENGINE ---

        // Constants
        const TEAM_RADIANT = 'radiant';
        const TEAM_DIRE = 'dire';
        const COLOR_RADIANT = 0x00ff88;
        const COLOR_DIRE = 0xff3c3c;

        // HERO DEFINITIONS - Multiple playable heroes
        const HERO_DEFS = {
            voidwalker: {
                name: 'Void Walker',
                color: 0x00ff88,
                icon: 'üåÄ',
                description: 'Agile assassin with blink and burst damage',
                stats: { hp: 1200, mp: 600, damage: 45, armor: 3, speed: 0.28, critChance: 0.15 },
                abilities: {
                    q: { name: 'Void Bolt', cd: 2, cost: 60, icon: 'üåÄ', desc: 'Fire energy projectile' },
                    w: { name: 'Blink', cd: 5, cost: 40, icon: '‚ö°', desc: 'Dash forward' },
                    e: { name: 'Void Shield', cd: 12, cost: 80, icon: 'üõ°Ô∏è', desc: 'Absorb damage' },
                    r: { name: 'Void Nova', cd: 40, cost: 150, icon: 'üí•', desc: 'Massive AOE damage' }
                }
            },
            ironclad: {
                name: 'Iron Clad',
                color: 0xccaa44,
                icon: 'üõ°Ô∏è',
                description: 'Durable tank with high armor and crowd control',
                stats: { hp: 1800, mp: 400, damage: 35, armor: 8, speed: 0.18, critChance: 0.05 },
                abilities: {
                    q: { name: 'Shield Slam', cd: 3, cost: 50, icon: 'üõ°Ô∏è', desc: 'Stun nearby enemies' },
                    w: { name: 'Charge', cd: 8, cost: 60, icon: 'üêÇ', desc: 'Rush forward' },
                    e: { name: 'Fortify', cd: 15, cost: 100, icon: 'üè∞', desc: 'Triple armor briefly' },
                    r: { name: 'Earthquake', cd: 50, cost: 200, icon: 'üåã', desc: 'Ground slam AOE' }
                }
            },
            pyromancer: {
                name: 'Pyromancer',
                color: 0xff6622,
                icon: 'üî•',
                description: 'Glass cannon mage with powerful fire spells',
                stats: { hp: 900, mp: 800, damage: 30, armor: 1, speed: 0.22, critChance: 0.08 },
                abilities: {
                    q: { name: 'Fireball', cd: 1.5, cost: 40, icon: 'üî•', desc: 'Fast fire projectile' },
                    w: { name: 'Flame Dash', cd: 6, cost: 50, icon: 'üí®', desc: 'Leave fire trail' },
                    e: { name: 'Ignite', cd: 10, cost: 70, icon: 'üå°Ô∏è', desc: 'Burn enemies over time' },
                    r: { name: 'Inferno', cd: 35, cost: 180, icon: '‚òÄÔ∏è', desc: 'Rain fire from sky' }
                }
            },
            shadowblade: {
                name: 'Shadow Blade',
                color: 0x8844ff,
                icon: 'üó°Ô∏è',
                description: 'Stealth assassin with high crit damage',
                stats: { hp: 1000, mp: 500, damage: 60, armor: 2, speed: 0.30, critChance: 0.25 },
                abilities: {
                    q: { name: 'Shadow Strike', cd: 2, cost: 45, icon: 'üó°Ô∏è', desc: 'Teleport to target' },
                    w: { name: 'Vanish', cd: 10, cost: 80, icon: 'üëÅÔ∏è', desc: 'Become invisible' },
                    e: { name: 'Poison Blade', cd: 8, cost: 55, icon: '‚ò†Ô∏è', desc: 'Next hit poisons' },
                    r: { name: 'Death Mark', cd: 45, cost: 160, icon: 'üíÄ', desc: 'Execute low HP targets' }
                }
            }
        };

        let selectedHeroType = null;

        // LANE DEFINITIONS - Top, Mid, Bot
        // Map layout: Radiant base at (-45,-45), Dire base at (45,45)
        // Top lane: goes up left side, then across top to Dire
        // Mid lane: diagonal through center
        // Bot lane: goes across bottom, then up right side to Dire
        const LANES = {
            top: {
                radiantSpawn: { x: -42, z: -38 },  // Near left side
                direSpawn: { x: 38, z: 42 },       // Near top side from Dire
                waypoints: {
                    radiant: [{ x: -42, z: 0 }, { x: -42, z: 35 }, { x: 0, z: 42 }, { x: 35, z: 42 }],
                    dire: [{ x: 0, z: 42 }, { x: -35, z: 42 }, { x: -42, z: 0 }, { x: -42, z: -35 }]
                },
                towers: {
                    radiant: [{ x: -42, z: -25 }, { x: -42, z: 10 }],
                    dire: [{ x: 10, z: 42 }, { x: 25, z: 42 }]
                }
            },
            mid: {
                radiantSpawn: { x: -38, z: -38 },  // Center path from Radiant
                direSpawn: { x: 38, z: 38 },       // Center path from Dire
                waypoints: {
                    radiant: [{ x: -20, z: -20 }, { x: 0, z: 0 }, { x: 20, z: 20 }],
                    dire: [{ x: 20, z: 20 }, { x: 0, z: 0 }, { x: -20, z: -20 }]
                },
                towers: {
                    radiant: [{ x: -28, z: -28 }, { x: -15, z: -15 }],
                    dire: [{ x: 15, z: 15 }, { x: 28, z: 28 }]
                }
            },
            bot: {
                radiantSpawn: { x: -38, z: -42 },  // Near bottom side
                direSpawn: { x: 42, z: 38 },       // Near right side from Dire
                waypoints: {
                    radiant: [{ x: 0, z: -42 }, { x: 35, z: -42 }, { x: 42, z: 0 }, { x: 42, z: 35 }],
                    dire: [{ x: 42, z: 0 }, { x: 42, z: -35 }, { x: 0, z: -42 }, { x: -35, z: -42 }]
                },
                towers: {
                    radiant: [{ x: -25, z: -42 }, { x: 10, z: -42 }],
                    dire: [{ x: 42, z: -10 }, { x: 42, z: 25 }]
                }
            }
        };

        // ============================================
        // 3D MODEL BUILDER SYSTEM
        // ============================================

        // Detailed body part definitions for heroes
        const HERO_MODELS = {
            voidwalker: {
                scale: 1.0,
                bodyParts: [
                    // Torso
                    { name: 'torso', shape: 'box', width: 0.6, height: 0.9, depth: 0.4, color: '#00ff88', position: [0, 1.2, 0], emissive: '#004422', shininess: 60 },
                    // Chest plate
                    { name: 'chestPlate', shape: 'box', width: 0.65, height: 0.5, depth: 0.15, color: '#00aa66', position: [0, 1.4, 0.2], shininess: 80 },
                    // Head
                    { name: 'head', shape: 'sphere', size: 0.25, color: '#00ff88', position: [0, 2.0, 0], emissive: '#004422', shininess: 70 },
                    // Visor/eyes
                    { name: 'visor', shape: 'box', width: 0.3, height: 0.08, depth: 0.1, color: '#00ffff', position: [0, 2.0, 0.2], emissive: '#00ffff', shininess: 100 },
                    // Shoulders
                    { name: 'shoulderL', shape: 'box', width: 0.25, height: 0.2, depth: 0.25, color: '#00cc66', position: [-0.45, 1.5, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.25, height: 0.2, depth: 0.25, color: '#00cc66', position: [0.45, 1.5, 0], shininess: 50 },
                    // Arms
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#00dd77', position: [-0.45, 1.0, 0], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#00dd77', position: [0.45, 1.0, 0], shininess: 40 },
                    // Hands with blade effects
                    { name: 'handL', shape: 'box', width: 0.12, height: 0.15, depth: 0.08, color: '#00ffaa', position: [-0.45, 0.6, 0], shininess: 60 },
                    { name: 'handR', shape: 'box', width: 0.12, height: 0.15, depth: 0.08, color: '#00ffaa', position: [0.45, 0.6, 0], shininess: 60 },
                    // Blades
                    { name: 'bladeL', shape: 'box', width: 0.03, height: 0.5, depth: 0.15, color: '#00ffff', position: [-0.45, 0.3, 0.1], emissive: '#00cccc', shininess: 100 },
                    { name: 'bladeR', shape: 'box', width: 0.03, height: 0.5, depth: 0.15, color: '#00ffff', position: [0.45, 0.3, 0.1], emissive: '#00cccc', shininess: 100 },
                    // Legs
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#00bb66', position: [-0.2, 0.35, 0], shininess: 40 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.1, radiusBottom: 0.12, height: 0.7, color: '#00bb66', position: [0.2, 0.35, 0], shininess: 40 },
                    // Feet
                    { name: 'footL', shape: 'box', width: 0.12, height: 0.08, depth: 0.2, color: '#008855', position: [-0.2, 0.04, 0.05], shininess: 30 },
                    { name: 'footR', shape: 'box', width: 0.12, height: 0.08, depth: 0.2, color: '#008855', position: [0.2, 0.04, 0.05], shininess: 30 },
                    // Energy core
                    { name: 'core', shape: 'sphere', size: 0.15, color: '#00ffff', position: [0, 1.2, 0], emissive: '#00ffff', shininess: 100 },
                    // Cape/cloak effect
                    { name: 'cape', shape: 'box', width: 0.5, height: 0.8, depth: 0.05, color: '#006644', position: [0, 1.0, -0.25], shininess: 20 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            ironclad: {
                scale: 1.2,
                bodyParts: [
                    // Massive torso
                    { name: 'torso', shape: 'box', width: 1.0, height: 1.2, depth: 0.7, color: '#ccaa44', position: [0, 1.4, 0], shininess: 70 },
                    // Chest armor
                    { name: 'chestArmor', shape: 'box', width: 1.1, height: 0.6, depth: 0.2, color: '#ddbb55', position: [0, 1.6, 0.35], shininess: 90 },
                    // Head with helmet
                    { name: 'helmet', shape: 'box', width: 0.5, height: 0.45, depth: 0.45, color: '#bb9933', position: [0, 2.3, 0], shininess: 80 },
                    { name: 'visor', shape: 'box', width: 0.35, height: 0.12, depth: 0.1, color: '#ffdd00', position: [0, 2.25, 0.25], emissive: '#ffaa00', shininess: 100 },
                    // Horns
                    { name: 'hornL', shape: 'cone', size: 0.08, height: 0.3, color: '#aa8822', position: [-0.25, 2.5, -0.1], rotation: [0, 0, -0.3], shininess: 60 },
                    { name: 'hornR', shape: 'cone', size: 0.08, height: 0.3, color: '#aa8822', position: [0.25, 2.5, -0.1], rotation: [0, 0, 0.3], shininess: 60 },
                    // Massive shoulders
                    { name: 'shoulderL', shape: 'box', width: 0.5, height: 0.4, depth: 0.4, color: '#ccaa44', position: [-0.8, 1.7, 0], shininess: 70 },
                    { name: 'shoulderR', shape: 'box', width: 0.5, height: 0.4, depth: 0.4, color: '#ccaa44', position: [0.8, 1.7, 0], shininess: 70 },
                    // Shoulder spikes
                    { name: 'spikeL', shape: 'cone', size: 0.1, height: 0.25, color: '#ffcc00', position: [-0.9, 1.95, 0], emissive: '#aa8800', shininess: 80 },
                    { name: 'spikeR', shape: 'cone', size: 0.1, height: 0.25, color: '#ffcc00', position: [0.9, 1.95, 0], emissive: '#aa8800', shininess: 80 },
                    // Arms
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.2, height: 0.8, color: '#bb9944', position: [-0.7, 1.0, 0], shininess: 50 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.15, radiusBottom: 0.2, height: 0.8, color: '#bb9944', position: [0.7, 1.0, 0], shininess: 50 },
                    // Shield on left arm
                    { name: 'shield', shape: 'box', width: 0.6, height: 0.8, depth: 0.1, color: '#ddcc66', position: [-0.9, 0.8, 0.2], emissive: '#554400', shininess: 90 },
                    // Hammer in right hand
                    { name: 'hammerHandle', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.05, height: 0.7, color: '#885522', position: [0.7, 0.5, 0.15], shininess: 30 },
                    { name: 'hammerHead', shape: 'box', width: 0.3, height: 0.25, depth: 0.2, color: '#ccaa44', position: [0.7, 0.15, 0.15], emissive: '#665522', shininess: 80 },
                    // Legs
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.2, height: 0.9, color: '#aa8833', position: [-0.3, 0.45, 0], shininess: 50 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.18, radiusBottom: 0.2, height: 0.9, color: '#aa8833', position: [0.3, 0.45, 0], shininess: 50 },
                    // Boots
                    { name: 'bootL', shape: 'box', width: 0.22, height: 0.15, depth: 0.3, color: '#775522', position: [-0.3, 0.07, 0.05], shininess: 40 },
                    { name: 'bootR', shape: 'box', width: 0.22, height: 0.15, depth: 0.3, color: '#775522', position: [0.3, 0.07, 0.05], shininess: 40 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            pyromancer: {
                scale: 0.9,
                bodyParts: [
                    // Robed torso
                    { name: 'robe', shape: 'cone', size: 0.4, height: 1.2, color: '#ff6622', position: [0, 0.6, 0], shininess: 30 },
                    // Upper body
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.6, depth: 0.35, color: '#dd5511', position: [0, 1.4, 0], shininess: 40 },
                    // Flame trim
                    { name: 'flameTrim', shape: 'box', width: 0.55, height: 0.1, depth: 0.4, color: '#ff8800', position: [0, 1.1, 0], emissive: '#ff4400', shininess: 60 },
                    // Head
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#ffaa66', position: [0, 1.9, 0], shininess: 50 },
                    // Hood
                    { name: 'hood', shape: 'box', width: 0.35, height: 0.25, depth: 0.3, color: '#cc4400', position: [0, 2.0, -0.05], shininess: 25 },
                    // Eyes (glowing)
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#ffff00', position: [-0.08, 1.92, 0.15], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#ffff00', position: [0.08, 1.92, 0.15], emissive: '#ffaa00', shininess: 100 },
                    // Arms with sleeves
                    { name: 'sleeveL', shape: 'cone', size: 0.15, height: 0.5, color: '#dd5511', position: [-0.4, 1.2, 0], rotation: [0, 0, 0.5], shininess: 30 },
                    { name: 'sleeveR', shape: 'cone', size: 0.15, height: 0.5, color: '#dd5511', position: [0.4, 1.2, 0], rotation: [0, 0, -0.5], shininess: 30 },
                    // Hands
                    { name: 'handL', shape: 'sphere', size: 0.08, color: '#ffaa66', position: [-0.55, 0.95, 0.1], shininess: 40 },
                    { name: 'handR', shape: 'sphere', size: 0.08, color: '#ffaa66', position: [0.55, 0.95, 0.1], shininess: 40 },
                    // Staff
                    { name: 'staff', shape: 'cylinder', radiusTop: 0.03, radiusBottom: 0.04, height: 1.8, color: '#442200', position: [0.6, 1.0, 0.1], shininess: 40 },
                    { name: 'staffOrb', shape: 'sphere', size: 0.12, color: '#ff4400', position: [0.6, 1.95, 0.1], emissive: '#ff2200', shininess: 100 },
                    // Fire effects around orb
                    { name: 'flame1', shape: 'cone', size: 0.06, height: 0.15, color: '#ffaa00', position: [0.6, 2.1, 0.1], emissive: '#ff6600', shininess: 80 },
                    { name: 'flame2', shape: 'cone', size: 0.05, height: 0.12, color: '#ffcc00', position: [0.55, 2.05, 0.15], emissive: '#ff8800', shininess: 80 },
                    { name: 'flame3', shape: 'cone', size: 0.05, height: 0.12, color: '#ffcc00', position: [0.65, 2.05, 0.05], emissive: '#ff8800', shininess: 80 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            },
            shadowblade: {
                scale: 0.95,
                bodyParts: [
                    // Lean torso
                    { name: 'torso', shape: 'box', width: 0.5, height: 0.8, depth: 0.3, color: '#8844ff', position: [0, 1.3, 0], emissive: '#220066', shininess: 50 },
                    // Chest armor (light)
                    { name: 'chest', shape: 'box', width: 0.45, height: 0.4, depth: 0.15, color: '#6633cc', position: [0, 1.5, 0.15], shininess: 70 },
                    // Head with mask
                    { name: 'head', shape: 'sphere', size: 0.2, color: '#9955ff', position: [0, 2.0, 0], shininess: 50 },
                    { name: 'mask', shape: 'box', width: 0.25, height: 0.15, depth: 0.12, color: '#333333', position: [0, 1.95, 0.12], shininess: 30 },
                    { name: 'eyes', shape: 'box', width: 0.2, height: 0.04, depth: 0.05, color: '#ff00ff', position: [0, 2.0, 0.18], emissive: '#cc00cc', shininess: 100 },
                    // Hood
                    { name: 'hood', shape: 'cone', size: 0.25, height: 0.3, color: '#442288', position: [0, 2.15, -0.05], shininess: 25 },
                    // Shoulders (spiked)
                    { name: 'shoulderL', shape: 'box', width: 0.2, height: 0.15, depth: 0.2, color: '#6633cc', position: [-0.4, 1.55, 0], shininess: 50 },
                    { name: 'shoulderR', shape: 'box', width: 0.2, height: 0.15, depth: 0.2, color: '#6633cc', position: [0.4, 1.55, 0], shininess: 50 },
                    // Arms
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.6, color: '#7744dd', position: [-0.4, 1.0, 0], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.6, color: '#7744dd', position: [0.4, 1.0, 0], shininess: 40 },
                    // Daggers
                    { name: 'daggerL', shape: 'box', width: 0.02, height: 0.4, depth: 0.06, color: '#aaaaaa', position: [-0.4, 0.55, 0.1], emissive: '#444444', shininess: 100 },
                    { name: 'daggerR', shape: 'box', width: 0.02, height: 0.4, depth: 0.06, color: '#aaaaaa', position: [0.4, 0.55, 0.1], emissive: '#444444', shininess: 100 },
                    // Dagger glow
                    { name: 'poisonL', shape: 'sphere', size: 0.03, color: '#00ff00', position: [-0.4, 0.35, 0.1], emissive: '#00cc00', shininess: 100 },
                    { name: 'poisonR', shape: 'sphere', size: 0.03, color: '#00ff00', position: [0.4, 0.35, 0.1], emissive: '#00cc00', shininess: 100 },
                    // Legs
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.7, color: '#6633cc', position: [-0.18, 0.35, 0], shininess: 40 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.7, color: '#6633cc', position: [0.18, 0.35, 0], shininess: 40 },
                    // Boots
                    { name: 'bootL', shape: 'box', width: 0.1, height: 0.08, depth: 0.18, color: '#332255', position: [-0.18, 0.04, 0.03], shininess: 30 },
                    { name: 'bootR', shape: 'box', width: 0.1, height: 0.08, depth: 0.18, color: '#332255', position: [0.18, 0.04, 0.03], shininess: 30 },
                    // Cloak
                    { name: 'cloak', shape: 'box', width: 0.6, height: 1.0, depth: 0.05, color: '#221144', position: [0, 1.0, -0.2], shininess: 15 }
                ],
                animations: { idle: true, walk: true, attack: true, cast: true }
            }
        };

        // Detailed creep models
        const CREEP_MODELS = {
            melee_radiant: {
                scale: 0.5,
                bodyParts: [
                    { name: 'body', shape: 'sphere', size: 0.35, color: '#00ff88', position: [0, 0.4, 0], emissive: '#004422', shininess: 50 },
                    { name: 'eye', shape: 'sphere', size: 0.08, color: '#ffffff', position: [0, 0.5, 0.25], emissive: '#00ffff', shininess: 100 },
                    { name: 'armL', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.25, color: '#00dd77', position: [-0.3, 0.35, 0], rotation: [0, 0, 0.5], shininess: 40 },
                    { name: 'armR', shape: 'cylinder', radiusTop: 0.05, radiusBottom: 0.07, height: 0.25, color: '#00dd77', position: [0.3, 0.35, 0], rotation: [0, 0, -0.5], shininess: 40 },
                    { name: 'legL', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.2, color: '#00bb66', position: [-0.15, 0.1, 0], shininess: 30 },
                    { name: 'legR', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.2, color: '#00bb66', position: [0.15, 0.1, 0], shininess: 30 }
                ]
            },
            melee_dire: {
                scale: 0.5,
                bodyParts: [
                    { name: 'body', shape: 'box', width: 0.4, height: 0.4, depth: 0.4, color: '#ff3c3c', position: [0, 0.4, 0], emissive: '#441111', shininess: 50 },
                    { name: 'spike1', shape: 'cone', size: 0.05, height: 0.15, color: '#ff5555', position: [0, 0.65, 0], emissive: '#cc2222', shininess: 60 },
                    { name: 'spike2', shape: 'cone', size: 0.04, height: 0.1, color: '#ff5555', position: [-0.15, 0.6, 0.1], rotation: [0.3, 0, -0.3], shininess: 60 },
                    { name: 'spike3', shape: 'cone', size: 0.04, height: 0.1, color: '#ff5555', position: [0.15, 0.6, 0.1], rotation: [0.3, 0, 0.3], shininess: 60 },
                    { name: 'eye', shape: 'sphere', size: 0.06, color: '#ffff00', position: [0, 0.45, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'legL', shape: 'box', width: 0.1, height: 0.25, depth: 0.1, color: '#cc2222', position: [-0.12, 0.12, 0], shininess: 30 },
                    { name: 'legR', shape: 'box', width: 0.1, height: 0.25, depth: 0.1, color: '#cc2222', position: [0.12, 0.12, 0], shininess: 30 }
                ]
            },
            ranged_radiant: {
                scale: 0.45,
                bodyParts: [
                    { name: 'body', shape: 'octahedron', size: 0.3, color: '#00ffaa', position: [0, 0.5, 0], emissive: '#005544', shininess: 70 },
                    { name: 'core', shape: 'sphere', size: 0.12, color: '#00ffff', position: [0, 0.5, 0], emissive: '#00cccc', shininess: 100 },
                    { name: 'orbiter1', shape: 'sphere', size: 0.05, color: '#88ffff', position: [0.25, 0.5, 0], emissive: '#44cccc', shininess: 80 },
                    { name: 'orbiter2', shape: 'sphere', size: 0.05, color: '#88ffff', position: [-0.25, 0.5, 0], emissive: '#44cccc', shininess: 80 },
                    { name: 'tail', shape: 'cone', size: 0.08, height: 0.2, color: '#00dd88', position: [0, 0.25, 0], rotation: [3.14, 0, 0], shininess: 50 }
                ]
            },
            ranged_dire: {
                scale: 0.45,
                bodyParts: [
                    { name: 'body', shape: 'octahedron', size: 0.3, color: '#ff6666', position: [0, 0.5, 0], emissive: '#552222', shininess: 70 },
                    { name: 'core', shape: 'sphere', size: 0.12, color: '#ff4444', position: [0, 0.5, 0], emissive: '#cc2222', shininess: 100 },
                    { name: 'eyeL', shape: 'sphere', size: 0.04, color: '#ffff00', position: [-0.1, 0.55, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.04, color: '#ffff00', position: [0.1, 0.55, 0.2], emissive: '#ffaa00', shininess: 100 },
                    { name: 'wing1', shape: 'box', width: 0.25, height: 0.02, depth: 0.15, color: '#cc4444', position: [-0.2, 0.5, -0.1], rotation: [0, 0, -0.3], shininess: 40 },
                    { name: 'wing2', shape: 'box', width: 0.25, height: 0.02, depth: 0.15, color: '#cc4444', position: [0.2, 0.5, -0.1], rotation: [0, 0, 0.3], shininess: 40 }
                ]
            },
            siege_radiant: {
                scale: 0.8,
                bodyParts: [
                    { name: 'hull', shape: 'box', width: 0.8, height: 0.5, depth: 1.0, color: '#00cc66', position: [0, 0.35, 0], shininess: 60 },
                    { name: 'turret', shape: 'cylinder', radiusTop: 0.2, radiusBottom: 0.25, height: 0.3, color: '#00aa55', position: [0, 0.65, 0], shininess: 50 },
                    { name: 'cannon', shape: 'cylinder', radiusTop: 0.06, radiusBottom: 0.08, height: 0.5, color: '#008844', position: [0, 0.7, 0.35], rotation: [1.3, 0, 0], shininess: 70 },
                    { name: 'cannonTip', shape: 'sphere', size: 0.08, color: '#00ffff', position: [0, 0.55, 0.55], emissive: '#00aaaa', shininess: 100 },
                    { name: 'trackL', shape: 'box', width: 0.15, height: 0.2, depth: 1.1, color: '#006633', position: [-0.45, 0.1, 0], shininess: 30 },
                    { name: 'trackR', shape: 'box', width: 0.15, height: 0.2, depth: 1.1, color: '#006633', position: [0.45, 0.1, 0], shininess: 30 },
                    { name: 'antenna', shape: 'cylinder', radiusTop: 0.02, radiusBottom: 0.02, height: 0.3, color: '#00ff88', position: [0.2, 0.9, -0.2], shininess: 50 },
                    { name: 'light', shape: 'sphere', size: 0.04, color: '#00ff00', position: [0.2, 1.05, -0.2], emissive: '#00ff00', shininess: 100 }
                ]
            },
            siege_dire: {
                scale: 0.8,
                bodyParts: [
                    { name: 'hull', shape: 'box', width: 0.8, height: 0.5, depth: 1.0, color: '#cc3333', position: [0, 0.35, 0], shininess: 60 },
                    { name: 'turret', shape: 'box', width: 0.4, height: 0.35, depth: 0.4, color: '#aa2222', position: [0, 0.65, 0], shininess: 50 },
                    { name: 'cannon', shape: 'cylinder', radiusTop: 0.08, radiusBottom: 0.1, height: 0.6, color: '#881111', position: [0, 0.7, 0.4], rotation: [1.2, 0, 0], shininess: 70 },
                    { name: 'muzzle', shape: 'cone', size: 0.1, height: 0.15, color: '#ff4400', position: [0, 0.5, 0.65], rotation: [1.57, 0, 0], emissive: '#cc2200', shininess: 80 },
                    { name: 'trackL', shape: 'box', width: 0.15, height: 0.25, depth: 1.1, color: '#661111', position: [-0.45, 0.12, 0], shininess: 30 },
                    { name: 'trackR', shape: 'box', width: 0.15, height: 0.25, depth: 1.1, color: '#661111', position: [0.45, 0.12, 0], shininess: 30 },
                    { name: 'spike1', shape: 'cone', size: 0.06, height: 0.2, color: '#ff5555', position: [-0.3, 0.85, -0.3], emissive: '#cc2222', shininess: 60 },
                    { name: 'spike2', shape: 'cone', size: 0.06, height: 0.2, color: '#ff5555', position: [0.3, 0.85, -0.3], emissive: '#cc2222', shininess: 60 }
                ]
            }
        };

        // Tower and structure models
        const STRUCTURE_MODELS = {
            tower_radiant: {
                scale: 1.0,
                bodyParts: [
                    // Base
                    { name: 'base', shape: 'cylinder', radiusTop: 1.2, radiusBottom: 1.5, height: 0.5, color: '#1a3a2a', position: [0, 0.25, 0], shininess: 40 },
                    { name: 'baseRing', shape: 'cylinder', radiusTop: 1.55, radiusBottom: 1.55, height: 0.1, color: '#00ff88', position: [0, 0.5, 0], emissive: '#004422', shininess: 80 },
                    // Main tower
                    { name: 'tower1', shape: 'cylinder', radiusTop: 0.9, radiusBottom: 1.1, height: 2.0, color: '#2a4a3a', position: [0, 1.5, 0], shininess: 50 },
                    { name: 'tower2', shape: 'cylinder', radiusTop: 0.7, radiusBottom: 0.9, height: 1.5, color: '#3a5a4a', position: [0, 3.0, 0], shininess: 50 },
                    { name: 'tower3', shape: 'cylinder', radiusTop: 0.5, radiusBottom: 0.7, height: 1.0, color: '#4a6a5a', position: [0, 4.0, 0], shininess: 50 },
                    // Crystal top
                    { name: 'crystal', shape: 'octahedron', size: 0.6, color: '#00ffaa', position: [0, 5.0, 0], emissive: '#00ff88', shininess: 100 },
                    { name: 'crystalGlow', shape: 'sphere', size: 0.4, color: '#00ffff', position: [0, 5.0, 0], emissive: '#00ffff', shininess: 100 },
                    // Decorative rings
                    { name: 'ring1', shape: 'cylinder', radiusTop: 0.95, radiusBottom: 0.95, height: 0.08, color: '#00dd88', position: [0, 2.0, 0], emissive: '#006644', shininess: 70 },
                    { name: 'ring2', shape: 'cylinder', radiusTop: 0.75, radiusBottom: 0.75, height: 0.08, color: '#00dd88', position: [0, 3.2, 0], emissive: '#006644', shininess: 70 },
                    // Floating orbs
                    { name: 'orb1', shape: 'sphere', size: 0.15, color: '#00ff88', position: [0.8, 3.5, 0.8], emissive: '#00cc66', shininess: 90 },
                    { name: 'orb2', shape: 'sphere', size: 0.15, color: '#00ff88', position: [-0.8, 3.5, 0.8], emissive: '#00cc66', shininess: 90 },
                    { name: 'orb3', shape: 'sphere', size: 0.15, color: '#00ff88', position: [0, 3.5, -1.0], emissive: '#00cc66', shininess: 90 }
                ]
            },
            tower_dire: {
                scale: 1.0,
                bodyParts: [
                    // Base
                    { name: 'base', shape: 'box', width: 2.5, height: 0.5, depth: 2.5, color: '#2a1a1a', position: [0, 0.25, 0], shininess: 40 },
                    { name: 'baseSpike1', shape: 'cone', size: 0.2, height: 0.4, color: '#ff3c3c', position: [-1.0, 0.7, -1.0], emissive: '#661111', shininess: 60 },
                    { name: 'baseSpike2', shape: 'cone', size: 0.2, height: 0.4, color: '#ff3c3c', position: [1.0, 0.7, -1.0], emissive: '#661111', shininess: 60 },
                    { name: 'baseSpike3', shape: 'cone', size: 0.2, height: 0.4, color: '#ff3c3c', position: [-1.0, 0.7, 1.0], emissive: '#661111', shininess: 60 },
                    { name: 'baseSpike4', shape: 'cone', size: 0.2, height: 0.4, color: '#ff3c3c', position: [1.0, 0.7, 1.0], emissive: '#661111', shininess: 60 },
                    // Main tower
                    { name: 'tower1', shape: 'box', width: 1.8, height: 2.0, depth: 1.8, color: '#3a2020', position: [0, 1.5, 0], shininess: 50 },
                    { name: 'tower2', shape: 'box', width: 1.4, height: 1.5, depth: 1.4, color: '#4a2a2a', position: [0, 3.0, 0], shininess: 50 },
                    { name: 'tower3', shape: 'box', width: 1.0, height: 1.0, depth: 1.0, color: '#5a3a3a', position: [0, 4.0, 0], shininess: 50 },
                    // Skull top
                    { name: 'skull', shape: 'sphere', size: 0.5, color: '#ccccaa', position: [0, 4.8, 0], shininess: 60 },
                    { name: 'eyeL', shape: 'sphere', size: 0.12, color: '#ff0000', position: [-0.15, 4.85, 0.35], emissive: '#ff0000', shininess: 100 },
                    { name: 'eyeR', shape: 'sphere', size: 0.12, color: '#ff0000', position: [0.15, 4.85, 0.35], emissive: '#ff0000', shininess: 100 },
                    // Flame braziers
                    { name: 'brazier1', shape: 'cone', size: 0.25, height: 0.4, color: '#ff6600', position: [0.7, 3.8, 0.7], emissive: '#ff4400', shininess: 80 },
                    { name: 'brazier2', shape: 'cone', size: 0.25, height: 0.4, color: '#ff6600', position: [-0.7, 3.8, 0.7], emissive: '#ff4400', shininess: 80 },
                    { name: 'brazier3', shape: 'cone', size: 0.25, height: 0.4, color: '#ff6600', position: [0.7, 3.8, -0.7], emissive: '#ff4400', shininess: 80 },
                    { name: 'brazier4', shape: 'cone', size: 0.25, height: 0.4, color: '#ff6600', position: [-0.7, 3.8, -0.7], emissive: '#ff4400', shininess: 80 }
                ]
            },
            base_radiant: {
                scale: 1.5,
                bodyParts: [
                    // Main structure
                    { name: 'platform', shape: 'cylinder', radiusTop: 3.0, radiusBottom: 3.5, height: 0.5, color: '#1a3a2a', position: [0, 0.25, 0], shininess: 40 },
                    { name: 'tree', shape: 'cone', size: 2.0, height: 5.0, color: '#228844', position: [0, 3.0, 0], shininess: 30 },
                    { name: 'trunk', shape: 'cylinder', radiusTop: 0.5, radiusBottom: 0.8, height: 2.0, color: '#554422', position: [0, 1.0, 0], shininess: 25 },
                    { name: 'crystal1', shape: 'octahedron', size: 0.4, color: '#00ffaa', position: [1.5, 1.5, 0], emissive: '#00ff88', shininess: 100 },
                    { name: 'crystal2', shape: 'octahedron', size: 0.4, color: '#00ffaa', position: [-1.5, 1.5, 0], emissive: '#00ff88', shininess: 100 },
                    { name: 'crystal3', shape: 'octahedron', size: 0.4, color: '#00ffaa', position: [0, 1.5, 1.5], emissive: '#00ff88', shininess: 100 },
                    { name: 'crystal4', shape: 'octahedron', size: 0.4, color: '#00ffaa', position: [0, 1.5, -1.5], emissive: '#00ff88', shininess: 100 },
                    { name: 'glow', shape: 'sphere', size: 1.0, color: '#00ff88', position: [0, 4.0, 0], emissive: '#00ff88', shininess: 100 }
                ]
            },
            base_dire: {
                scale: 1.5,
                bodyParts: [
                    // Dark throne
                    { name: 'platform', shape: 'box', width: 6.0, height: 0.5, depth: 6.0, color: '#2a1a1a', position: [0, 0.25, 0], shininess: 40 },
                    { name: 'throne', shape: 'box', width: 2.0, height: 4.0, depth: 1.5, color: '#3a2020', position: [0, 2.5, 0], shininess: 50 },
                    { name: 'spikeL', shape: 'cone', size: 0.5, height: 3.0, color: '#ff3c3c', position: [-1.5, 3.5, 0], emissive: '#661111', shininess: 70 },
                    { name: 'spikeR', shape: 'cone', size: 0.5, height: 3.0, color: '#ff3c3c', position: [1.5, 3.5, 0], emissive: '#661111', shininess: 70 },
                    { name: 'skull1', shape: 'sphere', size: 0.5, color: '#ccccaa', position: [-2.0, 0.8, 2.0], shininess: 50 },
                    { name: 'skull2', shape: 'sphere', size: 0.5, color: '#ccccaa', position: [2.0, 0.8, 2.0], shininess: 50 },
                    { name: 'skull3', shape: 'sphere', size: 0.5, color: '#ccccaa', position: [-2.0, 0.8, -2.0], shininess: 50 },
                    { name: 'skull4', shape: 'sphere', size: 0.5, color: '#ccccaa', position: [2.0, 0.8, -2.0], shininess: 50 },
                    { name: 'orb', shape: 'sphere', size: 0.8, color: '#ff0000', position: [0, 4.5, 0], emissive: '#cc0000', shininess: 100 }
                ]
            }
        };

        // 3D Model Builder Function
        function buildModel(modelDef, teamColor = null) {
            const group = new THREE.Group();
            const scale = modelDef.scale || 1.0;

            modelDef.bodyParts.forEach(part => {
                let geometry;
                let color = teamColor || new THREE.Color(part.color);

                // Create geometry based on shape
                switch(part.shape) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            part.width || 1,
                            part.height || 1,
                            part.depth || 1
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(part.size || 0.5, 16, 16);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            part.radiusTop || 0.5,
                            part.radiusBottom || 0.5,
                            part.height || 1,
                            16
                        );
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(part.size || 0.5, part.height || 1, 16);
                        break;
                    case 'octahedron':
                        geometry = new THREE.OctahedronGeometry(part.size || 0.5);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }

                // Create material
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 1 - (part.shininess || 50) / 100,
                    metalness: (part.shininess || 50) / 200,
                    emissive: part.emissive ? new THREE.Color(part.emissive) : new THREE.Color(0x000000),
                    emissiveIntensity: part.emissive ? 0.5 : 0
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Set position
                if (part.position) {
                    mesh.position.set(
                        part.position[0] * scale,
                        part.position[1] * scale,
                        part.position[2] * scale
                    );
                }

                // Set rotation
                if (part.rotation) {
                    mesh.rotation.set(part.rotation[0], part.rotation[1], part.rotation[2]);
                }

                // Scale the mesh
                mesh.scale.multiplyScalar(scale);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = part.name;

                group.add(mesh);
            });

            return group;
        }

        // Animation System
        const AnimationSystem = {
            animations: new Map(),

            // Register an entity for animation
            register(entity, animationType) {
                this.animations.set(entity, {
                    type: animationType,
                    phase: Math.random() * Math.PI * 2,
                    walkPhase: 0,
                    attackPhase: 0,
                    isAttacking: false
                });
            },

            // Update all animations
            update(dt) {
                this.animations.forEach((anim, entity) => {
                    if (!entity || entity.dead || !entity.mesh) return;

                    anim.phase += dt * 2;

                    // Idle animation (breathing/bobbing)
                    const breathe = 1 + Math.sin(anim.phase) * 0.03;
                    const bob = Math.sin(anim.phase * 1.5) * 0.05;

                    // Apply idle animation
                    if (entity.modelGroup) {
                        entity.modelGroup.scale.y = breathe;
                        entity.modelGroup.position.y = bob;

                        // Walk animation
                        if (entity.isMoving) {
                            anim.walkPhase += dt * 12;
                            const walkBob = Math.abs(Math.sin(anim.walkPhase)) * 0.1;
                            const walkTilt = Math.sin(anim.walkPhase) * 0.05;
                            entity.modelGroup.position.y += walkBob;
                            entity.modelGroup.rotation.z = walkTilt;
                        } else {
                            entity.modelGroup.rotation.z *= 0.9;
                        }

                        // Attack animation
                        if (anim.isAttacking) {
                            anim.attackPhase += dt * 15;
                            const attackLean = Math.sin(anim.attackPhase) * 0.2;
                            entity.modelGroup.rotation.x = attackLean;

                            if (anim.attackPhase > Math.PI) {
                                anim.isAttacking = false;
                                anim.attackPhase = 0;
                            }
                        } else {
                            entity.modelGroup.rotation.x *= 0.9;
                        }
                    }
                });
            },

            // Trigger attack animation
            triggerAttack(entity) {
                const anim = this.animations.get(entity);
                if (anim) {
                    anim.isAttacking = true;
                    anim.attackPhase = 0;
                }
            }
        };

        // Particle System for Effects
        const ParticleSystem = {
            particles: [],
            maxParticles: 500,

            createParticle(config) {
                if (this.particles.length >= this.maxParticles) {
                    // Remove oldest particle
                    const old = this.particles.shift();
                    if (old.mesh) scene.remove(old.mesh);
                }

                const geometry = new THREE.SphereGeometry(config.size || 0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: config.color || 0xffffff,
                    transparent: true,
                    opacity: config.opacity || 1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(config.x, config.y, config.z);
                scene.add(mesh);

                const particle = {
                    mesh,
                    vx: config.vx || 0,
                    vy: config.vy || 0,
                    vz: config.vz || 0,
                    gravity: config.gravity || 0,
                    life: config.life || 1,
                    decay: config.decay || 0.02,
                    scale: config.scale || 1,
                    scaleDecay: config.scaleDecay || 0
                };

                this.particles.push(particle);
                return particle;
            },

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Update position
                    p.mesh.position.x += p.vx * dt * 60;
                    p.mesh.position.y += p.vy * dt * 60;
                    p.mesh.position.z += p.vz * dt * 60;

                    // Apply gravity
                    p.vy -= p.gravity * dt;

                    // Update life and opacity
                    p.life -= p.decay;
                    p.mesh.material.opacity = p.life;

                    // Update scale
                    if (p.scaleDecay) {
                        p.scale -= p.scaleDecay;
                        p.mesh.scale.setScalar(Math.max(0.01, p.scale));
                    }

                    // Remove dead particles
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            },

            // Create ability effect bursts
            createBurst(pos, color, count, config = {}) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const speed = config.speed || 0.1;
                    this.createParticle({
                        x: pos.x,
                        y: pos.y + (config.yOffset || 0.5),
                        z: pos.z,
                        vx: Math.cos(angle) * speed * (0.5 + Math.random() * 0.5),
                        vy: (config.vy || 0.05) + Math.random() * 0.1,
                        vz: Math.sin(angle) * speed * (0.5 + Math.random() * 0.5),
                        color: color,
                        size: config.size || 0.1,
                        life: config.life || 1,
                        decay: config.decay || 0.03,
                        gravity: config.gravity || 0.003
                    });
                }
            },

            // Fire trail effect
            createFireTrail(pos, direction) {
                for (let i = 0; i < 3; i++) {
                    this.createParticle({
                        x: pos.x + (Math.random() - 0.5) * 0.3,
                        y: pos.y + 0.5,
                        z: pos.z + (Math.random() - 0.5) * 0.3,
                        vx: -direction.x * 0.02 + (Math.random() - 0.5) * 0.02,
                        vy: 0.03 + Math.random() * 0.02,
                        vz: -direction.z * 0.02 + (Math.random() - 0.5) * 0.02,
                        color: 0xff6600 + Math.floor(Math.random() * 0x003300),
                        size: 0.08 + Math.random() * 0.05,
                        life: 0.6,
                        decay: 0.04,
                        gravity: -0.001
                    });
                }
            },

            // Magic sparkles
            createSparkles(pos, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    this.createParticle({
                        x: pos.x + (Math.random() - 0.5) * 0.5,
                        y: pos.y + Math.random() * 1.5,
                        z: pos.z + (Math.random() - 0.5) * 0.5,
                        vx: (Math.random() - 0.5) * 0.02,
                        vy: 0.02 + Math.random() * 0.02,
                        vz: (Math.random() - 0.5) * 0.02,
                        color: color,
                        size: 0.04 + Math.random() * 0.03,
                        life: 0.8,
                        decay: 0.02,
                        gravity: -0.002
                    });
                }
            }
        };

        // Globals
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let entities = [];
        let player = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let gameTime = 0;
        let score = { radiant: 0, dire: 0 };
        let portraitScene, portraitCamera, portraitRenderer, portraitMesh;

        // ROUND 1: Data Persistence System
        const STORAGE_KEYS = {
            matchHistory: 'dota3_match_history',
            settings: 'dota3_settings'
        };

        const defaultSettings = {
            bloomEnabled: true,
            bloomStrength: 1.2,
            showDamageNumbers: true,
            soundEnabled: true  // ROUND 3: Enabled by default
        };

        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.settings);
                return saved ? { ...defaultSettings, ...JSON.parse(saved) } : { ...defaultSettings };
            } catch (e) {
                return { ...defaultSettings };
            }
        }

        function saveSettings(settings) {
            try {
                localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(settings));
            } catch (e) {
                console.warn('Failed to save settings:', e);
            }
        }

        function loadMatchHistory() {
            try {
                const data = localStorage.getItem(STORAGE_KEYS.matchHistory);
                return data ? JSON.parse(data) : { matches: [], bestKills: 0, totalPlayTime: 0 };
            } catch (e) {
                return { matches: [], bestKills: 0, totalPlayTime: 0 };
            }
        }

        function saveMatchResult() {
            if (!player) return;
            const history = loadMatchHistory();
            const matchResult = {
                date: new Date().toISOString(),
                radiantScore: score.radiant,
                direScore: score.dire,
                gameTime: Math.floor(gameTime),
                playerSurvived: !player.dead
            };

            history.matches.unshift(matchResult);
            history.matches = history.matches.slice(0, 20);
            history.bestKills = Math.max(history.bestKills, score.radiant);
            history.totalPlayTime += Math.floor(gameTime);

            try {
                localStorage.setItem(STORAGE_KEYS.matchHistory, JSON.stringify(history));
            } catch (e) {
                console.warn('Failed to save match:', e);
            }
        }

        function exportGameData() {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                matchHistory: loadMatchHistory(),
                settings: loadSettings()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dota3-legacy-save-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Data Exported');
        }

        function importGameData(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.version && data.matchHistory) {
                        localStorage.setItem(STORAGE_KEYS.matchHistory, JSON.stringify(data.matchHistory));
                        if (data.settings) {
                            localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(data.settings));
                        }
                        showMessage('Import Successful');
                    } else {
                        showMessage('Invalid Save File');
                    }
                } catch (err) {
                    showMessage('Import Failed');
                }
            };
            reader.readAsText(file);
        }

        // ROUND 1: Entity cleanup system
        function cleanupDeadEntities() {
            const before = entities.length;
            entities = entities.filter(e => !e.dead);
            // Cleanup runs silently - no log spam
        }

        let gameSettings = loadSettings();

        // ROUND 3: Web Audio Sound System
        const AudioManager = {
            ctx: null,
            masterGain: null,

            init() {
                if (this.ctx) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.connect(this.ctx.destination);
                    this.masterGain.gain.value = 0.25;
                } catch (e) { console.warn('Web Audio not supported'); }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },

            playHit(type = 'physical') {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                if (type === 'crit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(150, now + 0.15);
                } else {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(120 + Math.random() * 40, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                }
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            playCast(key) {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                const freqs = { q: [400, 1000], w: [1500, 100], e: [220, 220], r: [80, 40] };
                const f = freqs[key] || [400, 200];
                osc.type = key === 'r' ? 'sawtooth' : 'sine';
                osc.frequency.setValueAtTime(f[0], now);
                osc.frequency.exponentialRampToValueAtTime(f[1], now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + (key === 'r' ? 0.5 : 0.2));
                osc.start(now);
                osc.stop(now + (key === 'r' ? 0.5 : 0.2));
            },

            playUI(type) {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);

                if (type === 'notification') {
                    osc.frequency.setValueAtTime(523, now);
                    osc.frequency.setValueAtTime(659, now + 0.08);
                } else if (type === 'click') {
                    osc.frequency.setValueAtTime(800, now);
                }
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            // ROUND 5: Error sound for failed casts
            playError() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.setValueAtTime(100, now + 0.05);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // ROUND 9: Purchase sound (coin/cash register feel)
            playPurchase() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.setValueAtTime(1200, now + 0.05);
                osc.frequency.setValueAtTime(1600, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            // ROUND 9: Level up fanfare
            playLevelUp() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                // Ascending arpeggio
                [523, 659, 784, 1047].forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.frequency.setValueAtTime(freq, now + i * 0.08);
                    gain.gain.setValueAtTime(0.1, now + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.2);
                    osc.start(now + i * 0.08);
                    osc.stop(now + i * 0.08 + 0.25);
                });
            },

            // ROUND 9: Gold pickup chime
            playGold() {
                if (!gameSettings.soundEnabled || !this.ctx) return;
                this.resume();
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(1500, now);
                osc.frequency.setValueAtTime(2000, now + 0.03);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.12);
            }
        };

        // ROUND 2: Game State Management
        let gameState = 'playing'; // 'playing', 'paused', 'victory', 'defeat'
        let respawnTimer = 0;
        let isRespawning = false;
        let radiantBase = null;
        let direBase = null;

        // ROUND 4: Store interval IDs for cleanup
        let spawnIntervalId = null;
        let cleanupIntervalId = null;

        // ROUND 2: Performance - minimap throttling
        let lastMinimapUpdate = 0;
        const MINIMAP_UPDATE_INTERVAL = 200; // 5fps instead of 60fps

        // ROUND 2: Performance - UI value caching
        let cachedUI = { hp: -1, mp: -1 };

        // ROUND 9: Item Shop System
        const ITEMS = {
            // === CONSUMABLES ===
            salve: { name: 'Healing Salve', cost: 100, icon: 'üíä', effect: 'heal', value: 300, desc: '+300 HP (instant)', category: 'consumable' },
            clarity: { name: 'Clarity', cost: 75, icon: 'üíß', effect: 'mana_restore', value: 200, desc: '+200 Mana (instant)', category: 'consumable' },
            flask: { name: 'Magic Flask', cost: 150, icon: 'üß™', effect: 'heal_both', value: 200, desc: '+200 HP & Mana', category: 'consumable' },

            // === BASIC ITEMS ===
            boots: { name: 'Boots', cost: 300, icon: 'üë¢', effect: 'speed', value: 0.05, desc: '+20% Move Speed', category: 'basic' },
            blade: { name: 'Blade', cost: 400, icon: 'üó°Ô∏è', effect: 'damage', value: 15, desc: '+15 Damage', category: 'basic' },
            armor: { name: 'Chainmail', cost: 400, icon: 'üõ°Ô∏è', effect: 'armor', value: 3, desc: '+3 Armor', category: 'basic' },
            crystal: { name: 'Mana Crystal', cost: 250, icon: 'üíé', effect: 'mana', value: 150, desc: '+150 Max Mana', category: 'basic' },
            cloak: { name: 'Cloak', cost: 350, icon: 'üß•', effect: 'magic_resist', value: 0.15, desc: '+15% Magic Resist', category: 'basic' },
            gloves: { name: 'Attack Gloves', cost: 400, icon: 'üß§', effect: 'attack_speed', value: 0.2, desc: '+20% Attack Speed', category: 'basic' },
            ring: { name: 'Vitality Ring', cost: 300, icon: 'üíç', effect: 'hp', value: 200, desc: '+200 Max HP', category: 'basic' },
            pendant: { name: 'Sage Pendant', cost: 350, icon: 'üìø', effect: 'mana_regen', value: 2, desc: '+2 Mana/sec', category: 'basic' },

            // === TIER 2 ITEMS ===
            powerboots: { name: 'Power Treads', cost: 900, icon: 'üëü', effect: 'multi', values: { speed: 0.08, damage: 10, attack_speed: 0.15 }, desc: '+Speed, +Dmg, +AS', category: 'tier2', recipe: ['boots', 'gloves'] },
            broadsword: { name: 'Broadsword', cost: 1000, icon: '‚öîÔ∏è', effect: 'damage', value: 35, desc: '+35 Damage', category: 'tier2' },
            platemail: { name: 'Platemail', cost: 1000, icon: 'üõ°Ô∏è', effect: 'armor', value: 8, desc: '+8 Armor', category: 'tier2' },
            staffmana: { name: 'Staff of Wizardry', cost: 800, icon: 'ü™Ñ', effect: 'multi', values: { mana: 300, mana_regen: 3 }, desc: '+300 Mana, +3 MP/s', category: 'tier2' },
            vanguard: { name: 'Vanguard', cost: 1100, icon: 'üõ°Ô∏è', effect: 'multi', values: { hp: 300, armor: 5, block: 0.3 }, desc: '+HP, +Armor, 30% Block', category: 'tier2' },
            mask: { name: 'Mask of Death', cost: 800, icon: 'üé≠', effect: 'lifesteal', value: 0.15, desc: '15% Lifesteal', category: 'tier2' },

            // === TIER 3 ITEMS (with actives) ===
            blink: { name: 'Blink Dagger', cost: 2000, icon: 'üó°Ô∏è', effect: 'active_blink', cooldown: 12, desc: 'Active: Blink 12 units', category: 'tier3', hasActive: true },
            bkb: { name: 'Black King Bar', cost: 2500, icon: 'üëë', effect: 'active_bkb', cooldown: 60, desc: 'Active: Magic Immunity 5s', category: 'tier3', hasActive: true },
            shadowblade: { name: 'Shadow Blade', cost: 2200, icon: 'üåë', effect: 'active_invis', cooldown: 20, desc: 'Active: Invisibility 4s', category: 'tier3', hasActive: true },
            desolator: { name: 'Desolator', cost: 2800, icon: '‚ö´', effect: 'multi', values: { damage: 50, armor_reduce: 5 }, desc: '+50 Dmg, -5 Enemy Armor', category: 'tier3' },
            satanic: { name: 'Satanic', cost: 3000, icon: 'üòà', effect: 'multi', values: { hp: 400, lifesteal: 0.25 }, desc: '+HP, 25% Lifesteal', category: 'tier3' },
            butterfly: { name: 'Butterfly', cost: 3500, icon: 'ü¶ã', effect: 'multi', values: { damage: 30, attack_speed: 0.35, evasion: 0.25 }, desc: '+Dmg, +AS, 25% Evasion', category: 'tier3' },
            daedalus: { name: 'Daedalus', cost: 3200, icon: 'üèπ', effect: 'multi', values: { damage: 80, crit_chance: 0.25, crit_mult: 0.75 }, desc: '+80 Dmg, 25% Crit', category: 'tier3' },
            heart: { name: 'Heart of Tarrasque', cost: 4000, icon: '‚ù§Ô∏è', effect: 'multi', values: { hp: 800, hp_regen: 10 }, desc: '+800 HP, +10 HP/s', category: 'tier3' },
            radiance: { name: 'Radiance', cost: 4500, icon: '‚òÄÔ∏è', effect: 'aura_damage', value: 40, desc: 'Burns enemies for 40 DPS', category: 'tier3' },
            divine: { name: 'Divine Rapier', cost: 5000, icon: '‚ö°', effect: 'damage', value: 300, desc: '+300 Damage (!)', category: 'tier3' }
        };

        // Item active ability cooldowns
        const itemCooldowns = {};

        let shopOpen = false;

        function toggleShop() {
            shopOpen = !shopOpen;
            const panel = document.getElementById('shop-panel');
            if (panel) {
                panel.style.display = shopOpen ? 'block' : 'none';
                if (shopOpen) renderShopItems();
            }
        }

        function renderShopItems() {
            const container = document.getElementById('shop-items');
            if (!container || !player) return;

            container.innerHTML = '';
            for (const [id, item] of Object.entries(ITEMS)) {
                const canAfford = player.gold >= item.cost;
                const btn = document.createElement('button');
                btn.style.cssText = `
                    display:flex;align-items:center;gap:10px;padding:8px 12px;
                    background:${canAfford ? 'rgba(0,255,136,0.2)' : 'rgba(100,100,100,0.2)'};
                    border:1px solid ${canAfford ? '#00ff88' : '#555'};
                    border-radius:6px;cursor:${canAfford ? 'pointer' : 'not-allowed'};
                    color:${canAfford ? '#fff' : '#666'};font-size:12px;text-align:left;
                `;
                btn.innerHTML = `
                    <span style="font-size:20px;">${item.icon}</span>
                    <div style="flex:1;">
                        <div style="font-weight:600;">${item.name}</div>
                        <div style="font-size:10px;color:#8899aa;">${item.desc}</div>
                    </div>
                    <span style="color:#ffd700;font-weight:600;">${item.cost}g</span>
                `;
                if (canAfford) {
                    btn.onclick = () => buyItem(id);
                }
                container.appendChild(btn);
            }
        }

        function buyItem(itemId) {
            if (!player || player.dead) return;
            const item = ITEMS[itemId];
            if (!item || player.gold < item.cost) return;

            player.gold -= item.cost;
            applyItemEffect(item);

            // ROUND 9: Play purchase sound
            AudioManager.playPurchase();

            // Add to inventory display
            player.inventory = player.inventory || [];
            if (item.effect !== 'heal') { // Consumables don't go to inventory
                player.inventory.push(itemId);
                updateInventoryUI();
            }

            renderShopItems(); // Refresh shop
            showMessage(`Purchased ${item.name}!`);
        }

        function applyItemEffect(item) {
            if (!player) return;

            // Handle multi-effect items
            if (item.effect === 'multi' && item.values) {
                for (const [key, val] of Object.entries(item.values)) {
                    applySingleEffect(key, val);
                }
                return;
            }

            // Handle active items (just store, don't apply passive)
            if (item.hasActive) {
                player.activeItems = player.activeItems || [];
                player.activeItems.push(item);
                return;
            }

            // Handle single effect
            applySingleEffect(item.effect, item.value);
        }

        function applySingleEffect(effect, value) {
            if (!player) return;

            switch (effect) {
                case 'heal':
                    player.hp = Math.min(player.hp + value, player.maxHp);
                    createExplosion(player.mesh.position, 0x00ff00, 15);
                    break;
                case 'mana_restore':
                    player.mp = Math.min(player.mp + value, player.maxMp);
                    createExplosion(player.mesh.position, 0x0088ff, 15);
                    break;
                case 'heal_both':
                    player.hp = Math.min(player.hp + value, player.maxHp);
                    player.mp = Math.min(player.mp + value, player.maxMp);
                    createExplosion(player.mesh.position, 0x88ff88, 15);
                    break;
                case 'speed':
                    player.speed += value;
                    break;
                case 'damage':
                    player.damage += value;
                    player.updateLevelUI();
                    break;
                case 'armor':
                    player.armor += value;
                    player.updateLevelUI();
                    break;
                case 'mana':
                    player.maxMp += value;
                    player.mp += value;
                    break;
                case 'hp':
                    player.maxHp += value;
                    player.hp += value;
                    break;
                case 'magic_resist':
                    player.magicResist = (player.magicResist || 0) + value;
                    break;
                case 'attack_speed':
                    player.attackSpeed = (player.attackSpeed || 1) * (1 + value);
                    break;
                case 'mana_regen':
                    player.manaRegen = (player.manaRegen || 0) + value;
                    break;
                case 'hp_regen':
                    player.hpRegen = (player.hpRegen || 0) + value;
                    break;
                case 'lifesteal':
                    player.lifesteal = (player.lifesteal || 0) + value;
                    break;
                case 'evasion':
                    player.evasion = (player.evasion || 0) + value;
                    break;
                case 'block':
                    player.blockChance = (player.blockChance || 0) + value;
                    break;
                case 'crit_chance':
                    player.critChance = (player.critChance || 0) + value;
                    break;
                case 'crit_mult':
                    player.critMultiplier = (player.critMultiplier || 2) + value;
                    break;
                case 'armor_reduce':
                    player.armorReduction = (player.armorReduction || 0) + value;
                    break;
                case 'aura_damage':
                    player.radianceAura = value;
                    break;
            }
        }

        // Use active item (1-6 keys)
        function useActiveItem(slot) {
            if (!player || !player.activeItems || !player.activeItems[slot]) return;

            const item = player.activeItems[slot];
            const cooldownKey = `item_${slot}`;

            if (itemCooldowns[cooldownKey] && itemCooldowns[cooldownKey] > 0) {
                showMessage('Item on cooldown!');
                return;
            }

            switch (item.effect) {
                case 'active_blink':
                    player.performBlink(12, 0xffaa00);
                    break;
                case 'active_bkb':
                    player.magicImmune = true;
                    createShield(player, 0);
                    setTimeout(() => { player.magicImmune = false; }, 5000);
                    break;
                case 'active_invis':
                    player.invisible = true;
                    player.mesh.visible = false;
                    setTimeout(() => {
                        player.invisible = false;
                        player.mesh.visible = true;
                    }, 4000);
                    break;
            }

            itemCooldowns[cooldownKey] = item.cooldown;
            showMessage(`Used ${item.name}!`);
        }

        function updateInventoryUI() {
            const container = document.getElementById('inventory-panel');
            if (!container || !player) return;

            container.innerHTML = '';
            (player.inventory || []).forEach(itemId => {
                const item = ITEMS[itemId];
                if (!item) return;
                const slot = document.createElement('div');
                slot.style.cssText = `
                    width:28px;height:28px;background:rgba(20,20,30,0.8);
                    border:1px solid #444;border-radius:4px;display:flex;
                    align-items:center;justify-content:center;font-size:16px;
                `;
                slot.textContent = item.icon;
                slot.title = item.name;
                container.appendChild(slot);
            });
        }

        // ROUND 2: Screen Shake System
        const screenShake = {
            intensity: 0,
            decay: 0.9,
            maxOffset: { x: 0, y: 0 },

            shake(amount, duration = 0.3) {
                this.intensity = Math.min(this.intensity + amount, 1.0);
                this.decay = Math.pow(0.01, 1 / (duration * 60));
            },

            update() {
                if (this.intensity > 0.01) {
                    const shakeAmount = this.intensity * 1.5;
                    this.maxOffset.x = (Math.random() - 0.5) * shakeAmount;
                    this.maxOffset.y = (Math.random() - 0.5) * shakeAmount * 0.5;
                    this.intensity *= this.decay;
                } else {
                    this.maxOffset.x = 0;
                    this.maxOffset.y = 0;
                    this.intensity = 0;
                }
                return this.maxOffset;
            },

            light() { this.shake(0.2, 0.15); },
            medium() { this.shake(0.4, 0.25); },
            heavy() { this.shake(0.7, 0.4); }
        };

        function togglePause() {
            if (gameState === 'victory' || gameState === 'defeat') return;
            if (gameState === 'paused') {
                gameState = 'playing';
                clock.start();
                document.getElementById('pause-overlay').style.display = 'none';
            } else {
                gameState = 'paused';
                clock.stop();
                document.getElementById('pause-overlay').style.display = 'flex';
            }
        }

        function checkWinConditions() {
            if (gameState !== 'playing') return;

            if (direBase && direBase.dead) {
                endGame('victory');
            } else if (radiantBase && radiantBase.dead) {
                // ROUND 4: Actually trigger defeat when base is destroyed!
                endGame('defeat');
            }
            // Note: Player death triggers respawn (handled in die() method), not immediate defeat
        }

        function endGame(result) {
            gameState = result;
            saveMatchResult();

            // ROUND 4: Clear intervals to prevent memory leaks
            if (spawnIntervalId) { clearInterval(spawnIntervalId); spawnIntervalId = null; }
            if (cleanupIntervalId) { clearInterval(cleanupIntervalId); cleanupIntervalId = null; }

            const overlay = document.createElement('div');
            overlay.id = 'game-over-overlay';
            overlay.style.cssText = `
                position:fixed;top:0;left:0;right:0;bottom:0;
                background:rgba(0,0,0,0.9);display:flex;flex-direction:column;
                justify-content:center;align-items:center;z-index:500;
            `;
            overlay.innerHTML = `
                <h1 style="font-family:var(--font-display);font-size:64px;margin:0;
                    color:${result === 'victory' ? '#00ff88' : '#ff3c3c'};
                    text-shadow:0 0 30px currentColor;">
                    ${result === 'victory' ? 'VICTORY' : 'DEFEAT'}
                </h1>
                <p style="color:#8899aa;font-size:20px;margin:20px 0;">
                    Time: ${document.getElementById('game-time').textContent} |
                    Score: ${score.radiant} - ${score.dire}
                </p>
                <button onclick="location.reload()" style="
                    padding:15px 40px;font-size:18px;background:var(--accent-radiant);
                    border:none;border-radius:8px;cursor:pointer;color:#000;font-weight:600;
                    margin-top:20px;">
                    Play Again
                </button>
            `;
            document.body.appendChild(overlay);
        }

        function respawnHero() {
            if (!player) return;
            isRespawning = false;
            player.dead = false;
            player.hp = player.maxHp;
            player.mp = player.maxMp;

            player.mesh.position.set(-40, 0, -40);
            player.targetPos.set(-40, 0, -40);
            scene.add(player.mesh);

            // Reset cooldowns
            for (let key in player.abilities) {
                player.abilities[key].currentCd = 0;
            }

            showMessage('Hero Respawned!');
            document.getElementById('respawn-timer').style.display = 'none';
        }

        // Visuals
        let floatingTexts = [];

        // --- CLASSES ---

        class FloatingText {
            constructor(text, x, y, z, color) {
                this.element = document.createElement('div');
                this.element.textContent = text;
                this.element.className = 'damage-number';
                this.element.style.color = color;
                document.body.appendChild(this.element);

                // Project 3D pos to 2D
                this.pos = new THREE.Vector3(x, y + 2, z);
                this.updatePosition();

                // Cleanup
                setTimeout(() => {
                    if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
                    const index = floatingTexts.indexOf(this);
                    if (index > -1) floatingTexts.splice(index, 1);
                }, 1000);
            }

            updatePosition() {
                const tempV = this.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * window.innerWidth;
                const y = (tempV.y * -.5 + .5) * window.innerHeight;
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
            }
        }

        class GameEntity {
            constructor(x, z, team, color) {
                this.team = team;
                this.color = color;
                this.hp = 100;
                this.maxHp = 100;
                this.dead = false;

                // ROUND 7: Combat stats
                this.armor = 0;          // Reduces physical damage
                this.attackSpeed = 1.0;  // Multiplier for attack cooldown
                this.damage = 10;        // Base damage
                this.critChance = 0;     // Chance to deal critical hit (0-1)
                this.critMultiplier = 2; // Damage multiplier on crit

                // Mesh
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);

                // ROUND 5: Add floating health bar above entity
                this.createHealthBar();

                // Physics
                this.targetPos = new THREE.Vector3(x, 0, z);
                this.speed = 0.1;
                this.radius = 0.5;
            }

            // ROUND 5: Create health bar above entity
            createHealthBar() {
                const barWidth = 1.2;
                const barHeight = 0.12;

                // Background (dark)
                const bgGeo = new THREE.PlaneGeometry(barWidth, barHeight);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
                this.healthBarBg = new THREE.Mesh(bgGeo, bgMat);
                this.healthBarBg.position.set(0, 2.5, 0);
                this.healthBarBg.rotation.x = -0.3; // Tilt towards camera
                this.mesh.add(this.healthBarBg);

                // Foreground (team colored)
                const fgGeo = new THREE.PlaneGeometry(barWidth * 0.98, barHeight * 0.7);
                const fgMat = new THREE.MeshBasicMaterial({
                    color: this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c,
                    side: THREE.DoubleSide
                });
                this.healthBarFg = new THREE.Mesh(fgGeo, fgMat);
                this.healthBarFg.position.set(0, 2.5, 0.01);
                this.healthBarFg.rotation.x = -0.3;
                this.mesh.add(this.healthBarFg);
            }

            // ROUND 5: Update health bar scale based on current HP
            updateHealthBar() {
                if (!this.healthBarFg) return;
                const ratio = Math.max(0, this.hp / this.maxHp);
                this.healthBarFg.scale.x = ratio;
                // Offset to keep bar left-aligned
                this.healthBarFg.position.x = -(1 - ratio) * 0.6;
            }

            // ROUND 7: Attack with crit chance - returns actual damage dealt
            performAttack(target, baseDamage = null) {
                if (!target || target.dead) return 0;

                let dmg = baseDamage || this.damage;
                let isCrit = false;

                // Roll for crit
                if (this.critChance > 0 && Math.random() < this.critChance) {
                    dmg *= this.critMultiplier;
                    isCrit = true;
                }

                target.takeDamage(dmg, isCrit ? 'crit' : 'physical');
                return dmg;
            }

            // ROUND 7: Get attack interval based on attackSpeed
            getAttackInterval() {
                const baseInterval = 1.5; // seconds
                return baseInterval / this.attackSpeed;
            }

            update(dt) {
                if (this.dead) return;

                // Movement
                const dist = this.mesh.position.distanceTo(this.targetPos);
                if (dist > 0.1) {
                    const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(this.speed));
                    this.mesh.lookAt(this.targetPos);

                    // Walk wobble
                    if (this.bodyMesh) {
                        this.bodyMesh.position.y = 0.5 + Math.sin(clock.getElapsedTime() * 10) * 0.05;
                    }
                }

                // ROUND 5: Update health bar
                this.updateHealthBar();
            }

            takeDamage(amt, type = 'physical') {
                // ROUND 3: Play hit sound
                AudioManager.playHit(type);

                // ROUND 7: Apply armor reduction for physical damage
                // Formula: finalDamage = damage * (1 - armor * 0.06), min 20% damage
                if (type === 'physical' && this.armor > 0) {
                    const reduction = Math.min(0.8, this.armor * 0.06); // Cap at 80% reduction
                    amt = Math.max(1, amt * (1 - reduction));
                }

                // ROUND 3: Shield absorbs damage first
                if (this.shieldActive && this.shieldHealth > 0) {
                    const absorbed = Math.min(amt, this.shieldHealth);
                    this.shieldHealth -= absorbed;
                    amt -= absorbed;
                    spawnFloatingText(absorbed, this.mesh.position, '#00ff00'); // Green for shield

                    // Shield broken?
                    if (this.shieldHealth <= 0) {
                        this.shieldActive = false;
                        if (this.shieldMesh && this.mesh) {
                            this.mesh.remove(this.shieldMesh);
                        }
                        this.shieldMesh = null;
                        if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
                        showMessage('Shield Broken!');
                    }

                    if (amt <= 0) return; // All damage absorbed
                }

                this.hp -= amt;
                spawnFloatingText(amt, this.mesh.position, type === 'crit' ? '#ff3c3c' : '#fff');

                // ROUND 2: Screen shake on damage
                if (this === player) {
                    screenShake.light();
                }

                // Flash
                if (this.bodyMesh) {
                    const oldInfo = this.bodyMesh.material.emissive.getHex();
                    this.bodyMesh.material.emissive.setHex(0xffffff);
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissive.setHex(oldInfo);
                    }, 100);
                }

                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                this.dead = true;

                // ROUND 6: Clear shield state on death
                if (this.shieldTimeout) {
                    clearTimeout(this.shieldTimeout);
                    this.shieldTimeout = null;
                }
                this.shieldActive = false;
                this.shieldHealth = 0;
                this.shieldMesh = null;

                scene.remove(this.mesh);

                if (this.team === TEAM_RADIANT) score.dire++;
                else score.radiant++;
                updateScoreBoard();

                // ROUND 2: Player respawn system
                if (this === player) {
                    isRespawning = true;
                    respawnTimer = Math.min(30, 5 + Math.floor(gameTime / 60) * 3); // 5s base + 3s per minute, max 30s
                    showMessage(`Respawning in ${respawnTimer}s`);
                    document.getElementById('respawn-timer').style.display = 'block';
                }
            }
        }

        class Hero extends GameEntity {
            constructor(x, z, team, heroType = 'voidwalker') {
                // Get hero definition
                const heroDef = HERO_DEFS[heroType] || HERO_DEFS.voidwalker;
                const heroColor = heroDef.color;

                super(x, z, team, heroColor);
                this.heroType = heroType;
                this.heroDef = heroDef;

                // Use hero-specific stats
                this.hp = heroDef.stats.hp;
                this.maxHp = heroDef.stats.hp;
                this.mp = heroDef.stats.mp;
                this.maxMp = heroDef.stats.mp;
                this.speed = heroDef.stats.speed;

                // Combat stats from hero definition
                this.damage = heroDef.stats.damage;
                this.armor = heroDef.stats.armor;
                this.critChance = heroDef.stats.critChance;
                this.critMultiplier = 2.0;
                this.attackSpeed = 1.2;

                // Leveling system
                this.level = 1;
                this.xp = 0;
                this.xpToLevel = 100;
                this.lastAttack = 0;

                // Gold system
                this.gold = 600; // Starting gold for items

                // Build detailed 3D model from HERO_MODELS
                const modelDef = HERO_MODELS[heroType] || HERO_MODELS.voidwalker;
                this.modelGroup = buildModel(modelDef);
                this.mesh.add(this.modelGroup);

                // Store reference to main body mesh for animations
                this.bodyMesh = this.modelGroup.children.find(c => c.name === 'torso') || this.modelGroup.children[0];

                // Pointer Ring with hero color
                const ringGeo = new THREE.RingGeometry(0.8, 0.9, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: heroColor, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.ring.rotation.x = -Math.PI / 2;
                this.ring.position.y = 0.05;
                this.mesh.add(this.ring);

                // Register for animations
                AnimationSystem.register(this, 'hero');

                // Movement tracking for animations
                this.isMoving = false;
                this.lastPosition = new THREE.Vector3(x, 0, z);

                // Setup abilities from hero definition
                this.abilities = {
                    q: { cd: heroDef.abilities.q.cd, currentCd: 0, cost: heroDef.abilities.q.cost },
                    w: { cd: heroDef.abilities.w.cd, currentCd: 0, cost: heroDef.abilities.w.cost },
                    e: { cd: heroDef.abilities.e.cd, currentCd: 0, cost: heroDef.abilities.e.cost },
                    r: { cd: heroDef.abilities.r.cd, currentCd: 0, cost: heroDef.abilities.r.cost }
                };
            }

            // ROUND 7: Add XP from kill
            gainXP(amount) {
                this.xp += amount;

                // Check for level up
                while (this.xp >= this.xpToLevel && this.level < 25) {
                    this.xp -= this.xpToLevel;
                    this.levelUp();
                }
            }

            // ROUND 7: Level up with stat growth
            levelUp() {
                this.level++;

                // Stat growth per level
                this.maxHp += 100;
                this.hp = Math.min(this.hp + 100, this.maxHp);
                this.maxMp += 50;
                this.mp = Math.min(this.mp + 50, this.maxMp);
                this.damage += 5;
                this.armor += 0.5;

                // XP curve: 100, 200, 400, 800... (doubles each level)
                this.xpToLevel = Math.floor(100 * Math.pow(1.5, this.level - 1));

                // Visual feedback
                showMessage(`LEVEL UP! Now Level ${this.level}`);
                createExplosion(this.mesh.position, 0xffd700, 30);
                screenShake.medium();
                AudioManager.playLevelUp(); // ROUND 9: Level up sound

                // Update UI
                this.updateLevelUI();
            }

            updateLevelUI() {
                const levelEl = document.querySelector('.unit-level');
                if (levelEl) levelEl.textContent = `Lvl ${this.level}`;
                const dmgEl = document.getElementById('stat-dmg');
                if (dmgEl) dmgEl.textContent = Math.floor(this.damage);
                const armorEl = document.getElementById('stat-armor');
                if (armorEl) armorEl.textContent = this.armor.toFixed(1);
            }

            update(dt) {
                super.update(dt);
                // Mana regen
                if (this.mp < this.maxMp) this.mp += 0.2;

                // Update CD
                for (let key in this.abilities) {
                    if (this.abilities[key].currentCd > 0) {
                        this.abilities[key].currentCd -= dt;
                        updateCooldownUI(key, this.abilities[key].currentCd, this.abilities[key].cd);
                    }
                }

                // ROUND 7: Auto-attack nearby enemies
                const now = clock.getElapsedTime();
                if (now - this.lastAttack > this.getAttackInterval()) {
                    let nearestEnemy = null;
                    let minDist = 3; // Attack range

                    entities.forEach(e => {
                        if (e.team !== this.team && !e.dead && e.mesh) {
                            const d = this.mesh.position.distanceTo(e.mesh.position);
                            if (d < minDist) {
                                minDist = d;
                                nearestEnemy = e;
                            }
                        }
                    });

                    if (nearestEnemy) {
                        this.performAttack(nearestEnemy);
                        this.lastAttack = now;

                        // Weapon swing animation
                        if (this.weapon) {
                            this.weapon.rotation.x = -0.5;
                            setTimeout(() => {
                                if (this.weapon) this.weapon.rotation.x = 0;
                            }, 100);
                        }
                    }
                }

                updateHeroUI();

                // Update Floating Portrait
                if (portraitMesh) {
                    portraitMesh.rotation.y += 0.01;
                }
            }

            cast(key) {
                const ab = this.abilities[key];

                // ROUND 5: Failed cast feedback
                if (ab.currentCd > 0) {
                    AudioManager.playError();
                    flashAbilityError(key);
                    return;
                }
                if (this.mp < ab.cost) {
                    AudioManager.playError();
                    flashAbilityError(key);
                    showMessage('Not Enough Mana');
                    return;
                }

                this.mp -= ab.cost;

                // ROUND 8: Cooldown reduction at key levels (6, 12, 18)
                let cdMultiplier = 1.0;
                if (this.level >= 18) cdMultiplier = 0.7;
                else if (this.level >= 12) cdMultiplier = 0.8;
                else if (this.level >= 6) cdMultiplier = 0.9;
                ab.currentCd = ab.cd * cdMultiplier;

                // ROUND 3: Play cast sound
                AudioManager.playCast(key);

                // Ability power scaling with level (10% per level)
                const levelBonus = 1 + (this.level - 1) * 0.1;

                // Hero-specific ability implementations
                this.executeHeroAbility(key, levelBonus);
            }

            executeHeroAbility(key, levelBonus) {
                const heroType = this.heroType;
                const pos = this.mesh.position.clone();
                const MAP_BOUNDARY = 48;

                // === VOID WALKER ABILITIES ===
                if (heroType === 'voidwalker') {
                    if (key === 'q') {
                        // Void Bolt - Energy projectile that burns mana
                        createProjectile(pos, mouse, Math.floor(80 * levelBonus), 0x00ff88);
                    }
                    if (key === 'w') {
                        // Blink - Short range teleport
                        this.performBlink(8, 0x00ffff);
                    }
                    if (key === 'e') {
                        // Counterspell - Magic shield that reflects damage
                        createShield(this, Math.floor(150 * levelBonus));
                        this.magicResist = 0.5; // 50% magic resist for 3 seconds
                        setTimeout(() => { this.magicResist = 0; }, 3000);
                    }
                    if (key === 'r') {
                        // Mana Void - AoE damage based on missing mana
                        createManaVoid(pos, Math.floor(300 * levelBonus));
                    }
                }

                // === IRON CLAD ABILITIES ===
                else if (heroType === 'ironclad') {
                    if (key === 'q') {
                        // Shield Slam - AoE stun around hero
                        createShieldSlam(pos, Math.floor(60 * levelBonus));
                    }
                    if (key === 'w') {
                        // Charge - Rush forward, knock back enemies
                        this.performCharge(10, Math.floor(80 * levelBonus));
                    }
                    if (key === 'e') {
                        // Fortify - Massive armor boost
                        this.armor += 20;
                        createShield(this, Math.floor(300 * levelBonus));
                        createExplosion(pos, 0x888888, 15);
                        setTimeout(() => { this.armor -= 20; }, 5000);
                    }
                    if (key === 'r') {
                        // Earthquake - Huge AoE damage and slow
                        createEarthquake(pos, Math.floor(350 * levelBonus));
                    }
                }

                // === PYROMANCER ABILITIES ===
                else if (heroType === 'pyromancer') {
                    if (key === 'q') {
                        // Fireball - Fast fire projectile
                        createFireball(pos, mouse, Math.floor(100 * levelBonus));
                    }
                    if (key === 'w') {
                        // Flame Dash - Leave fire trail
                        this.performFlameDash(6);
                    }
                    if (key === 'e') {
                        // Inferno - Ring of fire around self
                        createInferno(pos, Math.floor(40 * levelBonus));
                    }
                    if (key === 'r') {
                        // Meteor - Massive fire explosion at target
                        createMeteor(mouse, Math.floor(500 * levelBonus));
                    }
                }

                // === SHADOW BLADE ABILITIES ===
                else if (heroType === 'shadowblade') {
                    if (key === 'q') {
                        // Shadow Strike - Teleport to target and backstab
                        this.performShadowStrike(Math.floor(120 * levelBonus));
                    }
                    if (key === 'w') {
                        // Vanish - Become invisible
                        this.performVanish();
                    }
                    if (key === 'e') {
                        // Fan of Knives - Throw knives in cone
                        createFanOfKnives(pos, this.targetPos, Math.floor(70 * levelBonus));
                    }
                    if (key === 'r') {
                        // Death Mark - Mark enemy for death, bonus damage
                        createDeathMark(pos, Math.floor(400 * levelBonus));
                    }
                }

                // Fallback for unknown heroes
                else {
                    if (key === 'q') createProjectile(pos, mouse, Math.floor(80 * levelBonus));
                    if (key === 'w') this.performBlink(5, 0xffff00);
                    if (key === 'e') createShield(this, Math.floor(200 * levelBonus));
                    if (key === 'r') createUlt(pos, Math.floor(400 * levelBonus));
                }
            }

            performBlink(distance, color) {
                const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                const startPos = this.mesh.position.clone();
                const newPos = startPos.clone().add(dir.clone().multiplyScalar(distance));
                const MAP_BOUNDARY = 48;
                newPos.x = Math.max(-MAP_BOUNDARY, Math.min(MAP_BOUNDARY, newPos.x));
                newPos.z = Math.max(-MAP_BOUNDARY, Math.min(MAP_BOUNDARY, newPos.z));

                // Create afterimage trail
                for (let i = 1; i <= 5; i++) {
                    const t = i / 6;
                    const afterPos = startPos.clone().lerp(newPos, t);
                    const afterimage = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.3, 0.8, 4, 8),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 - t * 0.4 })
                    );
                    afterimage.position.copy(afterPos);
                    afterimage.position.y = 0.8;
                    scene.add(afterimage);
                    setTimeout(() => {
                        let fade = afterimage.material.opacity;
                        const fadeOut = () => {
                            fade -= 0.1;
                            afterimage.material.opacity = fade;
                            if (fade > 0) requestAnimationFrame(fadeOut);
                            else scene.remove(afterimage);
                        };
                        fadeOut();
                    }, i * 30);
                }

                this.mesh.position.copy(newPos);
                this.targetPos.copy(this.mesh.position);
                createExplosion(this.mesh.position, color, 15);
            }

            performCharge(distance, damage) {
                const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                const startPos = this.mesh.position.clone();
                const endPos = startPos.clone().add(dir.clone().multiplyScalar(distance));

                // Damage and knockback enemies along path
                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const toEnemy = e.mesh.position.clone().sub(startPos);
                        const proj = toEnemy.dot(dir);
                        if (proj > 0 && proj < distance) {
                            const perpDist = toEnemy.clone().sub(dir.clone().multiplyScalar(proj)).length();
                            if (perpDist < 2) {
                                e.takeDamage(damage, 'physical');
                                // Knockback
                                const knockDir = e.mesh.position.clone().sub(startPos).normalize();
                                e.mesh.position.add(knockDir.multiplyScalar(3));
                                createExplosion(e.mesh.position, 0xffaa00, 10);
                            }
                        }
                    }
                });

                this.mesh.position.copy(endPos);
                this.targetPos.copy(this.mesh.position);
                createExplosion(endPos, 0xffaa00, 20);
            }

            performFlameDash(distance) {
                const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                const startPos = this.mesh.position.clone();
                const endPos = startPos.clone().add(dir.clone().multiplyScalar(distance));

                // Create fire trail
                for (let i = 0; i < 10; i++) {
                    const t = i / 10;
                    const firePos = startPos.clone().lerp(endPos, t);
                    setTimeout(() => {
                        createFirePatch(firePos, 50, 3000);
                    }, i * 50);
                }

                this.mesh.position.copy(endPos);
                this.targetPos.copy(this.mesh.position);
            }

            performShadowStrike(damage) {
                // Find nearest enemy to teleport to
                let nearestEnemy = null;
                let minDist = 15;

                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            nearestEnemy = e;
                        }
                    }
                });

                if (nearestEnemy) {
                    const behindPos = nearestEnemy.mesh.position.clone();
                    const awayDir = behindPos.clone().sub(this.mesh.position).normalize();
                    behindPos.sub(awayDir.multiplyScalar(1.5));

                    createExplosion(this.mesh.position, 0x440066, 10);
                    this.mesh.position.copy(behindPos);
                    this.targetPos.copy(this.mesh.position);
                    createExplosion(this.mesh.position, 0x440066, 15);

                    // Backstab damage
                    nearestEnemy.takeDamage(damage * 1.5, 'physical');
                    showDamageNumber(nearestEnemy.mesh.position, damage * 1.5, true);
                }
            }

            performVanish() {
                this.invisible = true;
                this.mesh.visible = false;

                // Ghost trail effect
                const ghost = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.3, 0.8, 4, 8),
                    new THREE.MeshBasicMaterial({ color: 0x440066, transparent: true, opacity: 0.5 })
                );
                ghost.position.copy(this.mesh.position);
                ghost.position.y = 0.8;
                scene.add(ghost);

                let fadeTime = 1;
                const fadeGhost = () => {
                    fadeTime -= 0.05;
                    ghost.material.opacity = fadeTime * 0.5;
                    if (fadeTime > 0) requestAnimationFrame(fadeGhost);
                    else scene.remove(ghost);
                };
                fadeGhost();

                // Reveal after 4 seconds or on attack
                setTimeout(() => {
                    this.invisible = false;
                    this.mesh.visible = true;
                    createExplosion(this.mesh.position, 0x440066, 10);
                }, 4000);
            }
        }

        class Creep extends GameEntity {
            constructor(x, z, team) {
                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                super(x, z, team, color);
                this.hp = 300;
                this.maxHp = 300;  // ROUND 6: Fix health bar display
                this.damage = 15;
                this.armor = 1;           // ROUND 7: Base armor
                this.attackSpeed = 1.0;   // ROUND 7: Normal attack speed
                this.speed = 0.12;
                this.lastAttack = 0;
                this.animTime = Math.random() * 10; // Offset animation phase
                this.isAttacking = false;
                this.xpReward = 25;       // ROUND 7: XP given on death
                this.attackRange = 2;     // ROUND 7: Melee range
                this.goldReward = 30;     // ROUND 8: Gold given on death

                // Build detailed 3D model from CREEP_MODELS
                const modelKey = `melee_${team === TEAM_RADIANT ? 'radiant' : 'dire'}`;
                const modelDef = CREEP_MODELS[modelKey];
                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup; // For animation compatibility
                } else {
                    // Fallback to simple geometry
                    const geo = team === TEAM_RADIANT ? new THREE.SphereGeometry(0.4) : new THREE.BoxGeometry(0.6, 0.6, 0.6);
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, emissive: color, emissiveIntensity: 0.1 });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = 0.5;
                    this.mesh.add(this.bodyMesh);
                }

                // Register with animation system
                if (typeof AnimationSystem !== 'undefined') {
                    AnimationSystem.register(this, 'creep');
                }

                // Spawn animation - pop in
                this.mesh.scale.set(0.1, 0.1, 0.1);
                this.spawnAnim();
            }

            spawnAnim() {
                let scale = 0.1;
                const grow = () => {
                    scale += 0.15;
                    if (scale >= 1) {
                        this.mesh.scale.set(1, 1, 1);
                        return;
                    }
                    // Bouncy overshoot
                    const overshoot = scale > 0.8 ? 1 + (1 - scale) * 0.5 : scale;
                    this.mesh.scale.set(overshoot, overshoot, overshoot);
                    requestAnimationFrame(grow);
                };
                grow();
            }

            update(dt) {
                if (this.dead) return;

                this.animTime += dt * 3;

                // Idle breathing animation
                if (this.bodyMesh) {
                    const breathe = 1 + Math.sin(this.animTime * 2) * 0.08;
                    const bob = 0.5 + Math.sin(this.animTime * 3) * 0.05;
                    this.bodyMesh.scale.set(breathe, 1 / breathe, breathe);
                    this.bodyMesh.position.y = bob;

                    // Rotation wobble when moving
                    const dist = this.mesh.position.distanceTo(this.targetPos);
                    if (dist > 0.2) {
                        this.bodyMesh.rotation.z = Math.sin(this.animTime * 8) * 0.15;
                        this.bodyMesh.rotation.x = Math.sin(this.animTime * 6) * 0.1;
                    } else {
                        this.bodyMesh.rotation.z *= 0.9;
                        this.bodyMesh.rotation.x *= 0.9;
                    }
                }

                // Collision avoidance with other creeps
                entities.forEach(e => {
                    if (e === this || e.dead || !(e instanceof Creep)) return;
                    const dist = this.mesh.position.distanceTo(e.mesh.position);
                    if (dist < 1.2 && dist > 0.01) {
                        // Push apart
                        const pushDir = this.mesh.position.clone().sub(e.mesh.position).normalize();
                        this.mesh.position.add(pushDir.multiplyScalar(0.05));
                    }
                });

                // AI
                let target = null;
                let minDist = 8;
                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    }
                });

                if (target) {
                    if (minDist < this.attackRange) {
                        // Attack - ROUND 7: Use attackSpeed
                        if (clock.getElapsedTime() - this.lastAttack > this.getAttackInterval()) {
                            this.performAttack(target);
                            this.lastAttack = clock.getElapsedTime();
                            this.attackAnim(target);
                        }
                    } else {
                        // Chase
                        this.targetPos.copy(target.mesh.position);
                        super.update(dt);
                    }
                } else {
                    // Lane logic - follow waypoints if available
                    if (this.waypoints && this.waypoints.length > 0) {
                        const wp = this.waypoints[0];
                        const wpPos = new THREE.Vector3(wp.x, 0, wp.z);
                        const distToWp = this.mesh.position.distanceTo(wpPos);

                        if (distToWp < 3) {
                            // Reached waypoint, move to next
                            this.waypoints.shift();
                        }
                        this.targetPos.copy(wpPos);
                    } else {
                        // No waypoints, head to enemy base
                        const dest = this.team === TEAM_RADIANT ? new THREE.Vector3(45, 0, 45) : new THREE.Vector3(-45, 0, -45);
                        this.targetPos.copy(dest);
                    }
                    super.update(dt);
                }
            }

            attackAnim(target) {
                if (!this.bodyMesh) return;
                // Squash and stretch attack
                const dir = target.mesh.position.clone().sub(this.mesh.position).normalize();
                const bumpOffset = dir.clone().multiplyScalar(0.5);

                // Wind up (squash)
                this.bodyMesh.scale.set(1.3, 0.7, 1.3);

                setTimeout(() => {
                    if (this.dead || !this.bodyMesh) return;
                    // Strike (stretch forward)
                    this.bodyMesh.scale.set(0.7, 1.4, 0.7);
                    this.mesh.position.add(bumpOffset);
                }, 50);

                setTimeout(() => {
                    if (this.dead || !this.bodyMesh) return;
                    // Return
                    this.bodyMesh.scale.set(1, 1, 1);
                    this.mesh.position.sub(bumpOffset);
                }, 150);
            }

            die() {
                if (this.dead) return;
                // Death animation before removal
                this.dead = true;

                // Clear shield state
                if (this.shieldTimeout) {
                    clearTimeout(this.shieldTimeout);
                    this.shieldTimeout = null;
                }
                this.shieldActive = false;

                // ROUND 7: Grant XP to player if enemy dies near player
                // ROUND 8: Also grant gold
                if (this.team === TEAM_DIRE && player && !player.dead) {
                    const distToPlayer = this.mesh.position.distanceTo(player.mesh.position);
                    if (distToPlayer < 15) { // XP/Gold range
                        player.gainXP(this.xpReward);
                        player.gold += this.goldReward;
                        // Show gold floating text
                        showGoldText(this.mesh.position, this.goldReward);
                        AudioManager.playGold(); // ROUND 9: Gold sound
                    }
                }

                // Score
                if (this.team === TEAM_RADIANT) score.dire++;
                else score.radiant++;
                updateScoreBoard();

                // Death animation - shrink and spin
                let deathTime = 0;
                const deathAnim = () => {
                    deathTime += 0.05;
                    if (deathTime >= 1 || !this.mesh) {
                        scene.remove(this.mesh);
                        return;
                    }
                    const scale = 1 - deathTime;
                    this.mesh.scale.set(scale, scale * 0.5, scale);
                    this.mesh.rotation.y += 0.3;
                    this.mesh.position.y -= 0.05;
                    if (this.bodyMesh) {
                        this.bodyMesh.material.opacity = scale;
                        this.bodyMesh.material.transparent = true;
                    }
                    requestAnimationFrame(deathAnim);
                };
                deathAnim();

                // Particle burst on death
                createExplosion(this.mesh.position, this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c, 15);
            }
        }

        // ROUND 7: Ranged Creep - attacks from distance, lower HP
        class RangedCreep extends Creep {
            constructor(x, z, team) {
                super(x, z, team);
                this.hp = 200;
                this.maxHp = 200;
                this.damage = 20;
                this.armor = 0;
                this.attackRange = 6;      // Can attack from range
                this.attackSpeed = 0.8;    // Slower attack
                this.xpReward = 30;        // Slightly more XP
                this.goldReward = 40;      // ROUND 8: More gold for ranged

                // Build detailed ranged creep model
                if (this.modelGroup) {
                    this.mesh.remove(this.modelGroup);
                }
                if (this.bodyMesh && this.bodyMesh !== this.modelGroup) {
                    this.mesh.remove(this.bodyMesh);
                }

                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                const modelKey = `ranged_${team === TEAM_RADIANT ? 'radiant' : 'dire'}`;
                const modelDef = CREEP_MODELS[modelKey];

                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup;
                } else {
                    // Fallback
                    const geo = new THREE.OctahedronGeometry(0.35);
                    const mat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.5,
                        emissive: color,
                        emissiveIntensity: 0.3
                    });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = 0.6;
                    this.mesh.add(this.bodyMesh);
                }
            }

            attackAnim(target) {
                if (!this.bodyMesh || !target || !target.mesh) return;

                // Ranged attack - shoot projectile
                const start = this.mesh.position.clone();
                start.y = 0.6;
                const end = target.mesh.position.clone();
                end.y = 1;

                const color = this.team === TEAM_RADIANT ? 0x00ff88 : 0xff3c3c;
                const projectile = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                projectile.position.copy(start);
                scene.add(projectile);

                const dir = end.clone().sub(start).normalize();
                let dist = 0;
                const maxDist = start.distanceTo(end);

                const moveProjectile = () => {
                    dist += 0.5;
                    projectile.position.add(dir.clone().multiplyScalar(0.5));
                    if (dist >= maxDist) {
                        scene.remove(projectile);
                        return;
                    }
                    requestAnimationFrame(moveProjectile);
                };
                moveProjectile();

                // Body pulse
                this.bodyMesh.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => {
                    if (this.bodyMesh) this.bodyMesh.scale.set(1, 1, 1);
                }, 100);
            }
        }

        // ROUND 7: Siege Creep - high HP, bonus damage to structures, slow
        class SiegeCreep extends Creep {
            constructor(x, z, team) {
                super(x, z, team);
                this.hp = 600;
                this.maxHp = 600;
                this.damage = 25;
                this.armor = 3;            // Armored
                this.attackRange = 3;      // Slightly longer range
                this.attackSpeed = 0.6;    // Slow attack
                this.speed = 0.08;         // Slow movement
                this.xpReward = 50;        // More XP
                this.goldReward = 60;      // ROUND 8: Most gold for siege
                this.structureDamageBonus = 2.0; // Double damage to structures

                // Build detailed siege creep model
                if (this.modelGroup) {
                    this.mesh.remove(this.modelGroup);
                }
                if (this.bodyMesh && this.bodyMesh !== this.modelGroup) {
                    this.mesh.remove(this.bodyMesh);
                }

                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                const modelKey = `siege_${team === TEAM_RADIANT ? 'radiant' : 'dire'}`;
                const modelDef = CREEP_MODELS[modelKey];

                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup;
                    // Find cannon part for animation
                    this.modelGroup.traverse(child => {
                        if (child.name === 'cannon' || child.name === 'barrel') {
                            this.cannon = child;
                        }
                    });
                } else {
                    // Fallback
                    const geo = new THREE.BoxGeometry(0.8, 0.5, 1.0);
                    const mat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.5,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = 0.4;
                    this.mesh.add(this.bodyMesh);

                    // Cannon on top
                    const cannonGeo = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 8);
                    const cannonMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 });
                    this.cannon = new THREE.Mesh(cannonGeo, cannonMat);
                    this.cannon.rotation.x = Math.PI / 2;
                    this.cannon.position.set(0, 0.6, 0.3);
                    this.mesh.add(this.cannon);
                }

                // Make health bar bigger
                if (this.healthBarBg) this.healthBarBg.scale.set(1.5, 1.5, 1);
                if (this.healthBarFg) this.healthBarFg.scale.set(1.5, 1.5, 1);
            }

            // Override performAttack to deal bonus damage to structures
            performAttack(target, baseDamage = null) {
                if (!target || target.dead) return 0;

                let dmg = baseDamage || this.damage;

                // Bonus damage to structures
                if (target instanceof Structure) {
                    dmg *= this.structureDamageBonus;
                }

                target.takeDamage(dmg, 'physical');
                return dmg;
            }

            attackAnim(target) {
                if (!this.bodyMesh || !this.cannon) return;

                // Cannon recoil
                this.cannon.position.z = 0.1;
                setTimeout(() => {
                    if (this.cannon) this.cannon.position.z = 0.3;
                }, 100);

                // Body shake
                const origY = this.bodyMesh.position.y;
                this.bodyMesh.position.y = origY - 0.1;
                setTimeout(() => {
                    if (this.bodyMesh) this.bodyMesh.position.y = origY;
                }, 50);

                // Muzzle flash
                if (target && target.mesh) {
                    createExplosion(this.mesh.position.clone().add(new THREE.Vector3(0, 0.6, 0.5)), 0xffaa00, 5);
                }
            }
        }

        class Structure extends GameEntity {
            constructor(x, z, type, team) {
                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                super(x, z, team, color);
                this.type = type;
                this.maxHp = type === 'base' ? 2500 : 1500;
                this.hp = this.maxHp;
                this.damage = 40;
                this.range = 10;
                this.lastAttack = 0;
                this.baseEmissive = 0.4;

                // Build detailed structure model from STRUCTURE_MODELS
                const teamStr = team === TEAM_RADIANT ? 'radiant' : 'dire';
                const modelKey = `${type}_${teamStr}`;
                const modelDef = STRUCTURE_MODELS[modelKey];

                if (modelDef && typeof buildModel === 'function') {
                    this.modelGroup = buildModel(modelDef, color);
                    this.mesh.add(this.modelGroup);
                    this.bodyMesh = this.modelGroup;
                } else {
                    // Fallback to simple geometry
                    let geo;
                    if (type === 'base') geo = new THREE.ConeGeometry(3, 8, 6);
                    else geo = new THREE.CylinderGeometry(0.8, 1.2, 5, 8);

                    const mat = new THREE.MeshStandardMaterial({
                        color: color, roughness: 0.4,
                        emissive: color, emissiveIntensity: 0.4
                    });
                    this.bodyMesh = new THREE.Mesh(geo, mat);
                    this.bodyMesh.position.y = type === 'base' ? 4 : 2.5;
                    this.mesh.add(this.bodyMesh);
                }

                // Base Ring
                const ring = new THREE.Mesh(new THREE.TorusGeometry(2, 0.2, 8, 16), new THREE.MeshBasicMaterial({ color: color }));
                ring.rotation.x = -Math.PI / 2;
                this.mesh.add(ring);

                // Register with animation system for idle effects
                if (typeof AnimationSystem !== 'undefined') {
                    AnimationSystem.register(this, 'structure');
                }

                // Move health bar higher for structures
                if (this.healthBarBg) this.healthBarBg.position.y = type === 'base' ? 10 : 7;
                if (this.healthBarFg) this.healthBarFg.position.y = type === 'base' ? 10 : 7;

                // Make health bar bigger for structures
                if (this.healthBarBg) this.healthBarBg.scale.set(2, 2, 1);
                if (this.healthBarFg) this.healthBarFg.scale.set(2, 2, 1);
            }

            takeDamage(amt, type = 'physical') {
                // Call parent damage logic
                const oldHp = this.hp;
                super.takeDamage(amt, type);

                // Visual feedback - flash and shake
                if (this.bodyMesh && !this.dead) {
                    // Bright flash
                    this.bodyMesh.material.emissiveIntensity = 2;

                    // Shake effect
                    const shakeAmount = 0.3;
                    const origPos = this.bodyMesh.position.clone();
                    let shakeTime = 0;
                    const shake = () => {
                        shakeTime++;
                        if (shakeTime > 8) {
                            this.bodyMesh.position.copy(origPos);
                            this.bodyMesh.material.emissiveIntensity = this.baseEmissive;
                            return;
                        }
                        this.bodyMesh.position.x = origPos.x + (Math.random() - 0.5) * shakeAmount;
                        this.bodyMesh.position.z = origPos.z + (Math.random() - 0.5) * shakeAmount;
                        this.bodyMesh.material.emissiveIntensity *= 0.8;
                        requestAnimationFrame(shake);
                    };
                    shake();

                    // Damage particles
                    createExplosion(this.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), 0xffaa00, 8);
                }
            }

            update(dt) {
                if (this.dead) return;

                // Tower AI
                if (clock.getElapsedTime() - this.lastAttack > 1.0) {
                    let target = null;
                    let minD = this.range;

                    entities.forEach(e => {
                        if (e.team !== this.team && !e.dead) {
                            const d = this.mesh.position.distanceTo(e.mesh.position);
                            if (d < minD) {
                                minD = d;
                                target = e;
                            }
                        }
                    });

                    if (target) {
                        target.takeDamage(this.damage, 'physical');
                        this.lastAttack = clock.getElapsedTime();
                        // Laser shot
                        const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, minD), new THREE.MeshBasicMaterial({ color: this.color }));
                        laser.geometry.rotateX(-Math.PI / 2);
                        laser.position.copy(this.mesh.position).add(new THREE.Vector3(0, 4, 0));
                        laser.lookAt(target.mesh.position);
                        laser.position.lerp(target.mesh.position, 0.5); // Center it
                        scene.add(laser);
                        setTimeout(() => scene.remove(laser), 100);
                    }
                }

                // ROUND 6: Update structure health bar
                this.updateHealthBar();
            }
        }

        // --- FX SYSTEMS ---
        // ROUND 8: Added damage parameter for level scaling
        // ROUND 9: Enhanced with trail effect
        function createProjectile(start, info, damage = 80) {
            // Shoots towards mouse - ROUND 9: Glowing core with outer shell
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.2),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            const outer = new THREE.Mesh(
                new THREE.SphereGeometry(0.35),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 })
            );
            const sphere = new THREE.Group();
            sphere.add(core);
            sphere.add(outer);
            sphere.position.copy(start);
            sphere.position.y = 1;
            scene.add(sphere);

            // Raycast for direction
            raycaster.setFromCamera(info, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            let targetPoint = new THREE.Vector3(info.x * 50, 0, info.y * 50); // Fallback
            for (let i of intersects) {
                if (i.object.geometry && i.object.geometry.type === 'PlaneGeometry') {
                    targetPoint = i.point;
                    break;
                }
            }

            const dir = targetPoint.sub(start).normalize();
            let trailCounter = 0;

            let projectileAlive = true;
            const update = () => {
                if (!projectileAlive) return;

                sphere.position.add(dir.clone().multiplyScalar(0.8));

                // ROUND 9: Spawn trail particles every 3 frames
                trailCounter++;
                if (trailCounter % 3 === 0) {
                    const trail = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15),
                        new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 })
                    );
                    trail.position.copy(sphere.position);
                    scene.add(trail);
                    // Fade out trail
                    let fade = 0.5;
                    const fadeTrail = () => {
                        fade -= 0.05;
                        trail.material.opacity = fade;
                        trail.scale.multiplyScalar(0.9);
                        if (fade > 0) requestAnimationFrame(fadeTrail);
                        else scene.remove(trail);
                    };
                    fadeTrail();
                }

                // Rotate outer shell for effect
                outer.rotation.x += 0.2;
                outer.rotation.y += 0.3;

                // ROUND 3: Actual hit detection!
                for (let i = 0; i < entities.length; i++) {
                    const e = entities[i];
                    if (!e || e.dead || e.team === TEAM_RADIANT || !e.mesh) continue;
                    const dist = sphere.position.distanceTo(e.mesh.position);
                    if (dist < 1.5) {
                        e.takeDamage(damage, 'magic'); // ROUND 8: Use scaled damage
                        scene.remove(sphere);
                        projectileAlive = false;
                        screenShake.light();
                        return;
                    }
                }

                if (sphere.position.length() > 60) {
                    scene.remove(sphere);
                    projectileAlive = false;
                } else {
                    requestAnimationFrame(update);
                }
            };
            update();
        }

        function createExplosion(pos, color, count) {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = [];

            for (let i = 0; i < count; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;
                velocities.push({
                    x: (Math.random() - 0.5),
                    y: (Math.random() - 0.5) + 1,
                    z: (Math.random() - 0.5)
                });
            }

            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: color, size: 0.4, transparent: true });
            const points = new THREE.Points(geom, mat);
            scene.add(points);

            let frame = 0;
            const anim = () => {
                frame++;
                const posAttr = points.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    posAttr.setXYZ(i,
                        posAttr.getX(i) + velocities[i].x * 0.2,
                        posAttr.getY(i) + velocities[i].y * 0.2,
                        posAttr.getZ(i) + velocities[i].z * 0.2
                    );
                    velocities[i].y -= 0.05; // Gravity
                }
                posAttr.needsUpdate = true;
                mat.opacity -= 0.02;
                if (frame < 50) requestAnimationFrame(anim);
                else scene.remove(points);
            }
            anim();
        }

        // ROUND 8: Added shieldAmount parameter for level scaling
        // ROUND 9: Enhanced with pulsing glow and layered visuals
        function createShield(entity, shieldAmount = 200) {
            // ROUND 3: Shield now provides actual damage absorption
            entity.shieldHealth = shieldAmount;
            entity.shieldActive = true;

            // ROUND 9: Multi-layer shield with pulsing glow
            const shieldGroup = new THREE.Group();

            // Inner solid core
            const innerShield = new THREE.Mesh(
                new THREE.SphereGeometry(1.0, 24, 24),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.15
                })
            );
            shieldGroup.add(innerShield);

            // Wireframe layer
            const wireShield = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 16, 16),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                })
            );
            shieldGroup.add(wireShield);

            // Outer glow layer
            const outerGlow = new THREE.Mesh(
                new THREE.SphereGeometry(1.4, 16, 16),
                new THREE.MeshBasicMaterial({
                    color: 0x88ff88,
                    transparent: true,
                    opacity: 0.2
                })
            );
            shieldGroup.add(outerGlow);

            entity.mesh.add(shieldGroup);
            entity.shieldMesh = shieldGroup;

            // ROUND 9: Pulsing animation
            let pulsePhase = 0;
            let shieldAnimActive = true;
            const pulseShield = () => {
                if (!shieldAnimActive || !entity.shieldActive) return;

                pulsePhase += 0.15;
                const pulse = 0.5 + Math.sin(pulsePhase) * 0.2;
                const scale = 1 + Math.sin(pulsePhase * 0.5) * 0.05;

                wireShield.material.opacity = pulse;
                outerGlow.material.opacity = 0.1 + Math.sin(pulsePhase * 0.7) * 0.1;
                shieldGroup.scale.set(scale, scale, scale);

                // Rotate wireframe slowly
                wireShield.rotation.y += 0.02;
                wireShield.rotation.x += 0.01;

                requestAnimationFrame(pulseShield);
            };
            pulseShield();

            // ROUND 9: Shield spawn burst effect
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const spark = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 })
                );
                spark.position.set(Math.cos(angle) * 1.5, 0.5, Math.sin(angle) * 1.5);
                entity.mesh.add(spark);

                const sparkDir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                let sparkLife = 1;
                const animSpark = () => {
                    sparkLife -= 0.1;
                    spark.position.add(sparkDir.clone().multiplyScalar(0.1));
                    spark.material.opacity = sparkLife;
                    if (sparkLife > 0) requestAnimationFrame(animSpark);
                    else entity.mesh.remove(spark);
                };
                animSpark();
            }

            // Shield expires after 3 seconds OR when depleted
            entity.shieldTimeout = setTimeout(() => {
                if (entity.shieldActive) {
                    entity.shieldActive = false;
                    shieldAnimActive = false;
                    entity.shieldHealth = 0;
                    if (entity.shieldMesh && entity.mesh) {
                        entity.mesh.remove(entity.shieldMesh);
                    }
                    entity.shieldMesh = null;
                }
            }, 3000);
        }

        // ROUND 8: Added damage parameter for level scaling
        function createUlt(pos, damage = 400) {
            // Big Boom
            createExplosion(pos, 0xff00ff, 100);
            // ROUND 2: Heavy screen shake on ultimate
            screenShake.heavy();
            // ROUND 1: Guard against dead player
            if (!player || player.dead) return;
            // AOE Damage - ROUND 8: Use scaled damage
            entities.forEach(e => {
                if (e && !e.dead && e.team !== player.team && e.mesh && e.mesh.position.distanceTo(pos) < 10) {
                    e.takeDamage(damage, 'crit');
                }
            });
        }

        // === HERO-SPECIFIC ABILITY FUNCTIONS ===

        // Void Walker - Mana Void: AoE damage based on missing mana
        function createManaVoid(pos, damage) {
            if (!player) return;

            // Visual - swirling void effect
            const voidSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 })
            );
            voidSphere.position.copy(pos);
            voidSphere.position.y = 1;
            scene.add(voidSphere);

            let scale = 0.5;
            const expandVoid = () => {
                scale += 0.5;
                voidSphere.scale.set(scale, scale, scale);
                voidSphere.material.opacity -= 0.05;

                if (scale < 10) {
                    requestAnimationFrame(expandVoid);
                } else {
                    scene.remove(voidSphere);
                }

                // Damage enemies in expanding radius
                if (scale > 1 && scale < 8) {
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            const dist = e.mesh.position.distanceTo(pos);
                            if (dist < scale && dist > scale - 0.5) {
                                const bonusDamage = e.mp ? (e.maxMp - e.mp) * 0.5 : 0;
                                e.takeDamage(damage / 5 + bonusDamage, 'magical');
                            }
                        }
                    });
                }
            };
            expandVoid();

            createExplosion(pos, 0x00ffff, 30);
            screenShake.medium();
        }

        // Iron Clad - Shield Slam: AoE stun
        function createShieldSlam(pos, damage) {
            if (!player) return;

            // Visual - shockwave ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.5, 1, 32),
                new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(pos);
            ring.position.y = 0.1;
            scene.add(ring);

            let ringScale = 1;
            const expandRing = () => {
                ringScale += 0.3;
                ring.scale.set(ringScale, ringScale, 1);
                ring.material.opacity -= 0.05;

                if (ring.material.opacity > 0) {
                    requestAnimationFrame(expandRing);
                } else {
                    scene.remove(ring);
                }
            };
            expandRing();

            // Damage and stun enemies
            entities.forEach(e => {
                if (e && !e.dead && e.team !== player.team && e.mesh) {
                    const dist = e.mesh.position.distanceTo(pos);
                    if (dist < 5) {
                        e.takeDamage(damage, 'physical');
                        e.stunned = true;
                        e.stunEndTime = clock.getElapsedTime() + 1.5;
                        createExplosion(e.mesh.position, 0xffaa00, 5);
                    }
                }
            });

            screenShake.medium();
        }

        // Iron Clad - Earthquake: Large AoE damage and slow
        function createEarthquake(pos, damage) {
            if (!player) return;

            // Multiple shockwaves
            for (let wave = 0; wave < 3; wave++) {
                setTimeout(() => {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(1, 2, 32),
                        new THREE.MeshBasicMaterial({ color: 0x885522, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
                    );
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.copy(pos);
                    ring.position.y = 0.1;
                    scene.add(ring);

                    let ringScale = 1;
                    const expand = () => {
                        ringScale += 0.4;
                        ring.scale.set(ringScale, ringScale, 1);
                        ring.material.opacity -= 0.03;
                        if (ring.material.opacity > 0) requestAnimationFrame(expand);
                        else scene.remove(ring);
                    };
                    expand();

                    // Damage enemies
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            const dist = e.mesh.position.distanceTo(pos);
                            if (dist < 12) {
                                e.takeDamage(damage / 3, 'physical');
                                e.speed *= 0.5; // Slow
                                setTimeout(() => { if (e) e.speed *= 2; }, 3000);
                            }
                        }
                    });

                    screenShake.medium();
                }, wave * 300);
            }
        }

        // Pyromancer - Fireball: Fast fire projectile
        function createFireball(startPos, targetInfo, damage) {
            const projectile = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xff4400 })
            );
            projectile.position.copy(startPos);
            projectile.position.y = 1;

            // Add fire glow
            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.4 })
            );
            projectile.add(glow);

            scene.add(projectile);

            const direction = new THREE.Vector3(targetInfo.x, 0, targetInfo.z).sub(startPos).normalize();
            let traveled = 0;

            const moveFireball = () => {
                if (!projectile.parent) return;

                projectile.position.add(direction.clone().multiplyScalar(0.8));
                traveled += 0.8;

                // Fire trail particles
                if (Math.random() > 0.5) {
                    const trail = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15),
                        new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 })
                    );
                    trail.position.copy(projectile.position);
                    scene.add(trail);
                    setTimeout(() => scene.remove(trail), 200);
                }

                // Check collision
                let hit = false;
                entities.forEach(e => {
                    if (!hit && e && !e.dead && e.team !== player.team && e.mesh) {
                        if (projectile.position.distanceTo(e.mesh.position) < 1.5) {
                            e.takeDamage(damage, 'magical');
                            createExplosion(e.mesh.position, 0xff4400, 15);
                            hit = true;
                        }
                    }
                });

                if (hit || traveled > 30) {
                    createExplosion(projectile.position, 0xff4400, 10);
                    scene.remove(projectile);
                } else {
                    requestAnimationFrame(moveFireball);
                }
            };
            moveFireball();
        }

        // Pyromancer - Inferno: Ring of fire
        function createInferno(pos, damagePerTick) {
            const fireRing = new THREE.Group();

            // Create ring of fire particles
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.3, 1, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 })
                );
                flame.position.set(Math.cos(angle) * 4, 0.5, Math.sin(angle) * 4);
                fireRing.add(flame);
            }

            fireRing.position.copy(pos);
            scene.add(fireRing);

            let duration = 0;
            const burnTick = () => {
                duration += 16;
                fireRing.rotation.y += 0.05;

                // Animate flames
                fireRing.children.forEach((flame, i) => {
                    flame.scale.y = 0.8 + Math.sin(duration * 0.01 + i) * 0.3;
                });

                // Damage enemies in ring
                if (duration % 500 < 20) {
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            const dist = e.mesh.position.distanceTo(pos);
                            if (dist > 3 && dist < 5) {
                                e.takeDamage(damagePerTick, 'magical');
                            }
                        }
                    });
                }

                if (duration < 4000) {
                    requestAnimationFrame(burnTick);
                } else {
                    scene.remove(fireRing);
                }
            };
            burnTick();
        }

        // Pyromancer - Meteor: Massive fire explosion at target
        function createMeteor(targetInfo, damage) {
            const targetPos = new THREE.Vector3(targetInfo.x, 0, targetInfo.z);

            // Warning circle
            const warning = new THREE.Mesh(
                new THREE.CircleGeometry(5, 32),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 })
            );
            warning.rotation.x = -Math.PI / 2;
            warning.position.copy(targetPos);
            warning.position.y = 0.05;
            scene.add(warning);

            // Meteor falling
            const meteor = new THREE.Mesh(
                new THREE.SphereGeometry(2, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff4400 })
            );
            meteor.position.copy(targetPos);
            meteor.position.y = 30;
            scene.add(meteor);

            let fallProgress = 0;
            const fallMeteor = () => {
                fallProgress += 0.05;
                meteor.position.y = 30 - fallProgress * 30;
                warning.material.opacity = 0.3 + fallProgress * 0.3;

                if (fallProgress < 1) {
                    requestAnimationFrame(fallMeteor);
                } else {
                    // Impact
                    scene.remove(meteor);
                    scene.remove(warning);
                    createExplosion(targetPos, 0xff4400, 80);
                    screenShake.heavy();

                    // Damage in area
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            const dist = e.mesh.position.distanceTo(targetPos);
                            if (dist < 6) {
                                e.takeDamage(damage * (1 - dist / 12), 'magical');
                            }
                        }
                    });

                    // Leave burning ground
                    createFirePatch(targetPos, 30, 5000);
                }
            };
            setTimeout(fallMeteor, 100);
        }

        // Fire patch that damages over time
        function createFirePatch(pos, damagePerTick, duration) {
            const patch = new THREE.Mesh(
                new THREE.CircleGeometry(1.5, 16),
                new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.5 })
            );
            patch.rotation.x = -Math.PI / 2;
            patch.position.copy(pos);
            patch.position.y = 0.05;
            scene.add(patch);

            let elapsed = 0;
            const burnPatch = () => {
                elapsed += 100;
                patch.material.opacity = 0.5 * (1 - elapsed / duration);

                // Damage tick
                if (player) {
                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            if (e.mesh.position.distanceTo(pos) < 1.5) {
                                e.takeDamage(damagePerTick, 'magical');
                            }
                        }
                    });
                }

                if (elapsed < duration) {
                    setTimeout(burnPatch, 100);
                } else {
                    scene.remove(patch);
                }
            };
            burnPatch();
        }

        // Shadow Blade - Fan of Knives
        function createFanOfKnives(startPos, targetPos, damage) {
            const dir = new THREE.Vector3(targetPos.x, 0, targetPos.z).sub(startPos).normalize();
            const baseAngle = Math.atan2(dir.x, dir.z);

            for (let i = -2; i <= 2; i++) {
                const angle = baseAngle + i * 0.3;
                const knifeDir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));

                const knife = new THREE.Mesh(
                    new THREE.ConeGeometry(0.1, 0.5, 4),
                    new THREE.MeshBasicMaterial({ color: 0x888888 })
                );
                knife.position.copy(startPos);
                knife.position.y = 1;
                knife.rotation.x = Math.PI / 2;
                knife.rotation.z = -angle;
                scene.add(knife);

                let traveled = 0;
                const moveKnife = () => {
                    knife.position.add(knifeDir.clone().multiplyScalar(0.6));
                    traveled += 0.6;

                    entities.forEach(e => {
                        if (e && !e.dead && e.team !== player.team && e.mesh) {
                            if (knife.position.distanceTo(e.mesh.position) < 1) {
                                e.takeDamage(damage, 'physical');
                                scene.remove(knife);
                                createExplosion(e.mesh.position, 0x440066, 5);
                            }
                        }
                    });

                    if (traveled < 15 && knife.parent) {
                        requestAnimationFrame(moveKnife);
                    } else if (knife.parent) {
                        scene.remove(knife);
                    }
                };
                moveKnife();
            }
        }

        // Shadow Blade - Death Mark: Mark enemy for bonus damage
        function createDeathMark(pos, damage) {
            if (!player) return;

            let nearestEnemy = null;
            let minDist = 15;

            entities.forEach(e => {
                if (e && !e.dead && e.team !== player.team && e.mesh) {
                    const d = e.mesh.position.distanceTo(pos);
                    if (d < minDist) {
                        minDist = d;
                        nearestEnemy = e;
                    }
                }
            });

            if (nearestEnemy) {
                // Mark visual
                const mark = new THREE.Mesh(
                    new THREE.RingGeometry(1, 1.3, 6),
                    new THREE.MeshBasicMaterial({ color: 0x660066, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                );
                mark.rotation.x = -Math.PI / 2;
                nearestEnemy.mesh.add(mark);

                nearestEnemy.deathMarked = true;

                // Damage after delay
                setTimeout(() => {
                    if (nearestEnemy && !nearestEnemy.dead) {
                        nearestEnemy.takeDamage(damage, 'physical');
                        createExplosion(nearestEnemy.mesh.position, 0x660066, 30);
                        nearestEnemy.mesh.remove(mark);
                        nearestEnemy.deathMarked = false;
                        screenShake.medium();
                    }
                }, 2000);
            }
        }

        // Show damage number floating text
        function showDamageNumber(pos, amount, isCrit = false) {
            const color = isCrit ? '#ff4444' : '#ffffff';
            new FloatingText(Math.round(amount), pos.x, pos.y + 1, pos.z, color);
        }

        // === JUNGLE CAMP SYSTEM ===
        const jungleCamps = [];

        const JUNGLE_CAMP_DEFS = [
            { x: -25, z: -5, tier: 'small', respawnTime: 60, creeps: ['wolf', 'wolf'] },
            { x: -15, z: -20, tier: 'medium', respawnTime: 75, creeps: ['ogre', 'ogre'] },
            { x: -30, z: 15, tier: 'large', respawnTime: 90, creeps: ['centaur', 'centaur'] },
            { x: 25, z: 5, tier: 'small', respawnTime: 60, creeps: ['satyr', 'satyr'] },
            { x: 15, z: 20, tier: 'medium', respawnTime: 75, creeps: ['troll', 'troll'] },
            { x: 30, z: -15, tier: 'large', respawnTime: 90, creeps: ['golem'] },
            { x: 0, z: 0, tier: 'ancient', respawnTime: 180, creeps: ['dragon'] } // Roshan equivalent
        ];

        const JUNGLE_CREEP_DEFS = {
            wolf: { hp: 200, damage: 20, gold: 25, xp: 30, color: 0x666666, size: 0.4 },
            satyr: { hp: 250, damage: 25, gold: 30, xp: 35, color: 0x884422, size: 0.45 },
            ogre: { hp: 400, damage: 35, gold: 45, xp: 50, color: 0x448844, size: 0.6 },
            troll: { hp: 350, damage: 40, gold: 50, xp: 55, color: 0x4444aa, size: 0.55 },
            centaur: { hp: 600, damage: 50, gold: 70, xp: 80, color: 0x884400, size: 0.7 },
            golem: { hp: 800, damage: 60, gold: 100, xp: 120, color: 0x555555, size: 0.9 },
            dragon: { hp: 5000, damage: 150, gold: 500, xp: 1000, color: 0xff4400, size: 2.0 }
        };

        class JungleCreep extends GameEntity {
            constructor(x, z, creepType, campIndex) {
                const def = JUNGLE_CREEP_DEFS[creepType];
                super(x, z, 0, def.color); // Neutral team (0)
                this.creepType = creepType;
                this.campIndex = campIndex;
                this.hp = def.hp;
                this.maxHp = def.hp;
                this.damage = def.damage;
                this.goldReward = def.gold;
                this.xpReward = def.xp;
                this.attackRange = 2;
                this.speed = 0.08;
                this.lastAttack = 0;
                this.homePos = new THREE.Vector3(x, 0, z);
                this.leashRange = 10;

                // Build model
                const size = def.size;
                const bodyGeo = creepType === 'dragon' ?
                    new THREE.BoxGeometry(size * 2, size * 1.5, size * 3) :
                    new THREE.SphereGeometry(size, 8, 8);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: def.color,
                    roughness: 0.7,
                    emissive: def.color,
                    emissiveIntensity: 0.1
                });
                this.bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
                this.bodyMesh.position.y = size;
                this.mesh.add(this.bodyMesh);

                // Eyes
                if (creepType !== 'dragon') {
                    const eyeGeo = new THREE.SphereGeometry(size * 0.2);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
                    eye1.position.set(-size * 0.3, size * 1.2, size * 0.4);
                    this.mesh.add(eye1);
                    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
                    eye2.position.set(size * 0.3, size * 1.2, size * 0.4);
                    this.mesh.add(eye2);
                }
            }

            update(dt) {
                if (this.dead) return;

                // Find nearby enemies to attack
                let target = null;
                let minDist = 6;

                entities.forEach(e => {
                    if (e.team !== 0 && !e.dead && e.mesh) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    }
                });

                // Check leash range
                const distFromHome = this.mesh.position.distanceTo(this.homePos);
                if (distFromHome > this.leashRange) {
                    // Return home
                    this.targetPos.copy(this.homePos);
                    this.hp = Math.min(this.hp + 5, this.maxHp); // Regen while returning
                    super.update(dt);
                    return;
                }

                if (target) {
                    if (minDist < this.attackRange) {
                        if (clock.getElapsedTime() - this.lastAttack > 1.0) {
                            target.takeDamage(this.damage, 'physical');
                            this.lastAttack = clock.getElapsedTime();
                            createExplosion(target.mesh.position, 0xff6600, 5);
                        }
                    } else {
                        this.targetPos.copy(target.mesh.position);
                        super.update(dt);
                    }
                }
            }

            die() {
                super.die();
                // Notify camp to start respawn timer
                if (jungleCamps[this.campIndex]) {
                    jungleCamps[this.campIndex].onCreepDeath(this);
                }
            }
        }

        class JungleCamp {
            constructor(def, index) {
                this.def = def;
                this.index = index;
                this.creeps = [];
                this.respawnTimer = 0;
                this.isCleared = false;

                this.spawn();
            }

            spawn() {
                this.creeps = [];
                this.isCleared = false;

                this.def.creeps.forEach((creepType, i) => {
                    const offset = i * 1.5 - (this.def.creeps.length - 1) * 0.75;
                    const creep = new JungleCreep(
                        this.def.x + offset,
                        this.def.z,
                        creepType,
                        this.index
                    );
                    this.creeps.push(creep);
                    entities.push(creep);
                    scene.add(creep.mesh);
                });
            }

            onCreepDeath(creep) {
                const idx = this.creeps.indexOf(creep);
                if (idx > -1) this.creeps.splice(idx, 1);

                if (this.creeps.length === 0) {
                    this.isCleared = true;
                    this.respawnTimer = this.def.respawnTime;
                }
            }

            update(dt) {
                if (this.isCleared && this.respawnTimer > 0) {
                    this.respawnTimer -= dt;
                    if (this.respawnTimer <= 0) {
                        this.spawn();
                    }
                }
            }
        }

        function initJungleCamps() {
            JUNGLE_CAMP_DEFS.forEach((def, i) => {
                jungleCamps.push(new JungleCamp(def, i));
            });
        }

        function updateJungleCamps(dt) {
            jungleCamps.forEach(camp => camp.update(dt));
        }

        function spawnFloatingText(amt, pos, color) {
            // ROUND 1: Respect settings
            if (!gameSettings.showDamageNumbers) return;
            new FloatingText(Math.round(amt), pos.x, pos.y, pos.z, color);
        }

        // ROUND 8: Show gold gain floating text
        function showGoldText(pos, amount) {
            new FloatingText(`+${amount}g`, pos.x, pos.y + 1, pos.z, '#ffd700');
        }

        // Map details - trees, rocks, lanes
        // Environment decoration storage for animations
        const environmentObjects = {
            grass: [],
            fireflies: [],
            waterRipples: []
        };

        function createMapDetails() {
            // Lane paths (lighter ground) with stone texture effect
            const laneMat = new THREE.MeshStandardMaterial({ color: 0x3a4a3a, roughness: 0.6, metalness: 0.1 });

            // Mid lane (diagonal from Radiant to Dire)
            const midLane = new THREE.Mesh(new THREE.PlaneGeometry(8, 130), laneMat);
            midLane.rotation.x = -Math.PI / 2;
            midLane.rotation.z = Math.PI / 4;
            midLane.position.y = 0.01;
            scene.add(midLane);

            // Lane edge markers for mid lane
            createLaneEdgeMarkers(-46, -46, 46, 46, 20);

            // Top lane - left side (vertical) then top (horizontal)
            const topLane1 = new THREE.Mesh(new THREE.PlaneGeometry(6, 90), laneMat);
            topLane1.rotation.x = -Math.PI / 2;
            topLane1.position.set(-42, 0.01, 0);
            scene.add(topLane1);
            const topLane2 = new THREE.Mesh(new THREE.PlaneGeometry(90, 6), laneMat);
            topLane2.rotation.x = -Math.PI / 2;
            topLane2.position.set(0, 0.01, 42);
            scene.add(topLane2);

            // Bot lane - bottom (horizontal) then right side (vertical)
            const botLane1 = new THREE.Mesh(new THREE.PlaneGeometry(90, 6), laneMat);
            botLane1.rotation.x = -Math.PI / 2;
            botLane1.position.set(0, 0.01, -42);
            scene.add(botLane1);
            const botLane2 = new THREE.Mesh(new THREE.PlaneGeometry(6, 90), laneMat);
            botLane2.rotation.x = -Math.PI / 2;
            botLane2.position.set(42, 0.01, 0);
            scene.add(botLane2);

            // Trees (scattered around jungle areas) - more variety
            const treePositions = [
                [-30, -10], [-25, -20], [-15, -30], [-35, -25],
                [30, 10], [25, 20], [15, 30], [35, 25],
                [-10, 20], [-20, 30], [10, -20], [20, -30],
                [-30, 30], [30, -30], [-15, 15], [15, -15],
                [-28, -15], [-22, -25], [28, 15], [22, 25],
                [-18, 28], [18, -28], [-33, 18], [33, -18]
            ];

            treePositions.forEach(([x, z], i) => {
                const treeType = i % 3; // Variety of tree types
                createTree(x + (Math.random() - 0.5) * 5, z + (Math.random() - 0.5) * 5, treeType);
            });

            // Rocks
            const rockPositions = [
                [-20, -5], [20, 5], [-5, -25], [5, 25],
                [-35, 0], [35, 0], [0, -35], [0, 35],
                [-25, 15], [25, -15], [-12, -18], [12, 18]
            ];

            rockPositions.forEach(([x, z]) => {
                createRock(x + (Math.random() - 0.5) * 3, z + (Math.random() - 0.5) * 3);
            });

            // Grass patches throughout jungle
            createGrassPatches();

            // Shrubs and bushes
            createShrubs();

            // River (diagonal water through middle) with animated ripples
            const riverMat = new THREE.MeshStandardMaterial({
                color: 0x1a5a7a, roughness: 0.2, metalness: 0.6,
                emissive: 0x0a3a4a, emissiveIntensity: 0.4
            });
            const river = new THREE.Mesh(new THREE.PlaneGeometry(12, 120), riverMat);
            river.rotation.x = -Math.PI / 2;
            river.rotation.z = Math.PI / 4 + 0.3;
            river.position.y = 0.02;
            scene.add(river);

            // River banks (darker edges)
            createRiverBanks();

            // Fireflies in jungle areas
            createFireflies();

            // Base areas (team colored ground) with decorative rings
            const radiantBaseMat = new THREE.MeshStandardMaterial({
                color: 0x0a3a1a, roughness: 0.7,
                emissive: 0x002200, emissiveIntensity: 0.2
            });
            const radiantBase = new THREE.Mesh(new THREE.CircleGeometry(15, 24), radiantBaseMat);
            radiantBase.rotation.x = -Math.PI / 2;
            radiantBase.position.set(-45, 0.01, -45);
            scene.add(radiantBase);

            // Radiant decorative ring
            const radiantRing = new THREE.Mesh(
                new THREE.RingGeometry(14, 15.5, 24),
                new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 })
            );
            radiantRing.rotation.x = -Math.PI / 2;
            radiantRing.position.set(-45, 0.02, -45);
            scene.add(radiantRing);

            const direBaseMat = new THREE.MeshStandardMaterial({
                color: 0x3a0a0a, roughness: 0.7,
                emissive: 0x220000, emissiveIntensity: 0.2
            });
            const direBase = new THREE.Mesh(new THREE.CircleGeometry(15, 24), direBaseMat);
            direBase.rotation.x = -Math.PI / 2;
            direBase.position.set(45, 0.01, 45);
            scene.add(direBase);

            // Dire decorative ring
            const direRing = new THREE.Mesh(
                new THREE.RingGeometry(14, 15.5, 24),
                new THREE.MeshBasicMaterial({ color: 0xff3333, transparent: true, opacity: 0.3 })
            );
            direRing.rotation.x = -Math.PI / 2;
            direRing.position.set(45, 0.02, 45);
            scene.add(direRing);

            // Jungle camp markers
            createJungleCampAreas();

            // Rune spots
            createRuneSpots();
        }

        function createLaneEdgeMarkers(x1, z1, x2, z2, count) {
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            for (let i = 0; i < count; i++) {
                const t = i / (count - 1);
                const x = x1 + (x2 - x1) * t;
                const z = z1 + (z2 - z1) * t;
                const marker = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.3), markerMat);
                marker.position.set(x + 3, 0.05, z + 3);
                scene.add(marker);
                const marker2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.3), markerMat);
                marker2.position.set(x - 3, 0.05, z - 3);
                scene.add(marker2);
            }
        }

        function createGrassPatches() {
            const grassPositions = [];
            // Generate grass in jungle areas (avoiding lanes)
            for (let i = 0; i < 150; i++) {
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                // Avoid lane areas and bases
                if (Math.abs(x) < 4 && Math.abs(z) < 4) continue;
                if (Math.abs(x + z) < 8) continue; // Mid lane
                if (Math.abs(x) > 40 && Math.abs(z) < 6) continue; // Side lanes
                if (Math.abs(z) > 40 && Math.abs(x) < 6) continue;
                if (x < -35 && z < -35) continue; // Radiant base
                if (x > 35 && z > 35) continue; // Dire base

                grassPositions.push([x, z]);
            }

            grassPositions.forEach(([x, z]) => {
                const grassGroup = new THREE.Group();
                const bladeCount = 3 + Math.floor(Math.random() * 4);

                for (let i = 0; i < bladeCount; i++) {
                    const height = 0.3 + Math.random() * 0.4;
                    const blade = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, height, 4),
                        new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(0.28 + Math.random() * 0.08, 0.6, 0.25),
                            roughness: 0.9
                        })
                    );
                    blade.position.set(
                        (Math.random() - 0.5) * 0.5,
                        height / 2,
                        (Math.random() - 0.5) * 0.5
                    );
                    blade.rotation.x = (Math.random() - 0.5) * 0.3;
                    blade.rotation.z = (Math.random() - 0.5) * 0.3;
                    grassGroup.add(blade);
                }

                grassGroup.position.set(x, 0, z);
                scene.add(grassGroup);
                environmentObjects.grass.push(grassGroup);
            });
        }

        function createShrubs() {
            const shrubPositions = [
                [-25, -8], [-18, -22], [25, 8], [18, 22],
                [-8, 25], [8, -25], [-32, 12], [32, -12],
                [-15, -15], [15, 15], [-28, 28], [28, -28]
            ];

            shrubPositions.forEach(([x, z]) => {
                const shrub = new THREE.Group();

                // Multiple small spheres for bush effect
                for (let i = 0; i < 5; i++) {
                    const size = 0.4 + Math.random() * 0.3;
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(size, 6, 6),
                        new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.5, 0.2),
                            roughness: 0.9
                        })
                    );
                    leaf.position.set(
                        (Math.random() - 0.5) * 1,
                        size * 0.8,
                        (Math.random() - 0.5) * 1
                    );
                    shrub.add(leaf);
                }

                shrub.position.set(x + (Math.random() - 0.5) * 3, 0, z + (Math.random() - 0.5) * 3);
                scene.add(shrub);
            });
        }

        function createRiverBanks() {
            const bankMat = new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.9 });

            // Create bank edges along the river
            for (let i = 0; i < 15; i++) {
                const t = (i / 14) * 2 - 1;
                const x = t * 42;
                const z = t * 42 + 8;

                const bank1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 1.5), bankMat);
                bank1.position.set(x + 5, 0.08, z);
                bank1.rotation.y = Math.PI / 4;
                scene.add(bank1);

                const bank2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 1.5), bankMat);
                bank2.position.set(x - 5, 0.08, z - 8);
                bank2.rotation.y = Math.PI / 4;
                scene.add(bank2);
            }
        }

        function createFireflies() {
            // Create glowing particles in jungle areas
            const fireflyPositions = [
                [-25, -15], [-20, -25], [25, 15], [20, 25],
                [-15, 25], [15, -25], [-30, 20], [30, -20],
                [-10, -10], [10, 10]
            ];

            fireflyPositions.forEach(([x, z]) => {
                for (let i = 0; i < 3; i++) {
                    const firefly = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshBasicMaterial({
                            color: 0xffff88,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    firefly.position.set(
                        x + (Math.random() - 0.5) * 5,
                        1 + Math.random() * 2,
                        z + (Math.random() - 0.5) * 5
                    );
                    firefly.userData.baseY = firefly.position.y;
                    firefly.userData.phase = Math.random() * Math.PI * 2;
                    firefly.userData.speed = 0.5 + Math.random() * 0.5;
                    scene.add(firefly);
                    environmentObjects.fireflies.push(firefly);
                }
            });
        }

        function createJungleCampAreas() {
            // Jungle camp ground markers
            const campPositions = [
                { x: -25, z: -5, color: 0x2a2a1a },  // Radiant jungle
                { x: -15, z: -20, color: 0x2a2a1a },
                { x: 25, z: 5, color: 0x2a1a1a },   // Dire jungle
                { x: 15, z: 20, color: 0x2a1a1a }
            ];

            campPositions.forEach(camp => {
                const campGround = new THREE.Mesh(
                    new THREE.CircleGeometry(4, 12),
                    new THREE.MeshStandardMaterial({
                        color: camp.color,
                        roughness: 0.85
                    })
                );
                campGround.rotation.x = -Math.PI / 2;
                campGround.position.set(camp.x, 0.015, camp.z);
                scene.add(campGround);

                // Bones/debris decoration
                for (let i = 0; i < 3; i++) {
                    const bone = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.03, 0.4, 6),
                        new THREE.MeshStandardMaterial({ color: 0xccccaa, roughness: 0.8 })
                    );
                    bone.position.set(
                        camp.x + (Math.random() - 0.5) * 4,
                        0.1,
                        camp.z + (Math.random() - 0.5) * 4
                    );
                    bone.rotation.set(Math.random(), Math.random(), Math.PI / 2);
                    scene.add(bone);
                }
            });
        }

        function createRuneSpots() {
            // Power rune spots near river
            const runePositions = [
                { x: -15, z: 15 },
                { x: 15, z: -15 }
            ];

            runePositions.forEach(pos => {
                // Glowing rune circle
                const runeCircle = new THREE.Mesh(
                    new THREE.RingGeometry(1.2, 1.5, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.5,
                        side: THREE.DoubleSide
                    })
                );
                runeCircle.rotation.x = -Math.PI / 2;
                runeCircle.position.set(pos.x, 0.03, pos.z);
                scene.add(runeCircle);

                // Inner glow
                const innerGlow = new THREE.Mesh(
                    new THREE.CircleGeometry(1, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0xff8800,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                innerGlow.rotation.x = -Math.PI / 2;
                innerGlow.position.set(pos.x, 0.025, pos.z);
                scene.add(innerGlow);
            });
        }

        // Animate environment objects
        function updateEnvironment(dt) {
            const time = clock.getElapsedTime();

            // Animate grass swaying
            environmentObjects.grass.forEach((grass, i) => {
                grass.children.forEach((blade, j) => {
                    blade.rotation.z = Math.sin(time * 2 + i * 0.5 + j * 0.3) * 0.1;
                });
            });

            // Animate fireflies
            environmentObjects.fireflies.forEach((firefly, i) => {
                firefly.position.y = firefly.userData.baseY + Math.sin(time * firefly.userData.speed + firefly.userData.phase) * 0.5;
                firefly.position.x += Math.sin(time * 0.3 + i) * 0.01;
                firefly.position.z += Math.cos(time * 0.3 + i * 1.5) * 0.01;
                firefly.material.opacity = 0.5 + Math.sin(time * 3 + firefly.userData.phase) * 0.4;
            });
        }

        function createTree(x, z, treeType = 0) {
            const tree = new THREE.Group();

            // Tree type variations
            const treeConfigs = [
                { // Type 0: Standard tree
                    trunkHeight: 2, trunkRadius: [0.2, 0.3],
                    trunkColor: 0x4a3020, leafColor: 0x1a4a1a,
                    leafSize: 1.2, leafCount: 2
                },
                { // Type 1: Tall pine
                    trunkHeight: 3, trunkRadius: [0.15, 0.25],
                    trunkColor: 0x3a2515, leafColor: 0x0a3a0a,
                    leafSize: 0.8, leafCount: 3
                },
                { // Type 2: Wide oak
                    trunkHeight: 1.5, trunkRadius: [0.3, 0.4],
                    trunkColor: 0x5a4030, leafColor: 0x2a5a2a,
                    leafSize: 1.5, leafCount: 4
                }
            ];

            const config = treeConfigs[treeType % treeConfigs.length];

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(config.trunkRadius[0], config.trunkRadius[1], config.trunkHeight, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: config.trunkColor, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = config.trunkHeight / 2;
            tree.add(trunk);

            // Foliage based on tree type
            const leafMat = new THREE.MeshStandardMaterial({
                color: config.leafColor, roughness: 0.8,
                emissive: new THREE.Color(config.leafColor).multiplyScalar(0.3), emissiveIntensity: 0.15
            });

            if (treeType === 1) {
                // Pine tree - stacked cones
                for (let i = 0; i < config.leafCount; i++) {
                    const size = config.leafSize * (1 - i * 0.2);
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(size, size * 1.5, 6), leafMat);
                    cone.position.y = config.trunkHeight + i * 0.7;
                    tree.add(cone);
                }
            } else {
                // Regular tree - spherical foliage
                const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(config.leafSize, 6, 6), leafMat);
                leaf1.position.y = config.trunkHeight + 0.5;
                leaf1.scale.set(1, 0.8, 1);
                tree.add(leaf1);

                for (let i = 1; i < config.leafCount; i++) {
                    const angle = (i / config.leafCount) * Math.PI * 2;
                    const leaf = new THREE.Mesh(new THREE.SphereGeometry(config.leafSize * 0.6, 6, 6), leafMat);
                    leaf.position.set(
                        Math.cos(angle) * config.leafSize * 0.5,
                        config.trunkHeight + 0.8 + Math.random() * 0.5,
                        Math.sin(angle) * config.leafSize * 0.5
                    );
                    tree.add(leaf);
                }
            }

            tree.position.set(x, 0, z);
            tree.scale.setScalar(0.8 + Math.random() * 0.4);
            scene.add(tree);
        }

        function createRock(x, z) {
            const rockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.5, 0);
            const rockMat = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a, roughness: 0.9,
                flatShading: true
            });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, 0.3, z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.scale.set(1, 0.6, 1);
            scene.add(rock);
        }

        // --- CORE FUNCTIONS ---

        function init() {
            // ROUND 3: Initialize audio system
            AudioManager.init();

            // Setup Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050508, 20, 80); // Distance fog for atmosphere

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 30, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Shadows ON
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Post Processing
            const renderPass = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404060, 0.6); // Blue-ish ambient
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -50;
            sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50;
            sun.shadow.camera.bottom = -50;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // Environment
            const gridHelper = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
            scene.add(gridHelper);

            // Visual Ground with texture
            const planeGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x1a2a1a, roughness: 0.9 });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create map details
            createMapDetails();

            // Initialize jungle camps
            initJungleCamps();

            // LOGIC GROUND (Invisible, for reliable raycasting)
            const hitGeo = new THREE.PlaneGeometry(500, 500);
            const hitMat = new THREE.MeshBasicMaterial({ visible: false });
            window.hitPlane = new THREE.Mesh(hitGeo, hitMat); // Global for access
            window.hitPlane.rotation.x = -Math.PI / 2;
            scene.add(window.hitPlane);

            // Init Player with selected hero type
            player = new Hero(-42, -42, TEAM_RADIANT, selectedHeroType || 'voidwalker');
            entities.push(player);
            initPortrait();
            initMinimapClick();
            updateHeroUI(); // Update UI with hero-specific info

            // Structures - Bases
            radiantBase = new Structure(-45, -45, 'base', TEAM_RADIANT);
            direBase = new Structure(45, 45, 'base', TEAM_DIRE);
            entities.push(radiantBase);
            entities.push(direBase);

            // Towers for all 3 lanes
            for (const [laneName, lane] of Object.entries(LANES)) {
                // Radiant towers
                lane.towers.radiant.forEach(pos => {
                    entities.push(new Structure(pos.x, pos.z, 'tower', TEAM_RADIANT));
                });
                // Dire towers
                lane.towers.dire.forEach(pos => {
                    entities.push(new Structure(pos.x, pos.z, 'tower', TEAM_DIRE));
                });
            }

            // Inputs
            window.addEventListener('contextmenu', e => e.preventDefault()); // BLOCK RIGHT CLICK MENU
            window.addEventListener('mousedown', onMouseDown);
            // ROUND 5: Touch support for mobile
            window.addEventListener('touchstart', onTouchStart, { passive: false });

            // ROUND 1: Player death guards on keyboard
            // ROUND 2: Added Escape for pause
            // ROUND 9: Added B for shop
            window.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    togglePause();
                    return;
                }
                // ROUND 9: Shop toggle
                if (e.key.toLowerCase() === 'b') {
                    toggleShop();
                    return;
                }
                if (gameState !== 'playing') return;
                if (!player || player.dead) return;
                if (['q', 'w', 'e', 'r'].includes(e.key.toLowerCase())) player.cast(e.key.toLowerCase());
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start Loop
            spawnWave();
            // ROUND 4: Store interval IDs for cleanup on game end
            spawnIntervalId = setInterval(spawnWave, 30000);

            // ROUND 1: Save match on page unload
            window.addEventListener('beforeunload', saveMatchResult);

            // ROUND 1: Cleanup dead entities every 5 seconds
            // ROUND 4: Store interval ID for cleanup on game end
            cleanupIntervalId = setInterval(cleanupDeadEntities, 5000);

            animate();

            // Welcome msg
            setTimeout(() => document.getElementById('notification').classList.add('visible'), 500);
            setTimeout(() => document.getElementById('notification').classList.remove('visible'), 3000);
        }

        function updateMinimap() {
            const c = document.getElementById('minimap-canvas');
            if (!c) return;
            const ctx = c.getContext('2d');
            if (!ctx) return;

            c.width = 220; c.height = 220;
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, 220, 220);

            // Map Size 100x100 (-50 to 50) maps to 0-220
            const mapToScreen = (val) => (val + 50) * 2.2;

            // Draw all 3 lane paths on minimap
            ctx.strokeStyle = '#2a3a2a';
            ctx.lineWidth = 4;

            // Mid lane (diagonal from Radiant to Dire)
            ctx.beginPath();
            ctx.moveTo(mapToScreen(-42), mapToScreen(-42));
            ctx.lineTo(mapToScreen(42), mapToScreen(42));
            ctx.stroke();

            // Top lane (left side then across to Dire)
            ctx.beginPath();
            ctx.moveTo(mapToScreen(-42), mapToScreen(-42));
            ctx.lineTo(mapToScreen(-42), mapToScreen(42));  // Up left side
            ctx.lineTo(mapToScreen(42), mapToScreen(42));   // Across top to Dire
            ctx.stroke();

            // Bot lane (across bottom then up right side)
            ctx.beginPath();
            ctx.moveTo(mapToScreen(-42), mapToScreen(-42));
            ctx.lineTo(mapToScreen(42), mapToScreen(-42));  // Across bottom
            ctx.lineTo(mapToScreen(42), mapToScreen(42));   // Up right to Dire
            ctx.stroke();

            // Draw base indicators
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(mapToScreen(-45), mapToScreen(-45), 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff3c3c';
            ctx.beginPath();
            ctx.arc(mapToScreen(45), mapToScreen(45), 8, 0, Math.PI * 2);
            ctx.fill();

            entities.forEach(e => {
                // ROUND 1: Robust guards for entity state
                if (!e || e.dead || !e.mesh || !e.mesh.position) return;

                const x = mapToScreen(e.mesh.position.x);
                const z = mapToScreen(e.mesh.position.z);

                ctx.fillStyle = e.team === TEAM_RADIANT ? '#00ff88' : '#ff3c3c';

                // ROUND 8: Different shapes for different entity types
                if (e instanceof Structure) {
                    // Squares for structures, larger for bases
                    const size = e.type === 'base' ? 8 : 5;
                    ctx.fillStyle = e.team === TEAM_RADIANT ? '#00ffaa' : '#ff5555';
                    ctx.fillRect(x - size/2, z - size/2, size, size);
                    // Border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x - size/2, z - size/2, size, size);
                } else if (e instanceof Hero) {
                    // Triangle for hero
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.moveTo(x, z - 5);
                    ctx.lineTo(x - 4, z + 4);
                    ctx.lineTo(x + 4, z + 4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (e instanceof SiegeCreep) {
                    // Larger circle for siege
                    ctx.beginPath();
                    ctx.arc(x, z, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (e instanceof RangedCreep) {
                    // Diamond for ranged
                    ctx.beginPath();
                    ctx.moveTo(x, z - 2);
                    ctx.lineTo(x + 2, z);
                    ctx.lineTo(x, z + 2);
                    ctx.lineTo(x - 2, z);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Small circle for melee creeps
                    ctx.beginPath();
                    ctx.arc(x, z, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ROUND 8: Draw camera viewport rectangle
            if (player && player.mesh) {
                const camX = mapToScreen(player.mesh.position.x);
                const camZ = mapToScreen(player.mesh.position.z);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(camX - 30, camZ - 20, 60, 40);
            }
        }

        // ROUND 8: Minimap click-to-move
        function initMinimapClick() {
            const c = document.getElementById('minimap-canvas');
            if (!c) return;

            c.addEventListener('click', (e) => {
                if (gameState !== 'playing' || !player || player.dead) return;

                const rect = c.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickZ = e.clientY - rect.top;

                // Convert screen coords to world coords
                // Screen 0-220 maps to world -50 to 50
                const worldX = (clickX / 220) * 100 - 50;
                const worldZ = (clickZ / 220) * 100 - 50;

                player.targetPos.set(worldX, 0, worldZ);

                // Visual feedback on minimap
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(clickX, clickZ, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Track wave number for siege creep spawning
        let waveNumber = 0;

        // Spawn creeps on a specific lane
        function spawnLaneCreeps(laneName) {
            const lane = LANES[laneName];
            if (!lane) return;

            // Spawn positions with slight offset to avoid stacking
            const radiantSpawn = lane.radiantSpawn;
            const direSpawn = lane.direSpawn;

            // Melee creeps (3 per lane per wave)
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const rCreep = new Creep(
                        radiantSpawn.x + (Math.random() - 0.5) * 2,
                        radiantSpawn.z + (Math.random() - 0.5) * 2,
                        TEAM_RADIANT
                    );
                    rCreep.lane = laneName;
                    rCreep.waypoints = [...lane.waypoints.radiant];
                    entities.push(rCreep);

                    const dCreep = new Creep(
                        direSpawn.x + (Math.random() - 0.5) * 2,
                        direSpawn.z + (Math.random() - 0.5) * 2,
                        TEAM_DIRE
                    );
                    dCreep.lane = laneName;
                    dCreep.waypoints = [...lane.waypoints.dire];
                    entities.push(dCreep);
                }, i * 400);
            }

            // Ranged creep (1 per lane)
            setTimeout(() => {
                const rRanged = new RangedCreep(radiantSpawn.x, radiantSpawn.z - 2, TEAM_RADIANT);
                rRanged.lane = laneName;
                rRanged.waypoints = [...lane.waypoints.radiant];
                entities.push(rRanged);

                const dRanged = new RangedCreep(direSpawn.x, direSpawn.z + 2, TEAM_DIRE);
                dRanged.lane = laneName;
                dRanged.waypoints = [...lane.waypoints.dire];
                entities.push(dRanged);
            }, 3 * 400);

            // Siege creep every 3rd wave
            if (waveNumber % 3 === 0) {
                setTimeout(() => {
                    const rSiege = new SiegeCreep(radiantSpawn.x - 2, radiantSpawn.z, TEAM_RADIANT);
                    rSiege.lane = laneName;
                    rSiege.waypoints = [...lane.waypoints.radiant];
                    entities.push(rSiege);

                    const dSiege = new SiegeCreep(direSpawn.x + 2, direSpawn.z, TEAM_DIRE);
                    dSiege.lane = laneName;
                    dSiege.waypoints = [...lane.waypoints.dire];
                    entities.push(dSiege);
                }, 4 * 400);
            }
        }

        function spawnWave() {
            waveNumber++;

            // Spawn creeps on all 3 lanes
            spawnLaneCreeps('top');
            spawnLaneCreeps('mid');
            spawnLaneCreeps('bot');

            if (waveNumber % 3 === 0) {
                showMessage("SIEGE WAVE - ALL LANES!");
            } else {
                showMessage("Creeps Spawning - All Lanes");
            }
        }

        function showMessage(text) {
            const n = document.getElementById('notification');
            n.textContent = text;
            n.classList.add('visible');
            // ROUND 3: Play notification sound
            AudioManager.playUI('notification');
            setTimeout(() => n.classList.remove('visible'), 2000);
        }

        // ROUND 5: Flash ability icon red on failed cast
        function flashAbilityError(key) {
            const slot = document.getElementById(`ab-${key}`);
            if (!slot) return;
            slot.style.boxShadow = '0 0 15px #ff3c3c, inset 0 0 20px rgba(255,60,60,0.5)';
            slot.style.borderColor = '#ff3c3c';
            setTimeout(() => {
                slot.style.boxShadow = '';
                slot.style.borderColor = '';
            }, 200);
        }

        function onMouseDown(e) {
            // ROUND 3: Resume audio context on user interaction
            AudioManager.resume();

            if (e.button === 0 || e.button === 2) { // Left or Right Click to move
                e.preventDefault();

                // Don't move if clicking on UI elements
                if (e.target.closest('.ability-slot') || e.target.closest('.data-buttons') || e.target.closest('.hud-container')) return;

                // ROUND 1: Player death guard
                if (gameState !== 'playing' || !player || player.dead) return;

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                // Intersect ONLY the hit plane for reliable movement
                const intersects = raycaster.intersectObject(window.hitPlane);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    console.log("Move to:", point); // DEBUG
                    player.targetPos.copy(point);

                    // Click Visual
                    const r = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.8 }));
                    r.rotation.x = -Math.PI / 2;
                    r.position.copy(point); r.position.y = 0.2;
                    scene.add(r);

                    // Tween out
                    let sc = 1;
                    const animClick = () => {
                        sc -= 0.05;
                        r.scale.set(sc, sc, sc);
                        r.material.opacity = sc;
                        if (sc > 0) requestAnimationFrame(animClick);
                        else scene.remove(r);
                    };
                    animClick();
                }
            }
        }

        // ROUND 5: Touch support for mobile movement
        function onTouchStart(e) {
            // Don't interfere with ability buttons
            if (e.target.closest('.ability-slot') || e.target.closest('.data-buttons')) return;

            e.preventDefault();
            AudioManager.resume();

            if (gameState !== 'playing' || !player || player.dead) return;

            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(window.hitPlane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                player.targetPos.copy(point);

                // Touch Visual (same as click)
                const r = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.8 }));
                r.rotation.x = -Math.PI / 2;
                r.position.copy(point); r.position.y = 0.2;
                scene.add(r);

                let sc = 1;
                const animTouch = () => {
                    sc -= 0.05;
                    r.scale.set(sc, sc, sc);
                    r.material.opacity = sc;
                    if (sc > 0) requestAnimationFrame(animTouch);
                    else scene.remove(r);
                };
                animTouch();
            }
        }

        // ROUND 5: Ability button tap handler for mobile
        function castAbility(key) {
            if (gameState !== 'playing' || !player || player.dead) return;
            player.cast(key);
        }

        function updateHeroUI() {
            // ROUND 1: Guard against null/dead player
            if (!player || player.dead) return;

            // Update hero name and ability icons from hero definition
            if (player.heroDef && !cachedUI.heroInit) {
                cachedUI.heroInit = true;
                const heroDef = player.heroDef;

                // Update hero name
                const nameEl = document.querySelector('.unit-name');
                if (nameEl) nameEl.textContent = heroDef.name;

                // Update ability icons
                for (const key of ['q', 'w', 'e', 'r']) {
                    const iconEl = document.querySelector(`#ab-${key} .ability-icon`);
                    const costEl = document.querySelector(`#ab-${key} .mana-cost`);
                    if (iconEl && heroDef.abilities[key]) {
                        iconEl.textContent = heroDef.abilities[key].icon;
                    }
                    if (costEl && heroDef.abilities[key]) {
                        costEl.textContent = heroDef.abilities[key].cost;
                    }
                }

                // Update stat display
                document.getElementById('stat-dmg').textContent = Math.floor(player.damage);
                document.getElementById('stat-armor').textContent = player.armor.toFixed(1);
                document.getElementById('stat-gold').textContent = player.gold;

                // Update HP/MP text
                document.getElementById('hp-text').textContent = `${player.hp} / ${player.maxHp}`;
                document.getElementById('mp-text').textContent = `${player.mp} / ${player.maxMp}`;
            }

            // ROUND 2: Performance - only update DOM when values change
            const hpFloor = Math.floor(player.hp);
            const mpFloor = Math.floor(player.mp);

            if (hpFloor !== cachedUI.hp) {
                cachedUI.hp = hpFloor;
                const hpPct = (player.hp / player.maxHp) * 100;
                const hpBar = document.getElementById('hp-bar');
                const hpText = document.getElementById('hp-text');
                if (hpBar) hpBar.style.width = hpPct + '%';
                if (hpText) hpText.textContent = hpFloor + ' / ' + player.maxHp;
            }

            if (mpFloor !== cachedUI.mp) {
                cachedUI.mp = mpFloor;
                const mpPct = (player.mp / player.maxMp) * 100;
                const mpBar = document.getElementById('mp-bar');
                const mpText = document.getElementById('mp-text');
                if (mpBar) mpBar.style.width = mpPct + '%';
                if (mpText) mpText.textContent = mpFloor + ' / ' + player.maxMp;
            }

            // ROUND 7: Update XP bar
            if (cachedUI.xp !== player.xp || cachedUI.level !== player.level) {
                cachedUI.xp = player.xp;
                cachedUI.level = player.level;
                const xpPct = (player.xp / player.xpToLevel) * 100;
                const xpBar = document.getElementById('xp-bar');
                const xpText = document.getElementById('xp-text');
                if (xpBar) xpBar.style.width = xpPct + '%';
                if (xpText) xpText.textContent = `${player.xp} / ${player.xpToLevel} XP`;
            }

            // ROUND 8: Update gold display
            if (cachedUI.gold !== player.gold) {
                cachedUI.gold = player.gold;
                const goldEl = document.getElementById('stat-gold');
                if (goldEl) goldEl.textContent = player.gold;
            }
        }

        function updateCooldownUI(key, current, max) {
            const el = document.querySelector(`#ab-${key} .cooldown-mask`);
            if (el) {
                const pct = (current / max) * 100;
                el.style.height = pct + '%';
                el.textContent = current > 0 ? Math.ceil(current) : '';
            }
        }

        function updateScoreBoard() {
            document.getElementById('score-radiant').textContent = score.radiant;
            document.getElementById('score-dire').textContent = score.dire;
        }

        function initPortrait() {
            // Tiny separate scene for the 3D portrait
            const container = document.getElementById('portrait-container');
            if (!container) return;

            portraitScene = new THREE.Scene();
            portraitScene.background = new THREE.Color(0x111111);

            portraitCamera = new THREE.PerspectiveCamera(50, 90 / 110, 0.1, 100);
            portraitCamera.position.set(0, 0, 3);

            portraitRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            portraitRenderer.setSize(90, 110);
            container.appendChild(portraitRenderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(1, 1, 1);
            portraitScene.add(light);
            portraitScene.add(new THREE.AmbientLight(0x404040));

            // Copy hero mesh layout roughly
            const geo = new THREE.CylinderGeometry(0.6, 0.6, 2.2, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff88, roughness: 0.2 });
            portraitMesh = new THREE.Mesh(geo, mat);
            portraitScene.add(portraitMesh);
        }

        function animate() {
            requestAnimationFrame(animate);

            // ROUND 2: Handle pause state - still render but don't update
            if (gameState === 'paused') {
                composer.render();
                if (portraitRenderer) portraitRenderer.render(portraitScene, portraitCamera);
                return;
            }

            const dt = clock.getDelta();
            gameTime += dt;

            // ROUND 2: Respawn timer countdown
            if (isRespawning && gameState === 'playing') {
                respawnTimer -= dt;
                const timerEl = document.getElementById('respawn-timer');
                if (timerEl) timerEl.textContent = `Respawn: ${Math.ceil(respawnTimer)}s`;
                if (respawnTimer <= 0) {
                    respawnHero();
                }
            }

            // ROUND 2: Check win conditions
            checkWinConditions();

            // Camera Follow with screen shake
            if (player && !player.dead && player.mesh) {
                const shakeOffset = screenShake.update();
                const targetPos = player.mesh.position.clone().add(new THREE.Vector3(shakeOffset.x, 25 + shakeOffset.y, 20));
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(player.mesh.position);
            }

            // Entities (only update when playing)
            if (gameState === 'playing') {
                entities.forEach(e => e.update(dt));

                // Update jungle camp respawn timers
                updateJungleCamps(dt);

                // Update animation and particle systems
                if (typeof AnimationSystem !== 'undefined' && AnimationSystem.update) {
                    AnimationSystem.update(dt);
                }
                if (typeof ParticleSystem !== 'undefined' && ParticleSystem.update) {
                    ParticleSystem.update(dt);
                }

                // Update environment animations (grass, fireflies)
                if (typeof updateEnvironment === 'function') {
                    updateEnvironment(dt);
                }
            }
            floatingTexts.forEach(t => t.updatePosition());

            // ROUND 2: Throttled minimap updates
            const now = performance.now();
            if (now - lastMinimapUpdate > MINIMAP_UPDATE_INTERVAL) {
                updateMinimap();
                lastMinimapUpdate = now;
            }

            composer.render();

            // Portrait Render
            if (portraitRenderer) {
                portraitRenderer.render(portraitScene, portraitCamera);
            }

            // Time
            const mins = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const secs = Math.floor(gameTime % 60).toString().padStart(2, '0');
            document.getElementById('game-time').textContent = `${mins}:${secs}`;
        }

        // Populate hero selection screen
        function initHeroSelect() {
            const grid = document.getElementById('hero-grid');
            grid.innerHTML = '';

            for (const [heroId, hero] of Object.entries(HERO_DEFS)) {
                const card = document.createElement('div');
                card.style.cssText = `
                    background: rgba(20,20,35,0.9);
                    border: 2px solid #333;
                    border-radius: 12px;
                    padding: 20px;
                    width: 180px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                `;
                card.innerHTML = `
                    <div style="font-size:48px;margin-bottom:10px;">${hero.icon}</div>
                    <h3 style="color:#${hero.color.toString(16).padStart(6,'0')};margin:0;font-family:var(--font-display);font-size:18px;">${hero.name}</h3>
                    <p style="color:#8899aa;font-size:11px;margin:8px 0;">${hero.description}</p>
                    <div style="font-size:10px;color:#667788;text-align:left;margin-top:10px;">
                        <div>HP: ${hero.stats.hp} | MP: ${hero.stats.mp}</div>
                        <div>DMG: ${hero.stats.damage} | ARM: ${hero.stats.armor}</div>
                    </div>
                `;

                card.onmouseenter = () => {
                    card.style.borderColor = `#${hero.color.toString(16).padStart(6,'0')}`;
                    card.style.boxShadow = `0 0 20px rgba(${(hero.color >> 16) & 255},${(hero.color >> 8) & 255},${hero.color & 255},0.4)`;
                    card.style.transform = 'scale(1.05)';
                };
                card.onmouseleave = () => {
                    card.style.borderColor = '#333';
                    card.style.boxShadow = 'none';
                    card.style.transform = 'scale(1)';
                };
                card.onclick = () => selectHero(heroId);

                grid.appendChild(card);
            }
        }

        function selectHero(heroId) {
            selectedHeroType = heroId;
            document.getElementById('hero-select').style.display = 'none';
            init();
        }

        // Start with hero selection
        initHeroSelect();
    </script>
</body>

</html>
