<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Display Creator - Real 3D Holograms</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0ff;
            overflow-x: hidden;
            position: relative;
        }

        /* Hologram Canvas Styling */
        #hologram-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, #001122 0%, #000 50%);
        }

        #hologram-canvas {
            width: min(90vw, 90vh);
            height: min(90vw, 90vh);
            background: #000;
            position: relative;
            border: 2px solid #0ff;
            box-shadow: 0 0 30px #0ff, inset 0 0 30px rgba(0,255,255,0.1);
        }

        /* Quadrant Grid Overlay */
        .quadrant-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .grid-line-h {
            position: absolute;
            width: 100%;
            height: 1px;
            background: rgba(0, 255, 255, 0.2);
            top: 50%;
            left: 0;
        }

        .grid-line-v {
            position: absolute;
            width: 1px;
            height: 100%;
            background: rgba(0, 255, 255, 0.2);
            top: 0;
            left: 50%;
        }

        .quadrant-label {
            position: absolute;
            color: rgba(0, 255, 255, 0.3);
            font-size: 10px;
            padding: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .quadrant-label.top { top: 10px; left: 50%; transform: translateX(-50%); }
        .quadrant-label.right { right: 10px; top: 50%; transform: translateY(-50%) rotate(270deg); }
        .quadrant-label.bottom { bottom: 10px; left: 50%; transform: translateX(-50%) rotate(180deg); }
        .quadrant-label.left { left: 10px; top: 50%; transform: translateY(-50%) rotate(90deg); }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 20, 20, 0.95);
            border-bottom: 2px solid #0ff;
            padding: 15px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .control-panel.open {
            transform: translateY(0);
        }

        .panel-toggle {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 0 0 10px 10px;
            cursor: pointer;
            font-weight: bold;
            z-index: 1001;
            transition: all 0.3s;
        }

        .panel-toggle:hover {
            background: #fff;
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.8);
        }

        /* Model Library */
        .model-library {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
            margin-bottom: 15px;
        }

        .model-card {
            flex-shrink: 0;
            width: 120px;
            height: 120px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .model-card:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        .model-card.active {
            background: rgba(0, 255, 255, 0.4);
            border-color: #fff;
        }

        .model-icon {
            font-size: 40px;
            margin-bottom: 5px;
        }

        .model-name {
            font-size: 11px;
            color: #fff;
        }

        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-group {
            background: rgba(0, 40, 40, 0.5);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .control-label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(0, 255, 255, 0.8);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #0ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #0ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px #0ff;
        }

        /* Buttons */
        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #0ff, #00a8a8);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: linear-gradient(135deg, #fff, #0ff);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.recording {
            background: linear-gradient(135deg, #ff0040, #ff6b6b);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 64, 0.8); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 64, 1); }
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        /* Template Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: rgba(0, 40, 40, 0.98);
            border: 2px solid #0ff;
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #0ff;
            font-size: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-close:hover {
            color: #fff;
            transform: rotate(90deg);
        }

        /* Pyramid Template */
        .pyramid-template {
            text-align: center;
        }

        .template-svg {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .instructions {
            text-align: left;
            background: rgba(0, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            color: #0ff;
            margin-bottom: 15px;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .instructions li {
            margin-bottom: 10px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .control-panel {
                padding: 10px;
            }

            .model-library {
                flex-wrap: nowrap;
            }

            .model-card {
                width: 100px;
                height: 100px;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .button-row {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        /* Loading Animation */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 3000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 255, 255, 0.2);
            border-top: 3px solid #0ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 255, 255, 0.95);
            color: #000;
            padding: 20px 40px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 3000;
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translate(-50%, -50%) scale(1);
        }

        /* Hidden file input */
        #importFile {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Main Hologram Display -->
    <div id="hologram-container">
        <canvas id="hologram-canvas"></canvas>
        <div class="quadrant-grid">
            <div class="grid-line-h"></div>
            <div class="grid-line-v"></div>
            <div class="quadrant-label top">TOP</div>
            <div class="quadrant-label right">RIGHT</div>
            <div class="quadrant-label bottom">BOTTOM</div>
            <div class="quadrant-label left">LEFT</div>
        </div>
    </div>

    <!-- Control Panel Toggle -->
    <button class="panel-toggle" onclick="togglePanel()">‚ò∞ Control Panel</button>

    <!-- Control Panel -->
    <div class="control-panel" id="controlPanel">
        <h2 style="text-align: center; margin-bottom: 20px; color: #fff; text-shadow: 0 0 10px #0ff;">
            üîÆ Holographic Display Creator
        </h2>

        <!-- Model Library -->
        <div class="model-library" id="modelLibrary">
            <div class="model-card active" data-model="cube">
                <div class="model-icon">‚¨ú</div>
                <div class="model-name">Rotating Cube</div>
            </div>
            <div class="model-card" data-model="dna">
                <div class="model-icon">üß¨</div>
                <div class="model-name">DNA Helix</div>
            </div>
            <div class="model-card" data-model="atom">
                <div class="model-icon">‚öõÔ∏è</div>
                <div class="model-name">Atom</div>
            </div>
            <div class="model-card" data-model="heart">
                <div class="model-icon">‚ù§Ô∏è</div>
                <div class="model-name">Heart</div>
            </div>
            <div class="model-card" data-model="star">
                <div class="model-icon">‚≠ê</div>
                <div class="model-name">Star System</div>
            </div>
            <div class="model-card" data-model="robot">
                <div class="model-icon">ü§ñ</div>
                <div class="model-name">Dancing Robot</div>
            </div>
            <div class="model-card" data-model="crystal">
                <div class="model-icon">üíé</div>
                <div class="model-name">Crystal</div>
            </div>
            <div class="model-card" data-model="fireworks">
                <div class="model-icon">üéÜ</div>
                <div class="model-name">Fireworks</div>
            </div>
            <div class="model-card" data-model="galaxy">
                <div class="model-icon">üåå</div>
                <div class="model-name">Galaxy</div>
            </div>
            <div class="model-card" data-model="pyramid">
                <div class="model-icon">üî∫</div>
                <div class="model-name">Pyramid</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label class="control-label">Rotation Speed</label>
                <input type="range" id="rotationSpeed" min="0" max="100" value="50">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <small>Stopped</small>
                    <small id="rotationValue">50%</small>
                    <small>Fast</small>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Scale</label>
                <input type="range" id="scale" min="10" max="200" value="100">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <small>Small</small>
                    <small id="scaleValue">100%</small>
                    <small>Large</small>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Brightness</label>
                <input type="range" id="brightness" min="10" max="100" value="80">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <small>Dim</small>
                    <small id="brightnessValue">80%</small>
                    <small>Bright</small>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Color Hue</label>
                <input type="range" id="hue" min="0" max="360" value="180">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <small>Red</small>
                    <small id="hueValue">Cyan</small>
                    <small>Red</small>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="button-row">
            <button class="btn" onclick="toggleRecording()" id="recordBtn">üé• Record</button>
            <button class="btn" onclick="showTemplate()">üìê Get Pyramid Template</button>
            <button class="btn" onclick="toggleFullscreen()">üî≥ Fullscreen</button>
            <button class="btn" onclick="resetView()">üîÑ Reset View</button>
            <button class="btn" onclick="toggleAutoRotate()" id="autoRotateBtn">‚ñ∂Ô∏è Auto Rotate</button>
            <button class="btn" onclick="captureFrame()">üì∏ Screenshot</button>
        </div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">üíæ Export Settings</button>
        <button onclick="document.getElementById('importFile').click()">üìÇ Import Settings</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
    </div>

    <!-- Template Modal -->
    <div class="modal" id="templateModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">√ó</button>
            <div class="pyramid-template">
                <h2 style="color: #0ff; margin-bottom: 20px;">üìê Hologram Pyramid Template</h2>

                <div class="template-svg">
                    <svg width="400" height="400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400">
                        <!-- Background -->
                        <rect width="400" height="400" fill="white"/>

                        <!-- Title -->
                        <text x="200" y="30" text-anchor="middle" font-family="Arial" font-size="16" fill="black">
                            Hologram Pyramid Template (Print on Clear Plastic)
                        </text>

                        <!-- Center Square (base) -->
                        <rect x="150" y="150" width="100" height="100"
                              fill="none" stroke="black" stroke-width="2"/>
                        <text x="200" y="205" text-anchor="middle" font-size="10" fill="black">BASE</text>

                        <!-- Top Triangle -->
                        <path d="M 150,150 L 200,50 L 250,150 Z"
                              fill="none" stroke="black" stroke-width="2" stroke-dasharray="5,3"/>
                        <text x="200" y="110" text-anchor="middle" font-size="10" fill="black">TOP</text>

                        <!-- Right Triangle -->
                        <path d="M 250,150 L 350,200 L 250,250 Z"
                              fill="none" stroke="black" stroke-width="2" stroke-dasharray="5,3"/>
                        <text x="290" y="205" text-anchor="middle" font-size="10" fill="black">RIGHT</text>

                        <!-- Bottom Triangle -->
                        <path d="M 250,250 L 200,350 L 150,250 Z"
                              fill="none" stroke="black" stroke-width="2" stroke-dasharray="5,3"/>
                        <text x="200" y="290" text-anchor="middle" font-size="10" fill="black">BOTTOM</text>

                        <!-- Left Triangle -->
                        <path d="M 150,250 L 50,200 L 150,150 Z"
                              fill="none" stroke="black" stroke-width="2" stroke-dasharray="5,3"/>
                        <text x="110" y="205" text-anchor="middle" font-size="10" fill="black">LEFT</text>

                        <!-- Fold Lines -->
                        <line x1="150" y1="150" x2="200" y2="50" stroke="gray" stroke-width="1" stroke-dasharray="2,2"/>
                        <line x1="250" y1="150" x2="350" y2="200" stroke="gray" stroke-width="1" stroke-dasharray="2,2"/>
                        <line x1="250" y1="250" x2="200" y2="350" stroke="gray" stroke-width="1" stroke-dasharray="2,2"/>
                        <line x1="150" y1="250" x2="50" y2="200" stroke="gray" stroke-width="1" stroke-dasharray="2,2"/>

                        <!-- Instructions -->
                        <text x="200" y="380" text-anchor="middle" font-size="12" fill="black">
                            Cut solid lines, fold dashed lines inward
                        </text>
                    </svg>
                </div>

                <button class="btn" onclick="downloadTemplate()">‚¨áÔ∏è Download Template (SVG)</button>

                <div class="instructions">
                    <h3>üõ†Ô∏è Assembly Instructions</h3>
                    <ol>
                        <li><strong>Materials Needed:</strong> Clear plastic sheet (transparency film or CD case), scissors, clear tape</li>
                        <li><strong>Print:</strong> Print template on transparency sheet at 100% scale (or trace on CD case plastic)</li>
                        <li><strong>Cut:</strong> Cut along all solid black lines carefully</li>
                        <li><strong>Score:</strong> Lightly score dashed lines with a ruler and knife tip (don't cut through)</li>
                        <li><strong>Fold:</strong> Fold all four triangles inward along the dashed lines</li>
                        <li><strong>Tape:</strong> Apply small pieces of clear tape to join the edges, forming a pyramid</li>
                        <li><strong>Place:</strong> Put pyramid on phone screen with point facing up, centered on display</li>
                        <li><strong>Enjoy:</strong> Open this app, select a hologram, and watch the magic!</li>
                    </ol>

                    <h3>üí° Pro Tips</h3>
                    <ul style="margin-left: 20px; line-height: 1.8;">
                        <li>Use old CD cases for free clear plastic</li>
                        <li>Larger pyramids (tablet size) create bigger holograms</li>
                        <li>Clean pyramid surfaces for best clarity</li>
                        <li>Darken room and increase screen brightness</li>
                        <li>45¬∞ angle sides work best for smartphones</li>
                        <li>Multiple pyramids + multiple phones = mega hologram!</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Application state
        const APP_NAME = 'holographic-display-creator';
        let appData = {
            currentModel: 'cube',
            rotationSpeed: 50,
            scale: 100,
            brightness: 80,
            hue: 180,
            autoRotate: true,
            recordings: []
        };

        // Canvas and rendering context
        let canvas, ctx;
        let animationFrame;
        let currentRotation = 0;
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];

        // Initialize application
        function init() {
            loadData();
            setupCanvas();
            setupControls();
            setupModelLibrary();
            render();

            // Show welcome message
            showNotification('üîÆ Welcome to Holographic Display Creator!', 3000);
        }

        // Setup canvas
        function setupCanvas() {
            canvas = document.getElementById('hologram-canvas');
            ctx = canvas.getContext('2d');

            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        // Resize canvas to maintain square aspect ratio
        function resizeCanvas() {
            const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
            canvas.width = size;
            canvas.height = size;
        }

        // Setup control listeners
        function setupControls() {
            // Slider controls
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                appData.rotationSpeed = e.target.value;
                document.getElementById('rotationValue').textContent = e.target.value + '%';
                saveData();
            });

            document.getElementById('scale').addEventListener('input', (e) => {
                appData.scale = e.target.value;
                document.getElementById('scaleValue').textContent = e.target.value + '%';
                saveData();
            });

            document.getElementById('brightness').addEventListener('input', (e) => {
                appData.brightness = e.target.value;
                document.getElementById('brightnessValue').textContent = e.target.value + '%';
                saveData();
            });

            document.getElementById('hue').addEventListener('input', (e) => {
                appData.hue = e.target.value;
                const hueNames = ['Red', 'Orange', 'Yellow', 'Green', 'Cyan', 'Blue', 'Purple', 'Magenta', 'Red'];
                const index = Math.floor(e.target.value / 45);
                document.getElementById('hueValue').textContent = hueNames[index];
                saveData();
            });

            // Load saved values
            document.getElementById('rotationSpeed').value = appData.rotationSpeed;
            document.getElementById('scale').value = appData.scale;
            document.getElementById('brightness').value = appData.brightness;
            document.getElementById('hue').value = appData.hue;

            // Update displays
            document.getElementById('rotationValue').textContent = appData.rotationSpeed + '%';
            document.getElementById('scaleValue').textContent = appData.scale + '%';
            document.getElementById('brightnessValue').textContent = appData.brightness + '%';
        }

        // Setup model library
        function setupModelLibrary() {
            const cards = document.querySelectorAll('.model-card');
            cards.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active class from all
                    cards.forEach(c => c.classList.remove('active'));
                    // Add active to clicked
                    card.classList.add('active');
                    // Update current model
                    appData.currentModel = card.dataset.model;
                    saveData();
                    showNotification(`Selected: ${card.querySelector('.model-name').textContent}`, 1500);
                });
            });
        }

        // Main render loop
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update rotation
            if (appData.autoRotate) {
                currentRotation += (appData.rotationSpeed / 50) * 0.02;
            }

            // Calculate quadrant size
            const quadrantSize = canvas.width / 2;

            // Render each quadrant with different perspectives
            renderQuadrant('top', 0, 0, quadrantSize, 0);
            renderQuadrant('right', quadrantSize, 0, quadrantSize, 90);
            renderQuadrant('bottom', quadrantSize, quadrantSize, quadrantSize, 180);
            renderQuadrant('left', 0, quadrantSize, quadrantSize, 270);

            // Continue animation
            animationFrame = requestAnimationFrame(render);
        }

        // Render a single quadrant
        function renderQuadrant(position, x, y, size, rotation) {
            ctx.save();

            // Set up quadrant transform
            ctx.translate(x + size/2, y + size/2);
            ctx.rotate((rotation * Math.PI) / 180);

            // Apply brightness
            const brightness = appData.brightness / 100;
            ctx.globalAlpha = brightness;

            // Draw the current model
            drawModel(appData.currentModel, size * (appData.scale / 100));

            ctx.restore();
        }

        // Draw different 3D models
        function drawModel(modelType, size) {
            const color = `hsl(${appData.hue}, 100%, 50%)`;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;

            switch(modelType) {
                case 'cube':
                    drawCube(size);
                    break;
                case 'dna':
                    drawDNA(size);
                    break;
                case 'atom':
                    drawAtom(size);
                    break;
                case 'heart':
                    drawHeart(size);
                    break;
                case 'star':
                    drawStarSystem(size);
                    break;
                case 'robot':
                    drawRobot(size);
                    break;
                case 'crystal':
                    drawCrystal(size);
                    break;
                case 'fireworks':
                    drawFireworks(size);
                    break;
                case 'galaxy':
                    drawGalaxy(size);
                    break;
                case 'pyramid':
                    drawPyramid(size);
                    break;
                default:
                    drawCube(size);
            }
        }

        // Model drawing functions
        function drawCube(size) {
            const s = size * 0.3;
            const angle = currentRotation;

            // Calculate 3D rotation
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            // Front face
            ctx.beginPath();
            ctx.moveTo(-s * cos, -s);
            ctx.lineTo(s * cos, -s);
            ctx.lineTo(s * cos, s);
            ctx.lineTo(-s * cos, s);
            ctx.closePath();
            ctx.stroke();

            // Back face
            ctx.beginPath();
            ctx.moveTo(-s * sin * 0.7, -s * 0.7);
            ctx.lineTo(s * sin * 0.7, -s * 0.7);
            ctx.lineTo(s * sin * 0.7, s * 0.7);
            ctx.lineTo(-s * sin * 0.7, s * 0.7);
            ctx.closePath();
            ctx.stroke();

            // Connecting lines
            ctx.beginPath();
            ctx.moveTo(-s * cos, -s);
            ctx.lineTo(-s * sin * 0.7, -s * 0.7);
            ctx.moveTo(s * cos, -s);
            ctx.lineTo(s * sin * 0.7, -s * 0.7);
            ctx.moveTo(s * cos, s);
            ctx.lineTo(s * sin * 0.7, s * 0.7);
            ctx.moveTo(-s * cos, s);
            ctx.lineTo(-s * sin * 0.7, s * 0.7);
            ctx.stroke();
        }

        function drawDNA(size) {
            const s = size * 0.4;
            const steps = 30;

            ctx.beginPath();
            for (let i = 0; i < steps; i++) {
                const t = i / steps;
                const y = -s + (2 * s * t);
                const x1 = Math.sin(currentRotation + t * Math.PI * 4) * s * 0.3;
                const x2 = Math.sin(currentRotation + t * Math.PI * 4 + Math.PI) * s * 0.3;

                if (i === 0) {
                    ctx.moveTo(x1, y);
                } else {
                    ctx.lineTo(x1, y);
                }
            }
            ctx.stroke();

            ctx.beginPath();
            for (let i = 0; i < steps; i++) {
                const t = i / steps;
                const y = -s + (2 * s * t);
                const x1 = Math.sin(currentRotation + t * Math.PI * 4) * s * 0.3;
                const x2 = Math.sin(currentRotation + t * Math.PI * 4 + Math.PI) * s * 0.3;

                if (i === 0) {
                    ctx.moveTo(x2, y);
                } else {
                    ctx.lineTo(x2, y);
                }
            }
            ctx.stroke();

            // Connecting bars
            for (let i = 0; i < steps; i += 3) {
                const t = i / steps;
                const y = -s + (2 * s * t);
                const x1 = Math.sin(currentRotation + t * Math.PI * 4) * s * 0.3;
                const x2 = Math.sin(currentRotation + t * Math.PI * 4 + Math.PI) * s * 0.3;

                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();
            }
        }

        function drawAtom(size) {
            const s = size * 0.3;

            // Nucleus
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.1, 0, Math.PI * 2);
            ctx.stroke();

            // Electron orbits
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate((currentRotation + i * Math.PI / 3));
                ctx.scale(1, 0.3);
                ctx.beginPath();
                ctx.arc(0, 0, s, 0, Math.PI * 2);
                ctx.stroke();

                // Electron
                const electronAngle = currentRotation * 3;
                const ex = Math.cos(electronAngle) * s;
                const ey = Math.sin(electronAngle) * s;
                ctx.beginPath();
                ctx.arc(ex, ey, s * 0.05, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function drawHeart(size) {
            const s = size * 0.3;
            const scale = Math.sin(currentRotation * 2) * 0.1 + 1; // Pulsing effect

            ctx.save();
            ctx.scale(scale, scale);

            ctx.beginPath();
            ctx.moveTo(0, -s * 0.3);
            ctx.bezierCurveTo(-s * 0.5, -s * 0.8, -s, -s * 0.5, -s, 0);
            ctx.bezierCurveTo(-s, s * 0.3, -s * 0.5, s * 0.7, 0, s);
            ctx.bezierCurveTo(s * 0.5, s * 0.7, s, s * 0.3, s, 0);
            ctx.bezierCurveTo(s, -s * 0.5, s * 0.5, -s * 0.8, 0, -s * 0.3);
            ctx.closePath();
            ctx.stroke();
            ctx.fillStyle = ctx.strokeStyle;
            ctx.globalAlpha *= 0.3;
            ctx.fill();

            ctx.restore();
        }

        function drawStarSystem(size) {
            const s = size * 0.35;

            // Central star
            drawStar(0, 0, s * 0.15, s * 0.08, 8);

            // Orbiting planets
            for (let i = 0; i < 3; i++) {
                const orbit = s * (0.4 + i * 0.25);
                const speed = 1 - (i * 0.3);
                const angle = currentRotation * speed + (i * Math.PI * 2 / 3);
                const x = Math.cos(angle) * orbit;
                const y = Math.sin(angle) * orbit * 0.5;

                // Orbit ring
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.scale(1, 0.5);
                ctx.beginPath();
                ctx.arc(0, 0, orbit, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                // Planet
                ctx.beginPath();
                ctx.arc(x, y, s * 0.05, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawStar(cx, cy, outerRadius, innerRadius, points) {
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points - Math.PI / 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        function drawRobot(size) {
            const s = size * 0.3;
            const bounce = Math.sin(currentRotation * 4) * s * 0.05;

            // Head
            ctx.strokeRect(-s * 0.2, -s * 0.4 + bounce, s * 0.4, s * 0.3);

            // Eyes
            ctx.beginPath();
            ctx.arc(-s * 0.08, -s * 0.25 + bounce, s * 0.05, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(s * 0.08, -s * 0.25 + bounce, s * 0.05, 0, Math.PI * 2);
            ctx.stroke();

            // Body
            ctx.strokeRect(-s * 0.25, -s * 0.1 + bounce, s * 0.5, s * 0.5);

            // Arms (animated)
            const armAngle = Math.sin(currentRotation * 3) * 0.3;
            ctx.save();
            ctx.translate(-s * 0.25, -s * 0.05 + bounce);
            ctx.rotate(armAngle);
            ctx.strokeRect(-s * 0.05, 0, s * 0.1, s * 0.3);
            ctx.restore();

            ctx.save();
            ctx.translate(s * 0.25, -s * 0.05 + bounce);
            ctx.rotate(-armAngle);
            ctx.strokeRect(-s * 0.05, 0, s * 0.1, s * 0.3);
            ctx.restore();

            // Legs
            ctx.strokeRect(-s * 0.15, s * 0.4 + bounce, s * 0.1, s * 0.3);
            ctx.strokeRect(s * 0.05, s * 0.4 + bounce, s * 0.1, s * 0.3);
        }

        function drawCrystal(size) {
            const s = size * 0.35;
            const facets = 6;

            // Top point
            ctx.beginPath();
            for (let i = 0; i < facets; i++) {
                const angle = (i * Math.PI * 2) / facets + currentRotation;
                const x = Math.cos(angle) * s * 0.5;
                const y = Math.sin(angle) * s * 0.2;

                ctx.moveTo(0, -s);
                ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Middle ring
            ctx.beginPath();
            for (let i = 0; i <= facets; i++) {
                const angle = (i * Math.PI * 2) / facets + currentRotation;
                const x = Math.cos(angle) * s * 0.5;
                const y = Math.sin(angle) * s * 0.2;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Bottom point
            ctx.beginPath();
            for (let i = 0; i < facets; i++) {
                const angle = (i * Math.PI * 2) / facets + currentRotation;
                const x = Math.cos(angle) * s * 0.5;
                const y = Math.sin(angle) * s * 0.2;

                ctx.moveTo(0, s);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawFireworks(size) {
            const s = size * 0.4;
            const explosions = 5;
            const time = (currentRotation * 2) % (Math.PI * 2);

            for (let e = 0; e < explosions; e++) {
                const phase = (time + e * Math.PI * 2 / explosions) % (Math.PI * 2);
                const radius = phase < Math.PI ? phase / Math.PI * s : 0;
                const opacity = phase < Math.PI ? 1 - phase / Math.PI : 0;

                if (radius > 0) {
                    ctx.save();
                    ctx.globalAlpha *= opacity;

                    const cx = Math.cos(e * 2) * s * 0.3;
                    const cy = Math.sin(e * 2) * s * 0.3;

                    for (let i = 0; i < 16; i++) {
                        const angle = (i * Math.PI * 2) / 16;
                        const x = cx + Math.cos(angle) * radius;
                        const y = cy + Math.sin(angle) * radius;

                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }
            }
        }

        function drawGalaxy(size) {
            const s = size * 0.4;
            const arms = 3;
            const pointsPerArm = 20;

            for (let arm = 0; arm < arms; arm++) {
                ctx.beginPath();
                for (let i = 0; i < pointsPerArm; i++) {
                    const t = i / pointsPerArm;
                    const angle = (arm * Math.PI * 2 / arms) + t * Math.PI * 2 + currentRotation;
                    const radius = t * s;
                    const spiralOffset = t * Math.PI;

                    const x = Math.cos(angle + spiralOffset) * radius;
                    const y = Math.sin(angle + spiralOffset) * radius * 0.3;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);

                    // Add stars
                    if (i % 3 === 0) {
                        ctx.save();
                        ctx.globalAlpha *= (1 - t);
                        ctx.beginPath();
                        ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                ctx.stroke();
            }

            // Central core
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPyramid(size) {
            const s = size * 0.35;
            const height = s * 1.2;

            // Calculate rotation
            const cos = Math.cos(currentRotation);
            const sin = Math.sin(currentRotation);

            // Base square
            const base = [
                { x: -s * cos, y: s, z: -s * sin },
                { x: s * cos, y: s, z: -s * sin },
                { x: s * cos, y: s, z: s * sin },
                { x: -s * cos, y: s, z: s * sin }
            ];

            // Draw base
            ctx.beginPath();
            base.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.closePath();
            ctx.stroke();

            // Draw edges to apex
            base.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(0, -height);
                ctx.stroke();
            });

            // Inner glow effect
            ctx.save();
            ctx.globalAlpha *= 0.3;
            ctx.beginPath();
            ctx.moveTo(0, -height);
            ctx.lineTo(base[0].x, base[0].y);
            ctx.lineTo(base[1].x, base[1].y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Control functions
        function togglePanel() {
            const panel = document.getElementById('controlPanel');
            panel.classList.toggle('open');
        }

        function toggleRecording() {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        }

        function startRecording() {
            recordedChunks = [];
            const stream = canvas.captureStream(30);

            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 2500000
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                downloadVideo(blob);
            };

            mediaRecorder.start();
            isRecording = true;
            document.getElementById('recordBtn').classList.add('recording');
            document.getElementById('recordBtn').textContent = '‚èπÔ∏è Stop Recording';
            showNotification('üé• Recording started...', 2000);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('recordBtn').textContent = 'üé• Record';
            showNotification('üíæ Recording saved!', 2000);
        }

        function downloadVideo(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `hologram-${appData.currentModel}-${new Date().toISOString().split('T')[0]}.webm`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function showTemplate() {
            document.getElementById('templateModal').classList.add('open');
        }

        function closeModal() {
            document.getElementById('templateModal').classList.remove('open');
        }

        function downloadTemplate() {
            const svgContent = document.querySelector('.template-svg svg').outerHTML;
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hologram-pyramid-template.svg';
            a.click();
            URL.revokeObjectURL(url);
            showNotification('üìê Template downloaded!', 2000);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                showNotification('üî≥ Fullscreen mode', 1500);
            } else {
                document.exitFullscreen();
            }
        }

        function resetView() {
            appData.rotationSpeed = 50;
            appData.scale = 100;
            appData.brightness = 80;
            appData.hue = 180;
            currentRotation = 0;

            // Update UI
            document.getElementById('rotationSpeed').value = 50;
            document.getElementById('scale').value = 100;
            document.getElementById('brightness').value = 80;
            document.getElementById('hue').value = 180;

            document.getElementById('rotationValue').textContent = '50%';
            document.getElementById('scaleValue').textContent = '100%';
            document.getElementById('brightnessValue').textContent = '80%';
            document.getElementById('hueValue').textContent = 'Cyan';

            saveData();
            showNotification('üîÑ View reset!', 1500);
        }

        function toggleAutoRotate() {
            appData.autoRotate = !appData.autoRotate;
            const btn = document.getElementById('autoRotateBtn');
            btn.textContent = appData.autoRotate ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Auto Rotate';
            saveData();
            showNotification(appData.autoRotate ? '‚ñ∂Ô∏è Auto-rotation enabled' : '‚è∏Ô∏è Rotation paused', 1500);
        }

        function captureFrame() {
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hologram-${appData.currentModel}-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showNotification('üì∏ Screenshot saved!', 2000);
            });
        }

        // Data management
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function loadData() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    appData = { ...appData, ...JSON.parse(saved) };
                } catch (e) {
                    console.error('Error loading data:', e);
                }
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-settings-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('üíæ Settings exported!', 2000);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    appData = { ...appData, ...imported };
                    saveData();

                    // Update UI
                    setupControls();

                    // Update active model
                    document.querySelectorAll('.model-card').forEach(card => {
                        card.classList.toggle('active', card.dataset.model === appData.currentModel);
                    });

                    showNotification('‚úÖ Settings imported successfully!', 2000);
                } catch (error) {
                    showNotification('‚ùå Invalid settings file', 3000);
                    console.error('Import error:', error);
                }
            };
            reader.readAsText(file);

            // Clear the input
            event.target.value = '';
        }

        // Notification system
        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }

        // Initialize on load
        window.addEventListener('load', init);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (document.querySelector('.modal.open')) {
                    closeModal();
                } else if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            } else if (e.key === ' ') {
                e.preventDefault();
                toggleAutoRotate();
            } else if (e.key === 'r' && !e.metaKey && !e.ctrlKey) {
                toggleRecording();
            } else if (e.key === 'f') {
                toggleFullscreen();
            } else if (e.key === 'c') {
                captureFrame();
            } else if (e.key === 'p') {
                togglePanel();
            }
        });

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!e.touches[0]) return;

            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;

            // Manual rotation control
            currentRotation += deltaX * 0.01;

            // Scale control
            const newScale = Math.max(10, Math.min(200, appData.scale - deltaY * 0.5));
            appData.scale = newScale;
            document.getElementById('scale').value = newScale;
            document.getElementById('scaleValue').textContent = Math.round(newScale) + '%';

            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;

            saveData();
        });
    </script>
</body>
</html>