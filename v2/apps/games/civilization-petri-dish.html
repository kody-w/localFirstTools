<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civilization Petri Dish - Emergent Civilization Simulator</title>
    <meta name="description" content="Watch civilizations emerge from 5 simple rules. Trade routes, city-states, wars, and cultures develop spontaneously with no scripted events.">
    <!-- Tags: simulation, emergence, agents, civilization, canvas, animation -->
    <style>
        /* ========== CSS Reset & Variables ========== */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-void: #050508;
            --bg-panel: #0a0a12;
            --bg-panel-hover: #12121a;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --accent: #7c3aed;
            --accent-glow: rgba(124, 58, 237, 0.5);
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-void);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* ========== Layout ========== */
        .app-container {
            display: flex;
            height: 100vh;
        }

        .main-view {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #worldCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
        }

        #worldCanvas:active {
            cursor: grabbing;
        }

        /* ========== Control Panels ========== */
        .control-panel {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .top-controls {
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .left-panel {
            top: 80px;
            left: 16px;
            width: 260px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .right-panel {
            top: 80px;
            right: 16px;
            width: 300px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .bottom-controls {
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        /* ========== Title & Time Display ========== */
        .title-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .title-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent), #ec4899);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .title-text h1 {
            font-size: 16px;
            font-weight: 700;
            background: linear-gradient(135deg, #fff, var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title-text .subtitle {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .time-display {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            text-align: center;
        }

        .time-display .year {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
        }

        .time-display .label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stats-row {
            display: flex;
            gap: 16px;
            font-size: 12px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-item .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* ========== Panel Sections ========== */
        .panel-section {
            margin-bottom: 16px;
        }

        .panel-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* ========== Buttons ========== */
        .btn {
            background: var(--bg-panel-hover);
            border: 1px solid rgba(255,255,255,0.15);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.25);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: #8b5cf6;
            border-color: #8b5cf6;
        }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
        }

        .btn-warning {
            background: var(--warning);
            border-color: var(--warning);
            color: #000;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
        }

        .btn-icon {
            padding: 10px 12px;
        }

        .btn-group {
            display: flex;
            gap: 4px;
        }

        /* ========== Sliders ========== */
        .slider-group {
            margin-bottom: 12px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .slider-header label {
            color: var(--text-secondary);
        }

        .slider-header .value {
            color: var(--accent);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }

        /* ========== Toggles ========== */
        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toggle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }

        .toggle-item label {
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 22px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--accent);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        /* ========== Stats Display ========== */
        .stat-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .stat-card .stat-title {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card .stat-value {
            font-size: 24px;
            font-weight: 700;
            margin: 4px 0;
        }

        .stat-card .stat-change {
            font-size: 11px;
        }

        .stat-change.positive { color: var(--success); }
        .stat-change.negative { color: var(--danger); }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-mini {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .stat-mini .value {
            font-size: 18px;
            font-weight: 700;
        }

        .stat-mini .label {
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* ========== Mini Graph ========== */
        .mini-graph {
            height: 60px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .mini-graph canvas {
            width: 100%;
            height: 100%;
        }

        /* ========== Culture List ========== */
        .culture-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .culture-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            margin-bottom: 4px;
        }

        .culture-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .culture-info {
            flex: 1;
        }

        .culture-name {
            font-size: 12px;
            font-weight: 600;
        }

        .culture-pop {
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* ========== Event Log ========== */
        .event-log {
            max-height: 150px;
            overflow-y: auto;
            font-size: 11px;
        }

        .event-item {
            padding: 6px 8px;
            border-left: 3px solid var(--accent);
            margin-bottom: 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 0 4px 4px 0;
        }

        .event-item.war { border-color: var(--danger); }
        .event-item.trade { border-color: var(--success); }
        .event-item.city { border-color: var(--info); }
        .event-item.alliance { border-color: var(--warning); }

        .event-time {
            color: var(--text-secondary);
            font-size: 10px;
        }

        /* ========== Data Controls ========== */
        .data-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .data-controls .btn {
            flex: 1;
            justify-content: center;
            font-size: 11px;
            padding: 8px;
        }

        #importFile {
            display: none;
        }

        /* ========== Overlay Info ========== */
        .overlay-info {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 12px;
            display: none;
            z-index: 100;
        }

        .overlay-info.visible {
            display: block;
        }

        /* ========== Zoom Controls ========== */
        .zoom-controls {
            position: fixed;
            bottom: 80px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .zoom-controls .btn {
            width: 40px;
            height: 40px;
            padding: 0;
            justify-content: center;
            font-size: 18px;
        }

        /* ========== Instructions Modal ========== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            font-size: 24px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #fff, var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal p {
            color: var(--text-secondary);
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .modal h3 {
            font-size: 14px;
            margin: 20px 0 10px;
            color: var(--accent);
        }

        .modal ul {
            list-style: none;
            padding: 0;
        }

        .modal li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .modal li:before {
            content: "";
            position: absolute;
            left: 0;
            top: 14px;
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
        }

        .modal .btn-close {
            margin-top: 24px;
            width: 100%;
            justify-content: center;
        }

        /* ========== Loading State ========== */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* ========== Responsive ========== */
        @media (max-width: 1024px) {
            .left-panel {
                width: 220px;
            }
            .right-panel {
                width: 240px;
            }
        }

        @media (max-width: 768px) {
            .left-panel, .right-panel {
                display: none;
            }

            .top-controls {
                flex-wrap: wrap;
                padding: 8px;
            }

            .mobile-toggle {
                display: flex;
            }

            .left-panel.mobile-open,
            .right-panel.mobile-open {
                display: block;
                position: fixed;
                top: 0;
                bottom: 0;
                width: 280px;
                z-index: 500;
                border-radius: 0;
            }

            .left-panel.mobile-open {
                left: 0;
            }

            .right-panel.mobile-open {
                right: 0;
            }
        }

        /* ========== Scrollbar ========== */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Universe...</div>
    </div>

    <!-- Instructions Modal -->
    <div class="modal-overlay" id="instructionsModal">
        <div class="modal">
            <h2>Welcome to Civilization Petri Dish</h2>
            <p>Watch civilizations emerge from chaos. Hundreds of agents follow only 5 simple rules, yet complex societies spontaneously form - trade routes, city-states, wars, and distinct cultures.</p>

            <h3>The 5 Rules of Life</h3>
            <ul>
                <li><strong>Seek Food</strong> - Agents move toward food sources and consume to gain energy</li>
                <li><strong>Avoid Danger</strong> - Flee from aggressive agents and resource scarcity</li>
                <li><strong>Reproduce</strong> - Create offspring with slight color/trait mutations when energy is high</li>
                <li><strong>Trade</strong> - Exchange resources with nearby agents when mutually beneficial</li>
                <li><strong>Communicate</strong> - Share information about food and threats with neighbors</li>
            </ul>

            <h3>What Emerges</h3>
            <ul>
                <li><strong>Cities</strong> - Population clusters form naturally around resources</li>
                <li><strong>Trade Routes</strong> - Visible paths where frequent trading occurs</li>
                <li><strong>Cultures</strong> - Color clusters as offspring inherit (with mutation) from parents</li>
                <li><strong>Conflicts</strong> - Resource competition leads to territorial behavior</li>
            </ul>

            <h3>Controls</h3>
            <ul>
                <li><strong>Pan</strong> - Click and drag to move around the world</li>
                <li><strong>Zoom</strong> - Scroll wheel or pinch to zoom in/out</li>
                <li><strong>Speed</strong> - Adjust simulation speed from 1x to 1000x</li>
                <li><strong>Overlays</strong> - Toggle visualizations for trade, culture, and density</li>
            </ul>

            <button class="btn btn-primary btn-close" onclick="closeInstructions()">Begin Simulation</button>
        </div>
    </div>

    <div class="app-container">
        <!-- Main Canvas -->
        <div class="main-view">
            <canvas id="worldCanvas"></canvas>
        </div>

        <!-- Top Controls -->
        <div class="control-panel top-controls">
            <div class="title-section">
                <div class="title-icon">&#127758;</div>
                <div class="title-text">
                    <h1>Civilization Petri Dish</h1>
                    <div class="subtitle">Emergent Civilization Simulator</div>
                </div>
            </div>

            <div class="time-display">
                <div class="label">Simulated Year</div>
                <div class="year" id="yearDisplay">0</div>
            </div>

            <div class="stats-row">
                <div class="stat-item">
                    <div class="dot" style="background: var(--success);"></div>
                    <span id="popDisplay">0</span> agents
                </div>
                <div class="stat-item">
                    <div class="dot" style="background: var(--info);"></div>
                    <span id="genDisplay">0</span> generations
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-icon" id="playPauseBtn" onclick="togglePlay()" title="Play/Pause">
                    <span id="playIcon">&#9658;</span>
                </button>
                <button class="btn btn-icon" onclick="stepSimulation()" title="Step">&#9197;</button>
                <button class="btn btn-icon" onclick="resetSimulation()" title="Reset">&#8634;</button>
            </div>

            <button class="btn btn-warning" onclick="fastForwardToInteresting()" title="Skip to when interesting structures form">
                &#9889; Fast Forward
            </button>

            <button class="btn" onclick="showInstructions()">?</button>
        </div>

        <!-- Left Panel - Controls -->
        <div class="control-panel left-panel" id="leftPanel">
            <div class="panel-section">
                <h3>Simulation Speed</h3>
                <div class="slider-group">
                    <div class="slider-header">
                        <label>Speed</label>
                        <span class="value" id="speedValue">1x</span>
                    </div>
                    <input type="range" id="speedSlider" min="0" max="100" value="20" oninput="updateSpeed()">
                </div>
            </div>

            <div class="panel-section">
                <h3>World Settings</h3>
                <div class="slider-group">
                    <div class="slider-header">
                        <label>Food Abundance</label>
                        <span class="value" id="foodValue">50%</span>
                    </div>
                    <input type="range" id="foodSlider" min="10" max="100" value="50" oninput="updateFoodRate()">
                </div>
                <div class="slider-group">
                    <div class="slider-header">
                        <label>Mutation Rate</label>
                        <span class="value" id="mutationValue">5%</span>
                    </div>
                    <input type="range" id="mutationSlider" min="1" max="20" value="5" oninput="updateMutationRate()">
                </div>
                <div class="slider-group">
                    <div class="slider-header">
                        <label>Trade Willingness</label>
                        <span class="value" id="tradeValue">70%</span>
                    </div>
                    <input type="range" id="tradeSlider" min="10" max="100" value="70" oninput="updateTradeWillingness()">
                </div>
            </div>

            <div class="panel-section">
                <h3>Overlays</h3>
                <div class="toggle-group">
                    <div class="toggle-item">
                        <label>Trade Routes</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="tradeOverlay" onchange="toggleOverlay('trade')">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="toggle-item">
                        <label>Culture Borders</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="cultureOverlay" onchange="toggleOverlay('culture')">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="toggle-item">
                        <label>Population Heat</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="heatOverlay" onchange="toggleOverlay('heat')">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="toggle-item">
                        <label>Agent Trails</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="trailsOverlay" checked onchange="toggleOverlay('trails')">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="toggle-item">
                        <label>Communication</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="commOverlay" onchange="toggleOverlay('comm')">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>Data Management</h3>
                <div class="data-controls">
                    <button class="btn" onclick="exportData()">Export</button>
                    <button class="btn" onclick="document.getElementById('importFile').click()">Import</button>
                    <input type="file" id="importFile" accept=".json" onchange="importData(event)">
                </div>
            </div>
        </div>

        <!-- Right Panel - Statistics -->
        <div class="control-panel right-panel" id="rightPanel">
            <div class="panel-section">
                <h3>Population</h3>
                <div class="stat-card">
                    <div class="stat-title">Total Agents</div>
                    <div class="stat-value" id="totalPop">0</div>
                    <div class="stat-change positive" id="popChange">+0 this century</div>
                </div>
                <div class="mini-graph">
                    <canvas id="popGraph"></canvas>
                </div>
            </div>

            <div class="panel-section">
                <h3>Statistics</h3>
                <div class="stat-grid">
                    <div class="stat-mini">
                        <div class="value" id="cityStat">0</div>
                        <div class="label">Cities</div>
                    </div>
                    <div class="stat-mini">
                        <div class="value" id="cultureStat">0</div>
                        <div class="label">Cultures</div>
                    </div>
                    <div class="stat-mini">
                        <div class="value" id="tradeStat">0</div>
                        <div class="label">Trades/min</div>
                    </div>
                    <div class="stat-mini">
                        <div class="value" id="conflictStat">0</div>
                        <div class="label">Conflicts</div>
                    </div>
                    <div class="stat-mini">
                        <div class="value" id="avgLifeStat">0</div>
                        <div class="label">Avg Life</div>
                    </div>
                    <div class="stat-mini">
                        <div class="value" id="foodStat">0</div>
                        <div class="label">Food Sources</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>Cultures</h3>
                <div class="culture-list" id="cultureList">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <div class="panel-section">
                <h3>Recent Events</h3>
                <div class="event-log" id="eventLog">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="control-panel bottom-controls">
            <button class="btn" onclick="addAgents(50)">+ 50 Agents</button>
            <button class="btn" onclick="addFood(20)">+ 20 Food</button>
            <button class="btn btn-danger" onclick="triggerCataclysm()">&#9889; Cataclysm</button>
        </div>

        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <button class="btn" onclick="zoomIn()">+</button>
            <button class="btn" onclick="zoomOut()">-</button>
            <button class="btn" onclick="resetView()">&#8962;</button>
        </div>

        <!-- Overlay Info -->
        <div class="overlay-info" id="overlayInfo"></div>
    </div>

    <script>
        // ========== CONSTANTS ==========
        const APP_NAME = 'civilization-petri-dish';
        const WORLD_WIDTH = 2000;
        const WORLD_HEIGHT = 2000;
        const INITIAL_AGENTS = 100;
        const INITIAL_FOOD = 150;
        const SPATIAL_GRID_SIZE = 50;
        const MAX_AGENTS = 800;
        const MIN_AGENTS = 20;

        // ========== STATE ==========
        let canvas, ctx;
        let popCanvas, popCtx;
        let agents = [];
        let food = [];
        let tradeRoutes = [];
        let spatialGrid = {};
        let isPlaying = false;
        let lastTime = 0;
        let accumulator = 0;
        let simulationYear = 0;
        let generation = 0;
        let totalBirths = 0;
        let totalDeaths = 0;
        let tradeCount = 0;
        let conflictCount = 0;
        let lastCenturyPop = 0;
        let popHistory = [];
        let eventLog = [];
        let cities = [];

        // Settings
        let settings = {
            speed: 1,
            foodAbundance: 50,
            mutationRate: 5,
            tradeWillingness: 70
        };

        // Overlays
        let overlays = {
            trade: false,
            culture: false,
            heat: false,
            trails: true,
            comm: false
        };

        // View
        let view = {
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            zoom: 0.5,
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0
        };

        // ========== AGENT CLASS ==========
        class Agent {
            constructor(x, y, color = null, parentTraits = null) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.energy = 50 + Math.random() * 30;
                this.maxEnergy = 100;
                this.age = 0;
                this.generation = generation;

                // Color inheritance with mutation
                if (color) {
                    this.color = this.mutateColor(color);
                } else {
                    this.color = {
                        h: Math.random() * 360,
                        s: 60 + Math.random() * 30,
                        l: 50 + Math.random() * 20
                    };
                }

                // Traits (inherited with mutation)
                if (parentTraits) {
                    this.traits = {
                        speed: this.mutateValue(parentTraits.speed, 0.5, 2),
                        vision: this.mutateValue(parentTraits.vision, 30, 150),
                        aggression: this.mutateValue(parentTraits.aggression, 0, 1),
                        sociability: this.mutateValue(parentTraits.sociability, 0, 1),
                        resourcefulness: this.mutateValue(parentTraits.resourcefulness, 0.5, 1.5)
                    };
                } else {
                    this.traits = {
                        speed: 0.8 + Math.random() * 0.4,
                        vision: 50 + Math.random() * 50,
                        aggression: Math.random() * 0.5,
                        sociability: 0.3 + Math.random() * 0.5,
                        resourcefulness: 0.8 + Math.random() * 0.4
                    };
                }

                // Knowledge (shared through communication)
                this.knownFood = [];
                this.knownThreats = [];
                this.tradePartners = new Set();

                // Trail for visualization
                this.trail = [];
                this.maxTrailLength = 20;

                // Statistics
                this.tradesCompleted = 0;
                this.childrenBorn = 0;
                this.resourcesCollected = 0;
            }

            mutateColor(parentColor) {
                const mutationStrength = settings.mutationRate / 100 * 30;
                return {
                    h: (parentColor.h + (Math.random() - 0.5) * mutationStrength + 360) % 360,
                    s: Math.max(30, Math.min(100, parentColor.s + (Math.random() - 0.5) * mutationStrength)),
                    l: Math.max(30, Math.min(80, parentColor.l + (Math.random() - 0.5) * mutationStrength * 0.5))
                };
            }

            mutateValue(value, min, max) {
                const mutation = (Math.random() - 0.5) * (settings.mutationRate / 100) * (max - min) * 0.2;
                return Math.max(min, Math.min(max, value + mutation));
            }

            getColorString(alpha = 1) {
                return `hsla(${this.color.h}, ${this.color.s}%, ${this.color.l}%, ${alpha})`;
            }

            update(dt) {
                // Age and energy decay
                this.age += dt;
                this.energy -= dt * 0.1 * (1 + this.traits.speed * 0.5);

                // Update trail
                if (overlays.trails && this.trail.length < this.maxTrailLength) {
                    this.trail.push({ x: this.x, y: this.y });
                } else if (overlays.trails) {
                    this.trail.shift();
                    this.trail.push({ x: this.x, y: this.y });
                }

                // Get nearby entities
                const neighbors = this.getNeighbors();
                const nearbyFood = this.getNearbyFood();

                // Rule 1: Seek Food
                this.seekFood(nearbyFood, dt);

                // Rule 2: Avoid Danger
                this.avoidDanger(neighbors, dt);

                // Rule 3: Reproduce
                if (this.energy > 70 && agents.length < MAX_AGENTS) {
                    this.reproduce();
                }

                // Rule 4: Trade
                this.attemptTrade(neighbors);

                // Rule 5: Communicate
                this.communicate(neighbors);

                // Apply velocity
                this.x += this.vx * this.traits.speed * dt;
                this.y += this.vy * this.traits.speed * dt;

                // World boundaries (wrap around)
                if (this.x < 0) this.x += WORLD_WIDTH;
                if (this.x >= WORLD_WIDTH) this.x -= WORLD_WIDTH;
                if (this.y < 0) this.y += WORLD_HEIGHT;
                if (this.y >= WORLD_HEIGHT) this.y -= WORLD_HEIGHT;

                // Decay velocity
                this.vx *= 0.95;
                this.vy *= 0.95;

                // Clean up old knowledge
                this.knownFood = this.knownFood.filter(f => food.some(ff => ff.id === f.id));

                return this.energy > 0 && this.age < 500 + Math.random() * 200;
            }

            getNeighbors() {
                const gridX = Math.floor(this.x / SPATIAL_GRID_SIZE);
                const gridY = Math.floor(this.y / SPATIAL_GRID_SIZE);
                const neighbors = [];

                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const key = `${(gridX + dx + Math.ceil(WORLD_WIDTH / SPATIAL_GRID_SIZE)) % Math.ceil(WORLD_WIDTH / SPATIAL_GRID_SIZE)},${(gridY + dy + Math.ceil(WORLD_HEIGHT / SPATIAL_GRID_SIZE)) % Math.ceil(WORLD_HEIGHT / SPATIAL_GRID_SIZE)}`;
                        if (spatialGrid[key]) {
                            for (const agent of spatialGrid[key]) {
                                if (agent.id !== this.id) {
                                    const dx = agent.x - this.x;
                                    const dy = agent.y - this.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < this.traits.vision) {
                                        neighbors.push({ agent, dist, dx, dy });
                                    }
                                }
                            }
                        }
                    }
                }

                return neighbors;
            }

            getNearbyFood() {
                const nearby = [];
                for (const f of food) {
                    const dx = f.x - this.x;
                    const dy = f.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < this.traits.vision * 1.5) {
                        nearby.push({ food: f, dist, dx, dy });
                    }
                }
                // Also check known food locations
                for (const kf of this.knownFood) {
                    if (!nearby.some(n => n.food.id === kf.id)) {
                        const f = food.find(ff => ff.id === kf.id);
                        if (f) {
                            const dx = f.x - this.x;
                            const dy = f.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            nearby.push({ food: f, dist, dx, dy });
                        }
                    }
                }
                return nearby;
            }

            seekFood(nearbyFood, dt) {
                if (nearbyFood.length === 0) {
                    // Random exploration
                    this.vx += (Math.random() - 0.5) * 0.5;
                    this.vy += (Math.random() - 0.5) * 0.5;
                    return;
                }

                // Sort by distance and go to nearest
                nearbyFood.sort((a, b) => a.dist - b.dist);
                const target = nearbyFood[0];

                // Move toward food
                const strength = this.energy < 30 ? 2 : 1;
                this.vx += (target.dx / target.dist) * strength * dt * 10;
                this.vy += (target.dy / target.dist) * strength * dt * 10;

                // Consume food if close enough
                if (target.dist < 10) {
                    const energyGain = target.food.energy * this.traits.resourcefulness;
                    this.energy = Math.min(this.maxEnergy, this.energy + energyGain);
                    this.resourcesCollected += energyGain;

                    // Remove food
                    const idx = food.indexOf(target.food);
                    if (idx > -1) {
                        food.splice(idx, 1);
                    }
                }
            }

            avoidDanger(neighbors, dt) {
                for (const n of neighbors) {
                    // Avoid aggressive neighbors
                    if (n.agent.traits.aggression > 0.6 && n.agent.energy > this.energy) {
                        const fleeStrength = (1 - n.dist / this.traits.vision) * 2;
                        this.vx -= (n.dx / n.dist) * fleeStrength * dt * 10;
                        this.vy -= (n.dy / n.dist) * fleeStrength * dt * 10;

                        // Record as threat
                        if (!this.knownThreats.includes(n.agent.id)) {
                            this.knownThreats.push(n.agent.id);
                            if (this.knownThreats.length > 10) this.knownThreats.shift();
                        }
                    }

                    // Conflict when both aggressive and close
                    if (n.dist < 15 && this.traits.aggression > 0.5 && n.agent.traits.aggression > 0.5) {
                        // Energy-based conflict resolution
                        if (this.energy > n.agent.energy) {
                            n.agent.energy -= 10;
                            this.energy += 5;
                            conflictCount++;
                        } else {
                            this.energy -= 10;
                            n.agent.energy += 5;
                        }
                    }
                }
            }

            reproduce() {
                if (Math.random() > 0.01) return; // Low chance per frame

                const child = new Agent(
                    this.x + (Math.random() - 0.5) * 20,
                    this.y + (Math.random() - 0.5) * 20,
                    this.color,
                    this.traits
                );

                this.energy -= 30;
                child.energy = 40;
                child.generation = generation + 1;

                agents.push(child);
                totalBirths++;
                this.childrenBorn++;

                if (child.generation > generation) {
                    generation = child.generation;
                }
            }

            attemptTrade(neighbors) {
                if (Math.random() > settings.tradeWillingness / 100 * 0.1) return;

                for (const n of neighbors) {
                    if (n.dist > 30) continue;
                    if (this.tradePartners.has(n.agent.id)) continue;

                    // Trade if both benefit (different resource levels)
                    const myResource = this.resourcesCollected;
                    const theirResource = n.agent.resourcesCollected;

                    // Sociability affects trade willingness
                    const tradeChance = (this.traits.sociability + n.agent.traits.sociability) / 2;

                    if (Math.random() < tradeChance) {
                        // Exchange some energy
                        const exchange = Math.min(5, Math.abs(this.energy - n.agent.energy) * 0.2);
                        if (this.energy > n.agent.energy) {
                            this.energy -= exchange;
                            n.agent.energy += exchange * 0.9;
                        } else {
                            n.agent.energy -= exchange;
                            this.energy += exchange * 0.9;
                        }

                        // Record trade
                        this.tradePartners.add(n.agent.id);
                        n.agent.tradePartners.add(this.id);
                        this.tradesCompleted++;
                        n.agent.tradesCompleted++;
                        tradeCount++;

                        // Add to trade routes visualization
                        tradeRoutes.push({
                            x1: this.x,
                            y1: this.y,
                            x2: n.agent.x,
                            y2: n.agent.y,
                            alpha: 0.5,
                            color: this.getColorString(0.3)
                        });
                    }
                }
            }

            communicate(neighbors) {
                for (const n of neighbors) {
                    if (n.dist > 40) continue;
                    if (Math.random() > this.traits.sociability * 0.5) continue;

                    // Share food knowledge
                    for (const kf of this.knownFood) {
                        if (!n.agent.knownFood.some(f => f.id === kf.id)) {
                            n.agent.knownFood.push(kf);
                            if (n.agent.knownFood.length > 5) n.agent.knownFood.shift();
                        }
                    }

                    // Share threat knowledge
                    for (const kt of this.knownThreats) {
                        if (!n.agent.knownThreats.includes(kt)) {
                            n.agent.knownThreats.push(kt);
                            if (n.agent.knownThreats.length > 5) n.agent.knownThreats.shift();
                        }
                    }
                }
            }
        }

        // ========== FOOD CLASS ==========
        class Food {
            constructor(x, y) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.energy = 20 + Math.random() * 30;
                this.regenerateTime = 0;
            }
        }

        // ========== INITIALIZATION ==========
        function init() {
            canvas = document.getElementById('worldCanvas');
            ctx = canvas.getContext('2d');

            popCanvas = document.getElementById('popGraph');
            popCtx = popCanvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Mouse/touch events for panning and zooming
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);

            // Load saved data or initialize new simulation
            loadData();

            if (agents.length === 0) {
                initializeWorld();
            }

            // Hide loading overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').classList.add('hidden');
                // Show instructions on first visit
                if (!localStorage.getItem(APP_NAME + '-visited')) {
                    showInstructions();
                    localStorage.setItem(APP_NAME + '-visited', 'true');
                }
            }, 500);

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            popCanvas.width = popCanvas.parentElement.clientWidth;
            popCanvas.height = 60;
        }

        function initializeWorld() {
            agents = [];
            food = [];
            tradeRoutes = [];
            simulationYear = 0;
            generation = 0;
            totalBirths = 0;
            totalDeaths = 0;
            tradeCount = 0;
            conflictCount = 0;
            popHistory = [];
            eventLog = [];
            cities = [];

            // Create initial agents in clusters
            const clusterCount = 5;
            for (let c = 0; c < clusterCount; c++) {
                const cx = Math.random() * WORLD_WIDTH;
                const cy = Math.random() * WORLD_HEIGHT;
                const baseColor = {
                    h: (c * 72) % 360,
                    s: 70,
                    l: 55
                };

                for (let i = 0; i < INITIAL_AGENTS / clusterCount; i++) {
                    agents.push(new Agent(
                        cx + (Math.random() - 0.5) * 200,
                        cy + (Math.random() - 0.5) * 200,
                        baseColor
                    ));
                }
            }

            // Create initial food
            for (let i = 0; i < INITIAL_FOOD; i++) {
                food.push(new Food(
                    Math.random() * WORLD_WIDTH,
                    Math.random() * WORLD_HEIGHT
                ));
            }

            lastCenturyPop = agents.length;
        }

        // ========== GAME LOOP ==========
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            if (isPlaying) {
                accumulator += dt * settings.speed;

                while (accumulator >= 0.016) {
                    updateSimulation(0.016);
                    accumulator -= 0.016;
                }
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        function updateSimulation(dt) {
            // Update spatial grid
            updateSpatialGrid();

            // Update agents
            const survivingAgents = [];
            for (const agent of agents) {
                if (agent.update(dt)) {
                    survivingAgents.push(agent);
                } else {
                    totalDeaths++;
                }
            }
            agents = survivingAgents;

            // Spawn food
            if (Math.random() < settings.foodAbundance / 100 * 0.1 && food.length < 300) {
                food.push(new Food(
                    Math.random() * WORLD_WIDTH,
                    Math.random() * WORLD_HEIGHT
                ));
            }

            // Maintain minimum population
            if (agents.length < MIN_AGENTS && food.length > 10) {
                const randomFood = food[Math.floor(Math.random() * food.length)];
                agents.push(new Agent(randomFood.x, randomFood.y));
            }

            // Decay trade routes
            tradeRoutes = tradeRoutes.filter(t => {
                t.alpha -= 0.01;
                return t.alpha > 0;
            });

            // Update time
            simulationYear += dt * 10;

            // Update statistics periodically
            if (Math.floor(simulationYear) % 100 === 0 && Math.floor(simulationYear) !== Math.floor(simulationYear - dt * 10)) {
                updateStatistics();
            }

            // Detect and log interesting events
            detectEvents();
        }

        function updateSpatialGrid() {
            spatialGrid = {};
            for (const agent of agents) {
                const gridX = Math.floor(agent.x / SPATIAL_GRID_SIZE);
                const gridY = Math.floor(agent.y / SPATIAL_GRID_SIZE);
                const key = `${gridX},${gridY}`;
                if (!spatialGrid[key]) spatialGrid[key] = [];
                spatialGrid[key].push(agent);
            }
        }

        function updateStatistics() {
            // Record population history
            popHistory.push(agents.length);
            if (popHistory.length > 100) popHistory.shift();

            // Detect cities (clusters of agents)
            detectCities();

            // Detect cultures (color clusters)
            const cultures = detectCultures();

            // Update UI
            document.getElementById('yearDisplay').textContent = Math.floor(simulationYear).toLocaleString();
            document.getElementById('popDisplay').textContent = agents.length;
            document.getElementById('genDisplay').textContent = generation;
            document.getElementById('totalPop').textContent = agents.length;

            const popChange = agents.length - lastCenturyPop;
            const popChangeEl = document.getElementById('popChange');
            popChangeEl.textContent = `${popChange >= 0 ? '+' : ''}${popChange} this century`;
            popChangeEl.className = 'stat-change ' + (popChange >= 0 ? 'positive' : 'negative');
            lastCenturyPop = agents.length;

            document.getElementById('cityStat').textContent = cities.length;
            document.getElementById('cultureStat').textContent = cultures.length;
            document.getElementById('tradeStat').textContent = Math.round(tradeCount / Math.max(1, simulationYear / 60));
            document.getElementById('conflictStat').textContent = conflictCount;
            document.getElementById('avgLifeStat').textContent = Math.round(agents.reduce((sum, a) => sum + a.age, 0) / Math.max(1, agents.length));
            document.getElementById('foodStat').textContent = food.length;

            // Update culture list
            updateCultureList(cultures);

            // Draw population graph
            drawPopGraph();

            // Save data periodically
            if (Math.floor(simulationYear) % 500 === 0) {
                saveData();
            }
        }

        function detectCities() {
            cities = [];
            const visited = new Set();

            for (const agent of agents) {
                if (visited.has(agent.id)) continue;

                // Find cluster around this agent
                const cluster = [agent];
                visited.add(agent.id);

                const stack = [agent];
                while (stack.length > 0) {
                    const current = stack.pop();
                    const gridX = Math.floor(current.x / SPATIAL_GRID_SIZE);
                    const gridY = Math.floor(current.y / SPATIAL_GRID_SIZE);

                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const key = `${gridX + dx},${gridY + dy}`;
                            if (spatialGrid[key]) {
                                for (const neighbor of spatialGrid[key]) {
                                    if (!visited.has(neighbor.id)) {
                                        const dist = Math.sqrt(
                                            Math.pow(neighbor.x - current.x, 2) +
                                            Math.pow(neighbor.y - current.y, 2)
                                        );
                                        if (dist < 50) {
                                            visited.add(neighbor.id);
                                            cluster.push(neighbor);
                                            stack.push(neighbor);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // If cluster is large enough, it's a city
                if (cluster.length >= 10) {
                    const cx = cluster.reduce((sum, a) => sum + a.x, 0) / cluster.length;
                    const cy = cluster.reduce((sum, a) => sum + a.y, 0) / cluster.length;
                    cities.push({
                        x: cx,
                        y: cy,
                        population: cluster.length,
                        agents: cluster
                    });
                }
            }
        }

        function detectCultures() {
            const cultures = [];
            const hueBuckets = {};

            for (const agent of agents) {
                const bucket = Math.floor(agent.color.h / 30);
                if (!hueBuckets[bucket]) {
                    hueBuckets[bucket] = {
                        agents: [],
                        totalH: 0,
                        totalS: 0,
                        totalL: 0
                    };
                }
                hueBuckets[bucket].agents.push(agent);
                hueBuckets[bucket].totalH += agent.color.h;
                hueBuckets[bucket].totalS += agent.color.s;
                hueBuckets[bucket].totalL += agent.color.l;
            }

            for (const bucket in hueBuckets) {
                const b = hueBuckets[bucket];
                if (b.agents.length >= 5) {
                    cultures.push({
                        color: {
                            h: b.totalH / b.agents.length,
                            s: b.totalS / b.agents.length,
                            l: b.totalL / b.agents.length
                        },
                        population: b.agents.length,
                        agents: b.agents
                    });
                }
            }

            return cultures.sort((a, b) => b.population - a.population);
        }

        function updateCultureList(cultures) {
            const list = document.getElementById('cultureList');
            list.innerHTML = '';

            const cultureNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa'];

            cultures.slice(0, 10).forEach((culture, i) => {
                const div = document.createElement('div');
                div.className = 'culture-item';
                div.innerHTML = `
                    <div class="culture-color" style="background: hsl(${culture.color.h}, ${culture.color.s}%, ${culture.color.l}%)"></div>
                    <div class="culture-info">
                        <div class="culture-name">${cultureNames[i] || 'Minor'} Culture</div>
                        <div class="culture-pop">${culture.population} agents (${Math.round(culture.population / agents.length * 100)}%)</div>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function detectEvents() {
            // City formation
            for (const city of cities) {
                if (city.population >= 20 && !city.announced) {
                    addEvent('city', `City formed with ${city.population} inhabitants`);
                    city.announced = true;
                }
            }

            // Large trade
            if (tradeCount > 0 && tradeCount % 100 === 0) {
                addEvent('trade', `Trade milestone: ${tradeCount} total trades`);
            }

            // Major conflict
            if (conflictCount > 0 && conflictCount % 50 === 0) {
                addEvent('war', `Conflict escalation: ${conflictCount} total conflicts`);
            }
        }

        function addEvent(type, message) {
            const event = {
                type,
                message,
                year: Math.floor(simulationYear)
            };
            eventLog.unshift(event);
            if (eventLog.length > 20) eventLog.pop();

            // Update UI
            const logEl = document.getElementById('eventLog');
            const div = document.createElement('div');
            div.className = `event-item ${type}`;
            div.innerHTML = `
                <span class="event-time">Year ${event.year}</span>
                ${event.message}
            `;
            logEl.insertBefore(div, logEl.firstChild);
            if (logEl.children.length > 10) {
                logEl.removeChild(logEl.lastChild);
            }
        }

        function drawPopGraph() {
            if (!popCtx) return;

            popCtx.fillStyle = 'rgba(0,0,0,0.3)';
            popCtx.fillRect(0, 0, popCanvas.width, popCanvas.height);

            if (popHistory.length < 2) return;

            const max = Math.max(...popHistory, 100);
            const min = Math.min(...popHistory, 0);
            const range = max - min || 1;

            popCtx.strokeStyle = '#7c3aed';
            popCtx.lineWidth = 2;
            popCtx.beginPath();

            popHistory.forEach((pop, i) => {
                const x = (i / (popHistory.length - 1)) * popCanvas.width;
                const y = popCanvas.height - ((pop - min) / range) * (popCanvas.height - 10) - 5;

                if (i === 0) {
                    popCtx.moveTo(x, y);
                } else {
                    popCtx.lineTo(x, y);
                }
            });

            popCtx.stroke();

            // Fill underneath
            popCtx.lineTo(popCanvas.width, popCanvas.height);
            popCtx.lineTo(0, popCanvas.height);
            popCtx.closePath();
            popCtx.fillStyle = 'rgba(124, 58, 237, 0.2)';
            popCtx.fill();
        }

        // ========== RENDERING ==========
        function render() {
            // Clear canvas
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply view transformation
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(view.zoom, view.zoom);
            ctx.translate(-view.x, -view.y);

            // Draw world boundary
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 2 / view.zoom;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1 / view.zoom;
            const gridSize = 100;
            for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, WORLD_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(WORLD_WIDTH, y);
                ctx.stroke();
            }

            // Draw overlays
            if (overlays.heat) drawHeatMap();
            if (overlays.culture) drawCultureBorders();
            if (overlays.trade) drawTradeRoutes();

            // Draw food
            for (const f of food) {
                ctx.beginPath();
                ctx.arc(f.x, f.y, 4 + f.energy / 20, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(34, 197, 94, ${0.3 + f.energy / 100})`;
                ctx.fill();
            }

            // Draw agent trails
            if (overlays.trails) {
                for (const agent of agents) {
                    if (agent.trail.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(agent.trail[0].x, agent.trail[0].y);
                        for (let i = 1; i < agent.trail.length; i++) {
                            ctx.lineTo(agent.trail[i].x, agent.trail[i].y);
                        }
                        ctx.strokeStyle = agent.getColorString(0.2);
                        ctx.lineWidth = 1 / view.zoom;
                        ctx.stroke();
                    }
                }
            }

            // Draw communication lines
            if (overlays.comm) {
                for (const agent of agents) {
                    if (agent.traits.sociability > 0.6) {
                        const neighbors = agent.getNeighbors().filter(n => n.dist < 40);
                        for (const n of neighbors) {
                            ctx.beginPath();
                            ctx.moveTo(agent.x, agent.y);
                            ctx.lineTo(n.agent.x, n.agent.y);
                            ctx.strokeStyle = `rgba(255,255,255,${0.1 * agent.traits.sociability})`;
                            ctx.lineWidth = 0.5 / view.zoom;
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw agents
            for (const agent of agents) {
                // Agent body
                const size = 3 + agent.energy / 30;
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
                ctx.fillStyle = agent.getColorString();
                ctx.fill();

                // Glow for high energy
                if (agent.energy > 60) {
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, size + 3, 0, Math.PI * 2);
                    ctx.fillStyle = agent.getColorString(0.2);
                    ctx.fill();
                }

                // Aggression indicator
                if (agent.traits.aggression > 0.6) {
                    ctx.beginPath();
                    ctx.arc(agent.x, agent.y, size + 2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                    ctx.lineWidth = 1 / view.zoom;
                    ctx.stroke();
                }
            }

            // Draw city markers
            for (const city of cities) {
                ctx.beginPath();
                ctx.arc(city.x, city.y, 20 + city.population / 2, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                ctx.lineWidth = 2 / view.zoom;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        function drawHeatMap() {
            const gridSize = 50;
            const maxDensity = 10;

            for (const key in spatialGrid) {
                const [gx, gy] = key.split(',').map(Number);
                const density = Math.min(spatialGrid[key].length / maxDensity, 1);

                if (density > 0.1) {
                    ctx.fillStyle = `rgba(239, 68, 68, ${density * 0.3})`;
                    ctx.fillRect(gx * gridSize, gy * gridSize, gridSize, gridSize);
                }
            }
        }

        function drawCultureBorders() {
            const cultures = detectCultures();

            for (const culture of cultures) {
                if (culture.agents.length < 5) continue;

                // Find convex hull of culture agents
                const points = culture.agents.map(a => ({ x: a.x, y: a.y }));
                const hull = convexHull(points);

                if (hull.length < 3) continue;

                ctx.beginPath();
                ctx.moveTo(hull[0].x, hull[0].y);
                for (let i = 1; i < hull.length; i++) {
                    ctx.lineTo(hull[i].x, hull[i].y);
                }
                ctx.closePath();

                ctx.strokeStyle = `hsla(${culture.color.h}, ${culture.color.s}%, ${culture.color.l}%, 0.5)`;
                ctx.lineWidth = 3 / view.zoom;
                ctx.stroke();

                ctx.fillStyle = `hsla(${culture.color.h}, ${culture.color.s}%, ${culture.color.l}%, 0.1)`;
                ctx.fill();
            }
        }

        function drawTradeRoutes() {
            for (const route of tradeRoutes) {
                ctx.beginPath();
                ctx.moveTo(route.x1, route.y1);
                ctx.lineTo(route.x2, route.y2);
                ctx.strokeStyle = route.color;
                ctx.lineWidth = 2 / view.zoom;
                ctx.stroke();
            }
        }

        // Convex hull algorithm (Graham scan)
        function convexHull(points) {
            if (points.length < 3) return points;

            // Find bottom-most point
            let minY = points[0].y;
            let minIdx = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].y < minY || (points[i].y === minY && points[i].x < points[minIdx].x)) {
                    minY = points[i].y;
                    minIdx = i;
                }
            }

            // Swap
            [points[0], points[minIdx]] = [points[minIdx], points[0]];
            const pivot = points[0];

            // Sort by polar angle
            const sorted = points.slice(1).sort((a, b) => {
                const angleA = Math.atan2(a.y - pivot.y, a.x - pivot.x);
                const angleB = Math.atan2(b.y - pivot.y, b.x - pivot.x);
                return angleA - angleB;
            });

            const hull = [pivot];
            for (const p of sorted) {
                while (hull.length >= 2) {
                    const top = hull[hull.length - 1];
                    const next = hull[hull.length - 2];
                    const cross = (top.x - next.x) * (p.y - next.y) - (top.y - next.y) * (p.x - next.x);
                    if (cross <= 0) {
                        hull.pop();
                    } else {
                        break;
                    }
                }
                hull.push(p);
            }

            return hull;
        }

        // ========== CONTROLS ==========
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playIcon').textContent = isPlaying ? '\u275A\u275A' : '\u25B6';
            if (isPlaying) {
                document.getElementById('playPauseBtn').classList.add('btn-primary');
            } else {
                document.getElementById('playPauseBtn').classList.remove('btn-primary');
            }
        }

        function stepSimulation() {
            isPlaying = false;
            document.getElementById('playIcon').textContent = '\u25B6';
            document.getElementById('playPauseBtn').classList.remove('btn-primary');
            updateSimulation(0.1);
            updateStatistics();
        }

        function resetSimulation() {
            if (confirm('Reset simulation? All progress will be lost.')) {
                initializeWorld();
                view.x = WORLD_WIDTH / 2;
                view.y = WORLD_HEIGHT / 2;
                view.zoom = 0.5;
                isPlaying = false;
                document.getElementById('playIcon').textContent = '\u25B6';
                document.getElementById('playPauseBtn').classList.remove('btn-primary');
                updateStatistics();
            }
        }

        function updateSpeed() {
            const slider = document.getElementById('speedSlider');
            // Exponential scale for speed: 1x to 1000x
            settings.speed = Math.pow(10, slider.value / 33.33);
            document.getElementById('speedValue').textContent = settings.speed >= 100 ?
                Math.round(settings.speed) + 'x' :
                settings.speed.toFixed(1) + 'x';
        }

        function updateFoodRate() {
            settings.foodAbundance = document.getElementById('foodSlider').value;
            document.getElementById('foodValue').textContent = settings.foodAbundance + '%';
        }

        function updateMutationRate() {
            settings.mutationRate = document.getElementById('mutationSlider').value;
            document.getElementById('mutationValue').textContent = settings.mutationRate + '%';
        }

        function updateTradeWillingness() {
            settings.tradeWillingness = document.getElementById('tradeSlider').value;
            document.getElementById('tradeValue').textContent = settings.tradeWillingness + '%';
        }

        function toggleOverlay(type) {
            overlays[type] = document.getElementById(type + 'Overlay').checked;
        }

        function addAgents(count) {
            for (let i = 0; i < count && agents.length < MAX_AGENTS; i++) {
                agents.push(new Agent(
                    Math.random() * WORLD_WIDTH,
                    Math.random() * WORLD_HEIGHT
                ));
            }
        }

        function addFood(count) {
            for (let i = 0; i < count; i++) {
                food.push(new Food(
                    Math.random() * WORLD_WIDTH,
                    Math.random() * WORLD_HEIGHT
                ));
            }
        }

        function triggerCataclysm() {
            // Remove 50% of agents randomly
            const survivors = agents.filter(() => Math.random() > 0.5);
            const deaths = agents.length - survivors.length;
            agents = survivors;
            totalDeaths += deaths;

            // Remove 70% of food
            food = food.filter(() => Math.random() > 0.7);

            addEvent('war', `Cataclysm! ${deaths} agents perished.`);

            // Visual feedback
            canvas.style.filter = 'brightness(2)';
            setTimeout(() => canvas.style.filter = '', 200);
        }

        function fastForwardToInteresting() {
            const targetCities = 3;
            const targetCultures = 4;
            const maxIterations = 10000;

            let iterations = 0;
            isPlaying = false;

            const fastForward = () => {
                for (let i = 0; i < 100; i++) {
                    updateSimulation(0.016);
                    iterations++;
                }

                detectCities();
                const cultures = detectCultures();

                if ((cities.length >= targetCities && cultures.length >= targetCultures) || iterations >= maxIterations) {
                    updateStatistics();
                    addEvent('city', 'Fast forward complete: Civilization established');
                    return;
                }

                document.getElementById('yearDisplay').textContent = Math.floor(simulationYear).toLocaleString();
                requestAnimationFrame(fastForward);
            };

            fastForward();
        }

        function zoomIn() {
            view.zoom = Math.min(view.zoom * 1.3, 4);
        }

        function zoomOut() {
            view.zoom = Math.max(view.zoom / 1.3, 0.2);
        }

        function resetView() {
            view.x = WORLD_WIDTH / 2;
            view.y = WORLD_HEIGHT / 2;
            view.zoom = 0.5;
        }

        function showInstructions() {
            document.getElementById('instructionsModal').classList.add('visible');
        }

        function closeInstructions() {
            document.getElementById('instructionsModal').classList.remove('visible');
        }

        // ========== MOUSE/TOUCH EVENTS ==========
        function onMouseDown(e) {
            view.isDragging = true;
            view.lastMouseX = e.clientX;
            view.lastMouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (view.isDragging) {
                const dx = e.clientX - view.lastMouseX;
                const dy = e.clientY - view.lastMouseY;
                view.x -= dx / view.zoom;
                view.y -= dy / view.zoom;
                view.lastMouseX = e.clientX;
                view.lastMouseY = e.clientY;

                // Clamp view
                view.x = Math.max(0, Math.min(WORLD_WIDTH, view.x));
                view.y = Math.max(0, Math.min(WORLD_HEIGHT, view.y));
            }
        }

        function onMouseUp() {
            view.isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            view.zoom = Math.max(0.2, Math.min(4, view.zoom * zoomFactor));
        }

        let touchStartDist = 0;
        let touchStartZoom = 1;

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                view.isDragging = true;
                view.lastMouseX = e.touches[0].clientX;
                view.lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                view.isDragging = false;
                touchStartDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                touchStartZoom = view.zoom;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1 && view.isDragging) {
                const dx = e.touches[0].clientX - view.lastMouseX;
                const dy = e.touches[0].clientY - view.lastMouseY;
                view.x -= dx / view.zoom;
                view.y -= dy / view.zoom;
                view.lastMouseX = e.touches[0].clientX;
                view.lastMouseY = e.touches[0].clientY;

                view.x = Math.max(0, Math.min(WORLD_WIDTH, view.x));
                view.y = Math.max(0, Math.min(WORLD_HEIGHT, view.y));
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                view.zoom = Math.max(0.2, Math.min(4, touchStartZoom * (dist / touchStartDist)));
            }
        }

        function onTouchEnd() {
            view.isDragging = false;
        }

        // ========== DATA PERSISTENCE ==========
        function saveData() {
            const data = {
                version: 1,
                timestamp: Date.now(),
                simulationYear,
                generation,
                totalBirths,
                totalDeaths,
                tradeCount,
                conflictCount,
                settings,
                popHistory,
                eventLog,
                agents: agents.map(a => ({
                    x: a.x,
                    y: a.y,
                    vx: a.vx,
                    vy: a.vy,
                    energy: a.energy,
                    age: a.age,
                    color: a.color,
                    traits: a.traits,
                    generation: a.generation
                })),
                food: food.map(f => ({
                    x: f.x,
                    y: f.y,
                    energy: f.energy
                }))
            };

            try {
                localStorage.setItem(APP_NAME, JSON.stringify(data));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }

        function loadData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const data = JSON.parse(saved);

                    simulationYear = data.simulationYear || 0;
                    generation = data.generation || 0;
                    totalBirths = data.totalBirths || 0;
                    totalDeaths = data.totalDeaths || 0;
                    tradeCount = data.tradeCount || 0;
                    conflictCount = data.conflictCount || 0;
                    settings = { ...settings, ...data.settings };
                    popHistory = data.popHistory || [];
                    eventLog = data.eventLog || [];

                    // Restore agents
                    agents = (data.agents || []).map(a => {
                        const agent = new Agent(a.x, a.y, a.color, a.traits);
                        agent.vx = a.vx;
                        agent.vy = a.vy;
                        agent.energy = a.energy;
                        agent.age = a.age;
                        agent.generation = a.generation;
                        return agent;
                    });

                    // Restore food
                    food = (data.food || []).map(f => {
                        const fd = new Food(f.x, f.y);
                        fd.energy = f.energy;
                        return fd;
                    });

                    // Update UI
                    document.getElementById('speedSlider').value = Math.log10(settings.speed) * 33.33;
                    document.getElementById('speedValue').textContent = settings.speed.toFixed(1) + 'x';
                    document.getElementById('foodSlider').value = settings.foodAbundance;
                    document.getElementById('foodValue').textContent = settings.foodAbundance + '%';
                    document.getElementById('mutationSlider').value = settings.mutationRate;
                    document.getElementById('mutationValue').textContent = settings.mutationRate + '%';
                    document.getElementById('tradeSlider').value = settings.tradeWillingness;
                    document.getElementById('tradeValue').textContent = settings.tradeWillingness + '%';

                    lastCenturyPop = agents.length;
                    updateStatistics();
                }
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
            }
        }

        function exportData() {
            saveData();
            const data = localStorage.getItem(APP_NAME);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    localStorage.setItem(APP_NAME, JSON.stringify(data));
                    location.reload();
                } catch (error) {
                    alert('Invalid save file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ========== KEYBOARD SHORTCUTS ==========
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch (e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'r':
                    resetView();
                    break;
                case '+':
                case '=':
                    zoomIn();
                    break;
                case '-':
                    zoomOut();
                    break;
                case 'f':
                    fastForwardToInteresting();
                    break;
                case '?':
                    showInstructions();
                    break;
            }
        });

        // ========== START ==========
        window.addEventListener('DOMContentLoaded', init);

        // Save before leaving
        window.addEventListener('beforeunload', saveData);
    </script>
</body>
</html>
