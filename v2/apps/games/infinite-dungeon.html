<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Infinite Dungeon - Procedural Roguelike</title>
    <meta name="description" content="A fully procedural roguelike where every room, enemy, item, and narrative is generated algorithmically. No two runs are ever the same.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-medium: #12121a;
            --bg-light: #1a1a25;
            --text-primary: #e0e0e0;
            --text-secondary: #888;
            --accent: #6a5acd;
            --common: #9d9d9d;
            --uncommon: #1eff00;
            --rare: #0070dd;
            --epic: #a335ee;
            --legendary: #ff8000;
            --health: #c41e3a;
            --mana: #0070dd;
            --gold: #ffd700;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            display: grid;
            grid-template-columns: 200px 1fr 280px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 4px;
            padding: 4px;
        }

        .panel {
            background: var(--bg-medium);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            overflow: hidden;
        }

        #header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
        }

        #header h1 {
            font-size: 1.2em;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
        }

        #seed-display {
            font-size: 0.8em;
            color: var(--text-secondary);
            cursor: pointer;
        }

        #seed-display:hover {
            color: var(--accent);
        }

        #left-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #minimap-container {
            aspect-ratio: 1;
            background: var(--bg-dark);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        #player-stats h3 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .stat-bar {
            height: 16px;
            background: var(--bg-dark);
            border-radius: 2px;
            margin-bottom: 6px;
            position: relative;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7em;
            text-shadow: 1px 1px 1px black;
            white-space: nowrap;
        }

        .health-bar .stat-bar-fill { background: linear-gradient(to right, #8b0000, var(--health)); }
        .mana-bar .stat-bar-fill { background: linear-gradient(to right, #00008b, var(--mana)); }
        .xp-bar .stat-bar-fill { background: linear-gradient(to right, #4a0080, var(--accent)); }

        .player-info {
            font-size: 0.75em;
            margin-top: 8px;
        }

        .player-info div {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid #222;
        }

        #game-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
        }

        #game-canvas {
            image-rendering: pixelated;
            cursor: crosshair;
        }

        #right-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.8em;
        }

        #inventory-panel h3, #combat-log h3 {
            color: var(--accent);
            margin-bottom: 6px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
        }

        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-bottom: 8px;
        }

        .inv-slot {
            aspect-ratio: 1;
            background: var(--bg-dark);
            border: 1px solid #333;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .inv-slot:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .inv-slot.common { border-color: var(--common); }
        .inv-slot.uncommon { border-color: var(--uncommon); }
        .inv-slot.rare { border-color: var(--rare); }
        .inv-slot.epic { border-color: var(--epic); }
        .inv-slot.legendary { border-color: var(--legendary); box-shadow: 0 0 8px var(--legendary); }

        #equipment-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            padding: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .equip-slot {
            aspect-ratio: 1;
            background: var(--bg-light);
            border: 1px dashed #444;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            position: relative;
        }

        .equip-slot::before {
            content: attr(data-slot);
            position: absolute;
            bottom: -12px;
            font-size: 0.6em;
            color: var(--text-secondary);
        }

        #combat-log {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #log-content {
            flex: 1;
            overflow-y: auto;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .log-entry {
            padding: 2px 4px;
            border-bottom: 1px solid #1a1a1a;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .log-damage { color: #ff6b6b; }
        .log-heal { color: #69db7c; }
        .log-item { color: var(--gold); }
        .log-info { color: var(--text-secondary); }
        .log-critical { color: #ff0; font-weight: bold; }
        .log-death { color: var(--health); font-weight: bold; }

        #footer {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 16px;
            font-size: 0.75em;
        }

        #abilities {
            display: flex;
            gap: 8px;
        }

        .ability-btn {
            width: 48px;
            height: 48px;
            background: var(--bg-light);
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .ability-btn:hover:not(.on-cooldown) {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .ability-btn.on-cooldown {
            opacity: 0.5;
        }

        .ability-btn .icon {
            font-size: 1.4em;
        }

        .ability-btn .key {
            font-size: 0.6em;
            color: var(--text-secondary);
        }

        .ability-btn .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 0.7em;
            text-align: center;
        }

        #controls-hint {
            color: var(--text-secondary);
        }

        /* Tooltip */
        #tooltip {
            position: fixed;
            background: var(--bg-dark);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px 12px;
            max-width: 280px;
            font-size: 0.8em;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        #tooltip.visible {
            display: block;
        }

        #tooltip .item-name {
            font-weight: bold;
            margin-bottom: 4px;
        }

        #tooltip .item-type {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 6px;
        }

        #tooltip .item-stats {
            margin-bottom: 6px;
        }

        #tooltip .item-stats div {
            color: #8f8;
        }

        #tooltip .item-lore {
            color: var(--gold);
            font-style: italic;
            font-size: 0.9em;
            border-top: 1px solid #333;
            padding-top: 6px;
            margin-top: 6px;
        }

        /* Modal Screens */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: var(--bg-medium);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
        }

        .modal h2 {
            color: var(--accent);
            margin-bottom: 16px;
            text-shadow: 0 0 20px var(--accent);
        }

        .class-select {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 16px 0;
        }

        .class-option {
            background: var(--bg-dark);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .class-option:hover {
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .class-option .icon {
            font-size: 2em;
            margin-bottom: 8px;
        }

        .class-option h4 {
            color: var(--accent);
            margin-bottom: 4px;
        }

        .class-option p {
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1em;
            margin: 8px;
            transition: all 0.2s;
        }

        .btn:hover {
            filter: brightness(1.2);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--bg-light);
            border: 1px solid #444;
        }

        #death-stats {
            text-align: left;
            margin: 16px 0;
        }

        #death-stats div {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }

        /* Room description overlay */
        #room-description {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.85em;
            color: var(--text-secondary);
            max-width: 400px;
            text-align: center;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* Damage numbers */
        .damage-number {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 2px 2px 2px black;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        /* Responsive */
        @media (max-width: 900px) {
            #game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr auto auto;
            }

            #left-panel, #right-panel {
                flex-direction: row;
                flex-wrap: wrap;
            }

            #minimap-container {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <header id="header" class="panel">
            <h1>THE INFINITE DUNGEON</h1>
            <div id="floor-display">Floor 1</div>
            <div id="seed-display" title="Click to copy seed">Seed: ------</div>
        </header>

        <aside id="left-panel" class="panel">
            <div id="minimap-container">
                <canvas id="minimap"></canvas>
            </div>
            <div id="player-stats">
                <h3 id="player-class-display">Warrior</h3>
                <div class="stat-bar health-bar">
                    <div class="stat-bar-fill" style="width: 100%"></div>
                    <span class="stat-bar-text">100 / 100 HP</span>
                </div>
                <div class="stat-bar mana-bar">
                    <div class="stat-bar-fill" style="width: 100%"></div>
                    <span class="stat-bar-text">50 / 50 MP</span>
                </div>
                <div class="stat-bar xp-bar">
                    <div class="stat-bar-fill" style="width: 0%"></div>
                    <span class="stat-bar-text">Level 1 (0/100 XP)</span>
                </div>
                <div class="player-info">
                    <div><span>STR</span><span id="stat-str">10</span></div>
                    <div><span>DEX</span><span id="stat-dex">10</span></div>
                    <div><span>INT</span><span id="stat-int">10</span></div>
                    <div><span>VIT</span><span id="stat-vit">10</span></div>
                    <div><span>Gold</span><span id="stat-gold">0</span></div>
                </div>
            </div>
        </aside>

        <main id="game-area" class="panel">
            <canvas id="game-canvas"></canvas>
            <div id="room-description"></div>
        </main>

        <aside id="right-panel" class="panel">
            <div id="inventory-panel">
                <h3>Equipment</h3>
                <div id="equipment-slots">
                    <div class="equip-slot" data-slot="weapon" data-type="weapon"></div>
                    <div class="equip-slot" data-slot="helm" data-type="helm"></div>
                    <div class="equip-slot" data-slot="chest" data-type="chest"></div>
                    <div class="equip-slot" data-slot="boots" data-type="boots"></div>
                </div>
                <h3>Inventory <span id="inv-count">0/16</span></h3>
                <div id="inventory-grid"></div>
            </div>
            <div id="combat-log">
                <h3>Combat Log</h3>
                <div id="log-content"></div>
            </div>
        </aside>

        <footer id="footer" class="panel">
            <div id="abilities"></div>
            <div id="controls-hint">WASD/Arrows: Move | 1-4: Abilities | E: Pick up | Space: Wait | I: Inventory</div>
        </footer>
    </div>

    <div id="tooltip"></div>

    <!-- Start Screen Modal -->
    <div id="start-modal" class="modal">
        <div class="modal-content">
            <h2>THE INFINITE DUNGEON</h2>
            <p>Every room, enemy, and item is procedurally generated.<br>No two runs are ever the same.</p>

            <div style="margin: 16px 0;">
                <label>Seed (leave blank for random): </label><br>
                <input type="text" id="seed-input" placeholder="Enter seed or leave blank" style="padding: 8px; margin-top: 8px; width: 200px; background: var(--bg-dark); border: 1px solid #444; color: white; border-radius: 4px;">
            </div>

            <h3 style="margin-top: 20px; color: var(--accent);">Choose Your Class</h3>
            <div class="class-select">
                <div class="class-option" data-class="warrior">
                    <div class="icon">&#9876;</div>
                    <h4>Warrior</h4>
                    <p>High health, melee focused. Abilities: Shield Bash, Cleave, Battle Cry, Berserker Rage</p>
                </div>
                <div class="class-option" data-class="rogue">
                    <div class="icon">&#128481;</div>
                    <h4>Rogue</h4>
                    <p>Fast and deadly. Abilities: Backstab, Smoke Bomb, Poison Blade, Shadow Step</p>
                </div>
                <div class="class-option" data-class="mage">
                    <div class="icon">&#9733;</div>
                    <h4>Mage</h4>
                    <p>Powerful magic. Abilities: Fireball, Frost Nova, Lightning Bolt, Arcane Shield</p>
                </div>
                <div class="class-option" data-class="ranger">
                    <div class="icon">&#127993;</div>
                    <h4>Ranger</h4>
                    <p>Ranged expert. Abilities: Power Shot, Trap, Multi-Shot, Eagle Eye</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Death Screen Modal -->
    <div id="death-modal" class="modal hidden">
        <div class="modal-content">
            <h2 style="color: var(--health);">YOU HAVE FALLEN</h2>
            <p id="death-message">The dungeon claims another soul...</p>
            <div id="death-stats"></div>
            <button class="btn" onclick="game.restart()">Try Again</button>
            <button class="btn btn-secondary" onclick="game.exportRun()">Export Run Data</button>
        </div>
    </div>

    <!-- Level Up Modal -->
    <div id="levelup-modal" class="modal hidden">
        <div class="modal-content">
            <h2>LEVEL UP!</h2>
            <p>Choose a stat to increase:</p>
            <div id="levelup-choices" style="display: flex; gap: 12px; justify-content: center; margin-top: 16px;"></div>
        </div>
    </div>

    <script>
    // ============================================
    // SEEDED RANDOM NUMBER GENERATOR
    // ============================================
    class SeededRNG {
        constructor(seed) {
            this.seed = seed;
            this.state = this.hashString(seed.toString());
        }

        hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash) || 1;
        }

        next() {
            this.state = (this.state * 1103515245 + 12345) & 0x7fffffff;
            return this.state / 0x7fffffff;
        }

        nextInt(min, max) {
            return Math.floor(this.next() * (max - min + 1)) + min;
        }

        nextFloat(min, max) {
            return this.next() * (max - min) + min;
        }

        choose(arr) {
            return arr[this.nextInt(0, arr.length - 1)];
        }

        shuffle(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = this.nextInt(0, i);
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        weightedChoice(options, weights) {
            const total = weights.reduce((a, b) => a + b, 0);
            let random = this.next() * total;
            for (let i = 0; i < options.length; i++) {
                random -= weights[i];
                if (random <= 0) return options[i];
            }
            return options[options.length - 1];
        }
    }

    // ============================================
    // PROCEDURAL NAME GENERATOR
    // ============================================
    const NameGenerator = {
        prefixes: {
            fire: ['Blazing', 'Infernal', 'Scorching', 'Ember', 'Molten', 'Flame'],
            ice: ['Frozen', 'Glacial', 'Frigid', 'Frost', 'Icy', 'Winter'],
            lightning: ['Storming', 'Thunder', 'Shocking', 'Voltaic', 'Sparking', 'Electric'],
            poison: ['Venomous', 'Toxic', 'Noxious', 'Corrupted', 'Blighted', 'Festering'],
            void: ['Void', 'Shadow', 'Dark', 'Abyssal', 'Eldritch', 'Nightmare'],
            holy: ['Divine', 'Radiant', 'Sacred', 'Blessed', 'Celestial', 'Hallowed'],
            physical: ['Brutal', 'Savage', 'Fierce', 'Mighty', 'Ancient', 'Primal']
        },

        enemyBases: {
            humanoid: ['Knight', 'Soldier', 'Guard', 'Cultist', 'Bandit', 'Assassin', 'Witch', 'Necromancer'],
            beast: ['Wolf', 'Bear', 'Spider', 'Serpent', 'Bat', 'Rat', 'Hound', 'Scorpion'],
            undead: ['Skeleton', 'Zombie', 'Wraith', 'Ghoul', 'Specter', 'Revenant', 'Lich', 'Bone Horror'],
            elemental: ['Golem', 'Elemental', 'Spirit', 'Wisp', 'Guardian', 'Sentinel', 'Construct'],
            aberration: ['Horror', 'Abomination', 'Thing', 'Crawler', 'Lurker', 'Stalker', 'Devourer']
        },

        enemySuffixes: ['of Doom', 'the Destroyer', 'the Cursed', 'of Shadows', 'the Eternal', 'of the Depths', 'the Ravenous', 'of Torment', ''],

        itemPrefixes: {
            common: [''],
            uncommon: ['Sharp', 'Sturdy', 'Fine', 'Quality', 'Reliable'],
            rare: ['Masterwork', 'Enchanted', 'Runic', 'Mystic', 'Tempered'],
            epic: ['Legendary', 'Ancient', 'Mythic', 'Exalted', 'Transcendent'],
            legendary: ['Godforged', 'Primordial', 'Eternal', 'Cosmic', 'Divine']
        },

        weaponBases: ['Sword', 'Axe', 'Mace', 'Dagger', 'Staff', 'Bow', 'Spear', 'Warhammer', 'Scythe', 'Blade'],
        armorBases: { helm: ['Helm', 'Crown', 'Hood', 'Mask'], chest: ['Armor', 'Robe', 'Vest', 'Plate'], boots: ['Boots', 'Greaves', 'Treads', 'Sabatons'] },

        itemSuffixes: {
            fire: ['of Flames', 'of Burning', 'of the Inferno', 'of Cinders'],
            ice: ['of Frost', 'of Winter', 'of the Glacier', 'of Freezing'],
            lightning: ['of Storms', 'of Thunder', 'of Shocking', 'of Lightning'],
            poison: ['of Venom', 'of Blight', 'of Toxins', 'of Corruption'],
            void: ['of Shadows', 'of the Void', 'of Darkness', 'of Nightmares'],
            holy: ['of Light', 'of Divinity', 'of the Blessed', 'of Radiance'],
            physical: ['of Might', 'of Power', 'of the Giant', 'of Brutality']
        },

        dungeonAdjectives: ['Ancient', 'Forgotten', 'Cursed', 'Haunted', 'Abandoned', 'Ruined', 'Sunken', 'Burning', 'Frozen', 'Twisted'],
        dungeonNouns: ['Catacombs', 'Crypts', 'Depths', 'Halls', 'Chambers', 'Tunnels', 'Labyrinth', 'Sanctum', 'Void', 'Abyss'],

        roomDescriptions: {
            combat: [
                'The stench of death hangs heavy in the air.',
                'Shadows move in the corners of your vision.',
                'Ancient bloodstains mark the stone floor.',
                'The walls seem to close in around you.',
                'A cold wind whispers through the chamber.'
            ],
            treasure: [
                'Glittering treasures catch the torchlight.',
                'A forgotten hoard lies before you.',
                'The room sparkles with ancient riches.',
                'Long-dead adventurers\' belongings scatter the floor.'
            ],
            shrine: [
                'A mystical energy pulses through this place.',
                'An ancient altar stands at the center.',
                'Divine light filters from an unknown source.',
                'The air hums with magical resonance.'
            ],
            boss: [
                'The ground trembles with malevolent power.',
                'This chamber reeks of ancient evil.',
                'The very walls seem to breathe hatred.',
                'A throne of bones dominates the room.'
            ],
            empty: [
                'Dust motes dance in the stale air.',
                'Cobwebs drape the ancient stonework.',
                'The silence here is deafening.',
                'Time itself seems to have forgotten this place.'
            ]
        },

        generateEnemyName(rng, type, element) {
            const prefix = rng.choose(this.prefixes[element] || this.prefixes.physical);
            const base = rng.choose(this.enemyBases[type] || this.enemyBases.humanoid);
            const suffix = rng.next() > 0.7 ? rng.choose(this.enemySuffixes) : '';
            return `${prefix} ${base}${suffix ? ' ' + suffix : ''}`.trim();
        },

        generateItemName(rng, baseType, rarity, element) {
            const prefix = rng.choose(this.itemPrefixes[rarity] || ['']);
            let base;
            if (baseType === 'weapon') {
                base = rng.choose(this.weaponBases);
            } else if (this.armorBases[baseType]) {
                base = rng.choose(this.armorBases[baseType]);
            } else {
                base = baseType;
            }
            const suffix = element && rng.next() > 0.3 ? rng.choose(this.itemSuffixes[element] || []) : '';
            return `${prefix} ${base} ${suffix}`.trim().replace(/\s+/g, ' ');
        },

        generateDungeonName(rng) {
            return `The ${rng.choose(this.dungeonAdjectives)} ${rng.choose(this.dungeonNouns)}`;
        },

        generateRoomDescription(rng, roomType) {
            const descriptions = this.roomDescriptions[roomType] || this.roomDescriptions.empty;
            return rng.choose(descriptions);
        },

        generateLore(rng) {
            const subjects = ['A great king', 'An ancient mage', 'A fallen hero', 'Dark cultists', 'A forgotten god', 'Primordial forces'];
            const verbs = ['once ruled', 'were imprisoned in', 'died defending', 'corrupted', 'built', 'destroyed'];
            const objects = ['this place', 'these halls', 'the depths below', 'the ancient seal', 'the world above'];
            const endings = ['Legends say their power still lingers.', 'None who entered ever returned.', 'Their curse remains to this day.', 'Only death awaits those who seek their treasure.'];
            return `${rng.choose(subjects)} ${rng.choose(verbs)} ${rng.choose(objects)}. ${rng.choose(endings)}`;
        }
    };

    // ============================================
    // PROCEDURAL DUNGEON GENERATOR
    // ============================================
    class DungeonGenerator {
        constructor(rng, floor) {
            this.rng = rng;
            this.floor = floor;
            this.width = 60 + floor * 5;
            this.height = 40 + floor * 3;
            this.rooms = [];
            this.tiles = [];
            this.entities = [];
            this.items = [];
        }

        generate() {
            // Initialize with walls
            this.tiles = Array(this.height).fill(null).map(() =>
                Array(this.width).fill({ type: 'wall', char: '#', color: '#444' })
            );

            // Generate rooms
            const roomCount = 8 + this.floor * 2;
            const attempts = roomCount * 10;

            for (let i = 0; i < attempts && this.rooms.length < roomCount; i++) {
                this.tryPlaceRoom();
            }

            // Connect rooms with corridors
            this.connectRooms();

            // Assign room types
            this.assignRoomTypes();

            // Place player start
            const startRoom = this.rooms[0];
            this.playerStart = {
                x: Math.floor(startRoom.x + startRoom.w / 2),
                y: Math.floor(startRoom.y + startRoom.h / 2)
            };

            // Place stairs down
            const endRoom = this.rooms[this.rooms.length - 1];
            const stairsX = Math.floor(endRoom.x + endRoom.w / 2);
            const stairsY = Math.floor(endRoom.y + endRoom.h / 2);
            this.tiles[stairsY][stairsX] = { type: 'stairs', char: '>', color: '#ff0', description: 'Stairs leading deeper...' };

            // Populate rooms
            this.populateRooms();

            return {
                tiles: this.tiles,
                rooms: this.rooms,
                entities: this.entities,
                items: this.items,
                playerStart: this.playerStart,
                width: this.width,
                height: this.height,
                name: NameGenerator.generateDungeonName(this.rng),
                lore: NameGenerator.generateLore(this.rng)
            };
        }

        tryPlaceRoom() {
            const w = this.rng.nextInt(6, 14);
            const h = this.rng.nextInt(5, 10);
            const x = this.rng.nextInt(1, this.width - w - 1);
            const y = this.rng.nextInt(1, this.height - h - 1);

            // Check overlap
            for (const room of this.rooms) {
                if (x < room.x + room.w + 2 && x + w + 2 > room.x &&
                    y < room.y + room.h + 2 && y + h + 2 > room.y) {
                    return false;
                }
            }

            // Carve room
            const room = { x, y, w, h, type: 'empty' };
            this.carveRoom(room);
            this.rooms.push(room);
            return true;
        }

        carveRoom(room) {
            for (let dy = 0; dy < room.h; dy++) {
                for (let dx = 0; dx < room.w; dx++) {
                    const tx = room.x + dx;
                    const ty = room.y + dy;
                    if (ty >= 0 && ty < this.height && tx >= 0 && tx < this.width) {
                        this.tiles[ty][tx] = { type: 'floor', char: '.', color: '#555' };
                    }
                }
            }
        }

        connectRooms() {
            for (let i = 1; i < this.rooms.length; i++) {
                const a = this.rooms[i - 1];
                const b = this.rooms[i];

                const ax = Math.floor(a.x + a.w / 2);
                const ay = Math.floor(a.y + a.h / 2);
                const bx = Math.floor(b.x + b.w / 2);
                const by = Math.floor(b.y + b.h / 2);

                // L-shaped corridor
                if (this.rng.next() > 0.5) {
                    this.carveCorridor(ax, ay, bx, ay);
                    this.carveCorridor(bx, ay, bx, by);
                } else {
                    this.carveCorridor(ax, ay, ax, by);
                    this.carveCorridor(ax, by, bx, by);
                }
            }
        }

        carveCorridor(x1, y1, x2, y2) {
            const dx = Math.sign(x2 - x1);
            const dy = Math.sign(y2 - y1);
            let x = x1, y = y1;

            while (x !== x2 || y !== y2) {
                if (y >= 0 && y < this.height && x >= 0 && x < this.width) {
                    this.tiles[y][x] = { type: 'floor', char: '.', color: '#555' };
                }
                if (x !== x2) x += dx;
                else if (y !== y2) y += dy;
            }
            if (y >= 0 && y < this.height && x >= 0 && x < this.width) {
                this.tiles[y][x] = { type: 'floor', char: '.', color: '#555' };
            }
        }

        assignRoomTypes() {
            // First room is always safe (start)
            this.rooms[0].type = 'start';
            this.rooms[0].description = 'You enter the dungeon. The air is thick with dust and dread.';

            // Last room before stairs
            if (this.rooms.length > 1) {
                this.rooms[this.rooms.length - 1].type = (this.floor % 5 === 0) ? 'boss' : 'combat';
            }

            // Assign others randomly
            const types = ['combat', 'combat', 'combat', 'treasure', 'shrine', 'empty', 'trap'];
            for (let i = 1; i < this.rooms.length - 1; i++) {
                this.rooms[i].type = this.rng.choose(types);
                this.rooms[i].description = NameGenerator.generateRoomDescription(this.rng, this.rooms[i].type);
            }
        }

        populateRooms() {
            for (const room of this.rooms) {
                if (room.type === 'start') continue;

                switch (room.type) {
                    case 'combat':
                        this.spawnEnemies(room, this.rng.nextInt(1, 3));
                        if (this.rng.next() > 0.7) this.spawnItem(room);
                        break;
                    case 'boss':
                        this.spawnBoss(room);
                        this.spawnItem(room, 'rare');
                        break;
                    case 'treasure':
                        this.spawnItems(room, this.rng.nextInt(2, 4));
                        if (this.rng.next() > 0.5) this.spawnEnemies(room, 1);
                        break;
                    case 'shrine':
                        this.placeShrine(room);
                        break;
                    case 'trap':
                        this.placeTraps(room);
                        if (this.rng.next() > 0.6) this.spawnItem(room);
                        break;
                    case 'empty':
                        if (this.rng.next() > 0.7) this.spawnItem(room);
                        break;
                }
            }
        }

        spawnEnemies(room, count) {
            for (let i = 0; i < count; i++) {
                const pos = this.getRandomRoomPosition(room);
                if (pos) {
                    this.entities.push(this.generateEnemy(pos.x, pos.y));
                }
            }
        }

        spawnBoss(room) {
            const cx = Math.floor(room.x + room.w / 2);
            const cy = Math.floor(room.y + room.h / 2);
            this.entities.push(this.generateEnemy(cx, cy, true));
        }

        generateEnemy(x, y, isBoss = false) {
            const types = ['humanoid', 'beast', 'undead', 'elemental', 'aberration'];
            const elements = ['fire', 'ice', 'lightning', 'poison', 'void', 'holy', 'physical'];
            const sizes = ['tiny', 'normal', 'normal', 'normal', 'large'];
            const behaviors = ['aggressive', 'defensive', 'flanker', 'ranged'];

            const type = this.rng.choose(types);
            const element = this.rng.choose(elements);
            const size = isBoss ? 'massive' : this.rng.choose(sizes);
            const behavior = this.rng.choose(behaviors);

            const sizeMultipliers = { tiny: 0.5, normal: 1, large: 1.5, massive: 3 };
            const mult = sizeMultipliers[size] * (1 + this.floor * 0.2);

            const baseHP = { humanoid: 30, beast: 25, undead: 35, elemental: 40, aberration: 45 };
            const baseDamage = { humanoid: 8, beast: 10, undead: 7, elemental: 12, aberration: 15 };

            const chars = {
                humanoid: ['@', 'H', 'K', 'W'],
                beast: ['w', 'B', 's', 'S'],
                undead: ['z', 'Z', 'G', 'L'],
                elemental: ['E', 'e', '*', '&'],
                aberration: ['X', '?', '%', '!']
            };

            const colors = {
                fire: '#ff4400',
                ice: '#00ccff',
                lightning: '#ffff00',
                poison: '#00ff00',
                void: '#9900ff',
                holy: '#ffffff',
                physical: '#cc8844'
            };

            return {
                type: 'enemy',
                x, y,
                name: NameGenerator.generateEnemyName(this.rng, type, element),
                enemyType: type,
                element,
                size,
                behavior,
                isBoss,
                hp: Math.floor(baseHP[type] * mult),
                maxHp: Math.floor(baseHP[type] * mult),
                damage: Math.floor(baseDamage[type] * mult),
                defense: Math.floor(5 * mult),
                xpValue: Math.floor(20 * mult * (isBoss ? 5 : 1)),
                char: isBoss ? 'B' : this.rng.choose(chars[type]),
                color: colors[element],
                goldDrop: Math.floor(this.rng.nextInt(5, 20) * mult)
            };
        }

        spawnItem(room, minRarity = null) {
            const pos = this.getRandomRoomPosition(room);
            if (pos) {
                this.items.push(this.generateItem(pos.x, pos.y, minRarity));
            }
        }

        spawnItems(room, count) {
            for (let i = 0; i < count; i++) {
                this.spawnItem(room);
            }
        }

        generateItem(x, y, minRarity = null) {
            const rarities = ['common', 'common', 'common', 'uncommon', 'uncommon', 'rare', 'epic', 'legendary'];
            const rarityWeights = [30, 25, 20, 12, 8, 3, 1.5, 0.5];

            let rarity = this.rng.weightedChoice(rarities.filter((v, i, a) => a.indexOf(v) === i), [60, 25, 10, 4, 1]);

            const rarityOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
            if (minRarity && rarityOrder.indexOf(rarity) < rarityOrder.indexOf(minRarity)) {
                rarity = minRarity;
            }

            const types = ['weapon', 'helm', 'chest', 'boots', 'potion', 'scroll'];
            const typeWeights = [25, 15, 15, 15, 20, 10];
            const type = this.rng.weightedChoice(types, typeWeights);

            const elements = ['fire', 'ice', 'lightning', 'poison', 'void', 'holy', 'physical'];
            const element = this.rng.next() > 0.5 ? this.rng.choose(elements) : null;

            const rarityColors = {
                common: '#9d9d9d',
                uncommon: '#1eff00',
                rare: '#0070dd',
                epic: '#a335ee',
                legendary: '#ff8000'
            };

            const icons = {
                weapon: ['/', '|', ')', '(', 't'],
                helm: ['^', 'n', 'o'],
                chest: ['[', ']', 'T'],
                boots: ['L', '_', 'U'],
                potion: ['!', 'i', 'Y'],
                scroll: ['?', '~', '=']
            };

            const rarityMult = { common: 1, uncommon: 1.3, rare: 1.7, epic: 2.2, legendary: 3 };
            const floorMult = 1 + this.floor * 0.15;

            let item = {
                type: 'item',
                itemType: type,
                x, y,
                name: NameGenerator.generateItemName(this.rng, type, rarity, element),
                rarity,
                element,
                char: this.rng.choose(icons[type] || ['?']),
                color: rarityColors[rarity]
            };

            // Generate stats based on type
            if (type === 'weapon') {
                item.slot = 'weapon';
                item.damage = Math.floor(this.rng.nextInt(8, 15) * rarityMult[rarity] * floorMult);
                item.stats = { damage: item.damage };
                if (element) item.elementalDamage = { type: element, amount: Math.floor(item.damage * 0.3) };
            } else if (['helm', 'chest', 'boots'].includes(type)) {
                item.slot = type;
                item.defense = Math.floor(this.rng.nextInt(3, 8) * rarityMult[rarity] * floorMult);
                item.stats = { defense: item.defense };
                if (this.rng.next() > 0.7) item.stats.hp = Math.floor(10 * rarityMult[rarity]);
            } else if (type === 'potion') {
                const potionTypes = ['health', 'mana', 'strength', 'defense'];
                item.potionType = this.rng.choose(potionTypes);
                item.value = Math.floor(30 * rarityMult[rarity] * floorMult);
                item.consumable = true;
            } else if (type === 'scroll') {
                const scrollTypes = ['fireball', 'teleport', 'identify', 'mapping'];
                item.scrollType = this.rng.choose(scrollTypes);
                item.consumable = true;
            }

            // Generate lore for rare+ items
            if (rarityOrder.indexOf(rarity) >= 2) {
                item.lore = this.generateItemLore(item);
            }

            return item;
        }

        generateItemLore(item) {
            const loreTemplates = [
                `Forged in the depths of ${this.rng.choose(['Mount Doom', 'the Void', 'ancient times', 'dragon fire'])}.`,
                `Once wielded by ${this.rng.choose(['a fallen hero', 'a dark lord', 'an ancient king', 'the gods themselves'])}.`,
                `${this.rng.choose(['Whispers', 'Legends speak', 'The ancients say'])} of its ${this.rng.choose(['terrible power', 'lost origin', 'cursed nature'])}.`,
                `${this.rng.choose(['Blood', 'Tears', 'The souls of many'])} were ${this.rng.choose(['shed', 'sacrificed', 'consumed'])} to create this.`
            ];
            return this.rng.choose(loreTemplates);
        }

        placeShrine(room) {
            const cx = Math.floor(room.x + room.w / 2);
            const cy = Math.floor(room.y + room.h / 2);
            const shrineTypes = ['healing', 'mana', 'blessing', 'cursed'];
            const shrineType = this.rng.choose(shrineTypes);

            this.tiles[cy][cx] = {
                type: 'shrine',
                shrineType,
                char: '&',
                color: shrineType === 'cursed' ? '#900' : '#0ff',
                used: false,
                description: `A ${shrineType} shrine pulses with energy...`
            };
        }

        placeTraps(room) {
            const trapCount = this.rng.nextInt(2, 5);
            for (let i = 0; i < trapCount; i++) {
                const pos = this.getRandomRoomPosition(room);
                if (pos && this.tiles[pos.y][pos.x].type === 'floor') {
                    this.tiles[pos.y][pos.x] = {
                        type: 'trap',
                        trapType: this.rng.choose(['spike', 'poison', 'fire', 'teleport']),
                        char: '.',
                        color: '#555',
                        hidden: true,
                        damage: Math.floor(10 + this.floor * 3)
                    };
                }
            }
        }

        getRandomRoomPosition(room) {
            for (let i = 0; i < 20; i++) {
                const x = room.x + this.rng.nextInt(1, room.w - 2);
                const y = room.y + this.rng.nextInt(1, room.h - 2);
                if (this.tiles[y][x].type === 'floor') {
                    return { x, y };
                }
            }
            return null;
        }
    }

    // ============================================
    // AUDIO SYSTEM
    // ============================================
    class AudioSystem {
        constructor() {
            this.ctx = null;
            this.enabled = true;
            this.volume = 0.3;
        }

        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                this.enabled = false;
            }
        }

        play(type) {
            if (!this.enabled || !this.ctx) return;
            if (this.ctx.state === 'suspended') this.ctx.resume();

            const now = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            gain.gain.setValueAtTime(this.volume, now);

            switch(type) {
                case 'hit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'playerHit':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                case 'death':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                case 'pickup':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.setValueAtTime(660, now + 0.05);
                    osc.frequency.setValueAtTime(880, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                case 'levelup':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.setValueAtTime(554, now + 0.1);
                    osc.frequency.setValueAtTime(659, now + 0.2);
                    osc.frequency.setValueAtTime(880, now + 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                case 'stairs':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(220, now);
                    osc.frequency.exponentialRampToValueAtTime(880, now + 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    osc.stop(now + 0.4);
                    break;
                case 'ability':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.setValueAtTime(800, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
            }
        }
    }

    // ============================================
    // MAIN GAME CLASS
    // ============================================
    class Game {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.minimap = document.getElementById('minimap');
            this.minimapCtx = this.minimap.getContext('2d');

            this.audio = new AudioSystem();

            this.tileSize = 20;
            this.viewWidth = 40;
            this.viewHeight = 25;

            this.seed = null;
            this.rng = null;
            this.floor = 1;
            this.dungeon = null;

            this.player = null;
            this.entities = [];
            this.items = [];
            this.explored = [];
            this.visible = [];

            this.stats = {
                kills: 0,
                damageDealt: 0,
                damageTaken: 0,
                itemsFound: 0,
                goldCollected: 0,
                floorsCleared: 0,
                turnsPlayed: 0
            };

            this.inventory = [];
            this.maxInventory = 16;
            this.equipment = { weapon: null, helm: null, chest: null, boots: null };

            this.animating = false;
            this.damageNumbers = [];

            this.classes = {
                warrior: {
                    name: 'Warrior',
                    icon: '&#9876;',
                    baseStats: { str: 14, dex: 10, int: 6, vit: 14 },
                    abilities: [
                        { name: 'Shield Bash', icon: '&#128737;', cost: 10, cooldown: 0, maxCooldown: 3, damage: 1.5, effect: 'stun', range: 1 },
                        { name: 'Cleave', icon: '&#9876;', cost: 15, cooldown: 0, maxCooldown: 4, damage: 0.8, effect: 'aoe', range: 1 },
                        { name: 'Battle Cry', icon: '&#128227;', cost: 20, cooldown: 0, maxCooldown: 8, effect: 'buff', duration: 5 },
                        { name: 'Berserker', icon: '&#128293;', cost: 30, cooldown: 0, maxCooldown: 12, effect: 'rage', duration: 6 }
                    ]
                },
                rogue: {
                    name: 'Rogue',
                    icon: '&#128481;',
                    baseStats: { str: 10, dex: 16, int: 8, vit: 10 },
                    abilities: [
                        { name: 'Backstab', icon: '&#128481;', cost: 10, cooldown: 0, maxCooldown: 2, damage: 2.5, effect: 'crit', range: 1 },
                        { name: 'Smoke Bomb', icon: '&#128168;', cost: 20, cooldown: 0, maxCooldown: 6, effect: 'invisible', duration: 3 },
                        { name: 'Poison Blade', icon: '&#9760;', cost: 15, cooldown: 0, maxCooldown: 5, effect: 'poison', duration: 4 },
                        { name: 'Shadow Step', icon: '&#128065;', cost: 25, cooldown: 0, maxCooldown: 8, effect: 'teleport', range: 5 }
                    ]
                },
                mage: {
                    name: 'Mage',
                    icon: '&#9733;',
                    baseStats: { str: 6, dex: 10, int: 16, vit: 8 },
                    abilities: [
                        { name: 'Fireball', icon: '&#128293;', cost: 15, cooldown: 0, maxCooldown: 2, damage: 2, effect: 'fire', range: 6 },
                        { name: 'Frost Nova', icon: '&#10052;', cost: 25, cooldown: 0, maxCooldown: 5, damage: 1.2, effect: 'freeze', range: 2 },
                        { name: 'Lightning', icon: '&#9889;', cost: 20, cooldown: 0, maxCooldown: 3, damage: 1.8, effect: 'chain', range: 5 },
                        { name: 'Arcane Shield', icon: '&#128302;', cost: 30, cooldown: 0, maxCooldown: 10, effect: 'shield', duration: 5 }
                    ]
                },
                ranger: {
                    name: 'Ranger',
                    icon: '&#127993;',
                    baseStats: { str: 10, dex: 14, int: 10, vit: 10 },
                    abilities: [
                        { name: 'Power Shot', icon: '&#127993;', cost: 10, cooldown: 0, maxCooldown: 2, damage: 2, range: 8 },
                        { name: 'Trap', icon: '&#128737;', cost: 15, cooldown: 0, maxCooldown: 4, effect: 'trap', damage: 1.5 },
                        { name: 'Multi-Shot', icon: '&#10148;', cost: 25, cooldown: 0, maxCooldown: 5, damage: 1, effect: 'multi', range: 6 },
                        { name: 'Eagle Eye', icon: '&#128065;', cost: 20, cooldown: 0, maxCooldown: 8, effect: 'reveal', range: 10 }
                    ]
                }
            };

            this.setupEventListeners();
            this.resizeCanvas();
        }

        setupEventListeners() {
            window.addEventListener('resize', () => this.resizeCanvas());

            document.addEventListener('keydown', (e) => this.handleInput(e));

            this.canvas.addEventListener('click', (e) => this.handleClick(e));

            // Class selection
            document.querySelectorAll('.class-option').forEach(el => {
                el.addEventListener('click', () => {
                    const className = el.dataset.class;
                    this.startGame(className);
                });
            });

            // Seed display click to copy
            document.getElementById('seed-display').addEventListener('click', () => {
                navigator.clipboard.writeText(this.seed.toString());
                this.log('Seed copied to clipboard!', 'info');
            });

            // Inventory slot interactions
            this.setupInventoryUI();
        }

        setupInventoryUI() {
            const invGrid = document.getElementById('inventory-grid');
            invGrid.innerHTML = '';
            for (let i = 0; i < this.maxInventory; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                slot.dataset.index = i;
                slot.addEventListener('click', () => this.handleInventoryClick(i));
                slot.addEventListener('mouseenter', (e) => this.showItemTooltip(e, this.inventory[i]));
                slot.addEventListener('mouseleave', () => this.hideTooltip());
                invGrid.appendChild(slot);
            }

            document.querySelectorAll('.equip-slot').forEach(slot => {
                slot.addEventListener('click', () => this.handleEquipmentClick(slot.dataset.type));
                slot.addEventListener('mouseenter', (e) => this.showItemTooltip(e, this.equipment[slot.dataset.type]));
                slot.addEventListener('mouseleave', () => this.hideTooltip());
            });
        }

        resizeCanvas() {
            const container = document.getElementById('game-area');
            const maxWidth = container.clientWidth - 20;
            const maxHeight = container.clientHeight - 40;

            this.viewWidth = Math.floor(maxWidth / this.tileSize);
            this.viewHeight = Math.floor(maxHeight / this.tileSize);

            this.canvas.width = this.viewWidth * this.tileSize;
            this.canvas.height = this.viewHeight * this.tileSize;

            this.minimap.width = 180;
            this.minimap.height = 180;

            if (this.dungeon) this.render();
        }

        startGame(playerClass) {
            const seedInput = document.getElementById('seed-input').value;
            this.seed = seedInput || Date.now();
            this.rng = new SeededRNG(this.seed);

            document.getElementById('seed-display').textContent = `Seed: ${this.seed}`;

            this.floor = 1;
            this.stats = { kills: 0, damageDealt: 0, damageTaken: 0, itemsFound: 0, goldCollected: 0, floorsCleared: 0, turnsPlayed: 0 };
            this.inventory = [];
            this.equipment = { weapon: null, helm: null, chest: null, boots: null };

            // Initialize player
            const classData = this.classes[playerClass];
            this.player = {
                x: 0, y: 0,
                class: playerClass,
                className: classData.name,
                level: 1,
                xp: 0,
                xpToLevel: 100,
                hp: 80 + classData.baseStats.vit * 2,
                maxHp: 80 + classData.baseStats.vit * 2,
                mp: 40 + classData.baseStats.int * 2,
                maxMp: 40 + classData.baseStats.int * 2,
                str: classData.baseStats.str,
                dex: classData.baseStats.dex,
                int: classData.baseStats.int,
                vit: classData.baseStats.vit,
                gold: 0,
                abilities: JSON.parse(JSON.stringify(classData.abilities)),
                buffs: [],
                char: '@',
                color: '#0f0'
            };

            document.getElementById('player-class-display').innerHTML = `${classData.icon} ${classData.name}`;

            this.generateFloor();
            this.setupAbilityUI();

            document.getElementById('start-modal').classList.add('hidden');

            this.audio.init();
            this.log(`You descend into ${this.dungeon.name}...`, 'info');
            this.log(this.dungeon.lore, 'info');

            this.render();
        }

        generateFloor() {
            const floorRng = new SeededRNG(`${this.seed}-floor-${this.floor}`);
            const generator = new DungeonGenerator(floorRng, this.floor);
            this.dungeon = generator.generate();

            this.player.x = this.dungeon.playerStart.x;
            this.player.y = this.dungeon.playerStart.y;

            this.entities = this.dungeon.entities;
            this.items = this.dungeon.items;

            // Initialize exploration
            this.explored = Array(this.dungeon.height).fill(null).map(() => Array(this.dungeon.width).fill(false));
            this.visible = Array(this.dungeon.height).fill(null).map(() => Array(this.dungeon.width).fill(false));

            this.updateVisibility();
            this.updateUI();

            document.getElementById('floor-display').textContent = `Floor ${this.floor}`;
        }

        setupAbilityUI() {
            const container = document.getElementById('abilities');
            container.innerHTML = '';

            this.player.abilities.forEach((ability, i) => {
                const btn = document.createElement('div');
                btn.className = 'ability-btn';
                btn.innerHTML = `
                    <span class="icon">${ability.icon}</span>
                    <span class="key">${i + 1}</span>
                    ${ability.cooldown > 0 ? `<div class="cooldown-overlay">${ability.cooldown}</div>` : ''}
                `;
                btn.title = `${ability.name} (${ability.cost} MP)`;
                btn.addEventListener('click', () => this.useAbility(i));
                container.appendChild(btn);
            });
        }

        handleInput(e) {
            if (this.animating) return;

            let dx = 0, dy = 0;
            let handled = false;

            switch (e.key.toLowerCase()) {
                case 'w': case 'arrowup': dy = -1; handled = true; break;
                case 's': case 'arrowdown': dy = 1; handled = true; break;
                case 'a': case 'arrowleft': dx = -1; handled = true; break;
                case 'd': case 'arrowright': dx = 1; handled = true; break;
                case 'e': this.pickupItem(); handled = true; break;
                case ' ': this.wait(); handled = true; break;
                case '1': case '2': case '3': case '4':
                    this.useAbility(parseInt(e.key) - 1);
                    handled = true;
                    break;
            }

            if (handled) e.preventDefault();

            if (dx !== 0 || dy !== 0) {
                this.movePlayer(dx, dy);
            }
        }

        handleClick(e) {
            // Click to move/attack later
        }

        movePlayer(dx, dy) {
            const newX = this.player.x + dx;
            const newY = this.player.y + dy;

            if (!this.isValidMove(newX, newY)) return;

            // Check for enemy
            const enemy = this.entities.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                this.attack(this.player, enemy);
            } else {
                this.player.x = newX;
                this.player.y = newY;
                this.checkTile();
            }

            this.endTurn();
        }

        isValidMove(x, y) {
            if (x < 0 || x >= this.dungeon.width || y < 0 || y >= this.dungeon.height) return false;
            const tile = this.dungeon.tiles[y][x];
            return tile.type !== 'wall';
        }

        checkTile() {
            const tile = this.dungeon.tiles[this.player.y][this.player.x];

            if (tile.type === 'stairs') {
                this.nextFloor();
            } else if (tile.type === 'trap' && tile.hidden) {
                this.triggerTrap(tile);
            } else if (tile.type === 'shrine' && !tile.used) {
                this.useShrine(tile);
            }

            // Check for items at location
            const item = this.items.find(i => i.x === this.player.x && i.y === this.player.y);
            if (item) {
                this.log(`You see: ${item.name}`, 'item');
            }

            // Update room description
            const room = this.dungeon.rooms.find(r =>
                this.player.x >= r.x && this.player.x < r.x + r.w &&
                this.player.y >= r.y && this.player.y < r.y + r.h
            );
            if (room && room.description) {
                document.getElementById('room-description').textContent = room.description;
            }
        }

        triggerTrap(tile) {
            tile.hidden = false;
            tile.char = '^';
            tile.color = '#f00';

            this.log(`You triggered a ${tile.trapType} trap!`, 'damage');
            this.damageEntity(this.player, tile.damage);
            this.audio.play('playerHit');
        }

        useShrine(tile) {
            tile.used = true;
            tile.color = '#444';

            switch (tile.shrineType) {
                case 'healing':
                    this.player.hp = this.player.maxHp;
                    this.log('The shrine restores your health!', 'heal');
                    break;
                case 'mana':
                    this.player.mp = this.player.maxMp;
                    this.log('The shrine restores your mana!', 'heal');
                    break;
                case 'blessing':
                    const stat = this.rng.choose(['str', 'dex', 'int', 'vit']);
                    this.player[stat] += 2;
                    this.log(`The shrine blesses you with +2 ${stat.toUpperCase()}!`, 'heal');
                    break;
                case 'cursed':
                    this.player.hp = Math.floor(this.player.hp / 2);
                    this.player.gold += 100;
                    this.log('The cursed shrine drains your life but grants gold!', 'damage');
                    break;
            }

            this.audio.play('ability');
        }

        nextFloor() {
            this.floor++;
            this.stats.floorsCleared++;
            this.audio.play('stairs');
            this.log(`Descending to floor ${this.floor}...`, 'info');

            // Heal slightly between floors
            this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.floor(this.player.maxHp * 0.2));

            this.generateFloor();
            this.render();
        }

        attack(attacker, defender) {
            const isPlayer = attacker === this.player;
            let damage = this.calculateDamage(attacker, defender);

            // Critical hit chance
            const critChance = isPlayer ? (this.player.dex / 100) : 0.05;
            const isCrit = Math.random() < critChance;
            if (isCrit) {
                damage = Math.floor(damage * 1.5);
            }

            this.damageEntity(defender, damage, isCrit);

            const logClass = isPlayer ? 'damage' : 'log-damage';
            this.log(
                `${attacker.name || 'You'} ${isCrit ? 'CRITICALLY ' : ''}hit ${defender.name || 'the enemy'} for ${damage} damage!`,
                isCrit ? 'critical' : (isPlayer ? 'info' : 'damage')
            );

            this.audio.play(isPlayer ? 'hit' : 'playerHit');

            if (isPlayer) {
                this.stats.damageDealt += damage;
            } else {
                this.stats.damageTaken += damage;
            }
        }

        calculateDamage(attacker, defender) {
            let baseDamage;

            if (attacker === this.player) {
                baseDamage = this.player.str + (this.equipment.weapon?.damage || 5);
            } else {
                baseDamage = attacker.damage;
            }

            // Apply defense
            const defense = defender === this.player ?
                this.getPlayerDefense() :
                (defender.defense || 0);

            const finalDamage = Math.max(1, baseDamage - Math.floor(defense / 2));
            return finalDamage + Math.floor(Math.random() * 5);
        }

        getPlayerDefense() {
            let defense = 0;
            for (const slot of ['helm', 'chest', 'boots']) {
                if (this.equipment[slot]) {
                    defense += this.equipment[slot].defense || 0;
                }
            }
            return defense + Math.floor(this.player.vit / 2);
        }

        damageEntity(entity, damage, isCrit = false) {
            entity.hp -= damage;

            // Show damage number
            this.showDamageNumber(entity.x, entity.y, damage, isCrit, entity === this.player);

            if (entity.hp <= 0) {
                if (entity === this.player) {
                    this.gameOver();
                } else {
                    this.killEnemy(entity);
                }
            }
        }

        showDamageNumber(x, y, amount, isCrit, isPlayerDamage) {
            const screenX = (x - this.player.x + Math.floor(this.viewWidth / 2)) * this.tileSize + this.tileSize / 2;
            const screenY = (y - this.player.y + Math.floor(this.viewHeight / 2)) * this.tileSize;

            const el = document.createElement('div');
            el.className = 'damage-number';
            el.textContent = amount;
            el.style.left = screenX + 'px';
            el.style.top = screenY + 'px';
            el.style.color = isCrit ? '#ff0' : (isPlayerDamage ? '#f66' : '#fff');
            el.style.fontSize = isCrit ? '1.5em' : '1em';

            document.getElementById('game-area').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        killEnemy(enemy) {
            const index = this.entities.indexOf(enemy);
            if (index > -1) {
                this.entities.splice(index, 1);
            }

            this.stats.kills++;
            this.player.gold += enemy.goldDrop;
            this.stats.goldCollected += enemy.goldDrop;

            this.log(`${enemy.name} defeated! +${enemy.goldDrop} gold, +${enemy.xpValue} XP`, 'item');
            this.audio.play('death');

            this.gainXP(enemy.xpValue);

            // Chance to drop item
            if (Math.random() < 0.3) {
                const floorRng = new SeededRNG(`${this.seed}-drop-${this.stats.kills}`);
                const generator = new DungeonGenerator(floorRng, this.floor);
                const item = generator.generateItem(enemy.x, enemy.y);
                this.items.push(item);
                this.log(`${enemy.name} dropped ${item.name}!`, 'item');
            }
        }

        gainXP(amount) {
            this.player.xp += amount;

            while (this.player.xp >= this.player.xpToLevel) {
                this.player.xp -= this.player.xpToLevel;
                this.levelUp();
            }
        }

        levelUp() {
            this.player.level++;
            this.player.xpToLevel = Math.floor(this.player.xpToLevel * 1.5);

            // Show level up modal
            const modal = document.getElementById('levelup-modal');
            const choices = document.getElementById('levelup-choices');
            choices.innerHTML = '';

            const stats = [
                { stat: 'str', name: 'Strength', desc: '+5 damage' },
                { stat: 'dex', name: 'Dexterity', desc: '+5% crit' },
                { stat: 'int', name: 'Intelligence', desc: '+10 MP' },
                { stat: 'vit', name: 'Vitality', desc: '+15 HP' }
            ];

            stats.forEach(s => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.innerHTML = `${s.name}<br><small>${s.desc}</small>`;
                btn.onclick = () => {
                    this.player[s.stat] += 3;
                    if (s.stat === 'vit') {
                        this.player.maxHp += 15;
                        this.player.hp += 15;
                    }
                    if (s.stat === 'int') {
                        this.player.maxMp += 10;
                        this.player.mp += 10;
                    }
                    modal.classList.add('hidden');
                    this.updateUI();
                };
                choices.appendChild(btn);
            });

            modal.classList.remove('hidden');

            this.audio.play('levelup');
            this.log(`LEVEL UP! You are now level ${this.player.level}!`, 'critical');
        }

        wait() {
            this.log('You wait...', 'info');
            this.endTurn();
        }

        endTurn() {
            this.stats.turnsPlayed++;

            // Reduce cooldowns
            this.player.abilities.forEach(a => {
                if (a.cooldown > 0) a.cooldown--;
            });

            // Process buffs
            this.player.buffs = this.player.buffs.filter(b => {
                b.duration--;
                return b.duration > 0;
            });

            // Regenerate small amount of MP
            this.player.mp = Math.min(this.player.maxMp, this.player.mp + 1);

            // Enemy turns
            this.processEnemyTurns();

            this.updateVisibility();
            this.updateUI();
            this.render();
        }

        processEnemyTurns() {
            for (const enemy of this.entities) {
                if (enemy.type !== 'enemy') continue;

                const dist = Math.abs(enemy.x - this.player.x) + Math.abs(enemy.y - this.player.y);

                // Only act if visible or close
                if (dist > 15) continue;

                if (dist === 1) {
                    // Attack player
                    this.attack(enemy, this.player);
                } else if (dist < 10) {
                    // Move toward player
                    this.moveEnemyToward(enemy, this.player.x, this.player.y);
                }
            }
        }

        moveEnemyToward(enemy, targetX, targetY) {
            const dx = Math.sign(targetX - enemy.x);
            const dy = Math.sign(targetY - enemy.y);

            // Try horizontal first, then vertical
            const moves = Math.random() > 0.5 ?
                [[dx, 0], [0, dy], [-dx, 0], [0, -dy]] :
                [[0, dy], [dx, 0], [0, -dy], [-dx, 0]];

            for (const [mx, my] of moves) {
                if (mx === 0 && my === 0) continue;
                const newX = enemy.x + mx;
                const newY = enemy.y + my;

                if (this.isValidMove(newX, newY) &&
                    !this.entities.some(e => e.x === newX && e.y === newY) &&
                    !(newX === this.player.x && newY === this.player.y)) {
                    enemy.x = newX;
                    enemy.y = newY;
                    break;
                }
            }
        }

        useAbility(index) {
            const ability = this.player.abilities[index];
            if (!ability) return;

            if (ability.cooldown > 0) {
                this.log(`${ability.name} is on cooldown (${ability.cooldown} turns)`, 'info');
                return;
            }

            if (this.player.mp < ability.cost) {
                this.log(`Not enough mana for ${ability.name}!`, 'info');
                return;
            }

            this.player.mp -= ability.cost;
            ability.cooldown = ability.maxCooldown;

            this.audio.play('ability');
            this.log(`You use ${ability.name}!`, 'info');

            // Apply ability effect
            this.applyAbilityEffect(ability);

            this.endTurn();
        }

        applyAbilityEffect(ability) {
            const nearbyEnemies = this.entities.filter(e => {
                const dist = Math.abs(e.x - this.player.x) + Math.abs(e.y - this.player.y);
                return e.type === 'enemy' && dist <= (ability.range || 1);
            });

            switch (ability.effect) {
                case 'aoe':
                    nearbyEnemies.forEach(e => {
                        const damage = Math.floor(this.calculateDamage(this.player, e) * (ability.damage || 1));
                        this.damageEntity(e, damage);
                        this.log(`${e.name} takes ${damage} damage!`, 'damage');
                    });
                    break;

                case 'stun':
                    if (nearbyEnemies.length > 0) {
                        const target = nearbyEnemies[0];
                        const damage = Math.floor(this.calculateDamage(this.player, target) * (ability.damage || 1));
                        this.damageEntity(target, damage);
                    }
                    break;

                case 'fire':
                case 'chain':
                    if (nearbyEnemies.length > 0) {
                        const target = nearbyEnemies[0];
                        const damage = Math.floor((this.player.int + 10) * (ability.damage || 1));
                        this.damageEntity(target, damage);
                        this.log(`${target.name} takes ${damage} magical damage!`, 'damage');
                    }
                    break;

                case 'freeze':
                    nearbyEnemies.forEach(e => {
                        const damage = Math.floor((this.player.int + 5) * (ability.damage || 1));
                        this.damageEntity(e, damage);
                    });
                    break;

                case 'buff':
                case 'rage':
                    this.player.buffs.push({ type: ability.effect, duration: ability.duration || 5 });
                    this.log(`You feel empowered!`, 'heal');
                    break;

                case 'shield':
                    this.player.buffs.push({ type: 'shield', duration: ability.duration || 5, amount: 30 });
                    this.log(`A magical shield surrounds you!`, 'heal');
                    break;

                case 'invisible':
                    this.player.buffs.push({ type: 'invisible', duration: ability.duration || 3 });
                    this.log(`You fade into the shadows...`, 'info');
                    break;

                case 'poison':
                    nearbyEnemies.forEach(e => {
                        e.poisoned = ability.duration || 4;
                    });
                    break;

                case 'reveal':
                    // Reveal all tiles temporarily
                    for (let y = 0; y < this.dungeon.height; y++) {
                        for (let x = 0; x < this.dungeon.width; x++) {
                            this.explored[y][x] = true;
                        }
                    }
                    this.log(`The dungeon layout is revealed!`, 'info');
                    break;

                default:
                    if (nearbyEnemies.length > 0) {
                        const target = nearbyEnemies[0];
                        const damage = Math.floor(this.calculateDamage(this.player, target) * (ability.damage || 1));
                        this.damageEntity(target, damage);
                    }
            }
        }

        pickupItem() {
            const item = this.items.find(i => i.x === this.player.x && i.y === this.player.y);
            if (!item) {
                this.log('Nothing to pick up here.', 'info');
                return;
            }

            if (item.consumable) {
                this.useConsumable(item);
                this.items.splice(this.items.indexOf(item), 1);
            } else if (this.inventory.length < this.maxInventory) {
                this.inventory.push(item);
                this.items.splice(this.items.indexOf(item), 1);
                this.stats.itemsFound++;
                this.log(`Picked up ${item.name}`, 'item');
                this.audio.play('pickup');
            } else {
                this.log('Inventory full!', 'info');
            }

            this.updateUI();
        }

        useConsumable(item) {
            if (item.potionType) {
                switch (item.potionType) {
                    case 'health':
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.value);
                        this.log(`Restored ${item.value} health!`, 'heal');
                        break;
                    case 'mana':
                        this.player.mp = Math.min(this.player.maxMp, this.player.mp + item.value);
                        this.log(`Restored ${item.value} mana!`, 'heal');
                        break;
                    case 'strength':
                        this.player.buffs.push({ type: 'strength', duration: 10, amount: item.value });
                        this.log(`Strength increased temporarily!`, 'heal');
                        break;
                    case 'defense':
                        this.player.buffs.push({ type: 'defense', duration: 10, amount: item.value });
                        this.log(`Defense increased temporarily!`, 'heal');
                        break;
                }
            } else if (item.scrollType) {
                switch (item.scrollType) {
                    case 'fireball':
                        const enemies = this.entities.filter(e => e.type === 'enemy');
                        enemies.slice(0, 3).forEach(e => this.damageEntity(e, 30));
                        this.log('Flames engulf your enemies!', 'damage');
                        break;
                    case 'teleport':
                        const room = this.rng.choose(this.dungeon.rooms);
                        this.player.x = Math.floor(room.x + room.w / 2);
                        this.player.y = Math.floor(room.y + room.h / 2);
                        this.log('You teleport to a new location!', 'info');
                        break;
                    case 'mapping':
                        for (let y = 0; y < this.dungeon.height; y++) {
                            for (let x = 0; x < this.dungeon.width; x++) {
                                this.explored[y][x] = true;
                            }
                        }
                        this.log('The dungeon map is revealed!', 'info');
                        break;
                }
            }

            this.audio.play('pickup');
        }

        handleInventoryClick(index) {
            const item = this.inventory[index];
            if (!item) return;

            if (item.slot) {
                // Equip item
                const oldItem = this.equipment[item.slot];
                this.equipment[item.slot] = item;
                this.inventory.splice(index, 1);

                if (oldItem) {
                    this.inventory.push(oldItem);
                }

                this.log(`Equipped ${item.name}`, 'item');
                this.audio.play('pickup');
            } else if (item.consumable) {
                this.useConsumable(item);
                this.inventory.splice(index, 1);
            }

            this.updateUI();
        }

        handleEquipmentClick(slot) {
            const item = this.equipment[slot];
            if (!item) return;

            if (this.inventory.length < this.maxInventory) {
                this.equipment[slot] = null;
                this.inventory.push(item);
                this.log(`Unequipped ${item.name}`, 'info');
                this.updateUI();
            } else {
                this.log('Inventory full!', 'info');
            }
        }

        showItemTooltip(e, item) {
            if (!item) return;

            const tooltip = document.getElementById('tooltip');
            const rarityColors = {
                common: 'var(--common)',
                uncommon: 'var(--uncommon)',
                rare: 'var(--rare)',
                epic: 'var(--epic)',
                legendary: 'var(--legendary)'
            };

            let statsHtml = '';
            if (item.stats) {
                for (const [key, value] of Object.entries(item.stats)) {
                    statsHtml += `<div>+${value} ${key}</div>`;
                }
            }
            if (item.elementalDamage) {
                statsHtml += `<div>+${item.elementalDamage.amount} ${item.elementalDamage.type} damage</div>`;
            }

            tooltip.innerHTML = `
                <div class="item-name" style="color: ${rarityColors[item.rarity]}">${item.name}</div>
                <div class="item-type">${item.rarity} ${item.itemType}</div>
                ${statsHtml ? `<div class="item-stats">${statsHtml}</div>` : ''}
                ${item.lore ? `<div class="item-lore">"${item.lore}"</div>` : ''}
            `;

            tooltip.style.left = e.pageX + 10 + 'px';
            tooltip.style.top = e.pageY + 10 + 'px';
            tooltip.classList.add('visible');
        }

        hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        updateVisibility() {
            // Clear visibility
            for (let y = 0; y < this.dungeon.height; y++) {
                for (let x = 0; x < this.dungeon.width; x++) {
                    this.visible[y][x] = false;
                }
            }

            // Simple raycasting for visibility
            const radius = 8;
            for (let angle = 0; angle < 360; angle += 2) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                for (let dist = 0; dist <= radius; dist += 0.5) {
                    const x = Math.round(this.player.x + dx * dist);
                    const y = Math.round(this.player.y + dy * dist);

                    if (x < 0 || x >= this.dungeon.width || y < 0 || y >= this.dungeon.height) break;

                    this.visible[y][x] = true;
                    this.explored[y][x] = true;

                    if (this.dungeon.tiles[y][x].type === 'wall') break;
                }
            }
        }

        updateUI() {
            // Health bar
            const healthPercent = (this.player.hp / this.player.maxHp) * 100;
            document.querySelector('.health-bar .stat-bar-fill').style.width = healthPercent + '%';
            document.querySelector('.health-bar .stat-bar-text').textContent = `${this.player.hp} / ${this.player.maxHp} HP`;

            // Mana bar
            const manaPercent = (this.player.mp / this.player.maxMp) * 100;
            document.querySelector('.mana-bar .stat-bar-fill').style.width = manaPercent + '%';
            document.querySelector('.mana-bar .stat-bar-text').textContent = `${this.player.mp} / ${this.player.maxMp} MP`;

            // XP bar
            const xpPercent = (this.player.xp / this.player.xpToLevel) * 100;
            document.querySelector('.xp-bar .stat-bar-fill').style.width = xpPercent + '%';
            document.querySelector('.xp-bar .stat-bar-text').textContent = `Level ${this.player.level} (${this.player.xp}/${this.player.xpToLevel} XP)`;

            // Stats
            document.getElementById('stat-str').textContent = this.player.str;
            document.getElementById('stat-dex').textContent = this.player.dex;
            document.getElementById('stat-int').textContent = this.player.int;
            document.getElementById('stat-vit').textContent = this.player.vit;
            document.getElementById('stat-gold').textContent = this.player.gold;

            // Inventory
            document.getElementById('inv-count').textContent = `${this.inventory.length}/${this.maxInventory}`;
            const slots = document.querySelectorAll('#inventory-grid .inv-slot');
            slots.forEach((slot, i) => {
                const item = this.inventory[i];
                slot.textContent = item ? item.char : '';
                slot.className = 'inv-slot' + (item ? ` ${item.rarity}` : '');
            });

            // Equipment
            for (const [slotName, item] of Object.entries(this.equipment)) {
                const slot = document.querySelector(`.equip-slot[data-type="${slotName}"]`);
                slot.textContent = item ? item.char : '';
                slot.className = 'equip-slot' + (item ? ` ${item.rarity}` : '');
            }

            // Abilities
            this.setupAbilityUI();
        }

        log(message, type = 'info') {
            const logContent = document.getElementById('log-content');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;

            // Limit log entries
            while (logContent.children.length > 100) {
                logContent.removeChild(logContent.firstChild);
            }
        }

        render() {
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            const centerX = Math.floor(this.viewWidth / 2);
            const centerY = Math.floor(this.viewHeight / 2);

            // Draw tiles
            for (let vy = 0; vy < this.viewHeight; vy++) {
                for (let vx = 0; vx < this.viewWidth; vx++) {
                    const worldX = this.player.x - centerX + vx;
                    const worldY = this.player.y - centerY + vy;

                    if (worldX < 0 || worldX >= this.dungeon.width ||
                        worldY < 0 || worldY >= this.dungeon.height) continue;

                    const tile = this.dungeon.tiles[worldY][worldX];
                    const isVisible = this.visible[worldY][worldX];
                    const isExplored = this.explored[worldY][worldX];

                    if (!isExplored) continue;

                    const screenX = vx * this.tileSize;
                    const screenY = vy * this.tileSize;

                    let color = tile.color;
                    if (!isVisible) {
                        // Darken explored but not visible tiles
                        color = this.darkenColor(color, 0.4);
                    }

                    this.ctx.fillStyle = color;
                    this.ctx.font = `${this.tileSize - 2}px monospace`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(tile.char, screenX + this.tileSize / 2, screenY + this.tileSize / 2);
                }
            }

            // Draw items
            for (const item of this.items) {
                const vx = item.x - this.player.x + centerX;
                const vy = item.y - this.player.y + centerY;

                if (vx < 0 || vx >= this.viewWidth || vy < 0 || vy >= this.viewHeight) continue;
                if (!this.visible[item.y][item.x]) continue;

                const screenX = vx * this.tileSize;
                const screenY = vy * this.tileSize;

                this.ctx.fillStyle = item.color;
                this.ctx.fillText(item.char, screenX + this.tileSize / 2, screenY + this.tileSize / 2);
            }

            // Draw entities
            for (const entity of this.entities) {
                const vx = entity.x - this.player.x + centerX;
                const vy = entity.y - this.player.y + centerY;

                if (vx < 0 || vx >= this.viewWidth || vy < 0 || vy >= this.viewHeight) continue;
                if (!this.visible[entity.y][entity.x]) continue;

                const screenX = vx * this.tileSize;
                const screenY = vy * this.tileSize;

                this.ctx.fillStyle = entity.color;
                this.ctx.fillText(entity.char, screenX + this.tileSize / 2, screenY + this.tileSize / 2);

                // Health bar for enemies
                if (entity.hp < entity.maxHp) {
                    const barWidth = this.tileSize - 4;
                    const barHeight = 3;
                    const healthPercent = entity.hp / entity.maxHp;

                    this.ctx.fillStyle = '#300';
                    this.ctx.fillRect(screenX + 2, screenY - 2, barWidth, barHeight);
                    this.ctx.fillStyle = '#f00';
                    this.ctx.fillRect(screenX + 2, screenY - 2, barWidth * healthPercent, barHeight);
                }
            }

            // Draw player
            const playerScreenX = centerX * this.tileSize;
            const playerScreenY = centerY * this.tileSize;

            this.ctx.fillStyle = this.player.color;
            this.ctx.fillText(this.player.char, playerScreenX + this.tileSize / 2, playerScreenY + this.tileSize / 2);

            // Render minimap
            this.renderMinimap();
        }

        renderMinimap() {
            const scale = Math.min(
                this.minimap.width / this.dungeon.width,
                this.minimap.height / this.dungeon.height
            );

            this.minimapCtx.fillStyle = '#000';
            this.minimapCtx.fillRect(0, 0, this.minimap.width, this.minimap.height);

            for (let y = 0; y < this.dungeon.height; y++) {
                for (let x = 0; x < this.dungeon.width; x++) {
                    if (!this.explored[y][x]) continue;

                    const tile = this.dungeon.tiles[y][x];
                    let color = '#222';

                    if (tile.type === 'floor') color = '#333';
                    else if (tile.type === 'stairs') color = '#ff0';
                    else if (tile.type === 'shrine') color = '#0ff';

                    if (this.visible[y][x]) {
                        color = tile.type === 'wall' ? '#444' : '#555';
                    }

                    this.minimapCtx.fillStyle = color;
                    this.minimapCtx.fillRect(x * scale, y * scale, scale, scale);
                }
            }

            // Draw entities on minimap
            for (const entity of this.entities) {
                if (!this.visible[entity.y][entity.x]) continue;
                this.minimapCtx.fillStyle = '#f00';
                this.minimapCtx.fillRect(entity.x * scale, entity.y * scale, scale * 2, scale * 2);
            }

            // Draw player
            this.minimapCtx.fillStyle = '#0f0';
            this.minimapCtx.fillRect(this.player.x * scale - 1, this.player.y * scale - 1, scale * 3, scale * 3);
        }

        darkenColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.floor(parseInt(hex.substr(0, 2), 16) * amount);
            const g = Math.floor(parseInt(hex.substr(2, 2), 16) * amount);
            const b = Math.floor(parseInt(hex.substr(4, 2), 16) * amount);
            return `rgb(${r},${g},${b})`;
        }

        gameOver() {
            this.audio.play('death');

            const modal = document.getElementById('death-modal');
            const stats = document.getElementById('death-stats');

            const killedBy = this.entities.find(e =>
                Math.abs(e.x - this.player.x) <= 1 && Math.abs(e.y - this.player.y) <= 1
            );

            document.getElementById('death-message').textContent = killedBy ?
                `Slain by ${killedBy.name} on floor ${this.floor}` :
                `You perished on floor ${this.floor}`;

            stats.innerHTML = `
                <div><span>Floor Reached</span><span>${this.floor}</span></div>
                <div><span>Level</span><span>${this.player.level}</span></div>
                <div><span>Enemies Killed</span><span>${this.stats.kills}</span></div>
                <div><span>Damage Dealt</span><span>${this.stats.damageDealt}</span></div>
                <div><span>Damage Taken</span><span>${this.stats.damageTaken}</span></div>
                <div><span>Gold Collected</span><span>${this.stats.goldCollected}</span></div>
                <div><span>Items Found</span><span>${this.stats.itemsFound}</span></div>
                <div><span>Turns Played</span><span>${this.stats.turnsPlayed}</span></div>
                <div><span>Seed</span><span>${this.seed}</span></div>
            `;

            modal.classList.remove('hidden');

            // Save to bestiary/codex
            this.saveRunData();
        }

        saveRunData() {
            const runData = {
                seed: this.seed,
                class: this.player.class,
                floor: this.floor,
                level: this.player.level,
                stats: this.stats,
                date: new Date().toISOString()
            };

            let runs = JSON.parse(localStorage.getItem('infiniteDungeon_runs') || '[]');
            runs.push(runData);
            runs = runs.slice(-50); // Keep last 50 runs
            localStorage.setItem('infiniteDungeon_runs', JSON.stringify(runs));
        }

        exportRun() {
            const data = {
                seed: this.seed,
                class: this.player.class,
                floor: this.floor,
                player: this.player,
                stats: this.stats,
                inventory: this.inventory,
                equipment: this.equipment
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `infinite-dungeon-run-${this.seed}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        restart() {
            document.getElementById('death-modal').classList.add('hidden');
            document.getElementById('start-modal').classList.remove('hidden');
            document.getElementById('seed-input').value = '';
            document.getElementById('log-content').innerHTML = '';
        }
    }

    // Initialize game
    const game = new Game();
    </script>
</body>
</html>
