<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Forest of Infinite Recursion</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #001122 0%, #003344 50%, #002233 100%);
            overflow: hidden;
            position: relative;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            image-rendering: optimizeSpeed;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            cursor: pointer;
            background: rgba(0, 200, 255, 0.2);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .data-controls button:hover {
            background: rgba(0, 200, 255, 0.4);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .info-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 15px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #0ff;
            border-radius: 10px;
            color: #0ff;
            font-size: 14px;
            backdrop-filter: blur(10px);
            max-width: 300px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 0 10px #0ff;
        }

        .info-panel .scale-indicator {
            font-size: 18px;
            font-weight: bold;
            color: #0f0;
            margin: 10px 0;
            text-shadow: 0 0 10px #0f0;
        }

        .controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }

        .controls div {
            margin: 5px 0;
            opacity: 0.8;
        }

        .controls .key {
            display: inline-block;
            padding: 2px 6px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 3px;
            margin-right: 5px;
            font-weight: bold;
        }

        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: 24px;
            text-align: center;
            z-index: 2000;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #0ff;
            border-radius: 50%;
            pointer-events: none;
            animation: float 10s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            50% { transform: translateY(-100px) translateX(50px); }
        }

        .scale-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 0%, rgba(0, 255, 255, 0.3) 100%);
            pointer-events: none;
            opacity: 0;
            z-index: 999;
            animation: pulse 0.5s ease-out;
        }

        @keyframes pulse {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; }
            100% { opacity: 0; transform: scale(2); }
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="loadingIndicator">
        <div>Generating Fractal Forest...</div>
        <div style="font-size: 14px; margin-top: 10px;">Prepare for infinite recursion</div>
    </div>

    <div class="info-panel">
        <h3>Fractal Forest Explorer</h3>
        <div class="scale-indicator">Scale: <span id="scaleLevel">1.00x</span></div>
        <div>Recursion Level: <span id="recursionLevel">1</span>/5</div>
        <div>Trees Visible: <span id="treeCount">0</span></div>
        <div style="margin-top: 10px; color: #fff;">
            <small id="ecosystem">Surface Forest</small>
        </div>
        <div class="controls">
            <div><span class="key">WASD/Arrows</span> Move</div>
            <div><span class="key">Scroll/+-</span> Zoom</div>
            <div><span class="key">Space</span> Underground</div>
            <div><span class="key">R</span> Reset View</div>
            <div><span class="key">F</span> Toggle Fractals</div>
        </div>
    </div>

    <div class="data-controls">
        <button onclick="exportData()">Export Pattern</button>
        <button onclick="document.getElementById('importFile').click()">Import Pattern</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
        <button onclick="regenerateForest()">New Forest</button>
    </div>

    <script>
        // Application configuration
        const APP_NAME = 'fractal-forest-recursion';
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let appData = {
            camera: { x: 0, y: 0, zoom: 1 },
            playerScale: 1,
            recursionDepth: 1,
            underground: false,
            fractalSeed: Math.random(),
            patterns: [],
            savedForests: [],
            settings: {
                maxRecursion: 5,
                fractalDetail: 'high',
                particlesEnabled: true,
                animationSpeed: 1
            }
        };

        // Load saved data
        const savedData = localStorage.getItem(APP_NAME);
        if (savedData) {
            try {
                appData = { ...appData, ...JSON.parse(savedData) };
            } catch (e) {
                console.error('Failed to load saved data');
            }
        }

        // Game variables
        let trees = [];
        let particles = [];
        let caveSystem = [];
        let miniForests = new Map();
        let animationFrame = 0;
        let keys = {};
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let scaleTransitioning = false;

        // Fractal parameters
        const GOLDEN_RATIO = 1.618033988749895;
        const FRACTAL_ANGLE = Math.PI / 7;
        const BRANCH_REDUCTION = 0.7;
        const MIN_BRANCH_SIZE = 2;
        const RECURSION_SCALES = [1, 0.3, 0.1, 0.03, 0.01];

        // Ecosystems at different scales
        const ECOSYSTEMS = [
            { name: "Surface Forest", colors: ["#2d5016", "#3a6324", "#4a7c30"], bg: "#001122" },
            { name: "Canopy Realm", colors: ["#0a4020", "#135030", "#1c6040"], bg: "#002233" },
            { name: "Micro Grove", colors: ["#402050", "#503060", "#604070"], bg: "#110022" },
            { name: "Quantum Woods", colors: ["#204080", "#3050a0", "#4060c0"], bg: "#000033" },
            { name: "Subatomic Garden", colors: ["#802040", "#a03050", "#c04060"], bg: "#220011" }
        ];

        // Initialize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Fractal tree generation
        class FractalTree {
            constructor(x, y, size, depth = 0, angle = -Math.PI/2, parent = null) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.depth = depth;
                this.angle = angle;
                this.parent = parent;
                this.branches = [];
                this.leaves = [];
                this.miniForest = null;
                this.swayPhase = Math.random() * Math.PI * 2;
                this.color = this.getColorForDepth();

                if (size > MIN_BRANCH_SIZE && depth < appData.settings.maxRecursion) {
                    this.generateBranches();
                }

                if (size <= MIN_BRANCH_SIZE * 2) {
                    this.generateLeaves();
                }
            }

            getColorForDepth() {
                const ecosystem = ECOSYSTEMS[Math.min(this.depth, ECOSYSTEMS.length - 1)];
                return ecosystem.colors[Math.floor(Math.random() * ecosystem.colors.length)];
            }

            generateBranches() {
                const branchCount = Math.floor(2 + Math.random() * 2);
                for (let i = 0; i < branchCount; i++) {
                    const angleOffset = (Math.random() - 0.5) * FRACTAL_ANGLE * 2;
                    const newAngle = this.angle + angleOffset;
                    const branchLength = this.size * (0.6 + Math.random() * 0.3);
                    const endX = this.x + Math.cos(newAngle) * branchLength;
                    const endY = this.y + Math.sin(newAngle) * branchLength;

                    this.branches.push(new FractalTree(
                        endX, endY,
                        this.size * BRANCH_REDUCTION,
                        this.depth + 1,
                        newAngle,
                        this
                    ));
                }

                // Add mini forest at certain depths
                if (this.depth === 1 && Math.random() > 0.7) {
                    this.miniForest = this.generateMiniForest();
                }
            }

            generateLeaves() {
                const leafCount = Math.floor(3 + Math.random() * 5);
                for (let i = 0; i < leafCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.size * 2;
                    this.leaves.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        size: 2 + Math.random() * 3,
                        color: this.getLeafColor(),
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            getLeafColor() {
                const colors = ["#00ff00", "#00ff44", "#44ff00", "#00ffaa", "#aaff00"];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            generateMiniForest() {
                const miniTrees = [];
                const count = 3 + Math.floor(Math.random() * 5);
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                    const dist = 10 + Math.random() * 20;
                    miniTrees.push(new FractalTree(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        this.size * 0.2,
                        this.depth + 2
                    ));
                }
                return miniTrees;
            }

            draw(ctx, camera, time) {
                const sway = Math.sin(time + this.swayPhase) * 0.02 * (this.depth + 1);

                ctx.save();
                ctx.translate(camera.x + this.x * camera.zoom, camera.y + this.y * camera.zoom);
                ctx.rotate(sway);

                // Draw trunk/branch
                ctx.strokeStyle = this.color;
                ctx.lineWidth = Math.max(1, this.size * camera.zoom * 0.3);
                ctx.lineCap = 'round';

                if (this.parent) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    const dx = (this.parent.x - this.x) * camera.zoom;
                    const dy = (this.parent.y - this.y) * camera.zoom;
                    ctx.lineTo(dx, dy);
                    ctx.stroke();
                }

                // Draw leaves
                this.leaves.forEach(leaf => {
                    const leafSway = Math.sin(time * 2 + leaf.phase) * 2;
                    ctx.fillStyle = leaf.color + '88';
                    ctx.beginPath();
                    ctx.arc(
                        leaf.x * camera.zoom + leafSway,
                        leaf.y * camera.zoom,
                        leaf.size * camera.zoom,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });

                ctx.restore();

                // Draw branches recursively
                this.branches.forEach(branch => branch.draw(ctx, camera, time));

                // Draw mini forest if zoomed in enough
                if (this.miniForest && camera.zoom > 2) {
                    this.miniForest.forEach(tree => tree.draw(ctx, camera, time));
                }
            }
        }

        // Cave system generation
        class FractalCave {
            constructor(x, y, size, depth = 0) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.depth = depth;
                this.tunnels = [];
                this.crystals = [];

                if (size > 5 && depth < 3) {
                    this.generateTunnels();
                }
                this.generateCrystals();
            }

            generateTunnels() {
                const tunnelCount = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < tunnelCount; i++) {
                    const angle = (Math.PI * 2 / tunnelCount) * i + Math.random() * 0.5;
                    const length = this.size * (0.5 + Math.random() * 0.5);
                    const endX = this.x + Math.cos(angle) * length;
                    const endY = this.y + Math.sin(angle) * length;

                    this.tunnels.push({
                        start: { x: this.x, y: this.y },
                        end: { x: endX, y: endY },
                        width: this.size * 0.3,
                        cave: new FractalCave(endX, endY, this.size * 0.6, this.depth + 1)
                    });
                }
            }

            generateCrystals() {
                const crystalCount = 3 + Math.floor(Math.random() * 7);
                for (let i = 0; i < crystalCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.size;
                    this.crystals.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        size: 2 + Math.random() * 5,
                        color: this.getCrystalColor(),
                        glow: Math.random() * 0.5 + 0.5
                    });
                }
            }

            getCrystalColor() {
                const colors = ["#00ffff", "#ff00ff", "#ffff00", "#00ff00", "#ff0088"];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            draw(ctx, camera, time) {
                // Draw tunnels
                this.tunnels.forEach(tunnel => {
                    ctx.strokeStyle = '#004466';
                    ctx.lineWidth = tunnel.width * camera.zoom;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(
                        camera.x + tunnel.start.x * camera.zoom,
                        camera.y + tunnel.start.y * camera.zoom
                    );
                    ctx.lineTo(
                        camera.x + tunnel.end.x * camera.zoom,
                        camera.y + tunnel.end.y * camera.zoom
                    );
                    ctx.stroke();

                    tunnel.cave.draw(ctx, camera, time);
                });

                // Draw crystals with glow
                this.crystals.forEach(crystal => {
                    const pulse = Math.sin(time * 3 + crystal.x) * 0.2 + 1;
                    const glowSize = crystal.size * crystal.glow * pulse;

                    // Glow effect
                    ctx.fillStyle = crystal.color + '33';
                    ctx.beginPath();
                    ctx.arc(
                        camera.x + crystal.x * camera.zoom,
                        camera.y + crystal.y * camera.zoom,
                        glowSize * camera.zoom * 2,
                        0, Math.PI * 2
                    );
                    ctx.fill();

                    // Crystal core
                    ctx.fillStyle = crystal.color;
                    ctx.beginPath();
                    ctx.arc(
                        camera.x + crystal.x * camera.zoom,
                        camera.y + crystal.y * camera.zoom,
                        crystal.size * camera.zoom,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });
            }
        }

        // Initialize forest
        function generateForest() {
            trees = [];
            const treeCount = 15 + Math.floor(Math.random() * 10);

            for (let i = 0; i < treeCount; i++) {
                const x = (Math.random() - 0.5) * 800;
                const y = 200 + Math.random() * 100;
                const size = 30 + Math.random() * 40;
                trees.push(new FractalTree(x, y, size));
            }

            // Generate cave system
            caveSystem = [];
            for (let i = 0; i < 5; i++) {
                const x = (Math.random() - 0.5) * 600;
                const y = 400 + Math.random() * 200;
                caveSystem.push(new FractalCave(x, y, 50 + Math.random() * 50));
            }

            // Generate floating particles
            particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 2 + 1,
                    color: `hsl(${180 + Math.random() * 60}, 100%, 50%)`,
                    phase: Math.random() * Math.PI * 2
                });
            }

            setTimeout(() => {
                document.getElementById('loadingIndicator').style.display = 'none';
            }, 500);
        }

        // Update function
        function update() {
            animationFrame += 0.01 * appData.settings.animationSpeed;

            // Update particles
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;

                if (p.x < 0) p.x = canvas.width;
                if (p.x > canvas.width) p.x = 0;
                if (p.y < 0) p.y = canvas.height;
                if (p.y > canvas.height) p.y = 0;
            });

            // Handle keyboard input
            const moveSpeed = 5 / appData.camera.zoom;
            if (keys['w'] || keys['ArrowUp']) appData.camera.y += moveSpeed;
            if (keys['s'] || keys['ArrowDown']) appData.camera.y -= moveSpeed;
            if (keys['a'] || keys['ArrowLeft']) appData.camera.x += moveSpeed;
            if (keys['d'] || keys['ArrowRight']) appData.camera.x -= moveSpeed;

            // Update UI
            document.getElementById('scaleLevel').textContent = appData.camera.zoom.toFixed(2) + 'x';
            document.getElementById('recursionLevel').textContent = Math.min(
                Math.floor(Math.log2(appData.camera.zoom) + 1),
                appData.settings.maxRecursion
            );
            document.getElementById('treeCount').textContent = countVisibleTrees();

            // Update ecosystem based on zoom
            const ecosystemIndex = Math.min(
                Math.floor(Math.log2(appData.camera.zoom)),
                ECOSYSTEMS.length - 1
            );
            const ecosystem = ECOSYSTEMS[Math.max(0, ecosystemIndex)];
            document.getElementById('ecosystem').textContent =
                appData.underground ? "Underground Caves" : ecosystem.name;
        }

        function countVisibleTrees() {
            let count = 0;
            const countTree = (tree) => {
                count++;
                tree.branches.forEach(countTree);
                if (tree.miniForest && appData.camera.zoom > 2) {
                    tree.miniForest.forEach(countTree);
                }
            };
            trees.forEach(countTree);
            return count;
        }

        // Render function
        function render() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

            if (appData.underground) {
                gradient.addColorStop(0, '#000033');
                gradient.addColorStop(0.5, '#001144');
                gradient.addColorStop(1, '#002255');
            } else {
                const ecosystem = ECOSYSTEMS[Math.min(
                    Math.floor(Math.log2(appData.camera.zoom)),
                    ECOSYSTEMS.length - 1
                )];
                const bg = ecosystem.bg;
                gradient.addColorStop(0, bg);
                gradient.addColorStop(0.5, bg + 'cc');
                gradient.addColorStop(1, bg);
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw particles
            if (appData.settings.particlesEnabled) {
                particles.forEach(p => {
                    const pulse = Math.sin(animationFrame * 2 + p.phase) * 0.3 + 1;
                    ctx.fillStyle = p.color + '66';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * pulse, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Apply camera transform
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);

            if (appData.underground) {
                // Draw cave system
                caveSystem.forEach(cave => cave.draw(ctx, appData.camera, animationFrame));
            } else {
                // Draw trees
                trees.forEach(tree => tree.draw(ctx, appData.camera, animationFrame));
            }

            ctx.restore();
        }

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Input handlers
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === ' ') {
                e.preventDefault();
                appData.underground = !appData.underground;
                showScaleTransition();
            } else if (e.key === 'r' || e.key === 'R') {
                appData.camera = { x: 0, y: 0, zoom: 1 };
            } else if (e.key === 'f' || e.key === 'F') {
                appData.settings.particlesEnabled = !appData.settings.particlesEnabled;
            } else if (e.key === '+' || e.key === '=') {
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                zoomOut();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                appData.camera.x += dx;
                appData.camera.y += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom(zoomFactor);
        });

        function zoom(factor) {
            const newZoom = appData.camera.zoom * factor;
            if (newZoom >= 0.1 && newZoom <= 100) {
                appData.camera.zoom = newZoom;

                // Show transition effect at certain thresholds
                const thresholds = [0.5, 1, 2, 5, 10, 20, 50];
                if (thresholds.some(t =>
                    (appData.camera.zoom < t && newZoom >= t) ||
                    (appData.camera.zoom > t && newZoom <= t)
                )) {
                    showScaleTransition();
                }
            }
        }

        function zoomIn() {
            zoom(1.2);
        }

        function zoomOut() {
            zoom(0.8);
        }

        function showScaleTransition() {
            if (scaleTransitioning) return;
            scaleTransitioning = true;

            const transition = document.createElement('div');
            transition.className = 'scale-transition';
            document.body.appendChild(transition);

            setTimeout(() => {
                transition.remove();
                scaleTransitioning = false;
            }, 500);
        }

        // Data management
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const exportData = {
                ...appData,
                forestPattern: trees.map(tree => ({
                    x: tree.x,
                    y: tree.y,
                    size: tree.size,
                    seed: tree.swayPhase
                })),
                cavePattern: caveSystem.map(cave => ({
                    x: cave.x,
                    y: cave.y,
                    size: cave.size
                })),
                timestamp: new Date().toISOString()
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `fractal-forest-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    appData = { ...appData, ...imported };

                    // Reconstruct forest from pattern
                    if (imported.forestPattern) {
                        trees = imported.forestPattern.map(pattern =>
                            new FractalTree(pattern.x, pattern.y, pattern.size)
                        );
                    }

                    if (imported.cavePattern) {
                        caveSystem = imported.cavePattern.map(pattern =>
                            new FractalCave(pattern.x, pattern.y, pattern.size)
                        );
                    }

                    saveData();
                    showScaleTransition();
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        function regenerateForest() {
            appData.fractalSeed = Math.random();
            generateForest();
            saveData();
            showScaleTransition();
        }

        // Auto-save periodically
        setInterval(saveData, 10000);

        // Initialize and start
        generateForest();
        gameLoop();
    </script>
</body>
</html>