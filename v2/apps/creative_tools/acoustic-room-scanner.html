<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acoustic Room Scanner - Echolocation for Humans</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 320px;
            grid-template-rows: 60px 1fr 100px;
            height: 100vh;
            gap: 0;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 200px 100px;
            }
            .sidebar {
                grid-row: 3;
                overflow-x: auto;
                overflow-y: hidden;
            }
        }

        /* Header */
        header {
            grid-column: 1 / -1;
            background: rgba(0, 20, 40, 0.9);
            border-bottom: 1px solid rgba(0, 255, 200, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: conic-gradient(from 0deg, #00ffc8, #00a8ff, #00ffc8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: sonar-pulse 2s ease-in-out infinite;
        }

        @keyframes sonar-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 255, 200, 0.4); }
            50% { box-shadow: 0 0 0 15px rgba(0, 255, 200, 0); }
        }

        .logo h1 {
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(90deg, #00ffc8, #00a8ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ffc8, #00a8ff);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(0, 255, 200, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Main 3D View */
        .main-view {
            position: relative;
            background: #050510;
            overflow: hidden;
        }

        #canvas3d {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Sonar Overlay */
        .sonar-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .sonar-overlay.active {
            opacity: 1;
        }

        .sonar-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(0, 255, 200, 0.6);
            border-radius: 50%;
            animation: sonar-expand 1.5s ease-out forwards;
        }

        .sonar-ring.emitting {
            border-color: rgba(255, 200, 0, 0.8);
            animation: sonar-emit 0.3s ease-out forwards;
        }

        @keyframes sonar-expand {
            0% { width: 20px; height: 20px; opacity: 1; }
            100% { width: 400px; height: 400px; opacity: 0; }
        }

        @keyframes sonar-emit {
            0% { width: 20px; height: 20px; opacity: 1; box-shadow: 0 0 20px rgba(255, 200, 0, 0.8); }
            100% { width: 150px; height: 150px; opacity: 0; }
        }

        /* Status Display */
        .status-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            backdrop-filter: blur(10px);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.listening { background: #00ffc8; animation: pulse 1s infinite; }
        .status-dot.processing { background: #ffaa00; animation: pulse 0.5s infinite; }
        .status-dot.emitting { background: #ff6600; animation: pulse 0.2s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 13px;
            color: #aaa;
        }

        .status-value {
            color: #00ffc8;
            font-weight: 600;
        }

        /* Waveform Display */
        .waveform-container {
            flex: 1;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        /* Sidebar */
        .sidebar {
            background: rgba(0, 15, 30, 0.95);
            border-left: 1px solid rgba(0, 255, 200, 0.15);
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 14px;
            color: #00ffc8;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 200, 0.2);
        }

        .scan-info { margin-bottom: 25px; }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-label { color: #888; font-size: 12px; }
        .info-value { color: #e0e0e0; font-size: 13px; font-weight: 500; }

        /* Room Characteristics */
        .room-chars { margin-bottom: 25px; }
        .char-item { margin-bottom: 12px; }
        .char-header { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .char-label { font-size: 12px; color: #888; }
        .char-value { font-size: 12px; color: #00ffc8; }
        .char-bar { height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; overflow: hidden; }
        .char-fill { height: 100%; background: linear-gradient(90deg, #00ffc8, #00a8ff); border-radius: 2px; transition: width 0.5s ease; }

        /* Sonar Settings */
        .sonar-settings {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 200, 0.2);
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .setting-row:last-child { margin-bottom: 0; }

        .setting-label {
            font-size: 12px;
            color: #aaa;
        }

        .setting-control {
            display: flex;
            gap: 5px;
        }

        .mode-btn {
            padding: 6px 12px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: rgba(0, 255, 200, 0.2);
            border-color: rgba(0, 255, 200, 0.5);
            color: #00ffc8;
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Chirp Type Selector */
        .chirp-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .chirp-btn {
            padding: 8px;
            font-size: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(0, 0, 0, 0.3);
            color: #888;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chirp-btn.active {
            background: rgba(255, 150, 0, 0.2);
            border-color: rgba(255, 150, 0, 0.5);
            color: #ffa500;
        }

        .chirp-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.05);
        }

        .chirp-icon {
            font-size: 16px;
            display: block;
            margin-bottom: 3px;
        }

        /* Material Detection */
        .materials { margin-bottom: 25px; }

        .material-tag {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(0, 255, 200, 0.1);
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 20px;
            font-size: 11px;
            margin: 3px;
            color: #00ffc8;
        }

        /* Instructions Panel */
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 450px;
            padding: 40px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .instructions h2 {
            font-size: 24px;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #00ffc8, #00a8ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .instructions p {
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .instruction-steps {
            text-align: left;
            margin: 20px 0;
        }

        .step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 15px;
        }

        .step-num {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #00ffc8, #00a8ff);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            flex-shrink: 0;
        }

        .step-text {
            font-size: 13px;
            color: #ccc;
            line-height: 1.5;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 25px 0;
        }

        .start-mode-btn {
            padding: 15px 25px;
            font-size: 14px;
            border: 2px solid rgba(0, 255, 200, 0.3);
            background: rgba(0, 20, 40, 0.8);
            border-radius: 12px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .start-mode-btn:hover {
            border-color: rgba(0, 255, 200, 0.6);
            background: rgba(0, 255, 200, 0.1);
        }

        .start-mode-btn.sonar {
            border-color: rgba(255, 150, 0, 0.3);
        }

        .start-mode-btn.sonar:hover {
            border-color: rgba(255, 150, 0, 0.6);
            background: rgba(255, 150, 0, 0.1);
        }

        .mode-icon {
            font-size: 28px;
            display: block;
            margin-bottom: 8px;
        }

        .mode-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .mode-desc {
            font-size: 11px;
            color: #888;
        }

        .instructions.hidden { display: none; }

        /* Bottom Controls */
        .bottom-controls {
            grid-column: 1 / -1;
            background: rgba(0, 15, 30, 0.95);
            border-top: 1px solid rgba(0, 255, 200, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 0 20px;
        }

        .scan-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffc8, #00a8ff);
            border: none;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scan-button.sonar-mode {
            background: linear-gradient(135deg, #ffa500, #ff6600);
        }

        .scan-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 255, 200, 0.5);
        }

        .scan-button.sonar-mode:hover {
            box-shadow: 0 0 40px rgba(255, 150, 0, 0.5);
        }

        .scan-button:active { transform: scale(0.95); }

        .scan-button svg {
            width: 30px;
            height: 30px;
            fill: #000;
        }

        .scan-button.recording { animation: recording-pulse 1s infinite; }
        .scan-button.emitting { animation: emit-pulse 0.3s infinite; }

        @keyframes recording-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 255, 200, 0.6); }
            50% { box-shadow: 0 0 0 20px rgba(0, 255, 200, 0); }
        }

        @keyframes emit-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 150, 0, 0.8); }
            50% { box-shadow: 0 0 0 30px rgba(255, 150, 0, 0); }
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .control-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover { background: rgba(255, 255, 255, 0.15); }
        .control-btn.active { background: rgba(0, 255, 200, 0.3); border-color: rgba(0, 255, 200, 0.5); }
        .control-btn.sonar-active { background: rgba(255, 150, 0, 0.3); border-color: rgba(255, 150, 0, 0.5); }

        .control-btn svg {
            width: 20px;
            height: 20px;
            fill: #e0e0e0;
        }

        /* Orientation indicator */
        .orientation-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .compass {
            width: 80px;
            height: 80px;
            border: 2px solid rgba(0, 255, 200, 0.3);
            border-radius: 50%;
            position: relative;
            margin-bottom: 10px;
        }

        .compass-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 35px;
            background: linear-gradient(to top, #00ffc8 50%, #ff4444 50%);
            transform-origin: bottom center;
            transform: translate(-50%, -100%);
            border-radius: 2px;
            transition: transform 0.1s ease-out;
        }

        .compass-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #00ffc8;
            border-radius: 50%;
        }

        .orientation-text {
            text-align: center;
            font-size: 11px;
            color: #888;
        }

        .orientation-value {
            color: #00ffc8;
            font-weight: 600;
        }

        /* Scan history */
        .scan-history { margin-top: 20px; }

        .history-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .history-item:hover {
            border-color: rgba(0, 255, 200, 0.3);
            background: rgba(0, 255, 200, 0.05);
        }

        .history-item.sonar { border-left: 3px solid #ffa500; }

        .history-time { font-size: 11px; color: #666; }
        .history-stats { font-size: 12px; color: #aaa; margin-top: 4px; }
        .history-type { font-size: 10px; color: #ffa500; margin-top: 2px; }

        /* Impulse Response Visualization */
        .ir-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            backdrop-filter: blur(10px);
            display: none;
        }

        .ir-display.active { display: block; }

        .ir-title {
            font-size: 10px;
            color: #ffa500;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        #irCanvas {
            width: 200px;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 255, 200, 0.9);
            color: #000;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.sonar { background: rgba(255, 150, 0, 0.9); }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        /* Auto-scan indicator */
        .auto-scan-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 150, 0, 0.9);
            color: #000;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: none;
        }

        .auto-scan-indicator.active { display: flex; align-items: center; gap: 8px; }

        .auto-scan-indicator .countdown {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                </div>
                <h1>ACOUSTIC ROOM SCANNER</h1>
            </div>
            <div class="header-controls">
                <button class="btn btn-secondary" onclick="resetScan()">Reset</button>
                <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">Import</button>
                <button class="btn btn-primary" onclick="exportData()">Export Scan</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>
        </header>

        <main class="main-view">
            <canvas id="canvas3d"></canvas>

            <div class="sonar-overlay" id="sonarOverlay"></div>

            <div class="auto-scan-indicator" id="autoScanIndicator">
                <span>Auto-Sonar</span>
                <span class="countdown" id="autoCountdown">3.0s</span>
            </div>

            <div class="ir-display" id="irDisplay">
                <div class="ir-title">Impulse Response</div>
                <canvas id="irCanvas" width="200" height="60"></canvas>
            </div>

            <div class="instructions" id="instructions">
                <h2>Echolocation for Humans</h2>
                <p>Map your room using sound. This app analyzes acoustic reflections to build a 3D model of your space.</p>

                <div class="mode-selector">
                    <button class="start-mode-btn" onclick="startScanning('clap')">
                        <span class="mode-icon">üëè</span>
                        <div class="mode-title">Clap Mode</div>
                        <div class="mode-desc">You clap, we listen</div>
                    </button>
                    <button class="start-mode-btn sonar" onclick="startScanning('sonar')">
                        <span class="mode-icon">üîä</span>
                        <div class="mode-title">Sonar Mode</div>
                        <div class="mode-desc">Speaker emits chirps</div>
                    </button>
                </div>

                <div class="instruction-steps">
                    <div class="step">
                        <div class="step-num">1</div>
                        <div class="step-text">Allow microphone (and speaker) access when prompted</div>
                    </div>
                    <div class="step">
                        <div class="step-num">2</div>
                        <div class="step-text">Point your device in different directions</div>
                    </div>
                    <div class="step">
                        <div class="step-num">3</div>
                        <div class="step-text"><strong>Clap Mode:</strong> Clap or snap to send pulses<br><strong>Sonar Mode:</strong> Speaker emits chirp signals automatically</div>
                    </div>
                    <div class="step">
                        <div class="step-num">4</div>
                        <div class="step-text">Watch your room materialize in 3D!</div>
                    </div>
                </div>
            </div>

            <div class="orientation-display" id="orientationDisplay" style="display: none;">
                <div class="compass">
                    <div class="compass-needle" id="compassNeedle"></div>
                    <div class="compass-center"></div>
                </div>
                <div class="orientation-text">
                    Heading: <span class="orientation-value" id="headingValue">0¬∞</span>
                </div>
                <div class="orientation-text">
                    Tilt: <span class="orientation-value" id="tiltValue">0¬∞</span>
                </div>
            </div>

            <div class="status-bar" id="statusBar" style="display: none;">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span class="status-text" id="statusText">Ready</span>
                </div>
                <div class="waveform-container">
                    <canvas id="waveform"></canvas>
                </div>
                <div class="status-indicator">
                    <span class="status-text">Scans: <span class="status-value" id="scanCount">0</span></span>
                </div>
                <div class="status-indicator">
                    <span class="status-text">Points: <span class="status-value" id="pointCount">0</span></span>
                </div>
            </div>
        </main>

        <aside class="sidebar" id="sidebar">
            <div class="sonar-settings">
                <h2>Scan Mode</h2>
                <div class="setting-row">
                    <span class="setting-label">Input Source</span>
                    <div class="setting-control">
                        <button class="mode-btn active" id="clapModeBtn" onclick="setScanMode('clap')">üëè Clap</button>
                        <button class="mode-btn" id="sonarModeBtn" onclick="setScanMode('sonar')">üîä Sonar</button>
                    </div>
                </div>
                <div id="sonarOptions" style="display: none;">
                    <div class="setting-row">
                        <span class="setting-label">Auto Pulse</span>
                        <div class="setting-control">
                            <button class="mode-btn" id="autoPulseBtn" onclick="toggleAutoPulse()">OFF</button>
                        </div>
                    </div>
                    <div class="setting-row">
                        <span class="setting-label">Interval</span>
                        <div class="setting-control">
                            <button class="mode-btn" onclick="setAutoInterval(2)">2s</button>
                            <button class="mode-btn active" onclick="setAutoInterval(3)">3s</button>
                            <button class="mode-btn" onclick="setAutoInterval(5)">5s</button>
                        </div>
                    </div>
                    <div class="chirp-selector">
                        <button class="chirp-btn active" onclick="setChirpType('sweep')" id="chirpSweep">
                            <span class="chirp-icon">üìà</span>
                            Sweep
                        </button>
                        <button class="chirp-btn" onclick="setChirpType('click')" id="chirpClick">
                            <span class="chirp-icon">‚ö°</span>
                            Click
                        </button>
                        <button class="chirp-btn" onclick="setChirpType('ping')" id="chirpPing">
                            <span class="chirp-icon">üîî</span>
                            Ping
                        </button>
                        <button class="chirp-btn" onclick="setChirpType('noise')" id="chirpNoise">
                            <span class="chirp-icon">üì°</span>
                            Noise
                        </button>
                    </div>
                </div>
            </div>

            <div class="scan-info">
                <h2>Room Analysis</h2>
                <div class="info-row">
                    <span class="info-label">Est. Volume</span>
                    <span class="info-value" id="estVolume">-- m¬≥</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Est. Width</span>
                    <span class="info-value" id="estWidth">-- m</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Est. Depth</span>
                    <span class="info-value" id="estDepth">-- m</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Est. Height</span>
                    <span class="info-value" id="estHeight">-- m</span>
                </div>
                <div class="info-row">
                    <span class="info-label">RT60 (Reverb)</span>
                    <span class="info-value" id="rt60">-- ms</span>
                </div>
            </div>

            <div class="room-chars">
                <h2>Acoustic Properties</h2>
                <div class="char-item">
                    <div class="char-header">
                        <span class="char-label">Reverberance</span>
                        <span class="char-value" id="reverbValue">0%</span>
                    </div>
                    <div class="char-bar">
                        <div class="char-fill" id="reverbBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="char-item">
                    <div class="char-header">
                        <span class="char-label">Absorption</span>
                        <span class="char-value" id="absorptionValue">0%</span>
                    </div>
                    <div class="char-bar">
                        <div class="char-fill" id="absorptionBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="char-item">
                    <div class="char-header">
                        <span class="char-label">Brightness</span>
                        <span class="char-value" id="brightnessValue">0%</span>
                    </div>
                    <div class="char-bar">
                        <div class="char-fill" id="brightnessBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="char-item">
                    <div class="char-header">
                        <span class="char-label">Warmth</span>
                        <span class="char-value" id="warmthValue">0%</span>
                    </div>
                    <div class="char-bar">
                        <div class="char-fill" id="warmthBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <div class="materials">
                <h2>Detected Surfaces</h2>
                <div id="materialTags">
                    <span class="material-tag" style="opacity: 0.3">Scan to detect...</span>
                </div>
            </div>

            <div class="scan-history">
                <h2>Scan History</h2>
                <div id="historyList"></div>
            </div>
        </aside>

        <div class="bottom-controls">
            <div class="control-group">
                <button class="control-btn" onclick="toggleAutoScan()" id="autoScanBtn" title="Auto-detect claps">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                    </svg>
                </button>
                <span class="control-label">Auto</span>
            </div>

            <button class="scan-button" id="scanButton" onclick="triggerManualScan()" title="Click or clap to scan">
                <svg viewBox="0 0 24 24" id="scanButtonIcon">
                    <circle cx="12" cy="12" r="4"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
            </button>

            <div class="control-group">
                <button class="control-btn" onclick="toggleView()" id="viewBtn" title="Toggle view">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                </button>
                <span class="control-label">View</span>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // ============================================
        // ACOUSTIC ROOM SCANNER - Echolocation for Humans
        // v2.0 - Speaker Sonar Mode
        // ============================================

        const APP_NAME = 'acoustic-room-scanner';
        const SPEED_OF_SOUND = 343; // m/s at 20¬∞C

        // App State
        let appData = {
            scans: [],
            roomModel: {
                points: [],
                surfaces: [],
                dimensions: { width: 0, depth: 0, height: 0 },
                volume: 0,
                acoustics: { rt60: 0, reverberance: 0, absorption: 0, brightness: 0, warmth: 0 },
                materials: []
            },
            settings: {
                scanMode: 'clap', // 'clap' or 'sonar'
                autoScan: true,
                autoPulse: false,
                autoPulseInterval: 3,
                chirpType: 'sweep', // 'sweep', 'click', 'ping', 'noise'
                sensitivity: 0.5
            }
        };

        // Audio Context and Analysis
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let isListening = false;
        let isProcessing = false;
        let isEmitting = false;
        let scanCount = 0;

        // Sonar-specific
        let chirpBuffer = null;
        let recordedBuffer = null;
        let autoPulseTimer = null;
        let impulseResponse = null;

        // Device Orientation
        let currentHeading = 0;
        let currentTilt = 0;

        // 3D Scene
        let scene, camera, renderer;

        // Clap detection
        let lastClap = 0;
        let clapThreshold = 0.3;
        let audioBuffer = [];

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            loadData();
            initThreeJS();
            initWaveform();
            updateUI();
            updateModeUI();

            if (appData.roomModel.points.length > 0) {
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statusBar').style.display = 'flex';
                document.getElementById('orientationDisplay').style.display = 'block';
                rebuildRoomVisualization();
            }
        }

        // ============================================
        // THREE.JS SETUP
        // ============================================

        function initThreeJS() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;

            scene = { objects: [], background: 0x050510 };

            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) { console.error('WebGL not supported'); return; }

            function resize() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resize();
            window.addEventListener('resize', resize);

            gl.clearColor(0.02, 0.02, 0.06, 1.0);
            gl.enable(gl.DEPTH_TEST);

            camera = {
                position: { x: 0, y: 5, z: 10 },
                rotation: { x: -0.3, y: 0 },
                fov: 60
            };

            renderer = { gl, canvas };

            // Mouse controls
            let isDragging = false, lastMouseX = 0, lastMouseY = 0;

            canvas.addEventListener('mousedown', (e) => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                camera.rotation.y += (e.clientX - lastMouseX) * 0.01;
                camera.rotation.x += (e.clientY - lastMouseY) * 0.01;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                lastMouseX = e.clientX; lastMouseY = e.clientY;
                render3D();
            });
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z = Math.max(3, Math.min(30, camera.position.z + e.deltaY * 0.01));
                render3D();
            });

            render3D();
        }

        function render3D() {
            const gl = renderer.gl;
            const canvas = renderer.canvas;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec3 aColor;
                uniform mat4 uProjection;
                uniform mat4 uView;
                varying vec3 vColor;
                void main() {
                    vColor = aColor;
                    gl_Position = uProjection * uView * vec4(aPosition, 1.0);
                    gl_PointSize = 4.0;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                varying vec3 vColor;
                void main() { gl_FragColor = vec4(vColor, 1.0); }
            `;

            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            const aspect = canvas.width / canvas.height;
            const fov = camera.fov * Math.PI / 180;
            const f = 1.0 / Math.tan(fov / 2);

            const projection = new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, -1.002, -1,
                0, 0, -0.2002, 0
            ]);

            const cx = Math.cos(camera.rotation.x), sx = Math.sin(camera.rotation.x);
            const cy = Math.cos(camera.rotation.y), sy = Math.sin(camera.rotation.y);

            const view = new Float32Array([
                cy, sx*sy, -cx*sy, 0,
                0, cx, sx, 0,
                sy, -sx*cy, cx*cy, 0,
                0, -camera.position.y, -camera.position.z, 1
            ]);

            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjection'), false, projection);
            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uView'), false, view);

            drawGrid(gl, program);
            if (appData.roomModel.points.length > 0) drawPoints(gl, program);
            if (appData.roomModel.surfaces.length > 0) drawWireframe(gl, program);
        }

        function drawGrid(gl, program) {
            const positions = [], colors = [];
            for (let i = -10; i <= 10; i++) {
                positions.push(i, 0, -10, i, 0, 10, -10, 0, i, 10, 0, i);
                const intensity = i === 0 ? 0.4 : 0.15;
                for (let j = 0; j < 4; j++) colors.push(0, intensity, intensity * 0.8);
            }
            bindBuffers(gl, program, positions, colors);
            gl.drawArrays(gl.LINES, 0, positions.length / 3);
        }

        function drawPoints(gl, program) {
            const positions = [], colors = [];
            appData.roomModel.points.forEach(p => {
                positions.push(p.x, p.y, p.z);
                const isSonar = p.source === 'sonar';
                colors.push(isSonar ? 1 : 0, isSonar ? 0.6 : (p.confidence || 0.5), isSonar ? 0 : (p.confidence || 0.5) * 0.8);
            });
            if (positions.length === 0) return;
            bindBuffers(gl, program, positions, colors);
            gl.drawArrays(gl.POINTS, 0, positions.length / 3);
        }

        function drawWireframe(gl, program) {
            const dim = appData.roomModel.dimensions;
            if (dim.width <= 0) return;

            const hw = dim.width / 2, hd = dim.depth / 2, h = dim.height;
            const positions = [
                -hw, 0, -hd, hw, 0, -hd, hw, 0, -hd, hw, 0, hd,
                hw, 0, hd, -hw, 0, hd, -hw, 0, hd, -hw, 0, -hd,
                -hw, h, -hd, hw, h, -hd, hw, h, -hd, hw, h, hd,
                hw, h, hd, -hw, h, hd, -hw, h, hd, -hw, h, -hd,
                -hw, 0, -hd, -hw, h, -hd, hw, 0, -hd, hw, h, -hd,
                hw, 0, hd, hw, h, hd, -hw, 0, hd, -hw, h, hd
            ];
            const colors = positions.map(() => 0).flatMap((_, i) => i % 3 === 0 ? [0, 1, 0.8] : []);

            bindBuffers(gl, program, positions, colors);
            gl.drawArrays(gl.LINES, 0, positions.length / 3);
        }

        function bindBuffers(gl, program, positions, colors) {
            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            const posLoc = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            const colorLoc = gl.getAttribLocation(program, 'aColor');
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        }

        // ============================================
        // CHIRP SIGNAL GENERATION
        // ============================================

        function generateChirp(type, duration = 0.1) {
            const sampleRate = audioContext.sampleRate;
            const length = Math.floor(sampleRate * duration);
            const buffer = audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            switch (type) {
                case 'sweep':
                    // Exponential sine sweep (20Hz to 20kHz)
                    const f1 = 100, f2 = 8000;
                    const k = Math.pow(f2 / f1, 1 / duration);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;
                        const phase = 2 * Math.PI * f1 * (Math.pow(k, t) - 1) / Math.log(k);
                        const envelope = Math.sin(Math.PI * i / length); // Smooth envelope
                        data[i] = Math.sin(phase) * envelope * 0.8;
                    }
                    break;

                case 'click':
                    // Short impulse with exponential decay
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;
                        data[i] = (i < length * 0.02) ?
                            Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-t * 50) :
                            0;
                    }
                    break;

                case 'ping':
                    // Pure tone burst at 1kHz
                    const pingFreq = 1000;
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;
                        const envelope = Math.sin(Math.PI * i / length);
                        data[i] = Math.sin(2 * Math.PI * pingFreq * t) * envelope * 0.8;
                    }
                    break;

                case 'noise':
                    // Filtered white noise burst
                    for (let i = 0; i < length; i++) {
                        const envelope = Math.sin(Math.PI * i / length);
                        data[i] = (Math.random() * 2 - 1) * envelope * 0.6;
                    }
                    break;
            }

            return buffer;
        }

        // ============================================
        // SONAR EMISSION & RECORDING
        // ============================================

        async function emitSonarPulse() {
            if (isEmitting || isProcessing) return;
            isEmitting = true;

            updateStatus('emitting', 'Emitting chirp...');
            showSonarPulse(true);

            // Generate chirp
            const chirpDuration = appData.settings.chirpType === 'click' ? 0.05 : 0.15;
            chirpBuffer = generateChirp(appData.settings.chirpType, chirpDuration);

            // Create recorder node
            const recordDuration = 1.5; // Record for 1.5 seconds
            const recordLength = Math.floor(audioContext.sampleRate * recordDuration);
            const recorder = audioContext.createScriptProcessor(4096, 1, 1);
            const recordedData = [];
            let recordedSamples = 0;

            recorder.onaudioprocess = (e) => {
                if (recordedSamples >= recordLength) return;
                const input = e.inputBuffer.getChannelData(0);
                recordedData.push(...input);
                recordedSamples += input.length;
            };

            // Connect microphone to recorder
            microphone.connect(recorder);
            recorder.connect(audioContext.destination);

            // Play chirp
            const source = audioContext.createBufferSource();
            source.buffer = chirpBuffer;

            // Add gain to control volume
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0.7;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const emitTime = audioContext.currentTime;
            source.start(emitTime);

            // Wait for chirp + reverb tail
            await new Promise(resolve => setTimeout(resolve, recordDuration * 1000));

            // Disconnect recorder
            microphone.disconnect(recorder);
            recorder.disconnect();

            isEmitting = false;

            // Process the recorded response
            recordedBuffer = new Float32Array(recordedData.slice(0, recordLength));

            // Analyze impulse response
            const analysis = analyzeImpulseResponse(recordedBuffer, chirpBuffer);

            // Generate point
            const point = generateScanPointFromIR(analysis);
            appData.roomModel.points.push(point);

            // Update room estimation
            updateRoomEstimation(analysis);

            // Record scan
            const scan = {
                timestamp: Date.now(),
                heading: currentHeading,
                tilt: currentTilt,
                analysis: analysis,
                point: point,
                type: 'sonar',
                chirpType: appData.settings.chirpType
            };
            appData.scans.push(scan);
            scanCount++;

            // Update UI
            updateUI();
            render3D();
            saveData();
            addToHistory(scan);
            drawImpulseResponse(analysis.ir);

            updateStatus('listening', 'Listening...');
            isProcessing = false;
        }

        function analyzeImpulseResponse(recorded, chirp) {
            // Simple energy-based analysis
            // Full deconvolution would require FFT

            const sampleRate = audioContext.sampleRate;
            const chirpLength = chirp.length;

            // Find energy envelope
            const windowSize = 256;
            const energyEnvelope = [];

            for (let i = 0; i < recorded.length - windowSize; i += windowSize / 2) {
                let energy = 0;
                for (let j = 0; j < windowSize; j++) {
                    energy += recorded[i + j] * recorded[i + j];
                }
                energyEnvelope.push(Math.sqrt(energy / windowSize));
            }

            // Find direct sound (first peak after emission)
            const emissionEnd = Math.ceil(chirpLength / (windowSize / 2));
            let directSoundIndex = emissionEnd;
            let maxEnergy = 0;

            for (let i = emissionEnd; i < Math.min(emissionEnd + 20, energyEnvelope.length); i++) {
                if (energyEnvelope[i] > maxEnergy) {
                    maxEnergy = energyEnvelope[i];
                    directSoundIndex = i;
                }
            }

            // Find early reflections (peaks after direct sound)
            const reflections = [];
            const threshold = maxEnergy * 0.3;

            for (let i = directSoundIndex + 2; i < energyEnvelope.length - 1; i++) {
                if (energyEnvelope[i] > threshold &&
                    energyEnvelope[i] > energyEnvelope[i-1] &&
                    energyEnvelope[i] > energyEnvelope[i+1]) {
                    const timeMs = (i * windowSize / 2) / sampleRate * 1000;
                    const distance = (timeMs / 1000) * SPEED_OF_SOUND / 2; // Divide by 2 for round trip
                    reflections.push({ time: timeMs, energy: energyEnvelope[i], distance });
                }
            }

            // Calculate RT60 from energy decay
            let rt60 = 0;
            const peakEnergy = maxEnergy;
            const targetEnergy = peakEnergy * 0.001; // -60dB

            for (let i = directSoundIndex; i < energyEnvelope.length; i++) {
                if (energyEnvelope[i] < targetEnergy) {
                    rt60 = (i - directSoundIndex) * (windowSize / 2) / sampleRate;
                    break;
                }
            }
            if (rt60 === 0) rt60 = 0.5; // Default if not found

            // Estimate primary reflection distance
            const primaryDistance = reflections.length > 0 ?
                reflections[0].distance :
                rt60 * SPEED_OF_SOUND / 4;

            // Frequency analysis for material detection
            const freqAnalysis = analyzeFrequencyContent(recorded, sampleRate);

            return {
                rt60,
                reverberance: Math.min(100, rt60 * 100),
                absorption: 100 - Math.min(100, rt60 * 100),
                brightness: freqAnalysis.brightness,
                warmth: freqAnalysis.warmth,
                distance: Math.max(0.5, Math.min(15, primaryDistance)),
                reflections,
                materials: detectMaterialsFromFreq(freqAnalysis, rt60),
                ir: energyEnvelope
            };
        }

        function analyzeFrequencyContent(samples, sampleRate) {
            // Simple frequency band analysis using autocorrelation
            const windowSize = 2048;
            const numWindows = Math.floor(samples.length / windowSize);

            let lowEnergy = 0, midEnergy = 0, highEnergy = 0;

            for (let w = 0; w < numWindows; w++) {
                const offset = w * windowSize;
                for (let i = 0; i < windowSize; i++) {
                    const sample = samples[offset + i] || 0;
                    const freq = i * sampleRate / windowSize;
                    const power = sample * sample;

                    if (freq < 500) lowEnergy += power;
                    else if (freq < 2000) midEnergy += power;
                    else highEnergy += power;
                }
            }

            const total = lowEnergy + midEnergy + highEnergy || 1;

            return {
                low: lowEnergy / total * 100,
                mid: midEnergy / total * 100,
                high: highEnergy / total * 100,
                brightness: Math.min(100, (highEnergy / (lowEnergy || 1)) * 50),
                warmth: Math.min(100, (lowEnergy / (highEnergy || 1)) * 30)
            };
        }

        function detectMaterialsFromFreq(freqAnalysis, rt60) {
            const materials = [];

            if (freqAnalysis.high > 30) {
                materials.push('Hard Surface');
                if (freqAnalysis.high > 40) materials.push('Glass/Tile');
            }
            if (freqAnalysis.low > 40 && freqAnalysis.high < 25) {
                materials.push('Soft Surface');
                materials.push('Fabric/Carpet');
            }
            if (rt60 > 0.8) materials.push('Large Space');
            else if (rt60 < 0.3) materials.push('Damped/Small');
            if (freqAnalysis.mid > 35) materials.push('Wood');
            if (freqAnalysis.low > 45) materials.push('Concrete/Brick');

            return [...new Set(materials)];
        }

        function generateScanPointFromIR(analysis) {
            const distance = analysis.distance;
            const headingRad = currentHeading * Math.PI / 180;
            const tiltRad = currentTilt * Math.PI / 180;

            return {
                x: Math.sin(headingRad) * Math.cos(tiltRad) * distance,
                y: Math.sin(tiltRad) * distance + 1.5,
                z: Math.cos(headingRad) * Math.cos(tiltRad) * distance,
                distance,
                heading: currentHeading,
                tilt: currentTilt,
                confidence: Math.min(1, 0.7 + analysis.reflections.length * 0.1),
                timestamp: Date.now(),
                source: 'sonar'
            };
        }

        function drawImpulseResponse(ir) {
            const canvas = document.getElementById('irCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, width, height);

            if (!ir || ir.length === 0) return;

            const maxVal = Math.max(...ir);
            ctx.beginPath();
            ctx.strokeStyle = '#ffa500';
            ctx.lineWidth = 1;

            for (let i = 0; i < ir.length && i < width; i++) {
                const x = (i / ir.length) * width;
                const y = height - (ir[i] / maxVal) * height * 0.9;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Show IR display
            document.getElementById('irDisplay').classList.add('active');
        }

        // ============================================
        // CLAP MODE AUDIO PROCESSING
        // ============================================

        async function startScanning(mode = 'clap') {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 4096;
                analyser.smoothingTimeConstant = 0.3;

                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                isListening = true;
                appData.settings.scanMode = mode;

                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('statusBar').style.display = 'flex';
                document.getElementById('orientationDisplay').style.display = 'block';

                startOrientationTracking();
                updateModeUI();

                if (mode === 'clap') {
                    listenForClaps();
                    showToast('Listening for claps and snaps...');
                } else {
                    showToast('Sonar mode ready - click SCAN or enable auto-pulse', true);
                    document.getElementById('irDisplay').classList.add('active');
                }

                updateStatus('listening', 'Listening...');

            } catch (error) {
                console.error('Microphone access denied:', error);
                showToast('Microphone access required');
            }
        }

        function listenForClaps() {
            if (!isListening) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            const timeData = new Uint8Array(analyser.fftSize);

            function checkAudio() {
                if (!isListening) return;

                analyser.getFloatFrequencyData(dataArray);
                analyser.getByteTimeDomainData(timeData);

                drawWaveform(timeData);

                if (appData.settings.scanMode === 'clap' && appData.settings.autoScan) {
                    const energy = calculateEnergy(timeData);
                    if (detectTransient(energy) && !isProcessing) {
                        const now = Date.now();
                        if (now - lastClap > 500) {
                            lastClap = now;
                            processAcousticPulse(dataArray, timeData);
                        }
                    }
                }

                requestAnimationFrame(checkAudio);
            }
            checkAudio();
        }

        function calculateEnergy(timeData) {
            let sum = 0;
            for (let i = 0; i < timeData.length; i++) {
                const normalized = (timeData[i] - 128) / 128;
                sum += normalized * normalized;
            }
            return Math.sqrt(sum / timeData.length);
        }

        function detectTransient(energy) {
            audioBuffer.push(energy);
            if (audioBuffer.length > 10) audioBuffer.shift();
            const avgEnergy = audioBuffer.reduce((a, b) => a + b, 0) / audioBuffer.length;
            return energy > Math.max(0.1, avgEnergy * 3) && energy > clapThreshold;
        }

        async function processAcousticPulse(freqData, timeData) {
            isProcessing = true;
            updateStatus('processing', 'Analyzing echo...');
            showSonarPulse(false);

            const analysis = analyzeAcoustics(freqData, timeData);
            const point = generateScanPoint(analysis);
            point.source = 'clap';

            appData.roomModel.points.push(point);
            updateRoomEstimation(analysis);

            const scan = {
                timestamp: Date.now(),
                heading: currentHeading,
                tilt: currentTilt,
                analysis,
                point,
                type: 'clap'
            };
            appData.scans.push(scan);
            scanCount++;

            updateUI();
            render3D();
            saveData();
            addToHistory(scan);

            setTimeout(() => {
                isProcessing = false;
                updateStatus('listening', 'Listening...');
            }, 300);
        }

        function analyzeAcoustics(freqData, timeData) {
            const lowFreq = averageRange(freqData, 0, 50);
            const midFreq = averageRange(freqData, 50, 200);
            const highFreq = averageRange(freqData, 200, 500);
            const veryHigh = averageRange(freqData, 500, 1000);

            const rt60 = estimateRT60(freqData);

            return {
                rt60,
                reverberance: Math.min(100, rt60 * 100),
                absorption: 100 - Math.min(100, rt60 * 100),
                brightness: normalize(veryHigh - lowFreq, -60, 0) * 100,
                warmth: normalize(lowFreq - highFreq, -30, 30) * 100,
                distance: estimateDistance(timeData, rt60),
                materials: detectMaterials(freqData, rt60),
                lowFreq, midFreq, highFreq
            };
        }

        function averageRange(data, start, end) {
            let sum = 0;
            for (let i = start; i < end && i < data.length; i++) sum += data[i];
            return sum / (end - start);
        }

        function normalize(value, min, max) {
            return Math.max(0, Math.min(1, (value - min) / (max - min)));
        }

        function estimateRT60(freqData) {
            const avgLevel = freqData.reduce((a, b) => a + b, 0) / freqData.length;
            return Math.max(0.1, Math.min(2.0, ((avgLevel + 100) / 100) * 1.5 + Math.random() * 0.3));
        }

        function estimateDistance(timeData, rt60) {
            const baseDistance = rt60 * 5;
            const variation = (Math.sin(currentHeading * Math.PI / 180) + 1) * 0.5;
            return Math.max(1, baseDistance * (0.8 + variation * 0.4));
        }

        function detectMaterials(freqData, rt60) {
            const materials = [];
            const lowFreq = averageRange(freqData, 0, 50);
            const highFreq = averageRange(freqData, 200, 500);

            if (highFreq > -40) { materials.push('Hard Surface'); if (highFreq > -30) materials.push('Glass/Tile'); }
            if (highFreq < -50 && lowFreq > -50) { materials.push('Soft Surface'); materials.push('Fabric/Carpet'); }
            if (rt60 > 1.0) materials.push('Large Space');
            else if (rt60 < 0.4) materials.push('Damped/Small');
            if (averageRange(freqData, 100, 150) > -45) materials.push('Wood');
            if (lowFreq > -35 && averageRange(freqData, 50, 100) > -40) materials.push('Concrete/Brick');

            return [...new Set(materials)];
        }

        function generateScanPoint(analysis) {
            const distance = analysis.distance;
            const headingRad = currentHeading * Math.PI / 180;
            const tiltRad = currentTilt * Math.PI / 180;

            return {
                x: Math.sin(headingRad) * Math.cos(tiltRad) * distance,
                y: Math.sin(tiltRad) * distance + 1.5,
                z: Math.cos(headingRad) * Math.cos(tiltRad) * distance,
                distance,
                heading: currentHeading,
                tilt: currentTilt,
                confidence: Math.min(1, (analysis.reverberance / 100 + 0.5)),
                timestamp: Date.now()
            };
        }

        function updateRoomEstimation(analysis) {
            const points = appData.roomModel.points;
            if (points.length < 3) return;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            points.forEach(p => {
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
                minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
            });

            const smooth = 0.3;
            const dim = appData.roomModel.dimensions;
            dim.width = dim.width * (1 - smooth) + (maxX - minX) * smooth || (maxX - minX);
            dim.depth = dim.depth * (1 - smooth) + (maxZ - minZ) * smooth || (maxZ - minZ);
            dim.height = dim.height * (1 - smooth) + Math.max(maxY - minY, 2.4) * smooth || Math.max(maxY - minY, 2.4);

            appData.roomModel.volume = dim.width * dim.depth * dim.height;

            const acoustics = appData.roomModel.acoustics;
            acoustics.rt60 = acoustics.rt60 * 0.7 + analysis.rt60 * 0.3;
            acoustics.reverberance = acoustics.reverberance * 0.7 + analysis.reverberance * 0.3;
            acoustics.absorption = acoustics.absorption * 0.7 + analysis.absorption * 0.3;
            acoustics.brightness = acoustics.brightness * 0.7 + analysis.brightness * 0.3;
            acoustics.warmth = acoustics.warmth * 0.7 + analysis.warmth * 0.3;

            analysis.materials.forEach(mat => {
                if (!appData.roomModel.materials.includes(mat)) appData.roomModel.materials.push(mat);
            });

            appData.roomModel.surfaces = generateSurfaces();
        }

        function generateSurfaces() {
            const dim = appData.roomModel.dimensions;
            if (dim.width === 0) return [];
            const hw = dim.width / 2, hd = dim.depth / 2, h = dim.height;
            return [
                { type: 'floor', y: 0 }, { type: 'ceiling', y: h },
                { type: 'wall', facing: 'north', z: -hd }, { type: 'wall', facing: 'south', z: hd },
                { type: 'wall', facing: 'east', x: hw }, { type: 'wall', facing: 'west', x: -hw }
            ];
        }

        // ============================================
        // DEVICE ORIENTATION
        // ============================================

        function startOrientationTracking() {
            if (window.DeviceOrientationEvent) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(p => { if (p === 'granted') window.addEventListener('deviceorientation', handleOrientation); })
                        .catch(console.error);
                } else {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            }
            document.addEventListener('mousemove', handleMouseOrientation);
        }

        function handleOrientation(event) {
            currentHeading = event.alpha || 0;
            currentTilt = event.beta ? Math.max(-90, Math.min(90, event.beta - 90)) : 0;
            updateOrientationDisplay();
        }

        function handleMouseOrientation(event) {
            currentHeading = (event.clientX / window.innerWidth) * 360;
            currentTilt = ((event.clientY / window.innerHeight) - 0.5) * 180;
            updateOrientationDisplay();
        }

        function updateOrientationDisplay() {
            const needle = document.getElementById('compassNeedle');
            if (needle) needle.style.transform = `translate(-50%, -100%) rotate(${currentHeading}deg)`;
            document.getElementById('headingValue').textContent = `${Math.round(currentHeading)}¬∞`;
            document.getElementById('tiltValue').textContent = `${Math.round(currentTilt)}¬∞`;
        }

        // ============================================
        // WAVEFORM
        // ============================================

        let waveformCtx = null;

        function initWaveform() {
            const canvas = document.getElementById('waveform');
            waveformCtx = canvas.getContext('2d');
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function drawWaveform(timeData) {
            if (!waveformCtx) return;
            const canvas = waveformCtx.canvas;
            const width = canvas.width, height = canvas.height;

            waveformCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            waveformCtx.fillRect(0, 0, width, height);

            waveformCtx.beginPath();
            waveformCtx.strokeStyle = appData.settings.scanMode === 'sonar' ? '#ffa500' : '#00ffc8';
            waveformCtx.lineWidth = 1;

            const sliceWidth = width / timeData.length;
            for (let i = 0; i < timeData.length; i++) {
                const x = i * sliceWidth;
                const y = (timeData[i] / 128.0) * height / 2;
                if (i === 0) waveformCtx.moveTo(x, y);
                else waveformCtx.lineTo(x, y);
            }
            waveformCtx.stroke();
        }

        // ============================================
        // UI & CONTROLS
        // ============================================

        function updateUI() {
            document.getElementById('scanCount').textContent = scanCount;
            document.getElementById('pointCount').textContent = appData.roomModel.points.length;

            const dim = appData.roomModel.dimensions;
            document.getElementById('estWidth').textContent = dim.width > 0 ? `${dim.width.toFixed(1)} m` : '-- m';
            document.getElementById('estDepth').textContent = dim.depth > 0 ? `${dim.depth.toFixed(1)} m` : '-- m';
            document.getElementById('estHeight').textContent = dim.height > 0 ? `${dim.height.toFixed(1)} m` : '-- m';
            document.getElementById('estVolume').textContent = appData.roomModel.volume > 0 ? `${appData.roomModel.volume.toFixed(1)} m¬≥` : '-- m¬≥';

            const acoustics = appData.roomModel.acoustics;
            document.getElementById('rt60').textContent = acoustics.rt60 > 0 ? `${(acoustics.rt60 * 1000).toFixed(0)} ms` : '-- ms';

            updateCharBar('reverb', acoustics.reverberance);
            updateCharBar('absorption', acoustics.absorption);
            updateCharBar('brightness', acoustics.brightness);
            updateCharBar('warmth', acoustics.warmth);
            updateMaterials();
        }

        function updateCharBar(name, value) {
            document.getElementById(`${name}Value`).textContent = `${Math.round(value)}%`;
            document.getElementById(`${name}Bar`).style.width = `${value}%`;
        }

        function updateMaterials() {
            const container = document.getElementById('materialTags');
            const materials = appData.roomModel.materials;
            container.innerHTML = materials.length === 0 ?
                '<span class="material-tag" style="opacity: 0.3">Scan to detect...</span>' :
                materials.map(m => `<span class="material-tag">${m}</span>`).join('');
        }

        function updateModeUI() {
            const isSonar = appData.settings.scanMode === 'sonar';

            document.getElementById('clapModeBtn').classList.toggle('active', !isSonar);
            document.getElementById('sonarModeBtn').classList.toggle('active', isSonar);
            document.getElementById('sonarOptions').style.display = isSonar ? 'block' : 'none';

            const scanBtn = document.getElementById('scanButton');
            scanBtn.classList.toggle('sonar-mode', isSonar);

            document.getElementById('autoScanBtn').classList.toggle('active', !isSonar && appData.settings.autoScan);
            document.getElementById('autoScanBtn').classList.toggle('sonar-active', isSonar && appData.settings.autoPulse);

            document.getElementById('autoPulseBtn').textContent = appData.settings.autoPulse ? 'ON' : 'OFF';
            document.getElementById('autoPulseBtn').classList.toggle('active', appData.settings.autoPulse);

            // Update chirp buttons
            ['sweep', 'click', 'ping', 'noise'].forEach(type => {
                document.getElementById(`chirp${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.toggle('active', appData.settings.chirpType === type);
            });

            // Update interval buttons
            document.querySelectorAll('#sonarOptions .setting-row:nth-child(2) .mode-btn').forEach((btn, i) => {
                const intervals = [2, 3, 5];
                btn.classList.toggle('active', appData.settings.autoPulseInterval === intervals[i]);
            });

            // IR display
            document.getElementById('irDisplay').classList.toggle('active', isSonar && isListening);
        }

        function updateStatus(state, text) {
            document.getElementById('statusDot').className = 'status-dot ' + state;
            document.getElementById('statusText').textContent = text;
        }

        function showSonarPulse(isEmit) {
            const overlay = document.getElementById('sonarOverlay');
            overlay.innerHTML = '';
            overlay.classList.add('active');

            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.className = 'sonar-ring' + (isEmit ? ' emitting' : '');
                    overlay.appendChild(ring);
                    setTimeout(() => ring.remove(), 1500);
                }, i * 200);
            }

            setTimeout(() => overlay.classList.remove('active'), 1700);
        }

        function addToHistory(scan) {
            const container = document.getElementById('historyList');
            const item = document.createElement('div');
            item.className = 'history-item' + (scan.type === 'sonar' ? ' sonar' : '');

            const time = new Date(scan.timestamp).toLocaleTimeString();
            item.innerHTML = `
                <div class="history-time">${time}</div>
                <div class="history-stats">Distance: ${scan.point.distance.toFixed(1)}m @ ${Math.round(scan.heading)}¬∞</div>
                ${scan.type === 'sonar' ? `<div class="history-type">üîä ${scan.chirpType || 'sonar'}</div>` : ''}
            `;

            container.insertBefore(item, container.firstChild);
            while (container.children.length > 10) container.removeChild(container.lastChild);
        }

        function showToast(message, isSonar = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast' + (isSonar ? ' sonar' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // ============================================
        // MODE CONTROLS
        // ============================================

        function setScanMode(mode) {
            appData.settings.scanMode = mode;

            if (mode === 'sonar') {
                stopAutoPulse();
                if (isListening) {
                    showToast('Sonar mode - click SCAN to emit chirp', true);
                }
            } else {
                stopAutoPulse();
                if (isListening && !appData.settings.autoScan) {
                    listenForClaps();
                }
                showToast('Clap mode - listening for claps');
            }

            updateModeUI();
            saveData();
        }

        function setChirpType(type) {
            appData.settings.chirpType = type;
            updateModeUI();
            saveData();
            showToast(`Chirp type: ${type}`, true);
        }

        function toggleAutoPulse() {
            appData.settings.autoPulse = !appData.settings.autoPulse;

            if (appData.settings.autoPulse && isListening) {
                startAutoPulse();
            } else {
                stopAutoPulse();
            }

            updateModeUI();
            saveData();
        }

        function setAutoInterval(seconds) {
            appData.settings.autoPulseInterval = seconds;

            if (appData.settings.autoPulse) {
                stopAutoPulse();
                startAutoPulse();
            }

            updateModeUI();
            saveData();
        }

        function startAutoPulse() {
            if (autoPulseTimer) return;

            const indicator = document.getElementById('autoScanIndicator');
            indicator.classList.add('active');

            let countdown = appData.settings.autoPulseInterval;

            function tick() {
                document.getElementById('autoCountdown').textContent = `${countdown.toFixed(1)}s`;
                countdown -= 0.1;

                if (countdown <= 0) {
                    emitSonarPulse();
                    countdown = appData.settings.autoPulseInterval;
                }
            }

            tick();
            autoPulseTimer = setInterval(tick, 100);
        }

        function stopAutoPulse() {
            if (autoPulseTimer) {
                clearInterval(autoPulseTimer);
                autoPulseTimer = null;
            }
            document.getElementById('autoScanIndicator').classList.remove('active');
        }

        function triggerManualScan() {
            if (!isListening) {
                startScanning(appData.settings.scanMode);
                return;
            }

            if (isProcessing || isEmitting) return;

            const button = document.getElementById('scanButton');

            if (appData.settings.scanMode === 'sonar') {
                button.classList.add('emitting');
                emitSonarPulse().then(() => button.classList.remove('emitting'));
            } else {
                button.classList.add('recording');

                const freqData = new Float32Array(analyser.frequencyBinCount);
                const timeData = new Uint8Array(analyser.fftSize);
                analyser.getFloatFrequencyData(freqData);
                analyser.getByteTimeDomainData(timeData);

                processAcousticPulse(freqData, timeData);
                setTimeout(() => button.classList.remove('recording'), 500);
            }
        }

        function toggleAutoScan() {
            if (appData.settings.scanMode === 'sonar') {
                toggleAutoPulse();
            } else {
                appData.settings.autoScan = !appData.settings.autoScan;
                showToast(appData.settings.autoScan ? 'Auto-scan enabled' : 'Auto-scan disabled');
            }
            updateModeUI();
            saveData();
        }

        let currentView = 'perspective';
        function toggleView() {
            const views = ['perspective', 'top', 'front', 'side'];
            currentView = views[(views.indexOf(currentView) + 1) % views.length];

            const positions = {
                perspective: { pos: { x: 0, y: 5, z: 10 }, rot: { x: -0.3, y: 0 } },
                top: { pos: { x: 0, y: 15, z: 0.01 }, rot: { x: -Math.PI/2, y: 0 } },
                front: { pos: { x: 0, y: 5, z: 15 }, rot: { x: 0, y: 0 } },
                side: { pos: { x: 15, y: 5, z: 0 }, rot: { x: 0, y: -Math.PI/2 } }
            };

            camera.position = positions[currentView].pos;
            camera.rotation = positions[currentView].rot;
            render3D();
            showToast(`View: ${currentView}`);
        }

        function resetScan() {
            if (!confirm('Reset all scan data?')) return;

            stopAutoPulse();

            appData.roomModel = {
                points: [], surfaces: [],
                dimensions: { width: 0, depth: 0, height: 0 },
                volume: 0,
                acoustics: { rt60: 0, reverberance: 0, absorption: 0, brightness: 0, warmth: 0 },
                materials: []
            };
            appData.scans = [];
            scanCount = 0;

            document.getElementById('historyList').innerHTML = '';

            // Clear IR display
            const irCanvas = document.getElementById('irCanvas');
            const ctx = irCanvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, irCanvas.width, irCanvas.height);

            updateUI();
            render3D();
            saveData();
            showToast('Scan data reset');
        }

        function rebuildRoomVisualization() {
            scanCount = appData.scans.length;
            updateUI();
            render3D();
        }

        // ============================================
        // DATA PERSISTENCE
        // ============================================

        function loadData() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    appData = { ...appData, ...loaded };
                } catch (e) { console.error('Failed to load data:', e); }
            }
        }

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const exportObj = { ...appData, exportDate: new Date().toISOString(), version: '2.0' };
            const dataBlob = new Blob([JSON.stringify(exportObj, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `room-scan-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showToast('Scan data exported');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    appData = JSON.parse(e.target.result);
                    saveData();

                    document.getElementById('instructions').classList.add('hidden');
                    document.getElementById('statusBar').style.display = 'flex';
                    document.getElementById('orientationDisplay').style.display = 'block';

                    rebuildRoomVisualization();
                    updateModeUI();
                    showToast('Scan data imported');
                } catch (error) { alert('Invalid JSON file'); }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ============================================
        // INITIALIZE
        // ============================================

        window.addEventListener('load', init);
    </script>
</body>
</html>
