<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>APEX PROTOCOL - Arena Combat</title>
    <meta name="description" content="AAA first-person arena combat game optimized for Xbox Series X Edge browser with full controller support">
    <!-- xbox, controller, fps, 3d, webgl, game, arena, shooter -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', -apple-system, sans-serif;
            color: #fff;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 10-foot UI - Large, readable from couch */
        .hud {
            position: absolute;
            pointer-events: none;
            font-weight: 600;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.5);
        }

        /* Health Bar - Bottom Left */
        #health-container {
            bottom: 60px;
            left: 60px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #health-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            box-shadow: 0 0 30px rgba(255,68,68,0.5);
        }

        #health-bar-outer {
            width: 350px;
            height: 32px;
            background: rgba(0,0,0,0.7);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            overflow: hidden;
        }

        #health-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 14px;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 20px rgba(255,68,68,0.6) inset;
        }

        #health-text {
            font-size: 28px;
            min-width: 100px;
        }

        /* Ammo - Bottom Right */
        #ammo-container {
            bottom: 60px;
            right: 60px;
            text-align: right;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #ammo-count {
            font-size: 72px;
            font-weight: 700;
            letter-spacing: -2px;
            background: linear-gradient(180deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #ammo-max {
            font-size: 32px;
            color: rgba(255,255,255,0.5);
        }

        #weapon-name {
            font-size: 24px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        /* Score/Wave - Top */
        #top-hud {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #wave-display {
            font-size: 24px;
            color: #ffaa00;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        #score-display {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(180deg, #00ffff, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #enemy-count {
            font-size: 20px;
            color: rgba(255,255,255,0.6);
            margin-top: 8px;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair svg {
            filter: drop-shadow(0 0 4px rgba(0,255,255,0.8));
        }

        /* Damage Overlay */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(255,0,0,0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }

        /* Hit Marker */
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
        }

        /* Kill Feed */
        #kill-feed {
            position: absolute;
            top: 120px;
            right: 60px;
            text-align: right;
        }

        .kill-entry {
            font-size: 22px;
            padding: 8px 16px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.5);
            border-right: 4px solid #ff4444;
            animation: killFade 3s forwards;
        }

        @keyframes killFade {
            0%, 70% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(50px); }
        }

        /* Weapon Wheel */
        #weapon-wheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: rgba(0,0,0,0.9);
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2);
            display: none;
            backdrop-filter: blur(10px);
        }

        .weapon-slot {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            border: 3px solid transparent;
        }

        .weapon-slot.selected {
            background: rgba(0,255,255,0.2);
            border-color: #00ffff;
            transform: scale(1.1);
        }

        .weapon-slot-icon {
            font-size: 48px;
        }

        .weapon-slot-name {
            font-size: 14px;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-screen.hidden {
            display: none;
        }

        #title-screen h1 {
            font-size: 120px;
            font-weight: 900;
            letter-spacing: -4px;
            background: linear-gradient(180deg, #00ffff, #0066ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 20px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        #title-screen h2 {
            font-size: 32px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 20px;
            text-transform: uppercase;
            margin-bottom: 80px;
        }

        .menu-button {
            padding: 24px 80px;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 6px;
            background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(0,100,255,0.2));
            border: 3px solid rgba(0,255,255,0.5);
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            margin: 12px;
            transition: all 0.2s;
        }

        .menu-button:hover, .menu-button.selected {
            background: linear-gradient(135deg, rgba(0,255,255,0.4), rgba(0,100,255,0.4));
            border-color: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0,255,255,0.4);
        }

        .controller-prompt {
            position: absolute;
            bottom: 60px;
            display: flex;
            gap: 40px;
            font-size: 20px;
            color: rgba(255,255,255,0.6);
        }

        .controller-prompt span {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .xbox-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-weight: 700;
            font-size: 18px;
        }

        .xbox-a { background: #2ecc40; }
        .xbox-b { background: #ff4444; }
        .xbox-x { background: #0074d9; }
        .xbox-y { background: #ffdc00; color: #000; }
        .xbox-lb, .xbox-rb {
            background: #333;
            border-radius: 8px;
            width: auto;
            padding: 8px 16px;
        }

        /* Upgrade Screen */
        #upgrade-screen {
            background: rgba(0,0,0,0.95);
        }

        #upgrade-screen h2 {
            font-size: 48px;
            margin-bottom: 60px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 10px;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            max-width: 1000px;
        }

        .upgrade-card {
            background: rgba(255,255,255,0.05);
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .upgrade-card:hover, .upgrade-card.selected {
            background: rgba(0,255,255,0.1);
            border-color: #00ffff;
            transform: scale(1.05);
        }

        .upgrade-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .upgrade-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .upgrade-desc {
            font-size: 16px;
            color: rgba(255,255,255,0.6);
        }

        /* Pause Screen */
        #pause-screen {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
        }

        #pause-screen h2 {
            font-size: 72px;
            margin-bottom: 60px;
            letter-spacing: 20px;
        }

        /* Loading Screen */
        #loading-screen {
            background: #000;
        }

        .loading-bar-outer {
            width: 400px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 40px;
        }

        .loading-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 4px;
            animation: loadingProgress 2s ease-out forwards;
        }

        @keyframes loadingProgress {
            from { width: 0%; }
            to { width: 100%; }
        }

        #loading-text {
            font-size: 24px;
            color: rgba(255,255,255,0.5);
            margin-top: 20px;
            letter-spacing: 4px;
        }

        /* Wave Announcement */
        #wave-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        #wave-announce.show {
            animation: waveAnnounce 3s forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            25% { transform: translate(-50%, -50%) scale(1); }
            75% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #wave-announce h2 {
            font-size: 36px;
            color: #ffaa00;
            letter-spacing: 10px;
            text-transform: uppercase;
        }

        #wave-announce h1 {
            font-size: 120px;
            font-weight: 900;
            background: linear-gradient(180deg, #fff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Boss Warning */
        #boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        #boss-warning.show {
            animation: bossWarn 4s forwards;
        }

        @keyframes bossWarn {
            0%, 10%, 20%, 30%, 40% { opacity: 1; }
            5%, 15%, 25%, 35% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        #boss-warning h1 {
            font-size: 80px;
            color: #ff4444;
            text-transform: uppercase;
            letter-spacing: 20px;
            text-shadow: 0 0 60px rgba(255,0,0,0.8);
        }

        /* FPS Counter */
        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 16px;
            color: rgba(255,255,255,0.4);
            font-family: monospace;
        }

        /* Combo Counter */
        #combo-display {
            position: absolute;
            right: 60px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo-display.active {
            opacity: 1;
        }

        #combo-count {
            font-size: 96px;
            font-weight: 900;
            background: linear-gradient(180deg, #ffaa00, #ff4400);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #combo-label {
            font-size: 24px;
            color: #ffaa00;
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        #combo-multiplier {
            font-size: 32px;
            color: #ff4400;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            top: 40px;
            right: 60px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.6);
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            overflow: hidden;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- HUD Elements -->
        <div id="health-container" class="hud">
            <div id="health-icon">+</div>
            <div id="health-bar-outer">
                <div id="health-bar-inner" style="width: 100%"></div>
            </div>
            <div id="health-text">100</div>
        </div>

        <div id="ammo-container" class="hud">
            <div>
                <div id="weapon-name">PLASMA RIFLE</div>
                <div id="ammo-max">/ 30</div>
            </div>
            <div id="ammo-count">30</div>
        </div>

        <div id="top-hud" class="hud">
            <div id="wave-display">WAVE 1</div>
            <div id="score-display">0</div>
            <div id="enemy-count">ENEMIES: 0</div>
        </div>

        <div id="crosshair">
            <svg width="64" height="64" viewBox="0 0 64 64">
                <circle cx="32" cy="32" r="4" fill="none" stroke="#00ffff" stroke-width="2"/>
                <line x1="32" y1="12" x2="32" y2="24" stroke="#00ffff" stroke-width="2"/>
                <line x1="32" y1="40" x2="32" y2="52" stroke="#00ffff" stroke-width="2"/>
                <line x1="12" y1="32" x2="24" y2="32" stroke="#00ffff" stroke-width="2"/>
                <line x1="40" y1="32" x2="52" y2="32" stroke="#00ffff" stroke-width="2"/>
            </svg>
        </div>

        <div id="damage-overlay"></div>

        <div id="hit-marker">
            <svg width="48" height="48" viewBox="0 0 48 48">
                <line x1="12" y1="12" x2="20" y2="20" stroke="#fff" stroke-width="3"/>
                <line x1="36" y1="12" x2="28" y2="20" stroke="#fff" stroke-width="3"/>
                <line x1="12" y1="36" x2="20" y2="28" stroke="#fff" stroke-width="3"/>
                <line x1="36" y1="36" x2="28" y2="28" stroke="#fff" stroke-width="3"/>
            </svg>
        </div>

        <div id="kill-feed"></div>

        <div id="combo-display">
            <div id="combo-count">0</div>
            <div id="combo-label">COMBO</div>
            <div id="combo-multiplier">x1.0</div>
        </div>

        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <div id="wave-announce">
            <h2>WAVE</h2>
            <h1 id="wave-number">1</h1>
        </div>

        <div id="boss-warning">
            <h1>WARNING: BOSS INCOMING</h1>
        </div>

        <div id="fps-counter">60 FPS</div>

        <!-- Menu Screens -->
        <div id="loading-screen" class="menu-screen">
            <h1 style="font-size: 80px; letter-spacing: -2px; background: linear-gradient(180deg, #00ffff, #0066ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">APEX PROTOCOL</h1>
            <div class="loading-bar-outer">
                <div class="loading-bar-inner"></div>
            </div>
            <div id="loading-text">INITIALIZING COMBAT SYSTEMS...</div>
        </div>

        <div id="title-screen" class="menu-screen hidden">
            <h1>APEX</h1>
            <h2>PROTOCOL</h2>
            <button class="menu-button selected" id="btn-start">START GAME</button>
            <button class="menu-button" id="btn-continue">CONTINUE</button>
            <div class="controller-prompt">
                <span><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span><span class="xbox-button xbox-b">B</span> BACK</span>
                <span>MOVE TO NAVIGATE</span>
            </div>
        </div>

        <div id="pause-screen" class="menu-screen hidden">
            <h2>PAUSED</h2>
            <button class="menu-button selected" id="btn-resume">RESUME</button>
            <button class="menu-button" id="btn-restart">RESTART</button>
            <button class="menu-button" id="btn-quit">QUIT TO MENU</button>
            <div class="controller-prompt">
                <span><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span><span class="xbox-button xbox-b">B</span> RESUME</span>
            </div>
        </div>

        <div id="upgrade-screen" class="menu-screen hidden">
            <h2>CHOOSE UPGRADE</h2>
            <div class="upgrade-grid" id="upgrade-grid"></div>
            <div class="controller-prompt">
                <span><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span>MOVE TO CHOOSE</span>
            </div>
        </div>

        <div id="gameover-screen" class="menu-screen hidden">
            <h1 style="font-size: 96px; color: #ff4444; margin-bottom: 20px;">GAME OVER</h1>
            <div style="font-size: 36px; margin-bottom: 20px;">WAVE <span id="final-wave">1</span></div>
            <div style="font-size: 72px; color: #00ffff; margin-bottom: 60px;">SCORE: <span id="final-score">0</span></div>
            <button class="menu-button selected" id="btn-retry">RETRY</button>
            <button class="menu-button" id="btn-menu">MAIN MENU</button>
            <div class="controller-prompt">
                <span><span class="xbox-button xbox-a">A</span> SELECT</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ═══════════════════════════════════════════════════════════════
        // GAME STATE
        // ═══════════════════════════════════════════════════════════════
        const GameState = {
            LOADING: 'loading',
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            UPGRADE: 'upgrade',
            GAMEOVER: 'gameover'
        };

        const state = {
            current: GameState.LOADING,
            wave: 1,
            score: 0,
            combo: 0,
            comboTimer: 0,
            highScore: parseInt(localStorage.getItem('apex_highscore') || '0'),

            player: {
                health: 100,
                maxHealth: 100,
                armor: 0,
                speed: 12,
                damage: 1,
                critChance: 0.1,
                critMultiplier: 2,
                position: new THREE.Vector3(0, 1.8, 0),
                velocity: new THREE.Vector3(),
                rotation: { x: 0, y: 0 },
                isGrounded: true
            },

            weapons: [
                {
                    name: 'PLASMA RIFLE',
                    ammo: 30,
                    maxAmmo: 30,
                    damage: 25,
                    fireRate: 0.1,
                    reloadTime: 1.5,
                    spread: 0.02,
                    projectileSpeed: 150,
                    color: 0x00ffff,
                    sound: 'plasma'
                },
                {
                    name: 'SHOTGUN',
                    ammo: 8,
                    maxAmmo: 8,
                    damage: 15,
                    fireRate: 0.6,
                    reloadTime: 2.0,
                    spread: 0.15,
                    pellets: 8,
                    projectileSpeed: 100,
                    color: 0xffaa00,
                    sound: 'shotgun'
                },
                {
                    name: 'RAILGUN',
                    ammo: 5,
                    maxAmmo: 5,
                    damage: 150,
                    fireRate: 1.2,
                    reloadTime: 3.0,
                    spread: 0,
                    piercing: true,
                    projectileSpeed: 500,
                    color: 0xff00ff,
                    sound: 'railgun'
                },
                {
                    name: 'ROCKET LAUNCHER',
                    ammo: 3,
                    maxAmmo: 3,
                    damage: 100,
                    fireRate: 1.0,
                    reloadTime: 2.5,
                    spread: 0,
                    explosive: true,
                    explosionRadius: 8,
                    projectileSpeed: 40,
                    color: 0xff4400,
                    sound: 'rocket'
                }
            ],
            currentWeapon: 0,
            lastFire: 0,
            isReloading: false,
            reloadTimer: 0,

            enemies: [],
            projectiles: [],
            particles: [],
            pickups: [],

            arenaRadius: 50,

            input: {
                move: { x: 0, y: 0 },
                look: { x: 0, y: 0 },
                fire: false,
                aim: false,
                reload: false,
                jump: false,
                weapon1: false,
                weapon2: false,
                weapon3: false,
                weapon4: false,
                pause: false,
                select: false,
                back: false,
                menuMove: { x: 0, y: 0 }
            },

            gamepadConnected: false,
            lastGamepadInput: 0,
            menuSelection: 0,
            upgradeSelection: 0,

            upgrades: [],
            appliedUpgrades: [],

            screenShake: 0,
            damageFlash: 0,

            time: 0,
            deltaTime: 0,
            fps: 60,
            frameCount: 0,
            lastFpsUpdate: 0
        };

        // ═══════════════════════════════════════════════════════════════
        // THREE.JS SETUP
        // ═══════════════════════════════════════════════════════════════
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();

        const canvas = document.getElementById('game-canvas');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(state.player.position);

            // Renderer - optimized for Xbox Series X
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // Post-processing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8,  // strength
                0.4,  // radius
                0.85  // threshold
            );
            composer.addPass(bloomPass);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(20, 40, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 1;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -60;
            mainLight.shadow.camera.right = 60;
            mainLight.shadow.camera.top = 60;
            mainLight.shadow.camera.bottom = -60;
            scene.add(mainLight);

            // Rim lights for dramatic effect
            const rimLight1 = new THREE.DirectionalLight(0x00ffff, 0.5);
            rimLight1.position.set(-30, 20, -30);
            scene.add(rimLight1);

            const rimLight2 = new THREE.DirectionalLight(0xff00ff, 0.3);
            rimLight2.position.set(30, 15, -30);
            scene.add(rimLight2);

            // Create arena
            createArena();

            // Minimap setup
            minimapCanvas.width = 180;
            minimapCanvas.height = 180;

            // Handle resize
            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // ═══════════════════════════════════════════════════════════════
        // ARENA CREATION
        // ═══════════════════════════════════════════════════════════════
        function createArena() {
            // Ground
            const groundGeometry = new THREE.CircleGeometry(state.arenaRadius, 64);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.8,
                roughness: 0.4
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid lines on ground
            const gridHelper = new THREE.GridHelper(state.arenaRadius * 2, 40, 0x00ffff22, 0x00ffff11);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Arena walls
            const wallGeometry = new THREE.CylinderGeometry(
                state.arenaRadius,
                state.arenaRadius,
                20,
                64,
                1,
                true
            );
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a1a,
                metalness: 0.9,
                roughness: 0.2,
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.8
            });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 10;
            scene.add(walls);

            // Glowing ring at base of walls
            const ringGeometry = new THREE.TorusGeometry(state.arenaRadius, 0.3, 8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.1;
            scene.add(ring);

            // Pillars around arena
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * (state.arenaRadius - 5);
                const z = Math.sin(angle) * (state.arenaRadius - 5);

                createPillar(x, z);
            }

            // Central platform
            const platformGeometry = new THREE.CylinderGeometry(8, 8, 0.5, 32);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4e,
                metalness: 0.9,
                roughness: 0.3,
                emissive: 0x00ffff,
                emissiveIntensity: 0.1
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = 0.25;
            platform.receiveShadow = true;
            scene.add(platform);

            // Cover objects
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                const radius = 20 + Math.random() * 10;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                createCover(x, z);
            }
        }

        function createPillar(x, z) {
            const pillarGroup = new THREE.Group();

            // Main pillar
            const pillarGeometry = new THREE.CylinderGeometry(1.5, 2, 15, 8);
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4e,
                metalness: 0.9,
                roughness: 0.2
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 7.5;
            pillar.castShadow = true;
            pillarGroup.add(pillar);

            // Glowing ring on pillar
            const glowRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.8, 0.15, 8, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 12;
            pillarGroup.add(glowRing);

            // Point light
            const light = new THREE.PointLight(0x00ffff, 1, 15);
            light.position.y = 12;
            pillarGroup.add(light);

            pillarGroup.position.set(x, 0, z);
            scene.add(pillarGroup);
        }

        function createCover(x, z) {
            const coverGeometry = new THREE.BoxGeometry(
                2 + Math.random() * 2,
                2 + Math.random() * 2,
                2 + Math.random() * 2
            );
            const coverMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a5e,
                metalness: 0.7,
                roughness: 0.4
            });
            const cover = new THREE.Mesh(coverGeometry, coverMaterial);
            cover.position.set(x, coverGeometry.parameters.height / 2, z);
            cover.rotation.y = Math.random() * Math.PI;
            cover.castShadow = true;
            cover.receiveShadow = true;
            cover.userData.isCover = true;
            scene.add(cover);
        }

        // ═══════════════════════════════════════════════════════════════
        // ENEMY SYSTEM
        // ═══════════════════════════════════════════════════════════════
        const EnemyTypes = {
            GRUNT: {
                name: 'Grunt',
                health: 50,
                damage: 10,
                speed: 6,
                score: 100,
                color: 0xff4444,
                size: 1,
                attackRange: 3,
                attackRate: 1
            },
            RUSHER: {
                name: 'Rusher',
                health: 30,
                damage: 15,
                speed: 12,
                score: 150,
                color: 0xff8800,
                size: 0.8,
                attackRange: 2,
                attackRate: 0.5
            },
            TANK: {
                name: 'Tank',
                health: 200,
                damage: 25,
                speed: 3,
                score: 300,
                color: 0x8844ff,
                size: 1.5,
                attackRange: 4,
                attackRate: 2
            },
            SNIPER: {
                name: 'Sniper',
                health: 40,
                damage: 30,
                speed: 4,
                score: 200,
                color: 0x44ff44,
                size: 1,
                attackRange: 40,
                attackRate: 2.5,
                ranged: true
            },
            BOSS: {
                name: 'OVERLORD',
                health: 1000,
                damage: 40,
                speed: 5,
                score: 2000,
                color: 0xff00ff,
                size: 3,
                attackRange: 6,
                attackRate: 1.5,
                isBoss: true
            }
        };

        function createEnemy(type, position) {
            const config = type;
            const group = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(
                config.size * 1.2,
                config.size * 2,
                config.size * 0.8
            );
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: config.color,
                metalness: 0.6,
                roughness: 0.3,
                emissive: config.color,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = config.size;
            body.castShadow = true;
            group.add(body);

            // Head/Core
            const headGeometry = new THREE.SphereGeometry(config.size * 0.4, 16, 12);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: config.color,
                emissiveIntensity: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = config.size * 2.2;
            group.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(config.size * 0.12, 8, 6);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-config.size * 0.15, config.size * 2.25, config.size * 0.3);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(config.size * 0.15, config.size * 2.25, config.size * 0.3);
            group.add(rightEye);

            // Legs
            const legGeometry = new THREE.BoxGeometry(config.size * 0.3, config.size * 0.8, config.size * 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.8,
                roughness: 0.2
            });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-config.size * 0.35, config.size * -0.4, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(config.size * 0.35, config.size * -0.4, 0);
            group.add(rightLeg);

            // Boss-specific additions
            if (config.isBoss) {
                // Crown/horns
                for (let i = 0; i < 3; i++) {
                    const hornGeometry = new THREE.ConeGeometry(0.3, 1.5, 4);
                    const horn = new THREE.Mesh(hornGeometry, new THREE.MeshStandardMaterial({
                        color: 0xffaa00,
                        emissive: 0xffaa00,
                        emissiveIntensity: 0.5
                    }));
                    horn.position.set(
                        (i - 1) * 0.8,
                        config.size * 2.8,
                        0
                    );
                    group.add(horn);
                }

                // Shoulder armor
                for (let side of [-1, 1]) {
                    const shoulderGeometry = new THREE.BoxGeometry(1.5, 0.8, 1);
                    const shoulder = new THREE.Mesh(shoulderGeometry, new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        metalness: 0.9,
                        roughness: 0.2
                    }));
                    shoulder.position.set(side * 1.5, config.size * 1.8, 0);
                    group.add(shoulder);
                }
            }

            group.position.copy(position);
            scene.add(group);

            const enemy = {
                mesh: group,
                type: config,
                health: config.health,
                maxHealth: config.health,
                lastAttack: 0,
                velocity: new THREE.Vector3(),
                targetPosition: new THREE.Vector3(),
                state: 'chase',
                stateTimer: 0
            };

            state.enemies.push(enemy);
            return enemy;
        }

        function spawnWave(waveNumber) {
            const baseEnemies = 3 + Math.floor(waveNumber * 1.5);

            // Boss wave every 5 waves
            if (waveNumber % 5 === 0) {
                showBossWarning();
                setTimeout(() => {
                    const bossPos = new THREE.Vector3(
                        (Math.random() - 0.5) * 40,
                        0,
                        (Math.random() - 0.5) * 40
                    );
                    createEnemy(EnemyTypes.BOSS, bossPos);
                }, 2000);
            }

            // Regular enemies
            const enemyCount = waveNumber % 5 === 0 ? Math.floor(baseEnemies / 2) : baseEnemies;

            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 35 + Math.random() * 10;
                    const pos = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    );

                    // Mix of enemy types based on wave
                    let type = EnemyTypes.GRUNT;
                    const roll = Math.random();

                    if (waveNumber >= 3 && roll < 0.2) {
                        type = EnemyTypes.RUSHER;
                    }
                    if (waveNumber >= 5 && roll < 0.15) {
                        type = EnemyTypes.TANK;
                    }
                    if (waveNumber >= 7 && roll < 0.1) {
                        type = EnemyTypes.SNIPER;
                    }

                    // Scale enemy stats with wave
                    const scaledType = { ...type };
                    scaledType.health = type.health * (1 + waveNumber * 0.1);
                    scaledType.damage = type.damage * (1 + waveNumber * 0.05);

                    createEnemy(scaledType, pos);
                }, i * 300);
            }

            showWaveAnnouncement(waveNumber);
            updateEnemyCount();
        }

        function updateEnemies(deltaTime) {
            for (let i = state.enemies.length - 1; i >= 0; i--) {
                const enemy = state.enemies[i];

                // Calculate direction to player
                const dirToPlayer = new THREE.Vector3()
                    .subVectors(state.player.position, enemy.mesh.position)
                    .setY(0)
                    .normalize();

                const distToPlayer = enemy.mesh.position.distanceTo(state.player.position);

                // State machine
                if (enemy.type.ranged) {
                    // Ranged enemies try to keep distance
                    if (distToPlayer < 15) {
                        // Back away
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(-enemy.type.speed);
                    } else if (distToPlayer > 25) {
                        // Get closer
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(enemy.type.speed);
                    } else {
                        // Strafe
                        const strafeDir = new THREE.Vector3(-dirToPlayer.z, 0, dirToPlayer.x);
                        enemy.velocity.copy(strafeDir).multiplyScalar(enemy.type.speed * 0.5);
                    }
                } else {
                    // Melee enemies chase
                    if (distToPlayer > enemy.type.attackRange) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(enemy.type.speed);
                    } else {
                        enemy.velocity.multiplyScalar(0.9);
                    }
                }

                // Apply velocity
                enemy.mesh.position.addScaledVector(enemy.velocity, deltaTime);

                // Keep in arena
                const distFromCenter = Math.sqrt(
                    enemy.mesh.position.x ** 2 + enemy.mesh.position.z ** 2
                );
                if (distFromCenter > state.arenaRadius - 3) {
                    const pushBack = enemy.mesh.position.clone().normalize().multiplyScalar(-1);
                    enemy.mesh.position.addScaledVector(pushBack, deltaTime * 10);
                }

                // Face player
                enemy.mesh.lookAt(
                    state.player.position.x,
                    enemy.mesh.position.y,
                    state.player.position.z
                );

                // Animation - bobbing
                const bobAmount = Math.sin(state.time * 5 + i) * 0.1;
                enemy.mesh.position.y = bobAmount;

                // Attack
                if (distToPlayer <= enemy.type.attackRange) {
                    if (state.time - enemy.lastAttack > enemy.type.attackRate) {
                        attackPlayer(enemy);
                        enemy.lastAttack = state.time;
                    }
                }

                // Health bar display would go here
            }
        }

        function attackPlayer(enemy) {
            if (enemy.type.ranged) {
                // Shoot projectile at player
                const dir = new THREE.Vector3()
                    .subVectors(state.player.position, enemy.mesh.position)
                    .normalize();
                createEnemyProjectile(
                    enemy.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)),
                    dir,
                    enemy.type.damage,
                    enemy.type.color
                );
            } else {
                // Melee attack
                damagePlayer(enemy.type.damage);
            }
        }

        function damageEnemy(enemy, damage, isCrit = false) {
            enemy.health -= damage;

            // Hit feedback
            enemy.mesh.children.forEach(child => {
                if (child.material) {
                    child.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (child.material) child.material.emissiveIntensity = 0.2;
                    }, 100);
                }
            });

            // Damage numbers
            createDamageNumber(
                enemy.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)),
                damage,
                isCrit
            );

            // Screen shake for crits
            if (isCrit) {
                state.screenShake = 0.3;
            }

            // Death
            if (enemy.health <= 0) {
                killEnemy(enemy);
            }
        }

        function killEnemy(enemy) {
            // Score and combo
            const comboMultiplier = 1 + state.combo * 0.1;
            const score = Math.floor(enemy.type.score * comboMultiplier);
            state.score += score;
            state.combo++;
            state.comboTimer = 3;

            updateScore();
            updateCombo();

            // Kill feed
            addKillFeed(enemy.type.name, score);

            // Explosion effect
            createExplosion(enemy.mesh.position.clone(), enemy.type.color, enemy.type.size);

            // Chance to drop pickup
            if (Math.random() < 0.3) {
                createPickup(enemy.mesh.position.clone());
            }

            // Remove from scene
            scene.remove(enemy.mesh);
            const idx = state.enemies.indexOf(enemy);
            if (idx > -1) state.enemies.splice(idx, 1);

            updateEnemyCount();

            // Check wave complete
            if (state.enemies.length === 0) {
                setTimeout(() => {
                    if (state.current === GameState.PLAYING) {
                        showUpgradeScreen();
                    }
                }, 1500);
            }

            // Controller vibration
            vibrateController(0.5, 0.5, 150);
        }

        // ═══════════════════════════════════════════════════════════════
        // WEAPON & PROJECTILE SYSTEM
        // ═══════════════════════════════════════════════════════════════
        function fireWeapon() {
            const weapon = state.weapons[state.currentWeapon];

            if (state.isReloading) return;
            if (weapon.ammo <= 0) {
                startReload();
                return;
            }
            if (state.time - state.lastFire < weapon.fireRate) return;

            weapon.ammo--;
            state.lastFire = state.time;
            updateAmmo();

            // Fire direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);

            // Multiple pellets for shotgun
            const pelletCount = weapon.pellets || 1;

            for (let i = 0; i < pelletCount; i++) {
                const spread = weapon.spread;
                const spreadDir = forward.clone();
                spreadDir.x += (Math.random() - 0.5) * spread;
                spreadDir.y += (Math.random() - 0.5) * spread;
                spreadDir.z += (Math.random() - 0.5) * spread;
                spreadDir.normalize();

                createProjectile(
                    camera.position.clone().add(spreadDir.clone().multiplyScalar(1)),
                    spreadDir,
                    weapon
                );
            }

            // Muzzle flash
            createMuzzleFlash();

            // Sound
            playSound(weapon.sound);

            // Recoil / screen shake
            state.screenShake = 0.1 * (weapon.damage / 25);

            // Controller vibration
            const vibIntensity = Math.min(weapon.damage / 100, 1);
            vibrateController(vibIntensity, vibIntensity * 0.5, 100);

            // Auto reload
            if (weapon.ammo <= 0) {
                startReload();
            }
        }

        function createProjectile(position, direction, weapon) {
            const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: weapon.color
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            scene.add(projectile);

            // Trail
            const trailGeometry = new THREE.CylinderGeometry(0.05, 0.15, 1, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: weapon.color,
                transparent: true,
                opacity: 0.5
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            projectile.add(trail);

            // Glow
            const glowLight = new THREE.PointLight(weapon.color, 1, 5);
            projectile.add(glowLight);

            state.projectiles.push({
                mesh: projectile,
                velocity: direction.clone().multiplyScalar(weapon.projectileSpeed),
                damage: weapon.damage * state.player.damage,
                piercing: weapon.piercing || false,
                explosive: weapon.explosive || false,
                explosionRadius: weapon.explosionRadius || 0,
                color: weapon.color,
                isPlayer: true,
                lifetime: 3
            });
        }

        function createEnemyProjectile(position, direction, damage, color) {
            const projectileGeometry = new THREE.SphereGeometry(0.2, 8, 6);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: color });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            scene.add(projectile);

            state.projectiles.push({
                mesh: projectile,
                velocity: direction.clone().multiplyScalar(30),
                damage: damage,
                color: color,
                isPlayer: false,
                lifetime: 5
            });
        }

        function updateProjectiles(deltaTime) {
            for (let i = state.projectiles.length - 1; i >= 0; i--) {
                const proj = state.projectiles[i];

                proj.mesh.position.addScaledVector(proj.velocity, deltaTime);
                proj.lifetime -= deltaTime;

                // Check bounds
                const distFromCenter = Math.sqrt(
                    proj.mesh.position.x ** 2 + proj.mesh.position.z ** 2
                );

                if (proj.lifetime <= 0 || distFromCenter > state.arenaRadius + 10 ||
                    proj.mesh.position.y < -5 || proj.mesh.position.y > 50) {
                    scene.remove(proj.mesh);
                    state.projectiles.splice(i, 1);
                    continue;
                }

                // Collision detection
                if (proj.isPlayer) {
                    // Check enemy hits
                    for (const enemy of state.enemies) {
                        const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < enemy.type.size * 1.5) {
                            // Hit!
                            const isCrit = Math.random() < state.player.critChance;
                            const damage = isCrit ?
                                proj.damage * state.player.critMultiplier :
                                proj.damage;

                            damageEnemy(enemy, damage, isCrit);
                            showHitMarker();

                            if (proj.explosive) {
                                createExplosion(proj.mesh.position.clone(), proj.color, 2);
                                // Damage nearby enemies
                                for (const nearEnemy of state.enemies) {
                                    const blastDist = proj.mesh.position.distanceTo(nearEnemy.mesh.position);
                                    if (blastDist < proj.explosionRadius) {
                                        const falloff = 1 - (blastDist / proj.explosionRadius);
                                        damageEnemy(nearEnemy, proj.damage * falloff * 0.5, false);
                                    }
                                }
                            }

                            if (!proj.piercing) {
                                scene.remove(proj.mesh);
                                state.projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                } else {
                    // Enemy projectile - check player hit
                    const dist = proj.mesh.position.distanceTo(state.player.position);
                    if (dist < 1) {
                        damagePlayer(proj.damage);
                        scene.remove(proj.mesh);
                        state.projectiles.splice(i, 1);
                    }
                }
            }
        }

        function startReload() {
            if (state.isReloading) return;
            const weapon = state.weapons[state.currentWeapon];
            if (weapon.ammo === weapon.maxAmmo) return;

            state.isReloading = true;
            state.reloadTimer = weapon.reloadTime;

            playSound('reload');
            document.getElementById('weapon-name').textContent = 'RELOADING...';
        }

        function updateReload(deltaTime) {
            if (!state.isReloading) return;

            state.reloadTimer -= deltaTime;
            if (state.reloadTimer <= 0) {
                const weapon = state.weapons[state.currentWeapon];
                weapon.ammo = weapon.maxAmmo;
                state.isReloading = false;
                updateAmmo();
            }
        }

        function switchWeapon(index) {
            if (index === state.currentWeapon) return;
            if (index < 0 || index >= state.weapons.length) return;

            state.currentWeapon = index;
            state.isReloading = false;
            updateAmmo();
            playSound('switch');
        }

        // ═══════════════════════════════════════════════════════════════
        // VISUAL EFFECTS
        // ═══════════════════════════════════════════════════════════════
        function createExplosion(position, color, size = 1) {
            const particleCount = 30 * size;

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.2);
                const material = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? color : 0xffffff,
                    transparent: true
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                scene.add(particle);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 20 * size,
                    Math.random() * 15 * size,
                    (Math.random() - 0.5) * 20 * size
                );

                state.particles.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 0.5 + Math.random() * 0.5,
                    gravity: true
                });
            }

            // Flash light
            const flash = new THREE.PointLight(color, 5, 20);
            flash.position.copy(position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 100);

            playSound('explosion');
        }

        function createMuzzleFlash() {
            // Visual effect at gun position
            const flash = new THREE.PointLight(0xffff00, 3, 10);
            flash.position.copy(camera.position);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            flash.position.addScaledVector(forward, 1);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }

        function createDamageNumber(position, damage, isCrit) {
            // This would be a floating text effect
            // For now, handled in particle system
            const geometry = new THREE.PlaneGeometry(1, 0.5);
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isCrit ? '#ffff00' : '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(Math.floor(damage).toString(), 64, 48);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const number = new THREE.Mesh(geometry, material);
            number.position.copy(position);
            number.lookAt(camera.position);
            scene.add(number);

            state.particles.push({
                mesh: number,
                velocity: new THREE.Vector3(0, 3, 0),
                lifetime: 1,
                gravity: false,
                fadeOut: true,
                billboard: true
            });
        }

        function updateParticles(deltaTime) {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const particle = state.particles[i];

                particle.mesh.position.addScaledVector(particle.velocity, deltaTime);

                if (particle.gravity) {
                    particle.velocity.y -= 30 * deltaTime;
                }

                particle.lifetime -= deltaTime;

                if (particle.fadeOut && particle.mesh.material) {
                    particle.mesh.material.opacity = particle.lifetime;
                }

                if (particle.billboard) {
                    particle.mesh.lookAt(camera.position);
                }

                if (particle.lifetime <= 0) {
                    scene.remove(particle.mesh);
                    state.particles.splice(i, 1);
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // PICKUPS
        // ═══════════════════════════════════════════════════════════════
        function createPickup(position) {
            const types = ['health', 'ammo', 'damage'];
            const type = types[Math.floor(Math.random() * types.length)];

            const colors = { health: 0x44ff44, ammo: 0x4444ff, damage: 0xff4444 };

            const geometry = new THREE.OctahedronGeometry(0.5);
            const material = new THREE.MeshStandardMaterial({
                color: colors[type],
                emissive: colors[type],
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const pickup = new THREE.Mesh(geometry, material);
            pickup.position.copy(position);
            pickup.position.y = 1;
            scene.add(pickup);

            state.pickups.push({
                mesh: pickup,
                type: type,
                lifetime: 15
            });
        }

        function updatePickups(deltaTime) {
            for (let i = state.pickups.length - 1; i >= 0; i--) {
                const pickup = state.pickups[i];

                // Rotate and bob
                pickup.mesh.rotation.y += deltaTime * 2;
                pickup.mesh.position.y = 1 + Math.sin(state.time * 3) * 0.3;

                pickup.lifetime -= deltaTime;

                // Check player collision
                const dist = pickup.mesh.position.distanceTo(state.player.position);
                if (dist < 2) {
                    collectPickup(pickup);
                    scene.remove(pickup.mesh);
                    state.pickups.splice(i, 1);
                    continue;
                }

                if (pickup.lifetime <= 0) {
                    scene.remove(pickup.mesh);
                    state.pickups.splice(i, 1);
                }
            }
        }

        function collectPickup(pickup) {
            switch (pickup.type) {
                case 'health':
                    state.player.health = Math.min(
                        state.player.maxHealth,
                        state.player.health + 25
                    );
                    updateHealth();
                    break;
                case 'ammo':
                    state.weapons.forEach(w => w.ammo = w.maxAmmo);
                    updateAmmo();
                    break;
                case 'damage':
                    state.player.damage *= 1.1;
                    break;
            }
            playSound('pickup');
        }

        // ═══════════════════════════════════════════════════════════════
        // PLAYER CONTROLLER
        // ═══════════════════════════════════════════════════════════════
        function updatePlayer(deltaTime) {
            // Movement
            const moveSpeed = state.player.speed;
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(
                new THREE.Vector3(0, 1, 0),
                state.player.rotation.y
            );
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(
                new THREE.Vector3(0, 1, 0),
                state.player.rotation.y
            );

            const moveVec = new THREE.Vector3();
            moveVec.addScaledVector(forward, state.input.move.y);
            moveVec.addScaledVector(right, state.input.move.x);

            if (moveVec.length() > 0) {
                moveVec.normalize().multiplyScalar(moveSpeed);
            }

            state.player.velocity.x = moveVec.x;
            state.player.velocity.z = moveVec.z;

            // Apply velocity
            state.player.position.addScaledVector(state.player.velocity, deltaTime);

            // Keep in arena
            const distFromCenter = Math.sqrt(
                state.player.position.x ** 2 + state.player.position.z ** 2
            );
            if (distFromCenter > state.arenaRadius - 2) {
                const pushBack = new THREE.Vector3(
                    state.player.position.x,
                    0,
                    state.player.position.z
                ).normalize();
                state.player.position.x = pushBack.x * (state.arenaRadius - 2);
                state.player.position.z = pushBack.z * (state.arenaRadius - 2);
            }

            // Look (controller)
            const lookSensitivity = 2.5;
            state.player.rotation.y -= state.input.look.x * lookSensitivity * deltaTime;
            state.player.rotation.x -= state.input.look.y * lookSensitivity * deltaTime;
            state.player.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, state.player.rotation.x));

            // Apply to camera
            camera.position.copy(state.player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = state.player.rotation.y;
            camera.rotation.x = state.player.rotation.x;

            // Screen shake
            if (state.screenShake > 0) {
                camera.position.x += (Math.random() - 0.5) * state.screenShake;
                camera.position.y += (Math.random() - 0.5) * state.screenShake;
                state.screenShake *= 0.9;
                if (state.screenShake < 0.01) state.screenShake = 0;
            }

            // Firing
            if (state.input.fire) {
                fireWeapon();
            }

            // Reload
            if (state.input.reload) {
                startReload();
            }

            // Weapon switching
            if (state.input.weapon1) switchWeapon(0);
            if (state.input.weapon2) switchWeapon(1);
            if (state.input.weapon3) switchWeapon(2);
            if (state.input.weapon4) switchWeapon(3);
        }

        function damagePlayer(damage) {
            const effectiveDamage = Math.max(1, damage - state.player.armor);
            state.player.health -= effectiveDamage;
            state.damageFlash = 0.5;

            updateHealth();

            // Damage overlay
            document.getElementById('damage-overlay').style.opacity = '0.6';
            setTimeout(() => {
                document.getElementById('damage-overlay').style.opacity = '0';
            }, 200);

            // Controller vibration
            vibrateController(0.8, 0.4, 200);

            // Screen shake
            state.screenShake = 0.5;

            if (state.player.health <= 0) {
                gameOver();
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // INPUT HANDLING - XBOX CONTROLLER FOCUSED
        // ═══════════════════════════════════════════════════════════════
        function updateInput() {
            const gamepads = navigator.getGamepads();

            for (const gamepad of gamepads) {
                if (!gamepad) continue;

                state.gamepadConnected = true;

                // Deadzone
                const deadzone = 0.15;
                const applyDeadzone = (val) => Math.abs(val) < deadzone ? 0 : val;

                // Left stick - movement
                state.input.move.x = applyDeadzone(gamepad.axes[0]);
                state.input.move.y = -applyDeadzone(gamepad.axes[1]);

                // Right stick - look
                state.input.look.x = applyDeadzone(gamepad.axes[2]) * 2;
                state.input.look.y = applyDeadzone(gamepad.axes[3]) * 2;

                // Buttons (Xbox layout)
                // A = 0, B = 1, X = 2, Y = 3
                // LB = 4, RB = 5, LT = 6, RT = 7
                // Back = 8, Start = 9
                // LS = 10, RS = 11
                // DPad: Up = 12, Down = 13, Left = 14, Right = 15

                state.input.fire = gamepad.buttons[7]?.pressed || false; // RT
                state.input.aim = gamepad.buttons[6]?.pressed || false;  // LT
                state.input.reload = gamepad.buttons[2]?.pressed || false; // X
                state.input.jump = gamepad.buttons[0]?.pressed || false;   // A

                // Weapon switching with bumpers
                if (gamepad.buttons[4]?.pressed) { // LB
                    const prev = (state.currentWeapon - 1 + state.weapons.length) % state.weapons.length;
                    if (!state.input.prevWeaponHeld) switchWeapon(prev);
                    state.input.prevWeaponHeld = true;
                } else {
                    state.input.prevWeaponHeld = false;
                }

                if (gamepad.buttons[5]?.pressed) { // RB
                    const next = (state.currentWeapon + 1) % state.weapons.length;
                    if (!state.input.nextWeaponHeld) switchWeapon(next);
                    state.input.nextWeaponHeld = true;
                } else {
                    state.input.nextWeaponHeld = false;
                }

                // D-pad for quick weapon select
                if (gamepad.buttons[12]?.pressed) state.input.weapon1 = true; // Up
                else state.input.weapon1 = false;
                if (gamepad.buttons[13]?.pressed) state.input.weapon2 = true; // Down
                else state.input.weapon2 = false;
                if (gamepad.buttons[14]?.pressed) state.input.weapon3 = true; // Left
                else state.input.weapon3 = false;
                if (gamepad.buttons[15]?.pressed) state.input.weapon4 = true; // Right
                else state.input.weapon4 = false;

                // Pause
                if (gamepad.buttons[9]?.pressed) { // Start
                    if (!state.input.pauseHeld) {
                        state.input.pause = true;
                    }
                    state.input.pauseHeld = true;
                } else {
                    state.input.pauseHeld = false;
                    state.input.pause = false;
                }

                // Menu navigation
                state.input.select = gamepad.buttons[0]?.pressed || false; // A
                state.input.back = gamepad.buttons[1]?.pressed || false;   // B

                // Menu movement (with debounce)
                const now = performance.now();
                if (now - state.lastGamepadInput > 200) {
                    if (Math.abs(gamepad.axes[1]) > 0.5) {
                        state.input.menuMove.y = gamepad.axes[1] > 0 ? 1 : -1;
                        state.lastGamepadInput = now;
                    }
                    if (Math.abs(gamepad.axes[0]) > 0.5) {
                        state.input.menuMove.x = gamepad.axes[0] > 0 ? 1 : -1;
                        state.lastGamepadInput = now;
                    }
                    if (gamepad.buttons[12]?.pressed) {
                        state.input.menuMove.y = -1;
                        state.lastGamepadInput = now;
                    }
                    if (gamepad.buttons[13]?.pressed) {
                        state.input.menuMove.y = 1;
                        state.lastGamepadInput = now;
                    }
                    if (gamepad.buttons[14]?.pressed) {
                        state.input.menuMove.x = -1;
                        state.lastGamepadInput = now;
                    }
                    if (gamepad.buttons[15]?.pressed) {
                        state.input.menuMove.x = 1;
                        state.lastGamepadInput = now;
                    }
                } else {
                    state.input.menuMove.x = 0;
                    state.input.menuMove.y = 0;
                }

                break; // Only use first connected controller
            }
        }

        function vibrateController(leftIntensity, rightIntensity, duration) {
            const gamepads = navigator.getGamepads();
            for (const gamepad of gamepads) {
                if (gamepad?.vibrationActuator) {
                    gamepad.vibrationActuator.playEffect('dual-rumble', {
                        startDelay: 0,
                        duration: duration,
                        weakMagnitude: leftIntensity,
                        strongMagnitude: rightIntensity
                    }).catch(() => {});
                }
            }
        }

        // Keyboard/Mouse fallback
        const keys = {};
        let mouseMovement = { x: 0, y: 0 };

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            // Weapon switching with number keys
            if (e.code === 'Digit1') switchWeapon(0);
            if (e.code === 'Digit2') switchWeapon(1);
            if (e.code === 'Digit3') switchWeapon(2);
            if (e.code === 'Digit4') switchWeapon(3);

            if (e.code === 'Escape') {
                state.input.pause = true;
            }
            if (e.code === 'KeyR') {
                state.input.reload = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'KeyR') state.input.reload = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                mouseMovement.x += e.movementX * 0.002;
                mouseMovement.y += e.movementY * 0.002;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) state.input.fire = true;
            if (e.button === 2) state.input.aim = true;

            if (!document.pointerLockElement && state.current === GameState.PLAYING) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) state.input.fire = false;
            if (e.button === 2) state.input.aim = false;
        });

        canvas.addEventListener('click', () => {
            if (state.current === GameState.PLAYING && !document.pointerLockElement) {
                canvas.requestPointerLock();
            }
        });

        function applyKeyboardInput() {
            if (!state.gamepadConnected) {
                // Movement
                state.input.move.x = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
                state.input.move.y = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);

                // Look
                state.input.look.x = mouseMovement.x * 50;
                state.input.look.y = mouseMovement.y * 50;
                mouseMovement.x = 0;
                mouseMovement.y = 0;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // AUDIO SYSTEM (Procedural)
        // ═══════════════════════════════════════════════════════════════
        let audioContext;

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioContext) initAudio();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const now = audioContext.currentTime;

            switch (type) {
                case 'plasma':
                    playSynth([440, 880, 1760], 0.1, 'square', 0.15);
                    break;
                case 'shotgun':
                    playNoise(0.15, 0.3);
                    playSynth([100, 80, 60], 0.1, 'sawtooth', 0.2);
                    break;
                case 'railgun':
                    playSynth([2000, 1000, 500, 250], 0.15, 'sine', 0.4);
                    break;
                case 'rocket':
                    playSynth([80, 60, 40], 0.2, 'sawtooth', 0.3);
                    playNoise(0.1, 0.2);
                    break;
                case 'explosion':
                    playNoise(0.3, 0.5);
                    playSynth([60, 40, 30, 20], 0.3, 'sine', 0.4);
                    break;
                case 'pickup':
                    playSynth([440, 660, 880], 0.05, 'sine', 0.2);
                    break;
                case 'reload':
                    playSynth([300, 400, 300], 0.1, 'square', 0.1);
                    break;
                case 'switch':
                    playSynth([600, 800], 0.05, 'sine', 0.1);
                    break;
                case 'hit':
                    playSynth([200, 100], 0.05, 'square', 0.1);
                    break;
            }
        }

        function playSynth(frequencies, duration, type, volume) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequencies[0], audioContext.currentTime);

            frequencies.forEach((freq, i) => {
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + (i * duration / frequencies.length));
            });

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playNoise(duration, volume) {
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = buffer;
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            source.start();
        }

        // ═══════════════════════════════════════════════════════════════
        // UI UPDATES
        // ═══════════════════════════════════════════════════════════════
        function updateHealth() {
            const percent = (state.player.health / state.player.maxHealth) * 100;
            document.getElementById('health-bar-inner').style.width = `${percent}%`;
            document.getElementById('health-text').textContent = Math.ceil(state.player.health);
        }

        function updateAmmo() {
            const weapon = state.weapons[state.currentWeapon];
            document.getElementById('ammo-count').textContent = weapon.ammo;
            document.getElementById('ammo-max').textContent = `/ ${weapon.maxAmmo}`;
            document.getElementById('weapon-name').textContent = weapon.name;
        }

        function updateScore() {
            document.getElementById('score-display').textContent = state.score.toLocaleString();
        }

        function updateCombo() {
            const comboDisplay = document.getElementById('combo-display');
            const comboCount = document.getElementById('combo-count');
            const comboMultiplier = document.getElementById('combo-multiplier');

            if (state.combo > 1) {
                comboDisplay.classList.add('active');
                comboCount.textContent = state.combo;
                comboMultiplier.textContent = `x${(1 + state.combo * 0.1).toFixed(1)}`;
            } else {
                comboDisplay.classList.remove('active');
            }
        }

        function updateEnemyCount() {
            document.getElementById('enemy-count').textContent = `ENEMIES: ${state.enemies.length}`;
        }

        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            playSound('hit');
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 100);
        }

        function showWaveAnnouncement(waveNum) {
            const announce = document.getElementById('wave-announce');
            document.getElementById('wave-number').textContent = waveNum;
            document.getElementById('wave-display').textContent = `WAVE ${waveNum}`;
            announce.classList.remove('show');
            void announce.offsetWidth; // Reflow
            announce.classList.add('show');
        }

        function showBossWarning() {
            const warning = document.getElementById('boss-warning');
            warning.classList.remove('show');
            void warning.offsetWidth;
            warning.classList.add('show');
            vibrateController(1, 1, 2000);
        }

        function addKillFeed(enemyName, score) {
            const feed = document.getElementById('kill-feed');
            const entry = document.createElement('div');
            entry.className = 'kill-entry';
            entry.textContent = `${enemyName} +${score}`;
            feed.appendChild(entry);

            setTimeout(() => {
                if (entry.parentNode) {
                    entry.parentNode.removeChild(entry);
                }
            }, 3000);
        }

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 180, 180);

            const scale = 180 / (state.arenaRadius * 2);
            const centerX = 90;
            const centerY = 90;

            // Arena border
            minimapCtx.strokeStyle = '#00ffff44';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, state.arenaRadius * scale, 0, Math.PI * 2);
            minimapCtx.stroke();

            // Enemies
            minimapCtx.fillStyle = '#ff4444';
            for (const enemy of state.enemies) {
                const x = centerX + enemy.mesh.position.x * scale;
                const y = centerY + enemy.mesh.position.z * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, enemy.type.isBoss ? 6 : 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Player
            minimapCtx.fillStyle = '#00ffff';
            const px = centerX + state.player.position.x * scale;
            const py = centerY + state.player.position.z * scale;
            minimapCtx.beginPath();
            minimapCtx.arc(px, py, 4, 0, Math.PI * 2);
            minimapCtx.fill();

            // Player direction
            const dirX = Math.sin(state.player.rotation.y) * 10;
            const dirY = -Math.cos(state.player.rotation.y) * 10;
            minimapCtx.strokeStyle = '#00ffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(px, py);
            minimapCtx.lineTo(px + dirX, py + dirY);
            minimapCtx.stroke();
        }

        // ═══════════════════════════════════════════════════════════════
        // UPGRADE SYSTEM
        // ═══════════════════════════════════════════════════════════════
        const UpgradePool = [
            { name: 'Health Boost', icon: '❤️', desc: '+25 Max Health', apply: () => { state.player.maxHealth += 25; state.player.health += 25; updateHealth(); }},
            { name: 'Damage Up', icon: '⚔️', desc: '+15% Damage', apply: () => { state.player.damage *= 1.15; }},
            { name: 'Speed Boost', icon: '⚡', desc: '+10% Move Speed', apply: () => { state.player.speed *= 1.1; }},
            { name: 'Critical Hit', icon: '💥', desc: '+5% Crit Chance', apply: () => { state.player.critChance += 0.05; }},
            { name: 'Armor', icon: '🛡️', desc: '+5 Armor', apply: () => { state.player.armor += 5; }},
            { name: 'Rapid Fire', icon: '🔥', desc: 'Faster Fire Rate', apply: () => { state.weapons.forEach(w => w.fireRate *= 0.9); }},
            { name: 'Extended Mag', icon: '📦', desc: '+50% Ammo Capacity', apply: () => { state.weapons.forEach(w => { w.maxAmmo = Math.floor(w.maxAmmo * 1.5); w.ammo = w.maxAmmo; }); updateAmmo(); }},
            { name: 'Quick Reload', icon: '🔄', desc: '-25% Reload Time', apply: () => { state.weapons.forEach(w => w.reloadTime *= 0.75); }},
            { name: 'Vampiric', icon: '🧛', desc: 'Heal 5% on Kill', apply: () => { /* Would need kill hook */ }}
        ];

        function showUpgradeScreen() {
            state.current = GameState.UPGRADE;
            document.getElementById('upgrade-screen').classList.remove('hidden');

            // Pick 3 random upgrades
            const available = [...UpgradePool];
            state.upgrades = [];
            for (let i = 0; i < 3 && available.length > 0; i++) {
                const idx = Math.floor(Math.random() * available.length);
                state.upgrades.push(available.splice(idx, 1)[0]);
            }

            // Render
            const grid = document.getElementById('upgrade-grid');
            grid.innerHTML = '';
            state.upgrades.forEach((upgrade, i) => {
                const card = document.createElement('div');
                card.className = `upgrade-card ${i === 0 ? 'selected' : ''}`;
                card.innerHTML = `
                    <div class="upgrade-icon">${upgrade.icon}</div>
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                `;
                card.onclick = () => selectUpgrade(i);
                grid.appendChild(card);
            });

            state.upgradeSelection = 0;
        }

        function selectUpgrade(index) {
            const upgrade = state.upgrades[index];
            upgrade.apply();
            state.appliedUpgrades.push(upgrade);

            document.getElementById('upgrade-screen').classList.add('hidden');

            // Next wave
            state.wave++;
            state.current = GameState.PLAYING;
            spawnWave(state.wave);
        }

        // ═══════════════════════════════════════════════════════════════
        // MENU SYSTEM
        // ═══════════════════════════════════════════════════════════════
        function updateMenu(deltaTime) {
            // Handle menu navigation
            if (state.current === GameState.MENU) {
                const buttons = document.querySelectorAll('#title-screen .menu-button');

                if (state.input.menuMove.y !== 0) {
                    state.menuSelection += state.input.menuMove.y;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));

                    buttons.forEach((btn, i) => {
                        btn.classList.toggle('selected', i === state.menuSelection);
                    });
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) {
                        startGame();
                    } else if (state.menuSelection === 1) {
                        loadGame();
                    }
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            if (state.current === GameState.PAUSED) {
                const buttons = document.querySelectorAll('#pause-screen .menu-button');

                if (state.input.menuMove.y !== 0) {
                    state.menuSelection += state.input.menuMove.y;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));

                    buttons.forEach((btn, i) => {
                        btn.classList.toggle('selected', i === state.menuSelection);
                    });
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) resumeGame();
                    else if (state.menuSelection === 1) restartGame();
                    else if (state.menuSelection === 2) quitToMenu();
                }
                if (!state.input.select) state.input.selectHeld = false;

                if (state.input.back) {
                    resumeGame();
                }
            }

            if (state.current === GameState.UPGRADE) {
                const cards = document.querySelectorAll('.upgrade-card');

                if (state.input.menuMove.x !== 0) {
                    state.upgradeSelection += state.input.menuMove.x;
                    state.upgradeSelection = Math.max(0, Math.min(cards.length - 1, state.upgradeSelection));

                    cards.forEach((card, i) => {
                        card.classList.toggle('selected', i === state.upgradeSelection);
                    });
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    selectUpgrade(state.upgradeSelection);
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            if (state.current === GameState.GAMEOVER) {
                const buttons = document.querySelectorAll('#gameover-screen .menu-button');

                if (state.input.menuMove.y !== 0) {
                    state.menuSelection += state.input.menuMove.y;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));

                    buttons.forEach((btn, i) => {
                        btn.classList.toggle('selected', i === state.menuSelection);
                    });
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) restartGame();
                    else if (state.menuSelection === 1) quitToMenu();
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            // Pause toggle
            if (state.current === GameState.PLAYING && state.input.pause) {
                pauseGame();
            }
        }

        function showMenu() {
            state.current = GameState.MENU;
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('loading-screen').classList.add('hidden');
            state.menuSelection = 0;
        }

        function startGame() {
            state.current = GameState.PLAYING;
            document.getElementById('title-screen').classList.add('hidden');

            // Reset game state
            state.wave = 1;
            state.score = 0;
            state.combo = 0;
            state.player.health = state.player.maxHealth = 100;
            state.player.armor = 0;
            state.player.speed = 12;
            state.player.damage = 1;
            state.player.critChance = 0.1;
            state.player.position.set(0, 1.8, 0);
            state.appliedUpgrades = [];

            // Reset weapons
            state.weapons.forEach(w => w.ammo = w.maxAmmo);
            state.currentWeapon = 0;

            // Clear entities
            state.enemies.forEach(e => scene.remove(e.mesh));
            state.enemies = [];
            state.projectiles.forEach(p => scene.remove(p.mesh));
            state.projectiles = [];
            state.particles.forEach(p => scene.remove(p.mesh));
            state.particles = [];
            state.pickups.forEach(p => scene.remove(p.mesh));
            state.pickups = [];

            updateHealth();
            updateAmmo();
            updateScore();
            updateEnemyCount();

            // Start first wave
            spawnWave(1);

            // Request pointer lock on desktop
            if (!state.gamepadConnected) {
                canvas.requestPointerLock();
            }
        }

        function loadGame() {
            // Load from localStorage
            const save = localStorage.getItem('apex_save');
            if (save) {
                const data = JSON.parse(save);
                state.wave = data.wave;
                state.score = data.score;
                // etc...
            }
            startGame();
        }

        function pauseGame() {
            state.current = GameState.PAUSED;
            document.getElementById('pause-screen').classList.remove('hidden');
            state.menuSelection = 0;
            document.exitPointerLock();
        }

        function resumeGame() {
            state.current = GameState.PLAYING;
            document.getElementById('pause-screen').classList.add('hidden');
            if (!state.gamepadConnected) {
                canvas.requestPointerLock();
            }
        }

        function restartGame() {
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');
            startGame();
        }

        function quitToMenu() {
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');

            // Clear entities
            state.enemies.forEach(e => scene.remove(e.mesh));
            state.enemies = [];
            state.projectiles.forEach(p => scene.remove(p.mesh));
            state.projectiles = [];

            showMenu();
        }

        function gameOver() {
            state.current = GameState.GAMEOVER;

            // Update high score
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('apex_highscore', state.score.toString());
            }

            document.getElementById('final-wave').textContent = state.wave;
            document.getElementById('final-score').textContent = state.score.toLocaleString();
            document.getElementById('gameover-screen').classList.remove('hidden');

            state.menuSelection = 0;

            document.exitPointerLock();
            vibrateController(1, 1, 500);
        }

        // ═══════════════════════════════════════════════════════════════
        // MAIN GAME LOOP
        // ═══════════════════════════════════════════════════════════════
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const deltaTime = Math.min(clock.getDelta(), 0.1);
            state.time += deltaTime;
            state.deltaTime = deltaTime;

            // FPS counter
            state.frameCount++;
            if (state.time - state.lastFpsUpdate > 0.5) {
                state.fps = Math.round(state.frameCount / (state.time - state.lastFpsUpdate));
                document.getElementById('fps-counter').textContent = `${state.fps} FPS`;
                state.frameCount = 0;
                state.lastFpsUpdate = state.time;
            }

            // Input
            updateInput();
            applyKeyboardInput();

            // Update based on game state
            if (state.current === GameState.PLAYING) {
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updateProjectiles(deltaTime);
                updateParticles(deltaTime);
                updatePickups(deltaTime);
                updateReload(deltaTime);
                updateMinimap();

                // Combo timer
                if (state.combo > 0) {
                    state.comboTimer -= deltaTime;
                    if (state.comboTimer <= 0) {
                        state.combo = 0;
                        updateCombo();
                    }
                }
            }

            updateMenu(deltaTime);

            // Render
            composer.render();
        }

        // ═══════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════
        async function init() {
            initThreeJS();
            initAudio();

            // Loading simulation
            await new Promise(resolve => setTimeout(resolve, 2500));

            showMenu();
            gameLoop();
        }

        // Button click handlers for menu
        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-continue').onclick = loadGame;
        document.getElementById('btn-resume').onclick = resumeGame;
        document.getElementById('btn-restart').onclick = restartGame;
        document.getElementById('btn-quit').onclick = quitToMenu;
        document.getElementById('btn-retry').onclick = restartGame;
        document.getElementById('btn-menu').onclick = quitToMenu;

        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Handle visibility change (Quick Resume)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && state.current === GameState.PLAYING) {
                pauseGame();
            }
        });

        // Start
        init();
    </script>
</body>
</html>
