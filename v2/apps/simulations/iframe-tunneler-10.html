<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cumulative 3D Dimensional Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            cursor: crosshair;
            user-select: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .portal {
            position: absolute;
            width: 120px;
            height: 120px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }

        .portal-glass {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.2), 
                rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .portal:hover {
            transform: scale(1.1);
        }

        .portal:hover .portal-glass {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 
                0 12px 48px rgba(0, 0, 0, 0.4),
                0 0 80px rgba(255, 255, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .world-info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            font-weight: 300;
            letter-spacing: 0.5px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
        }

        .save-load-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            max-width: 400px;
        }

        .gesture-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            color: white;
            font-size: 12px;
            display: none;
        }

        .gesture-controls.active {
            display: block;
        }

        .gesture-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .gesture-icon {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .webcam-preview {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: none;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
        }

        .webcam-preview.active {
            display: block;
        }

        .webcam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .webcam-preview canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .hand-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            display: none;
            transition: all 0.1s ease;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .hand-cursor.pinching {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.8);
        }

        .gesture-status {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 10px;
            display: none;
        }

        .save-load-panel button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .save-load-panel button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .json-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 30px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 2000;
            display: none;
            max-width: 600px;
            width: 90%;
        }

        .json-modal textarea {
            width: 100%;
            height: 300px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .json-modal h4 {
            color: white;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .json-modal .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .json-modal button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .json-modal button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }

        .world-info h3 {
            font-size: 16px;
            font-weight: 400;
            margin-bottom: 15px;
            color: #fff;
        }

        .world-info div {
            margin: 5px 0;
            font-size: 11px;
        }

        .world-info .label {
            color: rgba(255, 255, 255, 0.6);
            display: inline-block;
            width: 100px;
        }

        .world-info .value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 400;
        }

        .mutations-list {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 200px;
            overflow-y: auto;
        }

        .mutation-item {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin: 3px 0;
            padding-left: 10px;
            position: relative;
        }

        .mutation-item:before {
            content: '‚ñ∏';
            position: absolute;
            left: 0;
        }

        .dimension-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 300;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .portal:hover .dimension-label {
            opacity: 1;
        }

        .flash-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, 
                rgba(255, 255, 255, 0.9), 
                transparent);
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="loading">Loading 3D Environment...</div>
    <canvas id="canvas"></canvas>
    
    <div class="world-info">
        <h3 id="visualizer-name">Origin Matrix</h3>
        <div><span class="label">Dimension:</span> <span class="value" id="dimension">0</span></div>
        <div><span class="label">Total Mutations:</span> <span class="value" id="total-mutations">0</span></div>
        <div><span class="label">Geometry Layers:</span> <span class="value" id="layers">1</span></div>
        <div><span class="label">Particle Systems:</span> <span class="value" id="particle-systems">0</span></div>
        <div><span class="label">Active Effects:</span> <span class="value" id="effects">1</span></div>
        
        <div class="mutations-list" id="mutations-list">
            <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5); margin-bottom: 5px;">Mutation History:</div>
        </div>
    </div>
    
    <div class="flash-transition"></div>

    <div class="save-load-panel">
        <button onclick="exportState()">Export State</button>
        <button onclick="showImportModal()">Import State</button>
        <button onclick="resetState()">Reset</button>
        <button onclick="toggleGestureControl()" id="gesture-toggle">Enable Gestures</button>
    </div>

    <div class="gesture-controls">
        <h4 style="margin: 0 0 10px 0; font-weight: 300;">Gesture Controls</h4>
        <div class="gesture-indicator">
            <div class="gesture-icon">üëå</div>
            <span>Pinch to select portal</span>
        </div>
        <div class="gesture-indicator">
            <div class="gesture-icon">‚úã</div>
            <span>Open hand to navigate</span>
        </div>
        <div class="gesture-indicator">
            <div class="gesture-icon">üëä</div>
            <span>Fist to rotate scene</span>
        </div>
        <div class="gesture-indicator">
            <div class="gesture-icon">‚úåÔ∏è</div>
            <span>Peace sign to zoom</span>
        </div>
    </div>

    <div class="webcam-preview" id="webcam-preview">
        <video id="webcam-video" autoplay playsinline></video>
        <canvas id="webcam-canvas"></canvas>
        <div class="gesture-status" id="gesture-status"></div>
    </div>

    <div class="hand-cursor" id="hand-cursor"></div>

    <div class="modal-overlay" onclick="closeModal()"></div>
    <div class="json-modal" id="json-modal">
        <h4 id="modal-title">State Data</h4>
        <textarea id="json-textarea" placeholder="Paste your saved state JSON here..."></textarea>
        <div class="modal-buttons">
            <button onclick="closeModal()">Cancel</button>
            <button id="modal-action-btn" onclick="">Copy</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script>
        // Remove loading message after Three.js loads
        window.addEventListener('load', () => {
            document.querySelector('.loading').style.display = 'none';
        });

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mutations that can stack
        const mutationTypes = {
            geometryComplexity: {
                name: 'Geometry Complexity',
                apply: (state) => {
                    state.geometrySegments = Math.min(128, state.geometrySegments + 8);
                    state.geometryLayers = Math.min(10, state.geometryLayers + 1);
                }
            },
            particleSystem: {
                name: 'Particle System',
                apply: (state) => {
                    state.particleSystems.push({
                        count: 1000 + Math.random() * 2000,
                        speed: 0.001 + Math.random() * 0.005,
                        spread: 10 + Math.random() * 20,
                        color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6)
                    });
                }
            },
            waveDistortion: {
                name: 'Wave Distortion',
                apply: (state) => {
                    state.waveAmplitude += 0.1 + Math.random() * 0.2;
                    state.waveFrequency += 0.5 + Math.random() * 1.5;
                }
            },
            rotationDynamics: {
                name: 'Rotation Dynamics',
                apply: (state) => {
                    state.rotationSpeeds.x += (Math.random() - 0.5) * 0.002;
                    state.rotationSpeeds.y += (Math.random() - 0.5) * 0.002;
                    state.rotationSpeeds.z += (Math.random() - 0.5) * 0.001;
                }
            },
            colorShift: {
                name: 'Color Shift',
                apply: (state) => {
                    state.colorShiftSpeed += 0.001;
                    state.colorRange += 0.1;
                }
            },
            fractalDepth: {
                name: 'Fractal Depth',
                apply: (state) => {
                    state.fractalIterations = Math.min(5, state.fractalIterations + 1);
                    state.fractalScale *= 0.8;
                }
            },
            lightingSystem: {
                name: 'Dynamic Lighting',
                apply: (state) => {
                    state.lights.push({
                        color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                        intensity: 0.5 + Math.random() * 0.5,
                        distance: 20 + Math.random() * 30,
                        speed: 0.001 + Math.random() * 0.003
                    });
                }
            },
            meshDuplication: {
                name: 'Mesh Duplication',
                apply: (state) => {
                    state.meshCopies = Math.min(12, state.meshCopies + 2);
                    state.meshSpread += 2;
                }
            },
            audioReactivity: {
                name: 'Audio Reactivity',
                apply: (state) => {
                    state.audioSensitivity += 0.2;
                    state.frequencyBands = Math.min(32, state.frequencyBands + 4);
                }
            },
            glitchEffect: {
                name: 'Glitch Effect',
                apply: (state) => {
                    state.glitchIntensity += 0.1;
                    state.glitchFrequency += 0.05;
                }
            }
        };

        // World state - accumulates all mutations
        let worldState = {
            dimension: 0,
            seed: Date.now(),
            mutationHistory: [],
            // Base parameters
            geometrySegments: 16,
            geometryLayers: 1,
            particleSystems: [],
            waveAmplitude: 0,
            waveFrequency: 0,
            rotationSpeeds: { x: 0.001, y: 0.002, z: 0 },
            colorShiftSpeed: 0,
            colorRange: 0.5,
            fractalIterations: 1,
            fractalScale: 1,
            lights: [],
            meshCopies: 1,
            meshSpread: 0,
            audioSensitivity: 1,
            frequencyBands: 8,
            glitchIntensity: 0,
            glitchFrequency: 0,
            // Visual state
            baseHue: 0.6,
            time: 0,
            // Audio simulation
            audioData: new Array(32).fill(0),
            // Three.js objects
            meshes: [],
            particles: [],
            dynamicLights: []
        };

        // Initialize camera position
        camera.position.z = 30;

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Main directional light
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
        mainLight.position.set(5, 5, 5);
        scene.add(mainLight);

        // Create base geometry
        function createGeometry() {
            // Clear existing meshes
            worldState.meshes.forEach(mesh => scene.remove(mesh));
            worldState.meshes = [];

            // Create layered geometry
            for (let layer = 0; layer < worldState.geometryLayers; layer++) {
                const geometry = new THREE.IcosahedronGeometry(
                    5 + layer * 2, 
                    Math.floor(worldState.geometrySegments / (layer + 1))
                );

                // Create material with accumulative effects
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(worldState.baseHue + layer * 0.1, 0.7, 0.5),
                    wireframe: layer % 2 === 0,
                    transparent: true,
                    opacity: 0.8 - layer * 0.1,
                    emissive: new THREE.Color().setHSL(worldState.baseHue, 0.5, 0.2),
                    emissiveIntensity: 0.2
                });

                // Create mesh copies
                for (let i = 0; i < worldState.meshCopies; i++) {
                    const mesh = new THREE.Mesh(geometry, material.clone());
                    
                    if (i > 0) {
                        const angle = (i / worldState.meshCopies) * Math.PI * 2;
                        mesh.position.x = Math.cos(angle) * worldState.meshSpread;
                        mesh.position.y = Math.sin(angle) * worldState.meshSpread;
                        mesh.position.z = (Math.random() - 0.5) * worldState.meshSpread;
                    }

                    worldState.meshes.push(mesh);
                    scene.add(mesh);
                }
            }
        }

        // Create particle systems
        function createParticles() {
            // Clear existing particles
            worldState.particles.forEach(system => scene.remove(system));
            worldState.particles = [];

            worldState.particleSystems.forEach((config, index) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.count * 3);
                const colors = new Float32Array(config.count * 3);

                for (let i = 0; i < config.count * 3; i += 3) {
                    const radius = config.spread;
                    positions[i] = (Math.random() - 0.5) * radius;
                    positions[i + 1] = (Math.random() - 0.5) * radius;
                    positions[i + 2] = (Math.random() - 0.5) * radius;

                    colors[i] = config.color.r;
                    colors[i + 1] = config.color.g;
                    colors[i + 2] = config.color.b;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                const particles = new THREE.Points(geometry, material);
                particles.userData = config;
                worldState.particles.push(particles);
                scene.add(particles);
            });
        }

        // Create dynamic lights
        function createDynamicLights() {
            // Clear existing dynamic lights
            worldState.dynamicLights.forEach(light => scene.remove(light));
            worldState.dynamicLights = [];

            worldState.lights.forEach((config, index) => {
                const light = new THREE.PointLight(config.color, config.intensity, config.distance);
                light.userData = config;
                worldState.dynamicLights.push(light);
                scene.add(light);
            });
        }

        // Update audio simulation
        function updateAudioData() {
            for (let i = 0; i < worldState.audioData.length; i++) {
                const target = Math.random() * Math.exp(-i / worldState.frequencyBands) * worldState.audioSensitivity;
                worldState.audioData[i] += (target - worldState.audioData[i]) * 0.1;
            }
        }

        // Apply wave distortion to geometry
        function applyWaveDistortion(mesh, time) {
            if (worldState.waveAmplitude > 0 && mesh.geometry) {
                const positions = mesh.geometry.attributes.position;
                const originalPositions = mesh.geometry.userData.originalPositions;

                if (!originalPositions) {
                    mesh.geometry.userData.originalPositions = positions.array.slice();
                    return;
                }

                for (let i = 0; i < positions.count; i++) {
                    const x = originalPositions[i * 3];
                    const y = originalPositions[i * 3 + 1];
                    const z = originalPositions[i * 3 + 2];

                    const waveX = Math.sin(y * worldState.waveFrequency + time) * worldState.waveAmplitude;
                    const waveY = Math.cos(x * worldState.waveFrequency + time) * worldState.waveAmplitude;
                    const waveZ = Math.sin((x + y) * worldState.waveFrequency * 0.5 + time) * worldState.waveAmplitude;

                    positions.array[i * 3] = x + waveX * worldState.audioData[i % worldState.frequencyBands];
                    positions.array[i * 3 + 1] = y + waveY * worldState.audioData[(i + 1) % worldState.frequencyBands];
                    positions.array[i * 3 + 2] = z + waveZ * worldState.audioData[(i + 2) % worldState.frequencyBands];
                }

                positions.needsUpdate = true;
                mesh.geometry.computeVertexNormals();
            }
        }

        // Seeded random
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Generate mutation based on portal
        function generateMutation(seed) {
            const mutationKeys = Object.keys(mutationTypes);
            const selectedMutation = mutationKeys[Math.floor(seededRandom(seed) * mutationKeys.length)];
            return mutationTypes[selectedMutation];
        }

        // Create portal elements
        function createPortals() {
            // Remove existing portals
            document.querySelectorAll('.portal').forEach(p => p.remove());

            const portalCount = 3 + Math.floor(seededRandom(worldState.seed) * 2);

            for (let i = 0; i < portalCount; i++) {
                const portal = document.createElement('div');
                portal.className = 'portal';

                // Position portals
                const angle = (i / portalCount) * Math.PI * 2;
                const radius = Math.min(window.innerWidth, window.innerHeight) * 0.3;
                const x = window.innerWidth / 2 + Math.cos(angle) * radius - 60;
                const y = window.innerHeight / 2 + Math.sin(angle) * radius - 60;

                portal.style.left = x + 'px';
                portal.style.top = y + 'px';

                // Create glass effect
                const glass = document.createElement('div');
                glass.className = 'portal-glass';
                portal.appendChild(glass);

                // Create dimension label
                const label = document.createElement('div');
                label.className = 'dimension-label';
                portal.appendChild(label);

                // Generate portal destination
                const portalSeed = worldState.seed + i * 1337;
                portal.dataset.seed = portalSeed;

                const mutation = generateMutation(portalSeed);
                label.textContent = mutation.name;

                // Click handler
                portal.addEventListener('click', () => enterPortal(portalSeed, mutation));

                document.body.appendChild(portal);
            }
        }

        // Enter portal and apply mutation
        function enterPortal(seed, mutation) {
            // Flash effect
            const flash = document.querySelector('.flash-transition');
            flash.style.transition = 'none';
            flash.style.opacity = '1';

            setTimeout(() => {
                flash.style.transition = 'opacity 0.8s ease';
                flash.style.opacity = '0';
            }, 50);

            // Update state
            worldState.seed = seed;
            worldState.dimension++;
            worldState.baseHue = (worldState.baseHue + seededRandom(seed) * 0.3) % 1;

            // Apply the mutation
            mutation.apply(worldState);
            worldState.mutationHistory.push(mutation.name);

            // Rebuild 3D scene with accumulated changes
            createGeometry();
            createParticles();
            createDynamicLights();

            // Update UI
            updateInfo();

            // Recreate portals
            setTimeout(() => {
                createPortals();
            }, 400);
        }

        // Update info display
        function updateInfo() {
            document.getElementById('visualizer-name').textContent = 
                `Dimension ${worldState.dimension} Entity`;
            document.getElementById('dimension').textContent = worldState.dimension;
            document.getElementById('total-mutations').textContent = worldState.mutationHistory.length;
            document.getElementById('layers').textContent = worldState.geometryLayers;
            document.getElementById('particle-systems').textContent = worldState.particleSystems.length;
            document.getElementById('effects').textContent = 
                (worldState.waveAmplitude > 0 ? 1 : 0) + 
                (worldState.glitchIntensity > 0 ? 1 : 0) + 
                worldState.lights.length;

            // Update mutation history
            const mutationsList = document.getElementById('mutations-list');
            mutationsList.innerHTML = '<div style="font-size: 11px; color: rgba(255, 255, 255, 0.5); margin-bottom: 5px;">Mutation History:</div>';
            
            worldState.mutationHistory.slice(-10).forEach(mutation => {
                const item = document.createElement('div');
                item.className = 'mutation-item';
                item.textContent = mutation;
                mutationsList.appendChild(item);
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            worldState.time += 0.01;
            updateAudioData();

            // Rotate meshes with accumulated speeds
            worldState.meshes.forEach((mesh, index) => {
                mesh.rotation.x += worldState.rotationSpeeds.x * (1 + worldState.audioData[0] * 0.5);
                mesh.rotation.y += worldState.rotationSpeeds.y * (1 + worldState.audioData[1] * 0.5);
                mesh.rotation.z += worldState.rotationSpeeds.z * (1 + worldState.audioData[2] * 0.5);

                // Apply wave distortion
                applyWaveDistortion(mesh, worldState.time);

                // Color shift
                if (worldState.colorShiftSpeed > 0) {
                    mesh.material.color.setHSL(
                        (worldState.baseHue + worldState.time * worldState.colorShiftSpeed + index * 0.1) % 1,
                        0.7,
                        0.5 + worldState.audioData[index % worldState.frequencyBands] * 0.2
                    );
                }

                // Scale with audio
                const scale = 1 + worldState.audioData[index % worldState.frequencyBands] * 0.1;
                mesh.scale.set(scale, scale, scale);
            });

            // Animate particles
            worldState.particles.forEach((system, sysIndex) => {
                system.rotation.y += system.userData.speed;
                
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(worldState.time + i) * 0.01;
                }
                system.geometry.attributes.position.needsUpdate = true;
            });

            // Animate dynamic lights
            worldState.dynamicLights.forEach((light, index) => {
                const angle = worldState.time * light.userData.speed + index * Math.PI * 2 / worldState.dynamicLights.length;
                light.position.x = Math.cos(angle) * 20;
                light.position.z = Math.sin(angle) * 20;
                light.position.y = Math.sin(worldState.time * 2 + index) * 10;
            });

            // Apply glitch effect
            if (worldState.glitchIntensity > 0 && Math.random() < worldState.glitchFrequency) {
                camera.position.x += (Math.random() - 0.5) * worldState.glitchIntensity;
                camera.position.y += (Math.random() - 0.5) * worldState.glitchIntensity;
            }

            // Camera movement
            camera.position.x = Math.sin(worldState.time * 0.1) * 5;
            camera.position.y = Math.cos(worldState.time * 0.1) * 5;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        // Initialize
        createGeometry();
        createPortals();
        updateInfo();
        animate();

        // Hand tracking setup
        let gestureEnabled = false;
        let hands = null;
        let camera2 = null;
        let handCursor = document.getElementById('hand-cursor');
        let lastGesture = null;
        let pinchStartPos = null;
        let cameraRotation = { x: 0, y: 0 };

        function toggleGestureControl() {
            gestureEnabled = !gestureEnabled;
            const btn = document.getElementById('gesture-toggle');
            const preview = document.getElementById('webcam-preview');
            const controls = document.querySelector('.gesture-controls');
            
            if (gestureEnabled) {
                btn.textContent = 'Disable Gestures';
                preview.classList.add('active');
                controls.classList.add('active');
                initializeHandTracking();
            } else {
                btn.textContent = 'Enable Gestures';
                preview.classList.remove('active');
                controls.classList.remove('active');
                if (camera2) {
                    camera2.stop();
                }
                handCursor.style.display = 'none';
            }
        }

        function initializeHandTracking() {
            const videoElement = document.getElementById('webcam-video');
            const canvasElement = document.getElementById('webcam-canvas');
            const canvasCtx = canvasElement.getContext('2d');
            
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            camera2 = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            camera2.start();
        }

        function onHandResults(results) {
            const canvasElement = document.getElementById('webcam-canvas');
            const canvasCtx = canvasElement.getContext('2d');
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw hand skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, 
                    { color: '#00FF00', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, 
                    { color: '#FF0073', lineWidth: 1, radius: 3 });
                
                // Process gestures
                processHandGesture(landmarks);
                
                // Update hand cursor position
                const indexTip = landmarks[8];
                const cursorX = (1 - indexTip.x) * window.innerWidth;
                const cursorY = indexTip.y * window.innerHeight;
                
                handCursor.style.left = cursorX + 'px';
                handCursor.style.top = cursorY + 'px';
                handCursor.style.display = 'block';
            } else {
                handCursor.style.display = 'none';
            }
            
            canvasCtx.restore();
        }

        function processHandGesture(landmarks) {
            const gesture = detectGesture(landmarks);
            const statusEl = document.getElementById('gesture-status');
            
            if (gesture !== lastGesture) {
                statusEl.textContent = gesture;
                statusEl.style.display = 'block';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 1000);
            }
            
            // Handle different gestures
            switch (gesture) {
                case 'pinch':
                    handlePinch(landmarks);
                    break;
                case 'fist':
                    handleFist(landmarks);
                    break;
                case 'peace':
                    handlePeace(landmarks);
                    break;
                case 'open':
                    handleOpenHand(landmarks);
                    break;
            }
            
            lastGesture = gesture;
        }

        function detectGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            const indexMCP = landmarks[5];
            const middleMCP = landmarks[9];
            const ringMCP = landmarks[13];
            const pinkyMCP = landmarks[17];
            
            // Calculate distances
            const pinchDistance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            
            // Check finger states
            const indexUp = indexTip.y < indexMCP.y;
            const middleUp = middleTip.y < middleMCP.y;
            const ringUp = ringTip.y < ringMCP.y;
            const pinkyUp = pinkyTip.y < pinkyMCP.y;
            
            // Detect gestures
            if (pinchDistance < 0.05) {
                handCursor.classList.add('pinching');
                return 'pinch';
            } else {
                handCursor.classList.remove('pinching');
            }
            
            if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                return 'fist';
            }
            
            if (indexUp && middleUp && !ringUp && !pinkyUp) {
                return 'peace';
            }
            
            if (indexUp && middleUp && ringUp && pinkyUp) {
                return 'open';
            }
            
            return 'unknown';
        }

        function handlePinch(landmarks) {
            const indexTip = landmarks[8];
            const x = (1 - indexTip.x) * window.innerWidth;
            const y = indexTip.y * window.innerHeight;
            
            // Check if pinching over a portal
            const portals = document.querySelectorAll('.portal');
            portals.forEach(portal => {
                const rect = portal.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && 
                    y >= rect.top && y <= rect.bottom) {
                    portal.click();
                }
            });
        }

        function handleFist(landmarks) {
            const indexKnuckle = landmarks[5];
            
            if (!pinchStartPos) {
                pinchStartPos = { x: indexKnuckle.x, y: indexKnuckle.y };
            }
            
            const deltaX = (indexKnuckle.x - pinchStartPos.x) * 5;
            const deltaY = (indexKnuckle.y - pinchStartPos.y) * 5;
            
            cameraRotation.x += deltaY;
            cameraRotation.y += deltaX;
            
            camera.position.x = Math.sin(cameraRotation.y) * 30;
            camera.position.z = Math.cos(cameraRotation.y) * 30;
            camera.position.y = Math.sin(cameraRotation.x) * 20;
            camera.lookAt(scene.position);
            
            pinchStartPos = { x: indexKnuckle.x, y: indexKnuckle.y };
        }

        function handlePeace(landmarks) {
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const distance = Math.abs(indexTip.y - middleTip.y);
            
            const zoom = 20 + distance * 100;
            camera.position.z = Math.max(10, Math.min(50, zoom));
        }

        function handleOpenHand(landmarks) {
            pinchStartPos = null;
            
            // Slowly rotate scene when hand is open
            worldState.meshes.forEach(mesh => {
                mesh.rotation.y += 0.01;
            });
        }

        // MediaPipe hand connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startPoint.x * ctx.canvas.width, startPoint.y * ctx.canvas.height);
                ctx.lineTo(endPoint.x * ctx.canvas.width, endPoint.y * ctx.canvas.height);
                ctx.stroke();
            });
        }

        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(
                    landmark.x * ctx.canvas.width,
                    landmark.y * ctx.canvas.height,
                    style.radius,
                    0,
                    2 * Math.PI
                );
                ctx.fill();
            });
        }

        // Save/Load functionality
        function exportState() {
            // Create a serializable version of the state
            const exportData = {
                version: "1.0",
                timestamp: new Date().toISOString(),
                dimension: worldState.dimension,
                seed: worldState.seed,
                mutationHistory: worldState.mutationHistory,
                // Core parameters
                geometrySegments: worldState.geometrySegments,
                geometryLayers: worldState.geometryLayers,
                waveAmplitude: worldState.waveAmplitude,
                waveFrequency: worldState.waveFrequency,
                rotationSpeeds: worldState.rotationSpeeds,
                colorShiftSpeed: worldState.colorShiftSpeed,
                colorRange: worldState.colorRange,
                fractalIterations: worldState.fractalIterations,
                fractalScale: worldState.fractalScale,
                meshCopies: worldState.meshCopies,
                meshSpread: worldState.meshSpread,
                audioSensitivity: worldState.audioSensitivity,
                frequencyBands: worldState.frequencyBands,
                glitchIntensity: worldState.glitchIntensity,
                glitchFrequency: worldState.glitchFrequency,
                baseHue: worldState.baseHue,
                // Particle systems (simplified)
                particleSystems: worldState.particleSystems.map(ps => ({
                    count: ps.count,
                    speed: ps.speed,
                    spread: ps.spread,
                    color: { h: ps.color.getHSL({}).h, s: ps.color.getHSL({}).s, l: ps.color.getHSL({}).l }
                })),
                // Lights (simplified)
                lights: worldState.lights.map(light => ({
                    color: { h: light.color.getHSL({}).h, s: light.color.getHSL({}).s, l: light.color.getHSL({}).l },
                    intensity: light.intensity,
                    distance: light.distance,
                    speed: light.speed
                }))
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Show modal with export data
            document.getElementById('modal-title').textContent = 'Export State - Copy this JSON';
            document.getElementById('json-textarea').value = jsonString;
            document.getElementById('modal-action-btn').textContent = 'Copy to Clipboard';
            document.getElementById('modal-action-btn').onclick = () => {
                navigator.clipboard.writeText(jsonString).then(() => {
                    document.getElementById('modal-action-btn').textContent = 'Copied!';
                    setTimeout(() => {
                        closeModal();
                    }, 1000);
                });
            };
            
            document.getElementById('json-modal').style.display = 'block';
            document.querySelector('.modal-overlay').style.display = 'block';
        }

        function showImportModal() {
            document.getElementById('modal-title').textContent = 'Import State - Paste your JSON';
            document.getElementById('json-textarea').value = '';
            document.getElementById('modal-action-btn').textContent = 'Import';
            document.getElementById('modal-action-btn').onclick = importState;
            
            document.getElementById('json-modal').style.display = 'block';
            document.querySelector('.modal-overlay').style.display = 'block';
        }

        function importState() {
            try {
                const jsonString = document.getElementById('json-textarea').value;
                const importData = JSON.parse(jsonString);
                
                // Validate version
                if (!importData.version || !importData.dimension) {
                    throw new Error('Invalid state data');
                }

                // Clear current scene
                worldState.meshes.forEach(mesh => scene.remove(mesh));
                worldState.particles.forEach(system => scene.remove(system));
                worldState.dynamicLights.forEach(light => scene.remove(light));

                // Import basic parameters
                worldState.dimension = importData.dimension;
                worldState.seed = importData.seed;
                worldState.mutationHistory = importData.mutationHistory || [];
                worldState.geometrySegments = importData.geometrySegments;
                worldState.geometryLayers = importData.geometryLayers;
                worldState.waveAmplitude = importData.waveAmplitude;
                worldState.waveFrequency = importData.waveFrequency;
                worldState.rotationSpeeds = importData.rotationSpeeds;
                worldState.colorShiftSpeed = importData.colorShiftSpeed;
                worldState.colorRange = importData.colorRange;
                worldState.fractalIterations = importData.fractalIterations;
                worldState.fractalScale = importData.fractalScale;
                worldState.meshCopies = importData.meshCopies;
                worldState.meshSpread = importData.meshSpread;
                worldState.audioSensitivity = importData.audioSensitivity;
                worldState.frequencyBands = importData.frequencyBands;
                worldState.glitchIntensity = importData.glitchIntensity;
                worldState.glitchFrequency = importData.glitchFrequency;
                worldState.baseHue = importData.baseHue;

                // Reconstruct particle systems
                worldState.particleSystems = importData.particleSystems.map(ps => ({
                    count: ps.count,
                    speed: ps.speed,
                    spread: ps.spread,
                    color: new THREE.Color().setHSL(ps.color.h, ps.color.s, ps.color.l)
                }));

                // Reconstruct lights
                worldState.lights = importData.lights.map(light => ({
                    color: new THREE.Color().setHSL(light.color.h, light.color.s, light.color.l),
                    intensity: light.intensity,
                    distance: light.distance,
                    speed: light.speed
                }));

                // Rebuild scene
                createGeometry();
                createParticles();
                createDynamicLights();
                createPortals();
                updateInfo();

                // Flash effect
                const flash = document.querySelector('.flash-transition');
                flash.style.transition = 'none';
                flash.style.opacity = '1';
                setTimeout(() => {
                    flash.style.transition = 'opacity 0.8s ease';
                    flash.style.opacity = '0';
                }, 50);

                closeModal();
            } catch (error) {
                alert('Error importing state: ' + error.message);
            }
        }

        function resetState() {
            if (confirm('Reset to origin dimension? This will clear all mutations.')) {
                // Clear scene
                worldState.meshes.forEach(mesh => scene.remove(mesh));
                worldState.particles.forEach(system => scene.remove(system));
                worldState.dynamicLights.forEach(light => scene.remove(light));

                // Reset state
                worldState = {
                    dimension: 0,
                    seed: Date.now(),
                    mutationHistory: [],
                    geometrySegments: 16,
                    geometryLayers: 1,
                    particleSystems: [],
                    waveAmplitude: 0,
                    waveFrequency: 0,
                    rotationSpeeds: { x: 0.001, y: 0.002, z: 0 },
                    colorShiftSpeed: 0,
                    colorRange: 0.5,
                    fractalIterations: 1,
                    fractalScale: 1,
                    lights: [],
                    meshCopies: 1,
                    meshSpread: 0,
                    audioSensitivity: 1,
                    frequencyBands: 8,
                    glitchIntensity: 0,
                    glitchFrequency: 0,
                    baseHue: 0.6,
                    time: 0,
                    audioData: new Array(32).fill(0),
                    meshes: [],
                    particles: [],
                    dynamicLights: []
                };

                // Rebuild
                createGeometry();
                createPortals();
                updateInfo();
            }
        }

        function closeModal() {
            document.getElementById('json-modal').style.display = 'none';
            document.querySelector('.modal-overlay').style.display = 'none';
        }
    </script>
</body>
</html>