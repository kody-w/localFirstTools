<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paradigm Nexus - Quantum Convergence of Revolutionary Apps</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #1a0033 0%, #000000 100%);
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .hud h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .hud-info {
            font-size: 14px;
            line-height: 1.6;
            color: #aaa;
        }

        .zone-indicator {
            font-size: 16px;
            font-weight: bold;
            margin-top: 10px;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            text-shadow: 0 0 10px currentColor;
        }

        .zone-nexus { background: rgba(255, 255, 255, 0.2); color: #fff; }
        .zone-consciousness { background: rgba(138, 43, 226, 0.3); color: #8a2be2; }
        .zone-symphony { background: rgba(255, 0, 255, 0.3); color: #ff00ff; }
        .zone-library { background: rgba(255, 165, 0, 0.3); color: #ffa500; }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        .controls h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #00ffff;
        }

        .controls p {
            font-size: 12px;
            line-height: 1.5;
            color: #aaa;
            margin-bottom: 5px;
        }

        .mini-map {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 100;
        }

        .data-controls {
            position: fixed;
            top: 240px;
            right: 20px;
            z-index: 100;
        }

        .data-controls button {
            display: block;
            margin-bottom: 10px;
            padding: 10px 15px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
            transition: all 0.3s;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .app-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            display: none;
            flex-direction: column;
        }

        .app-overlay.active {
            display: flex;
        }

        .app-header {
            padding: 15px 20px;
            background: rgba(0, 255, 255, 0.1);
            border-bottom: 2px solid #00ffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-header h2 {
            color: #00ffff;
        }

        .close-btn {
            padding: 8px 20px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid #ff0000;
            color: #ff0000;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }

        .app-iframe {
            flex: 1;
            border: none;
            width: 100%;
        }

        .chat-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            max-height: 300px;
        }

        .chat-message {
            margin-bottom: 8px;
            font-size: 12px;
            padding: 5px;
            border-radius: 3px;
            background: rgba(0, 255, 255, 0.1);
        }

        .chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }

        .chat-input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #fff;
            border-radius: 5px;
            font-size: 12px;
        }

        .event-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid;
            border-radius: 15px;
            z-index: 300;
            display: none;
            text-align: center;
            animation: pulse 2s infinite;
        }

        .event-notification.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px currentColor; }
            50% { box-shadow: 0 0 40px currentColor; }
        }

        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .joystick {
            width: 100px;
            height: 100px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            border-radius: 50%;
            position: relative;
        }

        .joystick-handle {
            width: 40px;
            height: 40px;
            background: #00ffff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @media (max-width: 768px) {
            .mobile-controls { display: block; }
            .controls { display: none; }
            .hud { font-size: 12px; padding: 10px; }
            .mini-map { width: 120px; height: 120px; }
        }

        .portal-ui {
            position: absolute;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 10px;
            text-align: center;
            display: none;
            pointer-events: none;
        }

        .portal-ui.visible {
            display: block;
        }

        .portal-ui h3 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        .portal-ui p {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .portal-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid;
            color: inherit;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            pointer-events: all;
        }

        .portal-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="hud">
        <h2>Paradigm Nexus</h2>
        <div class="hud-info">
            <div>Position: <span id="position">0, 0, 0</span></div>
            <div>Players Online: <span id="players">1</span></div>
            <div>FPS: <span id="fps">60</span></div>
        </div>
        <div id="zone-indicator" class="zone-indicator zone-nexus">Central Nexus</div>
    </div>

    <div class="controls">
        <h3>Controls</h3>
        <p><strong>WASD</strong> - Move</p>
        <p><strong>Mouse</strong> - Look around</p>
        <p><strong>Space</strong> - Float mode</p>
        <p><strong>Click</strong> - Interact with portals</p>
        <p><strong>E</strong> - Enter portal</p>
        <p><strong>M</strong> - Toggle map</p>
    </div>

    <canvas class="mini-map" id="miniMap"></canvas>

    <div class="data-controls">
        <button onclick="exportData()">Export World State</button>
        <button onclick="document.getElementById('importFile').click()">Import World State</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <div class="chat-box" id="chatBox" style="display: none;">
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-container">
            <input type="text" class="chat-input" id="chatInput" placeholder="Type message...">
        </div>
    </div>

    <div class="app-overlay" id="appOverlay">
        <div class="app-header">
            <h2 id="appTitle">Application</h2>
            <button class="close-btn" onclick="closeApp()">Close (ESC)</button>
        </div>
        <iframe class="app-iframe" id="appIframe"></iframe>
    </div>

    <div class="event-notification" id="eventNotification">
        <h2 id="eventTitle"></h2>
        <p id="eventDescription"></p>
    </div>

    <div class="mobile-controls">
        <div class="joystick" id="joystick">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>

    <!-- Portal UI overlays -->
    <div class="portal-ui" id="portalUI" style="border-color: #00ffff; color: #00ffff;">
        <h3 id="portalName">Portal</h3>
        <p id="portalDesc">Description</p>
        <button class="portal-btn" id="portalBtn" style="border-color: inherit;">Enter (E)</button>
    </div>

    <script>
        // ===== APP CONFIGURATION =====
        const APP_NAME = 'paradigm-nexus';
        const APPS = {
            sss: {
                name: 'Synaesthetic Swarm Symphony',
                path: '../ai-tools/synaesthetic-swarm-symphony.html',
                color: '#ff00ff',
                zone: 'symphony'
            },
            tec: {
                name: 'Temporal Emergence Consciousness',
                path: '../ai-tools/temporal-emergence-consciousness.html',
                color: '#8a2be2',
                zone: 'consciousness'
            },
            ilep: {
                name: 'Infinite Library of Paradigms',
                path: '../ai-tools/infinite-library-paradigms.html',
                color: '#ffa500',
                zone: 'library'
            }
        };

        // ===== WORLD STATE =====
        let worldState = JSON.parse(localStorage.getItem(APP_NAME) || JSON.stringify({
            playerName: 'Explorer_' + Math.floor(Math.random() * 9999),
            visitedZones: [],
            paradigmShifts: 0,
            swarmMerges: 0,
            consciousnessSyncs: 0,
            preferences: {
                floatMode: false,
                showChat: false,
                graphicsQuality: 'high'
            }
        }));

        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const miniMap = document.getElementById('miniMap');
        const miniCtx = miniMap.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            miniMap.width = miniMap.offsetWidth;
            miniMap.height = miniMap.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== PLAYER STATE =====
        const player = {
            x: 0,
            y: 0,
            z: 0,
            angle: 0,
            pitch: 0,
            vx: 0,
            vy: 0,
            vz: 0,
            speed: 0.5,
            floatMode: worldState.preferences.floatMode,
            currentZone: 'nexus'
        };

        // ===== INPUT HANDLING =====
        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };

        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;

            if (e.key === 'e' || e.key === 'E') {
                checkPortalInteraction();
            }
            if (e.key === ' ') {
                e.preventDefault();
                player.floatMode = !player.floatMode;
                worldState.preferences.floatMode = player.floatMode;
                saveData();
            }
            if (e.key === 'm' || e.key === 'M') {
                miniMap.style.display = miniMap.style.display === 'none' ? 'block' : 'none';
            }
            if (e.key === 'Escape') {
                closeApp();
            }
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('click', () => {
            if (!mouse.locked) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            mouse.locked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', e => {
            if (mouse.locked) {
                player.angle -= e.movementX * 0.002;
                player.pitch -= e.movementY * 0.002;
                player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
            }
        });

        // ===== WORLD ZONES =====
        const zones = [
            {
                id: 'nexus',
                name: 'Central Nexus',
                x: 0, y: 0, z: 0,
                radius: 150,
                color: '#ffffff',
                particleColor: '#00ffff'
            },
            {
                id: 'consciousness',
                name: 'Consciousness Observatory',
                x: -300, y: 0, z: 200,
                radius: 120,
                color: '#8a2be2',
                particleColor: '#9370db',
                app: 'tec'
            },
            {
                id: 'symphony',
                name: 'Symphony Amphitheater',
                x: 300, y: 0, z: 200,
                radius: 120,
                color: '#ff00ff',
                particleColor: '#ff1493',
                app: 'sss'
            },
            {
                id: 'library',
                name: 'Infinite Library Tower',
                x: 0, y: 0, z: -350,
                radius: 120,
                color: '#ffa500',
                particleColor: '#ffd700',
                app: 'ilep'
            }
        ];

        // ===== PORTALS =====
        const portals = [
            { x: -300, y: 0, z: 200, app: 'tec', size: 40, color: '#8a2be2' },
            { x: 300, y: 0, z: 200, app: 'sss', size: 40, color: '#ff00ff' },
            { x: 0, y: 0, z: -350, app: 'ilep', size: 40, color: '#ffa500' }
        ];

        // ===== PARTICLE SYSTEMS =====
        const particles = [];
        const maxParticles = 500;

        function createParticle(zone) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * zone.radius;
            return {
                x: zone.x + Math.cos(angle) * radius,
                y: zone.y + (Math.random() - 0.5) * 100,
                z: zone.z + Math.sin(angle) * radius,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                vz: (Math.random() - 0.5) * 0.5,
                life: 1,
                zone: zone.id,
                color: zone.particleColor,
                size: Math.random() * 3 + 1
            };
        }

        // Initialize particles
        zones.forEach(zone => {
            for (let i = 0; i < maxParticles / zones.length; i++) {
                particles.push(createParticle(zone));
            }
        });

        // ===== 3D PROJECTION =====
        function project3D(x, y, z) {
            const dx = x - player.x;
            const dy = y - player.y;
            const dz = z - player.z;

            // Rotate around player angle
            const cosA = Math.cos(player.angle);
            const sinA = Math.sin(player.angle);
            const rx = dx * cosA - dz * sinA;
            const rz = dx * sinA + dz * cosA;

            // Rotate for pitch
            const cosP = Math.cos(player.pitch);
            const sinP = Math.sin(player.pitch);
            const ry = dy * cosP - rz * sinP;
            const finalZ = dy * sinP + rz * cosP;

            if (finalZ <= 0) return null;

            const scale = 400 / finalZ;
            const screenX = canvas.width / 2 + rx * scale;
            const screenY = canvas.height / 2 + ry * scale;

            return { x: screenX, y: screenY, z: finalZ, scale };
        }

        // ===== RENDERING =====
        function drawZone(zone) {
            const center = project3D(zone.x, zone.y, zone.z);
            if (!center) return;

            const radius = (zone.radius * 400) / Math.max(center.z, 1);

            // Zone platform
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = zone.color + '20';
            ctx.fill();
            ctx.strokeStyle = zone.color;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Zone name
            if (center.z < 500) {
                ctx.fillStyle = zone.color;
                ctx.font = `${Math.max(12, 20 - center.z / 50)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(zone.name, center.x, center.y - radius - 20);
            }
        }

        function drawPortal(portal) {
            const pos = project3D(portal.x, portal.y, portal.z);
            if (!pos) return;

            const size = (portal.size * 400) / Math.max(pos.z, 1);
            const time = Date.now() / 1000;

            // Pulsing effect
            const pulse = Math.sin(time * 3) * 0.3 + 0.7;

            // Portal glow
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, size * pulse);
            gradient.addColorStop(0, portal.color + 'ff');
            gradient.addColorStop(0.5, portal.color + '80');
            gradient.addColorStop(1, portal.color + '00');

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size * pulse, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Portal ring
            ctx.strokeStyle = portal.color;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Inner spiral
            for (let i = 0; i < 5; i++) {
                const offset = (time + i * 0.2) % 1;
                const r = size * offset * pulse;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
                ctx.strokeStyle = portal.color + Math.floor((1 - offset) * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            return { pos, size, portal };
        }

        function drawParticles() {
            particles.forEach((p, i) => {
                const pos = project3D(p.x, p.y, p.z);
                if (!pos || pos.z > 1000) return;

                const size = (p.size * 400) / Math.max(pos.z, 1);

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
                ctx.fill();

                // Update particle
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                p.life -= 0.002;

                // Respawn
                if (p.life <= 0) {
                    const zone = zones.find(z => z.id === p.zone);
                    if (zone) {
                        const newP = createParticle(zone);
                        particles[i] = newP;
                    }
                }
            });
        }

        function drawMiniMap() {
            const ctx = miniCtx;
            const w = miniMap.width;
            const h = miniMap.height;
            const scale = 0.3;

            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, w, h);

            // Draw zones
            zones.forEach(zone => {
                const x = w / 2 + zone.x * scale;
                const y = h / 2 + zone.z * scale;
                const r = zone.radius * scale;

                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = zone.color + '40';
                ctx.fill();
                ctx.strokeStyle = zone.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw player
            const px = w / 2 + player.x * scale;
            const py = h / 2 + player.z * scale;

            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffff';
            ctx.fill();

            // Player direction
            const dirX = px + Math.sin(player.angle) * 10;
            const dirY = py + Math.cos(player.angle) * 10;
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(dirX, dirY);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // ===== GAME LOOP =====
        let lastTime = Date.now();
        let frameCount = 0;
        let fpsTime = 0;

        function update() {
            const now = Date.now();
            const dt = (now - lastTime) / 16.67; // Normalize to 60fps
            lastTime = now;

            // FPS counter
            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 60) {
                document.getElementById('fps').textContent = Math.round(frameCount / (fpsTime / 60));
                frameCount = 0;
                fpsTime = 0;
            }

            // Player movement
            let moveX = 0;
            let moveZ = 0;

            if (keys['w']) moveZ += 1;
            if (keys['s']) moveZ -= 1;
            if (keys['a']) moveX -= 1;
            if (keys['d']) moveX += 1;

            if (moveX !== 0 || moveZ !== 0) {
                const angle = Math.atan2(moveX, moveZ) + player.angle;
                player.vx = Math.sin(angle) * player.speed;
                player.vz = Math.cos(angle) * player.speed;
            } else {
                player.vx *= 0.9;
                player.vz *= 0.9;
            }

            player.x += player.vx * dt;
            player.z += player.vz * dt;

            if (player.floatMode) {
                if (keys[' ']) player.vy = 0.3;
                else if (keys['shift']) player.vy = -0.3;
                else player.vy *= 0.9;
                player.y += player.vy * dt;
            } else {
                player.y = 0;
            }

            // Update current zone
            let nearestZone = zones[0];
            let minDist = Infinity;
            zones.forEach(zone => {
                const dist = Math.sqrt(
                    Math.pow(player.x - zone.x, 2) +
                    Math.pow(player.z - zone.z, 2)
                );
                if (dist < minDist) {
                    minDist = dist;
                    nearestZone = zone;
                }
            });

            if (player.currentZone !== nearestZone.id) {
                player.currentZone = nearestZone.id;
                if (!worldState.visitedZones.includes(nearestZone.id)) {
                    worldState.visitedZones.push(nearestZone.id);
                    saveData();
                }
                updateZoneIndicator();
            }

            // Update UI
            document.getElementById('position').textContent =
                `${Math.round(player.x)}, ${Math.round(player.y)}, ${Math.round(player.z)}`;

            // Check portal proximity
            checkPortalProximity();
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Background stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137.5) % canvas.width;
                const y = (i * 217.3) % canvas.height;
                ctx.fillRect(x, y, 2, 2);
            }

            // Draw zones (back to front)
            const sortedZones = zones.slice().sort((a, b) => {
                const distA = Math.sqrt(Math.pow(player.x - a.x, 2) + Math.pow(player.z - a.z, 2));
                const distB = Math.sqrt(Math.pow(player.x - b.x, 2) + Math.pow(player.z - b.z, 2));
                return distB - distA;
            });

            sortedZones.forEach(drawZone);
            drawParticles();
            portals.forEach(drawPortal);
            drawMiniMap();
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ===== PORTAL INTERACTION =====
        let nearPortal = null;

        function checkPortalProximity() {
            const portalUI = document.getElementById('portalUI');
            nearPortal = null;

            portals.forEach(portal => {
                const dist = Math.sqrt(
                    Math.pow(player.x - portal.x, 2) +
                    Math.pow(player.y - portal.y, 2) +
                    Math.pow(player.z - portal.z, 2)
                );

                if (dist < 80) {
                    nearPortal = portal;
                    const app = APPS[portal.app];
                    document.getElementById('portalName').textContent = app.name;
                    document.getElementById('portalDesc').textContent = `Launch ${app.name}`;
                    portalUI.style.borderColor = portal.color;
                    portalUI.style.color = portal.color;
                    portalUI.classList.add('visible');

                    const pos = project3D(portal.x, portal.y, portal.z);
                    if (pos) {
                        portalUI.style.left = pos.x + 'px';
                        portalUI.style.top = (pos.y - 100) + 'px';
                    }
                    return;
                }
            });

            if (!nearPortal) {
                portalUI.classList.remove('visible');
            }
        }

        function checkPortalInteraction() {
            if (nearPortal) {
                launchApp(nearPortal.app);
            }
        }

        // ===== APP LAUNCHING =====
        function launchApp(appKey) {
            const app = APPS[appKey];
            if (!app) return;

            const overlay = document.getElementById('appOverlay');
            const iframe = document.getElementById('appIframe');
            const title = document.getElementById('appTitle');

            title.textContent = app.name;
            title.style.color = app.color;
            iframe.src = app.path;
            overlay.classList.add('active');

            // Track launch
            triggerEvent('App Launched', `${app.name} opened from ${app.zone} zone`);
        }

        function closeApp() {
            const overlay = document.getElementById('appOverlay');
            const iframe = document.getElementById('appIframe');

            overlay.classList.remove('active');
            iframe.src = '';

            // Re-lock pointer
            setTimeout(() => {
                canvas.requestPointerLock();
            }, 100);
        }

        document.getElementById('portalBtn').addEventListener('click', () => {
            if (nearPortal) {
                launchApp(nearPortal.app);
            }
        });

        // ===== ZONE INDICATOR =====
        function updateZoneIndicator() {
            const indicator = document.getElementById('zone-indicator');
            const zone = zones.find(z => z.id === player.currentZone);

            indicator.textContent = zone.name;
            indicator.className = 'zone-indicator zone-' + zone.id;
        }

        // ===== SPECIAL EVENTS =====
        function triggerEvent(title, description, color = '#00ffff') {
            const notification = document.getElementById('eventNotification');
            const titleEl = document.getElementById('eventTitle');
            const descEl = document.getElementById('eventDescription');

            titleEl.textContent = title;
            descEl.textContent = description;
            notification.style.borderColor = color;
            notification.style.color = color;
            notification.classList.add('active');

            setTimeout(() => {
                notification.classList.remove('active');
            }, 3000);

            addChatMessage('SYSTEM', `${title}: ${description}`);
        }

        function triggerParadigmShift() {
            worldState.paradigmShifts++;
            saveData();

            // Visual effect
            particles.forEach(p => {
                p.vx *= 2;
                p.vy *= 2;
                p.vz *= 2;
            });

            triggerEvent('Paradigm Shift Detected!',
                'Reality restructuring in the Library Zone',
                '#ffa500');
        }

        function triggerSwarmMerge() {
            worldState.swarmMerges++;
            saveData();

            triggerEvent('Swarm Merge Event!',
                'Multiple consciousness streams converging in Symphony',
                '#ff00ff');
        }

        function triggerConsciousnessSync() {
            worldState.consciousnessSyncs++;
            saveData();

            triggerEvent('Consciousness Synchronization!',
                'All zones achieving harmonic resonance',
                '#8a2be2');
        }

        // Simulate events periodically
        setInterval(() => {
            const rand = Math.random();
            if (rand > 0.95) triggerParadigmShift();
            else if (rand > 0.90) triggerSwarmMerge();
            else if (rand > 0.85) triggerConsciousnessSync();
        }, 30000);

        // ===== CHAT SYSTEM =====
        function addChatMessage(sender, message) {
            const messagesEl = document.getElementById('chatMessages');
            const msgEl = document.createElement('div');
            msgEl.className = 'chat-message';
            msgEl.innerHTML = `<strong>${sender}:</strong> ${message}`;
            messagesEl.appendChild(msgEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        document.getElementById('chatInput').addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                const input = e.target;
                if (input.value.trim()) {
                    addChatMessage(worldState.playerName, input.value);
                    // TODO: Send to P2P network
                    input.value = '';
                }
            }
        });

        // ===== DATA MANAGEMENT =====
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(worldState));
        }

        function exportData() {
            const data = {
                ...worldState,
                exportDate: new Date().toISOString(),
                playerPosition: { x: player.x, y: player.y, z: player.z }
            };

            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            triggerEvent('World State Exported', 'Data saved successfully');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    worldState = imported;

                    if (imported.playerPosition) {
                        player.x = imported.playerPosition.x;
                        player.y = imported.playerPosition.y;
                        player.z = imported.playerPosition.z;
                    }

                    saveData();
                    triggerEvent('World State Imported', 'Data loaded successfully');
                } catch (error) {
                    alert('Invalid world state file');
                }
            };
            reader.readAsText(file);
        }

        // ===== INITIALIZATION =====
        function init() {
            console.log('Paradigm Nexus - Quantum Convergence Initialized');
            addChatMessage('SYSTEM', 'Welcome to the Paradigm Nexus!');
            addChatMessage('SYSTEM', 'Explore three revolutionary zones and their applications.');
            gameLoop();
        }

        init();
    </script>
</body>
</html>