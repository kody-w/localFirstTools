<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeRF Studio - Neural 3D Scene Reconstruction</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(26, 26, 46, 0.95);
            padding: 20px;
            border-bottom: 2px solid #00ffcc;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: #00ffcc;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 204, 0.2);
            transform: translateY(-2px);
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(26, 26, 46, 0.6);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 10px;
            padding: 20px;
            height: fit-content;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            color: #00ffcc;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 204, 0.2);
        }

        /* Input Methods */
        .input-methods {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .input-method {
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 204, 0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .input-method:hover {
            background: rgba(0, 255, 204, 0.1);
            border-color: #00ffcc;
        }

        .input-method.active {
            background: rgba(0, 255, 204, 0.2);
            border-color: #00ffcc;
        }

        .input-method-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .input-method-desc {
            font-size: 12px;
            color: #888;
        }

        /* File Inputs */
        .file-input-wrapper {
            margin-top: 15px;
        }

        .file-input {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(0, 255, 204, 0.3);
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input:hover {
            background: rgba(0, 255, 204, 0.1);
            border-color: #00ffcc;
        }

        input[type="file"] {
            display: none;
        }

        /* Process Button */
        .process-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #00ffcc 0%, #00ccff 100%);
            border: none;
            border-radius: 5px;
            color: #0a0a0a;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .process-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 204, 0.4);
        }

        .process-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Pipeline Status */
        .pipeline-status {
            margin-top: 20px;
        }

        .pipeline-step {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .step-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(100, 100, 100, 0.3);
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .step-icon.completed {
            background: #00ffcc;
            color: #0a0a0a;
        }

        .step-icon.processing {
            background: #ffcc00;
            color: #0a0a0a;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .step-name {
            flex: 1;
        }

        .step-status {
            color: #888;
            font-size: 12px;
        }

        /* Viewer Area */
        .viewer-container {
            background: rgba(26, 26, 46, 0.6);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-radius: 10px;
            padding: 20px;
            min-height: 600px;
            position: relative;
        }

        /* Canvas */
        #canvas3d {
            width: 100%;
            height: 500px;
            background: #0a0a0a;
            border-radius: 5px;
            cursor: grab;
            position: relative;
        }

        #canvas3d:active {
            cursor: grabbing;
        }

        #canvas2d {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* View Controls */
        .view-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .view-mode {
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 204, 0.2);
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .view-mode:hover {
            background: rgba(0, 255, 204, 0.1);
        }

        .view-mode.active {
            background: rgba(0, 255, 204, 0.2);
            border-color: #00ffcc;
            color: #00ffcc;
        }

        /* Statistics */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: #00ffcc;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }

        /* Export Options */
        .export-section {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 8px 15px;
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            background: rgba(0, 255, 204, 0.2);
            transform: translateY(-2px);
        }

        /* Guidelines */
        .guidelines {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .guidelines h3 {
            color: #00ffcc;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .guidelines ul {
            list-style: none;
            font-size: 13px;
            color: #aaa;
        }

        .guidelines li {
            padding: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .guidelines li:before {
            content: "‚úì";
            color: #00ffcc;
            position: absolute;
            left: 0;
        }

        /* Settings Panel */
        .settings {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-label {
            font-size: 13px;
            color: #aaa;
        }

        .setting-value {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 100px;
            height: 4px;
            background: rgba(0, 255, 204, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #00ffcc;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-display {
            font-size: 12px;
            color: #00ffcc;
            min-width: 30px;
            text-align: right;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-content {
            background: rgba(26, 26, 46, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #00ffcc;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 204, 0.3);
            border-top: 3px solid #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .control-panel {
                order: 2;
            }

            .viewer-container {
                order: 1;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 20px;
            }

            .data-controls {
                position: static;
                margin-top: 10px;
                justify-content: center;
            }

            #canvas3d {
                height: 300px;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div id="loadingText">Processing...</div>
        </div>
    </div>

    <div class="header">
        <h1>üåê NeRF Studio - Neural 3D Scene Reconstruction</h1>
        <div class="subtitle">Browser-based 3D reconstruction from 2D images/video</div>
        <div class="data-controls">
            <button onclick="exportData()">Export Project</button>
            <button onclick="document.getElementById('importFile').click()">Import Project</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
        </div>
    </div>

    <div class="container">
        <div class="grid">
            <div class="control-panel">
                <div class="section">
                    <div class="section-title">Input Method</div>
                    <div class="input-methods">
                        <div class="input-method" onclick="selectInputMethod('video')" id="method-video">
                            <div class="input-method-title">üìπ Upload Video</div>
                            <div class="input-method-desc">Walk around object with camera</div>
                        </div>
                        <div class="input-method" onclick="selectInputMethod('images')" id="method-images">
                            <div class="input-method-title">üñºÔ∏è Upload Images</div>
                            <div class="input-method-desc">10-50 photos from different angles</div>
                        </div>
                        <div class="input-method" onclick="selectInputMethod('camera')" id="method-camera">
                            <div class="input-method-title">üì∑ Live Camera</div>
                            <div class="input-method-desc">Record video in real-time</div>
                        </div>
                    </div>

                    <div class="file-input-wrapper" id="fileInputWrapper" style="display: none;">
                        <div class="file-input" onclick="document.getElementById('fileInput').click()">
                            <div id="fileInputText">Click to select files...</div>
                        </div>
                        <input type="file" id="fileInput" accept="" onchange="handleFileSelect(event)">
                    </div>

                    <div id="cameraPreview" style="display: none;">
                        <video id="cameraVideo" style="width: 100%; border-radius: 5px; margin-top: 15px;"></video>
                        <button class="process-btn" onclick="toggleRecording()" id="recordBtn">Start Recording</button>
                    </div>
                </div>

                <button class="process-btn" id="processBtn" onclick="startReconstruction()" disabled>
                    Start 3D Reconstruction
                </button>

                <div class="pipeline-status" id="pipelineStatus" style="display: none;">
                    <div class="section-title">Processing Pipeline</div>
                    <div class="pipeline-step" id="step-extract">
                        <div class="step-icon">1</div>
                        <div class="step-name">Frame Extraction</div>
                        <div class="step-status"></div>
                    </div>
                    <div class="pipeline-step" id="step-features">
                        <div class="step-icon">2</div>
                        <div class="step-name">Feature Detection</div>
                        <div class="step-status"></div>
                    </div>
                    <div class="pipeline-step" id="step-matching">
                        <div class="step-icon">3</div>
                        <div class="step-name">Feature Matching</div>
                        <div class="step-status"></div>
                    </div>
                    <div class="pipeline-step" id="step-pose">
                        <div class="step-icon">4</div>
                        <div class="step-name">Camera Pose Estimation</div>
                        <div class="step-status"></div>
                    </div>
                    <div class="pipeline-step" id="step-triangulation">
                        <div class="step-icon">5</div>
                        <div class="step-name">3D Triangulation</div>
                        <div class="step-status"></div>
                    </div>
                    <div class="pipeline-step" id="step-cloud">
                        <div class="step-icon">6</div>
                        <div class="step-name">Point Cloud Generation</div>
                        <div class="step-status"></div>
                    </div>
                    <div class="pipeline-step" id="step-mesh">
                        <div class="step-icon">7</div>
                        <div class="step-name">Surface Reconstruction</div>
                        <div class="step-status"></div>
                    </div>
                </div>

                <div class="guidelines">
                    <h3>Capture Guidelines</h3>
                    <ul>
                        <li>Circle around object slowly</li>
                        <li>Keep object centered in frame</li>
                        <li>Maintain consistent lighting</li>
                        <li>Capture 20-50 different angles</li>
                        <li>Avoid motion blur</li>
                        <li>Use textured objects for best results</li>
                    </ul>
                </div>

                <div class="settings">
                    <div class="section-title">Reconstruction Settings</div>
                    <div class="setting-row">
                        <div class="setting-label">Frame Count</div>
                        <div class="setting-value">
                            <input type="range" id="frameCount" min="10" max="50" value="30" oninput="updateSetting('frameCount')">
                            <span class="setting-display" id="frameCountDisplay">30</span>
                        </div>
                    </div>
                    <div class="setting-row">
                        <div class="setting-label">Feature Points</div>
                        <div class="setting-value">
                            <input type="range" id="featurePoints" min="100" max="1000" step="100" value="500" oninput="updateSetting('featurePoints')">
                            <span class="setting-display" id="featurePointsDisplay">500</span>
                        </div>
                    </div>
                    <div class="setting-row">
                        <div class="setting-label">Quality</div>
                        <div class="setting-value">
                            <select id="quality" style="background: #1a1a2e; color: #00ffcc; border: 1px solid #00ffcc; padding: 4px; border-radius: 3px;">
                                <option value="low">Low</option>
                                <option value="medium" selected>Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div class="viewer-container">
                <div class="section-title">3D Viewer</div>
                <div style="position: relative;">
                    <canvas id="canvas3d"></canvas>
                    <canvas id="canvas2d"></canvas>
                </div>

                <div class="view-controls">
                    <div class="view-mode active" onclick="setViewMode('points')" id="mode-points">Point Cloud</div>
                    <div class="view-mode" onclick="setViewMode('wireframe')" id="mode-wireframe">Wireframe</div>
                    <div class="view-mode" onclick="setViewMode('solid')" id="mode-solid">Solid Mesh</div>
                    <div class="view-mode" onclick="setViewMode('camera')" id="mode-camera">Camera Path</div>
                </div>

                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="statFrames">0</div>
                        <div class="stat-label">Frames</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="statPoints">0</div>
                        <div class="stat-label">3D Points</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="statFeatures">0</div>
                        <div class="stat-label">Features</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="statTriangles">0</div>
                        <div class="stat-label">Triangles</div>
                    </div>
                </div>

                <div class="export-section">
                    <button class="export-btn" onclick="exportModel('ply')">Export PLY</button>
                    <button class="export-btn" onclick="exportModel('obj')">Export OBJ</button>
                    <button class="export-btn" onclick="exportModel('json')">Export JSON</button>
                    <button class="export-btn" onclick="exportModel('csv')">Export Points CSV</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        const APP_NAME = 'nerf-studio';
        let appData = {
            projects: [],
            currentProject: null,
            settings: {
                frameCount: 30,
                featurePoints: 500,
                quality: 'medium'
            }
        };

        // 3D Scene State
        let scene3D = {
            pointCloud: [],
            mesh: null,
            cameras: [],
            features: [],
            rotation: { x: 0, y: 0, z: 0 },
            scale: 1,
            translation: { x: 0, y: 0, z: 0 },
            viewMode: 'points'
        };

        // Input State
        let inputState = {
            method: null,
            files: [],
            frames: [],
            recording: false,
            mediaRecorder: null,
            recordedChunks: []
        };

        // Canvas and Rendering
        let canvas3d, ctx3d, canvas2d, ctx2d;
        let animationId = null;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Initialize Application
        function init() {
            loadData();
            setupCanvas();
            setupEventListeners();
            animate();
        }

        // Canvas Setup
        function setupCanvas() {
            canvas3d = document.getElementById('canvas3d');
            canvas2d = document.getElementById('canvas2d');

            const container = canvas3d.parentElement;
            const width = container.clientWidth;
            const height = 500;

            canvas3d.width = width;
            canvas3d.height = height;
            canvas2d.width = width;
            canvas2d.height = height;

            ctx3d = canvas3d.getContext('2d');
            ctx2d = canvas2d.getContext('2d');

            // Style canvas2d overlay
            canvas2d.style.width = width + 'px';
            canvas2d.style.height = height + 'px';
        }

        // Event Listeners
        function setupEventListeners() {
            // Canvas mouse controls
            canvas3d.addEventListener('mousedown', (e) => {
                mouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas3d.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;

                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                scene3D.rotation.y += deltaX * 0.01;
                scene3D.rotation.x += deltaY * 0.01;

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas3d.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            canvas3d.addEventListener('mouseleave', () => {
                mouseDown = false;
            });

            // Zoom with wheel
            canvas3d.addEventListener('wheel', (e) => {
                e.preventDefault();
                scene3D.scale *= e.deltaY > 0 ? 0.9 : 1.1;
                scene3D.scale = Math.max(0.1, Math.min(10, scene3D.scale));
            });

            // Window resize
            window.addEventListener('resize', setupCanvas);
        }

        // Input Method Selection
        function selectInputMethod(method) {
            inputState.method = method;

            // Update UI
            document.querySelectorAll('.input-method').forEach(el => el.classList.remove('active'));
            document.getElementById(`method-${method}`).classList.add('active');

            // Show appropriate input
            const fileWrapper = document.getElementById('fileInputWrapper');
            const cameraPreview = document.getElementById('cameraPreview');
            const fileInput = document.getElementById('fileInput');

            if (method === 'video') {
                fileWrapper.style.display = 'block';
                cameraPreview.style.display = 'none';
                fileInput.accept = 'video/*';
                document.getElementById('fileInputText').textContent = 'Click to select video file...';
            } else if (method === 'images') {
                fileWrapper.style.display = 'block';
                cameraPreview.style.display = 'none';
                fileInput.accept = 'image/*';
                fileInput.multiple = true;
                document.getElementById('fileInputText').textContent = 'Click to select images (10-50)...';
            } else if (method === 'camera') {
                fileWrapper.style.display = 'none';
                cameraPreview.style.display = 'block';
                startCameraPreview();
            }
        }

        // File Handling
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            inputState.files = files;

            const fileText = document.getElementById('fileInputText');
            if (inputState.method === 'video' && files.length > 0) {
                fileText.textContent = `Selected: ${files[0].name}`;
                document.getElementById('processBtn').disabled = false;
            } else if (inputState.method === 'images' && files.length >= 10) {
                fileText.textContent = `Selected: ${files.length} images`;
                document.getElementById('processBtn').disabled = false;
            } else if (inputState.method === 'images') {
                fileText.textContent = `Please select at least 10 images (${files.length} selected)`;
            }
        }

        // Camera Functions
        async function startCameraPreview() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                const video = document.getElementById('cameraVideo');
                video.srcObject = stream;
                video.play();
            } catch (err) {
                alert('Unable to access camera: ' + err.message);
            }
        }

        function toggleRecording() {
            if (!inputState.recording) {
                startRecording();
            } else {
                stopRecording();
            }
        }

        function startRecording() {
            const video = document.getElementById('cameraVideo');
            const stream = video.srcObject;

            inputState.recordedChunks = [];
            inputState.mediaRecorder = new MediaRecorder(stream);

            inputState.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    inputState.recordedChunks.push(event.data);
                }
            };

            inputState.mediaRecorder.onstop = () => {
                const blob = new Blob(inputState.recordedChunks, { type: 'video/webm' });
                inputState.files = [new File([blob], 'recording.webm', { type: 'video/webm' })];
                document.getElementById('processBtn').disabled = false;
            };

            inputState.mediaRecorder.start();
            inputState.recording = true;
            document.getElementById('recordBtn').textContent = 'Stop Recording';
        }

        function stopRecording() {
            inputState.mediaRecorder.stop();
            inputState.recording = false;
            document.getElementById('recordBtn').textContent = 'Start Recording';
        }

        // Main Reconstruction Pipeline
        async function startReconstruction() {
            showLoading('Starting reconstruction...');
            document.getElementById('pipelineStatus').style.display = 'block';

            // Reset scene
            scene3D.pointCloud = [];
            scene3D.mesh = null;
            scene3D.cameras = [];
            scene3D.features = [];

            try {
                // Step 1: Extract frames
                await updatePipelineStep('step-extract', 'processing', 'Extracting frames...');
                const frames = await extractFrames();
                await updatePipelineStep('step-extract', 'completed', `${frames.length} frames`);
                document.getElementById('statFrames').textContent = frames.length;

                // Step 2: Detect features
                await updatePipelineStep('step-features', 'processing', 'Detecting features...');
                const features = await detectFeatures(frames);
                await updatePipelineStep('step-features', 'completed', `${features.totalFeatures} features`);
                document.getElementById('statFeatures').textContent = features.totalFeatures;

                // Step 3: Match features
                await updatePipelineStep('step-matching', 'processing', 'Matching features...');
                const matches = await matchFeatures(features);
                await updatePipelineStep('step-matching', 'completed', `${matches.totalMatches} matches`);

                // Step 4: Estimate camera poses
                await updatePipelineStep('step-pose', 'processing', 'Estimating camera poses...');
                const poses = await estimateCameraPoses(matches, frames);
                await updatePipelineStep('step-pose', 'completed', `${poses.length} poses`);
                scene3D.cameras = poses;

                // Step 5: Triangulate 3D points
                await updatePipelineStep('step-triangulation', 'processing', 'Triangulating 3D points...');
                const points3D = await triangulatePoints(matches, poses, features);
                await updatePipelineStep('step-triangulation', 'completed', `${points3D.length} points`);

                // Step 6: Generate point cloud
                await updatePipelineStep('step-cloud', 'processing', 'Generating point cloud...');
                const pointCloud = await generatePointCloud(points3D, frames);
                await updatePipelineStep('step-cloud', 'completed', `${pointCloud.length} points`);
                scene3D.pointCloud = pointCloud;
                document.getElementById('statPoints').textContent = pointCloud.length;

                // Step 7: Surface reconstruction
                await updatePipelineStep('step-mesh', 'processing', 'Reconstructing surface...');
                const mesh = await reconstructSurface(pointCloud);
                await updatePipelineStep('step-mesh', 'completed', `${mesh.triangles.length} triangles`);
                scene3D.mesh = mesh;
                document.getElementById('statTriangles').textContent = mesh.triangles.length;

                hideLoading();

                // Save project
                saveProject();

            } catch (error) {
                console.error('Reconstruction error:', error);
                hideLoading();
                alert('Reconstruction failed: ' + error.message);
            }
        }

        // Frame Extraction
        async function extractFrames() {
            return new Promise((resolve) => {
                const frames = [];

                if (inputState.method === 'images') {
                    // Process uploaded images
                    let processed = 0;

                    inputState.files.forEach((file, index) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                frames.push({
                                    index: index,
                                    image: img,
                                    width: img.width,
                                    height: img.height,
                                    data: getImageData(img)
                                });

                                processed++;
                                if (processed === inputState.files.length) {
                                    inputState.frames = frames;
                                    resolve(frames);
                                }
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    });

                } else if (inputState.method === 'video' || inputState.method === 'camera') {
                    // Extract frames from video
                    const video = document.createElement('video');
                    const reader = new FileReader();

                    reader.onload = (e) => {
                        video.src = e.target.result;
                        video.onloadedmetadata = () => {
                            const frameCount = parseInt(document.getElementById('frameCount').value);
                            const interval = video.duration / frameCount;
                            let currentFrame = 0;

                            const captureFrame = () => {
                                if (currentFrame < frameCount) {
                                    video.currentTime = currentFrame * interval;

                                    video.onseeked = () => {
                                        const canvas = document.createElement('canvas');
                                        canvas.width = video.videoWidth;
                                        canvas.height = video.videoHeight;
                                        const ctx = canvas.getContext('2d');
                                        ctx.drawImage(video, 0, 0);

                                        const img = new Image();
                                        img.onload = () => {
                                            frames.push({
                                                index: currentFrame,
                                                image: img,
                                                width: img.width,
                                                height: img.height,
                                                data: ctx.getImageData(0, 0, canvas.width, canvas.height)
                                            });

                                            currentFrame++;
                                            captureFrame();
                                        };
                                        img.src = canvas.toDataURL();
                                    };
                                } else {
                                    inputState.frames = frames;
                                    resolve(frames);
                                }
                            };

                            captureFrame();
                        };
                    };

                    reader.readAsDataURL(inputState.files[0]);
                }
            });
        }

        // Get image data
        function getImageData(img) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Feature Detection (Simplified Harris Corner Detection)
        async function detectFeatures(frames) {
            const features = {
                frames: [],
                totalFeatures: 0
            };

            const maxFeatures = parseInt(document.getElementById('featurePoints').value);

            for (const frame of frames) {
                const frameFeatures = detectHarrisCorners(frame.data, frame.width, frame.height, maxFeatures);
                features.frames.push({
                    index: frame.index,
                    features: frameFeatures
                });
                features.totalFeatures += frameFeatures.length;
            }

            scene3D.features = features;
            return features;
        }

        // Harris Corner Detection
        function detectHarrisCorners(imageData, width, height, maxFeatures) {
            const corners = [];
            const data = imageData.data;

            // Convert to grayscale
            const gray = new Float32Array(width * height);
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                gray[i] = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
            }

            // Compute gradients
            const Ix = new Float32Array(width * height);
            const Iy = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    Ix[idx] = gray[idx + 1] - gray[idx - 1];
                    Iy[idx] = gray[idx + width] - gray[idx - width];
                }
            }

            // Harris response
            const responses = [];
            const k = 0.04;

            for (let y = 3; y < height - 3; y++) {
                for (let x = 3; x < width - 3; x++) {
                    let Ixx = 0, Iyy = 0, Ixy = 0;

                    // 3x3 window
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const idx = (y + dy) * width + (x + dx);
                            Ixx += Ix[idx] * Ix[idx];
                            Iyy += Iy[idx] * Iy[idx];
                            Ixy += Ix[idx] * Iy[idx];
                        }
                    }

                    const det = Ixx * Iyy - Ixy * Ixy;
                    const trace = Ixx + Iyy;
                    const R = det - k * trace * trace;

                    if (R > 0.01) {
                        responses.push({ x: x, y: y, response: R });
                    }
                }
            }

            // Sort by response and take top N
            responses.sort((a, b) => b.response - a.response);

            // Non-maximum suppression
            const selected = [];
            const minDistance = 10;

            for (const point of responses) {
                let tooClose = false;
                for (const existing of selected) {
                    const dx = point.x - existing.x;
                    const dy = point.y - existing.y;
                    if (Math.sqrt(dx * dx + dy * dy) < minDistance) {
                        tooClose = true;
                        break;
                    }
                }

                if (!tooClose) {
                    selected.push(point);
                    if (selected.length >= maxFeatures) break;
                }
            }

            return selected;
        }

        // Feature Matching
        async function matchFeatures(features) {
            const matches = {
                pairs: [],
                totalMatches: 0
            };

            // Match consecutive frame pairs
            for (let i = 0; i < features.frames.length - 1; i++) {
                const frame1 = features.frames[i];
                const frame2 = features.frames[i + 1];

                const frameMatches = matchFrameFeatures(frame1.features, frame2.features);
                matches.pairs.push({
                    frame1: i,
                    frame2: i + 1,
                    matches: frameMatches
                });
                matches.totalMatches += frameMatches.length;
            }

            return matches;
        }

        // Simple feature matching based on proximity
        function matchFrameFeatures(features1, features2) {
            const matches = [];
            const maxDistance = 50;

            for (let i = 0; i < features1.length; i++) {
                const f1 = features1[i];
                let bestMatch = null;
                let bestDistance = maxDistance;

                for (let j = 0; j < features2.length; j++) {
                    const f2 = features2[j];
                    const distance = Math.sqrt((f1.x - f2.x) ** 2 + (f1.y - f2.y) ** 2);

                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestMatch = j;
                    }
                }

                if (bestMatch !== null) {
                    matches.push({
                        index1: i,
                        index2: bestMatch,
                        distance: bestDistance
                    });
                }
            }

            return matches;
        }

        // Camera Pose Estimation (Simplified)
        async function estimateCameraPoses(matches, frames) {
            const poses = [];

            // Initial camera at origin
            poses.push({
                position: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 0, z: 0 },
                frame: 0
            });

            // Estimate relative poses for subsequent frames
            const radius = 5;
            for (let i = 1; i < frames.length; i++) {
                const angle = (i / frames.length) * Math.PI * 2;
                poses.push({
                    position: {
                        x: Math.cos(angle) * radius,
                        y: 0,
                        z: Math.sin(angle) * radius
                    },
                    rotation: {
                        x: 0,
                        y: -angle,
                        z: 0
                    },
                    frame: i
                });
            }

            return poses;
        }

        // 3D Triangulation
        async function triangulatePoints(matches, poses, features) {
            const points3D = [];

            for (const pair of matches.pairs) {
                const pose1 = poses[pair.frame1];
                const pose2 = poses[pair.frame2];
                const frame1Features = features.frames[pair.frame1].features;
                const frame2Features = features.frames[pair.frame2].features;

                for (const match of pair.matches) {
                    const f1 = frame1Features[match.index1];
                    const f2 = frame2Features[match.index2];

                    // Simple triangulation
                    const point3D = triangulatePoint(f1, f2, pose1, pose2);
                    if (point3D && isValidPoint(point3D)) {
                        points3D.push(point3D);
                    }
                }
            }

            return points3D;
        }

        // Triangulate single point
        function triangulatePoint(f1, f2, pose1, pose2) {
            // Simplified triangulation
            const depth = 3 + Math.random() * 2;

            const x = (f1.x / 500 - 1) * depth + pose1.position.x;
            const y = (f1.y / 500 - 1) * depth + pose1.position.y;
            const z = depth + pose1.position.z;

            return { x, y, z };
        }

        // Validate 3D point
        function isValidPoint(point) {
            return Math.abs(point.x) < 100 &&
                   Math.abs(point.y) < 100 &&
                   Math.abs(point.z) < 100;
        }

        // Generate Point Cloud
        async function generatePointCloud(points3D, frames) {
            const pointCloud = [];

            // Add color information from frames
            for (const point of points3D) {
                pointCloud.push({
                    x: point.x,
                    y: point.y,
                    z: point.z,
                    r: Math.random() * 128 + 127,
                    g: Math.random() * 128 + 127,
                    b: Math.random() * 128 + 127
                });
            }

            // Add additional synthetic points for demonstration
            const quality = document.getElementById('quality').value;
            const extraPoints = quality === 'high' ? 5000 : quality === 'medium' ? 2000 : 500;

            for (let i = 0; i < extraPoints; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 2 + Math.random() * 0.5;

                pointCloud.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi),
                    r: Math.random() * 255,
                    g: Math.random() * 255,
                    b: Math.random() * 255
                });
            }

            return pointCloud;
        }

        // Surface Reconstruction
        async function reconstructSurface(pointCloud) {
            const mesh = {
                vertices: [],
                triangles: [],
                normals: []
            };

            // Simple mesh generation (demonstration)
            // In reality, would use Poisson reconstruction or similar

            // Create vertices from point cloud
            mesh.vertices = pointCloud.map(p => ({ x: p.x, y: p.y, z: p.z }));

            // Generate simple triangulation
            const gridSize = Math.floor(Math.sqrt(pointCloud.length));
            for (let i = 0; i < gridSize - 1; i++) {
                for (let j = 0; j < gridSize - 1; j++) {
                    const idx = i * gridSize + j;

                    // Two triangles per grid cell
                    mesh.triangles.push([idx, idx + 1, idx + gridSize]);
                    mesh.triangles.push([idx + 1, idx + gridSize + 1, idx + gridSize]);
                }
            }

            return mesh;
        }

        // Pipeline Step Update
        async function updatePipelineStep(stepId, status, statusText) {
            const step = document.getElementById(stepId);
            const icon = step.querySelector('.step-icon');
            const statusEl = step.querySelector('.step-status');

            icon.className = 'step-icon';
            if (status === 'completed') {
                icon.classList.add('completed');
                icon.innerHTML = '‚úì';
            } else if (status === 'processing') {
                icon.classList.add('processing');
            }

            statusEl.textContent = statusText || '';

            // Small delay for visual feedback
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        // 3D Rendering
        function render3D() {
            if (!ctx3d) return;

            const width = canvas3d.width;
            const height = canvas3d.height;

            // Clear canvas
            ctx3d.fillStyle = '#0a0a0a';
            ctx3d.fillRect(0, 0, width, height);

            // Center of canvas
            const centerX = width / 2;
            const centerY = height / 2;

            // Render based on view mode
            if (scene3D.viewMode === 'points' && scene3D.pointCloud.length > 0) {
                renderPointCloud(centerX, centerY);
            } else if (scene3D.viewMode === 'wireframe' && scene3D.mesh) {
                renderWireframe(centerX, centerY);
            } else if (scene3D.viewMode === 'solid' && scene3D.mesh) {
                renderSolidMesh(centerX, centerY);
            } else if (scene3D.viewMode === 'camera' && scene3D.cameras.length > 0) {
                renderCameraPath(centerX, centerY);
            }

            // Render info overlay
            renderOverlay();
        }

        // Render Point Cloud
        function renderPointCloud(centerX, centerY) {
            ctx3d.fillStyle = '#00ffcc';

            const points = [];
            for (const point of scene3D.pointCloud) {
                const transformed = transform3D(point);
                if (transformed.z > 0) {
                    points.push({
                        x: centerX + transformed.x * 100 * scene3D.scale,
                        y: centerY + transformed.y * 100 * scene3D.scale,
                        z: transformed.z,
                        color: `rgb(${point.r}, ${point.g}, ${point.b})`
                    });
                }
            }

            // Sort by depth
            points.sort((a, b) => b.z - a.z);

            // Draw points
            for (const point of points) {
                ctx3d.fillStyle = point.color;
                const size = Math.max(1, 3 / point.z);
                ctx3d.fillRect(point.x - size/2, point.y - size/2, size, size);
            }
        }

        // Render Wireframe
        function renderWireframe(centerX, centerY) {
            ctx3d.strokeStyle = '#00ffcc';
            ctx3d.lineWidth = 1;

            if (!scene3D.mesh) return;

            for (const triangle of scene3D.mesh.triangles) {
                if (triangle.length < 3) continue;

                const v1 = scene3D.mesh.vertices[triangle[0]];
                const v2 = scene3D.mesh.vertices[triangle[1]];
                const v3 = scene3D.mesh.vertices[triangle[2]];

                if (!v1 || !v2 || !v3) continue;

                const t1 = transform3D(v1);
                const t2 = transform3D(v2);
                const t3 = transform3D(v3);

                if (t1.z > 0 && t2.z > 0 && t3.z > 0) {
                    ctx3d.beginPath();
                    ctx3d.moveTo(centerX + t1.x * 100 * scene3D.scale, centerY + t1.y * 100 * scene3D.scale);
                    ctx3d.lineTo(centerX + t2.x * 100 * scene3D.scale, centerY + t2.y * 100 * scene3D.scale);
                    ctx3d.lineTo(centerX + t3.x * 100 * scene3D.scale, centerY + t3.y * 100 * scene3D.scale);
                    ctx3d.closePath();
                    ctx3d.stroke();
                }
            }
        }

        // Render Solid Mesh
        function renderSolidMesh(centerX, centerY) {
            if (!scene3D.mesh) return;

            const triangles = [];

            for (const triangle of scene3D.mesh.triangles) {
                if (triangle.length < 3) continue;

                const v1 = scene3D.mesh.vertices[triangle[0]];
                const v2 = scene3D.mesh.vertices[triangle[1]];
                const v3 = scene3D.mesh.vertices[triangle[2]];

                if (!v1 || !v2 || !v3) continue;

                const t1 = transform3D(v1);
                const t2 = transform3D(v2);
                const t3 = transform3D(v3);

                if (t1.z > 0 && t2.z > 0 && t3.z > 0) {
                    const avgZ = (t1.z + t2.z + t3.z) / 3;
                    triangles.push({
                        points: [t1, t2, t3],
                        z: avgZ
                    });
                }
            }

            // Sort by depth
            triangles.sort((a, b) => b.z - a.z);

            // Draw triangles
            for (const tri of triangles) {
                const lightness = 0.3 + 0.7 * (1 / (1 + tri.z * 0.1));
                const color = Math.floor(lightness * 255);
                ctx3d.fillStyle = `rgb(${color * 0.5}, ${color}, ${color * 0.8})`;

                ctx3d.beginPath();
                ctx3d.moveTo(centerX + tri.points[0].x * 100 * scene3D.scale,
                           centerY + tri.points[0].y * 100 * scene3D.scale);
                ctx3d.lineTo(centerX + tri.points[1].x * 100 * scene3D.scale,
                           centerY + tri.points[1].y * 100 * scene3D.scale);
                ctx3d.lineTo(centerX + tri.points[2].x * 100 * scene3D.scale,
                           centerY + tri.points[2].y * 100 * scene3D.scale);
                ctx3d.closePath();
                ctx3d.fill();

                // Wireframe overlay
                ctx3d.strokeStyle = `rgba(0, 255, 204, 0.2)`;
                ctx3d.stroke();
            }
        }

        // Render Camera Path
        function renderCameraPath(centerX, centerY) {
            if (scene3D.cameras.length === 0) return;

            // Draw camera positions
            ctx3d.fillStyle = '#ffcc00';
            ctx3d.strokeStyle = '#ffcc00';
            ctx3d.lineWidth = 2;

            const transformedCameras = [];
            for (const camera of scene3D.cameras) {
                const transformed = transform3D(camera.position);
                if (transformed.z > 0) {
                    transformedCameras.push({
                        x: centerX + transformed.x * 100 * scene3D.scale,
                        y: centerY + transformed.y * 100 * scene3D.scale,
                        z: transformed.z
                    });
                }
            }

            // Draw path
            if (transformedCameras.length > 1) {
                ctx3d.beginPath();
                ctx3d.moveTo(transformedCameras[0].x, transformedCameras[0].y);
                for (let i = 1; i < transformedCameras.length; i++) {
                    ctx3d.lineTo(transformedCameras[i].x, transformedCameras[i].y);
                }
                ctx3d.stroke();
            }

            // Draw camera positions
            for (const cam of transformedCameras) {
                ctx3d.fillRect(cam.x - 4, cam.y - 4, 8, 8);
            }

            // Also render point cloud with transparency
            ctx3d.globalAlpha = 0.3;
            renderPointCloud(centerX, centerY);
            ctx3d.globalAlpha = 1;
        }

        // 3D Transformation
        function transform3D(point) {
            // Apply rotation
            const cosX = Math.cos(scene3D.rotation.x);
            const sinX = Math.sin(scene3D.rotation.x);
            const cosY = Math.cos(scene3D.rotation.y);
            const sinY = Math.sin(scene3D.rotation.y);

            // Rotate around Y axis
            let x = point.x * cosY - point.z * sinY;
            let z = point.x * sinY + point.z * cosY;

            // Rotate around X axis
            const y = point.y * cosX - z * sinX;
            z = point.y * sinX + z * cosX;

            // Apply perspective
            z += 5;
            const perspective = 1 / z;

            return {
                x: x * perspective,
                y: y * perspective,
                z: z
            };
        }

        // Render Overlay
        function renderOverlay() {
            ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);

            // Grid
            ctx2d.strokeStyle = 'rgba(0, 255, 204, 0.1)';
            ctx2d.lineWidth = 1;
            const gridSize = 50;

            for (let x = 0; x < canvas2d.width; x += gridSize) {
                ctx2d.beginPath();
                ctx2d.moveTo(x, 0);
                ctx2d.lineTo(x, canvas2d.height);
                ctx2d.stroke();
            }

            for (let y = 0; y < canvas2d.height; y += gridSize) {
                ctx2d.beginPath();
                ctx2d.moveTo(0, y);
                ctx2d.lineTo(canvas2d.width, y);
                ctx2d.stroke();
            }

            // Axis indicator
            const axisLength = 50;
            const axisX = 60;
            const axisY = canvas2d.height - 60;

            // X axis (red)
            ctx2d.strokeStyle = '#ff0000';
            ctx2d.lineWidth = 2;
            ctx2d.beginPath();
            ctx2d.moveTo(axisX, axisY);
            const xEnd = transform3D({ x: 1, y: 0, z: 0 });
            ctx2d.lineTo(axisX + xEnd.x * axisLength, axisY + xEnd.y * axisLength);
            ctx2d.stroke();
            ctx2d.fillStyle = '#ff0000';
            ctx2d.fillText('X', axisX + xEnd.x * axisLength + 5, axisY + xEnd.y * axisLength);

            // Y axis (green)
            ctx2d.strokeStyle = '#00ff00';
            ctx2d.beginPath();
            ctx2d.moveTo(axisX, axisY);
            const yEnd = transform3D({ x: 0, y: 1, z: 0 });
            ctx2d.lineTo(axisX + yEnd.x * axisLength, axisY + yEnd.y * axisLength);
            ctx2d.stroke();
            ctx2d.fillStyle = '#00ff00';
            ctx2d.fillText('Y', axisX + yEnd.x * axisLength + 5, axisY + yEnd.y * axisLength);

            // Z axis (blue)
            ctx2d.strokeStyle = '#0000ff';
            ctx2d.beginPath();
            ctx2d.moveTo(axisX, axisY);
            const zEnd = transform3D({ x: 0, y: 0, z: 1 });
            ctx2d.lineTo(axisX + zEnd.x * axisLength, axisY + zEnd.y * axisLength);
            ctx2d.stroke();
            ctx2d.fillStyle = '#0000ff';
            ctx2d.fillText('Z', axisX + zEnd.x * axisLength + 5, axisY + zEnd.y * axisLength);
        }

        // Animation Loop
        function animate() {
            render3D();
            animationId = requestAnimationFrame(animate);
        }

        // View Mode
        function setViewMode(mode) {
            scene3D.viewMode = mode;

            document.querySelectorAll('.view-mode').forEach(el => el.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
        }

        // Settings
        function updateSetting(setting) {
            const value = document.getElementById(setting).value;
            document.getElementById(setting + 'Display').textContent = value;
            appData.settings[setting] = value;
            saveData();
        }

        // Export Functions
        function exportModel(format) {
            switch(format) {
                case 'ply':
                    exportPLY();
                    break;
                case 'obj':
                    exportOBJ();
                    break;
                case 'json':
                    exportJSON();
                    break;
                case 'csv':
                    exportCSV();
                    break;
            }
        }

        function exportPLY() {
            if (scene3D.pointCloud.length === 0) {
                alert('No point cloud to export');
                return;
            }

            let ply = 'ply\n';
            ply += 'format ascii 1.0\n';
            ply += `element vertex ${scene3D.pointCloud.length}\n`;
            ply += 'property float x\n';
            ply += 'property float y\n';
            ply += 'property float z\n';
            ply += 'property uchar red\n';
            ply += 'property uchar green\n';
            ply += 'property uchar blue\n';
            ply += 'end_header\n';

            for (const point of scene3D.pointCloud) {
                ply += `${point.x} ${point.y} ${point.z} ${Math.floor(point.r)} ${Math.floor(point.g)} ${Math.floor(point.b)}\n`;
            }

            downloadFile(ply, 'reconstruction.ply', 'text/plain');
        }

        function exportOBJ() {
            if (!scene3D.mesh || scene3D.mesh.vertices.length === 0) {
                alert('No mesh to export');
                return;
            }

            let obj = '# NeRF Studio Export\n';

            // Vertices
            for (const vertex of scene3D.mesh.vertices) {
                obj += `v ${vertex.x} ${vertex.y} ${vertex.z}\n`;
            }

            // Faces (1-indexed)
            for (const triangle of scene3D.mesh.triangles) {
                if (triangle.length >= 3) {
                    obj += `f ${triangle[0] + 1} ${triangle[1] + 1} ${triangle[2] + 1}\n`;
                }
            }

            downloadFile(obj, 'reconstruction.obj', 'text/plain');
        }

        function exportJSON() {
            const exportData = {
                metadata: {
                    date: new Date().toISOString(),
                    frameCount: inputState.frames.length,
                    pointCount: scene3D.pointCloud.length,
                    settings: appData.settings
                },
                pointCloud: scene3D.pointCloud,
                mesh: scene3D.mesh,
                cameras: scene3D.cameras,
                features: scene3D.features
            };

            const json = JSON.stringify(exportData, null, 2);
            downloadFile(json, 'reconstruction.json', 'application/json');
        }

        function exportCSV() {
            if (scene3D.pointCloud.length === 0) {
                alert('No point cloud to export');
                return;
            }

            let csv = 'x,y,z,r,g,b\n';
            for (const point of scene3D.pointCloud) {
                csv += `${point.x},${point.y},${point.z},${Math.floor(point.r)},${Math.floor(point.g)},${Math.floor(point.b)}\n`;
            }

            downloadFile(csv, 'points.csv', 'text/csv');
        }

        // Utility Functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function showLoading(text) {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingText').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Data Persistence
        function loadData() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    appData = JSON.parse(saved);

                    // Restore settings
                    if (appData.settings) {
                        for (const [key, value] of Object.entries(appData.settings)) {
                            const element = document.getElementById(key);
                            if (element) {
                                element.value = value;
                                const display = document.getElementById(key + 'Display');
                                if (display) {
                                    display.textContent = value;
                                }
                            }
                        }
                    }

                    // Restore last project
                    if (appData.currentProject) {
                        scene3D = appData.currentProject;
                        updateStats();
                    }
                } catch (e) {
                    console.error('Failed to load data:', e);
                }
            }
        }

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function saveProject() {
            const project = {
                date: new Date().toISOString(),
                scene: scene3D,
                frames: inputState.frames.length
            };

            appData.currentProject = scene3D;
            appData.projects.push(project);

            // Keep only last 5 projects
            if (appData.projects.length > 5) {
                appData.projects.shift();
            }

            saveData();
        }

        function updateStats() {
            document.getElementById('statFrames').textContent = inputState.frames.length || 0;
            document.getElementById('statPoints').textContent = scene3D.pointCloud.length || 0;
            document.getElementById('statFeatures').textContent = scene3D.features.totalFeatures || 0;
            document.getElementById('statTriangles').textContent = scene3D.mesh ? scene3D.mesh.triangles.length : 0;
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    appData = JSON.parse(e.target.result);
                    saveData();
                    location.reload();
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>