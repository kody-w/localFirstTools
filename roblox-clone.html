<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Clone - 3D Block World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 100;
        }

        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #health {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        #healthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #51cf66);
            transition: width 0.3s ease;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            pointer-events: all;
        }

        .inventorySlot {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            background: rgba(255,255,255,0.1);
        }

        .inventorySlot:hover {
            border-color: rgba(255,255,255,0.8);
            transform: scale(1.1);
            background: rgba(255,255,255,0.2);
        }

        .inventorySlot.active {
            border-color: #ffd43b;
            box-shadow: 0 0 20px rgba(255,212,59,0.5);
            background: rgba(255,212,59,0.2);
        }

        .blockPreview {
            width: 40px;
            height: 40px;
            border-radius: 4px;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
        }

        #controls h3 {
            margin-bottom: 10px;
            color: #ffd43b;
        }

        #controls div {
            margin: 5px 0;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1000;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        #crosshair::before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }

        #crosshair::after {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }

        #startScreen h1 {
            font-size: 72px;
            color: white;
            margin-bottom: 20px;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #startButton {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #startButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
        }

        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            animation: fadeInOut 2s ease;
            pointer-events: none;
            z-index: 500;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="health">
                <div id="healthBar"></div>
            </div>
        </div>

        <div id="crosshair"></div>

        <div id="inventory">
            <div class="inventorySlot active" data-block="grass">
                <div class="blockPreview" style="background: linear-gradient(135deg, #27ae60, #2ecc71);"></div>
            </div>
            <div class="inventorySlot" data-block="stone">
                <div class="blockPreview" style="background: linear-gradient(135deg, #7f8c8d, #95a5a6);"></div>
            </div>
            <div class="inventorySlot" data-block="wood">
                <div class="blockPreview" style="background: linear-gradient(135deg, #8b6f47, #a0826d);"></div>
            </div>
            <div class="inventorySlot" data-block="brick">
                <div class="blockPreview" style="background: linear-gradient(135deg, #c0392b, #e74c3c);"></div>
            </div>
            <div class="inventorySlot" data-block="gold">
                <div class="blockPreview" style="background: linear-gradient(135deg, #f39c12, #f1c40f);"></div>
            </div>
        </div>

        <div id="controls">
            <h3>Controls</h3>
            <div>WASD - Move</div>
            <div>Space - Jump</div>
            <div>Shift - Run</div>
            <div>Mouse - Look</div>
            <div>Left Click - Place Block</div>
            <div>Right Click - Remove Block</div>
            <div>1-5 - Select Block</div>
        </div>

        <canvas id="minimap"></canvas>

        <div id="startScreen">
            <h1>BLOCK WORLD</h1>
            <button id="startButton">START GAME</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let player, playerVelocity;
        let blocks = [];
        let raycaster, mouse;
        let score = 0;
        let health = 100;
        let isJumping = false;
        let isRunning = false;
        let currentBlockType = 'grass';
        let gameStarted = false;
        let keys = {};
        let clock;
        let particles = [];
        let miniMapRenderer, miniMapCamera;

        // Block types with colors
        const blockTypes = {
            grass: { color: 0x2ecc71, emissive: 0x27ae60 },
            stone: { color: 0x95a5a6, emissive: 0x7f8c8d },
            wood: { color: 0xa0826d, emissive: 0x8b6f47 },
            brick: { color: 0xe74c3c, emissive: 0xc0392b },
            gold: { color: 0xf1c40f, emissive: 0xf39c12 }
        };

        // Initialize Three.js
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Clock for animations
            clock = new THREE.Clock();

            // Raycaster for block interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create player
            createPlayer();

            // Create initial world
            createWorld();

            // Setup minimap
            setupMinimap();

            // Setup controls
            setupControls();

            // Start animation loop
            animate();
        }

        function createPlayer() {
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3498db,
                emissive: 0x2980b9,
                emissiveIntensity: 0.2
            });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 3, 0);
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);

            playerVelocity = new THREE.Vector3(0, 0, 0);
        }

        function createWorld() {
            // Create ground
            const groundSize = 50;
            for (let x = -groundSize/2; x < groundSize/2; x += 2) {
                for (let z = -groundSize/2; z < groundSize/2; z += 2) {
                    if (Math.random() > 0.3) {
                        createBlock(x, 0, z, 'grass');
                    }
                }
            }

            // Create some random structures
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 40 - 20;
                const z = Math.random() * 40 - 20;
                const height = Math.random() * 5 + 2;
                for (let y = 0; y < height; y++) {
                    createBlock(x, y * 2, z, Object.keys(blockTypes)[Math.floor(Math.random() * 5)]);
                }
            }

            // Create sky sphere
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        function createBlock(x, y, z, type) {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhongMaterial({
                color: blockTypes[type].color,
                emissive: blockTypes[type].emissive,
                emissiveIntensity: 0.1
            });
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { type: type };
            scene.add(block);
            blocks.push(block);
            return block;
        }

        function removeBlock(block) {
            const index = blocks.indexOf(block);
            if (index > -1) {
                blocks.splice(index, 1);
                scene.remove(block);
                createParticles(block.position);
                updateScore(10);
            }
        }

        function createParticles(position) {
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const particleMaterial = new THREE.MeshPhongMaterial({
                    color: Math.random() * 0xffffff
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                particle.lifetime = 1;
                scene.add(particle);
                particles.push(particle);
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.lifetime -= delta;
                if (particle.lifetime <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                } else {
                    particle.position.add(particle.velocity);
                    particle.velocity.y -= 0.02;
                    particle.rotation.x += 0.1;
                    particle.rotation.y += 0.1;
                    particle.scale.multiplyScalar(0.95);
                }
            }
        }

        function setupMinimap() {
            const minimapCanvas = document.getElementById('minimap');
            miniMapRenderer = new THREE.WebGLRenderer({ 
                canvas: minimapCanvas,
                alpha: true 
            });
            miniMapRenderer.setSize(150, 150);

            miniMapCamera = new THREE.OrthographicCamera(-25, 25, 25, -25, 0.1, 1000);
            miniMapCamera.position.set(0, 50, 0);
            miniMapCamera.lookAt(0, 0, 0);
        }

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                // Block selection
                if (e.key >= '1' && e.key <= '5') {
                    const index = parseInt(e.key) - 1;
                    const slots = document.querySelectorAll('.inventorySlot');
                    slots.forEach(s => s.classList.remove('active'));
                    slots[index].classList.add('active');
                    currentBlockType = slots[index].dataset.block;
                }

                if (e.key.toLowerCase() === 'shift') {
                    isRunning = true;
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                if (e.key.toLowerCase() === 'shift') {
                    isRunning = false;
                }
            });

            // Mouse controls
            document.addEventListener('mousemove', (e) => {
                if (!gameStarted) return;
                
                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                player.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            // Click controls
            document.addEventListener('click', (e) => {
                if (!gameStarted) return;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(blocks);

                if (e.button === 0) { // Left click - place block
                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        const normal = intersect.face.normal;
                        const position = intersect.object.position.clone();
                        position.add(normal.multiplyScalar(2));
                        createBlock(position.x, position.y, position.z, currentBlockType);
                        updateScore(5);
                        showNotification('+5 Score!');
                    }
                }
            });

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (!gameStarted) return;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(blocks);

                if (intersects.length > 0) {
                    removeBlock(intersects[0].object);
                }
            });

            // Inventory slots
            document.querySelectorAll('.inventorySlot').forEach(slot => {
                slot.addEventListener('click', () => {
                    document.querySelectorAll('.inventorySlot').forEach(s => s.classList.remove('active'));
                    slot.classList.add('active');
                    currentBlockType = slot.dataset.block;
                });
            });

            // Start button
            document.getElementById('startButton').addEventListener('click', startGame);

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function startGame() {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 500);
            gameStarted = true;
            
            // Lock pointer for better control
            document.body.requestPointerLock = document.body.requestPointerLock || 
                                              document.body.mozRequestPointerLock;
            document.body.requestPointerLock();
        }

        function updatePlayer(delta) {
            if (!gameStarted) return;

            const speed = isRunning ? 15 : 8;
            const moveSpeed = speed * delta;

            // Movement
            if (keys['w']) {
                player.position.z -= Math.cos(player.rotation.y) * moveSpeed;
                player.position.x -= Math.sin(player.rotation.y) * moveSpeed;
            }
            if (keys['s']) {
                player.position.z += Math.cos(player.rotation.y) * moveSpeed;
                player.position.x += Math.sin(player.rotation.y) * moveSpeed;
            }
            if (keys['a']) {
                player.position.x -= Math.cos(player.rotation.y) * moveSpeed;
                player.position.z += Math.sin(player.rotation.y) * moveSpeed;
            }
            if (keys['d']) {
                player.position.x += Math.cos(player.rotation.y) * moveSpeed;
                player.position.z -= Math.sin(player.rotation.y) * moveSpeed;
            }

            // Jump
            if (keys[' '] && !isJumping) {
                playerVelocity.y = 0.3;
                isJumping = true;
            }

            // Apply gravity
            playerVelocity.y -= 0.015;
            player.position.y += playerVelocity.y;

            // Ground collision
            if (player.position.y <= 3) {
                player.position.y = 3;
                playerVelocity.y = 0;
                isJumping = false;
            }

            // Update camera to follow player
            camera.position.x = player.position.x;
            camera.position.y = player.position.y + 2;
            camera.position.z = player.position.z + 5;

            // Keep player in bounds
            player.position.x = Math.max(-50, Math.min(50, player.position.x));
            player.position.z = Math.max(-50, Math.min(50, player.position.z));
        }

        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = `Score: ${score}`;
        }

        function updateHealth(amount) {
            health = Math.max(0, Math.min(100, health + amount));
            document.getElementById('healthBar').style.width = health + '%';
        }

        function showNotification(text) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = text;
            document.getElementById('gameContainer').appendChild(notification);
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            updatePlayer(delta);
            updateParticles(delta);

            // Rotate some blocks for effect
            blocks.forEach((block, index) => {
                if (block.userData.type === 'gold') {
                    block.rotation.y += 0.01;
                }
            });

            // Render main view
            renderer.render(scene, camera);

            // Render minimap
            if (miniMapRenderer && miniMapCamera) {
                miniMapCamera.position.x = player.position.x;
                miniMapCamera.position.z = player.position.z;
                miniMapRenderer.render(scene, miniMapCamera);
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>