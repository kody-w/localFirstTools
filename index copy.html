<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Local First Tools Gallery - Xbox Controller Support</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #06ffa5;
            --accent-secondary: #ff006e;
            --accent-tertiary: #8338ec;
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 30, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 30, 120, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 10%, rgba(30, 255, 120, 0.3) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes drift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            33% { transform: scale(1.1) rotate(120deg); }
            66% { transform: scale(0.95) rotate(240deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 60px 20px 40px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 40px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        @media (max-width: 768px) {
            .header {
                padding: 40px 20px 30px;
            }
        }

        h1 {
            font-size: 5em;
            font-weight: 100;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 3em;
                letter-spacing: 0.1em;
            }
        }

        h1::before {
            content: 'LOCAL FIRST TOOLS';
            position: absolute;
            left: 0;
            top: 0;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.5em;
            font-weight: 200;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .subtitle {
                font-size: 1.2em;
                letter-spacing: 0.3em;
            }
        }

        .description {
            max-width: 600px;
            margin: 20px auto;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            font-weight: 300;
        }

        .search-container {
            margin-bottom: 30px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            font-size: 1.1em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border);
            border-radius: 30px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(6, 255, 165, 0.1);
            background: rgba(255, 255, 255, 0.15);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }

        .stumble-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        @media (max-width: 768px) {
            .stumble-container {
                gap: 10px;
            }
        }

        .stumble-button {
            padding: 15px 40px;
            background: linear-gradient(135deg, #06ffa5, #00d2d3);
            border: none;
            border-radius: 30px;
            color: var(--bg-primary);
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
            position: relative;
            overflow: hidden;
        }

        .stumble-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .stumble-button:active::before {
            width: 300px;
            height: 300px;
        }

        @media (max-width: 768px) {
            .stumble-button {
                padding: 12px 30px;
                font-size: 1em;
            }
        }

        .stumble-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 40px rgba(6, 255, 165, 0.4);
        }

        .stumble-button:active {
            transform: scale(0.98);
        }

        .category-filter {
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='white' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
            padding-right: 45px;
        }

        @media (max-width: 768px) {
            .category-filter {
                padding: 12px 25px;
                padding-right: 40px;
                font-size: 0.9em;
            }
        }

        .category-filter:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .category-filter:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(6, 255, 165, 0.1);
        }

        .category-filter option {
            background: var(--bg-secondary);
            color: white;
            padding: 10px;
        }

        .history-button {
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: none;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .history-button {
                padding: 12px 25px;
                font-size: 0.9em;
            }
        }

        .history-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .history-button:active {
            transform: scale(0.98);
        }

        .gallery-modes {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .gallery-modes {
                gap: 15px;
            }
        }

        .mode-button {
            padding: 15px 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .mode-button {
                padding: 12px 30px;
                font-size: 1em;
            }
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode:hover {
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 768px) {
            .tools-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        .tool-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: inherit;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        .tool-card.pinned {
            border-color: var(--accent-secondary);
            background: rgba(255, 0, 110, 0.05);
        }

        .tool-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, var(--accent), var(--accent-tertiary));
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .tool-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(255, 255, 255, 0.1), transparent 40%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        @media (hover: hover) {
            .tool-card:hover::after {
                opacity: 1;
            }

            .tool-card:hover {
                transform: translateY(-2px);
                border-color: var(--accent);
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5),
                           0 0 60px rgba(138, 43, 226, 0.2);
                background: rgba(255, 255, 255, 0.05);
            }

            .tool-card:hover::before {
                transform: translateX(0);
            }
        }

        @media (hover: none) {
            .tool-card:active {
                transform: scale(0.98);
                background: rgba(255, 255, 255, 0.05);
            }
        }

        .pin-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .pin-button:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            transform: scale(1.1);
        }

        .pin-button.pinned {
            background: var(--accent-secondary);
            border-color: var(--accent-secondary);
            color: white;
        }

        .tool-preview {
            width: 100%;
            height: 150px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            position: relative;
            overflow: hidden;
        }

        .tool-preview::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shine {
            0% { transform: rotate(0deg) translateX(-100%); }
            100% { transform: rotate(0deg) translateX(100%); }
        }

        .tool-title {
            font-size: 1.5em;
            font-weight: 300;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        .tool-filename {
            color: var(--text-secondary);
            font-size: 0.9em;
            font-family: 'Monaco', 'Menlo', monospace;
            margin-bottom: 10px;
        }

        .tool-description {
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            margin-bottom: 20px;
            flex-grow: 1;
            font-weight: 300;
        }

        .tool-meta {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
        }

        .tool-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.5);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .vote-count {
            color: var(--accent);
        }

        .tool-actions {
            display: flex;
            gap: 15px;
            margin-top: auto;
        }

        .view-button, .vote-button, .download-button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 400;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .view-button {
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-tertiary));
            color: white;
        }

        .view-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .view-button:active {
            transform: scale(0.98);
        }

        .vote-button {
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--accent);
            position: relative;
            overflow: hidden;
        }

        .vote-button:hover {
            background: rgba(6, 255, 165, 0.1);
            transform: scale(1.05);
        }

        .vote-button.voted {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .download-button {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .download-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .download-button:active {
            transform: scale(0.98);
        }

        /* Vote popup */
        .vote-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .vote-popup.show {
            display: block;
        }

        .vote-popup h3 {
            font-size: 1.8em;
            font-weight: 300;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .vote-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .vote-textarea {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
            min-height: 100px;
            outline: none;
        }

        .vote-textarea:focus {
            border-color: var(--accent);
        }

        .vote-textarea::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .vote-actions {
            display: flex;
            gap: 10px;
        }

        .submit-vote, .cancel-vote {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .submit-vote {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .submit-vote:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(6, 255, 165, 0.3);
        }

        .cancel-vote {
            background: transparent;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .cancel-vote:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .vote-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }

        .vote-popup-overlay.show {
            display: block;
        }

        .loading {
            text-align: center;
            padding: 100px 20px;
            color: var(--text-secondary);
            font-size: 1.2em;
            font-weight: 200;
            letter-spacing: 0.1em;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        .error {
            text-align: center;
            padding: 40px;
            color: var(--accent-secondary);
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
            margin: 20px auto;
            border: 1px solid rgba(255, 0, 110, 0.2);
            max-width: 600px;
        }

        .no-results {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .stats {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 40px;
        }

        .github-link {
            text-align: center;
            padding: 30px 20px;
            margin-top: 20px;
            border-top: 1px solid var(--border);
        }

        .github-link a {
            color: var(--accent);
            text-decoration: none;
            font-size: 1.1em;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .github-link a:hover {
            color: var(--accent-tertiary);
            transform: translateY(-2px);
        }

        .github-link svg {
            vertical-align: middle;
            transition: transform 0.3s ease;
        }

        .github-link a:hover svg {
            transform: scale(1.1);
        }

        .section-title {
            font-size: 2.5em;
            font-weight: 100;
            text-align: center;
            margin-bottom: 40px;
            letter-spacing: 0.1em;
            position: relative;
            padding-bottom: 20px;
        }

        @media (max-width: 768px) {
            .section-title {
                font-size: 2em;
                margin-bottom: 30px;
            }
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        }

        .exhibition-section {
            margin-bottom: 60px;
        }

        .content {
            padding: 40px 20px 80px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .content.hidden {
            display: none;
        }

        /* 3D Gallery Styles */
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            touch-action: none;
        }

        #three-container.active {
            display: block;
        }

        .three-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }

        .back-button {
            padding: 12px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 1em;
            color: rgba(255, 255, 255, 0.9);
            z-index: 1001;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 90%;
        }

        .controls-hint .controller-icon {
            display: inline-block;
            margin: 0 5px;
            padding: 3px 8px;
            background: rgba(6, 255, 165, 0.2);
            border-radius: 5px;
            color: var(--accent);
            font-weight: bold;
        }

        .gamepad-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .gamepad-status.connected {
            border-color: var(--accent);
            color: var(--accent);
        }

        .mobile-controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1001;
            gap: 20px;
        }

        .mobile-controls.show {
            display: flex;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        .artwork-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .artwork-tooltip {
                padding: 20px;
                max-width: 300px;
            }
        }

        .artwork-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #fff;
        }

        @media (max-width: 768px) {
            .tooltip-title {
                font-size: 1.2em;
            }
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: var(--accent-secondary);
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 15px 30px;
            color: white;
            font-size: 1em;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--accent);
            color: var(--accent);
        }

        .toast.error {
            border-color: var(--accent-secondary);
            color: var(--accent-secondary);
        }

        /* Stumble Modal */
        .stumble-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .stumble-modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .stumble-modal {
            background: var(--bg-secondary);
            border: 2px solid var(--accent);
            border-radius: 20px;
            padding: 40px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideUp 0.4s ease;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .stumble-modal {
                padding: 30px 20px;
                width: 95%;
            }
        }

        .stumble-modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .stumble-modal-close:hover {
            background: var(--accent-secondary);
            border-color: var(--accent-secondary);
            transform: rotate(90deg);
        }

        .stumble-modal-icon {
            font-size: 5em;
            text-align: center;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .stumble-modal-title {
            font-size: 2.5em;
            font-weight: 300;
            margin-bottom: 15px;
            text-align: center;
            color: var(--accent);
            letter-spacing: 0.05em;
        }

        @media (max-width: 768px) {
            .stumble-modal-title {
                font-size: 2em;
            }
        }

        .stumble-modal-category {
            text-align: center;
            color: var(--text-secondary);
            font-size: 1em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stumble-modal-filename {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9em;
            font-family: 'Monaco', 'Menlo', monospace;
            margin-bottom: 20px;
        }

        .stumble-modal-description {
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.8;
            margin-bottom: 25px;
            text-align: center;
            font-size: 1.1em;
        }

        .stumble-modal-tags {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 30px;
        }

        .stumble-tag {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 5px 15px;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
        }

        .stumble-modal-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        @media (max-width: 768px) {
            .stumble-modal-actions {
                flex-direction: column;
            }
        }

        .stumble-action-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .stumble-action-btn.primary {
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-tertiary));
            color: white;
        }

        .stumble-action-btn.primary:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .stumble-action-btn.secondary {
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        .stumble-action-btn.secondary:hover {
            background: rgba(6, 255, 165, 0.1);
            transform: scale(1.05);
        }

        .stumble-action-btn:active {
            transform: scale(0.98);
        }

        .stumble-history-modal {
            background: var(--bg-secondary);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .stumble-history-title {
            font-size: 2em;
            font-weight: 300;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .stumble-history-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .stumble-history-item {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .stumble-history-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent);
            transform: translateX(5px);
        }

        .stumble-history-item-title {
            font-size: 1.1em;
            margin-bottom: 5px;
            color: white;
        }

        .stumble-history-item-time {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        /* Custom scrollbar */
        @media (hover: hover) {
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LOCAL FIRST TOOLS</h1>
            <p class="subtitle">Self-contained HTML Applications</p>
            <p class="description">
                A collection of powerful, offline-first web tools that work entirely in your browser. 
                No servers, no tracking, just pure functionality. Now with Xbox controller support for 3D experience!
            </p>

            <div class="search-container">
                <input
                    type="text"
                    class="search-input"
                    placeholder="Search tools..."
                    id="searchInput"
                >
                <span class="search-icon">üîç</span>
            </div>

            <div class="stumble-container">
                <button class="stumble-button" id="stumble-btn" title="Discover a random app (Press 'S')">
                    üé≤ Stumble
                </button>
                <select class="category-filter" id="category-filter">
                    <option value="all">All Categories</option>
                    <option value="visual_art">Visual Art</option>
                    <option value="3d_immersive">3D Immersive</option>
                    <option value="audio_music">Audio & Music</option>
                    <option value="games_puzzles">Games & Puzzles</option>
                    <option value="experimental_ai">Experimental AI</option>
                    <option value="creative_tools">Creative Tools</option>
                    <option value="educational_tools">Educational</option>
                    <option value="generative_art">Generative Art</option>
                    <option value="particle_physics">Particle Physics</option>
                </select>
                <button class="history-button" id="stumble-history-btn" title="View stumble history">
                    üìú History (<span id="history-count">0</span>)
                </button>
            </div>

            <div class="gallery-modes">
                <button class="mode-button active" id="main-gallery">Main Gallery</button>
                <button class="mode-button" id="archive-mode">Archive</button>
                <button class="mode-button vr-mode" id="3d-mode">üéÆ 3D Experience</button>
            </div>
        </div>

        <div class="content" id="toolsContainer">
            <div class="loading">Loading tools...</div>
        </div>

        <div class="stats" id="stats"></div>
        
        <div class="github-link">
            <a href="https://github.com/kody-w/localFirstTools" 
               target="_blank" 
               rel="noopener noreferrer">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                View on GitHub
            </a>
        </div>
    </div>

    <!-- 3D Gallery Container -->
    <div id="three-container">
        <div class="three-ui">
            <button class="back-button" id="back-to-gallery">‚Üê Back to Gallery</button>
        </div>
        <div class="gamepad-status" id="gamepad-status">No Controller Detected</div>
        <div class="controls-hint" id="controls-hint">
            <span class="controller-icon">Left Stick</span> Move ‚Ä¢ 
            <span class="controller-icon">Right Stick</span> Look Around ‚Ä¢ 
            <span class="controller-icon">A Button</span> Open Tool
        </div>
        <div class="mobile-controls" id="mobile-controls">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
        <div class="artwork-tooltip" id="artwork-tooltip">
            <h3 class="tooltip-title"></h3>
            <p class="tooltip-description"></p>
            <p class="tooltip-instruction">Press A to open tool</p>
        </div>
    </div>

    <!-- Vote popup -->
    <div class="vote-popup-overlay" id="vote-overlay"></div>
    <div class="vote-popup" id="vote-popup">
        <h3>Vote for Feature Request</h3>
        <form class="vote-form" id="vote-form">
            <textarea class="vote-textarea" id="vote-message" placeholder="What features or improvements would you like to see in this tool?"></textarea>
            <div class="vote-actions">
                <button type="submit" class="submit-vote">Submit Vote</button>
                <button type="button" class="cancel-vote" id="cancel-vote">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <!-- Stumble Modal -->
    <div class="stumble-modal-overlay" id="stumble-modal-overlay">
        <div class="stumble-modal" id="stumble-modal">
            <button class="stumble-modal-close" id="stumble-modal-close">√ó</button>
            <div class="stumble-modal-icon" id="stumble-icon"></div>
            <h2 class="stumble-modal-title" id="stumble-title"></h2>
            <div class="stumble-modal-category" id="stumble-category"></div>
            <div class="stumble-modal-filename" id="stumble-filename"></div>
            <p class="stumble-modal-description" id="stumble-description"></p>
            <div class="stumble-modal-tags" id="stumble-tags"></div>
            <div class="stumble-modal-actions">
                <button class="stumble-action-btn primary" id="stumble-open">Open App</button>
                <button class="stumble-action-btn secondary" id="stumble-next">Next ‚Üí</button>
            </div>
        </div>
    </div>

    <!-- Stumble History Modal -->
    <div class="stumble-modal-overlay" id="stumble-history-overlay">
        <div class="stumble-history-modal">
            <button class="stumble-modal-close" id="stumble-history-close">√ó</button>
            <h2 class="stumble-history-title">Stumble History</h2>
            <ul class="stumble-history-list" id="stumble-history-list"></ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Store all tools globally for filtering
        let allTools = [];
        let galleryData = null;
        let threeScene = null;
        let currentView = 'main'; // 'main' or 'archive'
        
        // Icons for display
        const toolIcons = ['üõ†Ô∏è', '‚ö°', 'üéØ', 'üìä', 'üé®', 'üìù', 'üíæ', 'üîß', '‚öôÔ∏è', 'üóÇÔ∏è', 'üìà', 'üéÆ'];
        
        // Local storage keys
        const PINNED_TOOLS_KEY = 'local_tools_pinned';
        const VOTES_KEY = 'local_tools_votes';
        const USER_VOTES_KEY = 'local_tools_user_votes';
        const STUMBLE_HISTORY_KEY = 'local_tools_stumble_history';
        const STUMBLE_RECENT_KEY = 'local_tools_stumble_recent';

        // Stumble state
        let currentStumbleApp = null;

        // Check if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);

        // Function to format filename into a readable title
        function formatTitle(filename) {
            // Remove .html extension
            let name = filename.replace('.html', '');
            
            // Replace hyphens and underscores with spaces
            name = name.replace(/[-_]/g, ' ');
            
            // Capitalize first letter of each word
            return name.split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Function to format file size
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Function to format date
        function formatDate(timestamp) {
            const date = new Date(timestamp * 1000);
            const now = new Date();
            const diff = now - date;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            
            if (days === 0) return 'today';
            if (days === 1) return 'yesterday';
            if (days < 7) return `${days} days ago`;
            if (days < 30) return `${Math.floor(days / 7)} weeks ago`;
            if (days < 365) return `${Math.floor(days / 30)} months ago`;
            return `${Math.floor(days / 365)} years ago`;
        }

        // Generate tool metadata
        function generateToolMetadata(filename, index = 0) {
            const title = formatTitle(filename);
            const hash = filename.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            
            const descriptions = [
                "Powerful browser-based utility for productivity",
                "Offline-first tool that works without internet",
                "Self-contained application with zero dependencies",
                "Privacy-focused tool that processes data locally",
                "Efficient utility for everyday digital tasks",
                "Streamlined workflow enhancement tool",
                "Local data processing with complete privacy",
                "Browser-native application for maximum compatibility",
                "Lightweight tool with powerful features"
            ];
            
            return {
                title: title,
                description: descriptions[hash % descriptions.length],
                icon: toolIcons[hash % toolIcons.length]
            };
        }

        // Local storage helpers
        function getPinnedTools() {
            const pinned = localStorage.getItem(PINNED_TOOLS_KEY);
            return pinned ? JSON.parse(pinned) : [];
        }
        
        function setPinnedTools(pinned) {
            localStorage.setItem(PINNED_TOOLS_KEY, JSON.stringify(pinned));
        }
        
        function getVotes() {
            const votes = localStorage.getItem(VOTES_KEY);
            return votes ? JSON.parse(votes) : {};
        }
        
        function setVotes(votes) {
            localStorage.setItem(VOTES_KEY, JSON.stringify(votes));
        }
        
        function getUserVotes() {
            const userVotes = localStorage.getItem(USER_VOTES_KEY);
            return userVotes ? JSON.parse(userVotes) : {};
        }
        
        function setUserVotes(userVotes) {
            localStorage.setItem(USER_VOTES_KEY, JSON.stringify(userVotes));
        }

        // Stumble history helpers
        function getStumbleHistory() {
            const history = localStorage.getItem(STUMBLE_HISTORY_KEY);
            return history ? JSON.parse(history) : [];
        }

        function setStumbleHistory(history) {
            localStorage.setItem(STUMBLE_HISTORY_KEY, JSON.stringify(history));
        }

        function addToStumbleHistory(app) {
            const history = getStumbleHistory();
            history.unshift({
                ...app,
                timestamp: Date.now()
            });
            // Keep only last 50
            if (history.length > 50) {
                history.pop();
            }
            setStumbleHistory(history);
            updateHistoryCount();
        }

        function getRecentStumbles() {
            const recent = localStorage.getItem(STUMBLE_RECENT_KEY);
            return recent ? JSON.parse(recent) : [];
        }

        function setRecentStumbles(recent) {
            localStorage.setItem(STUMBLE_RECENT_KEY, JSON.stringify(recent));
        }

        function updateHistoryCount() {
            const history = getStumbleHistory();
            const countElement = document.getElementById('history-count');
            if (countElement) {
                countElement.textContent = history.length;
            }
        }

        // Get a random app with smart selection
        function getRandomApp(categoryFilter = 'all') {
            let availableApps = [];

            // Get apps based on category filter
            if (categoryFilter === 'all') {
                availableApps = allTools.filter(t => !t.isArchive);
            } else {
                // Try to load from vibe_gallery_config.json categories
                try {
                    // Check if we have gallery data with categories
                    if (galleryData && galleryData.vibeGallery && galleryData.vibeGallery.categories) {
                        const category = galleryData.vibeGallery.categories[categoryFilter];
                        if (category && category.apps) {
                            availableApps = category.apps.map(app => ({
                                filename: app.filename,
                                title: app.title,
                                url: app.path || app.filename,
                                description: app.description,
                                category: app.category,
                                tags: app.tags || [],
                                complexity: app.complexity,
                                interactionType: app.interactionType
                            }));
                        }
                    }
                } catch (e) {
                    console.log('Category filter error:', e);
                }

                // Fallback to all tools if category filtering failed
                if (availableApps.length === 0) {
                    availableApps = allTools.filter(t => !t.isArchive);
                }
            }

            if (availableApps.length === 0) {
                return null;
            }

            // Get recently stumbled apps (last 10)
            const recentStumbles = getRecentStumbles();

            // Filter out recently viewed apps (70% of the time)
            const shouldAvoidRecent = Math.random() < 0.7;
            let filteredApps = availableApps;

            if (shouldAvoidRecent && recentStumbles.length > 0) {
                filteredApps = availableApps.filter(app =>
                    !recentStumbles.includes(app.filename)
                );

                // If we filtered out everything, use all apps
                if (filteredApps.length === 0) {
                    filteredApps = availableApps;
                }
            }

            // Select random app
            const randomIndex = Math.floor(Math.random() * filteredApps.length);
            const selectedApp = filteredApps[randomIndex];

            // Update recent stumbles
            const newRecent = [selectedApp.filename, ...recentStumbles.slice(0, 9)];
            setRecentStumbles(newRecent);

            return selectedApp;
        }

        // Show stumble modal
        function showStumbleModal(app) {
            if (!app) return;

            currentStumbleApp = app;
            const metadata = generateToolMetadata(app.filename);

            // Update modal content
            document.getElementById('stumble-icon').textContent = metadata.icon;
            document.getElementById('stumble-title').textContent = app.title;
            document.getElementById('stumble-category').textContent = app.category ? app.category.replace(/_/g, ' ') : '';
            document.getElementById('stumble-filename').textContent = app.filename;
            document.getElementById('stumble-description').textContent = app.description || metadata.description;

            // Update tags
            const tagsContainer = document.getElementById('stumble-tags');
            tagsContainer.innerHTML = '';
            if (app.tags && app.tags.length > 0) {
                app.tags.slice(0, 8).forEach(tag => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'stumble-tag';
                    tagEl.textContent = tag;
                    tagsContainer.appendChild(tagEl);
                });
            }

            // Show modal
            document.getElementById('stumble-modal-overlay').classList.add('show');

            // Add to history
            addToStumbleHistory(app);
        }

        // Hide stumble modal
        function hideStumbleModal() {
            document.getElementById('stumble-modal-overlay').classList.remove('show');
            currentStumbleApp = null;
        }

        // Stumble action
        function performStumble() {
            const categoryFilter = document.getElementById('category-filter').value;
            const randomApp = getRandomApp(categoryFilter);

            if (randomApp) {
                showStumbleModal(randomApp);
                showToast('Stumbled upon: ' + randomApp.title);
            } else {
                showToast('No apps available to stumble', 'error');
            }
        }

        // Show stumble history
        function showStumbleHistory() {
            const history = getStumbleHistory();
            const historyList = document.getElementById('stumble-history-list');
            historyList.innerHTML = '';

            if (history.length === 0) {
                historyList.innerHTML = '<li style="text-align: center; color: rgba(255,255,255,0.5); padding: 40px;">No stumble history yet. Start exploring!</li>';
            } else {
                history.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'stumble-history-item';

                    const title = document.createElement('div');
                    title.className = 'stumble-history-item-title';
                    title.textContent = item.title;

                    const time = document.createElement('div');
                    time.className = 'stumble-history-item-time';
                    const date = new Date(item.timestamp);
                    time.textContent = date.toLocaleString();

                    li.appendChild(title);
                    li.appendChild(time);

                    li.addEventListener('click', () => {
                        window.open(item.url, '_blank');
                    });

                    historyList.appendChild(li);
                });
            }

            document.getElementById('stumble-history-overlay').classList.add('show');
        }

        // Hide history modal
        function hideStumbleHistory() {
            document.getElementById('stumble-history-overlay').classList.remove('show');
        }

        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Track mouse position for interactive effects
        if (!isMobile) {
            document.addEventListener('mousemove', (e) => {
                const cards = document.querySelectorAll('.tool-card');
                cards.forEach(card => {
                    const rect = card.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    card.style.setProperty('--mouse-x', `${x}%`);
                    card.style.setProperty('--mouse-y', `${y}%`);
                });
            });
        }

        // Function to load tools from manifest or create default
        async function loadTools() {
            const container = document.getElementById('toolsContainer');
            const statsElement = document.getElementById('stats');

            // Try to load vibe_gallery_config.json for category support
            try {
                const vibeResponse = await fetch('./vibe_gallery_config.json');
                if (vibeResponse.ok) {
                    galleryData = await vibeResponse.json();
                    console.log('Loaded vibe_gallery_config.json for category filtering');
                }
            } catch (e) {
                console.log('vibe_gallery_config.json not found, category filtering may be limited');
            }

            try {
                // Try to load manifest first
                const response = await fetch('./tools-manifest.json');
                if (response.ok) {
                    const manifest = await response.json();
                    
                    if (manifest.tools && manifest.tools.length > 0) {
                        allTools = manifest.tools.map(file => ({
                            filename: file.name,
                            title: formatTitle(file.name),
                            url: file.name,
                            size: formatSize(file.size),
                            modified: formatDate(file.modified),
                            isArchive: file.name.includes('archive/')
                        }));
                        
                        // Store gallery data
                        galleryData = {
                            mainFiles: allTools.filter(t => !t.isArchive),
                            archiveFiles: allTools.filter(t => t.isArchive)
                        };
                        
                        displayTools();
                        
                        const generated = new Date(manifest.generated);
                        const genFormatted = generated.toLocaleDateString() + ' ' +
                                           generated.toLocaleTimeString();
                        
                        statsElement.innerHTML = `
                            ${manifest.count} tools available
                            <div style="font-size: 0.85em; margin-top: 5px;">
                                Last updated: ${genFormatted}
                            </div>
                        `;
                        return;
                    }
                }
            } catch (error) {
                console.log('Manifest not found, using fallback data');
            }
            
            // Fallback: Use sample tools if manifest doesn't exist
            allTools = getSampleTools();
            galleryData = {
                mainFiles: allTools.filter(t => !t.isArchive),
                archiveFiles: allTools.filter(t => t.isArchive)
            };
            displayTools();
            statsElement.innerHTML = `${allTools.length} sample tools available`;
        }

        // Sample tools for demonstration
        function getSampleTools() {
            return [
                {
                    filename: 'text-editor.html',
                    title: 'Text Editor',
                    url: 'text-editor.html',
                    size: '12.3 KB',
                    modified: 'yesterday',
                    isArchive: false
                },
                {
                    filename: 'markdown-preview.html',
                    title: 'Markdown Preview',
                    url: 'markdown-preview.html',
                    size: '18.7 KB',
                    modified: '2 days ago',
                    isArchive: false
                },
                {
                    filename: 'json-formatter.html',
                    title: 'JSON Formatter',
                    url: 'json-formatter.html',
                    size: '14.2 KB',
                    modified: '3 days ago',
                    isArchive: false
                },
                {
                    filename: 'color-palette.html',
                    title: 'Color Palette',
                    url: 'color-palette.html',
                    size: '22.1 KB',
                    modified: '5 days ago',
                    isArchive: false
                },
                {
                    filename: 'todo-manager.html',
                    title: 'Todo Manager',
                    url: 'todo-manager.html',
                    size: '16.8 KB',
                    modified: '1 week ago',
                    isArchive: false
                },
                {
                    filename: 'calculator.html',
                    title: 'Calculator',
                    url: 'calculator.html',
                    size: '9.4 KB',
                    modified: '2 weeks ago',
                    isArchive: false
                },
                {
                    filename: 'old-timer.html',
                    title: 'Old Timer',
                    url: 'archive/old-timer.html',
                    size: '8.2 KB',
                    modified: '2 months ago',
                    isArchive: true
                }
            ];
        }

        // Sort tools by pinned status and votes
        function sortTools(tools) {
            const pinned = getPinnedTools();
            const votes = getVotes();
            
            return tools.sort((a, b) => {
                // First priority: pinned items
                const aPinned = pinned.includes(a.filename);
                const bPinned = pinned.includes(b.filename);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                
                // Second priority: vote count
                const aVotes = votes[a.filename]?.count || 0;
                const bVotes = votes[b.filename]?.count || 0;
                if (aVotes !== bVotes) return bVotes - aVotes;
                
                // Third priority: alphabetical by title
                return a.title.localeCompare(b.title);
            });
        }

        // Display tools function
        function displayTools() {
            const container = document.getElementById('toolsContainer');
            container.innerHTML = '';
            
            const tools = currentView === 'main' ? 
                (galleryData?.mainFiles || allTools.filter(t => !t.isArchive)) : 
                (galleryData?.archiveFiles || allTools.filter(t => t.isArchive));
            
            if (!tools || tools.length === 0) {
                container.innerHTML = `
                    <div class="no-results">No tools in ${currentView === 'main' ? 'main gallery' : 'archive'}</div>
                `;
                return;
            }
            
            // Sort tools
            const sortedTools = sortTools(tools);
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            
            // Create sections
            const pinnedTools = sortedTools.filter(t => pinned.includes(t.filename));
            const unpinnedTools = sortedTools.filter(t => !pinned.includes(t.filename));
            
            // Display pinned section if there are pinned items
            if (pinnedTools.length > 0 && currentView === 'main') {
                const pinnedSection = createSection('üìå Pinned Tools', pinnedTools);
                container.appendChild(pinnedSection);
            }
            
            // Display main section
            const sectionTitle = currentView === 'main' ? 
                (pinnedTools.length > 0 ? 'üöÄ All Tools' : 'üöÄ Available Tools') : 
                'üì¶ Archive';
            const mainSection = createSection(sectionTitle, unpinnedTools);
            container.appendChild(mainSection);
            
            // Restore search term if any
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value) {
                filterTools(searchInput.value.toLowerCase());
            }
        }

        function createSection(title, tools) {
            const section = document.createElement('div');
            section.className = 'exhibition-section';
            
            const sectionTitle = document.createElement('h2');
            sectionTitle.className = 'section-title';
            sectionTitle.textContent = title;
            section.appendChild(sectionTitle);
            
            const grid = document.createElement('div');
            grid.className = 'tools-grid';
            
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            
            tools.forEach((tool, index) => {
                const metadata = generateToolMetadata(tool.filename, index);
                const fileVotes = votes[tool.filename]?.count || 0;
                const hasVoted = userVotes[tool.filename] || false;
                const isPinned = pinned.includes(tool.filename);
                
                const card = document.createElement('div');
                card.className = 'tool-card' + (isPinned ? ' pinned' : '');
                
                card.innerHTML = `
                    <button class="pin-button ${isPinned ? 'pinned' : ''}" data-file="${tool.filename}" title="${isPinned ? 'Unpin' : 'Pin to top'}">
                        üìå
                    </button>
                    <div class="tool-preview">
                        ${metadata.icon}
                    </div>
                    <div class="tool-title">${tool.title}</div>
                    <div class="tool-filename">${tool.filename}</div>
                    <div class="tool-description">${metadata.description}</div>
                    <div class="tool-meta">
                        <span>${tool.size}</span>
                        <span>‚Ä¢</span>
                        <span>${tool.modified}</span>
                    </div>
                    <div class="tool-stats">
                        <div class="stat-item">
                            <span>üëç</span>
                            <span class="vote-count" data-file="${tool.filename}">${fileVotes}</span>
                            <span>votes</span>
                        </div>
                    </div>
                    <div class="tool-actions">
                        <button class="view-button" data-url="${tool.url}">View</button>
                        <button class="vote-button ${hasVoted ? 'voted' : ''}" data-file="${tool.filename}">${hasVoted ? 'Voted' : 'Vote'}</button>
                        <button class="download-button" data-url="${tool.url}" data-filename="${tool.filename}">Save</button>
                    </div>
                `;
                
                // Add event listeners
                const pinBtn = card.querySelector('.pin-button');
                pinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    togglePin(tool.filename);
                });
                
                const viewBtn = card.querySelector('.view-button');
                viewBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    window.open(tool.url, '_blank');
                });
                
                const voteBtn = card.querySelector('.vote-button');
                voteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleVote(tool);
                });
                
                const downloadBtn = card.querySelector('.download-button');
                downloadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    downloadFile(tool.url, tool.filename);
                });
                
                // Card click opens tool
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('button')) {
                        window.open(tool.url, '_blank');
                    }
                });
                
                grid.appendChild(card);
            });
            
            section.appendChild(grid);
            return section;
        }

        // Pin/unpin functionality
        function togglePin(filename) {
            const pinned = getPinnedTools();
            const index = pinned.indexOf(filename);
            
            if (index > -1) {
                pinned.splice(index, 1);
                showToast('Tool unpinned');
            } else {
                pinned.push(filename);
                showToast('Tool pinned to top');
            }
            
            setPinnedTools(pinned);
            displayTools();
        }

        // Vote handling
        const voteOverlay = document.getElementById('vote-overlay');
        const votePopup = document.getElementById('vote-popup');
        const voteForm = document.getElementById('vote-form');
        const cancelVote = document.getElementById('cancel-vote');
        let currentVoteTool = null;
        
        function handleVote(tool) {
            const userVotes = getUserVotes();
            
            if (userVotes[tool.filename]) {
                showToast('You have already voted for this tool', 'error');
                return;
            }
            
            currentVoteTool = tool;
            voteOverlay.classList.add('show');
            votePopup.classList.add('show');
            document.getElementById('vote-message').value = '';
        }
        
        function closeVotePopup() {
            voteOverlay.classList.remove('show');
            votePopup.classList.remove('show');
            currentVoteTool = null;
        }
        
        voteOverlay.addEventListener('click', closeVotePopup);
        cancelVote.addEventListener('click', closeVotePopup);
        
        voteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            if (!currentVoteTool) return;
            
            const message = document.getElementById('vote-message').value.trim();
            if (!message) {
                showToast('Please enter a feature request', 'error');
                return;
            }
            
            // Update votes
            const votes = getVotes();
            const userVotes = getUserVotes();
            const filename = currentVoteTool.filename;
            
            if (!votes[filename]) {
                votes[filename] = { count: 0, requests: [] };
            }
            
            votes[filename].count++;
            votes[filename].requests.push({
                message: message,
                timestamp: new Date().toISOString()
            });
            
            userVotes[filename] = true;
            
            setVotes(votes);
            setUserVotes(userVotes);
            
            // Update UI
            document.querySelectorAll(`.vote-count[data-file="${filename}"]`).forEach(el => {
                el.textContent = votes[filename].count;
            });
            
            document.querySelectorAll(`.vote-button[data-file="${filename}"]`).forEach(btn => {
                btn.classList.add('voted');
                btn.textContent = 'Voted';
            });
            
            closeVotePopup();
            showToast('Vote submitted! Thank you for your feedback.');
            
            console.log('Vote for:', filename, 'Request:', message);
        });

        // Download functionality
        function downloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showToast('Download started');
        }

        // Search functionality
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                filterTools(searchTerm);
            });
        }
        
        function filterTools(searchTerm) {
            const cards = document.querySelectorAll('.tool-card');
            cards.forEach(card => {
                const title = card.querySelector('.tool-title').textContent.toLowerCase();
                const description = card.querySelector('.tool-description').textContent.toLowerCase();
                const filename = card.querySelector('.tool-filename').textContent.toLowerCase();
                
                if (title.includes(searchTerm) || description.includes(searchTerm) || filename.includes(searchTerm)) {
                    card.style.display = 'flex';
                } else {
                    card.style.display = 'none';
                }
            });
            
            // Hide empty sections
            const sections = document.querySelectorAll('.exhibition-section');
            sections.forEach(section => {
                const visibleCards = section.querySelectorAll('.tool-card[style*="display: flex"], .tool-card:not([style*="display"])');
                if (visibleCards.length === 0) {
                    section.style.display = 'none';
                } else {
                    section.style.display = 'block';
                }
            });
        }

        // Mode switching
        document.getElementById('main-gallery').addEventListener('click', () => {
            currentView = 'main';
            document.getElementById('main-gallery').classList.add('active');
            document.getElementById('archive-mode').classList.remove('active');
            document.getElementById('three-container').classList.remove('active');
            document.getElementById('toolsContainer').classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            displayTools();
        });
        
        document.getElementById('archive-mode').addEventListener('click', () => {
            currentView = 'archive';
            document.getElementById('archive-mode').classList.add('active');
            document.getElementById('main-gallery').classList.remove('active');
            document.getElementById('three-container').classList.remove('active');
            document.getElementById('toolsContainer').classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            displayTools();
        });
        
        document.getElementById('3d-mode').addEventListener('click', () => {
            if (galleryData) {
                document.getElementById('toolsContainer').classList.add('hidden');
                document.getElementById('three-container').classList.add('active');
                init3DGallery();
            }
        });
        
        document.getElementById('back-to-gallery').addEventListener('click', () => {
            document.getElementById('main-gallery').click();
        });

        // 3D Gallery
        function init3DGallery() {
            if (threeScene) {
                threeScene.cleanup();
            }
            threeScene = new Gallery3D();
            threeScene.init();
        }
        
        class Gallery3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.tools = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.moveSpeed = 0.3;
                this.lookSpeed = 0.002;
                this.gamepadLookSpeed = 0.05;
                
                this.keys = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                
                this.rotation = {
                    x: 0,
                    y: 0
                };
                
                this.isMobile = isMobile;
                this.touches = {
                    start: null,
                    current: null
                };
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                
                this.gamepad = null;
                this.gamepadIndex = null;
                this.aButtonPressed = false;
                
                this.isPointerLocked = false;
                this.hoveredTool = null;
                this.tooltip = document.getElementById('artwork-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
                this.gamepadStatus = document.getElementById('gamepad-status');
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 10, 100);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 2, 10);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
                
                // Lighting
                this.setupLighting();
                
                // Create gallery
                this.createGallery();
                
                // Event listeners
                this.setupEventListeners();
                this.setupGamepad();
                
                // Update controls hint
                const controlsHint = document.getElementById('controls-hint');
                if (this.isMobile) {
                    controlsHint.innerHTML = 'Swipe to look around ‚Ä¢ Use joystick to move ‚Ä¢ Tap on tools to open';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                // Start animation
                this.animate();
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                this.scene.add(dirLight);
                
                const colors = [0x06ffa5, 0xff006e, 0x8338ec];
                colors.forEach((color, i) => {
                    const light = new THREE.PointLight(color, 0.5, 10);
                    light.position.set(i * 10 - 10, 3, 0);
                    this.scene.add(light);
                });
            }
            
            createGallery() {
                // Floor
                const floorGeometry = new THREE.BoxGeometry(100, 1, 100);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1a1a1a,
                    emissive: 0x0a0a0a
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Walls
                this.createWalls();
                
                // Create tool displays
                this.createToolDisplays();
                
                // Add decorations
                this.addDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x2a2a2a,
                    emissive: 0x111111
                });
                
                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 1),
                    wallMaterial
                );
                backWall.position.set(0, 10, -50);
                this.scene.add(backWall);
                
                // Side walls
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                leftWall.position.set(-50, 10, 0);
                this.scene.add(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                rightWall.position.set(50, 10, 0);
                this.scene.add(rightWall);
            }
            
            createTextSprite(text, fontSize = 0.5) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = `${canvas.width * fontSize}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = 'white';
                
                if (text.length <= 2 && /\p{Emoji}/u.test(text)) {
                    context.font = `${canvas.width * fontSize * 0.8}px Arial`;
                }
                
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 2, 1);
                
                return sprite;
            }
            
            createToolDisplays() {
                const tools = galleryData?.mainFiles || allTools.filter(t => !t.isArchive);
                const numTools = Math.min(tools.length, 20);
                
                for (let i = 0; i < numTools; i++) {
                    const tool = tools[i];
                    const metadata = generateToolMetadata(tool.filename, i);
                    
                    // Create tool group
                    const toolGroup = new THREE.Group();
                    
                    // Frame
                    const frameGeometry = new THREE.BoxGeometry(4, 3, 0.2);
                    const frameMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x444444,
                        emissive: 0x222222
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    
                    // Canvas with gradient
                    const canvasGeometry = new THREE.BoxGeometry(3.6, 2.6, 0.1);
                    const hue = Math.random();
                    const canvasMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                        emissive: new THREE.Color().setHSL(hue, 0.7, 0.3),
                        emissiveIntensity: 0.5
                    });
                    const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
                    canvas.position.z = 0.1;
                    frame.add(canvas);
                    
                    // Add icon sprite
                    const iconSprite = this.createTextSprite(metadata.icon, 0.4);
                    iconSprite.position.z = 0.2;
                    canvas.add(iconSprite);
                    
                    // Add title
                    const titleSprite = this.createTextSprite(tool.title.substring(0, 15) + (tool.title.length > 15 ? '...' : ''), 0.15);
                    titleSprite.position.y = -2;
                    titleSprite.position.z = 0.5;
                    frame.add(titleSprite);
                    
                    toolGroup.add(frame);
                    
                    // Position tool
                    const angle = (i / numTools) * Math.PI * 2;
                    const radius = 20;
                    toolGroup.position.x = Math.cos(angle) * radius;
                    toolGroup.position.z = Math.sin(angle) * radius;
                    toolGroup.position.y = 3;
                    toolGroup.rotation.y = -angle + Math.PI;
                    
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    
                    // Store data for interaction
                    frame.userData = {
                        url: tool.url,
                        title: tool.title,
                        description: metadata.description,
                        filename: tool.filename,
                        icon: metadata.icon
                    };
                    
                    this.tools.push(frame);
                    this.scene.add(toolGroup);
                }
            }
            
            addDecorations() {
                // Add floating cubes
                for (let i = 0; i < 20; i++) {
                    const size = Math.random() * 0.5 + 0.5;
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                            emissive: new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                            emissiveIntensity: 0.3
                        })
                    );
                    
                    cube.position.x = (Math.random() - 0.5) * 40;
                    cube.position.y = Math.random() * 10 + 10;
                    cube.position.z = (Math.random() - 0.5) * 40;
                    
                    cube.rotation.x = Math.random() * Math.PI * 2;
                    cube.rotation.y = Math.random() * Math.PI * 2;
                    
                    cube.userData.floatSpeed = Math.random() * 0.02 + 0.01;
                    cube.userData.rotateSpeed = Math.random() * 0.02 + 0.01;
                    
                    cube.castShadow = true;
                    
                    this.scene.add(cube);
                }
            }
            
            setupEventListeners() {
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupDesktopControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                // Mouse
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
                
                // Click on tool
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) return;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.tools, true);
                    
                    if (intersects.length > 0) {
                        const tool = intersects[0].object.parent || intersects[0].object;
                        if (tool.userData && tool.userData.url) {
                            window.open(tool.userData.url, '_blank');
                        }
                    }
                });
            }
            
            setupMobileControls() {
                const canvas = this.renderer.domElement;
                
                // Touch controls for looking
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touches.start = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                    this.touches.current = {...this.touches.start};
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touches.start) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touches.current.x;
                    const deltaY = touch.clientY - this.touches.current.y;
                    
                    this.rotation.y -= deltaX * this.lookSpeed * 2;
                    this.rotation.x -= deltaY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    
                    this.touches.current = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    // Check for tap
                    if (this.touches.start && this.touches.current) {
                        const dx = this.touches.current.x - this.touches.start.x;
                        const dy = this.touches.current.y - this.touches.start.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // It's a tap
                            const rect = canvas.getBoundingClientRect();
                            const x = ((this.touches.start.x - rect.left) / rect.width) * 2 - 1;
                            const y = -((this.touches.start.y - rect.top) / rect.height) * 2 + 1;
                            
                            this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                            const intersects = this.raycaster.intersectObjects(this.tools, true);
                            
                            if (intersects.length > 0) {
                                const tool = intersects[0].object.parent || intersects[0].object;
                                if (tool.userData && tool.userData.url) {
                                    window.open(tool.userData.url, '_blank');
                                }
                            }
                        }
                    }
                    
                    this.touches.start = null;
                    this.touches.current = null;
                });
                
                // Joystick for movement
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.updateJoystick(e.touches[0], joystick, handle);
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystickActive) {
                        this.updateJoystick(e.touches[0], joystick, handle);
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.joystickVector.set(0, 0);
                    handle.style.transform = 'translate(-50%, -50%)';
                });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            setupGamepad() {
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad);
                    this.gamepad = e.gamepad;
                    this.gamepadIndex = e.gamepad.index;
                    this.updateGamepadStatus(true);
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected');
                    this.gamepad = null;
                    this.gamepadIndex = null;
                    this.updateGamepadStatus(false);
                });
            }
            
            getGamepad() {
                const gamepads = navigator.getGamepads();
                if (this.gamepadIndex !== null && gamepads[this.gamepadIndex]) {
                    return gamepads[this.gamepadIndex];
                }
                for (let gp of gamepads) {
                    if (gp) return gp;
                }
                return null;
            }
            
            updateGamepadStatus(connected) {
                if (connected) {
                    this.gamepadStatus.textContent = 'üéÆ Controller Connected';
                    this.gamepadStatus.classList.add('connected');
                } else {
                    this.gamepadStatus.textContent = 'No Controller Detected';
                    this.gamepadStatus.classList.remove('connected');
                }
            }
            
            handleGamepadInput() {
                const gp = this.getGamepad();
                if (!gp) return;
                
                // Left stick for movement (axes 0 and 1)
                const deadzone = 0.15;
                const lx = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
                const ly = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;
                
                // Right stick for looking (axes 2 and 3)
                const rx = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
                const ry = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;
                
                // Update rotation based on right stick
                if (Math.abs(rx) > 0 || Math.abs(ry) > 0) {
                    this.rotation.y -= rx * this.gamepadLookSpeed;
                    this.rotation.x += ry * this.gamepadLookSpeed;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                }
                
                // Movement based on left stick
                if (Math.abs(lx) > 0 || Math.abs(ly) > 0) {
                    const forward = new THREE.Vector3();
                    const right = new THREE.Vector3();
                    
                    this.camera.getWorldDirection(forward);
                    forward.y = 0;
                    forward.normalize();
                    
                    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                    
                    const moveForward = forward.multiplyScalar(-ly * this.moveSpeed);
                    const moveRight = right.multiplyScalar(lx * this.moveSpeed);
                    
                    this.camera.position.add(moveForward);
                    this.camera.position.add(moveRight);
                }
                
                // A button (button 0) to interact with tools
                if (gp.buttons[0] && gp.buttons[0].pressed && !this.aButtonPressed) {
                    this.aButtonPressed = true;
                    this.interactWithTool();
                } else if (!gp.buttons[0] || !gp.buttons[0].pressed) {
                    this.aButtonPressed = false;
                }
            }
            
            interactWithTool() {
                if (this.hoveredTool && this.hoveredTool.userData && this.hoveredTool.userData.url) {
                    window.open(this.hoveredTool.userData.url, '_blank');
                    showToast('Opening ' + this.hoveredTool.userData.title);
                }
            }
            
            updateHover() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.tools, true);
                
                if (intersects.length > 0) {
                    const tool = intersects[0].object.parent || intersects[0].object;
                    
                    if (tool.userData && tool.userData.title && tool !== this.hoveredTool) {
                        this.hoveredTool = tool;
                        
                        this.tooltipTitle.textContent = `${tool.userData.icon} ${tool.userData.title}`;
                        this.tooltipDescription.textContent = tool.userData.description;
                        this.tooltip.classList.add('visible');
                        
                        const vector = new THREE.Vector3();
                        tool.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 420)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 250)}px`;
                    }
                } else {
                    if (this.hoveredTool) {
                        this.hoveredTool = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Handle gamepad input
                this.handleGamepadInput();
                
                this.updateMovement();
                this.updateHover();
                
                // Animate floating cubes
                this.scene.children.forEach(child => {
                    if (child.userData.floatSpeed) {
                        child.position.y += Math.sin(Date.now() * child.userData.floatSpeed) * 0.01;
                        child.rotation.x += child.userData.rotateSpeed;
                        child.rotation.y += child.userData.rotateSpeed * 0.7;
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            cleanup() {
                if (this.renderer) {
                    document.getElementById('three-container').removeChild(this.renderer.domElement);
                    this.renderer.dispose();
                }
                
                this.tooltip.classList.remove('visible');
                document.getElementById('mobile-controls').classList.remove('show');
                
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            }
        }

        // Setup stumble event listeners
        function setupStumble() {
            // Stumble button
            document.getElementById('stumble-btn').addEventListener('click', performStumble);

            // Modal close buttons
            document.getElementById('stumble-modal-close').addEventListener('click', hideStumbleModal);
            document.getElementById('stumble-history-close').addEventListener('click', hideStumbleHistory);

            // Modal overlay click to close
            document.getElementById('stumble-modal-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'stumble-modal-overlay') {
                    hideStumbleModal();
                }
            });

            document.getElementById('stumble-history-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'stumble-history-overlay') {
                    hideStumbleHistory();
                }
            });

            // Open app button
            document.getElementById('stumble-open').addEventListener('click', () => {
                if (currentStumbleApp) {
                    window.open(currentStumbleApp.url, '_blank');
                    hideStumbleModal();
                }
            });

            // Next button
            document.getElementById('stumble-next').addEventListener('click', () => {
                hideStumbleModal();
                // Small delay for better UX
                setTimeout(performStumble, 200);
            });

            // History button
            document.getElementById('stumble-history-btn').addEventListener('click', showStumbleHistory);

            // Update history count
            updateHistoryCount();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Focus search (/)
            if (e.key === '/' && document.activeElement !== document.getElementById('searchInput')) {
                e.preventDefault();
                document.getElementById('searchInput').focus();
            }

            // Stumble (S key)
            if (e.key === 's' || e.key === 'S') {
                // Don't trigger if typing in input fields
                if (document.activeElement.tagName === 'INPUT' ||
                    document.activeElement.tagName === 'TEXTAREA' ||
                    document.activeElement.tagName === 'SELECT') {
                    return;
                }

                e.preventDefault();
                performStumble();
            }

            // Close modals with Escape
            if (e.key === 'Escape') {
                if (document.getElementById('stumble-modal-overlay').classList.contains('show')) {
                    hideStumbleModal();
                }
                if (document.getElementById('stumble-history-overlay').classList.contains('show')) {
                    hideStumbleHistory();
                }
            }

            // Open app with Enter in stumble modal
            if (e.key === 'Enter' && document.getElementById('stumble-modal-overlay').classList.contains('show')) {
                if (currentStumbleApp) {
                    window.open(currentStumbleApp.url, '_blank');
                    hideStumbleModal();
                }
            }

            // Next stumble with Space or right arrow in modal
            if ((e.key === ' ' || e.key === 'ArrowRight') &&
                document.getElementById('stumble-modal-overlay').classList.contains('show')) {
                e.preventDefault();
                hideStumbleModal();
                setTimeout(performStumble, 200);
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadTools();
            setupSearch();
            setupStumble();
        });
    </script>
</body>
</html>