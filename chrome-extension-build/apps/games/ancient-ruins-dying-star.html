<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ancient Ruins on a Dying Star</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: crosshair;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD Elements */
        .hud {
            position: absolute;
            z-index: 100;
            pointer-events: none;
        }

        .timer {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border: 2px solid #ff3333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.5);
        }

        .timer-label {
            font-size: 14px;
            color: #ff9999;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .timer-value {
            font-size: 36px;
            font-weight: bold;
            color: #ff3333;
            text-shadow: 0 0 10px rgba(255, 51, 51, 0.8);
            font-family: 'Courier New', monospace;
        }

        .scanner {
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #00ffff;
            border-radius: 10px;
            min-width: 250px;
        }

        .scanner-title {
            color: #00ffff;
            font-size: 14px;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .discoveries {
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #ffa500;
            border-radius: 10px;
            max-width: 300px;
        }

        .discoveries-title {
            color: #ffa500;
            font-size: 14px;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .discovery-item {
            padding: 5px;
            margin: 5px 0;
            background: rgba(255, 165, 0, 0.1);
            border-left: 3px solid #ffa500;
            font-size: 12px;
            animation: newDiscovery 0.5s ease-in-out;
        }

        @keyframes newDiscovery {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .controls {
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #666;
            border-radius: 10px;
            font-size: 12px;
            line-height: 1.8;
        }

        .control-key {
            color: #00ffff;
            font-weight: bold;
            display: inline-block;
            min-width: 80px;
        }

        .warnings {
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .warning {
            background: rgba(255, 0, 0, 0.9);
            padding: 10px 20px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            animation: pulse 1s infinite;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .data-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }

        .data-controls button {
            margin-right: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ffff;
            border: 1px solid #00ffff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #importFile {
            display: none;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
        }

        .game-over.show {
            display: flex;
        }

        .game-over-title {
            font-size: 48px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .game-over-stats {
            background: rgba(255, 165, 0, 0.1);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #ffa500;
            margin: 20px;
            min-width: 400px;
        }

        .stat-line {
            margin: 10px 0;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
        }

        .restart-btn {
            padding: 15px 40px;
            margin-top: 30px;
            background: linear-gradient(45deg, #ff3333, #ff6666);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 51, 51, 0.8);
        }

        .solar-flare-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: #ff0000;
            text-shadow: 0 0 50px rgba(255, 0, 0, 1);
            animation: flareWarning 0.5s infinite;
            z-index: 500;
            pointer-events: none;
            display: none;
        }

        @keyframes flareWarning {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Data</button>
        <button onclick="document.getElementById('importFile').click()">Import Data</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
    </div>

    <!-- HUD -->
    <div class="hud timer">
        <div class="timer-label">Time Until Supernova</div>
        <div class="timer-value" id="timer">05:00</div>
    </div>

    <div class="hud scanner">
        <div class="scanner-title">Xenoarchaeology Scanner</div>
        <div id="scannerInfo">
            <div>Target: <span id="targetInfo">None</span></div>
            <div>Distance: <span id="distanceInfo">--</span></div>
            <div>Status: <span id="statusInfo">Scanning...</span></div>
        </div>
    </div>

    <div class="hud discoveries">
        <div class="discoveries-title">Discoveries (<span id="discoveryCount">0</span>/12)</div>
        <div id="discoveryList"></div>
    </div>

    <div class="hud controls">
        <div><span class="control-key">WASD/Arrows:</span> Move</div>
        <div><span class="control-key">Mouse:</span> Look</div>
        <div><span class="control-key">Space:</span> Jump</div>
        <div><span class="control-key">E:</span> Scan/Document</div>
        <div><span class="control-key">Shift:</span> Run</div>
    </div>

    <div class="hud warnings" id="warnings"></div>

    <div class="solar-flare-warning" id="flareWarning">SOLAR FLARE!</div>

    <!-- Game Over Screen -->
    <div class="game-over" id="gameOver">
        <h1 class="game-over-title" id="gameOverTitle">SUPERNOVA!</h1>
        <div class="game-over-stats">
            <div class="stat-line">
                <span>Artifacts Discovered:</span>
                <span id="finalDiscoveries">0/12</span>
            </div>
            <div class="stat-line">
                <span>Knowledge Preserved:</span>
                <span id="knowledgePercent">0%</span>
            </div>
            <div class="stat-line">
                <span>Time Survived:</span>
                <span id="timeSurvived">0:00</span>
            </div>
            <div class="stat-line">
                <span>Final Score:</span>
                <span id="finalScore">0</span>
            </div>
        </div>
        <button class="restart-btn" onclick="restartGame()">Explore Again</button>
    </div>

    <script>
        // Game State
        const APP_NAME = 'ancient-ruins-dying-star';
        let gameData = {
            discoveries: [],
            highScore: 0,
            totalPlays: 0,
            allDiscoveries: [],
            achievements: []
        };

        // Load saved data
        function loadData() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                gameData = JSON.parse(saved);
            }
        }

        // Save data
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(gameData));
        }

        // Export data
        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Import data
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    gameData = JSON.parse(e.target.result);
                    saveData();
                    location.reload();
                } catch (error) {
                    alert('Invalid save file');
                }
            };
            reader.readAsText(file);
        }

        // Game variables
        let canvas, ctx;
        let player = {
            x: 0,
            y: 5,
            z: 0,
            vx: 0,
            vy: 0,
            vz: 0,
            rotationY: 0,
            rotationX: 0,
            onGround: false,
            running: false
        };

        let camera = {
            x: 0,
            y: 10,
            z: 20,
            targetX: 0,
            targetY: 5,
            targetZ: 0
        };

        let timeRemaining = 300; // 5 minutes in seconds
        let gameRunning = true;
        let discoveries = new Set();
        let solarFlareTimer = 0;
        let solarFlareActive = false;
        let particles = [];
        let ruins = [];
        let platforms = [];
        let obelisks = [];

        // Obelisk lore texts
        const loreTexts = [
            "The star sang to us in frequencies beyond hearing",
            "We built these monuments as the light began to fade",
            "Time flows differently near the dying heart",
            "The plasma seas remember our first arrival",
            "Solar winds carried our prayers to distant worlds",
            "In the corona's embrace, we found enlightenment",
            "The star's death brings rebirth to the cosmos",
            "Energy and matter dance in eternal cycles",
            "We leave these words for those who come after",
            "The supernova will seed new civilizations",
            "Our knowledge lives on in crystallized light",
            "The final flash illuminates infinite possibilities"
        ];

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            loadData();
            generateWorld();
            setupControls();
            gameLoop();
            startTimer();
        }

        // Generate world
        function generateWorld() {
            // Generate platforms (lava walkways)
            for (let i = 0; i < 20; i++) {
                platforms.push({
                    x: Math.random() * 200 - 100,
                    y: Math.random() * 10,
                    z: Math.random() * 200 - 100,
                    width: 10 + Math.random() * 20,
                    height: 2,
                    depth: 10 + Math.random() * 20,
                    glow: Math.random() * 0.5 + 0.5
                });
            }

            // Generate ruins
            for (let i = 0; i < 15; i++) {
                ruins.push({
                    x: Math.random() * 150 - 75,
                    y: Math.random() * 5 + 5,
                    z: Math.random() * 150 - 75,
                    height: 10 + Math.random() * 20,
                    radius: 5 + Math.random() * 10,
                    rotation: Math.random() * Math.PI * 2,
                    discovered: false
                });
            }

            // Generate obelisks with lore
            for (let i = 0; i < 12; i++) {
                obelisks.push({
                    x: Math.random() * 180 - 90,
                    y: 0,
                    z: Math.random() * 180 - 90,
                    height: 15 + Math.random() * 10,
                    text: loreTexts[i],
                    id: `obelisk_${i}`,
                    discovered: false,
                    glyphRotation: 0
                });
            }

            // Generate initial particles for atmosphere
            for (let i = 0; i < 100; i++) {
                particles.push(createParticle());
            }
        }

        // Create particle for effects
        function createParticle() {
            return {
                x: Math.random() * 400 - 200,
                y: Math.random() * 100,
                z: Math.random() * 400 - 200,
                vx: (Math.random() - 0.5) * 0.5,
                vy: Math.random() * 0.2 + 0.1,
                vz: (Math.random() - 0.5) * 0.5,
                size: Math.random() * 3 + 1,
                life: 1,
                color: `hsl(${Math.random() * 60}, 100%, 50%)` // Red to orange spectrum
            };
        }

        // Setup controls
        function setupControls() {
            const keys = {};
            let mouseX = 0, mouseY = 0;
            let mouseLocked = false;

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key.toLowerCase() === 'e') {
                    scanNearbyObjects();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Mouse controls
            canvas.addEventListener('click', () => {
                if (!mouseLocked) {
                    canvas.requestPointerLock();
                    mouseLocked = true;
                }
            });

            document.addEventListener('pointerlockchange', () => {
                mouseLocked = document.pointerLockElement === canvas;
            });

            document.addEventListener('mousemove', (e) => {
                if (mouseLocked) {
                    player.rotationY += e.movementX * 0.002;
                    player.rotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3,
                        player.rotationX - e.movementY * 0.002));
                }
            });

            // Update player movement
            window.updatePlayer = function() {
                if (!gameRunning) return;

                const speed = keys['shift'] ? 0.5 : 0.3;

                // Movement
                if (keys['w'] || keys['arrowup']) {
                    player.vx -= Math.sin(player.rotationY) * speed;
                    player.vz -= Math.cos(player.rotationY) * speed;
                }
                if (keys['s'] || keys['arrowdown']) {
                    player.vx += Math.sin(player.rotationY) * speed;
                    player.vz += Math.cos(player.rotationY) * speed;
                }
                if (keys['a'] || keys['arrowleft']) {
                    player.vx -= Math.cos(player.rotationY) * speed;
                    player.vz += Math.sin(player.rotationY) * speed;
                }
                if (keys['d'] || keys['arrowright']) {
                    player.vx += Math.cos(player.rotationY) * speed;
                    player.vz -= Math.sin(player.rotationY) * speed;
                }

                // Jump
                if (keys[' '] && player.onGround) {
                    player.vy = 0.8;
                    player.onGround = false;
                }

                // Apply physics
                player.vy -= 0.05; // Gravity
                player.vx *= 0.9; // Friction
                player.vz *= 0.9;

                // Update position
                player.x += player.vx;
                player.y += player.vy;
                player.z += player.vz;

                // Ground collision
                if (player.y <= 0) {
                    player.y = 0;
                    player.vy = 0;
                    player.onGround = true;
                }

                // Check platform collisions
                platforms.forEach(platform => {
                    if (Math.abs(player.x - platform.x) < platform.width/2 &&
                        Math.abs(player.z - platform.z) < platform.depth/2 &&
                        player.y <= platform.y + platform.height &&
                        player.y + 3 >= platform.y) {
                        player.y = platform.y + platform.height;
                        player.vy = 0;
                        player.onGround = true;
                    }
                });

                // Update camera to follow player
                camera.targetX = player.x;
                camera.targetY = player.y + 5;
                camera.targetZ = player.z;

                camera.x += (camera.targetX - Math.sin(player.rotationY) * 15 - camera.x) * 0.1;
                camera.y += (camera.targetY + 10 - camera.y) * 0.1;
                camera.z += (camera.targetZ - Math.cos(player.rotationY) * 15 - camera.z) * 0.1;
            };
        }

        // Scan for nearby objects
        function scanNearbyObjects() {
            let closestObject = null;
            let closestDistance = Infinity;

            // Check obelisks
            obelisks.forEach(obelisk => {
                const dist = Math.sqrt(
                    Math.pow(player.x - obelisk.x, 2) +
                    Math.pow(player.z - obelisk.z, 2)
                );

                if (dist < 10 && dist < closestDistance) {
                    closestDistance = dist;
                    closestObject = obelisk;
                }
            });

            if (closestObject && !closestObject.discovered) {
                closestObject.discovered = true;
                discoveries.add(closestObject.id);

                // Update UI
                const discoveryList = document.getElementById('discoveryList');
                const item = document.createElement('div');
                item.className = 'discovery-item';
                item.textContent = closestObject.text;
                discoveryList.appendChild(item);

                document.getElementById('discoveryCount').textContent = discoveries.size;

                // Flash scanner
                document.getElementById('statusInfo').textContent = 'ARTIFACT DOCUMENTED!';
                document.getElementById('statusInfo').style.color = '#00ff00';
                setTimeout(() => {
                    document.getElementById('statusInfo').textContent = 'Scanning...';
                    document.getElementById('statusInfo').style.color = '#00ffff';
                }, 2000);

                // Save discovery
                if (!gameData.allDiscoveries.includes(closestObject.id)) {
                    gameData.allDiscoveries.push(closestObject.id);
                }
                gameData.discoveries = Array.from(discoveries);
                saveData();
            }
        }

        // Start game timer
        function startTimer() {
            setInterval(() => {
                if (!gameRunning) return;

                timeRemaining--;

                // Update timer display
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = timeRemaining % 60;
                document.getElementById('timer').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Solar flare warnings
                if (timeRemaining % 30 === 0 && timeRemaining > 0) {
                    triggerSolarFlare();
                }

                // Critical warnings
                if (timeRemaining === 60) {
                    showWarning('ONE MINUTE UNTIL SUPERNOVA!');
                } else if (timeRemaining === 30) {
                    showWarning('30 SECONDS - EVACUATE NOW!');
                } else if (timeRemaining === 10) {
                    showWarning('STELLAR COLLAPSE IMMINENT!');
                }

                // Game over
                if (timeRemaining <= 0) {
                    triggerSupernova();
                }
            }, 1000);
        }

        // Trigger solar flare event
        function triggerSolarFlare() {
            solarFlareActive = true;
            document.getElementById('flareWarning').style.display = 'block';

            // Add more particles for flare effect
            for (let i = 0; i < 50; i++) {
                particles.push(createParticle());
            }

            setTimeout(() => {
                solarFlareActive = false;
                document.getElementById('flareWarning').style.display = 'none';
            }, 3000);
        }

        // Show warning message
        function showWarning(text) {
            const warnings = document.getElementById('warnings');
            const warning = document.createElement('div');
            warning.className = 'warning';
            warning.textContent = text;
            warnings.appendChild(warning);

            setTimeout(() => {
                warning.remove();
            }, 5000);
        }

        // Trigger supernova ending
        function triggerSupernova() {
            gameRunning = false;

            // Calculate stats
            const totalTime = 300 - timeRemaining;
            const minutes = Math.floor(totalTime / 60);
            const seconds = totalTime % 60;
            const score = discoveries.size * 1000 + (timeRemaining > 0 ? timeRemaining * 10 : 0);

            // Update game data
            gameData.totalPlays++;
            if (score > gameData.highScore) {
                gameData.highScore = score;
            }
            saveData();

            // Show game over screen
            document.getElementById('finalDiscoveries').textContent = `${discoveries.size}/12`;
            document.getElementById('knowledgePercent').textContent =
                `${Math.round((discoveries.size / 12) * 100)}%`;
            document.getElementById('timeSurvived').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('finalScore').textContent = score;

            if (discoveries.size === 12) {
                document.getElementById('gameOverTitle').textContent = 'COMPLETE ARCHIVES SAVED!';
            } else if (discoveries.size >= 8) {
                document.getElementById('gameOverTitle').textContent = 'KNOWLEDGE PRESERVED!';
            } else {
                document.getElementById('gameOverTitle').textContent = 'SUPERNOVA!';
            }

            document.getElementById('gameOver').classList.add('show');
        }

        // Restart game
        function restartGame() {
            location.reload();
        }

        // Render 3D scene (simplified projection)
        function render() {
            // Clear canvas with gradient for star atmosphere
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width
            );

            if (solarFlareActive) {
                gradient.addColorStop(0, '#ff6600');
                gradient.addColorStop(0.5, '#ff3300');
                gradient.addColorStop(1, '#330000');
            } else {
                gradient.addColorStop(0, '#ff4400');
                gradient.addColorStop(0.5, '#cc0000');
                gradient.addColorStop(1, '#220000');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Simple 3D to 2D projection
            function project3D(x, y, z) {
                const dx = x - camera.x;
                const dy = y - camera.y;
                const dz = z - camera.z;

                const scale = 500 / (dz + 50);
                const screenX = canvas.width / 2 + dx * scale;
                const screenY = canvas.height / 2 - dy * scale;

                return { x: screenX, y: screenY, scale: scale };
            }

            // Sort objects by depth for proper rendering
            const renderObjects = [];

            // Add platforms
            platforms.forEach(platform => {
                const proj = project3D(platform.x, platform.y, platform.z);
                if (proj.scale > 0) {
                    renderObjects.push({
                        type: 'platform',
                        obj: platform,
                        proj: proj,
                        depth: Math.sqrt(
                            Math.pow(platform.x - camera.x, 2) +
                            Math.pow(platform.z - camera.z, 2)
                        )
                    });
                }
            });

            // Add ruins
            ruins.forEach(ruin => {
                const proj = project3D(ruin.x, ruin.y, ruin.z);
                if (proj.scale > 0) {
                    renderObjects.push({
                        type: 'ruin',
                        obj: ruin,
                        proj: proj,
                        depth: Math.sqrt(
                            Math.pow(ruin.x - camera.x, 2) +
                            Math.pow(ruin.z - camera.z, 2)
                        )
                    });
                }
            });

            // Add obelisks
            obelisks.forEach(obelisk => {
                const proj = project3D(obelisk.x, obelisk.y + obelisk.height/2, obelisk.z);
                if (proj.scale > 0) {
                    renderObjects.push({
                        type: 'obelisk',
                        obj: obelisk,
                        proj: proj,
                        depth: Math.sqrt(
                            Math.pow(obelisk.x - camera.x, 2) +
                            Math.pow(obelisk.z - camera.z, 2)
                        )
                    });
                }
            });

            // Sort by depth (far to near)
            renderObjects.sort((a, b) => b.depth - a.depth);

            // Render objects
            renderObjects.forEach(item => {
                if (item.type === 'platform') {
                    // Lava platform
                    ctx.fillStyle = `rgba(255, ${100 + item.obj.glow * 100}, 0, 0.8)`;
                    ctx.fillRect(
                        item.proj.x - item.obj.width * item.proj.scale / 2,
                        item.proj.y - item.obj.height * item.proj.scale / 2,
                        item.obj.width * item.proj.scale,
                        item.obj.height * item.proj.scale
                    );

                    // Glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff6600';
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        item.proj.x - item.obj.width * item.proj.scale / 2,
                        item.proj.y - item.obj.height * item.proj.scale / 2,
                        item.obj.width * item.proj.scale,
                        item.obj.height * item.proj.scale
                    );
                    ctx.shadowBlur = 0;
                }
                else if (item.type === 'ruin') {
                    // Ancient ruin structure
                    ctx.fillStyle = 'rgba(100, 80, 60, 0.8)';
                    const width = item.obj.radius * item.proj.scale * 2;
                    const height = item.obj.height * item.proj.scale;

                    ctx.fillRect(
                        item.proj.x - width / 2,
                        item.proj.y - height,
                        width,
                        height
                    );

                    // Add detail lines
                    ctx.strokeStyle = 'rgba(60, 40, 20, 0.8)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(item.proj.x - width / 2, item.proj.y - height + i * height / 3);
                        ctx.lineTo(item.proj.x + width / 2, item.proj.y - height + i * height / 3);
                        ctx.stroke();
                    }
                }
                else if (item.type === 'obelisk') {
                    // Obelisk with glowing glyphs
                    const width = 10 * item.proj.scale;
                    const height = item.obj.height * item.proj.scale;

                    // Main structure
                    ctx.fillStyle = item.obj.discovered ? 'rgba(150, 120, 100, 0.9)' : 'rgba(80, 60, 50, 0.9)';
                    ctx.fillRect(
                        item.proj.x - width / 2,
                        item.proj.y - height / 2,
                        width,
                        height
                    );

                    // Glowing glyphs if discovered
                    if (item.obj.discovered) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#00ffff';
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;

                        // Draw some alien symbols
                        ctx.beginPath();
                        ctx.arc(item.proj.x, item.proj.y, width / 3, 0, Math.PI * 2);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(item.proj.x - width / 4, item.proj.y - height / 4);
                        ctx.lineTo(item.proj.x + width / 4, item.proj.y + height / 4);
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                    }

                    // Update glyph rotation
                    item.obj.glyphRotation += 0.02;
                }
            });

            // Render particles
            particles.forEach(particle => {
                const proj = project3D(particle.x, particle.y, particle.z);
                if (proj.scale > 0 && particle.life > 0) {
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, particle.size * proj.scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;

            // Update particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.z += particle.vz;
                particle.life -= 0.01;

                // Respawn particles that die
                if (particle.life <= 0 || particle.y > 100) {
                    return false;
                }
                return true;
            });

            // Add new particles to maintain count
            while (particles.length < 100) {
                particles.push(createParticle());
            }

            // Render player shadow
            const playerProj = project3D(player.x, 0, player.z);
            if (playerProj.scale > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(playerProj.x, playerProj.y, 10 * playerProj.scale, 5 * playerProj.scale, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update scanner HUD
            let closestObelisk = null;
            let closestDist = Infinity;

            obelisks.forEach(obelisk => {
                const dist = Math.sqrt(
                    Math.pow(player.x - obelisk.x, 2) +
                    Math.pow(player.z - obelisk.z, 2)
                );

                if (dist < closestDist) {
                    closestDist = dist;
                    closestObelisk = obelisk;
                }
            });

            if (closestObelisk) {
                document.getElementById('targetInfo').textContent =
                    closestObelisk.discovered ? 'Documented' : 'Unknown Artifact';
                document.getElementById('distanceInfo').textContent =
                    `${Math.round(closestDist)}m`;
            }
        }

        // Main game loop
        function gameLoop() {
            if (gameRunning) {
                updatePlayer();
                render();
            }
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Start the game
        window.addEventListener('load', init);
    </script>
</body>
</html>