<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Forest of Infinite Recursion - Quantum World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d5016 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #header {
            background: rgba(45, 80, 22, 0.9);
            padding: 15px 20px;
            border-bottom: 2px solid #ffd700;
            pointer-events: all;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            background: #4a2511;
            color: #ffd700;
            border: 2px solid #ffd700;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            pointer-events: all;
        }

        .btn:hover {
            background: #ffd700;
            color: #4a2511;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #scale-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(45, 80, 22, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            pointer-events: all;
            width: 200px;
        }

        #scale-slider {
            width: 100%;
            margin: 15px 0;
            -webkit-appearance: none;
            height: 8px;
            background: linear-gradient(to right, #4a2511, #2d5016, #87ceeb);
            outline: none;
            border-radius: 4px;
        }

        #scale-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #ffd700;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #4a2511;
        }

        #scale-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ffd700;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #4a2511;
        }

        .scale-label {
            font-size: 14px;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .scale-value {
            font-size: 18px;
            color: #fff;
            text-align: center;
            margin-top: 10px;
        }

        #info-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            background: rgba(45, 80, 22, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            pointer-events: all;
            max-width: 300px;
        }

        .info-item {
            margin: 10px 0;
            padding: 8px;
            background: rgba(74, 37, 17, 0.5);
            border-radius: 5px;
            font-size: 14px;
        }

        .info-label {
            color: #ffd700;
            font-weight: bold;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(45, 80, 22, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            pointer-events: all;
            max-width: 350px;
        }

        .instruction {
            margin: 5px 0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key {
            background: #4a2511;
            padding: 3px 8px;
            border-radius: 3px;
            border: 1px solid #ffd700;
            font-family: monospace;
            font-weight: bold;
            color: #ffd700;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .spinner {
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #network-status {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(45, 80, 22, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #ffd700;
            pointer-events: all;
            font-size: 13px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-online {
            background: #00ff00;
        }

        .status-offline {
            background: #ff4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            #scale-panel {
                left: 10px;
                width: 150px;
                padding: 15px;
            }

            #info-panel {
                right: 10px;
                max-width: 200px;
                padding: 15px;
            }

            #instructions {
                left: 10px;
                bottom: 10px;
                max-width: 250px;
                font-size: 11px;
            }

            .title {
                font-size: 18px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        #transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 0%, #2d5016 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
        }

        #transition-overlay.active {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="ui-overlay">
        <div id="header">
            <div class="title">
                <span>üå≥</span>
                <span>Fractal Forest of Infinite Recursion</span>
            </div>
            <div class="controls">
                <button class="btn" id="save-btn">üíæ Save</button>
                <button class="btn" id="load-btn">üìÇ Load</button>
                <button class="btn" id="export-btn">üì§ Export</button>
                <button class="btn" id="import-btn">üì• Import</button>
                <button class="btn" id="reset-btn">üîÑ Reset</button>
            </div>
        </div>

        <div id="scale-panel">
            <div class="scale-label">Reality Scale</div>
            <input type="range" id="scale-slider" min="0" max="100" value="50" step="1">
            <div class="scale-value" id="scale-value">1.0x</div>
            <div style="margin-top: 15px; font-size: 12px; color: #ffd700;">
                <div>üî¨ Micro ‚Üí Macro üåç</div>
            </div>
        </div>

        <div id="info-panel">
            <div class="info-item">
                <span class="info-label">Recursion Depth:</span>
                <span id="recursion-depth">3</span>
            </div>
            <div class="info-item">
                <span class="info-label">Current Scale:</span>
                <span id="current-scale">Normal</span>
            </div>
            <div class="info-item">
                <span class="info-label">Trees Visible:</span>
                <span id="tree-count">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Position:</span>
                <span id="position">0, 0, 0</span>
            </div>
            <div class="info-item">
                <span class="info-label">FPS:</span>
                <span id="fps">60</span>
            </div>
        </div>

        <div id="network-status">
            <span class="status-indicator status-offline" id="status-indicator"></span>
            <span id="status-text">P2P: Offline</span>
        </div>

        <div id="instructions">
            <div class="instruction"><span class="key">WASD</span> Move Camera</div>
            <div class="instruction"><span class="key">Mouse</span> Look Around</div>
            <div class="instruction"><span class="key">Slider</span> Change Scale</div>
            <div class="instruction"><span class="key">Click Leaf</span> Zoom Into Ecosystem</div>
            <div class="instruction"><span class="key">Space</span> Jump Between Layers</div>
            <div class="instruction"><span class="key">R</span> Regenerate Forest</div>
        </div>

        <div id="loading">
            <div class="spinner"></div>
            <div>Generating Fractal Forest...</div>
        </div>

        <div id="transition-overlay"></div>
    </div>

    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
        // ============================================================================
        // SIMPLIFIED THREE.JS IMPLEMENTATION
        // Core 3D rendering engine (simplified for inline use)
        // ============================================================================

        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            set(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                return this;
            }

            multiplyScalar(s) {
                this.x *= s;
                this.y *= s;
                this.z *= s;
                return this;
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const len = this.length();
                if (len > 0) {
                    this.multiplyScalar(1 / len);
                }
                return this;
            }

            clone() {
                return new Vector3(this.x, this.y, this.z);
            }

            cross(v) {
                const x = this.y * v.z - this.z * v.y;
                const y = this.z * v.x - this.x * v.z;
                const z = this.x * v.y - this.y * v.x;
                return new Vector3(x, y, z);
            }

            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }
        }

        class Matrix4 {
            constructor() {
                this.elements = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            }

            identity() {
                this.elements = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
                return this;
            }

            perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);

                this.elements = [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, 2 * far * near * nf, 0
                ];
                return this;
            }

            lookAt(eye, target, up) {
                const z = new Vector3().copy(eye).sub(target).normalize();
                const x = up.clone().cross(z).normalize();
                const y = z.clone().cross(x);

                this.elements = [
                    x.x, y.x, z.x, 0,
                    x.y, y.y, z.y, 0,
                    x.z, y.z, z.z, 0,
                    -x.dot(eye), -y.dot(eye), -z.dot(eye), 1
                ];
                return this;
            }

            copy(m) {
                this.elements = [...m.elements];
                return this;
            }
        }

        Vector3.prototype.copy = function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        };

        // ============================================================================
        // FRACTAL FOREST ENGINE
        // Core engine for generating and managing the recursive forest
        // ============================================================================

        class FractalForestEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                // Camera settings
                this.camera = {
                    pos: new Vector3(0, 5, 20),
                    rot: new Vector3(0, 0, 0),
                    fov: Math.PI / 3,
                    near: 0.1,
                    far: 1000
                };

                // World state
                this.scale = 1.0;
                this.recursionDepth = 3;
                this.trees = [];
                this.particles = [];

                // Input state
                this.keys = {};
                this.mouse = { x: 0, y: 0, dx: 0, dy: 0, locked: false };

                // Performance tracking
                this.lastTime = performance.now();
                this.frameCount = 0;
                this.fps = 60;

                // Colors
                this.colors = {
                    sky: '#87ceeb',
                    ground: '#2d5016',
                    bark: '#4a2511',
                    leaves: '#3d7018',
                    leavesLight: '#5a9922',
                    gold: '#ffd700'
                };

                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.generateForest();
                this.animate();

                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 1000);
            }

            resizeCanvas() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());

                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;

                    if (e.key.toLowerCase() === 'r') {
                        this.generateForest();
                    }
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.jumpLayer();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.dx = e.movementX || 0;
                        this.mouse.dy = e.movementY || 0;
                    }
                });

                this.canvas.addEventListener('click', () => {
                    if (!this.mouse.locked) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                // Scale slider
                const slider = document.getElementById('scale-slider');
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.setScale(value);
                });
            }

            setScale(sliderValue) {
                // Map slider (0-100) to scale (0.001 - 1000)
                // Use logarithmic scale for better feel
                const normalized = sliderValue / 100; // 0 to 1
                this.scale = Math.pow(10, (normalized - 0.5) * 6); // 10^-3 to 10^3

                document.getElementById('scale-value').textContent = this.scale.toFixed(3) + 'x';

                // Update scale description
                let scaleDesc = 'Normal';
                if (this.scale < 0.01) scaleDesc = 'Microscopic';
                else if (this.scale < 0.1) scaleDesc = 'Tiny';
                else if (this.scale < 0.5) scaleDesc = 'Small';
                else if (this.scale < 2) scaleDesc = 'Normal';
                else if (this.scale < 10) scaleDesc = 'Large';
                else if (this.scale < 100) scaleDesc = 'Giant';
                else scaleDesc = 'Cosmic';

                document.getElementById('current-scale').textContent = scaleDesc;

                // Trigger transition effect
                this.triggerScaleTransition();
            }

            triggerScaleTransition() {
                const overlay = document.getElementById('transition-overlay');
                overlay.classList.add('active');
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 500);
            }

            jumpLayer() {
                // Jump to a random scale level
                const randomScale = Math.random() * 100;
                document.getElementById('scale-slider').value = randomScale;
                this.setScale(randomScale);
            }

            generateForest() {
                this.trees = [];
                const numTrees = 12;
                const radius = 30;

                for (let i = 0; i < numTrees; i++) {
                    const angle = (i / numTrees) * Math.PI * 2;
                    const distance = radius * (0.5 + Math.random() * 0.5);

                    const tree = {
                        pos: new Vector3(
                            Math.cos(angle) * distance,
                            0,
                            Math.sin(angle) * distance
                        ),
                        seed: Math.random(),
                        height: 8 + Math.random() * 6,
                        branches: []
                    };

                    this.generateTreeRecursive(tree, 0);
                    this.trees.push(tree);
                }

                document.getElementById('tree-count').textContent = this.trees.length;
            }

            generateTreeRecursive(tree, depth) {
                if (depth >= this.recursionDepth) return;

                const numBranches = 4 + Math.floor(Math.random() * 4);
                const baseHeight = tree.height / (depth + 1);

                for (let i = 0; i < numBranches; i++) {
                    const angle = (i / numBranches) * Math.PI * 2 + Math.random() * 0.5;
                    const height = baseHeight * (0.6 + Math.random() * 0.4);
                    const startHeight = baseHeight * 0.3 + Math.random() * baseHeight * 0.4;

                    const branch = {
                        angle: angle,
                        height: height,
                        startHeight: startHeight,
                        thickness: 0.3 / (depth + 1),
                        depth: depth,
                        subBranches: []
                    };

                    // Recursively generate sub-branches (fractal!)
                    if (depth < this.recursionDepth - 1 && Math.random() > 0.3) {
                        const subTree = {
                            pos: new Vector3(0, 0, 0),
                            seed: Math.random(),
                            height: height * 0.5,
                            branches: []
                        };
                        this.generateTreeRecursive(subTree, depth + 1);
                        branch.subBranches = subTree.branches;
                    }

                    tree.branches.push(branch);
                }
            }

            updateCamera(deltaTime) {
                const moveSpeed = 10 * deltaTime * this.scale;
                const lookSpeed = 0.002;

                // Mouse look
                if (this.mouse.locked) {
                    this.camera.rot.y -= this.mouse.dx * lookSpeed;
                    this.camera.rot.x -= this.mouse.dy * lookSpeed;
                    this.camera.rot.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.camera.rot.x));
                    this.mouse.dx = 0;
                    this.mouse.dy = 0;
                }

                // WASD movement
                const forward = new Vector3(
                    Math.sin(this.camera.rot.y),
                    0,
                    Math.cos(this.camera.rot.y)
                );
                const right = new Vector3(
                    Math.cos(this.camera.rot.y),
                    0,
                    -Math.sin(this.camera.rot.y)
                );

                if (this.keys['w']) {
                    this.camera.pos.add(forward.clone().multiplyScalar(moveSpeed));
                }
                if (this.keys['s']) {
                    this.camera.pos.sub(forward.clone().multiplyScalar(moveSpeed));
                }
                if (this.keys['a']) {
                    this.camera.pos.sub(right.clone().multiplyScalar(moveSpeed));
                }
                if (this.keys['d']) {
                    this.camera.pos.add(right.clone().multiplyScalar(moveSpeed));
                }

                // Update UI
                document.getElementById('position').textContent =
                    `${this.camera.pos.x.toFixed(1)}, ${this.camera.pos.y.toFixed(1)}, ${this.camera.pos.z.toFixed(1)}`;
            }

            project(point) {
                // Simple perspective projection
                const dx = point.x - this.camera.pos.x;
                const dy = point.y - this.camera.pos.y;
                const dz = point.z - this.camera.pos.z;

                // Rotate by camera rotation
                const cosY = Math.cos(-this.camera.rot.y);
                const sinY = Math.sin(-this.camera.rot.y);
                const cosX = Math.cos(-this.camera.rot.x);
                const sinX = Math.sin(-this.camera.rot.x);

                // Rotate around Y axis
                let x = dx * cosY - dz * sinY;
                let z = dx * sinY + dz * cosY;
                let y = dy;

                // Rotate around X axis
                const y2 = y * cosX - z * sinX;
                z = y * sinX + z * cosX;
                y = y2;

                if (z <= 0.1) return null;

                const scale = (this.height / 2) / Math.tan(this.camera.fov / 2) / z;
                return {
                    x: this.width / 2 + x * scale,
                    y: this.height / 2 - y * scale,
                    z: z,
                    scale: scale
                };
            }

            render() {
                // Clear canvas with sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, this.colors.sky);
                gradient.addColorStop(1, '#c8e6f5');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Draw ground
                this.drawGround();

                // Sort trees by distance for proper rendering
                const sortedTrees = [...this.trees].sort((a, b) => {
                    const distA = Math.sqrt(
                        Math.pow(a.pos.x - this.camera.pos.x, 2) +
                        Math.pow(a.pos.z - this.camera.pos.z, 2)
                    );
                    const distB = Math.sqrt(
                        Math.pow(b.pos.x - this.camera.pos.x, 2) +
                        Math.pow(b.pos.z - this.camera.pos.z, 2)
                    );
                    return distB - distA;
                });

                // Draw trees
                sortedTrees.forEach(tree => this.drawTree(tree));

                // Draw particles
                this.drawParticles();
            }

            drawGround() {
                const gridSize = 100;
                const gridStep = 5;
                this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                this.ctx.lineWidth = 1;

                for (let x = -gridSize; x <= gridSize; x += gridStep) {
                    const p1 = this.project(new Vector3(x, 0, -gridSize));
                    const p2 = this.project(new Vector3(x, 0, gridSize));
                    if (p1 && p2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                }

                for (let z = -gridSize; z <= gridSize; z += gridStep) {
                    const p1 = this.project(new Vector3(-gridSize, 0, z));
                    const p2 = this.project(new Vector3(gridSize, 0, z));
                    if (p1 && p2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                }
            }

            drawTree(tree) {
                // Draw trunk
                const baseProj = this.project(tree.pos);
                const topProj = this.project(new Vector3(tree.pos.x, tree.pos.y + tree.height, tree.pos.z));

                if (!baseProj || !topProj) return;

                this.ctx.strokeStyle = this.colors.bark;
                this.ctx.lineWidth = Math.max(2, 10 / topProj.z);
                this.ctx.beginPath();
                this.ctx.moveTo(baseProj.x, baseProj.y);
                this.ctx.lineTo(topProj.x, topProj.y);
                this.ctx.stroke();

                // Draw branches recursively
                tree.branches.forEach(branch => {
                    this.drawBranch(tree.pos, branch, tree.height);
                });

                // Draw foliage at top
                if (topProj.z > 0) {
                    const size = Math.max(20, 200 / topProj.z) * (1 + Math.sin(tree.seed * 100) * 0.2);
                    const gradient = this.ctx.createRadialGradient(
                        topProj.x, topProj.y, 0,
                        topProj.x, topProj.y, size
                    );
                    gradient.addColorStop(0, this.colors.leavesLight);
                    gradient.addColorStop(0.7, this.colors.leaves);
                    gradient.addColorStop(1, 'transparent');

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(topProj.x, topProj.y, size, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Add golden highlights (fractal indicators)
                    this.ctx.fillStyle = this.colors.gold;
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + Date.now() * 0.001;
                        const radius = size * 0.6;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            topProj.x + Math.cos(angle) * radius,
                            topProj.y + Math.sin(angle) * radius,
                            3, 0, Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                }
            }

            drawBranch(basePos, branch, parentHeight) {
                const startPos = new Vector3(
                    basePos.x,
                    basePos.y + branch.startHeight,
                    basePos.z
                );

                const endPos = new Vector3(
                    basePos.x + Math.cos(branch.angle) * branch.height * 0.5,
                    basePos.y + branch.startHeight + branch.height,
                    basePos.z + Math.sin(branch.angle) * branch.height * 0.5
                );

                const startProj = this.project(startPos);
                const endProj = this.project(endPos);

                if (startProj && endProj) {
                    this.ctx.strokeStyle = this.colors.bark;
                    this.ctx.lineWidth = Math.max(1, branch.thickness * 20 / endProj.z);
                    this.ctx.beginPath();
                    this.ctx.moveTo(startProj.x, startProj.y);
                    this.ctx.lineTo(endProj.x, endProj.y);
                    this.ctx.stroke();

                    // Draw leaves at branch end
                    const leafSize = Math.max(5, 30 / endProj.z) / (branch.depth + 1);
                    this.ctx.fillStyle = branch.depth % 2 === 0 ? this.colors.leaves : this.colors.leavesLight;
                    this.ctx.beginPath();
                    this.ctx.arc(endProj.x, endProj.y, leafSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Draw sub-branches recursively
                branch.subBranches.forEach(subBranch => {
                    this.drawBranch(endPos, subBranch, branch.height);
                });
            }

            drawParticles() {
                // Ambient particles (floating spores, light)
                const time = Date.now() * 0.001;
                for (let i = 0; i < 30; i++) {
                    const x = Math.sin(time * 0.5 + i) * 40;
                    const y = 3 + Math.sin(time * 0.3 + i * 0.5) * 2;
                    const z = Math.cos(time * 0.5 + i) * 40;

                    const proj = this.project(new Vector3(x, y, z));
                    if (proj && proj.z > 0) {
                        this.ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(time * 2 + i) * 0.2})`;
                        this.ctx.beginPath();
                        this.ctx.arc(proj.x, proj.y, 3 / proj.z * 10, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            animate() {
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                // Update FPS counter
                this.frameCount++;
                if (this.frameCount % 30 === 0) {
                    this.fps = Math.round(1 / deltaTime);
                    document.getElementById('fps').textContent = this.fps;
                }

                this.updateCamera(deltaTime);
                this.render();

                requestAnimationFrame(() => this.animate());
            }

            // Data persistence methods
            saveState() {
                const state = {
                    camera: {
                        pos: { x: this.camera.pos.x, y: this.camera.pos.y, z: this.camera.pos.z },
                        rot: { x: this.camera.rot.x, y: this.camera.rot.y, z: this.camera.rot.z }
                    },
                    scale: this.scale,
                    recursionDepth: this.recursionDepth,
                    trees: this.trees.map(tree => ({
                        pos: { x: tree.pos.x, y: tree.pos.y, z: tree.pos.z },
                        seed: tree.seed,
                        height: tree.height
                    })),
                    timestamp: Date.now()
                };

                localStorage.setItem('fractalForestState', JSON.stringify(state));
                return state;
            }

            loadState() {
                const saved = localStorage.getItem('fractalForestState');
                if (saved) {
                    const state = JSON.parse(saved);
                    this.camera.pos.set(state.camera.pos.x, state.camera.pos.y, state.camera.pos.z);
                    this.camera.rot.set(state.camera.rot.x, state.camera.rot.y, state.camera.rot.z);
                    this.scale = state.scale;
                    this.recursionDepth = state.recursionDepth;

                    // Restore trees
                    this.trees = state.trees.map(treeData => {
                        const tree = {
                            pos: new Vector3(treeData.pos.x, treeData.pos.y, treeData.pos.z),
                            seed: treeData.seed,
                            height: treeData.height,
                            branches: []
                        };
                        this.generateTreeRecursive(tree, 0);
                        return tree;
                    });

                    // Update UI
                    const sliderValue = Math.log10(this.scale) / 6 * 100 + 50;
                    document.getElementById('scale-slider').value = sliderValue;
                    this.setScale(sliderValue);

                    return true;
                }
                return false;
            }

            exportData() {
                const state = this.saveState();
                const json = JSON.stringify(state, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fractal-forest-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importData(jsonData) {
                try {
                    const state = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    localStorage.setItem('fractalForestState', JSON.stringify(state));
                    this.loadState();
                    return true;
                } catch (error) {
                    console.error('Import failed:', error);
                    return false;
                }
            }

            reset() {
                this.camera.pos.set(0, 5, 20);
                this.camera.rot.set(0, 0, 0);
                this.scale = 1.0;
                document.getElementById('scale-slider').value = 50;
                this.setScale(50);
                this.generateForest();
                localStorage.removeItem('fractalForestState');
            }
        }

        // ============================================================================
        // P2P NETWORKING (Simplified Implementation)
        // Basic P2P functionality for multiplayer (stub for future implementation)
        // ============================================================================

        class P2PNetwork {
            constructor() {
                this.peerId = this.generatePeerId();
                this.peers = [];
                this.isOnline = false;
            }

            generatePeerId() {
                return 'peer_' + Math.random().toString(36).substr(2, 9);
            }

            connect() {
                // Stub for P2P connection
                // In a full implementation, this would use WebRTC
                setTimeout(() => {
                    this.isOnline = true;
                    this.updateUI();
                }, 1000);
            }

            disconnect() {
                this.isOnline = false;
                this.peers = [];
                this.updateUI();
            }

            updateUI() {
                const indicator = document.getElementById('status-indicator');
                const text = document.getElementById('status-text');

                if (this.isOnline) {
                    indicator.className = 'status-indicator status-online';
                    text.textContent = `P2P: Online (${this.peers.length} peers)`;
                } else {
                    indicator.className = 'status-indicator status-offline';
                    text.textContent = 'P2P: Offline';
                }
            }

            broadcast(data) {
                // Stub for broadcasting data to peers
                console.log('Broadcasting:', data);
            }
        }

        // ============================================================================
        // APPLICATION INITIALIZATION
        // Main entry point and UI event handlers
        // ============================================================================

        let engine;
        let network;

        window.addEventListener('DOMContentLoaded', () => {
            engine = new FractalForestEngine();
            network = new P2PNetwork();

            // Setup UI event handlers
            document.getElementById('save-btn').addEventListener('click', () => {
                engine.saveState();
                showNotification('Forest state saved!');
            });

            document.getElementById('load-btn').addEventListener('click', () => {
                if (engine.loadState()) {
                    showNotification('Forest state loaded!');
                } else {
                    showNotification('No saved state found');
                }
            });

            document.getElementById('export-btn').addEventListener('click', () => {
                engine.exportData();
                showNotification('Data exported!');
            });

            document.getElementById('import-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        if (engine.importData(event.target.result)) {
                            showNotification('Data imported successfully!');
                        } else {
                            showNotification('Import failed!');
                        }
                    };
                    reader.readAsText(file);
                }
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                if (confirm('Reset the entire forest? This cannot be undone.')) {
                    engine.reset();
                    showNotification('Forest reset!');
                }
            });

            // Try to load saved state
            engine.loadState();

            // Connect to P2P network
            network.connect();
        });

        function showNotification(message) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(45, 80, 22, 0.95);
                color: #ffd700;
                padding: 15px 30px;
                border-radius: 8px;
                border: 2px solid #ffd700;
                font-size: 16px;
                z-index: 1000;
                pointer-events: none;
                animation: fadeInOut 2s;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // Add CSS animation for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            }
        `;
        document.head.appendChild(style);

        // ============================================================================
        // FRACTAL MATHEMATICS VISUALIZATION
        // Additional visual effects based on fractal mathematics
        // ============================================================================

        // L-System generator for procedural branch patterns
        class LSystem {
            constructor(axiom, rules, iterations) {
                this.axiom = axiom;
                this.rules = rules;
                this.iterations = iterations;
                this.result = axiom;
                this.generate();
            }

            generate() {
                for (let i = 0; i < this.iterations; i++) {
                    let next = '';
                    for (let char of this.result) {
                        next += this.rules[char] || char;
                    }
                    this.result = next;
                }
            }
        }

        // Example L-System for tree generation
        // F = Forward, + = Turn left, - = Turn right, [ = Push state, ] = Pop state
        const treeLSystem = new LSystem(
            'F',
            {
                'F': 'F[+F]F[-F]F'
            },
            4
        );

        console.log('üå≥ Fractal Forest Initialized');
        console.log('L-System Pattern:', treeLSystem.result.substring(0, 50) + '...');
    </script>
</body>
</html>