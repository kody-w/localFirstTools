<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Synthwave City at Perpetual Sunset</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #ff006e 0%, #8b2dd6 50%, #1a0033 100%);
            color: #00f5ff;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            pointer-events: all;
            background: rgba(26, 0, 51, 0.85);
            border: 2px solid rgba(255, 0, 110, 0.5);
            border-radius: 0;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.4), inset 0 0 20px rgba(0, 245, 255, 0.1);
            font-family: 'Courier New', monospace;
        }

        #top-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            flex-wrap: wrap;
        }

        #info-section {
            flex: 1;
            min-width: 250px;
        }

        #info-section h1 {
            font-size: 1.8rem;
            color: #ff006e;
            margin-bottom: 8px;
            text-shadow: 0 0 20px #ff006e, 0 0 40px #ff006e;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #stats {
            font-size: 0.9rem;
            line-height: 1.8;
            color: #00f5ff;
            text-shadow: 0 0 5px #00f5ff;
        }

        .stat-label {
            color: #ff9500;
            text-shadow: 0 0 5px #ff9500;
        }

        #controls-section {
            min-width: 280px;
        }

        #controls-section h3 {
            color: #8b2dd6;
            margin-bottom: 10px;
            font-size: 1.1rem;
            text-shadow: 0 0 10px #8b2dd6;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .control-key {
            color: #ff006e;
            font-weight: bold;
            text-shadow: 0 0 5px #ff006e;
        }

        #bottom-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #ff006e 0%, #8b2dd6 100%);
            color: #fff;
            border: 2px solid #00f5ff;
            padding: 10px 20px;
            border-radius: 0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: linear-gradient(135deg, #8b2dd6 0%, #ff006e 100%);
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.8);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            gap: 15px;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 110, 0.3);
            border: 2px solid #00f5ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            touch-action: none;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
            #top-panel {
                flex-direction: column;
            }
            .ui-panel {
                font-size: 0.85rem;
            }
        }

        /* Scanline effect */
        #canvas-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            opacity: 0.3;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #ff006e;
            text-shadow: 0 0 30px #ff006e;
            z-index: 200;
            text-align: center;
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="loading" class="pulse">LOADING NEON CITY...</div>

    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="top-panel">
            <div id="info-section" class="ui-panel">
                <h1>ðŸŒ† NEON CITY</h1>
                <div id="stats">
                    <div><span class="stat-label">Position:</span> <span id="pos-display">0, 0, 0</span></div>
                    <div><span class="stat-label">Flying Cars:</span> <span id="cars-display">0</span></div>
                    <div><span class="stat-label">Players:</span> <span id="players-display">1</span></div>
                    <div><span class="stat-label">Mode:</span> <span id="mode-display">Walking</span></div>
                    <div><span class="stat-label">Audio:</span> <span id="audio-display">Analyzing...</span></div>
                </div>
            </div>

            <div id="controls-section" class="ui-panel">
                <h3>Controls</h3>
                <div class="control-row">
                    <span class="control-key">WASD</span>
                    <span>Move</span>
                </div>
                <div class="control-row">
                    <span class="control-key">MOUSE</span>
                    <span>Look Around</span>
                </div>
                <div class="control-row">
                    <span class="control-key">SPACE</span>
                    <span>Jump / Fly Up</span>
                </div>
                <div class="control-row">
                    <span class="control-key">SHIFT</span>
                    <span>Sprint / Fly Down</span>
                </div>
                <div class="control-row">
                    <span class="control-key">F</span>
                    <span>Toggle Fly Mode</span>
                </div>
                <div class="control-row">
                    <span class="control-key">E</span>
                    <span>Interact</span>
                </div>
            </div>
        </div>

        <div id="bottom-panel">
            <button onclick="app.exportData()">Export City</button>
            <button onclick="document.getElementById('import-input').click()">Import City</button>
            <button onclick="app.toggleMusic()">Toggle Music</button>
            <button onclick="app.resetCity()">Reset City</button>
        </div>

        <div id="mobile-controls">
            <button class="mobile-btn" id="mobile-jump">â†‘</button>
            <button class="mobile-btn" id="mobile-forward">â–²</button>
            <button class="mobile-btn" id="mobile-fly">âœˆ</button>
        </div>
    </div>

    <input type="file" id="import-input" style="display: none;" accept=".json">

    <script>
        // ============================================================================
        // SIMPLIFIED THREE.JS (Core functionality inline)
        // ============================================================================

        const THREE = {
            MathUtils: {
                randFloatSpread(range) {
                    return (Math.random() - 0.5) * range;
                },
                degToRad(degrees) {
                    return degrees * Math.PI / 180;
                },
                clamp(value, min, max) {
                    return Math.max(min, Math.min(max, value));
                }
            }
        };

        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            set(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }

            clone() {
                return new Vector3(this.x, this.y, this.z);
            }

            copy(v) {
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                return this;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                return this;
            }

            multiplyScalar(s) {
                this.x *= s;
                this.y *= s;
                this.z *= s;
                return this;
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const len = this.length();
                if (len > 0) {
                    this.multiplyScalar(1 / len);
                }
                return this;
            }

            distanceTo(v) {
                const dx = this.x - v.x;
                const dy = this.y - v.y;
                const dz = this.z - v.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
        }

        class Color {
            constructor(hex) {
                this.r = 1;
                this.g = 1;
                this.b = 1;
                if (hex !== undefined) this.setHex(hex);
            }

            setHex(hex) {
                hex = Math.floor(hex);
                this.r = (hex >> 16 & 255) / 255;
                this.g = (hex >> 8 & 255) / 255;
                this.b = (hex & 255) / 255;
                return this;
            }

            setHSL(h, s, l) {
                h = ((h % 1) + 1) % 1;
                s = Math.max(0, Math.min(1, s));
                l = Math.max(0, Math.min(1, l));

                if (s === 0) {
                    this.r = this.g = this.b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    this.r = hue2rgb(p, q, h + 1/3);
                    this.g = hue2rgb(p, q, h);
                    this.b = hue2rgb(p, q, h - 1/3);
                }
                return this;
            }

            toCSS() {
                return `rgb(${Math.floor(this.r * 255)}, ${Math.floor(this.g * 255)}, ${Math.floor(this.b * 255)})`;
            }
        }

        // ============================================================================
        // NEON SYNTHWAVE CITY APPLICATION
        // ============================================================================

        class NeonSynthwaveCity {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                // Camera and player
                this.camera = {
                    position: new Vector3(0, 20, 50),
                    rotation: { x: 0, y: 0 },
                    velocity: new Vector3(),
                    isFlying: false
                };

                // World state
                this.buildings = [];
                this.flyingCars = [];
                this.billboards = [];
                this.gridFloor = null;
                this.players = new Map();

                // Input state
                this.keys = {};
                this.mouse = {
                    locked: false,
                    deltaX: 0,
                    deltaY: 0,
                    sensitivity: 0.002
                };

                // Settings
                this.settings = {
                    moveSpeed: 0.3,
                    flySpeed: 0.5,
                    sprintMultiplier: 2,
                    gravity: 0.5,
                    jumpForce: 10,
                    buildingCount: 120,
                    carCount: 30,
                    billboardCount: 40,
                    musicReactive: true
                };

                // Music visualization
                this.audioContext = null;
                this.analyser = null;
                this.audioDataArray = null;
                this.audioActive = false;
                this.musicIntensity = 0;

                // P2P networking (simplified)
                this.peerId = this.generatePeerId();
                this.connections = new Map();

                // Animation
                this.lastTime = 0;
                this.animationId = null;

                // Performance
                this.frameCount = 0;
                this.lastFpsTime = 0;
                this.fps = 60;

                this.init();
            }

            /**
             * Initialize the application
             */
            async init() {
                console.log('Initializing Neon Synthwave City...');

                // Create canvas
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.ctx = this.canvas.getContext('2d');
                document.getElementById('canvas-container').appendChild(this.canvas);

                // Load data from localStorage
                this.loadFromStorage();

                // Generate world
                this.generateCity();

                // Setup controls
                this.setupControls();

                // Setup audio
                this.setupAudio();

                // Setup import handler
                this.setupImportHandler();

                // Start animation loop
                this.lastTime = performance.now();
                this.animate();

                // Hide loading
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);

                // Update stats
                setInterval(() => this.updateStats(), 100);

                console.log('Neon Synthwave City initialized!');
            }

            /**
             * Generate the cyberpunk city
             */
            generateCity() {
                console.log('Generating cyberpunk city...');

                // Create grid floor
                this.gridFloor = {
                    size: 500,
                    spacing: 10,
                    color: new Color(0xff006e),
                    glowIntensity: 0.5
                };

                // Generate procedural buildings
                const gridSize = 15;
                const spacing = 30;
                const centerOffset = (gridSize * spacing) / 2;

                for (let x = 0; x < gridSize; x++) {
                    for (let z = 0; z < gridSize; z++) {
                        // Skip center area for open plaza
                        if (Math.abs(x - gridSize/2) < 2 && Math.abs(z - gridSize/2) < 2) continue;

                        const building = this.createBuilding(
                            new Vector3(
                                x * spacing - centerOffset,
                                0,
                                z * spacing - centerOffset
                            )
                        );
                        this.buildings.push(building);
                    }
                }

                // Generate flying cars
                for (let i = 0; i < this.settings.carCount; i++) {
                    this.flyingCars.push(this.createFlyingCar());
                }

                // Generate holographic billboards
                for (let i = 0; i < this.settings.billboardCount; i++) {
                    this.billboards.push(this.createBillboard());
                }

                console.log(`Generated ${this.buildings.length} buildings, ${this.flyingCars.length} flying cars`);
            }

            /**
             * Create a procedural building
             */
            createBuilding(position) {
                const width = 8 + Math.random() * 8;
                const height = 30 + Math.random() * 100;
                const depth = 8 + Math.random() * 8;

                // Neon color palette
                const colors = [0xff006e, 0x00f5ff, 0x8b2dd6, 0xff9500];
                const primaryColor = new Color(colors[Math.floor(Math.random() * colors.length)]);
                const accentColor = new Color(colors[Math.floor(Math.random() * colors.length)]);

                return {
                    position: position.clone(),
                    width,
                    height,
                    depth,
                    primaryColor,
                    accentColor,
                    glowIntensity: 0.5 + Math.random() * 0.5,
                    windowPattern: Math.floor(Math.random() * 3), // Different window patterns
                    rooftop: Math.random() > 0.7, // Some buildings have rooftop gardens
                    pulsePhase: Math.random() * Math.PI * 2 // For music reactivity
                };
            }

            /**
             * Create a flying car on sky lanes
             */
            createFlyingCar() {
                // Sky lanes at different heights
                const laneHeight = [40, 60, 80][Math.floor(Math.random() * 3)];
                const laneRadius = 100 + Math.random() * 100;
                const angle = Math.random() * Math.PI * 2;

                return {
                    position: new Vector3(
                        Math.cos(angle) * laneRadius,
                        laneHeight,
                        Math.sin(angle) * laneRadius
                    ),
                    velocity: new Vector3(),
                    angle: angle,
                    laneRadius: laneRadius,
                    speed: 0.02 + Math.random() * 0.02,
                    color: new Color().setHSL(Math.random(), 1, 0.6),
                    trailPositions: [],
                    maxTrailLength: 20
                };
            }

            /**
             * Create a holographic billboard
             */
            createBillboard() {
                const building = this.buildings[Math.floor(Math.random() * this.buildings.length)];

                return {
                    position: new Vector3(
                        building.position.x,
                        building.height * 0.7,
                        building.position.z
                    ),
                    width: building.width * 0.8,
                    height: building.width * 0.5,
                    text: this.generateBillboardText(),
                    color: new Color().setHSL(Math.random(), 1, 0.6),
                    animPhase: Math.random() * Math.PI * 2,
                    animSpeed: 0.02 + Math.random() * 0.03
                };
            }

            /**
             * Generate random billboard text
             */
            generateBillboardText() {
                const texts = [
                    'NEON CITY', 'CYBER SPACE', 'FUTURE NOW', 'TECH DREAMS',
                    'DIGITAL LIFE', 'SYNTH WAVE', 'GRID RUNNER', 'DATA FLOW',
                    'QUANTUM ZONE', 'VOID WALKER', 'NEURAL NET', 'BIO TECH'
                ];
                return texts[Math.floor(Math.random() * texts.length)];
            }

            /**
             * Setup keyboard, mouse, and touch controls
             */
            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.jump();
                    }

                    if (e.code === 'KeyF') {
                        this.toggleFlyMode();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse look (pointer lock)
                this.canvas.addEventListener('click', () => {
                    if (!this.mouse.locked) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.deltaX = e.movementX;
                        this.mouse.deltaY = e.movementY;
                        this.updateCameraRotation();
                    }
                });

                // Touch controls for mobile
                const mobileJump = document.getElementById('mobile-jump');
                const mobileFly = document.getElementById('mobile-fly');

                if (mobileJump) {
                    mobileJump.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.jump();
                    });
                }

                if (mobileFly) {
                    mobileFly.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.toggleFlyMode();
                    });
                }

                // Window resize
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                });
            }

            /**
             * Setup audio context and analyser for music visualization
             */
            setupAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.audioDataArray = new Uint8Array(bufferLength);

                    console.log('Audio context initialized');
                } catch (e) {
                    console.warn('Audio API not available:', e);
                }
            }

            /**
             * Update camera rotation from mouse movement
             */
            updateCameraRotation() {
                this.camera.rotation.y -= this.mouse.deltaX * this.mouse.sensitivity;
                this.camera.rotation.x -= this.mouse.deltaY * this.mouse.sensitivity;

                // Clamp vertical rotation
                this.camera.rotation.x = THREE.MathUtils.clamp(
                    this.camera.rotation.x,
                    -Math.PI / 2,
                    Math.PI / 2
                );

                this.mouse.deltaX = 0;
                this.mouse.deltaY = 0;
            }

            /**
             * Toggle flying mode
             */
            toggleFlyMode() {
                this.camera.isFlying = !this.camera.isFlying;
                this.camera.velocity.y = 0;
                console.log('Flying mode:', this.camera.isFlying);
            }

            /**
             * Jump action
             */
            jump() {
                if (!this.camera.isFlying && Math.abs(this.camera.velocity.y) < 0.1) {
                    this.camera.velocity.y = this.settings.jumpForce;
                }
            }

            /**
             * Update player movement
             */
            updateMovement(deltaTime) {
                const speed = this.camera.isFlying ? this.settings.flySpeed : this.settings.moveSpeed;
                const multiplier = this.keys.ShiftLeft ? this.settings.sprintMultiplier : 1;

                // Movement direction based on camera rotation
                const forward = new Vector3(
                    Math.sin(this.camera.rotation.y),
                    0,
                    Math.cos(this.camera.rotation.y)
                );
                const right = new Vector3(
                    Math.cos(this.camera.rotation.y),
                    0,
                    -Math.sin(this.camera.rotation.y)
                );

                const moveDir = new Vector3();

                if (this.keys.KeyW) moveDir.add(forward);
                if (this.keys.KeyS) moveDir.sub(forward);
                if (this.keys.KeyD) moveDir.add(right);
                if (this.keys.KeyA) moveDir.sub(right);

                if (moveDir.length() > 0) {
                    moveDir.normalize().multiplyScalar(speed * multiplier * deltaTime);
                    this.camera.position.add(moveDir);
                }

                // Flying mode vertical movement
                if (this.camera.isFlying) {
                    if (this.keys.Space) {
                        this.camera.position.y += speed * multiplier * deltaTime;
                    }
                    if (this.keys.ShiftLeft) {
                        this.camera.position.y -= speed * multiplier * deltaTime;
                    }
                } else {
                    // Apply gravity
                    this.camera.velocity.y -= this.settings.gravity * deltaTime;
                    this.camera.position.y += this.camera.velocity.y * deltaTime;

                    // Ground collision
                    if (this.camera.position.y < 5) {
                        this.camera.position.y = 5;
                        this.camera.velocity.y = 0;
                    }
                }
            }

            /**
             * Update flying cars along sky lanes
             */
            updateFlyingCars(deltaTime) {
                this.flyingCars.forEach(car => {
                    // Update angle for circular motion
                    car.angle += car.speed * deltaTime;

                    // Update position on sky lane
                    car.position.x = Math.cos(car.angle) * car.laneRadius;
                    car.position.z = Math.sin(car.angle) * car.laneRadius;

                    // Add to trail
                    car.trailPositions.push(car.position.clone());
                    if (car.trailPositions.length > car.maxTrailLength) {
                        car.trailPositions.shift();
                    }

                    // Music reactivity
                    if (this.settings.musicReactive) {
                        car.speed = (0.02 + Math.random() * 0.02) * (1 + this.musicIntensity * 0.5);
                    }
                });
            }

            /**
             * Update billboard animations
             */
            updateBillboards(deltaTime) {
                this.billboards.forEach(billboard => {
                    billboard.animPhase += billboard.animSpeed * deltaTime;
                });
            }

            /**
             * Update music visualization
             */
            updateMusicVisualization() {
                if (this.analyser && this.audioActive) {
                    this.analyser.getByteFrequencyData(this.audioDataArray);

                    // Calculate average intensity
                    let sum = 0;
                    for (let i = 0; i < this.audioDataArray.length; i++) {
                        sum += this.audioDataArray[i];
                    }
                    this.musicIntensity = (sum / this.audioDataArray.length) / 255;
                } else {
                    // Simulate pulse without audio
                    this.musicIntensity = 0.3 + Math.sin(Date.now() * 0.001) * 0.2;
                }
            }

            /**
             * Main animation loop
             */
            animate() {
                const currentTime = performance.now();
                const deltaTime = Math.min((currentTime - this.lastTime) / 16.67, 2); // Cap at 2x for stability
                this.lastTime = currentTime;

                // Update
                this.updateMovement(deltaTime);
                this.updateFlyingCars(deltaTime);
                this.updateBillboards(deltaTime);
                this.updateMusicVisualization();

                // Render
                this.render();

                // FPS counter
                this.frameCount++;
                if (currentTime - this.lastFpsTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsTime = currentTime;
                }

                // Continue loop
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            /**
             * Render the 3D scene (2.5D projection)
             */
            render() {
                const ctx = this.ctx;
                const w = this.width;
                const h = this.height;

                // Clear with sunset gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, h);
                gradient.addColorStop(0, '#ff006e');
                gradient.addColorStop(0.3, '#8b2dd6');
                gradient.addColorStop(0.6, '#1a0033');
                gradient.addColorStop(1, '#000000');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);

                // Add sun glow
                const sunGradient = ctx.createRadialGradient(w/2, h * 0.3, 0, w/2, h * 0.3, h * 0.4);
                sunGradient.addColorStop(0, 'rgba(255, 149, 0, 0.3)');
                sunGradient.addColorStop(1, 'rgba(255, 149, 0, 0)');
                ctx.fillStyle = sunGradient;
                ctx.fillRect(0, 0, w, h);

                // Render grid floor
                this.renderGridFloor(ctx);

                // Sort objects by distance for proper depth
                const renderList = [];

                // Add buildings to render list
                this.buildings.forEach(building => {
                    const dist = this.camera.position.distanceTo(building.position);
                    renderList.push({ type: 'building', object: building, distance: dist });
                });

                // Add flying cars
                this.flyingCars.forEach(car => {
                    const dist = this.camera.position.distanceTo(car.position);
                    renderList.push({ type: 'car', object: car, distance: dist });
                });

                // Add billboards
                this.billboards.forEach(billboard => {
                    const dist = this.camera.position.distanceTo(billboard.position);
                    renderList.push({ type: 'billboard', object: billboard, distance: dist });
                });

                // Sort by distance (far to near)
                renderList.sort((a, b) => b.distance - a.distance);

                // Render all objects
                renderList.forEach(item => {
                    if (item.type === 'building') {
                        this.renderBuilding(ctx, item.object);
                    } else if (item.type === 'car') {
                        this.renderFlyingCar(ctx, item.object);
                    } else if (item.type === 'billboard') {
                        this.renderBillboard(ctx, item.object);
                    }
                });
            }

            /**
             * Render the neon grid floor
             */
            renderGridFloor(ctx) {
                const gridSize = this.gridFloor.size;
                const spacing = this.gridFloor.spacing;

                ctx.strokeStyle = this.gridFloor.color.toCSS();
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.3 + this.musicIntensity * 0.3;

                // Only draw grid lines near camera for performance
                const drawDistance = 200;

                for (let x = -gridSize; x <= gridSize; x += spacing) {
                    const dist = Math.abs(x - this.camera.position.x);
                    if (dist < drawDistance) {
                        const start = this.worldToScreen(new Vector3(x, 0, -gridSize));
                        const end = this.worldToScreen(new Vector3(x, 0, gridSize));
                        if (start && end) {
                            ctx.beginPath();
                            ctx.moveTo(start.x, start.y);
                            ctx.lineTo(end.x, end.y);
                            ctx.stroke();
                        }
                    }
                }

                for (let z = -gridSize; z <= gridSize; z += spacing) {
                    const dist = Math.abs(z - this.camera.position.z);
                    if (dist < drawDistance) {
                        const start = this.worldToScreen(new Vector3(-gridSize, 0, z));
                        const end = this.worldToScreen(new Vector3(gridSize, 0, z));
                        if (start && end) {
                            ctx.beginPath();
                            ctx.moveTo(start.x, start.y);
                            ctx.lineTo(end.x, end.y);
                            ctx.stroke();
                        }
                    }
                }

                ctx.globalAlpha = 1;
            }

            /**
             * Render a neon building
             */
            renderBuilding(ctx, building) {
                // Calculate music-reactive pulse
                const pulse = this.settings.musicReactive ?
                    (1 + Math.sin(Date.now() * 0.003 + building.pulsePhase) * 0.1 * this.musicIntensity) : 1;

                // Get screen positions of building corners
                const pos = building.position;
                const w = building.width / 2;
                const h = building.height;
                const d = building.depth / 2;

                // Building corners (front face)
                const corners = [
                    this.worldToScreen(new Vector3(pos.x - w, pos.y, pos.z + d)),      // bottom left
                    this.worldToScreen(new Vector3(pos.x + w, pos.y, pos.z + d)),      // bottom right
                    this.worldToScreen(new Vector3(pos.x + w, pos.y + h, pos.z + d)),  // top right
                    this.worldToScreen(new Vector3(pos.x - w, pos.y + h, pos.z + d))   // top left
                ];

                // Skip if behind camera
                if (!corners[0] || !corners[1] || !corners[2] || !corners[3]) return;

                // Draw main building body
                ctx.fillStyle = `rgba(${building.primaryColor.r * 100}, ${building.primaryColor.g * 100}, ${building.primaryColor.b * 100}, 0.8)`;
                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                ctx.lineTo(corners[1].x, corners[1].y);
                ctx.lineTo(corners[2].x, corners[2].y);
                ctx.lineTo(corners[3].x, corners[3].y);
                ctx.closePath();
                ctx.fill();

                // Draw neon edges with glow
                ctx.strokeStyle = building.accentColor.toCSS();
                ctx.lineWidth = 2 * pulse;
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = building.accentColor.toCSS();
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Draw windows
                this.renderWindows(ctx, corners, building);
            }

            /**
             * Render building windows
             */
            renderWindows(ctx, corners, building) {
                const windowSize = 3;
                const windowSpacing = 8;
                const buildingWidth = Math.abs(corners[1].x - corners[0].x);
                const buildingHeight = Math.abs(corners[3].y - corners[0].y);

                ctx.fillStyle = building.accentColor.toCSS();
                ctx.globalAlpha = 0.6 + this.musicIntensity * 0.4;

                // Draw grid of windows
                for (let x = windowSpacing; x < buildingWidth - windowSpacing; x += windowSpacing) {
                    for (let y = windowSpacing; y < buildingHeight - windowSpacing; y += windowSpacing) {
                        // Random window on/off pattern
                        if (Math.random() > 0.3) {
                            const wx = corners[0].x + x;
                            const wy = corners[0].y + y;
                            ctx.fillRect(wx, wy, windowSize, windowSize);
                        }
                    }
                }

                ctx.globalAlpha = 1;
            }

            /**
             * Render a flying car with neon trail
             */
            renderFlyingCar(ctx, car) {
                // Render trail
                ctx.strokeStyle = car.color.toCSS();
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;

                ctx.beginPath();
                let firstPoint = true;
                car.trailPositions.forEach(pos => {
                    const screen = this.worldToScreen(pos);
                    if (screen) {
                        if (firstPoint) {
                            ctx.moveTo(screen.x, screen.y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(screen.x, screen.y);
                        }
                    }
                });
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Render car body
                const screen = this.worldToScreen(car.position);
                if (screen) {
                    ctx.fillStyle = car.color.toCSS();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = car.color.toCSS();
                    ctx.fillRect(screen.x - 3, screen.y - 2, 6, 4);
                    ctx.shadowBlur = 0;
                }
            }

            /**
             * Render a holographic billboard
             */
            renderBillboard(ctx, billboard) {
                const pos = this.worldToScreen(billboard.position);
                if (!pos) return;

                const opacity = 0.7 + Math.sin(billboard.animPhase) * 0.3;

                // Draw billboard background
                ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.5})`;
                ctx.fillRect(pos.x - 40, pos.y - 15, 80, 30);

                // Draw text
                ctx.font = 'bold 12px "Courier New"';
                ctx.fillStyle = billboard.color.toCSS();
                ctx.globalAlpha = opacity;
                ctx.shadowBlur = 10;
                ctx.shadowColor = billboard.color.toCSS();
                ctx.textAlign = 'center';
                ctx.fillText(billboard.text, pos.x, pos.y);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }

            /**
             * Convert 3D world position to 2D screen position
             */
            worldToScreen(worldPos) {
                // Simple perspective projection
                const cam = this.camera;

                // Translate to camera space
                const dx = worldPos.x - cam.position.x;
                const dy = worldPos.y - cam.position.y;
                const dz = worldPos.z - cam.position.z;

                // Rotate by camera rotation (yaw only for simplicity)
                const cosY = Math.cos(-cam.rotation.y);
                const sinY = Math.sin(-cam.rotation.y);

                const rx = dx * cosY - dz * sinY;
                const ry = dy;
                const rz = dx * sinY + dz * cosY;

                // Behind camera check
                if (rz <= 1) return null;

                // Apply pitch rotation
                const cosX = Math.cos(-cam.rotation.x);
                const sinX = Math.sin(-cam.rotation.x);

                const ry2 = ry * cosX - rz * sinX;
                const rz2 = ry * sinX + rz * cosX;

                // Perspective projection
                const fov = 90;
                const scale = (this.height / 2) / Math.tan(THREE.MathUtils.degToRad(fov / 2));

                const x = (rx / rz2) * scale + this.width / 2;
                const y = (ry2 / rz2) * scale + this.height / 2;

                return { x, y, z: rz2 };
            }

            /**
             * Update stats display
             */
            updateStats() {
                const pos = this.camera.position;
                document.getElementById('pos-display').textContent =
                    `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
                document.getElementById('cars-display').textContent = this.flyingCars.length;
                document.getElementById('players-display').textContent = this.players.size + 1;
                document.getElementById('mode-display').textContent = this.camera.isFlying ? 'Flying' : 'Walking';
                document.getElementById('audio-display').textContent =
                    this.audioActive ? `Active (${Math.floor(this.musicIntensity * 100)}%)` : 'Inactive';
            }

            /**
             * Toggle music visualization
             */
            toggleMusic() {
                if (this.audioContext) {
                    if (this.audioActive) {
                        this.audioActive = false;
                        console.log('Music visualization disabled');
                    } else {
                        this.audioActive = true;
                        console.log('Music visualization enabled');
                    }
                } else {
                    alert('Audio API not available in this browser');
                }
            }

            /**
             * Generate unique peer ID
             */
            generatePeerId() {
                return 'player_' + Math.random().toString(36).substr(2, 9);
            }

            /**
             * Save state to localStorage
             */
            saveToStorage() {
                const data = {
                    version: '1.0',
                    camera: {
                        position: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z },
                        rotation: this.camera.rotation,
                        isFlying: this.camera.isFlying
                    },
                    buildingCount: this.buildings.length,
                    timestamp: Date.now()
                };

                try {
                    localStorage.setItem('neonSynthwaveCity', JSON.stringify(data));
                    console.log('City saved to localStorage');
                } catch (e) {
                    console.error('Failed to save:', e);
                }
            }

            /**
             * Load state from localStorage
             */
            loadFromStorage() {
                try {
                    const data = localStorage.getItem('neonSynthwaveCity');
                    if (data) {
                        const parsed = JSON.parse(data);
                        if (parsed.camera) {
                            this.camera.position.set(
                                parsed.camera.position.x,
                                parsed.camera.position.y,
                                parsed.camera.position.z
                            );
                            this.camera.rotation = parsed.camera.rotation;
                            this.camera.isFlying = parsed.camera.isFlying || false;
                        }
                        console.log('City loaded from localStorage');
                    }
                } catch (e) {
                    console.error('Failed to load:', e);
                }
            }

            /**
             * Export city data as JSON
             */
            exportData() {
                const data = {
                    version: '1.0',
                    worldName: 'Neon Synthwave City',
                    exportDate: new Date().toISOString(),
                    camera: {
                        position: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z },
                        rotation: this.camera.rotation,
                        isFlying: this.camera.isFlying
                    },
                    settings: this.settings,
                    buildingCount: this.buildings.length,
                    carCount: this.flyingCars.length
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'neon-synthwave-city-' + Date.now() + '.json';
                a.click();
                URL.revokeObjectURL(url);

                console.log('City data exported');
            }

            /**
             * Setup import handler
             */
            setupImportHandler() {
                const input = document.getElementById('import-input');
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                this.importData(data);
                            } catch (error) {
                                console.error('Import error:', error);
                                alert('Failed to import city data');
                            }
                        };
                        reader.readAsText(file);
                    }
                    input.value = ''; // Reset input
                });
            }

            /**
             * Import city data from JSON
             */
            importData(data) {
                if (data.camera) {
                    this.camera.position.set(
                        data.camera.position.x,
                        data.camera.position.y,
                        data.camera.position.z
                    );
                    this.camera.rotation = data.camera.rotation;
                    this.camera.isFlying = data.camera.isFlying || false;
                }

                if (data.settings) {
                    Object.assign(this.settings, data.settings);
                }

                console.log('City data imported');
                alert('City data imported successfully!');
            }

            /**
             * Reset city to initial state
             */
            resetCity() {
                if (confirm('Reset the city to its initial state? This will clear your current position.')) {
                    this.camera.position.set(0, 20, 50);
                    this.camera.rotation = { x: 0, y: 0 };
                    this.camera.isFlying = false;
                    this.camera.velocity.set(0, 0, 0);

                    localStorage.removeItem('neonSynthwaveCity');
                    console.log('City reset');
                }
            }

            /**
             * Cleanup
             */
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.audioContext) {
                    this.audioContext.close();
                }
            }
        }

        // ============================================================================
        // INITIALIZE APPLICATION
        // ============================================================================

        let app;

        window.addEventListener('DOMContentLoaded', () => {
            app = new NeonSynthwaveCity();

            // Auto-save periodically
            setInterval(() => {
                if (app) {
                    app.saveToStorage();
                }
            }, 30000); // Every 30 seconds
        });

        window.addEventListener('beforeunload', () => {
            if (app) {
                app.saveToStorage();
                app.destroy();
            }
        });
    </script>
</body>
</html>
