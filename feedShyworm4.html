<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>3D Minecraft Worm ‚Äî Pro Edition</title>
  <style>
    :root{
      --ui-bg: rgba(0,0,0,0.65);
      --ui-panel: rgba(18,18,18,0.9);
      --ui-accent: #66e3a5;
      --ui-danger: #ff6565;
      --ui-warn: #ffc34d;
      --text: #f5f7fa;
      --muted: #bfc7d5;
      --neon: #25f0d2;
    }
    html, body{
      margin:0; padding:0; height:100%;
      overflow:hidden;
      background: radial-gradient(1000px 800px at 70% 10%, #b7e7ff 0%, #7bc9ff 25%, #62b5ff 40%, #5aa0f0 60%, #4a75c2 100%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: none;
    }
    #gameContainer{ position:relative; width:100vw; height:100vh; }
    .glass{
      backdrop-filter: blur(8px) saturate(1.2);
      -webkit-backdrop-filter: blur(8px) saturate(1.2);
      background: var(--ui-bg);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.04);
      border-radius: 12px;
    }
    #hudLeft{
      position:absolute; top:16px; left:16px; z-index:50; padding:14px 16px; min-width:240px;
    }
    #hudRight{
      position:absolute; top:16px; right:16px; z-index:50; padding:14px 16px; min-width:240px; text-align:right;
    }
    #brand{
      font-weight:700; letter-spacing:0.5px; color:var(--neon);
      text-shadow:0 0 10px rgba(37,240,210,0.6); margin-bottom:6px;
    }
    #scoreRow, #statsRow{
      display:flex; align-items:center; gap:12px; justify-content:space-between;
      margin-bottom:12px; font-size:16px;
    }
    .stat{ font-weight:600; color:#fff; }
    .muted{ color:var(--muted); font-size:12px; }

    #controls{
      font-size:13px; line-height:1.5; padding:12px;
      border-radius:10px; background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.06);
    }
    #toggles{
      display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px;
    }
    .toggle{
      display:flex; align-items:center; gap:8px; justify-content:space-between;
      background: rgba(255,255,255,0.06);
      padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.05);
      font-size:13px;
    }
    .toggle input[type="checkbox"]{ width:18px; height:18px; accent-color: var(--ui-accent); cursor:pointer; }

    select, button, input[type="range"]{
      background: rgba(255,255,255,0.08);
      color:var(--text);
      border:1px solid rgba(255,255,255,0.15);
      padding:8px 10px;
      border-radius:8px; font-size:13px; outline:none;
    }
    button{
      cursor:pointer; transition: transform .12s ease, background .12s ease, box-shadow .2s ease;
      background: linear-gradient(180deg, #2f8b6a, #268460);
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 6px 14px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
    }
    button:hover{ transform: translateY(-1px); box-shadow: 0 10px 18px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.08); }
    button:active{ transform: translateY(0) scale(.99); }
    .secondary{ background: linear-gradient(180deg, #355b93, #2d4f82); }
    .warn{ background: linear-gradient(180deg, #b1842f, #a07628); }
    .danger{ background: linear-gradient(180deg, #b64040, #a63838); }

    #welcome, #gameOver{
      position:absolute; left:50%; top:50%; transform: translate(-50%, -50%);
      z-index:200; padding:24px 22px; width:min(560px, calc(100vw - 32px)); text-align:center;
    }
    #welcome h2, #gameOver h2{ margin:0 0 8px; letter-spacing:.3px; }
    #welcome .desc{
      text-align:left; background: rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.06); border-radius:10px;
      padding:12px 14px; margin:16px 0 4px; line-height:1.55;
    }
    .kbd{
      display:inline-block; border:1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.4); padding:2px 6px; border-radius:6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; color:#fff;
    }
    #overlayButtons{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin-top:14px; }

    #tips{
      position:absolute; bottom:16px; left:50%; transform: translateX(-50%);
      z-index:40; padding:10px 14px; font-size:13px; opacity:.9;
    }
    #tips .hint{ color:var(--muted); }

    @media (max-width: 720px){
      #hudLeft, #hudRight{
        min-width:unset; width:calc(100vw - 32px); left:50%; transform:translateX(-50%);
        right:unset; margin-bottom:8px;
      }
      #hudRight{ top:unset; bottom:16px; }
      #toggles{ grid-template-columns:1fr; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- HUD Left -->
    <div id="hudLeft" class="glass">
      <div id="brand">AI Pathfinder ‚Äî 3D Worm</div>
      <div id="scoreRow">
        <div><span class="muted">Score</span><div class="stat" id="score">0</div></div>
        <div><span class="muted">Length</span><div class="stat" id="length">3</div></div>
        <div><span class="muted">High</span><div class="stat" id="highScore">0</div></div>
      </div>
      <div id="controls">
        <div class="muted">Controls</div>
        <div>üêõ Worm auto-navigates via smart pathfinding</div>
        <div>üçî Move/Place food: <span class="kbd">W/A/S/D</span> or <span class="kbd">Arrows</span> or tap/click ground</div>
        <div>‚èØ Pause: <span class="kbd">Space</span> ‚Ä¢ Restart: <span class="kbd">R</span> ‚Ä¢ Follow Cam: <span class="kbd">F</span></div>
        <div>üß≠ Drag to orbit ‚Ä¢ <span class="kbd">Shift</span> + Drag to pan ‚Ä¢ Wheel to zoom</div>
        <div id="toggles">
          <div class="toggle">
            <label for="speed">Speed</label>
            <select id="speed">
              <option value="slow">Slow</option>
              <option value="normal" selected>Normal</option>
              <option value="fast">Fast</option>
              <option value="insane">Insane</option>
            </select>
          </div>
          <div class="toggle">
            <label for="wrapWalls">Wrap Walls</label>
            <input type="checkbox" id="wrapWalls" />
          </div>
          <div class="toggle">
            <label for="autoFood">Auto Food</label>
            <input type="checkbox" id="autoFood" checked />
          </div>
          <div class="toggle">
            <label for="showPath">Show Path</label>
            <input type="checkbox" id="showPath" checked />
          </div>
          <div class="toggle">
            <label for="mute">Mute</label>
            <input type="checkbox" id="mute" />
          </div>
        </div>
      </div>
    </div>

    <!-- HUD Right -->
    <div id="hudRight" class="glass">
      <div class="muted">Session</div>
      <div id="statsRow">
        <div>
          <div class="muted">Time</div>
          <div class="stat" id="time">0s</div>
        </div>
        <div>
          <div class="muted">FPS</div>
          <div class="stat" id="fps">0</div>
        </div>
        <div>
          <div class="muted">Speed</div>
          <div class="stat" id="speedLabel">Normal</div>
        </div>
      </div>
      <div style="margin-top:8px;">
        <button id="btnPause" class="secondary">Pause</button>
        <button id="btnRestart" class="warn">Restart</button>
      </div>
    </div>

    <!-- Welcome -->
    <div id="welcome" class="glass">
      <h2>3D Minecraft Worm ‚Äî Pro Edition</h2>
      <div class="desc">
        <p>üêõ Smart pathfinding steers the worm toward food while avoiding itself and walls.</p>
        <p>üçî Use <span class="kbd">W/A/S/D</span> or <span class="kbd">Arrows</span> or tap/click ground to move/place food.</p>
        <p>üß≠ Drag to orbit; <span class="kbd">Shift</span> + Drag to pan; scroll to zoom.</p>
        <p>üöß Toggle <b>Wrap Walls</b> for portal-style edges. Enable <b>Auto Food</b> to respawn food randomly.</p>
        <p>üèÜ Grow the worm, boost your score, and set the high score (saved locally).</p>
      </div>
      <div id="overlayButtons">
        <button id="btnStart">Start Game</button>
        <button id="btnStartFast" class="secondary">Start Fast</button>
      </div>
      <div class="muted" style="margin-top:10px;">Built for smoothness, clarity, and fun ‚Äî enjoy! ‚ú®</div>
    </div>

    <!-- Game Over -->
    <div id="gameOver" class="glass" style="display:none;">
      <h2>Game Over</h2>
      <div style="margin:10px 0;">
        <div>Final Score: <span class="stat" id="finalScore">0</span></div>
        <div>Final Length: <span class="stat" id="finalLength">0</span></div>
        <div>Time: <span class="stat" id="finalTime">0s</span></div>
      </div>
      <div id="overlayButtons">
        <button id="btnPlayAgain">Play Again</button>
        <button id="btnClose" class="danger">Close</button>
      </div>
    </div>

    <!-- Hints -->
    <div id="tips" class="glass">
      <span class="hint">Tip: Toggle <b>F</b> to switch Follow Cam ‚Ä¢ Use <b>Wrap Walls</b> for longer runs.</span>
    </div>
  </div>

  <!-- three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
  (function(){
    class ProWormGame {
      constructor(){
        // Core config
        this.gridSize = 22;
        this.cellSize = 1;
        this.worm = [
          { x: 5, y: 0, z: 10 },
          { x: 4, y: 0, z: 10 },
          { x: 3, y: 0, z: 10 },
        ];
        this.food = { x: Math.floor(this.gridSize/2), y: 0, z: Math.floor(this.gridSize/2) };
        this.wrapWalls = false;
        this.autoFood = true;
        this.showPath = true;
        this.followCam = true;

        // State
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem("proWormHighScore") || "0", 10);
        this.gameRunning = false;
        this.gamePaused = false;
        this.startTime = 0;
        this.fps = 0;

        // Timing
        this.speedMode = "normal";
        this.baseInterval = 0.22; // seconds between cell moves
        this.accum = 0;
        this.clock = new THREE.Clock();

        // Pathfinding
        this.currentPath = [];
        this.noPathStreak = 0;

        // Init
        this._initScene();
        this._createTextures();
        this._buildWorld();
        this._buildWorm();
        this._buildFood();
        this._buildPathPreview();
        this._buildParticles();
        this._initAudio();

        this._setupUI();
        this._setupInput();
        this._loop();
      }

      /* ---------- Scene ---------- */
      _initScene(){
        const container = document.getElementById("gameContainer");
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x7bc9ff, 24, 80);

        const aspect = window.innerWidth / window.innerHeight;
        this.camera = new THREE.PerspectiveCamera(65, aspect, 0.1, 1000);

        this.renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x7bc9ff);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(this.renderer.domElement);

        // Lights
        const hemi = new THREE.HemisphereLight(0xb2d7ff, 0x41577c, 0.75);
        this.scene.add(hemi);

        this.dirLight = new THREE.DirectionalLight(0xffffff, 0.95);
        this.dirLight.position.set(18, 30, 22);
        this.dirLight.castShadow = true;
        const s = 40;
        this.dirLight.shadow.camera.left = -s;
        this.dirLight.shadow.camera.right = s;
        this.dirLight.shadow.camera.top = s;
        this.dirLight.shadow.camera.bottom = -s;
        this.dirLight.shadow.mapSize.set(2048, 2048);
        this.scene.add(this.dirLight);

        // Simple sky dome
        const skyGeo = new THREE.SphereGeometry(200, 32, 16);
        const skyMat = new THREE.ShaderMaterial({
          side: THREE.BackSide,
          uniforms: {
            topColor: { value: new THREE.Color(0x86c9ff) },
            bottomColor: { value: new THREE.Color(0x5a86c2) },
            offset: { value: 33 },
            exponent: { value: 0.6 },
          },
          vertexShader: `
            varying vec3 vWorldPosition;
            void main(){
              vec4 wp = modelMatrix * vec4(position, 1.0);
              vWorldPosition = wp.xyz;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main(){
              float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
              float f = max(pow(max(h, 0.0), exponent), 0.0);
              gl_FragColor = vec4(mix(bottomColor, topColor, f), 1.0);
            }
          `,
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        this.scene.add(sky);

        // Camera target
        this.camTarget = new THREE.Vector3(this.gridSize/2, 0, this.gridSize/2);
        this.spherical = new THREE.Spherical(30, Math.PI/3, Math.PI/6);
        this._applyCamera();

        // Resize
        window.addEventListener("resize", () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }
      _applyCamera(){
        const { radius, phi, theta } = this.spherical;
        const x = this.camTarget.x + radius * Math.sin(phi) * Math.cos(theta);
        const y = this.camTarget.y + radius * Math.cos(phi);
        const z = this.camTarget.z + radius * Math.sin(phi) * Math.sin(theta);
        this.camera.position.set(x, y, z);
        this.camera.lookAt(this.camTarget);
      }

      /* ---------- Textures ---------- */
      _createTextures(){
        this.textures = {
          grass: this._blockTexture("#2e8b57"),
          dirt: this._blockTexture("#7a4a28"),
          stone: this._blockTexture("#5d6065"),
          wormHead: this._blockTexture("#1e7a1e"),
          wormBody: this._blockTexture("#34c634"),
          food: this._blockTexture("#ff6a00"),
          grid: this._gridTexture(this.gridSize, 0.15),
        };
      }
      _blockTexture(hex){
        const c = document.createElement("canvas");
        c.width = c.height = 64;
        const ctx = c.getContext("2d");
        ctx.fillStyle = hex;
        ctx.fillRect(0,0,64,64);
        for(let i=0;i<170;i++){
          const x = (Math.random()*62)|0;
          const y = (Math.random()*62)|0;
          const b = (Math.random()*0.35 - 0.17)*255;
          const r = Math.max(0, Math.min(255, parseInt(hex.slice(1,3),16) + b));
          const g = Math.max(0, Math.min(255, parseInt(hex.slice(3,5),16) + b));
          const bl= Math.max(0, Math.min(255, parseInt(hex.slice(5,7),16) + b));
          ctx.fillStyle = `rgb(${r|0},${g|0},${bl|0})`;
          ctx.fillRect(x,y,2,2);
        }
        const tex = new THREE.CanvasTexture(c);
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        return tex;
      }
      _gridTexture(size, alpha=0.2){
        const dim = 512;
        const c = document.createElement("canvas");
        c.width = c.height = dim;
        const ctx = c.getContext("2d");
        ctx.clearRect(0,0,dim,dim);
        ctx.fillStyle = "rgba(255,255,255,0.0)";
        ctx.fillRect(0,0,dim,dim);
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 1;
        const step = dim / size;
        for(let i=0;i<=size;i++){
          const p = (i*step)|0;
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,dim); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(dim,p); ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.magFilter = THREE.LinearFilter;
        tex.minFilter = THREE.LinearMipMapLinearFilter;
        return tex;
      }

      /* ---------- World ---------- */
      _buildWorld(){
        this.ground = new THREE.Group();
        this.scene.add(this.ground);

        const grassMat = new THREE.MeshLambertMaterial({ map: this.textures.grass });
        const dirtMat  = new THREE.MeshLambertMaterial({ map: this.textures.dirt  });
        const stoneMat = new THREE.MeshLambertMaterial({ map: this.textures.stone });

        const unit = this.cellSize;
        const boxGeo = new THREE.BoxBufferGeometry(unit, unit, unit);

        for(let x=-2; x<this.gridSize+2; x++){
          for(let z=-2; z<this.gridSize+2; z++){
            const grass = new THREE.Mesh(boxGeo, grassMat);
            grass.position.set(x, -0.5, z);
            grass.receiveShadow = true;
            this.ground.add(grass);

            const dirt = new THREE.Mesh(boxGeo, dirtMat);
            dirt.position.set(x, -1.5, z);
            dirt.receiveShadow = true;
            this.ground.add(dirt);
          }
        }

        // Walls (hidden when wrapWalls is on)
        this.wallsGroup = new THREE.Group();
        this.scene.add(this.wallsGroup);
        for(let i=-1; i<=this.gridSize; i++){
          for(let h=0; h<3; h++){
            const w1 = new THREE.Mesh(boxGeo, stoneMat); w1.position.set(i, h, -1); w1.castShadow=true; this.wallsGroup.add(w1);
            const w2 = new THREE.Mesh(boxGeo, stoneMat); w2.position.set(i, h, this.gridSize); w2.castShadow=true; this.wallsGroup.add(w2);
            const w3 = new THREE.Mesh(boxGeo, stoneMat); w3.position.set(-1, h, i); w3.castShadow=true; this.wallsGroup.add(w3);
            const w4 = new THREE.Mesh(boxGeo, stoneMat); w4.position.set(this.gridSize, h, i); w4.castShadow=true; this.wallsGroup.add(w4);
          }
        }

        // Ground click plane
        const planeGeo = new THREE.PlaneBufferGeometry(this.gridSize, this.gridSize);
        this.clickPlane = new THREE.Mesh(
          planeGeo,
          new THREE.MeshBasicMaterial({ map: this.textures.grid, transparent:true, opacity:0.12, depthWrite:false })
        );
        this.clickPlane.rotation.x = -Math.PI/2;
        this.clickPlane.position.set((this.gridSize-1)/2, -0.49, (this.gridSize-1)/2);
        this.clickPlane.userData.clickable = true;
        this.scene.add(this.clickPlane);
      }

      /* ---------- Worm ---------- */
      _buildWorm(){
        this.wormGroup = new THREE.Group();
        this.scene.add(this.wormGroup);

        const bodyMat = new THREE.MeshLambertMaterial({ map: this.textures.wormBody });
        const headMat = new THREE.MeshLambertMaterial({ map: this.textures.wormHead });
        const segGeo  = new THREE.BoxBufferGeometry(0.9, 0.9, 0.9);

        this.headMesh = new THREE.Mesh(segGeo, headMat);
        this.headMesh.castShadow = true;
        this.wormGroup.add(this.headMesh);

        this.bodyPool  = [];
        this.activeBody= [];

        for(let i=0;i<this.gridSize*3;i++){
          const m = new THREE.Mesh(segGeo, bodyMat);
          m.castShadow = true; m.visible = false;
          this.wormGroup.add(m);
          this.bodyPool.push(m);
        }
        this._syncWormVisuals(true);
      }
      _syncWormVisuals(reset=false){
        const head = this.worm[0];
        this.headMesh.position.set(head.x, head.y, head.z);

        if(reset){
          this.activeBody.forEach(m => m.visible=false);
          this.activeBody.length = 0;
        }
        const needed = Math.max(0, this.worm.length - 1);
        while(this.activeBody.length < needed){
          const m = this.bodyPool.pop();
          if(!m) break;
          m.visible = true;
          this.activeBody.push(m);
        }
        while(this.activeBody.length > needed){
          const m = this.activeBody.pop();
          m.visible = false;
          this.bodyPool.push(m);
        }
        for(let i=1;i<this.worm.length;i++){
          const seg = this.worm[i];
          this.activeBody[i-1].position.set(seg.x, seg.y, seg.z);
        }
      }

      /* ---------- Food ---------- */
      _buildFood(){
        if(this.foodGroup) this.scene.remove(this.foodGroup);
        this.foodGroup = new THREE.Group();
        this.scene.add(this.foodGroup);

        const geo = new THREE.BoxBufferGeometry(0.8, 0.8, 0.8);
        const mat = new THREE.MeshLambertMaterial({ map: this.textures.food, emissive: 0x662b00, emissiveIntensity: 0.2 });
        this.foodMesh = new THREE.Mesh(geo, mat);
        this.foodMesh.castShadow = true;
        this.foodGroup.add(this.foodMesh);

        this.foodLight = new THREE.PointLight(0xff6a00, 0.65, 10);
        this.foodLight.position.set(this.food.x, this.food.y + 1.2, this.food.z);
        this.foodGroup.add(this.foodLight);

        this._syncFoodVisuals();
      }
      _syncFoodVisuals(){
        this.foodMesh.position.set(this.food.x, this.food.y + 0.15, this.food.z);
        this.foodLight.position.set(this.food.x, this.food.y + 1.2, this.food.z);
      }

      /* ---------- Path Preview ---------- */
      _buildPathPreview(){
        const mat = new THREE.LineBasicMaterial({ color:0x25f0d2, transparent:true, opacity:0.65 });
        this.pathGeom = new THREE.BufferGeometry();
        this.pathLine = new THREE.Line(this.pathGeom, mat);
        this.pathLine.frustumCulled = false;
        this.scene.add(this.pathLine);
      }
      _updatePathPreview(){
        if(!this.showPath || !this.currentPath || this.currentPath.length <= 1){
          this.pathLine.visible = false;
          return;
        }
        const pts = [];
        for(const p of this.currentPath){ pts.push(p.x, 0.55, p.z); }
        const arr = new Float32Array(pts);
        this.pathGeom.setAttribute("position", new THREE.BufferAttribute(arr, 3));
        this.pathGeom.computeBoundingSphere();
        this.pathLine.visible = true;
      }

      /* ---------- Particles ---------- */
      _buildParticles(){
        this.particles = [];
        this.particlePool = [];
        const geo = new THREE.BoxBufferGeometry(0.15, 0.15, 0.15);
        const mat = new THREE.MeshLambertMaterial({ color: 0xffa566 });
        for(let i=0;i<120;i++){
          const m = new THREE.Mesh(geo, mat);
          m.visible = false; m.castShadow = false; m.receiveShadow = false;
          m.userData = { life:0, vel: new THREE.Vector3() };
          this.scene.add(m);
          this.particlePool.push(m);
        }
      }
      _emitParticles(x,y,z,count=18){
        for(let i=0;i<count;i++){
          const p = this.particlePool.pop();
          if(!p) break;
          p.visible = true;
          p.position.set(x,y,z);
          p.userData.life = 0.7 + Math.random()*0.4;
          const ang = Math.random()*Math.PI*2;
          const up  = 0.7 + Math.random()*0.7;
          const sp  = 0.5 + Math.random()*0.9;
          p.userData.vel.set(Math.cos(ang)*sp, up, Math.sin(ang)*sp);
          this.particles.push(p);
        }
      }
      _updateParticles(dt){
        for(let i=this.particles.length-1; i>=0; i--){
          const p = this.particles[i];
          p.userData.life -= dt;
          p.position.addScaledVector(p.userData.vel, dt);
          p.userData.vel.y -= 1.5*dt;
          if(p.userData.life <= 0){
            p.visible = false;
            this.particles.splice(i,1);
            this.particlePool.push(p);
          }
        }
      }

      /* ---------- Audio ---------- */
      _initAudio(){
        try{
          this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }catch(e){
          this.audioCtx = null;
        }
      }
      _playTone(freq=440, dur=0.08, type='square', gain=0.03){
        if(!this.audioCtx) return;
        if(this.dom && this.dom.mute.checked) return;
        const ctx=this.audioCtx;
        const osc=ctx.createOscillator();
        const g  =ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        g.gain.value = gain;
        osc.connect(g).connect(ctx.destination);
        const t0 = ctx.currentTime;
        osc.start(t0);
        g.gain.setValueAtTime(gain, t0);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        osc.stop(t0 + dur);
      }
      _playEat(){ this._playTone(740, 0.07, 'square', 0.03); }
      _playGameOver(){
        this._playTone(260, 0.18, 'sawtooth', 0.04);
        setTimeout(()=>this._playTone(200, 0.22, 'sawtooth', 0.035), 120);
      }

      /* ---------- UI & Input ---------- */
      _setupUI(){
        this.dom = {
          score: document.getElementById("score"),
          length: document.getElementById("length"),
          high: document.getElementById("highScore"),
          time: document.getElementById("time"),
          fps: document.getElementById("fps"),
          speed: document.getElementById("speed"),
          speedLabel: document.getElementById("speedLabel"),
          wrapWalls: document.getElementById("wrapWalls"),
          autoFood: document.getElementById("autoFood"),
          showPath: document.getElementById("showPath"),
          mute: document.getElementById("mute"),
          btnPause: document.getElementById("btnPause"),
          btnRestart: document.getElementById("btnRestart"),
          welcome: document.getElementById("welcome"),
          gameOver: document.getElementById("gameOver"),
          finalScore: document.getElementById("finalScore"),
          finalLength: document.getElementById("finalLength"),
          finalTime: document.getElementById("finalTime"),
          btnStart: document.getElementById("btnStart"),
          btnStartFast: document.getElementById("btnStartFast"),
          btnPlayAgain: document.getElementById("btnPlayAgain"),
          btnClose: document.getElementById("btnClose"),
        };
        this.dom.high.textContent = this.highScore;

        const speedIntervals = { slow:0.30, normal:0.22, fast:0.16, insane:0.10 };
        const setSpeed = (mode) => {
          this.speedMode = mode;
          this.baseInterval = speedIntervals[mode] || 0.22;
          this.dom.speedLabel.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
        };
        this.dom.speed.addEventListener("change", (e)=> setSpeed(e.target.value));
        setSpeed(this.speedMode);

        this.dom.wrapWalls.addEventListener("change", (e)=>{
          this.wrapWalls = !!e.target.checked;
          this.wallsGroup.visible = !this.wrapWalls;
        });
        this.dom.autoFood.addEventListener("change", (e)=>{ this.autoFood = !!e.target.checked; });
        this.dom.showPath.addEventListener("change", (e)=>{ this.showPath = !!e.target.checked; this._updatePathPreview(); });

        this.dom.btnPause.addEventListener("click", ()=> this._togglePause());
        this.dom.btnRestart.addEventListener("click", ()=> this._restart());

        this.dom.btnStart.addEventListener("click", async ()=>{
          this.dom.welcome.style.display = "none";
          try{ await this.audioCtx?.resume?.(); }catch{}
          this._startGame();
        });
        this.dom.btnStartFast.addEventListener("click", async ()=>{
          this.dom.welcome.style.display = "none";
          this.dom.speed.value = "fast";
          this.dom.speed.dispatchEvent(new Event("change"));
          try{ await this.audioCtx?.resume?.(); }catch{}
          this._startGame();
        });
        this.dom.btnPlayAgain.addEventListener("click", ()=>{
          this.dom.gameOver.style.display = "none";
          this._restart(true);
          this._startGame();
        });
        this.dom.btnClose.addEventListener("click", ()=>{
          this.dom.gameOver.style.display = "none";
        });
      }

      _setupInput(){
        // Keyboard
        window.addEventListener("keydown", (e)=>{
          const code = e.code;
          if(code === "KeyR"){ this._restart(); return; }
          if(code === "Space"){ this._togglePause(); return; }
          if(code === "KeyF"){ this.followCam = !this.followCam; return; }
          if(!this.gameRunning || this.gamePaused) return;
          if(code === "ArrowUp" || code === "KeyW") this._moveFood(this.food.x, this.food.z - 1);
          if(code === "ArrowDown"|| code === "KeyS") this._moveFood(this.food.x, this.food.z + 1);
          if(code === "ArrowLeft"|| code === "KeyA") this._moveFood(this.food.x - 1, this.food.z);
          if(code === "ArrowRight"|| code === "KeyD") this._moveFood(this.food.x + 1, this.food.z);
        });

        // Mouse/touch orbit + click-to-place food
        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();
        let dragging=false, panning=false, lastX=0, lastY=0;
        const onDown = (clientX, clientY, isShift)=>{
          if(!this.gameRunning) return;
          dragging = true; panning = isShift;
          lastX = clientX; lastY = clientY;
        };
        const onMove = (clientX, clientY)=>{
          if(!dragging) return;
          const dx = clientX - lastX;
          const dy = clientY - lastY;
          lastX = clientX; lastY = clientY;
          if(panning){
            const panSpeed = 0.02 * (this.spherical.radius / 18);
            const right = new THREE.Vector3().subVectors(this.camera.position, this.camTarget).cross(this.camera.up).normalize().multiplyScalar(-1);
            const up = new THREE.Vector3(0,1,0);
            this.camTarget.addScaledVector(right, dx*panSpeed);
            this.camTarget.addScaledVector(up, dy*panSpeed);
          }else{
            const rotSpeed = 0.005;
            this.spherical.theta -= dx * rotSpeed;
            const newPhi = this.spherical.phi - dy * rotSpeed;
            this.spherical.phi = THREE.MathUtils.clamp(newPhi, 0.12, Math.PI/2.2);
          }
          this._applyCamera();
        };
        const onUp = (clientX, clientY, clickLike)=>{
          dragging=false; panning=false;
          if(!clickLike) return;
          this.pointer.x = (clientX / window.innerWidth) * 2 - 1;
          this.pointer.y = -(clientY / window.innerHeight) * 2 + 1;
          this.raycaster.setFromCamera(this.pointer, this.camera);
          const intersects = this.raycaster.intersectObject(this.clickPlane);
          if(intersects.length){
            const p = intersects[0].point;
            const gx = Math.round(p.x);
            const gz = Math.round(p.z);
            this._moveFood(gx, gz);
          }
        };
        const clickThresholdSq = 8*8;
        let downX=0, downY=0;

        this.renderer.domElement.addEventListener("mousedown", (e)=>{
          downX=e.clientX; downY=e.clientY;
          onDown(e.clientX, e.clientY, e.shiftKey);
        });
        window.addEventListener("mousemove", (e)=> onMove(e.clientX, e.clientY));
        window.addEventListener("mouseup", (e)=>{
          const dx = e.clientX - downX, dy = e.clientY - downY;
          const clickLike = (dx*dx + dy*dy) < clickThresholdSq;
          onUp(e.clientX, e.clientY, clickLike);
        });
        this.renderer.domElement.addEventListener("wheel", (e)=>{
          const delta = Math.sign(e.deltaY);
          this.spherical.radius = THREE.MathUtils.clamp(this.spherical.radius + delta*2.0, 10, 80);
          this._applyCamera();
        }, { passive:true });

        // Touch
        this.renderer.domElement.addEventListener("touchstart", (e)=>{
          if(e.touches.length === 1){
            const t=e.touches[0];
            downX=t.clientX; downY=t.clientY;
            onDown(t.clientX, t.clientY, false);
          }
          if(e.touches.length === 2){
            const midX=(e.touches[0].clientX + e.touches[1].clientX)*0.5;
            const midY=(e.touches[0].clientY + e.touches[1].clientY)*0.5;
            onDown(midX, midY, true);
          }
        }, { passive:true });
        this.renderer.domElement.addEventListener("touchmove", (e)=>{
          if(e.touches.length === 1){
            const t=e.touches[0];
            onMove(t.clientX, t.clientY);
          }
          if(e.touches.length === 2){
            const midX=(e.touches[0].clientX + e.touches[1].clientX)*0.5;
            const midY=(e.touches[0].clientY + e.touches[1].clientY)*0.5;
            onMove(midX, midY);
          }
        }, { passive:true });
        this.renderer.domElement.addEventListener("touchend", (e)=>{
          const touch=e.changedTouches[0];
          const dx=touch.clientX - downX;
          const dy=touch.clientY - downY;
          const clickLike=(dx*dx + dy*dy) < clickThresholdSq;
          onUp(touch.clientX, touch.clientY, clickLike);
        });
      }

      /* ---------- Game Loop ---------- */
      _loop(){
        const dt = this.clock.getDelta();
        const now = this.clock.elapsedTime;

        // FPS
        this._fpsAccum = (this._fpsAccum || 0) + dt;
        this._fpsCount = (this._fpsCount || 0) + 1;
        if(this._fpsAccum >= 0.5){
          this.fps = Math.round(this._fpsCount / this._fpsAccum);
          this._fpsAccum = 0; this._fpsCount = 0;
          if(this.dom) this.dom.fps.textContent = this.fps;
        }

        // Food animation
        if(this.foodMesh){
          const t = now*4;
          this.foodMesh.rotation.y += 0.02;
          this.foodMesh.position.y = 0.15 + Math.sin(t)*0.08;
          if(this.foodLight){
            this.foodLight.intensity = 0.55 + Math.sin(t*0.6)*0.12;
          }
        }

        // Follow camera
        if(this.followCam && this.worm && this.worm.length){
          const head = this.worm[0];
          const target = new THREE.Vector3(head.x, 0, head.z);
          this.camTarget.lerp(target, 0.12);
          this._applyCamera();
        }

        // Particles
        this._updateParticles(dt);

        // Step movement
        if(this.gameRunning && !this.gamePaused){
          this.accum += dt;
          const interval = Math.max(0.06, this.baseInterval * Math.pow(0.97, Math.max(0, this.worm.length - 3)));
          if(this.accum >= interval){
            this.accum -= interval;
            this._step();
          }
          const sec = Math.floor((Date.now() - this.startTime) / 1000);
          if(this.dom) this.dom.time.textContent = `${sec}s`;
        }

        // Path line
        this._updatePathPreview();

        // Render
        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame(()=> this._loop());
      }

      /* ---------- Mechanics ---------- */
      _inBounds(x,z){ return x>=0 && x<this.gridSize && z>=0 && z<this.gridSize; }
      _wrap(x,z){
        if(!this.wrapWalls) return { x, z };
        return { x: (x + this.gridSize) % this.gridSize, z: (z + this.gridSize) % this.gridSize };
      }
      _moveFood(nx,nz){
        const p = this._wrap(nx,nz);
        if(!this.wrapWalls && !this._inBounds(nx,nz)) return;
        this.food.x = p.x; this.food.z = p.z;
        this._syncFoodVisuals();
        this._planPath();
      }
      _occupiedSet(excludeTail=true){
        const set = new Set();
        for(let i=0;i<this.worm.length;i++){
          if(excludeTail && i === this.worm.length-1) continue;
          const seg = this.worm[i];
          set.add(`${seg.x},${seg.z}`);
        }
        return set;
      }
      _planPath(){
        const start = this.worm[0];
        const goal = this.food;
        const occ = this._occupiedSet(true);
        const path = this._aStar(start, goal, occ);
        this.currentPath = path || [];
        this.noPathStreak = path ? 0 : (this.noPathStreak + 1);
      }
      _nextStepFromPath(){
        if(!this.currentPath || this.currentPath.length < 2) return null;
        return this.currentPath[1];
      }
      _safeNeighbors(x,z,occ){
        const dirs = [{x:1,z:0},{x:-1,z:0},{x:0,z:1},{x:0,z:-1}];
        const nbs=[];
        for(const d of dirs){
          let nx=x+d.x, nz=z+d.z;
          if(this.wrapWalls){ const p=this._wrap(nx,nz); nx=p.x; nz=p.z; }
          else if(!this._inBounds(nx,nz)) continue;
          if(!occ.has(`${nx},${nz}`)) nbs.push({x:nx, z:nz});
        }
        return nbs;
      }
      _aStar(start, goal, occ){
        const key = p => `${p.x},${p.z}`;
        const h   = (a,b)=> Math.abs(a.x-b.x) + Math.abs(a.z-b.z);
        const startK=key(start), goalK=key(goal);
        const open = new Map(); open.set(startK, h(start,goal));
        const gScore = new Map(); gScore.set(startK, 0);
        const came = new Map();
        while(open.size){
          let currentK=null, currentF=Infinity;
          for(const [k,f] of open){ if(f<currentF){ currentF=f; currentK=k; } }
          if(!currentK) break;
          const [cx,cz] = currentK.split(",").map(Number);
          const current = { x:cx, z:cz };
          if(currentK === goalK){
            const path = [current]; let ck=currentK;
            while(came.has(ck)){ ck=came.get(ck); const [px,pz]=ck.split(",").map(Number); path.push({x:px,z:pz}); }
            path.reverse(); return path;
          }
          open.delete(currentK);
          const dirs = [{x:1,z:0},{x:-1,z:0},{x:0,z:1},{x:0,z:-1}];
          for(const d of dirs){
            let nx=current.x+d.x, nz=current.z+d.z;
            if(this.wrapWalls){ const p=this._wrap(nx,nz); nx=p.x; nz=p.z; }
            else if(!this._inBounds(nx,nz)) continue;
            const nk = `${nx},${nz}`;
            if(occ.has(nk) && nk !== goalK) continue;
            const tentativeG = (gScore.get(currentK) ?? Infinity) + 1;
            const nG = gScore.get(nk);
            if(tentativeG < (nG ?? Infinity)){
              came.set(nk, currentK);
              gScore.set(nk, tentativeG);
              open.set(nk, tentativeG + h({x:nx,z:nz}, goal));
            }
          }
        }
        return null;
      }

      _step(){
        this._planPath();
        let next = this._nextStepFromPath();
        const head = this.worm[0];

        if(!next){
          const occ = this._occupiedSet(true);
          const nbs = this._safeNeighbors(head.x, head.z, occ);
          if(nbs.length === 0){ this._gameOver(); return; }
          nbs.sort((a,b)=>{
            const da = Math.abs(a.x - this.food.x)+Math.abs(a.z - this.food.z);
            const db = Math.abs(b.x - this.food.x)+Math.abs(b.z - this.food.z);
            return da - db;
          });
          next = nbs[0];
        }

        const newHead = { x: next.x, y: 0, z: next.z };
        this.worm.unshift(newHead);

        let grew = false;
        if(newHead.x === this.food.x && newHead.z === this.food.z){
          grew = true;
          this.score++;
          this._emitParticles(newHead.x, 0.4, newHead.z, 24);
          this._playEat();

          if(this.autoFood) this._spawnRandomFood();
          this._syncFoodVisuals();
        }
        if(!grew){ this.worm.pop(); }

        if(!this.wrapWalls && !this._inBounds(newHead.x, newHead.z)){ this._gameOver(); return; }
        for(let i=1;i<this.worm.length;i++){
          if(this.worm[i].x === newHead.x && this.worm[i].z === newHead.z){ this._gameOver(); return; }
        }

        this._syncWormVisuals();
        this._updateUI();
      }

      _spawnRandomFood(){
        const occ = this._occupiedSet(false);
        for(let tries=0; tries<500; tries++){
          const x = (Math.random()*this.gridSize)|0;
          const z = (Math.random()*this.gridSize)|0;
          if(!occ.has(`${x},${z}`)){ this.food.x=x; this.food.z=z; return; }
        }
        this.food.x = Math.floor(this.gridSize/2);
        this.food.z = Math.floor(this.gridSize/2);
      }

      _startGame(){
        if(this.gameRunning) return;
        this.gamePaused = false;
        this.gameRunning = true;
        this.startTime = Date.now();
        this.accum = 0;
        this._updateUI();
        this._planPath();
      }
      _togglePause(){
        if(!this.gameRunning) return;
        this.gamePaused = !this.gamePaused;
        this.dom.btnPause.textContent = this.gamePaused ? "Resume" : "Pause";
      }
      _restart(hideWelcome=false){
        this.score = 0;
        this.gameRunning = false;
        this.gamePaused = false;
        this.accum = 0;
        this.currentPath = [];
        this.worm = [
          { x: 5, y: 0, z: 10 },
          { x: 4, y: 0, z: 10 },
          { x: 3, y: 0, z: 10 },
        ];
        this.food = { x: Math.floor(this.gridSize/2), y: 0, z: Math.floor(this.gridSize/2) };
        this._syncWormVisuals(true);
        this._syncFoodVisuals();
        this._updateUI();
        if(!hideWelcome){ this.dom.welcome.style.display = "block"; }
      }
      _updateUI(){
        this.dom.score.textContent = this.score;
        this.dom.length.textContent = this.worm.length;
        this.dom.high.textContent = this.highScore;
      }
      _gameOver(){
        this.gameRunning = false;
        this.gamePaused = false;
        if(this.score > this.highScore){
          this.highScore = this.score;
          localStorage.setItem("proWormHighScore", String(this.highScore));
        }
        const totalSec = Math.floor((Date.now() - this.startTime) / 1000);
        this.dom.finalScore.textContent  = this.score;
        this.dom.finalLength.textContent = this.worm.length;
        this.dom.finalTime.textContent   = `${totalSec}s`;
        this.dom.gameOver.style.display  = "block";
        this._playGameOver();
        this._updateUI();
      }
    }

    // Start the game instance
    window.proWorm = new ProWormGame();
  })();
  </script>
</body>
