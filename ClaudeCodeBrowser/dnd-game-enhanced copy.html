<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronicles of the Fallen Kingdom - 3D Enhanced Edition</title>
    <style>
        :root {
            --primary: #7c3aed;
            --secondary: #d97706;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #dc2626;
            --dark: #1e1b4b;
            --gold: #fbbf24;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: #0a0a0f;
            color: #e5e7eb;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Three.js Canvas */
        #world-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }

        /* Game UI Overlay */
        .game-overlay {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            pointer-events: none;
        }

        .game-overlay > * {
            pointer-events: auto;
        }

        /* Header */
        .game-header {
            text-align: center;
            padding: 1.5rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.5) 80%, transparent 100%);
        }

        .game-title {
            font-size: 2.5rem;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(251,191,36,0.5);
            margin-bottom: 0.25rem;
        }

        .game-subtitle {
            font-size: 1rem;
            color: #9ca3af;
            font-style: italic;
        }

        /* Main Layout */
        .game-layout {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 1rem;
            padding: 1rem;
            min-height: calc(100vh - 100px);
        }

        @media (max-width: 1200px) {
            .game-layout { grid-template-columns: 1fr; }
        }

        /* Panels */
        .panel {
            background: rgba(0,0,0,0.85);
            border-radius: 12px;
            padding: 1rem;
            border: 2px solid rgba(124,58,237,0.5);
            backdrop-filter: blur(10px);
        }

        .panel-title {
            color: var(--gold);
            font-size: 1.1rem;
            text-align: center;
            border-bottom: 2px solid var(--gold);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        /* Party Panel with Emoji Characters */
        .character-card {
            background: linear-gradient(135deg, rgba(124,58,237,0.3) 0%, rgba(0,0,0,0.5) 100%);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border: 2px solid var(--primary);
            cursor: pointer;
            transition: all 0.3s;
            display: grid;
            grid-template-columns: 50px 1fr;
            gap: 0.75rem;
            align-items: center;
        }

        .character-card:hover {
            transform: translateX(5px);
            border-color: var(--gold);
        }

        .character-card.selected {
            border-color: var(--gold);
            box-shadow: 0 0 15px rgba(251,191,36,0.4);
        }

        .char-emoji {
            font-size: 2.5rem;
            text-align: center;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.3));
        }

        .char-info { }

        .char-name {
            font-size: 0.95rem;
            color: var(--gold);
            font-weight: bold;
        }

        .char-class {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 0.5rem;
        }

        .hp-bar-container {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #ef4444);
            transition: width 0.5s;
        }

        .hp-text {
            font-size: 0.7rem;
            color: #aaa;
            margin-top: 0.25rem;
        }

        /* Story Panel */
        .story-panel {
            min-height: 500px;
            display: flex;
            flex-direction: column;
        }

        .location-display {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid rgba(251,191,36,0.3);
        }

        .location-emoji {
            font-size: 2.5rem;
        }

        .location-info h3 {
            color: var(--gold);
            font-size: 1.1rem;
        }

        .location-info p {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        .scene-visual {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 1.5rem;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            margin-bottom: 1rem;
            min-height: 120px;
            flex-wrap: wrap;
        }

        .scene-entity {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .scene-entity.friendly {
            background: rgba(16,185,129,0.2);
            border: 2px solid rgba(16,185,129,0.5);
        }

        .scene-entity.enemy {
            background: rgba(220,38,38,0.2);
            border: 2px solid rgba(220,38,38,0.5);
        }

        .scene-entity.neutral {
            background: rgba(251,191,36,0.2);
            border: 2px solid rgba(251,191,36,0.5);
        }

        .entity-emoji {
            font-size: 3rem;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .entity-name {
            font-size: 0.75rem;
            color: #ccc;
            margin-top: 0.25rem;
        }

        .story-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
            margin-bottom: 1rem;
        }

        .story-text {
            font-size: 1rem;
            line-height: 1.8;
            margin-bottom: 1rem;
            text-align: justify;
        }

        .dialogue {
            background: rgba(124,58,237,0.2);
            border-left: 4px solid var(--primary);
            padding: 0.75rem 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .dialogue-speaker {
            color: var(--gold);
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        /* Choices */
        .choices-container {
            display: grid;
            gap: 0.5rem;
        }

        .choice-btn {
            background: linear-gradient(135deg, rgba(124,58,237,0.4) 0%, rgba(0,0,0,0.6) 100%);
            border: 2px solid var(--primary);
            color: #e5e7eb;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s;
            text-align: left;
            font-family: 'Georgia', serif;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .choice-btn:hover {
            background: linear-gradient(135deg, rgba(251,191,36,0.4) 0%, rgba(0,0,0,0.6) 100%);
            border-color: var(--gold);
            transform: translateX(5px);
        }

        .choice-emoji {
            font-size: 1.5rem;
            min-width: 40px;
            text-align: center;
        }

        .choice-btn.combat { border-color: var(--danger); }
        .choice-btn.skill { border-color: var(--warning); }

        /* Info Panel */
        .quest-item {
            padding: 0.5rem;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border-left: 3px solid var(--warning);
            font-size: 0.85rem;
        }

        .resources-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .resource-emoji { font-size: 1.2rem; }
        .resource-value { color: var(--gold); font-weight: bold; }

        /* Inventory */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .inv-slot {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.05);
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .inv-slot:hover {
            border-color: var(--gold);
            transform: scale(1.1);
        }

        .inv-slot.legendary { border-color: var(--warning); background: rgba(251,191,36,0.1); }
        .inv-slot.rare { border-color: var(--primary); }

        .inv-count {
            position: absolute;
            bottom: 2px; right: 4px;
            font-size: 0.6rem;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 0 3px;
            border-radius: 3px;
        }

        /* Battle Arena (Three.js overlay) */
        #battle-arena {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 100;
            display: none;
        }

        #battle-arena.active { display: block; }

        #battle-canvas {
            width: 100%; height: 100%;
        }

        .battle-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            padding: 1.5rem;
            background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.7) 80%, transparent 100%);
        }

        .battle-header {
            position: absolute;
            top: 0; left: 0; right: 0;
            padding: 1rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            text-align: center;
        }

        .battle-title {
            font-size: 2rem;
            color: #ff4444;
            text-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .combatants-row {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .combatant-card {
            background: rgba(0,0,0,0.8);
            border: 3px solid #444;
            border-radius: 8px;
            padding: 0.75rem;
            min-width: 140px;
            text-align: center;
        }

        .combatant-card.ally { border-color: var(--primary); }
        .combatant-card.enemy { border-color: var(--danger); }
        .combatant-card.active { border-color: var(--gold); box-shadow: 0 0 20px rgba(251,191,36,0.5); }

        .combatant-emoji { font-size: 2rem; }
        .combatant-name { font-size: 0.8rem; color: #ccc; margin-top: 0.25rem; }
        .combatant-hp { font-size: 0.75rem; color: #ef4444; }

        .battle-actions {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .action-btn {
            background: linear-gradient(135deg, var(--primary) 0%, #6d28d9 100%);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(124,58,237,0.5);
        }

        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .action-btn.attack { background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); }
        .action-btn.heal { background: linear-gradient(135deg, #10b981 0%, #047857 100%); }
        .action-btn.magic { background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); }

        .battle-log {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0,0,0,0.6);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .log-entry.damage { color: #fca5a5; }
        .log-entry.heal { color: #6ee7b7; }
        .log-entry.miss { color: #9ca3af; }

        /* Dice Roller */
        .dice-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .dice-overlay.active { display: flex; }

        .dice-modal {
            background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
            padding: 3rem;
            border-radius: 20px;
            border: 3px solid var(--gold);
            text-align: center;
            box-shadow: 0 0 50px rgba(251,191,36,0.3);
        }

        .dice-emoji {
            font-size: 8rem;
            animation: diceRoll 0.5s ease-out;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(0.5); }
            50% { transform: rotate(360deg) scale(1.2); }
            100% { transform: rotate(720deg) scale(1); }
        }

        .dice-result {
            font-size: 3rem;
            color: var(--gold);
            margin: 1rem 0;
        }

        .dice-outcome {
            font-size: 1.5rem;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-weight: bold;
        }

        .dice-outcome.success { background: var(--success); color: white; }
        .dice-outcome.failure { background: var(--danger); color: white; }

        /* World Map (minimap) */
        .world-map {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a15 100%);
            border: 2px solid var(--primary);
            border-radius: 8px;
            margin-bottom: 1rem;
            position: relative;
            overflow: hidden;
        }

        .map-icon {
            position: absolute;
            font-size: 1.2rem;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.2s;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
        }

        .map-icon:hover { transform: translate(-50%, -50%) scale(1.3); }
        .map-icon.current { animation: mapPulse 1.5s infinite; }

        @keyframes mapPulse {
            0%, 100% { filter: drop-shadow(0 0 5px var(--gold)); }
            50% { filter: drop-shadow(0 0 15px var(--gold)); }
        }

        .map-path {
            position: absolute;
            background: rgba(251,191,36,0.3);
            height: 2px;
            transform-origin: left center;
        }

        /* Save/Load */
        .save-menu {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .save-menu button {
            flex: 1;
            padding: 0.5rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn-save { background: var(--success); color: white; }
        .btn-load { background: var(--primary); color: white; }
        .btn-reset { background: var(--danger); color: white; }
    </style>
</head>
<body>
    <!-- Three.js World Canvas -->
    <canvas id="world-canvas"></canvas>

    <!-- Battle Arena (3D) -->
    <div id="battle-arena">
        <canvas id="battle-canvas"></canvas>
        <div class="battle-header">
            <h2 class="battle-title" id="battle-title">COMBAT!</h2>
        </div>
        <div class="battle-ui">
            <div class="combatants-row" id="combatants-display"></div>
            <div class="battle-actions" id="battle-actions"></div>
            <div class="battle-log" id="battle-log"></div>
        </div>
    </div>

    <!-- Dice Roller -->
    <div class="dice-overlay" id="dice-overlay">
        <div class="dice-modal">
            <div class="dice-emoji" id="dice-emoji">üé≤</div>
            <div class="dice-result" id="dice-result"></div>
            <div class="dice-outcome" id="dice-outcome"></div>
        </div>
    </div>

    <!-- Game UI Overlay -->
    <div class="game-overlay">
        <div class="game-header">
            <h1 class="game-title">Chronicles of the Fallen Kingdom</h1>
            <p class="game-subtitle">"When the crimson moon rises, the ancient seal shall break..."</p>
        </div>

        <div class="game-layout">
            <!-- Left Panel: Party -->
            <div class="panel" id="party-panel">
                <h2 class="panel-title">Your Party</h2>
                <div id="party-container"></div>
                <div class="save-menu">
                    <button class="btn-save" onclick="game.save()">Save</button>
                    <button class="btn-load" onclick="game.load()">Load</button>
                    <button class="btn-reset" onclick="game.reset()">Reset</button>
                </div>
            </div>

            <!-- Center Panel: Story -->
            <div class="panel story-panel" id="story-panel">
                <div class="location-display" id="location-display"></div>
                <div class="scene-visual" id="scene-visual"></div>
                <div class="story-content" id="story-content"></div>
                <div class="choices-container" id="choices-container"></div>
            </div>

            <!-- Right Panel: Info -->
            <div class="panel" id="info-panel">
                <div class="world-map" id="world-map"></div>
                <h2 class="panel-title">Quest Log</h2>
                <div id="quest-tracker"></div>
                <h2 class="panel-title">Resources</h2>
                <div class="resources-grid" id="resources-display"></div>
                <h2 class="panel-title">Inventory</h2>
                <div class="inventory-grid" id="inventory-grid"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // ============================================================================
    // EMOJI DEFINITIONS
    // ============================================================================
    const EMOJIS = {
        // Characters
        fighter: 'üó°Ô∏è',
        wizard: 'üßô',
        ranger: 'üèπ',
        cleric: '‚öïÔ∏è',
        knight: 'üõ°Ô∏è',
        rogue: 'üóùÔ∏è',

        // Enemies
        skeleton: 'üíÄ',
        zombie: 'üßü',
        ghost: 'üëª',
        dragon: 'üêâ',
        demon: 'üëπ',
        lich: '‚ò†Ô∏è',
        orc: 'üë∫',
        spider: 'üï∑Ô∏è',
        wolf: 'üê∫',
        golem: 'üóø',
        cultist: 'üé≠',
        wraith: 'üë§',

        // NPCs
        king: 'üëë',
        queen: 'üë∏',
        merchant: 'üßî',
        sage: 'üìö',
        captain: '‚öîÔ∏è',
        oracle: 'üîÆ',
        blacksmith: 'üî®',
        innkeeper: 'üç∫',

        // Locations
        castle: 'üè∞',
        dungeon: 'üï≥Ô∏è',
        forest: 'üå≤',
        mountain: '‚õ∞Ô∏è',
        village: 'üèòÔ∏è',
        temple: '‚õ™',
        cave: 'üï≥Ô∏è',
        graveyard: 'ü™¶',
        tower: 'üóº',
        bridge: 'üåâ',
        ruins: 'üèöÔ∏è',
        lake: 'üåä',
        volcano: 'üåã',

        // Items
        sword: 'üó°Ô∏è',
        shield: 'üõ°Ô∏è',
        bow: 'üèπ',
        staff: 'ü™Ñ',
        potion: 'üß™',
        scroll: 'üìú',
        key: 'üîë',
        gem: 'üíé',
        gold: 'üí∞',
        chest: 'üì¶',
        ring: 'üíç',
        crown: 'üëë',
        orb: 'üîÆ',
        book: 'üìñ',

        // Effects
        fire: 'üî•',
        ice: '‚ùÑÔ∏è',
        lightning: '‚ö°',
        magic: '‚ú®',
        heal: 'üíö',
        poison: '‚ò†Ô∏è',
        sleep: 'üò¥',
        rage: 'üò°',

        // UI
        heart: '‚ù§Ô∏è',
        mana: 'üíô',
        xp: '‚≠ê',
        quest: 'üìã',
        map: 'üó∫Ô∏è',
        compass: 'üß≠',
        moon: 'üåô',
        sun: '‚òÄÔ∏è',
        dice: 'üé≤'
    };

    // ============================================================================
    // THREE.JS WORLD ENGINE
    // ============================================================================
    class WorldEngine {
        constructor() {
            this.canvas = document.getElementById('world-canvas');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x0a0a15, 1);

            this.particles = [];
            this.time = 0;

            this.init();
            this.animate();
        }

        init() {
            // Camera position
            this.camera.position.set(0, 20, 30);
            this.camera.lookAt(0, 0, 0);

            // Ambient light
            const ambient = new THREE.AmbientLight(0x404080, 0.5);
            this.scene.add(ambient);

            // Moonlight
            const moonLight = new THREE.DirectionalLight(0x8888ff, 0.8);
            moonLight.position.set(-10, 20, 10);
            this.scene.add(moonLight);

            // Ground plane with mist
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.2,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -5;
            this.scene.add(ground);

            // Fog
            this.scene.fog = new THREE.FogExp2(0x0a0a15, 0.02);

            // Stars
            this.createStars();

            // Floating particles
            this.createParticles();

            // Crimson moon
            this.createMoon();

            window.addEventListener('resize', () => this.onResize());
        }

        createStars() {
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for (let i = 0; i < 2000; i++) {
                starPos.push(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 50 + 10,
                    (Math.random() - 0.5) * 200
                );
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 });
            this.scene.add(new THREE.Points(starGeo, starMat));
        }

        createParticles() {
            const particleGeo = new THREE.BufferGeometry();
            const particlePos = [];
            for (let i = 0; i < 100; i++) {
                particlePos.push(
                    (Math.random() - 0.5) * 40,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 40
                );
                this.particles.push({
                    y: Math.random() * 10,
                    speed: 0.01 + Math.random() * 0.02
                });
            }
            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(particlePos, 3));
            const particleMat = new THREE.PointsMaterial({
                color: 0x7c3aed,
                size: 0.3,
                transparent: true,
                opacity: 0.6
            });
            this.particleSystem = new THREE.Points(particleGeo, particleMat);
            this.scene.add(this.particleSystem);
        }

        createMoon() {
            const moonGeo = new THREE.SphereGeometry(3, 32, 32);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0x880000 });
            this.moon = new THREE.Mesh(moonGeo, moonMat);
            this.moon.position.set(20, 30, -50);
            this.scene.add(this.moon);

            // Moon glow
            const glowGeo = new THREE.SphereGeometry(4, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            this.moon.add(glow);
        }

        setLocation(locationType) {
            // Adjust lighting and fog based on location
            const locations = {
                castle: { fog: 0x1a1a2e, intensity: 0.8 },
                dungeon: { fog: 0x050505, intensity: 0.3 },
                forest: { fog: 0x0a1a0a, intensity: 0.6 },
                graveyard: { fog: 0x0a0a15, intensity: 0.4 },
                mountain: { fog: 0x202030, intensity: 1.0 },
                temple: { fog: 0x1a1a30, intensity: 0.9 }
            };
            const loc = locations[locationType] || locations.castle;
            this.scene.fog.color.setHex(loc.fog);
        }

        animate() {
            requestAnimationFrame(() => this.animate());

            this.time += 0.01;

            // Rotate moon slowly
            if (this.moon) {
                this.moon.position.y = 30 + Math.sin(this.time * 0.2) * 2;
            }

            // Animate particles
            if (this.particleSystem) {
                const positions = this.particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < this.particles.length; i++) {
                    positions[i * 3 + 1] += this.particles[i].speed;
                    if (positions[i * 3 + 1] > 15) {
                        positions[i * 3 + 1] = 0;
                    }
                }
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            // Gentle camera sway
            this.camera.position.x = Math.sin(this.time * 0.3) * 2;
            this.camera.lookAt(0, 0, 0);

            this.renderer.render(this.scene, this.camera);
        }

        onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    // ============================================================================
    // BATTLE ENGINE (3D)
    // ============================================================================
    class BattleEngine {
        constructor() {
            this.active = false;
            this.canvas = document.getElementById('battle-canvas');
            this.arena = document.getElementById('battle-arena');
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.combatants = [];
            this.currentTurn = 0;
            this.playerTurn = true;
        }

        init() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x1a0a0a, 1);

            // Lighting
            const ambient = new THREE.AmbientLight(0x442222, 0.5);
            this.scene.add(ambient);

            const battleLight = new THREE.PointLight(0xff4444, 1, 50);
            battleLight.position.set(0, 10, 0);
            this.scene.add(battleLight);

            // Camera
            this.camera.position.set(0, 15, 20);
            this.camera.lookAt(0, 0, 0);

            // Arena floor
            const floorGeo = new THREE.CircleGeometry(15, 32);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x220000,
                metalness: 0.3,
                roughness: 0.7
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            this.scene.add(floor);

            // Fog
            this.scene.fog = new THREE.Fog(0x1a0a0a, 10, 40);
        }

        startBattle(enemies, party) {
            if (!this.scene) this.init();

            this.active = true;
            this.arena.classList.add('active');
            this.combatants = [];
            this.currentTurn = 0;

            // Clear old meshes
            while(this.scene.children.length > 3) {
                this.scene.remove(this.scene.children[this.scene.children.length - 1]);
            }

            // Add party members as 3D objects
            party.forEach((char, i) => {
                const mesh = this.createCombatantMesh(char, true);
                mesh.position.set(-8 + i * 4, 1, 8);
                this.scene.add(mesh);
                this.combatants.push({ ...char, mesh, isAlly: true, initiative: Math.random() * 20 + char.dex });
            });

            // Add enemies
            enemies.forEach((enemy, i) => {
                const mesh = this.createCombatantMesh(enemy, false);
                mesh.position.set(-6 + i * 4, 1, -8);
                this.scene.add(mesh);
                this.combatants.push({ ...enemy, mesh, isAlly: false, initiative: Math.random() * 20 });
            });

            // Sort by initiative
            this.combatants.sort((a, b) => b.initiative - a.initiative);

            this.renderBattleUI();
            this.animateBattle();
        }

        createCombatantMesh(entity, isAlly) {
            const color = isAlly ? 0x7c3aed : 0xdc2626;
            const geo = new THREE.CapsuleGeometry(0.8, 1.5, 4, 8);
            const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.3, roughness: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);

            // Add glow
            const glowGeo = new THREE.SphereGeometry(1.2, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2
            });
            mesh.add(new THREE.Mesh(glowGeo, glowMat));

            return mesh;
        }

        renderBattleUI() {
            const display = document.getElementById('combatants-display');
            display.innerHTML = this.combatants.map((c, i) => `
                <div class="combatant-card ${c.isAlly ? 'ally' : 'enemy'} ${i === this.currentTurn ? 'active' : ''} ${c.hp <= 0 ? 'dead' : ''}">
                    <div class="combatant-emoji">${c.emoji || (c.isAlly ? EMOJIS.knight : EMOJIS.skeleton)}</div>
                    <div class="combatant-name">${c.name}</div>
                    <div class="combatant-hp">${EMOJIS.heart} ${Math.max(0, c.hp)}/${c.maxHp}</div>
                </div>
            `).join('');

            const actions = document.getElementById('battle-actions');
            const current = this.combatants[this.currentTurn];

            if (current && current.isAlly && current.hp > 0) {
                actions.innerHTML = `
                    <button class="action-btn attack" onclick="battle.attack()">${EMOJIS.sword} Attack</button>
                    <button class="action-btn magic" onclick="battle.castSpell()">${EMOJIS.magic} Spell</button>
                    <button class="action-btn heal" onclick="battle.useItem()">${EMOJIS.potion} Item</button>
                    <button class="action-btn" onclick="battle.defend()">${EMOJIS.shield} Defend</button>
                `;
            } else {
                actions.innerHTML = '<p style="color:#888">Enemy turn...</p>';
            }
        }

        attack() {
            const attacker = this.combatants[this.currentTurn];
            const targets = this.combatants.filter(c => !c.isAlly && c.hp > 0);
            if (targets.length === 0) return this.endBattle(true);

            const target = targets[0];
            const roll = Math.floor(Math.random() * 20) + 1;
            const damage = roll >= 10 ? Math.floor(Math.random() * 12) + 5 : 0;

            this.animateAttack(attacker.mesh, target.mesh);

            target.hp -= damage;
            this.logBattle(damage > 0
                ? `${attacker.name} hits ${target.name} for ${damage} damage!`
                : `${attacker.name} misses ${target.name}!`,
                damage > 0 ? 'damage' : 'miss'
            );

            setTimeout(() => this.nextTurn(), 1000);
        }

        castSpell() {
            const caster = this.combatants[this.currentTurn];
            const targets = this.combatants.filter(c => !c.isAlly && c.hp > 0);
            if (targets.length === 0) return this.endBattle(true);

            const damage = Math.floor(Math.random() * 20) + 10;
            targets.forEach(t => t.hp -= damage);

            this.logBattle(`${caster.name} casts Fireball for ${damage} damage to all enemies!`, 'damage');
            setTimeout(() => this.nextTurn(), 1000);
        }

        useItem() {
            const user = this.combatants[this.currentTurn];
            const healAmount = Math.floor(Math.random() * 15) + 10;
            user.hp = Math.min(user.maxHp, user.hp + healAmount);

            this.logBattle(`${user.name} uses a potion and heals for ${healAmount}!`, 'heal');
            setTimeout(() => this.nextTurn(), 800);
        }

        defend() {
            const defender = this.combatants[this.currentTurn];
            this.logBattle(`${defender.name} takes a defensive stance.`, 'miss');
            setTimeout(() => this.nextTurn(), 500);
        }

        animateAttack(attacker, target) {
            const origPos = attacker.position.clone();
            const targetPos = target.position.clone();

            // Lunge animation
            const tween = (t) => {
                if (t < 0.5) {
                    attacker.position.lerpVectors(origPos, targetPos, t * 2);
                } else {
                    attacker.position.lerpVectors(targetPos, origPos, (t - 0.5) * 2);
                }
            };

            let t = 0;
            const animate = () => {
                t += 0.05;
                if (t <= 1) {
                    tween(t);
                    requestAnimationFrame(animate);
                }
            };
            animate();
        }

        nextTurn() {
            // Check for victory/defeat
            const allies = this.combatants.filter(c => c.isAlly && c.hp > 0);
            const enemies = this.combatants.filter(c => !c.isAlly && c.hp > 0);

            if (enemies.length === 0) return this.endBattle(true);
            if (allies.length === 0) return this.endBattle(false);

            // Next turn
            do {
                this.currentTurn = (this.currentTurn + 1) % this.combatants.length;
            } while (this.combatants[this.currentTurn].hp <= 0);

            const current = this.combatants[this.currentTurn];

            if (!current.isAlly) {
                // Enemy AI
                setTimeout(() => this.enemyTurn(), 800);
            }

            this.renderBattleUI();
        }

        enemyTurn() {
            const attacker = this.combatants[this.currentTurn];
            const targets = this.combatants.filter(c => c.isAlly && c.hp > 0);
            if (targets.length === 0) return this.endBattle(false);

            const target = targets[Math.floor(Math.random() * targets.length)];
            const damage = Math.floor(Math.random() * 10) + 3;
            target.hp -= damage;

            this.animateAttack(attacker.mesh, target.mesh);
            this.logBattle(`${attacker.name} attacks ${target.name} for ${damage} damage!`, 'damage');

            setTimeout(() => this.nextTurn(), 1000);
        }

        logBattle(msg, type = '') {
            const log = document.getElementById('battle-log');
            log.innerHTML = `<div class="log-entry ${type}">${msg}</div>` + log.innerHTML;
        }

        endBattle(victory) {
            setTimeout(() => {
                this.active = false;
                this.arena.classList.remove('active');

                // Notify game engine
                game.onBattleEnd(victory);
            }, 1500);
        }

        animateBattle() {
            if (!this.active) return;

            requestAnimationFrame(() => this.animateBattle());

            // Animate combatants
            this.combatants.forEach((c, i) => {
                if (c.mesh && c.hp > 0) {
                    c.mesh.position.y = 1 + Math.sin(Date.now() * 0.003 + i) * 0.1;
                    c.mesh.rotation.y += 0.01;
                }
            });

            this.renderer.render(this.scene, this.camera);
        }
    }

    // ============================================================================
    // GAME ENGINE
    // ============================================================================
    class Game {
        constructor() {
            this.party = this.createParty();
            this.state = {
                location: 'castle',
                locationName: 'Valorhold Castle',
                chapter: 1,
                xp: 94500,
                gold: 47350,
                daysRemaining: 12,
                quests: [
                    { name: "Stop Azaroth's Ritual", progress: '12 days remaining' },
                    { name: 'Artifacts Collected', progress: '0/3' }
                ]
            };
            this.inventory = [
                { name: 'Healing Potion', emoji: EMOJIS.potion, count: 2, rarity: 'rare' },
                { name: 'Revivify Scroll', emoji: EMOJIS.scroll, count: 1, rarity: 'rare' },
                { name: 'Immovable Rod', emoji: 'üî©', count: 1, rarity: 'legendary' },
                { name: 'Bag of Holding', emoji: 'üëú', count: 1, rarity: 'rare' }
            ];
            this.currentScene = 'intro';
            this.scenes = this.createScenes();
        }

        createParty() {
            return [
                { id: 'theron', name: 'Theron', fullName: 'Theron Stormbreaker', class: 'Fighter', level: 11, hp: 102, maxHp: 102, emoji: EMOJIS.fighter, dex: 14, str: 20 },
                { id: 'lyra', name: 'Lyra', fullName: 'Lyra Moonshadow', class: 'Wizard', level: 11, hp: 68, maxHp: 68, emoji: EMOJIS.wizard, dex: 16, int: 20 },
                { id: 'kael', name: 'Kael', fullName: 'Kael Swiftarrow', class: 'Ranger', level: 11, hp: 88, maxHp: 88, emoji: EMOJIS.ranger, dex: 20, wis: 18 },
                { id: 'seraphina', name: 'Seraphina', fullName: 'Seraphina Lightbringer', class: 'Cleric', level: 11, hp: 95, maxHp: 95, emoji: EMOJIS.cleric, dex: 12, wis: 20 }
            ];
        }

        createScenes() {
            return {
                intro: {
                    location: 'castle',
                    locationName: 'War Room - Valorhold Castle',
                    entities: [
                        { name: 'Captain Elara', emoji: EMOJIS.captain, type: 'friendly' },
                        { name: 'Oracle Celestia', emoji: EMOJIS.oracle, type: 'neutral' }
                    ],
                    text: [
                        "The crimson moon hangs low in the night sky, casting an eerie red glow over the Kingdom of Elendor.",
                        "You stand in the War Room, maps spread before you. Captain Elara Brightshield's face is grim."
                    ],
                    dialogue: {
                        speaker: 'Captain Elara',
                        text: '"Heroes, Oracle Celestia has confirmed what we feared. Lord Malachar is actually Azaroth the Undying, an ancient lich. In twelve days, when the crimson moon reaches its zenith, his ritual will plunge our kingdom into eternal darkness."'
                    },
                    choices: [
                        { text: 'Storm the fortress NOW!', emoji: EMOJIS.sword, type: 'combat', leads: 'battle_direct' },
                        { text: 'Gather the three artifacts first', emoji: EMOJIS.quest, type: 'quest', leads: 'artifact_quest' },
                        { text: 'Scout the fortress (Stealth DC 18)', emoji: EMOJIS.ranger, type: 'skill', skill: 'stealth', dc: 18, success: 'scout_success', fail: 'scout_fail' },
                        { text: 'Seek the phylactery', emoji: EMOJIS.book, type: 'quest', leads: 'phylactery_hunt' }
                    ]
                },
                battle_direct: {
                    location: 'dungeon',
                    locationName: "Azaroth's Fortress",
                    entities: [
                        { name: 'Skeleton Guard', emoji: EMOJIS.skeleton, type: 'enemy' },
                        { name: 'Skeleton Guard', emoji: EMOJIS.skeleton, type: 'enemy' },
                        { name: 'Wraith', emoji: EMOJIS.wraith, type: 'enemy' }
                    ],
                    text: ["You charge into the fortress! Undead guards block your path.", "Prepare for battle!"],
                    choices: [
                        { text: 'FIGHT! Draw your weapons!', emoji: EMOJIS.sword, type: 'battle', enemies: [
                            { name: 'Skeleton Guard', hp: 30, maxHp: 30, emoji: EMOJIS.skeleton },
                            { name: 'Skeleton Guard', hp: 30, maxHp: 30, emoji: EMOJIS.skeleton },
                            { name: 'Wraith', hp: 45, maxHp: 45, emoji: EMOJIS.wraith }
                        ], afterBattle: 'fortress_interior' },
                        { text: 'Try to negotiate', emoji: 'üó£Ô∏è', type: 'skill', skill: 'charisma', dc: 20, success: 'negotiate_success', fail: 'battle_direct' }
                    ]
                },
                fortress_interior: {
                    location: 'dungeon',
                    locationName: "Fortress Inner Sanctum",
                    entities: [
                        { name: 'Dark Altar', emoji: '‚õ©Ô∏è', type: 'neutral' },
                        { name: 'Phylactery', emoji: EMOJIS.orb, type: 'neutral' }
                    ],
                    text: ["Victory! The undead crumble before you.", "You've reached the inner sanctum. The phylactery pulses with dark energy on the altar."],
                    choices: [
                        { text: 'Destroy the phylactery!', emoji: EMOJIS.fire, type: 'quest', leads: 'destroy_phylactery' },
                        { text: 'Take it to study', emoji: EMOJIS.book, type: 'quest', leads: 'take_phylactery' }
                    ]
                },
                negotiate_success: {
                    location: 'dungeon',
                    locationName: "Azaroth's Fortress",
                    entities: [],
                    text: ["Incredibly, the undead halt. Your words of power compel them to stand aside."],
                    choices: [
                        { text: 'Proceed deeper', emoji: EMOJIS.dungeon, type: 'quest', leads: 'fortress_interior' }
                    ]
                },
                artifact_quest: {
                    location: 'temple',
                    locationName: 'Ancient Temple of Dawn',
                    entities: [
                        { name: 'Temple Guardian', emoji: EMOJIS.golem, type: 'neutral' },
                        { name: 'Sacred Altar', emoji: '‚õ©Ô∏è', type: 'neutral' }
                    ],
                    text: [
                        "You travel to the Temple of Dawn, seeking the first artifact: The Sunblade.",
                        "A massive stone guardian blocks the entrance, its eyes glowing with ancient magic."
                    ],
                    dialogue: {
                        speaker: 'Guardian',
                        text: '"Prove your worth, mortals. Answer my riddle, or face my wrath."'
                    },
                    choices: [
                        { text: 'Accept the riddle challenge', emoji: EMOJIS.book, type: 'skill', skill: 'intelligence', dc: 15, success: 'riddle_success', fail: 'guardian_battle' },
                        { text: 'Attack the guardian!', emoji: EMOJIS.sword, type: 'battle', enemies: [
                            { name: 'Stone Guardian', hp: 120, maxHp: 120, emoji: EMOJIS.golem }
                        ], afterBattle: 'temple_interior' },
                        { text: 'Sneak past while it talks', emoji: EMOJIS.rogue, type: 'skill', skill: 'stealth', dc: 20, success: 'temple_interior', fail: 'guardian_battle' }
                    ]
                },
                guardian_battle: {
                    location: 'temple',
                    locationName: 'Temple Entrance',
                    entities: [
                        { name: 'Enraged Guardian', emoji: EMOJIS.golem, type: 'enemy' }
                    ],
                    text: ["The Guardian's eyes flash red with fury!", "COMBAT INITIATED!"],
                    choices: [
                        { text: 'FIGHT!', emoji: EMOJIS.sword, type: 'battle', enemies: [
                            { name: 'Stone Guardian', hp: 120, maxHp: 120, emoji: EMOJIS.golem }
                        ], afterBattle: 'temple_interior' }
                    ]
                },
                riddle_success: {
                    location: 'temple',
                    locationName: 'Temple Entrance',
                    entities: [
                        { name: 'Guardian', emoji: EMOJIS.golem, type: 'friendly' }
                    ],
                    text: ["The Guardian nods slowly.", "\"Wisdom guides you. Enter, worthy ones.\"", "The massive doors swing open."],
                    choices: [
                        { text: 'Enter the temple', emoji: EMOJIS.temple, type: 'quest', leads: 'temple_interior' }
                    ]
                },
                temple_interior: {
                    location: 'temple',
                    locationName: 'Temple Inner Sanctum',
                    entities: [
                        { name: 'Sunblade', emoji: 'üó°Ô∏è‚ú®', type: 'neutral' },
                        { name: 'Ancient Pedestal', emoji: 'üèõÔ∏è', type: 'neutral' }
                    ],
                    text: ["The Sunblade hovers above an ancient pedestal, radiating golden light.", "You have found the first artifact!"],
                    choices: [
                        { text: 'Take the Sunblade', emoji: EMOJIS.sword, type: 'quest', leads: 'artifact_obtained' }
                    ]
                },
                artifact_obtained: {
                    location: 'temple',
                    locationName: 'Temple of Dawn',
                    entities: [],
                    text: ["You grasp the Sunblade! Power surges through you.", "+1 Artifact Collected!", "Two more remain: The Orb of Shadows and the Crown of Kings."],
                    choices: [
                        { text: 'Return to Valorhold', emoji: EMOJIS.castle, type: 'quest', leads: 'intro' },
                        { text: 'Seek the next artifact', emoji: EMOJIS.quest, type: 'quest', leads: 'orb_quest' }
                    ]
                },
                scout_success: {
                    location: 'dungeon',
                    locationName: 'Fortress Catacombs',
                    entities: [
                        { name: 'Kael', emoji: EMOJIS.ranger, type: 'friendly' }
                    ],
                    text: [
                        "Kael moves like a shadow through the catacombs, evading every trap and patrol.",
                        "Deep inside, he spots the phylactery - a pulsing obsidian box on a pedestal!",
                        "Even better: half of Azaroth's forces have been sent north. The fortress is undermanned!"
                    ],
                    choices: [
                        { text: 'Strike now while weak!', emoji: EMOJIS.sword, type: 'battle', enemies: [
                            { name: 'Skeleton Mage', hp: 40, maxHp: 40, emoji: EMOJIS.skeleton },
                            { name: 'Death Knight', hp: 60, maxHp: 60, emoji: EMOJIS.knight }
                        ], afterBattle: 'fortress_interior' },
                        { text: 'Steal the phylactery first', emoji: EMOJIS.key, type: 'skill', skill: 'stealth', dc: 16, success: 'heist_success', fail: 'heist_fail' }
                    ]
                },
                heist_success: {
                    location: 'dungeon',
                    locationName: 'Fortress Sanctum',
                    entities: [
                        { name: 'Phylactery', emoji: EMOJIS.orb, type: 'neutral' }
                    ],
                    text: ["You grab the phylactery! Azaroth's power source is in your hands!", "Now to destroy it and end the lich forever!"],
                    choices: [
                        { text: 'Destroy it now!', emoji: EMOJIS.fire, type: 'quest', leads: 'destroy_phylactery' },
                        { text: 'Escape first', emoji: 'üèÉ', type: 'quest', leads: 'escape_fortress' }
                    ]
                },
                heist_fail: {
                    location: 'dungeon',
                    locationName: 'Fortress Sanctum',
                    entities: [
                        { name: 'Azaroth', emoji: EMOJIS.lich, type: 'enemy' },
                        { name: 'Shadow Demons', emoji: EMOJIS.demon, type: 'enemy' }
                    ],
                    text: ["FOOL!", "Azaroth himself materializes before you, his empty eye sockets blazing with necrotic fire."],
                    dialogue: {
                        speaker: 'Azaroth the Undying',
                        text: '"Did you think you could steal from ME? Now you die!"'
                    },
                    choices: [
                        { text: 'FINAL BATTLE!', emoji: 'üíÄ', type: 'battle', enemies: [
                            { name: 'Azaroth', hp: 200, maxHp: 200, emoji: EMOJIS.lich },
                            { name: 'Shadow Demon', hp: 50, maxHp: 50, emoji: EMOJIS.demon },
                            { name: 'Shadow Demon', hp: 50, maxHp: 50, emoji: EMOJIS.demon }
                        ], afterBattle: 'victory_ending' }
                    ]
                },
                destroy_phylactery: {
                    location: 'dungeon',
                    locationName: 'Fortress Sanctum',
                    entities: [],
                    text: ["You raise your weapon and strike the phylactery!", "A terrible scream echoes through the fortress as Azaroth's soul is torn apart!", "VICTORY! The kingdom is saved!"],
                    choices: [
                        { text: 'Celebrate your victory!', emoji: 'üéâ', type: 'quest', leads: 'victory_ending' }
                    ]
                },
                victory_ending: {
                    location: 'castle',
                    locationName: 'Valorhold - Throne Room',
                    entities: [
                        { name: 'King', emoji: EMOJIS.king, type: 'friendly' },
                        { name: 'Queen', emoji: EMOJIS.queen, type: 'friendly' },
                        { name: 'Captain Elara', emoji: EMOJIS.captain, type: 'friendly' }
                    ],
                    text: ["The kingdom celebrates! You are heroes!", "The King grants you lands, titles, and eternal gratitude.", "THE END... or is it?"],
                    choices: [
                        { text: 'Play Again', emoji: 'üîÑ', type: 'quest', leads: 'intro' }
                    ]
                },
                scout_fail: {
                    location: 'dungeon',
                    locationName: 'Fortress Entrance',
                    entities: [
                        { name: 'Skeleton Archer', emoji: EMOJIS.skeleton, type: 'enemy' },
                        { name: 'Skeleton Archer', emoji: EMOJIS.skeleton, type: 'enemy' },
                        { name: 'Death Knight', emoji: EMOJIS.knight, type: 'enemy' }
                    ],
                    text: [
                        "Kael triggers a magical alarm! The fortress awakens with fury.",
                        "A Death Knight emerges from the shadows, sword raised."
                    ],
                    choices: [
                        { text: 'FIGHT FOR YOUR LIVES!', emoji: EMOJIS.sword, type: 'battle', enemies: [
                            { name: 'Skeleton Archer', hp: 25, maxHp: 25, emoji: EMOJIS.skeleton },
                            { name: 'Skeleton Archer', hp: 25, maxHp: 25, emoji: EMOJIS.skeleton },
                            { name: 'Death Knight', hp: 80, maxHp: 80, emoji: EMOJIS.knight }
                        ], afterBattle: 'escape_fortress' },
                        { text: 'RETREAT!', emoji: 'üèÉ', type: 'quest', leads: 'intro' }
                    ]
                },
                escape_fortress: {
                    location: 'forest',
                    locationName: 'Forest Outside Fortress',
                    entities: [],
                    text: ["You escape the fortress with valuable intel!", "Now you must decide your next move."],
                    choices: [
                        { text: 'Return to Valorhold', emoji: EMOJIS.castle, type: 'quest', leads: 'intro' }
                    ]
                },
                phylactery_hunt: {
                    location: 'graveyard',
                    locationName: 'Forgotten Graveyard',
                    entities: [
                        { name: 'Ancient Tomb', emoji: 'ü™¶', type: 'neutral' },
                        { name: 'Ghost Scholar', emoji: EMOJIS.ghost, type: 'neutral' }
                    ],
                    text: [
                        "Your research leads you to the Forgotten Graveyard, where Azaroth was first buried centuries ago.",
                        "A spectral figure materializes - the ghost of a scholar who studied the lich."
                    ],
                    dialogue: {
                        speaker: 'Ghost Scholar',
                        text: '"You seek the phylactery? It was hidden where Azaroth\'s mortal heart still beats... inside his own statue in the throne room. But beware - the statue is guarded by his most loyal servants."'
                    },
                    choices: [
                        { text: 'Thank the ghost and head to throne room', emoji: EMOJIS.castle, type: 'quest', leads: 'throne_room' },
                        { text: 'Ask for more information', emoji: EMOJIS.book, type: 'quest', leads: 'ghost_lore' }
                    ]
                }
            };
        }

        init() {
            this.render();
            this.loadScene('intro');
        }

        render() {
            this.renderParty();
            this.renderResources();
            this.renderInventory();
            this.renderQuests();
            this.renderMap();
        }

        renderParty() {
            const container = document.getElementById('party-container');
            container.innerHTML = this.party.map(char => `
                <div class="character-card" onclick="game.selectCharacter('${char.id}')">
                    <div class="char-emoji">${char.emoji}</div>
                    <div class="char-info">
                        <div class="char-name">${char.fullName}</div>
                        <div class="char-class">${char.class} ${char.level}</div>
                        <div class="hp-bar-container">
                            <div class="hp-bar" style="width: ${(char.hp / char.maxHp) * 100}%"></div>
                        </div>
                        <div class="hp-text">${EMOJIS.heart} ${char.hp}/${char.maxHp}</div>
                    </div>
                </div>
            `).join('');
        }

        renderResources() {
            const container = document.getElementById('resources-display');
            container.innerHTML = `
                <div class="resource-item">
                    <span class="resource-emoji">${EMOJIS.gold}</span>
                    <span class="resource-value">${this.state.gold.toLocaleString()}</span>
                </div>
                <div class="resource-item">
                    <span class="resource-emoji">${EMOJIS.xp}</span>
                    <span class="resource-value">${this.state.xp.toLocaleString()}</span>
                </div>
                <div class="resource-item">
                    <span class="resource-emoji">${EMOJIS.moon}</span>
                    <span class="resource-value">${this.state.daysRemaining} days</span>
                </div>
            `;
        }

        renderInventory() {
            const container = document.getElementById('inventory-grid');
            const slots = [];

            this.inventory.forEach(item => {
                slots.push(`
                    <div class="inv-slot ${item.rarity}" title="${item.name}">
                        ${item.emoji}
                        ${item.count > 1 ? `<span class="inv-count">${item.count}</span>` : ''}
                    </div>
                `);
            });

            // Fill remaining slots
            while (slots.length < 12) {
                slots.push('<div class="inv-slot"></div>');
            }

            container.innerHTML = slots.join('');
        }

        renderQuests() {
            const container = document.getElementById('quest-tracker');
            container.innerHTML = this.state.quests.map(q => `
                <div class="quest-item">
                    <strong>${q.name}</strong><br>
                    <span style="color: #fbbf24">${q.progress}</span>
                </div>
            `).join('');
        }

        renderMap() {
            const container = document.getElementById('world-map');
            const locations = {
                castle: { x: 50, y: 30, emoji: EMOJIS.castle },
                dungeon: { x: 80, y: 20, emoji: EMOJIS.dungeon },
                forest: { x: 30, y: 50, emoji: EMOJIS.forest },
                temple: { x: 20, y: 30, emoji: EMOJIS.temple },
                graveyard: { x: 70, y: 60, emoji: 'ü™¶' },
                mountain: { x: 85, y: 70, emoji: EMOJIS.mountain },
                village: { x: 40, y: 70, emoji: EMOJIS.village }
            };

            container.innerHTML = Object.entries(locations).map(([key, loc]) => `
                <div class="map-icon ${key === this.state.location ? 'current' : ''}"
                     style="left: ${loc.x}%; top: ${loc.y}%"
                     title="${key}">
                    ${loc.emoji}
                </div>
            `).join('');
        }

        loadScene(sceneId) {
            const scene = this.scenes[sceneId];
            if (!scene) {
                console.error('Scene not found:', sceneId);
                return;
            }

            this.currentScene = sceneId;
            this.state.location = scene.location;
            this.state.locationName = scene.locationName;

            // Update world visuals
            if (window.world) {
                world.setLocation(scene.location);
            }

            this.renderStory();
            this.renderMap();

            // Start battle if defined
            if (scene.startBattle) {
                setTimeout(() => {
                    battle.startBattle(scene.startBattle, this.party);
                }, 1000);
            }
        }

        renderStory() {
            const scene = this.scenes[this.currentScene];
            if (!scene) return;

            // Location
            document.getElementById('location-display').innerHTML = `
                <div class="location-emoji">${EMOJIS[scene.location] || EMOJIS.castle}</div>
                <div class="location-info">
                    <h3>${scene.locationName}</h3>
                    <p>Chapter ${this.state.chapter}</p>
                </div>
            `;

            // Scene entities
            if (scene.entities) {
                document.getElementById('scene-visual').innerHTML = scene.entities.map(e => `
                    <div class="scene-entity ${e.type}">
                        <div class="entity-emoji">${e.emoji}</div>
                        <div class="entity-name">${e.name}</div>
                    </div>
                `).join('');
            }

            // Story text
            let storyHTML = scene.text.map(t => `<p class="story-text">${t}</p>`).join('');

            if (scene.dialogue) {
                storyHTML += `
                    <div class="dialogue">
                        <div class="dialogue-speaker">${scene.dialogue.speaker}</div>
                        <div>${scene.dialogue.text}</div>
                    </div>
                `;
            }

            document.getElementById('story-content').innerHTML = storyHTML;

            // Choices
            document.getElementById('choices-container').innerHTML = scene.choices.map((c, i) => `
                <button class="choice-btn ${c.type}" onclick="game.makeChoice(${i})">
                    <span class="choice-emoji">${c.emoji}</span>
                    <span>${c.text}</span>
                </button>
            `).join('');
        }

        makeChoice(index) {
            const scene = this.scenes[this.currentScene];
            const choice = scene.choices[index];

            if (choice.type === 'skill') {
                this.rollSkillCheck(choice);
            } else if (choice.type === 'battle') {
                // Start a battle!
                this.pendingAfterBattle = choice.afterBattle;
                battle.startBattle(choice.enemies, this.party);
            } else if (choice.leads) {
                this.loadScene(choice.leads);
            }
        }

        onBattleEnd(victory) {
            if (victory && this.pendingAfterBattle) {
                this.addXP(500);
                this.addGold(100);
                this.loadScene(this.pendingAfterBattle);
                this.pendingAfterBattle = null;
            } else if (!victory) {
                this.showMessage('Your party has been defeated...');
                this.loadScene('intro');
            }
        }

        rollSkillCheck(choice) {
            const overlay = document.getElementById('dice-overlay');
            overlay.classList.add('active');

            const roll = Math.floor(Math.random() * 20) + 1;
            const modifier = 5; // Simplified
            const total = roll + modifier;
            const success = total >= choice.dc;

            document.getElementById('dice-emoji').textContent = EMOJIS.dice;
            document.getElementById('dice-result').textContent = `${roll} + ${modifier} = ${total}`;
            document.getElementById('dice-outcome').className = `dice-outcome ${success ? 'success' : 'failure'}`;
            document.getElementById('dice-outcome').textContent = success ? `SUCCESS! (DC ${choice.dc})` : `FAILURE! (DC ${choice.dc})`;

            setTimeout(() => {
                overlay.classList.remove('active');
                this.loadScene(success ? choice.success : choice.fail);
            }, 2500);
        }

        addXP(amount) {
            this.state.xp += amount;
            this.renderResources();
        }

        addGold(amount) {
            this.state.gold += amount;
            this.renderResources();
        }

        showMessage(msg) {
            alert(msg); // Could be enhanced with custom modal
        }

        selectCharacter(id) {
            document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }

        save() {
            localStorage.setItem('dnd-save', JSON.stringify({
                party: this.party,
                state: this.state,
                inventory: this.inventory,
                currentScene: this.currentScene
            }));
            this.showMessage('Game saved!');
        }

        load() {
            const save = localStorage.getItem('dnd-save');
            if (save) {
                const data = JSON.parse(save);
                this.party = data.party;
                this.state = data.state;
                this.inventory = data.inventory;
                this.currentScene = data.currentScene;
                this.render();
                this.renderStory();
                this.showMessage('Game loaded!');
            }
        }

        reset() {
            if (confirm('Reset game? All progress will be lost!')) {
                localStorage.removeItem('dnd-save');
                location.reload();
            }
        }
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    let world, battle, game;

    window.addEventListener('load', () => {
        world = new WorldEngine();
        battle = new BattleEngine();
        game = new Game();
        game.init();
    });
    </script>
</body>
</html>
