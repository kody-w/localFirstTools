<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Share+Tech+Mono&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: #fff;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 32px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
        }

        .stats-box {
            display: flex;
            gap: 20px;
            text-align: right;
            align-items: center;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: 20px; color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: 10px; color: #666; text-transform: uppercase; }

        /* RPG INTERFACE (Bottom) */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 200px;
            background: linear-gradient(to top, rgba(5,5,5,0.95), transparent);
            display: none;
            padding: 20px;
            pointer-events: none;
            align-items: flex-end;
            justify-content: space-between;
        }

        .inventory-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: 300px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .panel-title {
            color: #fb0;
            font-family: 'Cinzel', serif;
            border-bottom: 1px solid #445;
            margin-bottom: 10px;
            padding-bottom: 5px;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 2px; right: 4px;
            font-size: 12px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        .player-stats {
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 15px;
            width: 280px;
        }

        .health-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-icon { font-size: 24px; }
        .health-bar-wrapper { flex: 1; }
        .health-bar-bg {
            height: 16px;
            background: #222;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #400;
        }
        .health-bar-fill {
            height: 100%;
            background: linear-gradient(to bottom, #ff4444, #aa0000);
            width: 100%;
            transition: width 0.3s;
        }
        .health-text {
            text-align: center;
            font-size: 11px;
            color: #faa;
            margin-top: 2px;
        }

        .xp-bar-container { margin-bottom: 8px; }
        .xp-label { font-size: 12px; color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-top: 4px; }
        .xp-bar-fill { height: 100%; background: #0f0; width: 0%; transition: width 0.3s; }

        /* Center Stats Panel */
        .center-stats {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        /* Action Button */
        .action-btn {
            background: linear-gradient(to bottom, #ffcc00, #cc9900);
            color: #000;
            border: none;
            padding: 12px 24px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Cinzel', serif;
            pointer-events: auto;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255,200,0,0.3);
            transition: all 0.2s;
        }
        .action-btn:hover {
            background: linear-gradient(to bottom, #fff, #ffcc00);
            box-shadow: 0 4px 25px rgba(255,200,0,0.5);
            transform: translateY(-2px);
        }
        .action-btn:active {
            transform: translateY(0);
        }

        /* Floating Text Pool */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000, 0 0 8px #000;
            pointer-events: none;
            z-index: 50;
        }

        .floater.animate {
            animation: floatUp 1.5s forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-60px) scale(1.3); opacity: 0; }
        }

        /* Damage indicator */
        .damage-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 5;
        }

        /* Minimap */
        .minimap {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #445;
            border-radius: 8px;
            overflow: hidden;
            pointer-events: auto;
        }

        .minimap canvas {
            width: 100%;
            height: 100%;
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
        }

        .tooltip-name { font-size: 14px; font-weight: bold; margin-bottom: 4px; }
        .tooltip-hp { color: #f88; }
        .tooltip-hint { color: #888; font-size: 11px; margin-top: 4px; }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999; font-family: 'Cinzel';
            gap: 20px;
        }

        .loading-title { font-size: 32px; letter-spacing: 4px; }
        .loading-bar { width: 300px; height: 4px; background: #222; border-radius: 2px; overflow: hidden; }
        .loading-fill { height: 100%; background: #0f0; width: 0%; transition: width 0.3s; }
        .loading-text { font-size: 14px; color: #666; }

        /* Screen shake */
        .shake {
            animation: shake 0.2s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-0.5deg); }
            75% { transform: translateX(5px) rotate(0.5deg); }
        }

        /* World info panel */
        .world-info {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            display: none;
        }

        .world-info .biome-name {
            font-family: 'Cinzel', serif;
            color: #fb0;
            font-size: 18px;
            margin-bottom: 8px;
        }

        .world-info .time-display {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 14px;
        }

        .time-icon { font-size: 20px; }

        /* Particle container */
        .particle-layer {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 4;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        .particle.spark {
            width: 4px; height: 4px;
            animation: sparkFly 0.6s ease-out forwards;
        }

        .particle.dust {
            width: 6px; height: 6px;
            animation: dustFloat 1s ease-out forwards;
        }

        @keyframes sparkFly {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.3) translateY(-30px); }
        }

        @keyframes dustFloat {
            0% { opacity: 0.8; transform: scale(1) translateY(0); }
            100% { opacity: 0; transform: scale(0.5) translateY(-20px); }
        }

        /* Save/Load UI */
        .save-panel {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #fb0;
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 200;
            pointer-events: auto;
            min-width: 300px;
        }

        .save-panel.visible { display: block; }

        .save-panel h3 {
            color: #fb0;
            font-family: 'Cinzel', serif;
            margin-bottom: 15px;
            text-align: center;
        }

        .save-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .save-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-slot:hover {
            border-color: #fb0;
            background: #2a2a2a;
        }

        .save-slot.empty { color: #666; font-style: italic; }
        .save-slot .slot-name { color: #fff; font-weight: bold; }
        .save-slot .slot-info { color: #888; font-size: 11px; margin-top: 4px; }

        .save-panel-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .save-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
        }

        .save-btn:hover { background: #444; border-color: #fb0; }
        .save-btn.primary { background: #fb0; color: #000; border-color: #fb0; }
        .save-btn.primary:hover { background: #fff; }

        /* Keyboard hints */
        .keyboard-hints {
            position: absolute;
            bottom: 220px;
            left: 20px;
            background: rgba(10, 15, 20, 0.8);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            color: #888;
            pointer-events: auto;
            display: none;
        }

        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            color: #fff;
            margin-right: 5px;
        }

        /* Level up effect */
        .level-up-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(255,215,0,0.4), transparent 70%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 6;
        }

        .level-up-flash.active {
            opacity: 1;
            animation: levelPulse 0.5s ease-out;
        }

        @keyframes levelPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(1.2); opacity: 0; }
        }

        /* Multiplayer UI */
        .multiplayer-panel {
            position: absolute;
            top: 80px;
            right: 180px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #0af;
            border-radius: 8px;
            padding: 15px;
            display: none;
            z-index: 200;
            pointer-events: auto;
            min-width: 280px;
            max-width: 320px;
        }

        .multiplayer-panel.visible { display: block; }

        .multiplayer-panel h3 {
            color: #0af;
            font-family: 'Cinzel', serif;
            margin-bottom: 15px;
            text-align: center;
            font-size: 16px;
        }

        .mp-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .mp-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .mp-label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .qr-container {
            display: flex;
            justify-content: center;
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .qr-container canvas {
            max-width: 150px;
            max-height: 150px;
        }

        .peer-id-display {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            color: #0f0;
            word-break: break-all;
            text-align: center;
        }

        .mp-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .mp-input:focus {
            outline: none;
            border-color: #0af;
        }

        .mp-btn {
            width: 100%;
            background: #0af;
            color: #000;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            transition: all 0.2s;
        }

        .mp-btn:hover { background: #0cf; }
        .mp-btn:disabled { background: #444; color: #888; cursor: not-allowed; }

        .mp-btn.danger { background: #f44; }
        .mp-btn.danger:hover { background: #f66; }

        .mp-status {
            text-align: center;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .mp-status.connected { background: rgba(0,255,0,0.2); color: #0f0; }
        .mp-status.connecting { background: rgba(255,165,0,0.2); color: #fa0; }
        .mp-status.disconnected { background: rgba(255,0,0,0.2); color: #f44; }
        .mp-status.hosting { background: rgba(0,170,255,0.2); color: #0af; }

        .connected-players {
            max-height: 120px;
            overflow-y: auto;
        }

        .player-entry {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: #1a1a1a;
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .player-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #0f0;
        }

        .player-name { flex: 1; color: #fff; }
        .player-ping { color: #888; font-size: 10px; }

        /* Player name tag in 3D */
        .player-nametag {
            position: absolute;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 4px #000, 0 0 8px #000;
            pointer-events: none;
            white-space: nowrap;
            transform: translateX(-50%);
        }

        /* Multiplayer button in HUD */
        .mp-toggle-btn {
            background: linear-gradient(to bottom, #0af, #08a);
            color: #fff;
            border: none;
            padding: 10px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Cinzel', serif;
            pointer-events: auto;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mp-toggle-btn:hover {
            background: linear-gradient(to bottom, #0cf, #0af);
        }

        .mp-toggle-btn .online-count {
            background: #0f0;
            color: #000;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        /* Chat overlay */
        .chat-container {
            position: absolute;
            bottom: 220px;
            left: 20px;
            width: 300px;
            pointer-events: none;
            display: none;
        }

        .chat-messages {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 8px;
            pointer-events: auto;
        }

        .chat-message {
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            margin-bottom: 2px;
            border-radius: 4px;
            font-size: 12px;
            animation: chatFadeIn 0.2s;
        }

        @keyframes chatFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message .sender {
            color: #0af;
            font-weight: bold;
        }

        .chat-message .text {
            color: #fff;
        }

        .chat-message.system {
            color: #fa0;
            font-style: italic;
        }

        .chat-input-container {
            display: flex;
            gap: 4px;
            pointer-events: auto;
        }

        .chat-input {
            flex: 1;
            background: rgba(0,0,0,0.8);
            border: 1px solid #333;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #0af;
        }

        .chat-send-btn {
            background: #0af;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        <div class="loading-title">LEVIATHAN</div>
        <div class="loading-bar"><div id="loading-fill" class="loading-fill"></div></div>
        <div id="loading-text" class="loading-text">Initializing Omniverse Engine...</div>
    </div>

    <div id="damage-flash" class="damage-flash"></div>
    <div id="level-up-flash" class="level-up-flash"></div>
    <div id="particle-layer" class="particle-layer"></div>
    <div id="container"></div>

    <!-- Save/Load Panel -->
    <div id="save-panel" class="save-panel">
        <h3 id="save-panel-title">Save Game</h3>
        <div id="save-slots" class="save-slots"></div>
        <div class="save-panel-buttons">
            <button class="save-btn" onclick="closeSavePanel()">Cancel</button>
        </div>
    </div>

    <!-- Multiplayer Panel -->
    <div id="multiplayer-panel" class="multiplayer-panel">
        <h3>üåê MULTIPLAYER</h3>

        <div id="mp-status" class="mp-status disconnected">Offline</div>

        <!-- Host Section -->
        <div id="mp-host-section" class="mp-section">
            <div class="mp-label">Host a World</div>
            <input type="text" id="mp-player-name" class="mp-input" placeholder="Your Name" maxlength="16" value="Player">
            <button id="mp-host-btn" class="mp-btn" onclick="hostWorld()">üéÆ START HOSTING</button>
        </div>

        <!-- QR Code Section (shown when hosting) -->
        <div id="mp-qr-section" class="mp-section" style="display:none;">
            <div class="mp-label">Scan to Join</div>
            <div id="qr-container" class="qr-container">
                <canvas id="qr-canvas"></canvas>
            </div>
            <div class="mp-label">Or share this code:</div>
            <div id="peer-id-display" class="peer-id-display">---</div>
            <button class="mp-btn" style="margin-top:10px;" onclick="copyPeerId()">üìã Copy Code</button>
        </div>

        <!-- Join Section -->
        <div id="mp-join-section" class="mp-section">
            <div class="mp-label">Join a World</div>
            <input type="text" id="mp-join-code" class="mp-input" placeholder="Enter host code...">
            <button id="mp-join-btn" class="mp-btn" onclick="joinWorld()">üöÄ JOIN</button>
        </div>

        <!-- Connected Players -->
        <div id="mp-players-section" class="mp-section" style="display:none;">
            <div class="mp-label">Connected Players</div>
            <div id="connected-players" class="connected-players"></div>
        </div>

        <!-- Disconnect -->
        <div id="mp-disconnect-section" style="display:none;">
            <button class="mp-btn danger" onclick="disconnectMultiplayer()">‚ùå DISCONNECT</button>
        </div>
    </div>

    <!-- Chat Container -->
    <div id="chat-container" class="chat-container">
        <div id="chat-messages" class="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="chat-input" class="chat-input" placeholder="Press Enter to chat..." maxlength="200">
            <button class="chat-send-btn" onclick="sendChatMessage()">‚û§</button>
        </div>
    </div>

    <!-- Nametags container -->
    <div id="nametags-container" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:15;"></div>

    <div class="ui-layer">

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div id="subtitle" style="color: #666; font-size: 12px;">GALAXY SIMULATION v2.1</div>
            </div>

            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Galactic Cycle</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <button class="mp-toggle-btn" onclick="toggleMultiplayerPanel()">
                    üåê ONLINE <span id="online-count" class="online-count" style="display:none;">0</span>
                </button>
                <button class="action-btn" onclick="openSavePanel('save')" style="background: #555; color: #fff;">üíæ SAVE</button>
                <button class="action-btn" onclick="openSavePanel('load')" style="background: #555; color: #fff;">üìÇ LOAD</button>
                <button class="action-btn" onclick="returnToGalaxy()">‚¨Ö LEAVE PLANET</button>
            </div>
        </div>

        <div id="world-info" class="world-info">
            <div id="biome-name" class="biome-name">Terra World</div>
            <div class="time-display">
                <span id="time-icon" class="time-icon">‚òÄÔ∏è</span>
                <span id="time-text">Day</span>
            </div>
        </div>

        <div id="minimap" class="minimap" style="display:none;">
            <canvas id="minimap-canvas" width="150" height="150"></canvas>
        </div>

        <div id="tooltip" class="context-tooltip">
            <div class="tooltip-name">Target</div>
            <div class="tooltip-hp"></div>
            <div class="tooltip-hint">Click to interact</div>
        </div>

        <div id="rpg-ui" class="rpg-ui">
            <div class="player-stats">
                <div class="panel-title">Character</div>
                <div class="health-section">
                    <div class="health-bar-container">
                        <span class="health-icon">‚ù§Ô∏è</span>
                        <div class="health-bar-wrapper">
                            <div class="health-bar-bg"><div id="health-bar" class="health-bar-fill"></div></div>
                            <div id="health-text" class="health-text">100 / 100</div>
                        </div>
                    </div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>‚õèÔ∏è Mining</span> <span>Lv. <span id="lvl-mining">1</span></span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background: linear-gradient(to right, #666, #999)"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>ü™ì Woodcutting</span> <span>Lv. <span id="lvl-wood">1</span></span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background: linear-gradient(to right, #a85, #da5)"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>‚öîÔ∏è Combat</span> <span>Lv. <span id="lvl-combat">1</span></span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background: linear-gradient(to right, #a00, #f44)"></div></div>
                </div>
            </div>

            <div class="center-stats">
                <div id="action-text" style="color: #fb0; font-size: 14px; text-align: center;"></div>
            </div>

            <div class="inventory-panel">
                <div class="panel-title">Backpack</div>
                <div class="inv-grid" id="inventory-grid"></div>
            </div>
        </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const CONFIG = {
            // Galaxy
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            STAR_COUNT: 12000,

            // World
            WORLD_SIZE: 80,
            TILE_SIZE: 2,
            TREE_DENSITY: 0.12,
            ROCK_DENSITY: 0.08,

            // Gameplay
            PLAYER_SPEED: 12,
            MOB_SPEED: 4,
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 3,
            MOB_ATTACK_COOLDOWN: 1500,
            RESPAWN_TIME: 15000,
            INTERACT_RANGE: 4,

            // Player
            PLAYER_MAX_HP: 100,
            PLAYER_REGEN_RATE: 0.5,

            // Performance
            MAX_FLOATERS: 20,
            MINIMAP_UPDATE_INTERVAL: 500
        };

        const BIOMES = {
            Terra:    { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, name: 'Terra Prime' },
            Desert:   { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, name: 'Arid Expanse' },
            Ice:      { sky: 0xddeeff, ground: 0xeeffff, tree: 0xaaccff, rock: 0x99aabb, name: 'Frozen Tundra' },
            Alien:    { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, name: 'Xenoscape' },
            Volcanic: { sky: 0x330000, ground: 0x332211, tree: 0x552222, rock: 0x444444, name: 'Magma Core' }
        };

        const ITEMS = {
            Log:   { icon: 'ü™µ', color: '#da5' },
            Ore:   { icon: 'ü™®', color: '#888' },
            Slime: { icon: 'üü¢', color: '#0f0' },
            Fang:  { icon: 'ü¶∑', color: '#eee' },
            Scale: { icon: 'üî∑', color: '#48f' }
        };

        const MOB_TYPES = {
            Slime: {
                color: 0x44dd44,
                hp: 10,
                damage: 5,
                xp: 75,
                drop: 'Slime',
                speed: 1,
                size: 1
            },
            Wolf: {
                color: 0x666666,
                hp: 20,
                damage: 10,
                xp: 150,
                drop: 'Fang',
                speed: 1.8,
                size: 0.9
            },
            Dragon: {
                color: 0x8844ff,
                hp: 50,
                damage: 20,
                xp: 400,
                drop: 'Scale',
                speed: 1.2,
                size: 1.5
            }
        };

        // ============================================================
        // UTILITY CLASSES
        // ============================================================
        class SeededRNG {
            constructor(seed) {
                this.seed = typeof seed === 'string' ? this.hash(seed) : seed;
            }
            hash(str) {
                let h = 0;
                for(let i = 0; i < str.length; i++) {
                    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
                }
                return Math.abs(h) || 1;
            }
            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max + 1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Improved noise function with octaves
        class SimplexNoise {
            constructor(seed = 'default') {
                this.rng = new SeededRNG(seed);
                this.perm = [];
                for(let i = 0; i < 256; i++) this.perm[i] = i;
                for(let i = 255; i > 0; i--) {
                    const j = Math.floor(this.rng.next() * (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                this.perm = [...this.perm, ...this.perm];
            }

            noise2D(x, z) {
                const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
                const lerp = (a, b, t) => a + t * (b - a);
                const grad = (hash, x, z) => {
                    const h = hash & 3;
                    const u = h < 2 ? x : z;
                    const v = h < 2 ? z : x;
                    return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
                };

                const X = Math.floor(x) & 255;
                const Z = Math.floor(z) & 255;
                const xf = x - Math.floor(x);
                const zf = z - Math.floor(z);
                const u = fade(xf);
                const v = fade(zf);

                const aa = this.perm[this.perm[X] + Z];
                const ab = this.perm[this.perm[X] + Z + 1];
                const ba = this.perm[this.perm[X + 1] + Z];
                const bb = this.perm[this.perm[X + 1] + Z + 1];

                return lerp(
                    lerp(grad(aa, xf, zf), grad(ba, xf - 1, zf), u),
                    lerp(grad(ab, xf, zf - 1), grad(bb, xf - 1, zf - 1), u),
                    v
                );
            }

            octaveNoise(x, z, octaves = 4, persistence = 0.5) {
                let total = 0, frequency = 1, amplitude = 1, maxValue = 0;
                for(let i = 0; i < octaves; i++) {
                    total += this.noise2D(x * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }
                return total / maxValue;
            }
        }

        // Object Pool for floaters
        class FloaterPool {
            constructor(maxSize) {
                this.pool = [];
                this.maxSize = maxSize;
                for(let i = 0; i < maxSize; i++) {
                    const el = document.createElement('div');
                    el.className = 'floater';
                    el.style.display = 'none';
                    document.body.appendChild(el);
                    this.pool.push({ el, inUse: false });
                }
            }

            spawn(pos, text, color = '#fff') {
                const item = this.pool.find(p => !p.inUse);
                if(!item) return;

                item.inUse = true;
                item.el.textContent = text;
                item.el.style.color = color;
                item.el.style.display = 'block';
                item.el.classList.remove('animate');

                // Project position
                const v = pos.clone();
                v.y += 2;
                v.project(camera);

                const x = (v.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-v.y * 0.5 + 0.5) * window.innerHeight;

                item.el.style.left = x + 'px';
                item.el.style.top = y + 'px';

                // Trigger animation
                void item.el.offsetWidth;
                item.el.classList.add('animate');

                setTimeout(() => {
                    item.el.style.display = 'none';
                    item.inUse = false;
                }, 1400);
            }
        }

        // Particle System
        class ParticleSystem {
            constructor(container) {
                this.container = container;
                this.particles = [];
                this.maxParticles = 50;
            }

            spawn(pos, type, color, count = 5) {
                const v = pos.clone();
                v.project(camera);
                const screenX = (v.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-v.y * 0.5 + 0.5) * window.innerHeight;

                for(let i = 0; i < count; i++) {
                    if(this.particles.length >= this.maxParticles) {
                        const old = this.particles.shift();
                        old.remove();
                    }

                    const p = document.createElement('div');
                    p.className = `particle ${type}`;
                    p.style.backgroundColor = color;
                    p.style.left = (screenX + (Math.random() - 0.5) * 30) + 'px';
                    p.style.top = (screenY + (Math.random() - 0.5) * 30) + 'px';

                    this.container.appendChild(p);
                    this.particles.push(p);

                    setTimeout(() => {
                        p.remove();
                        this.particles = this.particles.filter(x => x !== p);
                    }, type === 'spark' ? 600 : 1000);
                }
            }

            clear() {
                this.particles.forEach(p => p.remove());
                this.particles = [];
            }
        }

        // Save/Load System
        const SaveSystem = {
            STORAGE_KEY: 'leviathan_saves',
            MAX_SLOTS: 3,

            getSaves() {
                try {
                    return JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || {};
                } catch(e) {
                    return {};
                }
            },

            save(slot) {
                if(mode !== 'world' || !activeCiv) return false;

                const saves = this.getSaves();
                saves[slot] = {
                    timestamp: Date.now(),
                    civId: activeCiv.id,
                    civName: activeCiv.name,
                    biome: activeCiv.biome,
                    playerPos: {
                        x: worldState.playerMesh.position.x,
                        y: worldState.playerMesh.position.y,
                        z: worldState.playerMesh.position.z
                    },
                    hp: worldState.hp,
                    inventory: { ...worldState.inventory },
                    skills: JSON.parse(JSON.stringify(worldState.skills)),
                    timeOfDay: worldState.timeOfDay
                };

                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(saves));
                    return true;
                } catch(e) {
                    console.error('Save failed:', e);
                    return false;
                }
            },

            load(slot) {
                const saves = this.getSaves();
                const data = saves[slot];
                if(!data) return false;

                // Find the civilization
                const civ = civilizations.find(c => c.id === data.civId);
                if(!civ) return false;

                // Initialize the world
                initWorld(civ);

                // Restore state
                setTimeout(() => {
                    worldState.playerMesh.position.set(data.playerPos.x, data.playerPos.y, data.playerPos.z);
                    worldState.hp = data.hp;
                    worldState.inventory = { ...data.inventory };
                    worldState.skills = JSON.parse(JSON.stringify(data.skills));
                    worldState.timeOfDay = data.timeOfDay;

                    updateHealthUI();
                    updateInventoryUI();
                    Object.keys(worldState.skills).forEach(updateSkillUI);
                }, 100);

                return true;
            },

            delete(slot) {
                const saves = this.getSaves();
                delete saves[slot];
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(saves));
            },

            formatDate(timestamp) {
                const d = new Date(timestamp);
                return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
        };

        // ============================================================
        // GLOBAL STATE
        // ============================================================
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let lastTime = 0;
        let galacticCycle = 0;
        let floaterPool;
        let particleSystem;
        let minimapCtx;
        let lastMinimapUpdate = 0;
        let noise;
        let savePanelMode = 'save';

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let starField;

        // World State
        const worldState = {
            player: null,
            playerMesh: null,
            hp: CONFIG.PLAYER_MAX_HP,
            maxHp: CONFIG.PLAYER_MAX_HP,
            terrain: [],
            heightMap: [],
            interactables: [],
            mobs: [],
            groundMesh: null,
            sun: null,
            ambient: null,
            timeOfDay: 0.25,
            inventory: {},
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 }
            },
            target: null,
            interactTarget: null,
            respawnQueue: [],
            lastDamageTime: 0,
            isActioning: false,
            actionTimer: 0
        };

        // Helper to create capsule geometry (fallback for older Three.js)
        function createCapsuleGeometry(radius, height, capSegments, radialSegments) {
            // Check if CapsuleGeometry exists (Three.js r133+)
            if(THREE.CapsuleGeometry) {
                return new THREE.CapsuleGeometry(radius, height, capSegments, radialSegments);
            }
            // Fallback: use cylinder with hemisphere caps
            const geo = new THREE.CylinderGeometry(radius, radius, height, radialSegments, 1, true);
            const topCap = new THREE.SphereGeometry(radius, radialSegments, capSegments, 0, Math.PI * 2, 0, Math.PI / 2);
            const bottomCap = new THREE.SphereGeometry(radius, radialSegments, capSegments, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);

            topCap.translate(0, height / 2, 0);
            bottomCap.translate(0, -height / 2, 0);

            // Merge geometries
            const merged = new THREE.BufferGeometry();
            const positions = [];
            const normals = [];

            [geo, topCap, bottomCap].forEach(g => {
                const pos = g.attributes.position.array;
                const norm = g.attributes.normal.array;
                for(let i = 0; i < pos.length; i++) positions.push(pos[i]);
                for(let i = 0; i < norm.length; i++) normals.push(norm[i]);
            });

            merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            merged.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

            return merged;
        }

        // Geometry cache (initialized after Three.js loads)
        let geometryCache;

        // ============================================================
        // INITIALIZATION
        // ============================================================
        async function init() {
            updateLoadingProgress(10, 'Creating renderer...');

            // Initialize geometry cache now that Three.js is loaded
            geometryCache = {
                trunk: new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                leaves: new THREE.ConeGeometry(1.2, 2.5, 8),
                rock: new THREE.DodecahedronGeometry(1),
                mob: new THREE.SphereGeometry(0.8, 12, 12),
                player: createCapsuleGeometry(0.6, 1.5, 4, 8),
                healthBar: new THREE.PlaneGeometry(2, 0.3)
            };

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            updateLoadingProgress(30, 'Initializing systems...');

            // Object pool
            floaterPool = new FloaterPool(CONFIG.MAX_FLOATERS);

            // Particle system
            particleSystem = new ParticleSystem(document.getElementById('particle-layer'));

            // Minimap
            minimapCtx = document.getElementById('minimap-canvas').getContext('2d');

            updateLoadingProgress(50, 'Generating galaxy...');

            // Events
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('contextmenu', e => e.preventDefault());

            await initGalaxy();

            updateLoadingProgress(100, 'Ready!');

            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                requestAnimationFrame(loop);
            }, 500);
        }

        function updateLoadingProgress(percent, text) {
            document.getElementById('loading-fill').style.width = percent + '%';
            document.getElementById('loading-text').textContent = text;
        }

        // ============================================================
        // GALAXY MODE
        // ============================================================
        async function initGalaxy() {
            mode = 'galaxy';
            disposeWorld();

            scene.fog = new THREE.FogExp2(0x000510, 0.00015);
            scene.background = new THREE.Color(0x000510);

            // Ambient
            scene.add(new THREE.AmbientLight(0x222233));

            // Core glow
            const coreLight = new THREE.PointLight(0x4488ff, 2, 2000);
            coreLight.position.set(0, 0, 0);
            scene.add(coreLight);

            // Starfield with varying sizes
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starSizes = [];
            const rng = new SeededRNG('STARFIELD');

            for(let i = 0; i < CONFIG.STAR_COUNT; i++) {
                const r = 1500 + rng.next() * 1500;
                const theta = rng.next() * Math.PI * 2;
                const phi = Math.acos(2 * rng.next() - 1);
                starPos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                starSizes.push(rng.range(1, 3));
            }

            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));

            const starMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                sizeAttenuation: true
            });
            starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);

            // Galaxy dust clouds
            const dustGeo = new THREE.BufferGeometry();
            const dustPos = [];
            for(let i = 0; i < 2000; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(100, 1000);
                const spiral = angle + dist * 0.003;
                dustPos.push(
                    Math.cos(spiral) * dist,
                    rng.range(-30, 30),
                    Math.sin(spiral) * dist
                );
            }
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
            const dustMat = new THREE.PointsMaterial({
                color: 0x4466aa,
                size: 8,
                transparent: true,
                opacity: 0.3
            });
            const dustCloud = new THREE.Points(dustGeo, dustMat);
            scene.add(dustCloud);

            // Civilizations
            const civRng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();

            for(let i = 0; i < CONFIG.NUM_CIVS; i++) {
                const angle = civRng.next() * Math.PI * 2;
                const dist = civRng.range(150, 900);
                const spiralAngle = angle + dist * 0.002;
                const x = Math.cos(spiralAngle) * dist;
                const z = Math.sin(spiralAngle) * dist;
                const y = civRng.range(-50, 50) * (1 - dist / 1000);

                const hue = civRng.next();
                const color = new THREE.Color().setHSL(hue, 0.8, 0.5);

                const civ = {
                    id: i, x, y, z, color, hue,
                    name: `${civRng.pick(['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta'])}-${civRng.int(100, 999)}`,
                    biome: civRng.pick(Object.keys(BIOMES)),
                    pop: civRng.int(1, 100)
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x, y, z);

                // Star
                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(6 + civ.pop * 0.03, 16, 16),
                    new THREE.MeshBasicMaterial({ color })
                );
                sysGroup.add(star);

                // Glow layers
                for(let g = 0; g < 2; g++) {
                    const glow = new THREE.Mesh(
                        new THREE.SphereGeometry(12 + g * 6, 16, 16),
                        new THREE.MeshBasicMaterial({
                            color,
                            transparent: true,
                            opacity: 0.15 - g * 0.05
                        })
                    );
                    sysGroup.add(glow);
                }

                // Orbiting planet (visual only)
                const planet = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: BIOMES[civ.biome].ground })
                );
                planet.position.x = 15;
                planet.userData.orbitAngle = civRng.next() * Math.PI * 2;
                planet.userData.orbitSpeed = civRng.range(0.5, 1.5);
                sysGroup.add(planet);

                sysGroup.userData = { type: 'civ', data: civ, planet };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            // Selection ring
            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(18, 21, 32),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })
            );
            selectionRing.rotation.x = Math.PI / 2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            // Camera
            camera.position.set(0, 800, 1200);
            camera.lookAt(0, 0, 0);

            // UI
            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('world-info').style.display = 'none';
            document.getElementById('civ-count').textContent = CONFIG.NUM_CIVS;
            document.getElementById('subtitle').textContent = 'GALAXY SIMULATION v2.1';
        }

        function disposeWorld() {
            // Clean up world-specific objects
            while(scene.children.length > 0) {
                const obj = scene.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                scene.remove(obj);
            }

            worldState.interactables = [];
            worldState.mobs = [];
            worldState.respawnQueue = [];
            worldState.terrain = [];
            worldState.heightMap = [];
        }

        // ============================================================
        // WORLD MODE
        // ============================================================
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';
            disposeWorld();

            const biome = BIOMES[civ.biome];
            noise = new SimplexNoise(civ.name);

            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 30, 150);

            // Lighting
            worldState.ambient = new THREE.AmbientLight(0x404060, 0.4);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1.2);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -60;
            worldState.sun.shadow.camera.right = 60;
            worldState.sun.shadow.camera.top = 60;
            worldState.sun.shadow.camera.bottom = -60;
            worldState.sun.shadow.mapSize.width = 2048;
            worldState.sun.shadow.mapSize.height = 2048;
            worldState.sun.shadow.bias = -0.0001;
            scene.add(worldState.sun);

            // Hemisphere light for better ambient
            const hemi = new THREE.HemisphereLight(biome.sky, biome.ground, 0.3);
            scene.add(hemi);

            // Generate terrain using instanced mesh for performance
            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.heightMap = [];

            // Calculate heights first
            for(let x = 0; x < CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                worldState.heightMap[x] = [];
                for(let z = 0; z < CONFIG.WORLD_SIZE; z++) {
                    const nx = (x - CONFIG.WORLD_SIZE / 2) * 0.05;
                    const nz = (z - CONFIG.WORLD_SIZE / 2) * 0.05;
                    const hVal = noise.octaveNoise(nx + civ.id, nz + civ.id, 4, 0.5);
                    const height = Math.floor((hVal + 1) * 2.5);
                    const isWater = height < 1;

                    worldState.terrain[x][z] = isWater ? -99 : height * CONFIG.TILE_SIZE / 2 + CONFIG.TILE_SIZE / 2;
                    worldState.heightMap[x][z] = height;
                }
            }

            // Create ground mesh (single plane with vertex displacement)
            const groundGeo = new THREE.PlaneGeometry(
                CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE,
                CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE,
                CONFIG.WORLD_SIZE - 1,
                CONFIG.WORLD_SIZE - 1
            );
            groundGeo.rotateX(-Math.PI / 2);

            const positions = groundGeo.attributes.position.array;
            const colors = new Float32Array(positions.length);

            for(let i = 0; i < positions.length; i += 3) {
                const x = Math.round((positions[i] / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
                const z = Math.round((positions[i + 2] / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

                if(x >= 0 && x < CONFIG.WORLD_SIZE && z >= 0 && z < CONFIG.WORLD_SIZE) {
                    const h = worldState.heightMap[x][z];
                    const isWater = h < 1;
                    positions[i + 1] = isWater ? -1 : h * CONFIG.TILE_SIZE / 2;

                    const col = isWater ? new THREE.Color(0x224488) : new THREE.Color(biome.ground);
                    if(!isWater && h > 4) col.multiplyScalar(0.8); // Mountain shading
                    colors[i] = col.r;
                    colors[i + 1] = col.g;
                    colors[i + 2] = col.b;
                }
            }

            groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            groundGeo.computeVertexNormals();

            const groundMat = new THREE.MeshLambertMaterial({
                vertexColors: true,
                flatShading: true
            });

            worldState.groundMesh = new THREE.Mesh(groundGeo, groundMat);
            worldState.groundMesh.receiveShadow = true;
            scene.add(worldState.groundMesh);

            // Spawn props
            for(let x = 0; x < CONFIG.WORLD_SIZE; x++) {
                for(let z = 0; z < CONFIG.WORLD_SIZE; z++) {
                    if(worldState.terrain[x][z] > 0) {
                        const roll = rng.next();
                        if(roll < CONFIG.TREE_DENSITY) {
                            const wx = (x - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
                            const wz = (z - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
                            createProp('tree', wx, worldState.terrain[x][z], wz, biome, rng);
                        } else if(roll < CONFIG.TREE_DENSITY + CONFIG.ROCK_DENSITY) {
                            const wx = (x - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
                            const wz = (z - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
                            createProp('rock', wx, worldState.terrain[x][z], wz, biome, rng);
                        }
                    }
                }
            }

            // Player
            const playerMat = new THREE.MeshStandardMaterial({
                color: 0xffdd44,
                roughness: 0.5,
                metalness: 0.2
            });
            worldState.playerMesh = new THREE.Mesh(geometryCache.player, playerMat);
            worldState.playerMesh.position.set(0, 15, 0);
            worldState.playerMesh.castShadow = true;

            // Player indicator ring
            const ringGeo = new THREE.RingGeometry(0.8, 1, 16);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = -0.75;
            worldState.playerMesh.add(ring);

            scene.add(worldState.playerMesh);

            // Reset player state
            worldState.hp = worldState.maxHp;
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();

            // Spawn mobs
            for(let i = 0; i < 8; i++) {
                createMob(rng, biome);
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('rpg-ui').style.display = 'flex';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('world-info').style.display = 'block';
            document.getElementById('biome-name').textContent = biome.name;
            document.getElementById('subtitle').textContent = `LANDED: ${civ.name}`;

            updateInventoryUI();
            updateMinimap();
        }

        function createProp(type, x, y, z, biome, rng) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    geometryCache.trunk,
                    new THREE.MeshLambertMaterial({ color: 0x664422 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    geometryCache.leaves,
                    new THREE.MeshLambertMaterial({ color: biome.tree })
                );
                leaves.position.y = 2.8;
                leaves.castShadow = true;
                leaves.scale.set(1 + rng.next() * 0.3, 1 + rng.next() * 0.3, 1 + rng.next() * 0.3);
                group.add(leaves);

                group.userData = {
                    type: 'tree',
                    hp: 3,
                    maxHp: 3,
                    name: 'Ancient Tree',
                    gridX: Math.round(x / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2),
                    gridZ: Math.round(z / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2)
                };
            } else {
                const rock = new THREE.Mesh(
                    geometryCache.rock,
                    new THREE.MeshLambertMaterial({ color: biome.rock })
                );
                rock.position.y = 0.5;
                rock.rotation.set(rng.next() * 2, rng.next() * 2, rng.next() * 2);
                rock.scale.setScalar(0.7 + rng.next() * 0.5);
                rock.castShadow = true;
                group.add(rock);

                group.userData = {
                    type: 'rock',
                    hp: 3,
                    maxHp: 3,
                    name: 'Ore Vein',
                    gridX: Math.round(x / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2),
                    gridZ: Math.round(z / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2)
                };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createMob(rng, biome, forcedType = null) {
            const mob = new THREE.Group();

            // Select mob type based on combat level or random
            const combatLevel = worldState.skills.combat.level;
            let mobTypeName;
            if(forcedType) {
                mobTypeName = forcedType;
            } else {
                const roll = rng.next();
                if(combatLevel >= 10 && roll < 0.15) {
                    mobTypeName = 'Dragon';
                } else if(combatLevel >= 5 && roll < 0.4) {
                    mobTypeName = 'Wolf';
                } else {
                    mobTypeName = 'Slime';
                }
            }

            const mobType = MOB_TYPES[mobTypeName];

            // Body
            const body = new THREE.Mesh(
                geometryCache.mob,
                new THREE.MeshStandardMaterial({
                    color: mobType.color,
                    roughness: 0.3,
                    transparent: mobTypeName === 'Slime',
                    opacity: mobTypeName === 'Slime' ? 0.9 : 1
                })
            );
            body.castShadow = true;
            body.scale.setScalar(mobType.size);
            mob.add(body);

            // Eyes (different for each type)
            const eyeGeo = new THREE.SphereGeometry(0.15 * mobType.size, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: mobTypeName === 'Dragon' ? 0xff4400 : 0xffffff });
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const eyeOffsets = mobTypeName === 'Wolf' ? [-0.2, 0.2] : [-0.25, 0.25];
            eyeOffsets.forEach(offset => {
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(offset * mobType.size, 0.2 * mobType.size, 0.6 * mobType.size);
                mob.add(eye);

                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.08 * mobType.size, 6, 6), pupilMat);
                pupil.position.set(offset * mobType.size, 0.2 * mobType.size, 0.7 * mobType.size);
                mob.add(pupil);
            });

            // Wolf ears
            if(mobTypeName === 'Wolf') {
                const earGeo = new THREE.ConeGeometry(0.15, 0.4, 4);
                const earMat = new THREE.MeshLambertMaterial({ color: mobType.color });
                [-0.3, 0.3].forEach(offset => {
                    const ear = new THREE.Mesh(earGeo, earMat);
                    ear.position.set(offset, 0.7, 0);
                    ear.rotation.z = offset > 0 ? -0.3 : 0.3;
                    mob.add(ear);
                });
            }

            // Dragon wings
            if(mobTypeName === 'Dragon') {
                const wingGeo = new THREE.ConeGeometry(0.8, 1.5, 3);
                const wingMat = new THREE.MeshLambertMaterial({ color: 0x6622aa });
                [-1, 1].forEach(side => {
                    const wing = new THREE.Mesh(wingGeo, wingMat);
                    wing.position.set(side * 0.8, 0.3, -0.3);
                    wing.rotation.z = side * Math.PI / 3;
                    wing.rotation.x = -0.3;
                    mob.add(wing);
                });
            }

            // Health bar background
            const hpBg = new THREE.Mesh(
                geometryCache.healthBar,
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            hpBg.position.y = 1.5 * mobType.size;
            hpBg.rotation.x = 0;
            mob.add(hpBg);

            // Health bar fill
            const hpFill = new THREE.Mesh(
                geometryCache.healthBar,
                new THREE.MeshBasicMaterial({ color: 0x44ff44 })
            );
            hpFill.position.y = 1.5 * mobType.size;
            hpFill.position.z = 0.01;
            mob.add(hpFill);

            // Random position
            let rx, rz, attempts = 0;
            do {
                rx = (rng.next() - 0.5) * CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE * 0.7;
                rz = (rng.next() - 0.5) * CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE * 0.7;
                attempts++;
            } while(getTerrainHeight(rx, rz) < 0 && attempts < 20);

            mob.position.set(rx, 10, rz);

            mob.userData = {
                type: 'mob',
                mobType: mobTypeName,
                hp: mobType.hp,
                maxHp: mobType.hp,
                damage: mobType.damage,
                xp: mobType.xp,
                drop: mobType.drop,
                speedMult: mobType.speed,
                name: mobTypeName,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpFill,
                state: 'idle'
            };

            scene.add(mob);
            worldState.mobs.push(mob);
        }

        // ============================================================
        // GAME LOOP
        // ============================================================
        function loop(time) {
            requestAnimationFrame(loop);

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            if(mode === 'galaxy') {
                updateGalaxy(time, dt);
            } else if(mode === 'world') {
                updateWorld(time, dt);
            }

            renderer.render(scene, camera);
        }

        function updateGalaxy(time, dt) {
            // Rotate galaxy slowly
            galaxyGroup.rotation.y += 0.0005;
            starField.rotation.y -= 0.0001;

            // Update cycle counter
            galacticCycle += dt;
            document.getElementById('cycle-count').textContent = Math.floor(galacticCycle);

            // Animate planets orbiting stars
            galaxyGroup.children.forEach(system => {
                if(system.userData.planet) {
                    const planet = system.userData.planet;
                    planet.userData.orbitAngle += planet.userData.orbitSpeed * dt;
                    planet.position.x = Math.cos(planet.userData.orbitAngle) * 15;
                    planet.position.z = Math.sin(planet.userData.orbitAngle) * 15;
                }
            });

            // Selection ring pulse
            if(selectionRing.visible) {
                selectionRing.rotation.z -= 0.02;
                const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                selectionRing.scale.set(pulse, pulse, 1);
            }
        }

        function updateWorld(time, dt) {
            const player = worldState.playerMesh;
            const biome = BIOMES[activeCiv.biome];

            // 1. Day/Night Cycle
            worldState.timeOfDay = (worldState.timeOfDay + dt * 0.01) % 1;
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 100;

            worldState.sun.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle) * radius,
                50
            );

            const dayFactor = Math.max(0, Math.sin(angle));
            worldState.sun.intensity = dayFactor * 1.2;
            worldState.ambient.intensity = 0.2 + dayFactor * 0.3;

            // Sky color transition
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x0a0a20);
            scene.background.lerpColors(nightColor, dayColor, dayFactor);
            scene.fog.color.copy(scene.background);

            // Update time UI
            const isDay = worldState.timeOfDay > 0.2 && worldState.timeOfDay < 0.8;
            document.getElementById('time-icon').textContent = isDay ? '‚òÄÔ∏è' : 'üåô';
            document.getElementById('time-text').textContent = isDay ? 'Day' : 'Night';

            // 2. Player Movement
            if(worldState.target) {
                const dir = new THREE.Vector3().subVectors(worldState.target, player.position);
                dir.y = 0;
                const dist = dir.length();

                if(dist > 0.5) {
                    dir.normalize();
                    player.position.add(dir.multiplyScalar(CONFIG.PLAYER_SPEED * dt));

                    // Face direction
                    const lookTarget = player.position.clone().add(dir);
                    player.lookAt(lookTarget.x, player.position.y, lookTarget.z);
                } else {
                    worldState.target = null;
                }
            }

            // Snap to ground
            snapToGround(player);

            // 3. Interaction
            if(worldState.interactTarget && !worldState.isActioning) {
                const t = worldState.interactTarget;
                const dist = player.position.distanceTo(t.position);

                if(dist < CONFIG.INTERACT_RANGE) {
                    worldState.target = null;
                    worldState.isActioning = true;
                    worldState.actionTimer = 0;

                    const actionName = t.userData.type === 'tree' ? 'Chopping...' :
                                       t.userData.type === 'rock' ? 'Mining...' : 'Attacking...';
                    document.getElementById('action-text').textContent = actionName;
                } else if(!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // Action tick
            if(worldState.isActioning && worldState.interactTarget) {
                worldState.actionTimer += dt;
                if(worldState.actionTimer >= 0.8) {
                    worldState.actionTimer = 0;
                    performAction(worldState.interactTarget);
                }
            }

            // 4. Camera Follow
            const camOffset = new THREE.Vector3(0, 25, 25);
            camera.position.lerp(player.position.clone().add(camOffset), 0.08);
            camera.lookAt(player.position);

            // 5. Mob AI
            worldState.mobs.forEach(mob => {
                if(mob.userData.hp <= 0) return;

                const distToPlayer = mob.position.distanceTo(player.position);

                // Health bar always face camera
                mob.children.forEach(child => {
                    if(child.geometry === geometryCache.healthBar) {
                        child.lookAt(camera.position);
                    }
                });

                // Aggro check
                if(distToPlayer < CONFIG.MOB_AGGRO_RANGE) {
                    mob.userData.state = 'chase';
                    mob.userData.targetPos.copy(player.position);

                    // Attack if in range
                    if(distToPlayer < CONFIG.MOB_ATTACK_RANGE && time > mob.userData.nextAttack) {
                        mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                        const damage = mob.userData.damage || 5;
                        damagePlayer(damage);
                        floaterPool.spawn(player.position, `-${damage}`, '#ff4444');
                    }
                } else if(mob.userData.state === 'chase') {
                    mob.userData.state = 'idle';
                }

                // Idle wandering
                if(mob.userData.state === 'idle' && time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random() - 0.5) * 15,
                        0,
                        mob.position.z + (Math.random() - 0.5) * 15
                    );
                    mob.userData.nextMove = time + 2000 + Math.random() * 3000;
                }

                // Movement
                const mobDir = new THREE.Vector3().subVectors(mob.userData.targetPos, mob.position);
                mobDir.y = 0;
                const mobDist = mobDir.length();
                const speedMult = mob.userData.speedMult || 1;
                const speed = (mob.userData.state === 'chase' ? CONFIG.MOB_SPEED * 1.5 : CONFIG.MOB_SPEED) * speedMult;

                if(mobDist > (mob.userData.state === 'chase' ? CONFIG.MOB_ATTACK_RANGE * 0.8 : 0.5)) {
                    mobDir.normalize();
                    mob.position.add(mobDir.multiplyScalar(speed * dt));

                    // Bounce animation
                    mob.position.y += Math.sin(time * 0.01) * 0.02;
                }

                snapToGround(mob);
            });

            // 6. Respawn queue
            worldState.respawnQueue = worldState.respawnQueue.filter(item => {
                if(time >= item.time) {
                    if(item.type === 'prop') {
                        createProp(item.propType, item.x, getTerrainHeight(item.x, item.z), item.z, biome, new SeededRNG(Date.now().toString()));
                    } else if(item.type === 'mob') {
                        createMob(new SeededRNG(Date.now().toString()), biome);
                    }
                    return false;
                }
                return true;
            });

            // 7. Player regen
            if(worldState.hp < worldState.maxHp && time - worldState.lastDamageTime > 5000) {
                worldState.hp = Math.min(worldState.maxHp, worldState.hp + CONFIG.PLAYER_REGEN_RATE * dt);
                updateHealthUI();
            }

            // 8. Minimap update
            if(time - lastMinimapUpdate > CONFIG.MINIMAP_UPDATE_INTERVAL) {
                updateMinimap();
                lastMinimapUpdate = time;
            }
        }

        function getTerrainHeight(worldX, worldZ) {
            const gx = Math.round(worldX / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2);
            const gz = Math.round(worldZ / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2);

            if(gx >= 0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                return worldState.terrain[gx][gz];
            }
            return 0;
        }

        function snapToGround(obj) {
            const y = getTerrainHeight(obj.position.x, obj.position.z);
            if(y > -50) {
                const targetY = y + (obj.userData.type === 'mob' ? 0.8 : 1.5);
                obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.2);
            }
        }

        function performAction(target) {
            const data = target.userData;

            // Combat level bonus
            const combatLevel = worldState.skills.combat.level;
            const damage = 1 + Math.floor(combatLevel / 5);

            data.hp -= damage;

            // Visual feedback
            floaterPool.spawn(target.position, `‚àí${damage}`, data.type === 'mob' ? '#ff8844' : '#ffff00');

            // Spawn particles based on action type
            if(data.type === 'tree') {
                particleSystem.spawn(target.position, 'dust', '#8B4513', 3);
            } else if(data.type === 'rock') {
                particleSystem.spawn(target.position, 'spark', '#aaa', 4);
            } else if(data.type === 'mob') {
                particleSystem.spawn(target.position, 'spark', '#ff4444', 3);
            }

            target.scale.setScalar(0.85);
            setTimeout(() => target.scale.setScalar(1), 100);

            // Update mob health bar
            if(data.type === 'mob' && data.hpFill) {
                const hpPercent = Math.max(0, data.hp / data.maxHp);
                data.hpFill.scale.x = hpPercent;
                data.hpFill.position.x = -(1 - hpPercent);

                // Color based on HP
                const color = hpPercent > 0.5 ? 0x44ff44 : hpPercent > 0.25 ? 0xffff00 : 0xff4444;
                data.hpFill.material.color.setHex(color);
            }

            if(data.hp <= 0) {
                worldState.isActioning = false;
                document.getElementById('action-text').textContent = '';

                if(data.type === 'tree') {
                    addItem('Log');
                    addXp('wood', 35);
                    floaterPool.spawn(target.position, '+1 Log', ITEMS.Log.color);
                    particleSystem.spawn(target.position, 'dust', '#8B4513', 8);
                    queueRespawn('prop', 'tree', target.position.x, target.position.z);
                } else if(data.type === 'rock') {
                    addItem('Ore');
                    addXp('mining', 40);
                    floaterPool.spawn(target.position, '+1 Ore', ITEMS.Ore.color);
                    particleSystem.spawn(target.position, 'spark', '#888', 10);
                    queueRespawn('prop', 'rock', target.position.x, target.position.z);
                } else if(data.type === 'mob') {
                    const dropItem = data.drop || 'Slime';
                    const xpAmount = data.xp || 75;
                    addItem(dropItem);
                    addXp('combat', xpAmount);
                    floaterPool.spawn(target.position, `+1 ${dropItem}`, ITEMS[dropItem]?.color || '#fff');
                    particleSystem.spawn(target.position, 'spark', '#44ff44', 12);
                    queueRespawn('mob', null, 0, 0);
                    worldState.mobs = worldState.mobs.filter(m => m !== target);
                }

                if(data.type !== 'mob') {
                    worldState.interactables = worldState.interactables.filter(i => i !== target);
                }

                scene.remove(target);
                worldState.interactTarget = null;
            }
        }

        function queueRespawn(type, propType, x, z) {
            worldState.respawnQueue.push({
                type,
                propType,
                x, z,
                time: performance.now() + CONFIG.RESPAWN_TIME
            });
        }

        function damagePlayer(amount) {
            worldState.hp = Math.max(0, worldState.hp - amount);
            worldState.lastDamageTime = performance.now();
            updateHealthUI();

            // Screen flash
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);

            // Screen shake
            document.getElementById('container').classList.add('shake');
            setTimeout(() => document.getElementById('container').classList.remove('shake'), 200);

            if(worldState.hp <= 0) {
                // Player death - respawn
                floaterPool.spawn(worldState.playerMesh.position, 'RESPAWNING...', '#ff0000');
                worldState.hp = worldState.maxHp;
                worldState.playerMesh.position.set(0, 15, 0);
                worldState.target = null;
                worldState.interactTarget = null;
                worldState.isActioning = false;
                updateHealthUI();
            }
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');
            document.body.style.cursor = 'default';

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        const biome = BIOMES[civ.biome];

                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 15 + 'px';
                        tooltip.style.top = e.clientY + 15 + 'px';
                        tooltip.innerHTML = `
                            <div class="tooltip-name">${civ.name}</div>
                            <div style="color:#888">${biome.name} World</div>
                            <div class="tooltip-hint">Click to land</div>
                        `;
                        document.body.style.cursor = 'pointer';

                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
                selectionRing.visible = false;
            } else if(mode === 'world') {
                const targets = [...worldState.interactables, ...worldState.mobs];
                const hits = raycaster.intersectObjects(targets, true);

                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && !obj.userData.type) obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 15 + 'px';
                        tooltip.style.top = e.clientY + 15 + 'px';

                        const hpText = obj.userData.hp !== undefined ?
                            `<div class="tooltip-hp">HP: ${obj.userData.hp}/${obj.userData.maxHp}</div>` : '';

                        tooltip.innerHTML = `
                            <div class="tooltip-name">${obj.userData.name}</div>
                            ${hpText}
                            <div class="tooltip-hint">Click to interact</div>
                        `;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
        }

        function onMouseDown(e) {
            if(e.button !== 0) return; // Left click only

            raycaster.setFromCamera(mouse, camera);

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        initWorld(obj.userData.data);
                    }
                }
            } else if(mode === 'world') {
                // Check interactables first
                const targets = [...worldState.interactables, ...worldState.mobs];
                const hits = raycaster.intersectObjects(targets, true);

                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && !obj.userData.type) obj = obj.parent;

                    if(obj.userData.type) {
                        worldState.interactTarget = obj;
                        worldState.isActioning = false;
                        document.getElementById('action-text').textContent = '';
                        return;
                    }
                }

                // Ground click - move
                const groundHits = raycaster.intersectObject(worldState.groundMesh);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;

                    // Check if valid terrain
                    if(getTerrainHeight(pt.x, pt.z) > 0) {
                        worldState.target = pt;
                        worldState.interactTarget = null;
                        worldState.isActioning = false;
                        document.getElementById('action-text').textContent = '';

                        // Click marker
                        const marker = new THREE.Mesh(
                            new THREE.RingGeometry(0.4, 0.6, 16),
                            new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                        );
                        marker.rotation.x = -Math.PI / 2;
                        marker.position.copy(pt);
                        marker.position.y += 0.2;
                        scene.add(marker);

                        setTimeout(() => scene.remove(marker), 400);
                    }
                }
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            initGalaxy();
        }

        // ============================================================
        // UI SYSTEMS
        // ============================================================
        function addItem(name) {
            if(!worldState.inventory[name]) {
                worldState.inventory[name] = 0;
            }
            worldState.inventory[name]++;
            updateInventoryUI();
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            Object.entries(worldState.inventory).forEach(([name, count]) => {
                if(count > 0) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot';
                    slot.innerHTML = `${ITEMS[name]?.icon || '?'}<div class="inv-count">${count}</div>`;
                    slot.title = name;
                    grid.appendChild(slot);
                }
            });

            // Fill empty slots
            const emptySlots = 16 - grid.children.length;
            for(let i = 0; i < emptySlots; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }
        }

        function addXp(skill, amount) {
            const s = worldState.skills[skill];
            s.xp += amount;

            // Level up check (quadratic formula)
            const newLevel = Math.floor(Math.sqrt(s.xp / 80)) + 1;
            if(newLevel > s.level) {
                s.level = newLevel;
                floaterPool.spawn(worldState.playerMesh.position, `LEVEL UP! ${skill.toUpperCase()} ${newLevel}`, '#ffff00');

                // Level up flash effect
                const flash = document.getElementById('level-up-flash');
                flash.classList.add('active');
                setTimeout(() => flash.classList.remove('active'), 500);

                // Particles burst
                particleSystem.spawn(worldState.playerMesh.position, 'spark', '#ffd700', 15);
            }

            updateSkillUI(skill);
        }

        function updateSkillUI(skill) {
            const s = worldState.skills[skill];
            const prevLevelXp = Math.pow(s.level - 1, 2) * 80;
            const nextLevelXp = Math.pow(s.level, 2) * 80;
            const progress = ((s.xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

            const elId = skill === 'mining' ? 'lvl-mining' : skill === 'wood' ? 'lvl-wood' : 'lvl-combat';
            const barId = skill === 'mining' ? 'bar-mining' : skill === 'wood' ? 'bar-wood' : 'bar-combat';

            document.getElementById(elId).textContent = s.level;
            document.getElementById(barId).style.width = progress + '%';
        }

        function updateHealthUI() {
            const percent = (worldState.hp / worldState.maxHp) * 100;
            document.getElementById('health-bar').style.width = percent + '%';
            document.getElementById('health-text').textContent =
                `${Math.ceil(worldState.hp)} / ${worldState.maxHp}`;
        }

        function updateMinimap() {
            if(!minimapCtx || mode !== 'world') return;

            const size = 150;
            const scale = size / (CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE);

            minimapCtx.fillStyle = '#111';
            minimapCtx.fillRect(0, 0, size, size);

            // Draw terrain (simplified)
            const biome = BIOMES[activeCiv.biome];
            const step = 4;

            for(let x = 0; x < CONFIG.WORLD_SIZE; x += step) {
                for(let z = 0; z < CONFIG.WORLD_SIZE; z += step) {
                    const h = worldState.terrain[x]?.[z];
                    if(h > 0) {
                        minimapCtx.fillStyle = '#' + biome.ground.toString(16).padStart(6, '0');
                    } else {
                        minimapCtx.fillStyle = '#224';
                    }

                    const px = x * CONFIG.TILE_SIZE * scale;
                    const py = z * CONFIG.TILE_SIZE * scale;
                    minimapCtx.fillRect(px, py, step * CONFIG.TILE_SIZE * scale, step * CONFIG.TILE_SIZE * scale);
                }
            }

            // Draw mobs
            minimapCtx.fillStyle = '#f44';
            worldState.mobs.forEach(mob => {
                const mx = (mob.position.x / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE * scale;
                const mz = (mob.position.z / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(mx, mz, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Draw player
            if(worldState.playerMesh) {
                const px = (worldState.playerMesh.position.x / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE * scale;
                const pz = (worldState.playerMesh.position.z / CONFIG.TILE_SIZE + CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE * scale;

                minimapCtx.fillStyle = '#ff0';
                minimapCtx.beginPath();
                minimapCtx.arc(px, pz, 5, 0, Math.PI * 2);
                minimapCtx.fill();

                minimapCtx.strokeStyle = '#fff';
                minimapCtx.lineWidth = 2;
                minimapCtx.stroke();
            }
        }

        // ============================================================
        // SAVE/LOAD UI
        // ============================================================
        function openSavePanel(mode) {
            savePanelMode = mode;
            const panel = document.getElementById('save-panel');
            const title = document.getElementById('save-panel-title');
            const slotsContainer = document.getElementById('save-slots');

            title.textContent = mode === 'save' ? 'Save Game' : 'Load Game';

            const saves = SaveSystem.getSaves();
            slotsContainer.innerHTML = '';

            for(let i = 1; i <= SaveSystem.MAX_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'save-slot';

                const saveData = saves[i];
                if(saveData) {
                    slot.innerHTML = `
                        <div class="slot-name">Slot ${i}: ${saveData.civName}</div>
                        <div class="slot-info">${BIOMES[saveData.biome]?.name || saveData.biome} ‚Ä¢ ${SaveSystem.formatDate(saveData.timestamp)}</div>
                    `;
                    slot.onclick = () => handleSlotClick(i, mode);
                } else {
                    slot.className += ' empty';
                    slot.innerHTML = `<div class="slot-name">Slot ${i}: Empty</div>`;
                    if(mode === 'save') {
                        slot.onclick = () => handleSlotClick(i, mode);
                    }
                }

                slotsContainer.appendChild(slot);
            }

            panel.classList.add('visible');
        }

        function closeSavePanel() {
            document.getElementById('save-panel').classList.remove('visible');
        }

        function handleSlotClick(slot, mode) {
            if(mode === 'save') {
                if(SaveSystem.save(slot)) {
                    floaterPool.spawn(worldState.playerMesh.position, 'GAME SAVED!', '#44ff44');
                    closeSavePanel();
                } else {
                    floaterPool.spawn(worldState.playerMesh.position, 'SAVE FAILED!', '#ff4444');
                }
            } else {
                if(SaveSystem.load(slot)) {
                    floaterPool.spawn(worldState.playerMesh.position, 'GAME LOADED!', '#44ff44');
                    closeSavePanel();
                } else {
                    floaterPool.spawn(worldState.playerMesh.position, 'LOAD FAILED!', '#ff4444');
                }
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if(mode !== 'world') return;

            // ESC to close panels
            if(e.key === 'Escape') {
                closeSavePanel();
            }
            // F5 quick save
            if(e.key === 'F5') {
                e.preventDefault();
                if(SaveSystem.save(1)) {
                    floaterPool.spawn(worldState.playerMesh.position, 'QUICK SAVED!', '#44ff44');
                }
            }
            // F9 quick load
            if(e.key === 'F9') {
                e.preventDefault();
                if(SaveSystem.load(1)) {
                    floaterPool.spawn(worldState.playerMesh.position, 'QUICK LOADED!', '#44ff44');
                }
            }
        });

        // ============================================================
        // START
        // ============================================================
        init();
    </script>
</body>
</html>
