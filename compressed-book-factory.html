<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Autonomous Book Factory</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: ui-monospace, monospace;
      background: #0a0e1a;
      color: #eaf2ff;
      height: 100vh;
      overflow: hidden;
    }
    
    .header {
      position: fixed; top: 0; left: 0; right: 0; height: 60px; z-index: 1000;
      background: rgba(0,0,0,0.9); border-bottom: 1px solid #333;
      display: flex; align-items: center; justify-content: between;
      padding: 0 16px; backdrop-filter: blur(6px);
    }
    
    .title { color: #77ffc4; font-size: 18px; font-weight: 700; }
    .subtitle { color: #999; font-size: 12px; }
    
    .toolbar { display: flex; gap: 8px; margin-left: auto; }
    .btn { 
      background: #1a2332; color: #eaf2ff; border: 1px solid #2b3950; 
      border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 12px;
    }
    .btn:hover { border-color: #4a5568; }
    .btn.primary { background: #1476ff; border: 0; }
    
    .main-container {
      position: fixed; top: 60px; left: 0; right: 0; bottom: 0;
      display: grid; grid-template-columns: 300px 1fr 300px; gap: 16px;
      padding: 16px;
    }
    
    .panel {
      background: rgba(16,22,33,0.95); border: 1px solid #20314d; 
      border-radius: 12px; padding: 12px; overflow: auto;
    }
    
    .overseer { border-color: #ff8c00; }
    .overseer-avatar { 
      width: 60px; height: 60px; margin: 0 auto 8px; border-radius: 50%;
      background: #ff8c00; display: flex; align-items: center; justify-content: center;
      font-size: 24px; animation: glow 3s ease-in-out infinite;
    }
    @keyframes glow { 0%,100% { box-shadow: 0 0 10px #ff8c00; } 50% { box-shadow: 0 0 20px #ff8c00; } }
    
    .thoughts { 
      background: rgba(255,140,0,0.1); border: 1px solid rgba(255,140,0,0.3);
      border-radius: 8px; padding: 8px; min-height: 100px; max-height: 200px; 
      overflow: auto; margin-top: 12px;
    }
    .thought { 
      color: #ffd36d; margin-bottom: 6px; padding: 6px; 
      background: rgba(0,0,0,0.3); border-radius: 4px; font-style: italic; font-size: 12px;
    }
    
    .phase { 
      background: rgba(255,140,0,0.1); border: 1px solid rgba(255,140,0,0.4);
      border-radius: 8px; padding: 8px; margin-top: 8px;
    }
    .phase-label { color: #ff9e4a; font-size: 10px; text-transform: uppercase; margin-bottom: 4px; }
    .phase-value { font-weight: 700; color: #ffd36d; }
    
    .center-panel {
      display: flex; flex-direction: column; gap: 12px;
    }
    
    .prompt-input {
      width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #2b3950;
      background: rgba(12,17,25,0.95); color: #eaf2ff; font-size: 14px;
      resize: vertical; min-height: 80px;
    }
    
    .workers {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;
      flex: 1; overflow: auto;
    }
    
    .worker {
      background: linear-gradient(180deg, rgba(16,22,33,0.95), rgba(10,14,22,0.95));
      border: 1px solid #2a3d5d; border-radius: 8px; padding: 8px;
      display: flex; flex-direction: column; align-items: center; min-height: 140px;
    }
    .worker.planner { border-color: #ff8c00; }
    .worker.researcher { border-color: #00d9ff; }
    .worker.outliner { border-color: #6ecbff; }
    .worker.writer { border-color: #ff6347; }
    .worker.editor { border-color: #4ecdc4; }
    .worker.fact { border-color: #a78bfa; }
    .worker.qa { border-color: #a3e635; }
    .worker.publisher { border-color: #ffe66d; }
    
    .avatar {
      width: 40px; height: 40px; border-radius: 50%; margin-bottom: 6px;
      display: flex; align-items: center; justify-content: center; font-size: 18px;
    }
    .avatar.planner { background: #ff8c00; }
    .avatar.researcher { background: #00d9ff; }
    .avatar.outliner { background: #6ecbff; }
    .avatar.writer { background: #ff6347; }
    .avatar.editor { background: #4ecdc4; }
    .avatar.fact { background: #a78bfa; }
    .avatar.qa { background: #a3e635; }
    .avatar.publisher { background: #ffe66d; }
    
    .worker-name { font-size: 11px; font-weight: 700; text-align: center; margin-bottom: 4px; }
    .worker-status { 
      display: flex; align-items: center; gap: 4px; font-size: 10px; margin-bottom: 6px;
    }
    .dot { width: 6px; height: 6px; border-radius: 50%; background: #64748b; }
    .dot.ok { background: #22c55e; }
    .dot.warn { background: #fbbf24; }
    .dot.err { background: #ef4444; }
    
    .task { 
      font-size: 10px; color: #00e5ff; background: rgba(0,229,255,0.1); 
      border: 1px solid rgba(0,229,255,0.3); border-radius: 4px; padding: 4px; 
      text-align: center; flex: 1; display: flex; align-items: center;
    }
    
    .right-panel { display: flex; flex-direction: column; gap: 12px; }
    
    .book-status { border-color: #1db954; }
    .book-title { text-align: center; color: #77ffc4; font-size: 16px; font-weight: 700; margin-bottom: 8px; }
    .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px; }
    .stat { background: rgba(16,190,120,0.1); border: 1px solid rgba(16,190,120,0.3); border-radius: 6px; padding: 6px; }
    .stat-label { font-size: 10px; color: #9fb2cf; }
    .stat-value { color: #77ffc4; font-weight: 700; margin-top: 2px; font-size: 12px; }
    
    .chapters { display: flex; flex-direction: column; gap: 4px; max-height: 300px; overflow: auto; }
    .chapter {
      background: rgba(0,0,0,0.3); border: 1px solid rgba(16,190,120,0.2); 
      border-radius: 6px; padding: 6px;
    }
    .chapter-header { display: flex; justify-content: between; align-items: center; margin-bottom: 4px; }
    .chapter-title { color: #77ffc4; font-size: 11px; font-weight: 700; }
    .chapter-words { color: #9fb2cf; font-size: 10px; }
    .progress { height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #16e08f, #00d9ff); transition: width 0.3s; }
    
    .memory-panel { border-color: #7b1fa2; }
    .memory-label { color: #d993ff; font-size: 10px; text-transform: uppercase; }
    .memory-count { color: #d993ff; font-size: 24px; font-weight: 800; margin-top: 4px; }
    
    .modal {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000;
      display: none; align-items: center; justify-content: center;
    }
    .modal.active { display: flex; }
    .modal-content {
      background: #0a0e1a; border: 1px solid #2a3d5d; border-radius: 12px;
      padding: 20px; max-width: 80vw; max-height: 80vh; overflow: auto;
      width: 600px;
    }
    .modal-header { text-align: center; margin-bottom: 16px; }
    .modal-title { color: #ffd36d; font-size: 20px; font-weight: 700; }
    .modal-body { white-space: pre-wrap; line-height: 1.6; }
    .close-btn { 
      position: absolute; top: 10px; right: 10px; background: #ef4444; color: #fff;
      border: 0; border-radius: 50%; width: 30px; height: 30px; cursor: pointer;
    }
    
    .controls { position: fixed; bottom: 16px; right: 16px; display: flex; gap: 8px; z-index: 1000; }
    .control-btn {
      width: 40px; height: 40px; border-radius: 50%; background: #1476ff; color: #fff;
      border: 0; cursor: pointer; font-size: 16px;
    }
    
    .progress-indicator {
      position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.9); border: 1px solid #2a3d5d; border-radius: 8px;
      padding: 8px 16px; z-index: 1500; display: none; font-size: 12px;
    }
    .progress-indicator.active { display: flex; align-items: center; gap: 8px; }
    .mini-spinner { 
      width: 16px; height: 16px; border: 2px solid rgba(90,169,255,0.3); 
      border-top: 2px solid #5aa9ff; border-radius: 50%; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    .run-controls {
      position: fixed; bottom: 70px; right: 16px; display: none; flex-direction: column; gap: 8px; z-index: 1000;
    }
    .run-controls.active { display: flex; }
    .control-btn.small {
      width: 32px; height: 32px; font-size: 12px;
    }
    
    .toast {
      position: fixed; top: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.9); border: 1px solid #2a3d5d; border-radius: 8px;
      color: #eaf2ff; padding: 8px 12px; z-index: 4000; display: none; font-size: 12px;
    }
    
    @media (max-width: 1200px) {
      .main-container { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div>
      <div class="title">Autonomous Book Factory</div>
      <div class="subtitle">Claude API Simulation</div>
    </div>
    <div class="toolbar">
      <button class="btn" onclick="app.showModal('transcript')">Log</button>
      <button class="btn" onclick="app.showModal('settings')">Settings</button>
      <button class="btn" onclick="app.importState()">Import</button>
      <button class="btn primary" onclick="app.run()">Run</button>
    </div>
  </div>

  <div class="main-container">
    <div class="panel overseer">
      <div class="overseer-avatar">üëÅÔ∏è</div>
      <div style="text-align: center; font-weight: 700; color: #ffd36d;">OVERSEER</div>
      <div style="text-align: center; color: #ff9e4a; font-size: 11px;">Production Coordinator</div>
      <div class="thoughts" id="thoughts"></div>
      <div class="phase">
        <div class="phase-label">Current Phase</div>
        <div class="phase-value" id="phase">Idle</div>
      </div>
    </div>

    <div class="center-panel">
      <textarea class="prompt-input" id="prompt" placeholder="Describe your book project. Double-click for random example."></textarea>
      <div class="workers" id="workers"></div>
    </div>

    <div class="right-panel">
      <div class="panel memory-panel">
        <div class="memory-label">Core Memories</div>
        <div class="memory-count" id="memory-count">0</div>
      </div>
      
      <div class="panel book-status">
        <div class="book-title" id="book-title">Awaiting Project</div>
        <div class="stats">
          <div class="stat">
            <div class="stat-label">Genre</div>
            <div class="stat-value" id="genre">‚Äî</div>
          </div>
          <div class="stat">
            <div class="stat-label">Words</div>
            <div class="stat-value" id="word-count">0</div>
          </div>
        </div>
        <div class="chapters" id="chapters"></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <button class="control-btn" onclick="app.showOutput()" title="View Manuscript">üìñ</button>
    <button class="control-btn" onclick="app.export()" title="Export Current State">üíæ</button>
  </div>

  <div class="run-controls" id="run-controls">
    <button class="control-btn small" onclick="app.pause()" title="Pause">‚è∏Ô∏è</button>
    <button class="control-btn small" onclick="app.resume()" title="Resume">‚ñ∂Ô∏è</button>
    <button class="control-btn small" onclick="app.abort()" title="Abort">‚èπÔ∏è</button>
  </div>

  <div class="progress-indicator" id="progress-indicator">
    <div class="mini-spinner"></div>
    <span id="progress-text">Processing...</span>
  </div>

  <div class="loading" id="loading">
    <div>
      <div class="spinner"></div>
      <div style="margin-top: 12px; text-align: center;">Running Production...</div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modal-content">
      <button class="close-btn" onclick="app.hideModal()">√ó</button>
      <div class="modal-header">
        <div class="modal-title" id="modal-title"></div>
      </div>
      <div class="modal-body" id="modal-body"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    class BookFactory {
      constructor() {
        this.state = {
          universe: {
            metadata: { id: Date.now(), created: new Date().toISOString(), version: "1.0" },
            agents: {},
            simulation: { phase: "idle", cycle: 0, chapters: [], drafts: {}, finals: {}, manuscript: "" },
            settings: { chapters: 6, wordsPerChapter: 800, maxCycles: 1, houseStyle: "" },
            history: []
          }
        };
        
        this.paused = false;
        this.aborted = false;
        this.samples = [
          "Write 'The Remote Leader's Playbook' - practical guide for managing distributed teams. Include frameworks, case studies, and tools. Audience: managers. Tone: professional, actionable.",
          "Create 'Digital Minimalism for Parents' - helping families manage screen time and technology. Evidence-based advice with real stories. Audience: parents of kids 8-16.",
          "Develop 'The Solo Developer's Guide to Success' - complete handbook covering coding, marketing, business for indie developers. Include code examples and launch strategies.",
          "Write 'Creative Recovery: From Burnout to Breakthrough' - guide for artists, writers, designers dealing with creative blocks and career pivots.",
          "Create 'Urban Foraging 101' - finding edible plants in cities. Safety protocols, seasonal guides, recipes, legal considerations. Educational and enthusiastic tone."
        ];
        
        this.workers = [
          { key: 'planner', name: 'PLANNER', avatar: 'üìã' },
          { key: 'researcher', name: 'RESEARCH', avatar: 'üîé' },
          { key: 'outliner', name: 'OUTLINER', avatar: 'üóÇÔ∏è' },
          { key: 'writer', name: 'WRITER', avatar: '‚úèÔ∏è' },
          { key: 'editor', name: 'EDITOR', avatar: 'üìù' },
          { key: 'fact', name: 'FACT', avatar: 'üìö' },
          { key: 'qa', name: 'QA', avatar: '‚úÖ' },
          { key: 'publisher', name: 'PUBLISH', avatar: 'üöÄ' }
        ];
        
        this.init();
      }

      init() {
        this.loadSettings();
        this.mountWorkers();
        this.bindEvents();
        
        // Try to restore previous state on load
        if (this.loadCurrentState()) {
          this.toast('Previous session restored');
        }
      }

      bindEvents() {
        document.getElementById('prompt').addEventListener('dblclick', () => this.randomPrompt());
        document.getElementById('prompt').addEventListener('focus', (e) => {
          if (!e.target.value.trim()) this.randomPrompt();
        });
      }

      randomPrompt() {
        const prompt = this.samples[Math.floor(Math.random() * this.samples.length)];
        document.getElementById('prompt').value = prompt;
        this.toast('Random scenario loaded!');
      }

      mountWorkers() {
        const container = document.getElementById('workers');
        container.innerHTML = '';
        this.workers.forEach(w => {
          const div = document.createElement('div');
          div.className = `worker ${w.key}`;
          div.innerHTML = `
            <div class="avatar ${w.key}">${w.avatar}</div>
            <div class="worker-name">${w.name}</div>
            <div class="worker-status">
              <div class="dot" id="dot-${w.key}"></div>
              <span id="status-${w.key}">idle</span>
            </div>
            <div class="task" id="task-${w.key}">Ready</div>
          `;
          container.appendChild(div);
        });
      }

      setWorker(key, status, task) {
        const dot = document.getElementById(`dot-${key}`);
        const statusEl = document.getElementById(`status-${key}`);
        const taskEl = document.getElementById(`task-${key}`);
        
        dot.className = `dot ${status}`;
        statusEl.textContent = status;
        if (task) taskEl.textContent = task;
      }

      think(text, memory = false) {
        const thoughts = document.getElementById('thoughts');
        const div = document.createElement('div');
        div.className = 'thought';
        div.textContent = text;
        thoughts.appendChild(div);
        thoughts.scrollTop = thoughts.scrollHeight;
        
        if (memory) {
          const count = document.getElementById('memory-count');
          count.textContent = parseInt(count.textContent) + 1;
        }
      }

      setPhase(phase) {
        document.getElementById('phase').textContent = phase;
        this.state.universe.simulation.phase = phase;
      }

      updateBook(title, genre) {
        if (title) document.getElementById('book-title').textContent = title;
        if (genre) document.getElementById('genre').textContent = genre;
      }

      updateWordCount() {
        const total = Object.values(this.state.universe.simulation.finals)
          .join(' ').split(/\s+/).filter(Boolean).length;
        document.getElementById('word-count').textContent = total.toLocaleString();
      }

      drawChapters() {
        const container = document.getElementById('chapters');
        container.innerHTML = '';
        this.state.universe.simulation.chapters.forEach((ch, i) => {
          const div = document.createElement('div');
          div.className = 'chapter';
          div.innerHTML = `
            <div class="chapter-header">
              <div class="chapter-title">${i + 1}. ${ch.title}</div>
              <div class="chapter-words" id="words-${ch.id}">0</div>
            </div>
            <div class="progress">
              <div class="progress-fill" id="progress-${ch.id}" style="width: 0%"></div>
            </div>
          `;
          container.appendChild(div);
        });
      }

      setChapterProgress(id, percent, words) {
        const progress = document.getElementById(`progress-${id}`);
        const wordsEl = document.getElementById(`words-${id}`);
        if (progress) progress.style.width = percent + '%';
        if (wordsEl && words) wordsEl.textContent = words + ' words';
      }

      async callClaude(role, prompt) {
        try {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 3000,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) throw new Error(`API Error: ${response.status}`);
          const data = await response.json();
          const result = data.content[0].text;
          
          // Update universe state
          if (!this.state.universe.agents[role]) {
            this.state.universe.agents[role] = { outputs: [], memory: [] };
          }
          this.state.universe.agents[role].outputs.push({ content: result, timestamp: new Date().toISOString() });
          this.state.universe.history.push({ role: 'user', content: prompt }, { role: 'assistant', content: result });
          
          return result;
        } catch (error) {
          this.toast(`Error: ${error.message}`);
          return this.fallback(role);
        }
      }

      fallback(role) {
        const fallbacks = {
          planner: JSON.stringify({
            chapters: Array.from({ length: this.state.universe.settings.chapters }, (_, i) => ({
              id: `C${i + 1}`,
              title: `Chapter ${i + 1}: Key Topic`
            }))
          }),
          default: `[${role}] Simulated output for demonstration`
        };
        return fallbacks[role] || fallbacks.default;
      }

      parseJSON(text) {
        try {
          const match = text.match(/\{[\s\S]*\}/);
          return match ? JSON.parse(match[0]) : null;
        } catch { return null; }
      }

      pause() {
        this.paused = true;
        this.showProgress('Production paused - you can still export current state');
        this.toast('Production paused. Export available.');
      }

      resume() {
        this.paused = false;
        this.showProgress('Resuming production...');
        this.toast('Production resumed');
      }

      abort() {
        this.aborted = true;
        this.paused = false;
        this.hideProgress();
        document.getElementById('run-controls').classList.remove('active');
        this.toast('Production stopped. Current progress preserved.');
      }

      showProgress(text = 'Processing...') {
        document.getElementById('progress-indicator').classList.add('active');
        document.getElementById('progress-text').textContent = text;
        document.getElementById('run-controls').classList.add('active');
      }

      hideProgress() {
        document.getElementById('progress-indicator').classList.remove('active');
        document.getElementById('run-controls').classList.remove('active');
      }

      async waitForControl() {
        while (this.paused && !this.aborted) {
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        if (this.aborted) throw new Error('Aborted');
      }

      saveCurrentState() {
        // Auto-save current state every few seconds during production
        const stateJson = JSON.stringify(this.state.universe, null, 2);
        localStorage.setItem('bookFactoryCurrentState', stateJson);
      }

      loadCurrentState() {
        const saved = localStorage.getItem('bookFactoryCurrentState');
        if (saved) {
          try {
            this.state.universe = JSON.parse(saved);
            this.restoreUI();
            return true;
          } catch (e) {
            console.error('Failed to load state:', e);
          }
        }
        return false;
      }

      restoreUI() {
        // Restore UI from loaded state
        const sim = this.state.universe.simulation;
        
        if (sim.chapters.length > 0) {
          this.drawChapters();
          
          // Restore chapter progress
          sim.chapters.forEach(ch => {
            if (sim.finals[ch.id]) {
              const words = sim.finals[ch.id].split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(ch.id, 100, words);
            } else if (sim.drafts[ch.id]) {
              const words = sim.drafts[ch.id].split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(ch.id, 50, words);
            }
          });
        }

        // Restore book meta
        if (sim.bookTitle) this.updateBook(sim.bookTitle, sim.bookGenre);
        this.updateWordCount();
        
        // Restore phase
        this.setPhase(sim.phase || 'Loaded');
        
        // Show memory count
        const memoryCount = Object.values(this.state.universe.agents || {})
          .reduce((sum, agent) => sum + (agent.memory?.length || 0), 0);
        document.getElementById('memory-count').textContent = memoryCount;

        this.toast('State restored successfully');
      }

      importState() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                this.state.universe = JSON.parse(event.target.result);
                this.restoreUI();
                this.toast('Universe imported and restored');
              } catch (error) {
                this.toast('Import failed: Invalid JSON format');
              }
            };
            reader.readAsText(file);
          }
        };
        input.click();
      }

      async run() {
        const prompt = document.getElementById('prompt').value.trim();
        if (!prompt) return this.toast('Enter a project description');

        // Check if we should resume from saved state
        if (this.state.universe.simulation.phase !== 'idle' && this.state.universe.simulation.chapters.length > 0) {
          if (!confirm('Continue from current progress, or start fresh?')) {
            this.state.universe.simulation = {
              phase: "running", cycle: 0, chapters: [], drafts: {}, finals: {}, manuscript: ""
            };
          }
        }

        this.showProgress('Initializing production...');
        this.aborted = false;
        this.paused = false;

        try {
          // Store the current prompt for later use
          this.state.universe.simulation.prompt = prompt;
          this.state.universe.simulation.bookTitle = this.extractTitle(prompt);
          this.state.universe.simulation.bookGenre = this.extractGenre(prompt);

          // Phase 1: Planning (skip if we already have chapters)
          if (this.state.universe.simulation.chapters.length === 0) {
            this.setPhase('Planning');
            this.showProgress('Planning book structure...');
            this.think('Analyzing project requirements');
            this.setWorker('planner', 'warn', 'Planning structure');

            const planPrompt = `Create a book plan. Return JSON with "chapters" array containing objects with "id" and "title" fields. Make ${this.state.universe.settings.chapters} chapters for: ${prompt}`;
            const planText = await this.callClaude('planner', planPrompt);
            const plan = this.parseJSON(planText);
            
            if (plan?.chapters) {
              this.state.universe.simulation.chapters = plan.chapters.slice(0, this.state.universe.settings.chapters);
            } else {
              this.state.universe.simulation.chapters = Array.from({ length: this.state.universe.settings.chapters }, (_, i) => ({
                id: `C${i + 1}`,
                title: `Chapter ${i + 1}: Core Topic`
              }));
            }

            this.drawChapters();
            this.setWorker('planner', 'ok', 'Plan complete');
            this.updateBook(this.state.universe.simulation.bookTitle, this.state.universe.simulation.bookGenre);
            this.saveCurrentState(); // Save after planning
          }

          await this.waitForControl();

          // Phase 2: Content Creation (resume from where we left off)
          this.setPhase('Content Production');
          for (const chapter of this.state.universe.simulation.chapters) {
            // Skip chapters that are already completed
            if (this.state.universe.simulation.finals[chapter.id]) {
              continue;
            }

            await this.waitForControl();
            this.showProgress(`Processing: ${chapter.title}`);

            // Research (skip if already done)
            if (!this.state.universe.simulation.research?.[chapter.id]) {
              this.setWorker('researcher', 'warn', `Research: ${chapter.title}`);
              const research = await this.callClaude('researcher', 
                `Research brief for "${chapter.title}" in context of: ${prompt}. Provide key points, sources, and insights in 200 words.`);
              
              if (!this.state.universe.simulation.research) this.state.universe.simulation.research = {};
              this.state.universe.simulation.research[chapter.id] = research;
              this.setWorker('researcher', 'ok', 'Research done');
              this.saveCurrentState();
            }

            // Outline (skip if already done)
            if (!this.state.universe.simulation.outlines?.[chapter.id]) {
              this.setWorker('outliner', 'warn', `Outline: ${chapter.title}`);
              const outline = await this.callClaude('outliner',
                `Create chapter outline for "${chapter.title}". Research: ${this.state.universe.simulation.research[chapter.id]}. Provide 6-8 bullet points covering main topics and flow.`);
              
              if (!this.state.universe.simulation.outlines) this.state.universe.simulation.outlines = {};
              this.state.universe.simulation.outlines[chapter.id] = outline;
              this.setWorker('outliner', 'ok', 'Outline ready');
              this.saveCurrentState();
            }

            // Write (skip if already done)
            if (!this.state.universe.simulation.drafts[chapter.id]) {
              this.setWorker('writer', 'warn', `Writing: ${chapter.title}`);
              const draft = await this.callClaude('writer',
                `Write chapter "${chapter.title}" using this outline: ${this.state.universe.simulation.outlines[chapter.id]}. Target ${this.state.universe.settings.wordsPerChapter} words. Return markdown content only.`);
              
              this.state.universe.simulation.drafts[chapter.id] = draft;
              const words = draft.split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(chapter.id, 50, words);
              this.setWorker('writer', 'ok', 'Draft complete');
              this.updateWordCount();
              this.saveCurrentState();
            }

            await this.waitForControl();

            // Edit (only if not already done)
            if (!this.state.universe.simulation.finals[chapter.id]) {
              this.setWorker('editor', 'warn', `Editing: ${chapter.title}`);
              const edited = await this.callClaude('editor',
                `Edit this chapter for clarity and flow. Return only the improved markdown content: ${this.state.universe.simulation.drafts[chapter.id]}`);
              
              this.state.universe.simulation.finals[chapter.id] = edited;
              const finalWords = edited.split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(chapter.id, 100, finalWords);
              this.setWorker('editor', 'ok', 'Edit complete');
              this.updateWordCount();
              this.saveCurrentState(); // Save after each chapter completion
            }
          }

          // Phase 3: Compilation (only if not already done)
          if (!this.state.universe.simulation.manuscript) {
            this.setPhase('Compiling Manuscript');
            this.showProgress('Compiling final manuscript...');
            this.setWorker('publisher', 'warn', 'Compiling manuscript');
            
            const title = this.state.universe.simulation.bookTitle;
            const toc = this.state.universe.simulation.chapters.map((ch, i) => `${i + 1}. ${ch.title}`).join('\n');
            const content = this.state.universe.simulation.chapters
              .map((ch, i) => `# Chapter ${i + 1}: ${ch.title}\n\n${this.state.universe.simulation.finals[ch.id] || ''}`)
              .join('\n\n---\n\n');
            
            this.state.universe.simulation.manuscript = `# ${title}\n\n## Table of Contents\n\n${toc}\n\n---\n\n${content}`;
            
            this.setWorker('publisher', 'ok', 'Manuscript ready');
            this.saveCurrentState();
          }
          
          this.setPhase('Complete');
          this.think('Production completed successfully', true);
          this.toast('Book production complete!');

        } catch (error) {
          if (error.message !== 'Aborted') {
            this.toast('Production failed: ' + error.message);
            this.setPhase('Error: ' + error.message);
          } else {
            this.setPhase('Stopped');
          }
        } finally {
          this.hideProgress();
        }
      }

      extractTitle(prompt) {
        const match = prompt.match(/['"]([^'"]+)['"]/);
        return match ? match[1] : prompt.split(' ').slice(1, 6).join(' ');
      }

      extractGenre(prompt) {
        if (/business|management|leadership/.test(prompt)) return 'Business';
        if (/self-help|personal|development/.test(prompt)) return 'Self-Help';
        if (/technical|programming|coding/.test(prompt)) return 'Technical';
        if (/creative|art|design/.test(prompt)) return 'Creative';
        return 'Non-fiction';
      }

      showModal(type) {
        const modal = document.getElementById('modal');
        const title = document.getElementById('modal-title');
        const body = document.getElementById('modal-body');
        
        if (type === 'transcript') {
          title.textContent = 'Production Log';
          body.textContent = this.state.universe.history
            .slice(-20)
            .map(h => `[${h.role.toUpperCase()}] ${h.content.slice(0, 200)}...`)
            .join('\n\n');
        } else if (type === 'settings') {
          title.textContent = 'Settings';
          body.innerHTML = `
            <div style="margin-bottom: 12px;">
              <label>Chapters: </label>
              <input type="number" id="setting-chapters" min="3" max="12" value="${this.state.universe.settings.chapters}">
            </div>
            <div style="margin-bottom: 12px;">
              <label>Words per Chapter: </label>
              <input type="number" id="setting-words" min="300" max="2000" value="${this.state.universe.settings.wordsPerChapter}">
            </div>
            <div style="margin-bottom: 12px;">
              <label>House Style: </label>
              <input type="text" id="setting-style" value="${this.state.universe.settings.houseStyle}" placeholder="clear, engaging, practical">
            </div>
            <button class="btn primary" onclick="app.saveSettings()">Save</button>
          `;
        }
        modal.classList.add('active');
      }

      hideModal() {
        document.getElementById('modal').classList.remove('active');
      }

      saveSettings() {
        this.state.universe.settings.chapters = parseInt(document.getElementById('setting-chapters').value);
        this.state.universe.settings.wordsPerChapter = parseInt(document.getElementById('setting-words').value);
        this.state.universe.settings.houseStyle = document.getElementById('setting-style').value;
        localStorage.setItem('bookFactorySettings', JSON.stringify(this.state.universe.settings));
        this.hideModal();
        this.toast('Settings saved');
      }

      loadSettings() {
        const saved = localStorage.getItem('bookFactorySettings');
        if (saved) {
          this.state.universe.settings = { ...this.state.universe.settings, ...JSON.parse(saved) };
        }
      }

      showOutput() {
        const modal = document.getElementById('modal');
        document.getElementById('modal-title').textContent = 'Generated Manuscript';
        document.getElementById('modal-body').textContent = this.state.universe.simulation.manuscript || 'No manuscript generated yet.';
        modal.classList.add('active');
      }

      export() {
        const json = JSON.stringify(this.state.universe, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `book-factory-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        this.toast('Universe exported');
      }

      showLoading(show) {
        // Removed blocking loading screen - now uses progress indicator instead
      }

      toast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 2500);
      }
    }

    const app = new BookFactory();
    window.app = app;
  </script>
</body>
</html>