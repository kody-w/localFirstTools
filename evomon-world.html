<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EvoMon World: 3D RPG</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .panel {
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid #00ffff;
            padding: 15px;
            border-radius: 12px;
            pointer-events: auto;
            color: #fff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }
        
        /* HUD */
        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }
        
        #player-card {
            width: 250px;
        }
        
        .stat-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        .stat-fill { height: 100%; transition: width 0.3s; }
        .hp-fill { background: #ff4444; }
        .xp-fill { background: #4444ff; }
        
        /* Battle UI */
        #battle-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        
        #battle-box {
            width: 800px;
            height: 500px;
            background: #111;
            border: 4px solid #444;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        #battle-scene {
            flex-grow: 1;
            background: linear-gradient(#223, #112);
            position: relative;
        }
        
        .battler {
            width: 150px;
            height: 150px;
            position: absolute;
            bottom: 50px;
        }
        #player-battler { left: 50px; }
        #enemy-battler { right: 50px; filter: hue-rotate(180deg); } /* Placeholder visual diff */
        
        #battle-controls {
            height: 150px;
            background: #222;
            border-top: 4px solid #444;
            padding: 20px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        
        #battle-log {
            background: #000;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            color: #fff;
            overflow-y: auto;
        }
        
        #action-menu {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.1s;
        }
        button:hover { background: #444; border-color: #fff; }
        button:active { transform: scale(0.98); }
        .btn-attack { border-color: #ff4444; }
        .btn-flee { border-color: #4444ff; }
        
        /* Evolution Modal */
        #evo-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 4px solid #00ffff;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 20;
            color: #fff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }
        
        #mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            overflow: hidden;
        }
        #mm-canvas { width: 100%; height: 100%; }
        
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui-layer">
        <div id="hud-top">
            <div id="player-card" class="panel">
                <h3 style="margin:0">EvoCreature</h3>
                <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-val">1</span></div>
                <div style="font-size: 10px; color: #555;">Input: <span id="debug-key">-</span></div>
                <div class="stat-bar"><div class="stat-fill hp-fill" id="hp-bar" style="width: 100%"></div></div>
                <div class="stat-bar"><div class="stat-fill xp-fill" id="xp-bar" style="width: 0%"></div></div>
            </div>
        </div>
        
        <div id="mini-map">
            <canvas id="mm-canvas"></canvas>
        </div>
    </div>
    
    <div id="battle-overlay">
        <div id="battle-box">
            <div id="battle-scene">
                <div id="player-battler"></div> <!-- Will contain Canvas -->
                <div id="enemy-battler"></div> <!-- Will contain Canvas -->
                
                <div style="position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 0 #000;">
                    <h3>You</h3>
                    <div style="width: 150px; height: 10px; background: #333;"><div id="battle-player-hp" style="width: 100%; height: 100%; background: #0f0;"></div></div>
                </div>
                
                <div style="position: absolute; top: 20px; right: 20px; color: white; text-align: right; text-shadow: 2px 2px 0 #000;">
                    <h3 id="battle-enemy-name">Wild Beast</h3>
                    <div style="width: 150px; height: 10px; background: #333; display: inline-block;"><div id="battle-enemy-hp" style="width: 100%; height: 100%; background: #f00;"></div></div>
                </div>
            </div>
            <div id="battle-controls">
                <div id="battle-log">A wild creature appeared!</div>
                <div id="action-menu">
                    <button class="btn-attack" onclick="game.battleAction('attack')">ATTACK</button>
                    <button onclick="game.battleAction('defend')">DEFEND</button>
                    <button class="btn-flee" onclick="game.battleAction('flee')">FLEE</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="evo-modal">
        <h1 style="color: #00ffff; margin: 0;">EVOLUTION!</h1>
        <div id="evo-canvas-container" style="width: 200px; height: 200px; margin: 20px auto;"></div>
        <p id="evo-text" style="font-size: 18px; margin-bottom: 30px;">Your creature has adapted.</p>
        <button onclick="game.closeEvolution()" style="padding: 10px 30px; font-size: 20px;">CONTINUE</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // --- Game Engine ---
        
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.world = null;
                this.clock = new THREE.Clock();
                this.keys = {};
                this.state = 'roam'; // roam, battle, evolve
                
                this.playerStats = this.loadGame() || {
                    level: 1,
                    xp: 0,
                    hp: 100,
                    maxHp: 100,
                    atk: 10,
                    def: 5,
                    spd: 5,
                    genome: {
                        aggression: 0.5,
                        resilience: 0.5,
                        agility: 0.5,
                        element: 0.5
                    },
                    history: { damageTaken: 0, damageDealt: 0, fled: 0, biomeTime: {} }
                };
                
                this.init();
            }
            
            saveGame() {
                try {
                    localStorage.setItem('evomon_save', JSON.stringify(this.playerStats));
                } catch (e) {
                    if (!this.saveWarningShown) {
                        console.warn("Save failed (Storage Quota/Blocked). Progress will not persist.");
                        this.saveWarningShown = true;
                        
                        const card = document.getElementById('player-card');
                        let err = document.getElementById('save-error');
                        if (!err) {
                            err = document.createElement('div');
                            err.id = 'save-error';
                            err.style.color = '#ff5555';
                            err.style.fontSize = '10px';
                            err.style.marginTop = '5px';
                            err.textContent = 'âš  Saving Disabled (Browser Blocked)';
                            card.appendChild(err);
                        }
                    }
                }
            }
            
            loadGame() {
                try {
                    const save = localStorage.getItem('evomon_save');
                    return save ? JSON.parse(save) : null;
                } catch (e) {
                    console.warn("Failed to load game:", e);
                    return null;
                }
            }
            
            init() {
                // Three.js Setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 60);
                
                // "3DS Style" Camera: High angle, perspective
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 20, 20);
                this.camera.lookAt(0, 0, 0);
                
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                
                // Lights
                const ambient = new THREE.AmbientLight(0x404040, 0.8);
                this.scene.add(ambient);
                
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -50;
                sun.shadow.camera.right = 50;
                sun.shadow.camera.top = 50;
                sun.shadow.camera.bottom = -50;
                this.scene.add(sun);
                
                // Generate World
                this.world = new World(this.scene);
                
                // Spawn Fossils from previous runs (simulated for now)
                this.world.spawnFossils(this.scene);
                
                // Spawn Bosses
                this.world.spawnBosses(this.scene);
                
                // Create Player
                this.player = new Player(this.scene, this.playerStats.genome);
                
                // Find Safe Spawn
                this.findSafeSpawn();
                
                // Input
                window.addEventListener('keydown', e => {
                    this.keys[e.key.toLowerCase()] = true;
                    document.getElementById('debug-key').textContent = e.key; // Debug
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].indexOf(e.code) > -1) {
                        e.preventDefault();
                    }
                });
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
                window.addEventListener('resize', () => this.onResize());
                
                // Start Loop
                this.animate();
            }
            
            findSafeSpawn() {
                // Spiral out from 0,0 until we find land
                let r = 0;
                let angle = 0;
                while(r < 100) {
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const h = this.world.getHeight(x, z);
                    if (h > 0.5) {
                        this.player.mesh.position.set(x, h, z);
                        return;
                    }
                    angle += 0.5;
                    if (angle > Math.PI * 2) {
                        angle = 0;
                        r += 2;
                    }
                }
                // Fallback
                this.player.mesh.position.set(0, 10, 0);
            }

            update(dt) {
                if (this.state === 'roam') {
                    // Movement
                    const speed = 20 * dt; // Increased speed
                    const move = new THREE.Vector3(0, 0, 0);
                    
                    // Debug log for keys
                    // console.log(this.keys);
                    
                    if (this.keys['w'] || this.keys['arrowup']) move.z -= 1;
                    if (this.keys['s'] || this.keys['arrowdown']) move.z += 1;
                    if (this.keys['a'] || this.keys['arrowleft']) move.x -= 1;
                    if (this.keys['d'] || this.keys['arrowright']) move.x += 1;
                    
                    if (move.lengthSq() > 0) {
                        move.normalize().multiplyScalar(speed);
                        
                        // Collision Check (Simple bounds & water)
                        const nextPos = this.player.mesh.position.clone().add(move);
                        const height = this.world.getHeight(nextPos.x, nextPos.z);
                        
                        if (height > 0.5) { // Not water
                            this.player.mesh.position.add(move);
                            this.player.mesh.position.y = height;
                            this.player.mesh.lookAt(this.player.mesh.position.clone().add(move));
                            
                            // Encounter Check
                            if (this.world.isTallGrass(nextPos.x, nextPos.z)) {
                                if (Math.random() < 0.01) { // 1% chance per frame in grass
                                    this.startBattle();
                                }
                            }
                        }
                    }
                    
                    // Camera Follow
                    this.camera.position.x = this.player.mesh.position.x;
                    this.camera.position.z = this.player.mesh.position.z + 20;
                    this.camera.position.y = this.player.mesh.position.y + 20;
                    this.camera.lookAt(this.player.mesh.position);
                    
                    // Update MiniMap
                    this.world.drawMiniMap(this.player.mesh.position.x, this.player.mesh.position.z);
                    
                    // Biome Adaptation Check
                    this.checkBiomeAdaptation(dt);
                    
                    // Boss Collision Check
                    this.checkBossCollision();
                    
                    // Fossil Interaction
                    this.checkFossilInteraction();
                }
                
                this.player.update(dt);
            }
            
            checkBiomeAdaptation(dt) {
                const x = this.player.mesh.position.x;
                const z = this.player.mesh.position.z;
                const biome = this.world.getBiome(x, z);
                
                if (!this.playerStats.history.biomeTime) this.playerStats.history.biomeTime = {};
                if (!this.playerStats.history.biomeTime[biome]) this.playerStats.history.biomeTime[biome] = 0;
                
                this.playerStats.history.biomeTime[biome] += dt;
                
                // Trigger adaptation every 30 seconds in a biome
                if (this.playerStats.history.biomeTime[biome] > 30) {
                    this.playerStats.history.biomeTime[biome] = 0;
                    this.triggerBiomeAdaptation(biome);
                }
            }
            
            triggerBiomeAdaptation(biome) {
                const g = this.playerStats.genome;
                let msg = "";
                
                if (biome === 'snow') {
                    g.resilience = Math.min(1, g.resilience + 0.1);
                    g.element = (g.element * 0.8) + (0.8 * 0.2); // Towards white/blue
                    msg = "Adapted to Cold: Fur Grown";
                } else if (biome === 'desert') {
                    g.resilience = Math.max(0, g.resilience - 0.05);
                    g.agility = Math.min(1, g.agility + 0.1);
                    g.element = (g.element * 0.8) + (0.1 * 0.2); // Towards red/yellow
                    msg = "Adapted to Heat: Scales Grown";
                } else if (biome === 'water') {
                    g.agility = Math.min(1, g.agility + 0.1);
                    g.element = (g.element * 0.8) + (0.6 * 0.2); // Towards blue
                    msg = "Adapted to Water: Fins Grown";
                }
                
                if (msg) {
                    this.state = 'evolve';
                    document.getElementById('evo-modal').style.display = 'block';
                    document.getElementById('evo-text').innerHTML = `Biome Adaptation:<br>${msg}`;
                    this.player.updateMesh(g);
                    this.saveGame();
                }
            }
            
            checkBossCollision() {
                for (let boss of this.world.bosses) {
                    if (boss.mesh.position.distanceTo(this.player.mesh.position) < 3) {
                        this.startBattle(boss);
                        // Move player back slightly to prevent re-trigger
                        this.player.mesh.position.sub(this.player.mesh.getWorldDirection(new THREE.Vector3()).multiplyScalar(2));
                        return;
                    }
                }
            }
            
            checkFossilInteraction() {
                for (let i = this.world.fossils.length - 1; i >= 0; i--) {
                    const f = this.world.fossils[i];
                    if (f.mesh.position.distanceTo(this.player.mesh.position) < 2) {
                        // Absorb DNA
                        this.playerStats.xp += 50;
                        this.playerStats.genome.aggression = (this.playerStats.genome.aggression + f.genome.aggression) / 2;
                        this.playerStats.genome.resilience = (this.playerStats.genome.resilience + f.genome.resilience) / 2;
                        
                        this.scene.remove(f.mesh);
                        this.world.fossils.splice(i, 1);
                        
                        this.state = 'evolve';
                        document.getElementById('evo-modal').style.display = 'block';
                        document.getElementById('evo-text').innerHTML = `Ancient DNA Absorbed!<br>Traits Merged.`;
                        this.player.updateMesh(this.playerStats.genome);
                        this.saveGame();
                    }
                }
            }
            
            startBattle(boss = null) {
                this.state = 'battle';
                this.keys = {}; // Clear input
                
                if (boss) {
                    this.battleEnemy = {
                        name: boss.name,
                        hp: boss.stats.hp,
                        maxHp: boss.stats.maxHp,
                        atk: boss.stats.atk,
                        genome: boss.genome,
                        isBoss: true
                    };
                } else {
                    // Generate Wild Enemy
                    this.battleEnemy = {
                        name: "Wild Beast",
                        hp: 50 + this.playerStats.level * 10,
                        maxHp: 50 + this.playerStats.level * 10,
                        atk: 5 + this.playerStats.level * 2,
                        genome: {
                            aggression: Math.random(),
                            resilience: Math.random(),
                            agility: Math.random(),
                            element: Math.random()
                        }
                    };
                }
                
                // Setup UI
                document.getElementById('battle-overlay').style.display = 'flex';
                document.getElementById('battle-log').textContent = `A ${this.battleEnemy.name} appeared!`;
                document.getElementById('battle-enemy-name').textContent = this.battleEnemy.name;
                document.getElementById('battle-enemy-hp').style.width = '100%';
                
                // Render Battlers
                this.renderBattler('player-battler', this.playerStats.genome);
                this.renderBattler('enemy-battler', this.battleEnemy.genome, true);
            }
            
            battleAction(action) {
                const p = this.playerStats;
                const e = this.battleEnemy;
                const log = document.getElementById('battle-log');
                
                if (action === 'attack') {
                    // Player Attack
                    const dmg = Math.floor(p.atk * (1 + p.genome.aggression));
                    e.hp -= dmg;
                    p.history.damageDealt += dmg;
                    log.innerHTML += `<br>You dealt ${dmg} damage!`;
                    document.getElementById('battle-enemy-hp').style.width = (e.hp/e.maxHp*100) + '%';
                    
                    if (e.hp <= 0) {
                        this.winBattle();
                        return;
                    }
                    
                    // Enemy Attack
                    setTimeout(() => {
                        const eDmg = Math.max(1, Math.floor(e.atk * (1 + e.genome.aggression)) - Math.floor(p.def * p.genome.resilience));
                        p.hp -= eDmg;
                        p.history.damageTaken += eDmg;
                        log.innerHTML += `<br>Enemy dealt ${eDmg} damage!`;
                        this.updateHUD();
                        document.getElementById('battle-player-hp').style.width = (p.hp/p.maxHp*100) + '%';
                        
                        if (p.hp <= 0) {
                            alert("You fainted! Respawning...");
                            location.reload();
                        }
                    }, 500);
                } else if (action === 'flee') {
                    if (Math.random() < p.genome.agility) {
                        p.history.fled++;
                        this.endBattle();
                    } else {
                        log.innerHTML += "<br>Failed to flee!";
                        // Take damage
                        const eDmg = 5;
                        p.hp -= eDmg;
                        this.updateHUD();
                    }
                }
            }
            
            winBattle() {
                const xpGain = 20 + this.playerStats.level * 5;
                this.playerStats.xp += xpGain;
                
                // Check Level Up
                if (this.playerStats.xp >= this.playerStats.level * 100) {
                    this.playerStats.level++;
                    this.playerStats.xp = 0;
                    this.playerStats.maxHp += 10;
                    this.playerStats.hp = this.playerStats.maxHp;
                    this.playerStats.atk += 2;
                }
                
                this.updateHUD();
                this.saveGame();
                
                // Trigger Adaptation
                this.triggerAdaptation();
                
                this.endBattle();
            }
            
            triggerAdaptation() {
                const h = this.playerStats.history;
                const g = this.playerStats.genome;
                let changes = [];
                
                if (h.damageTaken > 20) {
                    g.resilience = Math.min(1, g.resilience + 0.05);
                    changes.push("Skin Hardened");
                }
                if (h.damageDealt > 50) {
                    g.aggression = Math.min(1, g.aggression + 0.05);
                    changes.push("Claws Sharpened");
                }
                if (h.fled > 0) {
                    g.agility = Math.min(1, g.agility + 0.05);
                    changes.push("Legs Strengthened");
                }
                
                // Reset history
                h.damageTaken = 0; h.damageDealt = 0; h.fled = 0;
                
                if (changes.length > 0) {
                    this.state = 'evolve';
                    document.getElementById('evo-modal').style.display = 'block';
                    document.getElementById('evo-text').innerHTML = `Adaptations:<br>${changes.join('<br>')}`;
                    
                    // Re-render player mesh
                    this.player.updateMesh(g);
                    this.saveGame();
                }
            }
            
            closeEvolution() {
                document.getElementById('evo-modal').style.display = 'none';
                this.state = 'roam';
                // Ensure input is cleared
                this.keys = {};
            }
            
            endBattle() {
                document.getElementById('battle-overlay').style.display = 'none';
                this.state = 'roam';
                this.keys = {}; // Clear input to prevent stuck movement
            }
            
            renderBattler(id, genome, flip=false) {
                const container = document.getElementById(id);
                container.innerHTML = '';
                
                const cvs = document.createElement('canvas');
                cvs.width = 150; cvs.height = 150;
                container.appendChild(cvs);
                
                const ctx = cvs.getContext('2d');
                
                // Draw 2D representation of genome
                const hue = Math.floor(genome.element * 360);
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                
                if (flip) {
                    ctx.translate(150, 0);
                    ctx.scale(-1, 1);
                }
                
                // Body
                if (genome.resilience > 0.6) {
                    ctx.fillRect(40, 40, 70, 70);
                } else {
                    ctx.beginPath();
                    ctx.arc(75, 75, 40, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // Spikes
                if (genome.aggression > 0.4) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(75, 20); ctx.lineTo(90, 50); ctx.lineTo(60, 50);
                    ctx.fill();
                }
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(90, 60, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(92, 60, 4, 0, Math.PI*2);
                ctx.fill();
            }
            
            updateHUD() {
                const p = this.playerStats;
                document.getElementById('lvl-val').textContent = p.level;
                document.getElementById('hp-bar').style.width = (p.hp/p.maxHp*100) + '%';
                document.getElementById('xp-bar').style.width = (p.xp/(p.level*100)*100) + '%';
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                const dt = this.clock.getDelta();
                this.update(dt);
                this.renderer.render(this.scene, this.camera);
            }
            
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // --- World Class ---
        class World {
            constructor(scene) {
                this.size = 100; // 100x100 tiles
                this.scale = 2;
                this.heightMap = [];
                this.objects = [];
                this.bosses = [];
                this.fossils = [];
                this.simplex = new SimplexNoise();
                
                this.generate(scene);
            }
            
            generate(scene) {
                // Terrain Geometry
                const geometry = new THREE.PlaneGeometry(this.size * this.scale, this.size * this.scale, this.size, this.size);
                geometry.rotateX(-Math.PI / 2);
                
                const colors = [];
                const pos = geometry.attributes.position;
                
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const z = pos.getZ(i);
                    
                    // Noise
                    let y = this.simplex.noise2D(x * 0.02, z * 0.02) * 5;
                    y += this.simplex.noise2D(x * 0.1, z * 0.1) * 1;
                    
                    // Water level flatten
                    if (y < 0) y = -1;
                    else if (y < 1) y = 0.5; // Beach
                    
                    pos.setY(i, y);
                    
                    // Color
                    const color = new THREE.Color();
                    if (y <= -0.5) color.setHex(0xe0cda4); // Sand underwater
                    else if (y <= 0.6) color.setHex(0xe0cda4); // Beach
                    else if (y > 4) color.setHex(0xffffff); // Snow Mountain
                    else if (y > 2.5) color.setHex(0x888888); // Rock
                    else color.setHex(0x228b22); // Grass
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
                
                const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 });
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                // Water Plane
                const waterGeo = new THREE.PlaneGeometry(this.size * this.scale, this.size * this.scale);
                waterGeo.rotateX(-Math.PI/2);
                const waterMat = new THREE.MeshStandardMaterial({ color: 0x0077be, transparent: true, opacity: 0.6 });
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.position.y = 0;
                scene.add(water);
                
                // Objects (Trees, Grass)
                for (let x = -this.size/2; x < this.size/2; x++) {
                    for (let z = -this.size/2; z < this.size/2; z++) {
                        const wx = x * this.scale;
                        const wz = z * this.scale;
                        const h = this.getHeight(wx, wz);
                        
                        if (h > 1 && h < 4) {
                            const n = this.simplex.noise2D(wx * 0.1 + 100, wz * 0.1 + 100);
                            
                            // Trees
                            if (n > 0.6 && Math.random() < 0.2) {
                                const tree = new THREE.Mesh(
                                    new THREE.ConeGeometry(0.5, 2, 8),
                                    new THREE.MeshStandardMaterial({ color: 0x004400 })
                                );
                                tree.position.set(wx, h + 1, wz);
                                tree.castShadow = true;
                                scene.add(tree);
                            }
                            
                            // Tall Grass (Encounter Zones)
                            if (n < -0.2 && Math.random() < 0.5) {
                                const grass = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.5, 0.8, 0.5),
                                    new THREE.MeshStandardMaterial({ color: 0x32cd32, transparent: true, opacity: 0.8 })
                                );
                                grass.position.set(wx, h + 0.4, wz);
                                scene.add(grass);
                                this.objects.push({ type: 'grass', x: wx, z: wz });
                            }
                        }
                    }
                }
            }
            
            spawnFossils(scene) {
                // Simulate finding 3 fossils
                for(let i=0; i<3; i++) {
                    const x = (Math.random() - 0.5) * 80;
                    const z = (Math.random() - 0.5) * 80;
                    const h = this.getHeight(x, z);
                    if (h > 0.5) {
                        const fossil = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(0.5),
                            new THREE.MeshStandardMaterial({ color: 0x885522 })
                        );
                        fossil.position.set(x, h + 0.5, z);
                        scene.add(fossil);
                        this.fossils.push({
                            mesh: fossil,
                            genome: { aggression: Math.random(), resilience: Math.random() }
                        });
                    }
                }
            }
            
            spawnBosses(scene) {
                // Spawn a Titan on a mountain
                let found = false;
                let attempts = 0;
                while(!found && attempts < 100) {
                    const x = (Math.random() - 0.5) * 100;
                    const z = (Math.random() - 0.5) * 100;
                    const h = this.getHeight(x, z);
                    if (h > 3) { // Mountain
                        const bossMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 3, 3),
                            new THREE.MeshStandardMaterial({ color: 0x550000 })
                        );
                        bossMesh.position.set(x, h + 1.5, z);
                        scene.add(bossMesh);
                        
                        this.bosses.push({
                            name: "Mountain Titan",
                            mesh: bossMesh,
                            stats: { hp: 500, maxHp: 500, atk: 30 },
                            genome: { aggression: 1, resilience: 1, element: 0.1 }
                        });
                        found = true;
                    }
                    attempts++;
                }
            }
            
            getBiome(x, z) {
                const h = this.getHeight(x, z);
                if (h < 0) return 'water';
                if (h < 1) return 'beach';
                if (h > 4) return 'snow';
                
                // Moisture noise
                const m = this.simplex.noise2D(x * 0.05 + 500, z * 0.05 + 500);
                if (m < -0.5) return 'desert';
                return 'forest';
            }
            
            getHeight(x, z) {
                let y = this.simplex.noise2D(x * 0.02, z * 0.02) * 5;
                y += this.simplex.noise2D(x * 0.1, z * 0.1) * 1;
                if (y < 0) return -1;
                if (y < 1) return 0.5;
                return y;
            }
            
            isTallGrass(x, z) {
                // Simple distance check against stored grass objects
                // Optimization: Spatial hash would be better, but linear scan ok for <1000 objects
                for(let o of this.objects) {
                    if (o.type === 'grass' && Math.abs(o.x - x) < 1 && Math.abs(o.z - z) < 1) {
                        return true;
                    }
                }
                return false;
            }
            
            drawMiniMap(px, pz) {
                const cvs = document.getElementById('mm-canvas');
                const ctx = cvs.getContext('2d');
                const w = cvs.width = cvs.offsetWidth;
                const h = cvs.height = cvs.offsetHeight;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);
                
                // Draw Player
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(w/2, h/2, 3, 0, Math.PI*2);
                ctx.fill();
                
                // Draw nearby objects
                const range = 40;
                const scale = w / (range * 2);
                
                for(let o of this.objects) {
                    const dx = o.x - px;
                    const dz = o.z - pz;
                    
                    if (Math.abs(dx) < range && Math.abs(dz) < range) {
                        if (o.type === 'grass') {
                            ctx.fillStyle = '#00ff00';
                            ctx.fillRect(w/2 + dx*scale, h/2 + dz*scale, 2, 2);
                        }
                    }
                }
                
                // Draw Bosses
                ctx.fillStyle = '#ff0000';
                for(let b of this.bosses) {
                    const dx = b.mesh.position.x - px;
                    const dz = b.mesh.position.z - pz;
                    if (Math.abs(dx) < range && Math.abs(dz) < range) {
                        ctx.fillRect(w/2 + dx*scale - 2, h/2 + dz*scale - 2, 4, 4);
                    }
                }
                
                // Draw Fossils
                ctx.fillStyle = '#aa8800';
                for(let f of this.fossils) {
                    const dx = f.mesh.position.x - px;
                    const dz = f.mesh.position.z - pz;
                    if (Math.abs(dx) < range && Math.abs(dz) < range) {
                        ctx.fillRect(w/2 + dx*scale - 1, h/2 + dz*scale - 1, 3, 3);
                    }
                }
            }
        }
        
        // --- Player Class ---
        class Player {
            constructor(scene, genome) {
                this.scene = scene;
                this.mesh = null;
                this.updateMesh(genome);
            }
            
            updateMesh(genome) {
                const oldPos = this.mesh ? this.mesh.position.clone() : null;
                const oldRot = this.mesh ? this.mesh.rotation.clone() : null;
                
                if (this.mesh) this.scene.remove(this.mesh);
                
                const group = new THREE.Group();
                
                // Body Color
                const hue = Math.floor(genome.element * 360);
                const color = new THREE.Color(`hsl(${hue}, 70%, 50%)`);
                
                // Body Shape
                let geo;
                if (genome.resilience > 0.6) {
                    geo = new THREE.BoxGeometry(1, 1, 1);
                } else {
                    geo = new THREE.SphereGeometry(0.6, 16, 16);
                }
                
                const body = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color }));
                body.position.y = 0.5;
                body.castShadow = true;
                group.add(body);
                
                // Spikes
                if (genome.aggression > 0.4) {
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(0.2, 0.8, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    spike.position.y = 1.0;
                    group.add(spike);
                }
                
                // Eyes
                const eye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                eye.position.set(0.3, 0.7, 0.4);
                group.add(eye);
                
                const eye2 = eye.clone();
                eye2.position.set(-0.3, 0.7, 0.4);
                group.add(eye2);
                
                this.mesh = group;
                this.scene.add(this.mesh);
                
                // Restore position
                if (oldPos) {
                    this.mesh.position.copy(oldPos);
                    this.mesh.rotation.copy(oldRot);
                }
            }
            
            update(dt) {
                // Animation (bobbing)
                if (this.mesh) {
                    this.mesh.children[0].position.y = 0.5 + Math.sin(Date.now() * 0.01) * 0.05;
                }
            }
        }
        
        // Start Game
        const game = new Game();
        
    </script>
</body>
</html>