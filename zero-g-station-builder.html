<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-G Station Builder Deluxe</title>
    <meta name="description" content="Advanced 3D space station construction simulator with bloom effects, physics-based movement, and modular building system.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Holographic UI Theme */
        :root {
            --hud-bg: rgba(10, 20, 30, 0.75);
            --hud-border: 1px solid rgba(0, 255, 255, 0.3);
            --accent: #00ffff;
            --accent-glow: 0 0 10px rgba(0, 255, 255, 0.5);
            --text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
        }

        .hud {
            position: fixed;
            background: var(--hud-bg);
            border: var(--hud-border);
            padding: 15px;
            backdrop-filter: blur(5px);
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s;
        }

        .hud-header {
            color: var(--accent);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 5px;
            text-shadow: var(--text-shadow);
        }

        #stats {
            top: 20px;
            left: 20px;
            min-width: 220px;
            clip-path: polygon(0 0, 100% 0, 100% 85%, 90% 100%, 0 100%);
        }

        #controls-info {
            top: 20px;
            right: 20px;
            text-align: right;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 10% 100%, 0 85%);
        }

        .key-hint {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: var(--accent);
            margin-right: 5px;
        }

        #build-menu {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0, 10, 20, 0.9);
            border-top: 2px solid var(--accent);
            border-radius: 10px 10px 0 0;
        }

        .module-button {
            background: rgba(0, 50, 100, 0.4);
            border: 1px solid rgba(0, 255, 255, 0.2);
            color: #fff;
            width: 80px;
            height: 80px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            position: relative;
            overflow: hidden;
        }

        .module-button:hover {
            background: rgba(0, 100, 200, 0.6);
            border-color: var(--accent);
            box-shadow: var(--accent-glow);
            transform: translateY(-2px);
        }

        .module-button.selected {
            background: rgba(0, 200, 255, 0.2);
            border-color: var(--accent);
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .module-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
        }

        .module-name {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .module-cost {
            font-size: 9px;
            color: #aaa;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: var(--hud-bg);
            padding: 5px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .icon-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 8px;
            cursor: pointer;
            transition: color 0.2s;
            font-size: 16px;
        }

        .icon-btn:hover {
            color: var(--accent);
        }

        /* Orbital info */
        #orbital-info {
            bottom: 20px;
            right: 20px;
            text-align: right;
            border-right: 2px solid var(--accent);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
        }

        .stat-label {
            color: #88aaff;
            margin-right: 15px;
        }

        .stat-value {
            color: #fff;
            font-family: monospace;
            font-weight: bold;
        }

        .warning {
            color: #ff3333;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 10px red; }
            50% { opacity: 0.5; }
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000510;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loader {
            width: 100px;
            height: 100px;
            border: 3px solid transparent;
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loader:before {
            content: "";
            position: absolute;
            top: 5px; left: 5px; right: 5px; bottom: 5px;
            border: 3px solid transparent;
            border-top-color: #0088ff;
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: monospace;
            color: var(--accent);
            letter-spacing: 4px;
            animation: blink 1s infinite;
        }

        @keyframes blink { 50% { opacity: 0.5; } }

        /* Mode indicator */
        #mode-indicator {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            padding: 20px 5px;
            background: rgba(0, 0, 0, 0.5);
            border-left: 3px solid var(--accent);
            font-weight: bold;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.3s;
        }

        #mode-indicator.active {
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            background: rgba(0, 20, 40, 0.8);
        }

        /* Notification */
        #notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid var(--accent);
            padding: 10px 30px;
            color: #fff;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1500;
            text-shadow: 0 0 5px var(--accent);
        }

        /* Title Screen */
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 10, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            transition: opacity 1s;
        }

        .title-glitch {
            font-size: 60px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff;
            letter-spacing: 10px;
            margin-bottom: 10px;
            animation: glitch 3s infinite alternate;
        }

        .subtitle {
            font-size: 20px;
            color: var(--accent);
            letter-spacing: 5px;
            margin-bottom: 50px;
            opacity: 0.8;
        }

        .menu-btn {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 15px 40px;
            font-size: 18px;
            letter-spacing: 3px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 20px var(--accent);
        }

        @keyframes glitch {
            0% { text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff; }
            90% { text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff; }
            92% { text-shadow: -2px 2px 0px #00ffff, 2px -2px 0px #ff00ff; transform: translate(2px, 0); }
            94% { text-shadow: 2px -2px 0px #00ffff, -2px 2px 0px #ff00ff; transform: translate(-2px, 0); }
            96% { text-shadow: 0px 0px 0px #00ffff, 0px 0px 0px #ff00ff; transform: translate(0, 0); }
            100% { text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff; }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div class="loading-text">SYSTEM INITIALIZATION</div>
    </div>

    <!-- Title Screen -->
    <div id="title-screen">
        <h1 class="title-glitch">ZERO-G STATION BUILDER</h1>
        <div class="subtitle">ORBITAL CONSTRUCTION SIMULATOR</div>
        <div class="start-menu">
            <button class="menu-btn" onclick="startGame()">ENTER SIMULATION</button>
            <button class="menu-btn" onclick="showMissionScreen()">TEST FLIGHT MISSION</button>
            <button class="menu-btn" onclick="startTutorialFromMenu()">RUN TRAINING PROGRAM</button>
        </div>
        <div style="margin-top: 50px; font-family: monospace; color: #446688;">v2.1 // SYSTEM READY</div>
    </div>

    <!-- Mission Control Screen -->
    <div id="mission-screen" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,5,10,0.95); z-index:3000; flex-direction:column; align-items:center; justify-content:center;">
        <h1 class="title-glitch" style="font-size:40px">MISSION CONTROL</h1>
        <div class="subtitle">SELECT FLIGHT PROFILE</div>
        
        <div style="display:flex; gap:20px; margin-bottom:30px;">
            <div class="mission-card" onclick="startMission('vostok')">
                <h3>VOSTOK 1 (1961)</h3>
                <p>OBJECTIVE: LOW EARTH ORBIT</p>
                <p>DIFFICULTY: ROOKIE</p>
                <div class="mission-icon">üåç</div>
            </div>
            <div class="mission-card" onclick="startMission('apollo')">
                <h3>APOLLO 11 (1969)</h3>
                <p>OBJECTIVE: LUNAR ORBIT INSERTION</p>
                <p>DIFFICULTY: VETERAN</p>
                <div class="mission-icon">üåë</div>
            </div>
            <div class="mission-card" onclick="startMission('interstellar')">
                <h3>PROJECT LONGSHOT (2150)</h3>
                <p>OBJECTIVE: ALPHA CENTAURI BURN</p>
                <p>DIFFICULTY: LEGEND</p>
                <div class="mission-icon">‚ú®</div>
            </div>
            <div class="mission-card" onclick="startMission('hail_mary')" style="border-color: #ff3300; box-shadow: 0 0 10px #ff3300;">
                <h3 style="color: #ff3300">PROJECT HAIL MARY</h3>
                <p>OBJECTIVE: TAU CETI (12 LY)</p>
                <p>DIFFICULTY: SUICIDE</p>
                <div class="mission-icon">üï∑Ô∏è</div>
            </div>
        </div>
        
        <button class="menu-btn" onclick="closeMissionScreen()">RETURN TO BUILDER</button>
    </div>

    <!-- Mission Summary Screen -->
    <div id="mission-summary" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,5,10,0.98); z-index:4000; flex-direction:column; align-items:center; justify-content:center;">
        <h1 class="title-glitch" style="font-size:40px; color:#00ff00; text-shadow: 0 0 10px #00ff00;">MISSION ACCOMPLISHED</h1>
        <div class="subtitle" id="summary-subtitle">ARRIVAL CONFIRMED</div>
        
        <div style="display:flex; gap:40px; margin:30px 0;">
            <div style="text-align:center;">
                <div class="stat-label">TOTAL FLIGHT TIME</div>
                <div class="stat-value" id="summary-time" style="font-size:24px;">00:00:00</div>
            </div>
            <div style="text-align:center;">
                <div class="stat-label">DISTANCE TRAVELED</div>
                <div class="stat-value" id="summary-dist" style="font-size:24px;">0 KM</div>
            </div>
            <div style="text-align:center;">
                <div class="stat-label">MAX VELOCITY</div>
                <div class="stat-value" id="summary-vel" style="font-size:24px;">0 KM/S</div>
            </div>
        </div>
        
        <div style="width:600px; height:200px; border:1px solid #333; margin-bottom:30px; position:relative; background:rgba(0,0,0,0.5);">
            <div style="position:absolute; top:10px; left:10px; color:#aaa; font-size:10px;">FLIGHT PROFILE REPLAY</div>
            <canvas id="flight-graph" width="600" height="200"></canvas>
        </div>
        
        <button class="menu-btn" onclick="closeMissionSummary()">RETURN TO BASE</button>
    </div>

    <!-- Flight UI -->
    <div id="flight-ui" style="display:none;">
        <div class="hud" style="top:20px; left:50%; transform:translateX(-50%); display:flex; gap:20px;">
            <div class="stat-value" id="mission-timer">T+ 00:00:00</div>
            <div class="stat-value" id="mission-vel">VEL: 0 m/s</div>
            <div class="stat-value" id="mission-alt">ALT: 0 km</div>
            <div class="stat-value" id="mission-fuel">FUEL: 100%</div>
            <div class="stat-value" id="mission-eta" style="color:var(--accent)">ETA: N/A</div>
            <div class="stat-value" id="mission-delta" style="color:#ff3300; display:none;">ŒîV COST: +0 m/s</div>
        </div>
        
        <!-- Autopilot Controls -->
        <div style="position:fixed; bottom:80px; left:50%; transform:translateX(-50%); text-align:center;">
            <button id="autopilot-btn" class="menu-btn" style="font-size:12px; padding:5px 20px; border-color:#00ff00; color:#00ff00;" onclick="toggleAutopilot()">AUTOPILOT: ON</button>
        </div>
        
        <!-- Progress Bar -->
        <div id="mission-progress-container" style="position:fixed; top:60px; left:50%; transform:translateX(-50%); width:400px; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">
            <div id="mission-progress-bar" style="width:0%; height:100%; background:var(--accent); box-shadow:0 0 10px var(--accent);"></div>
        </div>

        <!-- Camera Controls -->
        <div class="hud" style="top:20px; right:20px; text-align:right;">
            <div class="hud-header">VISUAL FEED</div>
            <div class="stat-value" id="cam-mode-display">CHASE CAM</div>
            <button class="menu-btn" style="font-size:12px; padding:5px 10px; margin:5px 0;" onclick="cycleCamera()">SWITCH VIEW [C]</button>
        </div>

        <!-- Comms Panel -->
        <div class="hud" style="top:100px; left:20px; width:280px;">
            <div class="hud-header">COMMS LINK</div>
            <div class="stat-row"><span class="stat-label">STATUS</span><span class="stat-value" id="comms-status" style="color:#00ff00">CONNECTED</span></div>
            <div class="stat-row"><span class="stat-label">ONE-WAY DELAY</span><span class="stat-value" id="light-lag">0.00s</span></div>
            <div class="stat-row"><span class="stat-label">RELATIVITY (Œ≥)</span><span class="stat-value" id="lorentz">1.000000</span></div>
            <div id="comms-log" style="height:100px; overflow-y:auto; font-size:10px; margin-top:10px; border-top:1px solid #333; padding-top:5px; font-family:monospace; color:#aaa;">
                > LINK ESTABLISHED...
            </div>
            <button class="menu-btn" style="width:100%; margin:10px 0 0 0; font-size:12px; padding:5px;" onclick="pingEarth()">PING MISSION CONTROL</button>
        </div>
        
        <div class="hud" style="bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px; align-items:center;">
            <span class="stat-label">TIME WARP:</span>
            <button class="icon-btn" onclick="setTimeWarp(1)">1x</button>
            <button class="icon-btn" onclick="setTimeWarp(10)">10x</button>
            <button class="icon-btn" onclick="setTimeWarp(100)">100x</button>
            <button class="icon-btn" onclick="setTimeWarp(1000)">1k</button>
            <span class="stat-value" id="warp-display" style="color:var(--accent)">1x</span>
        </div>

        <div id="navball" style="position:fixed; bottom:20px; left:20px; width:150px; height:150px; border-radius:50%; border:2px solid var(--accent); background:rgba(0,0,0,0.5); overflow:hidden;">
            <div id="navball-horizon" style="width:100%; height:100%; background:linear-gradient(#00aaff 50%, #885522 50%); transform:rotate(0deg) translateY(0%); transition:transform 0.1s;"></div>
            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:var(--accent); font-size:24px;">+</div>
        </div>
    </div>

    <style>
        .mission-card {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid var(--accent);
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .mission-card:hover {
            background: rgba(0, 40, 80, 0.9);
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent);
        }
        .mission-icon {
            font-size: 50px;
            margin-top: 15px;
        }
    </style>

    <!-- Notification -->
    <div id="notification">System Ready</div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button class="icon-btn" onclick="exportStation()" title="Save/Export">üíæ</button>
        <button class="icon-btn" onclick="document.getElementById('importFile').click()" title="Load/Import">üìÇ</button>
        <button class="icon-btn" onclick="clearStation()" title="Reset">üóëÔ∏è</button>
        <button class="icon-btn" onclick="startTutorial()" title="Start Tutorial" style="color: #00ff00;">üéì</button>
        <button class="icon-btn" onclick="toggleSound()" title="Toggle Sound" id="sound-btn">üîä</button>
        <select id="presetSelect" onchange="loadPreset(this.value)" style="background: rgba(0,20,40,0.8); color: #00ffff; border: 1px solid #00ffff; padding: 5px; border-radius: 5px; margin-left: 10px;">
            <option value="">Load Blueprint...</option>
            <option value="default">Standard Outpost</option>
            <option value="sputnik_future">Sputnik-X (2099)</option>
            <option value="iss_early">ISS (Alpha Phase)</option>
            <option value="iss_late">ISS (Omega Phase)</option>
            <option value="hail_mary">Hail Mary (Astrophage Drive)</option>
        </select>
        <input type="file" id="importFile" accept=".json" onchange="importStation(event)" style="display:none">
    </div>

    <!-- HUD Elements -->
    <div id="stats" class="hud">
        <div class="hud-header">Station Status</div>
        <div class="stat-row"><span class="stat-label">Modules</span><span class="stat-value" id="module-count">0</span></div>
        <div class="stat-row"><span class="stat-label">Net Power</span><span class="stat-value" id="power-status">0 MW</span></div>
        <div class="stat-row"><span class="stat-label">Crew Cap</span><span class="stat-value" id="crew-capacity">0</span></div>
        <div class="stat-row"><span class="stat-label">Solar Eff</span><span class="stat-value" id="solar-efficiency">0%</span></div>
        <div class="stat-row"><span class="stat-label">Integrity</span><span class="stat-value" style="color: #00ff00">100%</span></div>
    </div>

    <div id="controls-info" class="hud">
        <div class="hud-header">Flight Controls</div>
        <div style="margin-bottom: 5px"><span class="key-hint">W</span><span class="key-hint">S</span> Thrust Fwd/Back</div>
        <div style="margin-bottom: 5px"><span class="key-hint">A</span><span class="key-hint">D</span> Yaw Left/Right</div>
        <div style="margin-bottom: 5px"><span class="key-hint">Q</span><span class="key-hint">E</span> Vertical Thrust</div>
        <div style="margin-bottom: 5px"><span class="key-hint">SHIFT</span> Boost Engines</div>
        <div style="margin-bottom: 15px"><span class="key-hint">MOUSE</span> Pitch/Yaw</div>
        
        <div class="hud-header">Build Controls</div>
        <div style="margin-bottom: 5px"><span class="key-hint">B</span> Toggle Build Mode</div>
        <div style="margin-bottom: 5px"><span class="key-hint">R</span> Rotate Module</div>
        <div style="margin-bottom: 5px"><span class="key-hint">L-CLICK</span> Place</div>
        <div style="margin-bottom: 5px"><span class="key-hint">DEL</span> Remove</div>
    </div>

    <div id="build-menu" style="display: none;">
        <!-- Populated by JS -->
    </div>

    <div id="orbital-info" class="hud">
        <div class="hud-header">Telemetry</div>
        <div class="stat-row"><span class="stat-label">ALT</span><span class="stat-value" id="altitude">450 km</span></div>
        <div class="stat-row"><span class="stat-label">VEL</span><span class="stat-value">7.66 km/s</span></div>
        <div class="stat-row"><span class="stat-label">INC</span><span class="stat-value">51.6¬∞</span></div>
    </div>

    <div id="mode-indicator">FLIGHT MODE</div>

    <canvas id="canvas"></canvas>

    <!-- Three.js & Post Processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- Configuration ---
        const APP_NAME = 'zero-g-station-builder-v2';
        const SNAP_GRID = 2; // Finer grid for better detail
        
        // --- State ---
        let scene, camera, renderer, composer;
        let planet, rings, sun, stars;
        let station = [];
        let ghostModule = null;
        let buildMode = false;
        let selectedModuleType = 'habitat';
        let soundEnabled = true;
        
        // Input State
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false };
        const mouse = new THREE.Vector2();
        let cameraRotation = { phi: 0, theta: 0 };

        // Station Data
        let stationData = {
            modules: [],
            stats: { power: 0, crew: 0, efficiency: 0 }
        };

        // --- Module Definitions ---
        const MODULES = {
            habitat: {
                name: "Habitat Core",
                icon: "üè†",
                cost: "100k",
                power: -5,
                crew: 4,
                geometry: () => {
                    const g = new THREE.CylinderGeometry(2, 2, 6, 8);
                    g.rotateZ(Math.PI / 2);
                    return g;
                },
                material: new THREE.MeshStandardMaterial({ color: 0xeeeeff, roughness: 0.2, metalness: 0.8 })
            },
            connector: {
                name: "Corridor",
                icon: "‚ûñ",
                cost: "20k",
                power: -1,
                crew: 0,
                geometry: () => {
                    const g = new THREE.BoxGeometry(4, 1.5, 1.5);
                    return g;
                },
                material: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.9 })
            },
            solar: {
                name: "Solar Array",
                icon: "‚òÄÔ∏è",
                cost: "50k",
                power: 25,
                crew: 0,
                geometry: () => {
                    const g = new THREE.Group();
                    const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 0.2, 4),
                        new THREE.MeshStandardMaterial({ color: 0x111133, roughness: 0.2, metalness: 0.5, emissive: 0x000022 })
                    );
                    const arm = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.2, 2),
                        new THREE.MeshStandardMaterial({ color: 0x888888 })
                    );
                    arm.rotation.z = Math.PI / 2;
                    arm.position.x = -5;
                    // We return a group, but for collision/raycast we need a mesh. 
                    // For simplicity in this version, we'll use a simple box for the main geometry
                    return new THREE.BoxGeometry(10, 0.5, 4); 
                },
                material: new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.1, metalness: 0.6, emissive: 0x001133 })
            },
            reactor: {
                name: "Fusion Core",
                icon: "‚ò¢Ô∏è",
                cost: "500k",
                power: 100,
                crew: 2,
                geometry: () => new THREE.SphereGeometry(2.5, 16, 16),
                material: new THREE.MeshStandardMaterial({ color: 0xff3300, roughness: 0.4, metalness: 0.8, emissive: 0x330000 })
            },
            dock: {
                name: "Docking Port",
                icon: "‚öì",
                cost: "150k",
                power: -10,
                crew: 0,
                geometry: () => new THREE.TorusGeometry(2, 0.5, 8, 16),
                material: new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.3, metalness: 1.0 })
            },
            lab: {
                name: "Science Lab",
                icon: "üî¨",
                cost: "300k",
                power: -15,
                crew: 6,
                geometry: () => new THREE.BoxGeometry(5, 3, 5),
                material: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.5 })
            },
            dome: {
                name: "Obs. Dome",
                icon: "üî≠",
                cost: "200k",
                power: -5,
                crew: 2,
                geometry: () => {
                    const g = new THREE.SphereGeometry(3, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                    return g;
                },
                material: new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0, metalness: 0, transparent: true, opacity: 0.4 })
            }
        };

        // --- Presets ---
        const PRESETS = {
            default: [
                {type: "habitat", pos: [0, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, 6], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, -6], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 0, -10], rot: [0, 0, 0]},
                {type: "solar", pos: [10, 0, 6], rot: [0, 0, 0]},
                {type: "solar", pos: [-10, 0, 6], rot: [0, 0, 0]},
                {type: "dock", pos: [0, 0, 10], rot: [0, 0, 0]},
                {type: "dome", pos: [0, 4, 0], rot: [0, 0, 0]},
                {type: "lab", pos: [0, -4, 0], rot: [0, 0, 0]}
            ],
            sputnik_future: [
                // Core
                {type: "reactor", pos: [0, 0, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [4, 0, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [-4, 0, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 4, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, -4, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 0, 4], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 0, -4], rot: [0, 0, 0]},
                // Spikes (Antennas)
                {type: "connector", pos: [10, 10, 10], rot: [0.7, 0.7, 0]},
                {type: "connector", pos: [-10, 10, 10], rot: [0.7, -0.7, 0]},
                {type: "connector", pos: [10, -10, 10], rot: [-0.7, 0.7, 0]},
                {type: "connector", pos: [-10, -10, 10], rot: [-0.7, -0.7, 0]},
                // Rings
                {type: "dock", pos: [12, 0, 0], rot: [0, 1.57, 0]},
                {type: "dock", pos: [-12, 0, 0], rot: [0, 1.57, 0]},
                {type: "dock", pos: [0, 12, 0], rot: [1.57, 0, 0]},
                {type: "dock", pos: [0, -12, 0], rot: [1.57, 0, 0]},
                // Surveillance
                {type: "dome", pos: [0, 0, 10], rot: [0, 0, 0]},
                {type: "lab", pos: [0, 0, -10], rot: [0, 0, 0]}
            ],
            iss_early: [
                {type: "habitat", pos: [0, 0, 0], rot: [0, 0, 0]}, // Zarya
                {type: "connector", pos: [0, 0, 6], rot: [0, 0, 0]}, // Unity
                {type: "habitat", pos: [0, 0, -6], rot: [0, 0, 0]}, // Zvezda
                {type: "solar", pos: [0, 5, -6], rot: [0, 0, 1.57]},
                {type: "solar", pos: [0, -5, -6], rot: [0, 0, 1.57]},
                {type: "dock", pos: [0, 0, 10], rot: [0, 0, 0]}
            ],
            iss_late: [
                // Main Truss
                {type: "connector", pos: [0, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [6, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [-6, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [12, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [-12, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [18, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [-18, 0, 0], rot: [0, 0, 0]},
                // Solar Arrays (Massive)
                {type: "solar", pos: [24, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [24, 0, -5], rot: [0, 0, 0]},
                {type: "solar", pos: [-24, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [-24, 0, -5], rot: [0, 0, 0]},
                {type: "solar", pos: [30, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [30, 0, -5], rot: [0, 0, 0]},
                {type: "solar", pos: [-30, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [-30, 0, -5], rot: [0, 0, 0]},
                // Modules
                {type: "habitat", pos: [0, -5, 0], rot: [1.57, 0, 0]}, // Destiny
                {type: "lab", pos: [0, -10, 0], rot: [1.57, 0, 0]}, // Kibo
                {type: "lab", pos: [4, -5, 0], rot: [1.57, 0, 0]}, // Columbus
                {type: "habitat", pos: [0, -5, 6], rot: [0, 0, 0]}, // Harmony
                {type: "dock", pos: [0, -5, 10], rot: [0, 0, 0]},
                {type: "dome", pos: [0, -8, 2], rot: [0, 0, 0]} // Cupola
            ],
            hail_mary: [
                // Spin Drives (Astrophage)
                {type: "reactor", pos: [0, 0, -15], rot: [0, 0, 0]},
                {type: "reactor", pos: [2, 2, -15], rot: [0, 0, 0]},
                {type: "reactor", pos: [-2, -2, -15], rot: [0, 0, 0]},
                // Fuel Tanks
                {type: "connector", pos: [0, 0, -10], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, -6], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, -2], rot: [0, 0, 0]},
                // Centrifuge / Crew Area
                {type: "habitat", pos: [0, 0, 2], rot: [0, 0, 0]},
                {type: "lab", pos: [0, 0, 6], rot: [0, 0, 0]},
                // Nose Cone
                {type: "dome", pos: [0, 0, 10], rot: [0, 0, 0]},
                // Beetle Monitors (External)
                {type: "dock", pos: [3, 0, 4], rot: [0, 1.57, 0]},
                {type: "dock", pos: [-3, 0, 4], rot: [0, -1.57, 0]}
            ]
        };

        // --- Tutorial System ---
        let tutorialActive = false;
        let currentLookTarget = new THREE.Vector3(0, 0, 0);
        let tutorialTimer = null;

        const TUTORIAL_STEPS = [
            {
                msg: "WELCOME COMMANDER. INITIALIZING STATION OVERVIEW.",
                pos: new THREE.Vector3(50, 40, 50),
                look: new THREE.Vector3(0, 0, 0),
                delay: 4000
            },
            {
                msg: "HABITAT CORE (CENTER): MAINTAINS LIFE SUPPORT.",
                pos: new THREE.Vector3(8, 4, 8),
                look: new THREE.Vector3(0, 0, 0),
                delay: 5000
            },
            {
                msg: "SOLAR ARRAYS: CRITICAL FOR POWER GENERATION.",
                pos: new THREE.Vector3(15, 5, 15),
                look: new THREE.Vector3(10, 0, 6),
                delay: 5000
            },
            {
                msg: "FUSION REACTOR: HEAVY INDUSTRY POWER SOURCE.",
                pos: new THREE.Vector3(-5, 5, -15),
                look: new THREE.Vector3(0, 0, -10),
                delay: 5000
            },
            {
                msg: "OBSERVATION DOME: CREW MORALE & NAVIGATION.",
                pos: new THREE.Vector3(0, 10, 5),
                look: new THREE.Vector3(0, 4, 0),
                delay: 5000
            },
            {
                msg: "TUTORIAL COMPLETE. MANUAL CONTROL ENGAGED.",
                pos: new THREE.Vector3(30, 20, 30),
                look: new THREE.Vector3(0, 0, 0),
                delay: 3000
            }
        ];

        function startTutorial() {
            if(station.length > 0 && !confirm("Start Training? This will reset to the Standard Outpost.")) return;
            
            // Force load default for tutorial
            station.forEach(m => scene.remove(m));
            station = [];
            buildFromData(PRESETS['default']);
            
            tutorialActive = true;
            runTutorialStep(0);
        }

        function runTutorialStep(index) {
            if(index >= TUTORIAL_STEPS.length) {
                tutorialActive = false;
                showNotification("SYSTEMS ONLINE");
                return;
            }

            const step = TUTORIAL_STEPS[index];
            showNotification(step.msg);
            
            // Set targets for animation loop
            // We don't snap, we let the animate loop lerp to these
            window.tutorialTargetPos = step.pos;
            window.tutorialTargetLook = step.look;

            tutorialTimer = setTimeout(() => runTutorialStep(index + 1), step.delay);
        }

        // --- Audio System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (!soundEnabled || audioCtx.state === 'suspended') {
                audioCtx.resume();
                if (!soundEnabled) return;
            }
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if (type === 'hover') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'place') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000510, 0.0015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(30, 20, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Post Processing (Bloom)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // Intense bloom
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Environment
            createEnvironment();
            createLights();
            
            // UI Generation
            generateBuildMenu();
            
            // Event Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);

            // Start Loop
            loadStation();
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function createEnvironment() {
            // Stars
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<5000; i++) {
                starPos.push((Math.random()-0.5)*4000, (Math.random()-0.5)*4000, (Math.random()-0.5)*4000);
                const color = new THREE.Color();
                color.setHSL(Math.random(), 0.5, 0.8);
                starColors.push(color.r, color.g, color.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({size: 2, vertexColors: true}));
            scene.add(stars);

            // Planet
            const planetGeo = new THREE.SphereGeometry(800, 64, 64);
            const planetMat = new THREE.MeshStandardMaterial({
                color: 0x2244ff,
                roughness: 0.8,
                metalness: 0.1,
                emissive: 0x001133,
                emissiveIntensity: 0.2
            });
            planet = new THREE.Mesh(planetGeo, planetMat);
            planet.position.set(-1000, -800, -2000);
            scene.add(planet);

            // Atmosphere
            const atmoGeo = new THREE.SphereGeometry(820, 64, 64);
            const atmoMat = new THREE.MeshBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            const atmo = new THREE.Mesh(atmoGeo, atmoMat);
            planet.add(atmo);

            // Sun
            const sunGeo = new THREE.SphereGeometry(100, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({color: 0xffddaa});
            sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(1000, 500, 1000);
            scene.add(sun);
        }

        function createLights() {
            const ambient = new THREE.AmbientLight(0x111122, 0.5);
            scene.add(ambient);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(1000, 500, 1000);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 5000;
            const d = 200;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            scene.add(sunLight);

            // Blue bounce light from planet
            const planetLight = new THREE.DirectionalLight(0x0044ff, 0.3);
            planetLight.position.set(-1000, -800, -2000);
            scene.add(planetLight);
        }

        function generateBuildMenu() {
            const menu = document.getElementById('build-menu');
            Object.keys(MODULES).forEach(key => {
                const m = MODULES[key];
                const btn = document.createElement('div');
                btn.className = 'module-button';
                if(key === selectedModuleType) btn.classList.add('selected');
                btn.innerHTML = `
                    <div class="module-icon">${m.icon}</div>
                    <div class="module-name">${m.name}</div>
                    <div class="module-cost">${m.cost}</div>
                `;
                btn.onclick = () => selectModule(key);
                btn.onmouseenter = () => playSound('hover');
                menu.appendChild(btn);
            });
        }

        // --- Interaction ---
        function selectModule(type) {
            selectedModuleType = type;
            document.querySelectorAll('.module-button').forEach(b => b.classList.remove('selected'));
            // Find index and add class (simplified)
            const buttons = document.querySelectorAll('.module-button');
            const keys = Object.keys(MODULES);
            buttons[keys.indexOf(type)].classList.add('selected');
            
            if(buildMode) updateGhost();
        }

        function toggleBuildMode() {
            buildMode = !buildMode;
            const indicator = document.getElementById('mode-indicator');
            const menu = document.getElementById('build-menu');
            
            if(buildMode) {
                indicator.textContent = "BUILD MODE";
                indicator.classList.add('active');
                menu.style.display = 'flex';
                showNotification("Construction Systems Engaged");
            } else {
                indicator.textContent = "FLIGHT MODE";
                indicator.classList.remove('active');
                menu.style.display = 'none';
                if(ghostModule) {
                    scene.remove(ghostModule);
                    ghostModule = null;
                }
            }
        }

        function updateGhost() {
            if(ghostModule) scene.remove(ghostModule);
            if(!buildMode) return;

            const def = MODULES[selectedModuleType];
            const geo = def.geometry();
            const mat = def.material.clone();
            mat.transparent = true;
            mat.opacity = 0.5;
            mat.emissive = new THREE.Color(0x00ffff);
            mat.emissiveIntensity = 0.5;
            
            ghostModule = new THREE.Mesh(geo, mat);
            scene.add(ghostModule);
        }

        function getPlacement() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Raycast against existing station modules
            const intersects = raycaster.intersectObjects(station);
            
            let pos = new THREE.Vector3();
            let rot = new THREE.Euler();
            
            if(intersects.length > 0) {
                // Surface snapping
                const hit = intersects[0];
                const normal = hit.face.normal.clone().transformDirection(hit.object.matrixWorld).normalize();
                
                // Snap to center of the hit object + offset
                // This is a simplified snapping model. A robust one would use connection nodes.
                // We'll just stack them for now based on bounding box.
                
                pos.copy(hit.point).add(normal.multiplyScalar(2)); // Offset slightly
                
                // Snap to grid
                pos.x = Math.round(pos.x / SNAP_GRID) * SNAP_GRID;
                pos.y = Math.round(pos.y / SNAP_GRID) * SNAP_GRID;
                pos.z = Math.round(pos.z / SNAP_GRID) * SNAP_GRID;
                
                // Align rotation to normal (basic)
                if(Math.abs(normal.y) > 0.9) rot.x = normal.y > 0 ? 0 : Math.PI;
                else if(Math.abs(normal.x) > 0.9) rot.z = normal.x > 0 ? -Math.PI/2 : Math.PI/2;
                else if(Math.abs(normal.z) > 0.9) rot.y = normal.z > 0 ? 0 : Math.PI;
                
            } else {
                // Free space placement (at fixed distance)
                const dist = 40;
                const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera).sub(camera.position).normalize();
                pos.copy(camera.position).add(vec.multiplyScalar(dist));
                
                pos.x = Math.round(pos.x / SNAP_GRID) * SNAP_GRID;
                pos.y = Math.round(pos.y / SNAP_GRID) * SNAP_GRID;
                pos.z = Math.round(pos.z / SNAP_GRID) * SNAP_GRID;
            }
            
            return { pos, rot };
        }

        function placeModule() {
            if(!buildMode) return;
            
            const { pos, rot } = getPlacement();
            const def = MODULES[selectedModuleType];
            
            const mesh = new THREE.Mesh(def.geometry(), def.material);
            mesh.position.copy(pos);
            mesh.rotation.copy(rot);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { type: selectedModuleType, ...def };
            
            scene.add(mesh);
            station.push(mesh);
            
            // Add lights to some modules
            if(selectedModuleType === 'habitat' || selectedModuleType === 'dock') {
                const light = new THREE.PointLight(0x00ffff, 0.5, 10);
                mesh.add(light);
            }
            
            playSound('place');
            updateStats();
            
            // Particle effect
            createParticles(pos);
        }

        function removeModule() {
            if(!buildMode) return;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(station);
            
            if(intersects.length > 0) {
                const obj = intersects[0].object;
                scene.remove(obj);
                station = station.filter(m => m !== obj);
                playSound('error'); // Reuse error sound for delete
                updateStats();
            }
        }

        function createParticles(pos) {
            const geo = new THREE.BufferGeometry();
            const count = 20;
            const positions = [];
            for(let i=0; i<count; i++) {
                positions.push(pos.x, pos.y, pos.z);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({color: 0x00ffff, size: 0.5, transparent: true});
            const particles = new THREE.Points(geo, mat);
            scene.add(particles);
            
            // Animate and remove
            const startTime = Date.now();
            const animateParticles = () => {
                const elapsed = Date.now() - startTime;
                if(elapsed > 500) {
                    scene.remove(particles);
                    return;
                }
                
                const positions = particles.geometry.attributes.position.array;
                for(let i=0; i<count; i++) {
                    positions[i*3] += (Math.random()-0.5) * 0.5;
                    positions[i*3+1] += (Math.random()-0.5) * 0.5;
                    positions[i*3+2] += (Math.random()-0.5) * 0.5;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                mat.opacity = 1 - (elapsed/500);
                requestAnimationFrame(animateParticles);
            };
            animateParticles();
        }

        function updateStats() {
            let power = 0;
            let crew = 0;
            let solarCount = 0;
            
            station.forEach(m => {
                power += m.userData.power || 0;
                crew += m.userData.crew || 0;
                if(m.userData.type === 'solar') solarCount++;
            });
            
            // Solar efficiency based on angle to sun (simplified)
            // In a real game, we'd check each panel's rotation
            const efficiency = solarCount > 0 ? 95 : 0; 
            
            document.getElementById('module-count').textContent = station.length;
            
            const pEl = document.getElementById('power-status');
            pEl.textContent = power + " MW";
            pEl.style.color = power >= 0 ? '#00ff00' : '#ff0000';
            
            document.getElementById('crew-capacity').textContent = crew;
            document.getElementById('solar-efficiency').textContent = efficiency + "%";
        }

        // --- Input Handling ---
        function onKeyDown(e) {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(k === 'shift') keys.shift = true;
            
            if(k === 'b') toggleBuildMode();
            if(k === 'delete') removeModule();
            if(k === 'r' && ghostModule) ghostModule.rotation.y += Math.PI/2;
            if(k === 'c' && missionMode) cycleCamera();
        }

        function onKeyUp(e) {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
            if(k === 'shift') keys.shift = false;
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseDown(e) {
            if(e.target.closest('.hud') || e.target.closest('.data-controls')) return;
            if(buildMode) {
                if(e.button === 0) placeModule();
                if(e.button === 2) removeModule(); // Right click delete
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Physics & Mission System ---
        let missionMode = false;
        let physicsTime = 0;
        let timeWarp = 1;
        let shipVelocity = new THREE.Vector3();
        let shipPosition = new THREE.Vector3(); // Real physics position (scaled down for rendering)
        let celestialBody = null;
        let ghostShip = null;
        let orbitLine = null;
        let ghostOrbitLine = null;
        let spaceDust = null;
        let historyLine = null;
        let predictedLine = null;
        const MAX_TRAIL_POINTS = 1000;
        const PREDICTION_STEPS = 500;
        
        const G = 6.67430e-11;
        const C = 299792.458; // km/s (Speed of Light)
        const SCALE_FACTOR = 0.001; // 1 unit = 1km for physics calculations
        
        const MISSIONS = {
            vostok: {
                name: "Vostok 1",
                bodyRadius: 6371, // km
                bodyMass: 5.972e24, // kg
                bodyColor: 0x2244ff,
                startAlt: 200, // km
                startVel: 7.84, // km/s (approx orbital velocity)
                targetOrbit: 200,
                ghostColor: 0xff0000,
                desc: "Achieve stable orbit at 200km altitude."
            },
            apollo: {
                name: "Apollo 11",
                bodyRadius: 1737, // km
                bodyMass: 7.342e22, // kg
                bodyColor: 0xaaaaaa,
                startAlt: 500, // km
                startVel: 1.2, // km/s (Insertion velocity)
                targetOrbit: 110,
                ghostColor: 0xffaa00,
                desc: "Retrograde burn to capture into 110km lunar orbit."
            },
            interstellar: {
                name: "Project Longshot",
                bodyRadius: 696340, // Sun (km)
                bodyMass: 1.989e30, // kg
                bodyColor: 0xffff00,
                startAlt: 150000000, // 1 AU
                startVel: 30, // km/s
                targetOrbit: null,
                ghostColor: 0x00ffff,
                desc: "Escape velocity burn. Target: 0.1c",
                destName: "Alpha Centauri",
                destDist: 4.37 * 9.461e12, // km (4.37 LY)
                destColor: 0xffddaa
            },
            hail_mary: {
                name: "Project Hail Mary",
                bodyRadius: 6371, // Earth Start
                bodyMass: 5.972e24,
                bodyColor: 0x2244ff,
                startAlt: 400,
                startVel: 0, // Launch from orbit
                targetOrbit: null,
                ghostColor: 0xff3300, // Astrophage Red
                desc: "Tau Ceti Run. 12 Light Years. 1.5g Burn.",
                special: "astrophage",
                destName: "Tau Ceti",
                destDist: 11.9 * 9.461e12, // km (12 LY)
                destColor: 0xffaa88
            }
        };

        let currentMission = null;
        let cameraMode = 'CHASE'; // CHASE, COCKPIT, ORBIT, TARGET, CINEMATIC
        let camIndex = 0;
        const CAM_MODES = ['CHASE', 'COCKPIT', 'ORBIT', 'TARGET', 'CINEMATIC'];
        let destinationBody = null;

        function showMissionScreen() {
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('mission-screen').style.display = 'flex';
        }

        function closeMissionScreen() {
            document.getElementById('mission-screen').style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
        }

        let autopilotEngaged = true;
        let deviationAlert = false;

        let maxVelocity = 0;
        let flightHistory = []; // Store [time, distance] for graph

        function startMission(missionId) {
            document.getElementById('mission-screen').style.display = 'none';
            document.getElementById('flight-ui').style.display = 'block';
            document.getElementById('stats').style.display = 'none'; // Hide builder HUD
            document.getElementById('controls-info').style.display = 'none';
            document.getElementById('build-menu').style.display = 'none';
            document.getElementById('mode-indicator').textContent = "AUTOPILOT ENGAGED";
            document.getElementById('mode-indicator').style.color = "#00ff00";
            
            missionMode = true;
            autopilotEngaged = true;
            currentMission = MISSIONS[missionId];
            physicsTime = 0;
            maxVelocity = 0;
            flightHistory = [];
            
            // Setup Physics World
            setupMissionScene(currentMission);
            
            // Initialize Physics State
            const r = currentMission.bodyRadius + currentMission.startAlt;
            shipPosition.set(r, 0, 0);
            shipVelocity.set(0, 0, -currentMission.startVel); // Tangential velocity
            
            // Setup Ghost Ship (The "Gold Standard")
            setupGhostShip(currentMission);
            
            showNotification("MISSION START: " + currentMission.name);
            
            // Force HUD update immediately
            updatePhysics(0.016);
        }

        function setupMissionScene(mission) {
            // Clear existing scene elements except station
            if(planet) scene.remove(planet);
            if(sun) scene.remove(sun);
            if(rings) scene.remove(rings);
            if(destinationBody) scene.remove(destinationBody);
            
            // Create Celestial Body (Origin)
            const geo = new THREE.SphereGeometry(mission.bodyRadius * SCALE_FACTOR, 64, 64);
            const mat = new THREE.MeshStandardMaterial({
                color: mission.bodyColor,
                roughness: 0.8,
                emissive: 0x000000
            });
            celestialBody = new THREE.Mesh(geo, mat);
            scene.add(celestialBody);

            // Create Destination Body (if any)
            if(mission.destDist) {
                const dGeo = new THREE.SphereGeometry(1000, 32, 32); // Visual representation
                const dMat = new THREE.MeshBasicMaterial({
                    color: mission.destColor,
                    transparent: true,
                    opacity: 0.8
                });
                destinationBody = new THREE.Mesh(dGeo, dMat);
                // Position will be updated in physics loop relative to ship
                scene.add(destinationBody);
            }
            
            // Lighting
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(1000, 500, 1000);
            scene.add(sunLight);
            
            // Group station modules into a single ship object for physics
            // If station is empty, spawn a default ship
            if(station.length === 0) {
                if(missionId === 'hail_mary') {
                    buildFromData(PRESETS['hail_mary']);
                } else {
                    buildFromData(PRESETS['default']);
                }
            } else if (missionId === 'hail_mary' && confirm("Load 'Hail Mary' configuration for this mission?")) {
                 // Clear existing
                station.forEach(m => scene.remove(m));
                station = [];
                buildFromData(PRESETS['hail_mary']);
            }
            
            // Reset Camera
            cameraMode = 'CHASE';
            camIndex = 0;
            updateCameraModeDisplay();
            
            // Setup Visual Effects
            createSpaceDust();
            setupTrajectoryLines();
        }

        function createSpaceDust() {
            if(spaceDust) scene.remove(spaceDust);
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<2000; i++) {
                pos.push(
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0x88ccff,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            spaceDust = new THREE.Points(geo, mat);
            scene.add(spaceDust);
        }

        function setupTrajectoryLines() {
            if(historyLine) scene.remove(historyLine);
            if(predictedLine) scene.remove(predictedLine);
            
            // History (Green)
            const hGeo = new THREE.BufferGeometry();
            // Pre-allocate buffer
            hGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_TRAIL_POINTS * 3), 3));
            hGeo.setDrawRange(0, 0);
            const hMat = new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true });
            historyLine = new THREE.Line(hGeo, hMat);
            historyLine.userData.points = [];
            scene.add(historyLine);
            
            // Prediction (Blue Dotted)
            const pGeo = new THREE.BufferGeometry();
            pGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PREDICTION_STEPS * 3), 3));
            const pMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
            predictedLine = new THREE.Line(pGeo, pMat);
            scene.add(predictedLine);
        }

        function updateSpaceDust(dt) {
            if(!spaceDust || !missionMode) return;
            
            // Move dust opposite to ship velocity
            // We use a scaled velocity for visual effect, clamped so it doesn't look crazy at warp
            // Actually, we want to feel the speed.
            
            const positions = spaceDust.geometry.attributes.position.array;
            const vel = shipVelocity.clone().multiplyScalar(SCALE_FACTOR * 0.1); // Visual scale
            
            // If velocity is huge (interstellar), we need to fake it or it blurs out
            // Let's just move them along Z if speed is high to simulate "warp stars"
            
            for(let i=0; i<2000; i++) {
                let ix = i*3;
                let iy = i*3+1;
                let iz = i*3+2;
                
                // Move relative to camera (which is effectively 0,0,0 in chase mode)
                // But we want them to stream past.
                
                // Simple: Move dust by -velocity
                positions[ix] -= vel.x;
                positions[iy] -= vel.y;
                positions[iz] -= vel.z;
                
                // Wrap around box 1000x1000x1000
                if(positions[ix] < -500) positions[ix] += 1000;
                if(positions[ix] > 500) positions[ix] -= 1000;
                if(positions[iy] < -500) positions[iy] += 1000;
                if(positions[iy] > 500) positions[iy] -= 1000;
                if(positions[iz] < -500) positions[iz] += 1000;
                if(positions[iz] > 500) positions[iz] -= 1000;
            }
            spaceDust.geometry.attributes.position.needsUpdate = true;
        }

        function updateTrajectoryVisuals() {
            if(!historyLine || !predictedLine) return;
            
            // 1. Update History
            // We store positions relative to the Celestial Body (Origin)
            // But visually, the Celestial Body moves.
            // So we need to draw lines in the "World Space" where Ship is (0,0,0).
            // This means the history points need to shift every frame? That's expensive.
            
            // Better approach:
            // The Scene is "Ship-Centric". Ship is at 0,0,0.
            // Everything else moves.
            // So a point in history at (x,y,z) relative to ship *at that time* 
            // is now at (x-dx, y-dy, z-dz) relative to ship.
            
            // Actually, let's define points in "Solar System Space" (Origin = Sun/Earth).
            // Then transform them to "Ship Space" for rendering.
            
            // Add current pos to history (Solar System Space)
            // Only add if far enough from last point
            const lastPoint = historyLine.userData.points[historyLine.userData.points.length-1];
            const currentPos = shipPosition.clone();
            
            if(!lastPoint || currentPos.distanceTo(lastPoint) > (currentMission.bodyRadius * 0.05)) {
                historyLine.userData.points.push(currentPos);
                if(historyLine.userData.points.length > MAX_TRAIL_POINTS) {
                    historyLine.userData.points.shift();
                }
            }
            
            // Render History
            // Transform points to Visual Space (relative to ship)
            const hPos = historyLine.geometry.attributes.position.array;
            const visualShipPos = shipPosition.clone().multiplyScalar(SCALE_FACTOR);
            
            let count = 0;
            for(let i=0; i<historyLine.userData.points.length; i++) {
                const pt = historyLine.userData.points[i].clone().multiplyScalar(SCALE_FACTOR);
                // Vector from Ship to Point
                const rel = pt.sub(visualShipPos);
                
                hPos[count*3] = rel.x;
                hPos[count*3+1] = rel.y;
                hPos[count*3+2] = rel.z;
                count++;
            }
            historyLine.geometry.setDrawRange(0, count);
            historyLine.geometry.attributes.position.needsUpdate = true;
            
            // 2. Update Prediction
            // Simulate N steps ahead
            const pPos = predictedLine.geometry.attributes.position.array;
            let simPos = shipPosition.clone();
            let simVel = shipVelocity.clone();
            // Step size depends on mission scale
            let simDt = 10; // seconds
            if(currentMission.name.includes("Longshot") || currentMission.name.includes("Hail")) simDt = 10000;
            
            for(let i=0; i<PREDICTION_STEPS; i++) {
                // Simple gravity step
                const r = simPos.length();
                const G_km = 6.67430e-20;
                const acc = (G_km * currentMission.bodyMass) / (r*r);
                const gravityDir = simPos.clone().normalize().negate();
                
                simVel.add(gravityDir.multiplyScalar(acc * simDt));
                simPos.add(simVel.clone().multiplyScalar(simDt));
                
                // Transform to visual space
                const vis = simPos.clone().multiplyScalar(SCALE_FACTOR).sub(visualShipPos);
                
                pPos[i*3] = vis.x;
                pPos[i*3+1] = vis.y;
                pPos[i*3+2] = vis.z;
            }
            predictedLine.geometry.attributes.position.needsUpdate = true;
        }

        function endMission(success) {
            missionMode = false;
            document.getElementById('flight-ui').style.display = 'none';
            const summary = document.getElementById('mission-summary');
            summary.style.display = 'flex';
            
            document.getElementById('summary-subtitle').textContent = success ? "ARRIVAL CONFIRMED" : "MISSION ABORTED";
            document.getElementById('summary-time').textContent = formatTime(physicsTime);
            document.getElementById('summary-dist').textContent = formatDistance(shipPosition.length());
            document.getElementById('summary-vel').textContent = maxVelocity.toFixed(2) + " KM/S";
            
            drawFlightGraph();
        }

        function closeMissionSummary() {
            document.getElementById('mission-summary').style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
            
            // Reset scene to builder mode
            station.forEach(m => scene.remove(m));
            station = [];
            loadStation(); // Reload saved station or default
            
            // Restore builder UI
            document.getElementById('stats').style.display = 'block';
            document.getElementById('controls-info').style.display = 'block';
            document.getElementById('mode-indicator').textContent = "FLIGHT MODE";
            document.getElementById('mode-indicator').style.color = "rgba(255, 255, 255, 0.5)";
        }

        function drawFlightGraph() {
            const canvas = document.getElementById('flight-graph');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if(flightHistory.length < 2) return;
            
            // Draw Velocity Curve
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            
            const maxT = flightHistory[flightHistory.length-1].t;
            const maxV = maxVelocity;
            
            flightHistory.forEach((pt, i) => {
                const x = (pt.t / maxT) * canvas.width;
                const y = canvas.height - ((pt.v / maxV) * (canvas.height - 20)) - 10;
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw Distance Curve
            ctx.beginPath();
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            const maxD = currentMission.destDist || flightHistory[flightHistory.length-1].d;
            
            flightHistory.forEach((pt, i) => {
                const x = (pt.t / maxT) * canvas.width;
                const y = canvas.height - ((pt.d / maxD) * (canvas.height - 20)) - 10;
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.fillStyle = '#00ffff';
            ctx.fillText("VELOCITY", 10, 180);
            ctx.fillStyle = '#00ff00';
            ctx.fillText("DISTANCE", 80, 180);
        }

        function cycleCamera() {
            camIndex = (camIndex + 1) % CAM_MODES.length;
            cameraMode = CAM_MODES[camIndex];
            updateCameraModeDisplay();
            playSound('hover');
        }

        function updateCameraModeDisplay() {
            document.getElementById('cam-mode-display').textContent = cameraMode + " CAM";
        }

        function setupGhostShip(mission) {
            const geo = new THREE.ConeGeometry(1, 3, 8);
            geo.rotateX(Math.PI/2);
            const mat = new THREE.MeshBasicMaterial({
                color: mission.ghostColor, 
                wireframe: true,
                transparent: true, 
                opacity: 0.5
            });
            ghostShip = new THREE.Mesh(geo, mat);
            scene.add(ghostShip);
            
            // Ghost physics state
            ghostShip.userData = {
                pos: new THREE.Vector3(mission.bodyRadius + mission.startAlt, 0, 0),
                vel: new THREE.Vector3(0, 0, -mission.startVel)
            };
            
            // Create orbit trails
            const trailGeo = new THREE.BufferGeometry();
            const trailMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            orbitLine = new THREE.Line(trailGeo, trailMat);
            scene.add(orbitLine);
        }

        function setTimeWarp(val) {
            timeWarp = val;
            document.getElementById('warp-display').textContent = val + "x";
        }

        let pendingMessages = [];

        function pingEarth() {
            if(!missionMode) return;
            const dist = shipPosition.length(); // Distance from origin (Earth/Sun)
            const delay = dist / C; // seconds
            
            logComms("> PING SENT...");
            
            // Schedule response
            // We use real time for the UI delay, not physics time, but scaled?
            // No, let's use real time but if time warp is high, it might be instant.
            // Let's simulate it based on the game loop.
            
            pendingMessages.push({
                time: physicsTime + (delay * 2), // Round trip in physics time
                msg: "> PING RECEIVED. TRAJECTORY NOMINAL."
            });
        }

        function logComms(txt) {
            const log = document.getElementById('comms-log');
            const line = document.createElement('div');
            line.textContent = txt;
            log.appendChild(line);
            log.scrollTop = log.scrollHeight;
        }

        function toggleAutopilot() {
            autopilotEngaged = !autopilotEngaged;
            const btn = document.getElementById('autopilot-btn');
            const ind = document.getElementById('mode-indicator');
            
            if(autopilotEngaged) {
                btn.textContent = "AUTOPILOT: ON";
                btn.style.borderColor = "#00ff00";
                btn.style.color = "#00ff00";
                ind.textContent = "AUTOPILOT ENGAGED";
                ind.style.color = "#00ff00";
                showNotification("COURSE CORRECTION INITIATED");
                // Reset delta display
                document.getElementById('mission-delta').style.display = 'none';
            } else {
                btn.textContent = "AUTOPILOT: OFF";
                btn.style.borderColor = "#ff3300";
                btn.style.color = "#ff3300";
                ind.textContent = "MANUAL CONTROL";
                ind.style.color = "#ff3300";
                showNotification("MANUAL OVERRIDE");
            }
        }

        function updatePhysics(dt) {
            if(!missionMode || !currentMission) return;
            
            const steps = 10; // Sub-steps for stability
            const dtStep = (dt * timeWarp) / steps;
            
            physicsTime += dt * timeWarp;

            for(let i=0; i<steps; i++) {
                // Ship Gravity
                applyGravity(shipPosition, shipVelocity, dtStep);
                
                // Autopilot Logic
                if(autopilotEngaged && ghostShip) {
                    // Simple P-Controller to match Ghost Velocity vector direction
                    // We don't snap position, we just try to align velocity to target
                    const targetVel = ghostShip.userData.vel.clone();
                    const currentVel = shipVelocity.clone();
                    
                    // Correction vector
                    const correction = targetVel.sub(currentVel);
                    const maxThrust = 0.005 * dtStep; // Autopilot authority
                    
                    if(correction.length() > maxThrust) {
                        correction.normalize().multiplyScalar(maxThrust);
                    }
                    
                    shipVelocity.add(correction);
                }
                
                // Ghost Gravity (Gold Standard)
                if(ghostShip) {
                    applyGravity(ghostShip.userData.pos, ghostShip.userData.vel, dtStep);
                }
            }

            // Check pending messages
            for(let i = pendingMessages.length - 1; i >= 0; i--) {
                if(physicsTime >= pendingMessages[i].time) {
                    logComms(pendingMessages[i].msg);
                    playSound('hover'); // Beep
                    pendingMessages.splice(i, 1);
                }
            }
            
            // Update Visuals
            const visualPos = shipPosition.clone().multiplyScalar(SCALE_FACTOR);
            
            // Move celestial body (Origin) relative to ship
            celestialBody.position.copy(visualPos.clone().negate());
            
            // Move Destination Body relative to ship
            if(destinationBody && currentMission.destDist) {
                // Destination is at (0,0, -destDist) in physics space? 
                // Let's assume destination is along -Z axis for simplicity
                const destPos = new THREE.Vector3(0, 0, -currentMission.destDist);
                const relDest = destPos.sub(shipPosition).multiplyScalar(SCALE_FACTOR);
                
                // If too far, clamp visual distance so it's visible but small
                const maxVisDist = 5000;
                if(relDest.length() > maxVisDist) {
                    relDest.normalize().multiplyScalar(maxVisDist);
                }
                destinationBody.position.copy(relDest);
                destinationBody.lookAt(camera.position); // Billboard effect if needed
            }
            
            if(ghostShip) {
                const ghostVisual = ghostShip.userData.pos.clone().multiplyScalar(SCALE_FACTOR);
                ghostShip.position.copy(ghostVisual.sub(visualPos));
                ghostShip.lookAt(ghostShip.position.clone().add(ghostShip.userData.vel));
            }
            
            // Update HUD
            const alt = shipPosition.length() - currentMission.bodyRadius;
            const vel = shipVelocity.length(); // km/s
            
            document.getElementById('mission-alt').textContent = "ALT: " + formatDistance(alt);
            document.getElementById('mission-vel').textContent = "VEL: " + vel.toFixed(2) + " km/s";
            
            // ETA Calculation & Deviation
            if(currentMission.destDist) {
                const distToDest = currentMission.destDist - shipPosition.length(); 
                const vel = shipVelocity.length();
                
                // Calculate Deviation from Ideal Path (Ghost)
                if(ghostShip) {
                    const idealPos = ghostShip.userData.pos;
                    const deviation = shipPosition.distanceTo(idealPos);
                    
                    // Calculate Delta-V required to fix (rough approx)
                    // Energy difference + Plane change cost
                    const deltaV = deviation * 0.0001; // Fake metric for gameplay
                    
                    if(!autopilotEngaged && deviation > 1000) {
                        const dEl = document.getElementById('mission-delta');
                        dEl.style.display = 'block';
                        dEl.textContent = "ŒîV COST: +" + deltaV.toFixed(0) + " m/s";
                        
                        // Update ETA based on current bad trajectory
                        // If we are off course, ETA increases
                        // Angle between velocity and target
                        const toTarget = new THREE.Vector3(0,0,-1); // Simplified target direction
                        const angle = shipVelocity.angleTo(toTarget);
                        const efficiency = Math.cos(angle);
                        
                        if(efficiency > 0) {
                            const eta = (distToDest / (vel * efficiency));
                            document.getElementById('mission-eta').textContent = "ETA: " + formatTime(eta) + " (DRIFTING)";
                            document.getElementById('mission-eta').style.color = "#ffaa00";
                        } else {
                            document.getElementById('mission-eta').textContent = "ETA: OFF COURSE";
                            document.getElementById('mission-eta').style.color = "#ff0000";
                        }
                    } else {
                        // Nominal
                        if(vel > 0.1) {
                            const eta = distToDest / vel;
                            document.getElementById('mission-eta').textContent = "ETA: " + formatTime(eta);
                            document.getElementById('mission-eta').style.color = "var(--accent)";
                        } else {
                            document.getElementById('mission-eta').textContent = "ETA: --";
                        }
                    }
                }
                
                // Update Progress Bar
                const totalDist = currentMission.destDist;
                const currentDist = shipPosition.length();
                const progress = Math.min(100, Math.max(0, (currentDist / totalDist) * 100));
                document.getElementById('mission-progress-bar').style.width = progress + "%";
                document.getElementById('mission-progress-container').style.display = 'block';
                
                // Track Max Velocity
                if(vel > maxVelocity) maxVelocity = vel;
                
                // Record History (every ~100 physics seconds)
                if(flightHistory.length === 0 || (physicsTime - flightHistory[flightHistory.length-1].t) > 100) {
                    flightHistory.push({t: physicsTime, d: currentDist, v: vel});
                }

                // Check for Arrival
                if(currentDist >= totalDist * 0.999) {
                    endMission(true);
                }
                
            } else {
                document.getElementById('mission-eta').textContent = "ETA: N/A";
                document.getElementById('mission-progress-container').style.display = 'none';
            }
            
            // Relativistic Calcs
            
            // Relativistic Calcs
            const dist = shipPosition.length();
            const lightLag = dist / C; // seconds
            const lorentz = 1 / Math.sqrt(1 - (vel*vel)/(C*C));
            
            document.getElementById('light-lag').textContent = formatTime(lightLag);
            document.getElementById('lorentz').textContent = lorentz.toFixed(8);
            
            // Update Navball (Horizon)
            // Angle between position vector and camera up
            // Simplified horizon tilt
            const up = shipPosition.clone().normalize();
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const pitch = Math.asin(camDir.dot(up));
            const horizon = document.getElementById('navball-horizon');
            horizon.style.transform = `translateY(${pitch * 50}%)`;
            
            // Update Visual Effects
            updateSpaceDust(dt);
            updateTrajectoryVisuals();
        }

        function formatDistance(km) {
            if(km > 1000000) return (km/149600000).toFixed(3) + " AU";
            return Math.round(km) + " km";
        }

        function formatTime(sec) {
            if(sec < 60) return sec.toFixed(2) + "s";
            if(sec < 3600) return (sec/60).toFixed(1) + "m";
            return (sec/3600).toFixed(1) + "h";
        }

        function applyGravity(pos, vel, dt) {
            const r = pos.length();
            const rSq = r * r;
            const force = (G * currentMission.bodyMass) / (rSq * 1000000); // km^2 adjustment? 
            // G is in m^3 kg^-1 s^-2. 
            // Mass is kg.
            // Distance is km.
            // We need consistent units. Let's use km for distance.
            // G_km = G / 1e9 = 6.67e-20
            const G_km = 6.67430e-20;
            const acc = (G_km * currentMission.bodyMass) / rSq;
            
            const gravityDir = pos.clone().normalize().negate();
            vel.add(gravityDir.multiplyScalar(acc * dt));
            pos.add(vel.clone().multiplyScalar(dt));
        }

        // Modify animate to handle physics
        const clock = new THREE.Clock();
        
        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();

            if(missionMode) {
                // Physics Loop
                updatePhysics(dt);
                
                // Flight Controls (Thrust)
                if(keys.shift) {
                    // Disengage autopilot on manual input
                    if(autopilotEngaged) toggleAutopilot();
                    
                    const thrust = 0.01 * timeWarp * dt; // km/s^2
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    shipVelocity.add(dir.multiplyScalar(thrust));
                    createParticles(new THREE.Vector3(0,0,5)); 
                }
                
                // Camera System
                const time = Date.now() * 0.0005;
                
                if(cameraMode === 'CHASE') {
                    // Standard Chase Cam
                    const offset = new THREE.Vector3(0, 10, 30);
                    camera.position.lerp(offset, 0.1);
                    camera.lookAt(0, 0, 0);
                    
                    // Manual rotation override
                    const rotSpeed = 0.02;
                    if(keys.a) camera.position.x -= rotSpeed * 100;
                    if(keys.d) camera.position.x += rotSpeed * 100;
                    
                } else if(cameraMode === 'COCKPIT') {
                    // Inside view
                    camera.position.set(0, 0, 0);
                    // Allow looking around
                    if(keys.w) camera.rotation.x += 0.02;
                    if(keys.s) camera.rotation.x -= 0.02;
                    if(keys.a) camera.rotation.y += 0.02;
                    if(keys.d) camera.rotation.y -= 0.02;
                    
                } else if(cameraMode === 'ORBIT') {
                    // Rotating around ship
                    camera.position.x = Math.cos(time) * 40;
                    camera.position.z = Math.sin(time) * 40;
                    camera.position.y = 10;
                    camera.lookAt(0, 0, 0);
                    
                } else if(cameraMode === 'TARGET') {
                    // Look at destination
                    camera.position.set(0, 5, 5);
                    if(destinationBody) {
                        camera.lookAt(destinationBody.position);
                    } else {
                        // Look forward
                        camera.lookAt(0, 0, -100);
                    }
                    
                } else if(cameraMode === 'CINEMATIC') {
                    // Auto-switching cinematic angles
                    const cycle = Math.floor(time / 5) % 3;
                    if(cycle === 0) {
                        // Flyby
                        camera.position.set(Math.cos(time)*50, Math.sin(time)*20, Math.sin(time)*50);
                        camera.lookAt(0, 0, 0);
                    } else if(cycle === 1) {
                        // Rear view looking at origin
                        camera.position.set(0, 5, 20);
                        camera.lookAt(celestialBody.position);
                    } else {
                        // Top down
                        camera.position.set(0, 50, 0);
                        camera.lookAt(0, 0, 0);
                    }
                }
                
            } else if (tutorialActive && window.tutorialTargetPos) {
                // Tutorial Camera Mode
                camera.position.lerp(window.tutorialTargetPos, 0.03);
                currentLookTarget.lerp(window.tutorialTargetLook, 0.03);
                camera.lookAt(currentLookTarget);
            } else {
                // Manual Camera Movement (Builder Mode)
                const speed = keys.shift ? 1.0 : 0.2;
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const right = new THREE.Vector3().crossVectors(dir, camera.up);
                
                if(keys.w) camera.position.add(dir.multiplyScalar(speed));
                if(keys.s) camera.position.add(dir.multiplyScalar(-speed));
                if(keys.a) camera.position.add(right.multiplyScalar(-speed));
                if(keys.d) camera.position.add(right.multiplyScalar(speed));
                if(keys.q) camera.position.y += speed;
                if(keys.e) camera.position.y -= speed;

                // Mouse Look (when not in UI)
                const edgeThreshold = 0.8;
                const rotSpeed = 0.02;
                if(Math.abs(mouse.x) > edgeThreshold) camera.rotation.y -= Math.sign(mouse.x) * rotSpeed * (Math.abs(mouse.x) - edgeThreshold);
                if(Math.abs(mouse.y) > edgeThreshold) camera.rotation.x -= Math.sign(mouse.y) * rotSpeed * (Math.abs(mouse.y) - edgeThreshold);
                
                // Update look target for smooth transition back from tutorial
                const lookDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                currentLookTarget.copy(camera.position).add(lookDir.multiplyScalar(10));
            }

            // Update Ghost
            if(buildMode && ghostModule) {
                const { pos, rot } = getPlacement();
                ghostModule.position.lerp(pos, 0.5); // Smooth snapping
                // ghostModule.rotation.copy(rot); // Rotation snapping is jarring, maybe skip lerp
            }

            // Environment Animation
            planet.rotation.y += 0.0002;
            
            // Render
            composer.render();
        }

        // --- Persistence ---
        function saveStation() {
            const data = station.map(m => ({
                type: m.userData.type,
                pos: m.position.toArray(),
                rot: m.rotation.toArray()
            }));
            localStorage.setItem(APP_NAME, JSON.stringify(data));
            showNotification("Station Saved");
        }

        function loadStation() {
            const json = localStorage.getItem(APP_NAME);
            try {
                let data = json ? JSON.parse(json) : [];
                
                // Robust check for array
                if (!Array.isArray(data) || data.length === 0) {
                    console.log("No valid save found, loading default.");
                    buildFromData(PRESETS['default']);
                } else {
                    buildFromData(data);
                }
            } catch(e) { 
                console.error("Load failed", e);
                buildFromData(PRESETS['default']);
            }
        }

        function loadPreset(name) {
            if(!name || !PRESETS[name]) return;
            
            // Only ask for confirmation if there is a station AND we are not in the initial load phase (implied by user interaction via select)
            // However, since this function is called by the select element, we can check if the call is coming from user interaction
            // But for simplicity, let's just check if station has modules.
            // If called programmatically (like from loadStation), we might want to skip confirm.
            
            // Let's modify loadStation to call buildFromData directly for the default, 
            // and keep loadPreset for user interaction.
            
            if(station.length > 0 && !confirm("Load preset? Current station will be lost.")) {
                document.getElementById('presetSelect').value = "";
                return;
            }
            
            // Clear existing
            station.forEach(m => scene.remove(m));
            station = [];
            
            buildFromData(PRESETS[name]);
            document.getElementById('presetSelect').value = "";
            showNotification("Blueprint Loaded: " + name);
        }

        function buildFromData(data) {
            data.forEach(d => {
                const def = MODULES[d.type];
                if(!def) return;
                const mesh = new THREE.Mesh(def.geometry(), def.material);
                mesh.position.fromArray(d.pos);
                mesh.rotation.fromArray(d.rot);
                mesh.userData = { type: d.type, ...def };
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                station.push(mesh);
                
                if(d.type === 'habitat' || d.type === 'dock') {
                    const light = new THREE.PointLight(0x00ffff, 0.5, 10);
                    mesh.add(light);
                }
            });
            updateStats();
        }

        function clearStation() {
            if(confirm("Destroy entire station?")) {
                station.forEach(m => scene.remove(m));
                station = [];
                updateStats();
                saveStation();
            }
        }

        function exportStation() {
            saveStation();
            const data = localStorage.getItem(APP_NAME);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'station-blueprint.json';
            a.click();
        }

        function showNotification(msg) {
            const el = document.getElementById('notification');
            el.textContent = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-btn').textContent = soundEnabled ? 'üîä' : 'üîá';
        }

        function startGame() {
            const ts = document.getElementById('title-screen');
            ts.style.opacity = 0;
            setTimeout(() => {
                ts.style.display = 'none';
                playSound('hover');
            }, 1000);
        }

        function startTutorialFromMenu() {
            startGame();
            setTimeout(() => {
                startTutorial();
            }, 1200);
        }

        // Init
        window.onload = init;

    </script>
</body>
</html>