<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroPlay Console</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Poppins:wght@400;600&display=swap');

        :root {
            --console-color: #8ca5ac;
            --console-dark: #566366;
            --console-light: #b8c7cc;
            --screen-color: #8bac0f;
            --button-color: #2f3335;
            --button-shadow: #1a1c1d;
            --accent-color: #e42c64;
            --text-color: #181c1f;
            --menu-bg: rgba(240, 240, 240, 0.95);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #e0e8ec, #c4d4db);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            color: var(--text-color);
        }

        .retro-console {
            position: relative;
            width: 360px;
            height: 580px;
            background-color: var(--console-color);
            border-radius: 12px 12px 60px 12px;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.3),
                inset 0 -5px 20px rgba(0, 0, 0, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: perspective(1000px) rotateX(5deg);
        }

        .brand-name {
            position: absolute;
            top: 10px;
            left: 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--console-dark);
            letter-spacing: -0.5px;
        }

        .brand-logo {
            position: absolute;
            top: 26px;
            left: 32px;
            width: 50px;
            height: 8px;
            background: var(--console-dark);
            border-radius: 4px;
        }

        .screen-container {
            position: relative;
            width: 320px;
            height: 288px;
            margin-top: 45px;
            background-color: var(--console-dark);
            border-radius: 8px 8px 40px 8px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .power-indicator {
            position: absolute;
            top: 10px;
            left: 15px;
            width: 8px;
            height: 8px;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 5px var(--accent-color);
        }

        .power-text {
            position: absolute;
            top: 9px;
            left: 26px;
            font-size: 8px;
            color: var(--console-light);
        }

        .game-screen {
            width: 280px;
            height: 248px;
            background-color: var(--screen-color);
            border: 4px solid var(--text-color);
            border-radius: 3px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .screen-content {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .d-pad {
            position: absolute;
            bottom: 85px;
            left: 50px;
            width: 100px;
            height: 100px;
        }

        .d-pad-button {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: var(--button-color);
            border-radius: 3px;
            cursor: pointer;
            box-shadow: 0 4px 0 var(--button-shadow);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .d-pad-center {
            top: 35px;
            left: 35px;
            width: 30px;
            height: 30px;
            background-color: var(--button-color);
            border-radius: 3px;
            z-index: 0;
        }

        .d-pad-up {
            top: 0;
            left: 35px;
        }

        .d-pad-right {
            top: 35px;
            right: 0;
        }

        .d-pad-down {
            bottom: 0;
            left: 35px;
        }

        .d-pad-left {
            top: 35px;
            left: 0;
        }

        .d-pad-button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 var(--button-shadow);
        }

        .action-buttons {
            position: absolute;
            bottom: 85px;
            right: 50px;
            width: 100px;
            height: 100px;
        }

        .action-button {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: var(--accent-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 0 #a52147;
            user-select: none;
        }

        .button-a {
            top: 15px;
            right: 0;
        }

        .button-b {
            bottom: 15px;
            left: 0;
        }

        .action-button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #a52147;
        }

        .start-select-buttons {
            position: absolute;
            bottom: 45px;
            width: 120px;
            height: 20px;
            display: flex;
            justify-content: space-between;
        }

        .system-button {
            width: 45px;
            height: 12px;
            background-color: var(--button-color);
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 3px 0 var(--button-shadow);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .system-button:active {
            transform: translateY(3px);
            box-shadow: 0 0 0 var(--button-shadow);
        }

        .speaker {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 80px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-content: space-between;
        }

        .speaker-hole {
            width: 6px;
            height: 6px;
            background-color: var(--button-shadow);
            border-radius: 50%;
        }

        .game-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--menu-bg);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 40px;
            overflow-y: auto;
            z-index: 1000;
        }

        .menu-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .menu-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: var(--text-color);
        }

        .close-menu {
            font-size: 24px;
            color: var(--text-color);
            background: none;
            border: none;
            cursor: pointer;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }

        .game-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 7px 10px rgba(0, 0, 0, 0.15);
        }

        .game-icon {
            width: 80px;
            height: 80px;
            background-color: #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .game-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-align: center;
            margin-bottom: 8px;
        }

        .game-description {
            font-size: 12px;
            text-align: center;
            color: #666;
        }

        .app-store-section {
            width: 100%;
            max-width: 800px;
            margin-top: 30px;
            border-top: 2px solid #ddd;
            padding-top: 30px;
        }

        .store-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .upload-game {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            transition: background-color 0.2s;
        }

        .upload-game:hover {
            background-color: #c92554;
        }

        .file-input {
            display: none;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        }

        .modal-content {
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .confirm-button {
            background-color: var(--accent-color);
            color: white;
        }

        .cancel-button {
            background-color: #ddd;
        }
    </style>
</head>
<body>
    <div class="retro-console">
        <div class="brand-name">RetroPlay</div>
        <div class="brand-logo"></div>
        <div class="screen-container">
            <div class="power-indicator"></div>
            <div class="power-text">POWER</div>
            <div class="game-screen">
                <div class="screen-content" id="game-display">
                    <!-- Game will be displayed here -->
                </div>
            </div>
        </div>
        <div class="d-pad">
            <div class="d-pad-center"></div>
            <div class="d-pad-button d-pad-up" id="d-up">▲</div>
            <div class="d-pad-button d-pad-right" id="d-right">▶</div>
            <div class="d-pad-button d-pad-down" id="d-down">▼</div>
            <div class="d-pad-button d-pad-left" id="d-left">◀</div>
        </div>
        <div class="action-buttons">
            <div class="action-button button-a" id="btn-a">A</div>
            <div class="action-button button-b" id="btn-b">B</div>
        </div>
        <div class="start-select-buttons">
            <div class="system-button" id="btn-select">SELECT</div>
            <div class="system-button" id="btn-start">START</div>
        </div>
        <div class="speaker">
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
            <div class="speaker-hole"></div>
        </div>
    </div>

    <div class="game-menu" id="game-menu">
        <div class="menu-header">
            <h1 class="menu-title">RetroPlay App Store</h1>
            <button class="close-menu" id="close-menu">✕</button>
        </div>
        <div class="games-grid" id="games-grid">
            <!-- Games will be inserted here -->
        </div>
        <div class="app-store-section">
            <div class="store-header">
                <h2 class="menu-title">Upload Game</h2>
                <button class="upload-game" id="upload-game-btn">+ Add Game</button>
                <input type="file" id="file-input" class="file-input" accept=".json">
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay">
        <div class="modal" id="modal">
            <div class="modal-header">
                <h3>Export Game</h3>
                <button class="close-modal" id="close-modal">✕</button>
            </div>
            <div class="modal-content">
                <p>Do you want to export the current game as a JSON file?</p>
            </div>
            <div class="modal-actions">
                <button class="modal-button cancel-button" id="cancel-export">Cancel</button>
                <button class="modal-button confirm-button" id="confirm-export">Export</button>
            </div>
        </div>
    </div>

    <script>
        // Main System Class
        class RetroConsole {
            constructor() {
                this.gameLibrary = {};
                this.currentGame = null;
                this.gameRunning = false;
                this.gameLoop = null;
                this.gameDisplay = document.getElementById('game-display');
                this.setupEventListeners();
                this.loadDefaultGames();
                this.displayMainMenu();
            }

            setupEventListeners() {
                // Menu Controls
                document.getElementById('btn-start').addEventListener('click', () => {
                    document.getElementById('game-menu').style.display = 'flex';
                });
                
                document.getElementById('close-menu').addEventListener('click', () => {
                    document.getElementById('game-menu').style.display = 'none';
                });

                // Upload Game
                document.getElementById('upload-game-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                
                document.getElementById('file-input').addEventListener('change', (event) => {
                    this.handleFileUpload(event);
                });

                // Export Game
                document.getElementById('btn-select').addEventListener('click', () => {
                    if (this.currentGame) {
                        document.getElementById('overlay').style.display = 'flex';
                    }
                });
                
                document.getElementById('close-modal').addEventListener('click', () => {
                    document.getElementById('overlay').style.display = 'none';
                });
                
                document.getElementById('cancel-export').addEventListener('click', () => {
                    document.getElementById('overlay').style.display = 'none';
                });
                
                document.getElementById('confirm-export').addEventListener('click', () => {
                    this.exportCurrentGame();
                    document.getElementById('overlay').style.display = 'none';
                });

                // Game Controls
                const controls = {
                    up: document.getElementById('d-up'),
                    right: document.getElementById('d-right'),
                    down: document.getElementById('d-down'),
                    left: document.getElementById('d-left'),
                    a: document.getElementById('btn-a'),
                    b: document.getElementById('btn-b')
                };

                // Add touch/click event listeners for controls
                Object.entries(controls).forEach(([key, element]) => {
                    // MouseDown/TouchStart event
                    element.addEventListener('mousedown', () => this.handleButtonPress(key));
                    element.addEventListener('touchstart', () => this.handleButtonPress(key));
                    
                    // MouseUp/TouchEnd event
                    element.addEventListener('mouseup', () => this.handleButtonRelease(key));
                    element.addEventListener('touchend', () => this.handleButtonRelease(key));
                    
                    // Add attribute for preventing touch default behavior
                    element.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                });

                // Add keyboard event listeners
                document.addEventListener('keydown', (e) => {
                    this.handleKeyDown(e);
                });
                
                document.addEventListener('keyup', (e) => {
                    this.handleKeyUp(e);
                });
            }

            handleKeyDown(e) {
                if (!this.currentGame || !this.gameRunning) return;
                
                const keyMap = {
                    'ArrowUp': 'up',
                    'ArrowRight': 'right',
                    'ArrowDown': 'down',
                    'ArrowLeft': 'left',
                    'z': 'a',
                    'x': 'b'
                };
                
                if (keyMap[e.key]) {
                    this.handleButtonPress(keyMap[e.key]);
                    e.preventDefault();
                }
            }

            handleKeyUp(e) {
                if (!this.currentGame || !this.gameRunning) return;
                
                const keyMap = {
                    'ArrowUp': 'up',
                    'ArrowRight': 'right',
                    'ArrowDown': 'down',
                    'ArrowLeft': 'left',
                    'z': 'a',
                    'x': 'b'
                };
                
                if (keyMap[e.key]) {
                    this.handleButtonRelease(keyMap[e.key]);
                    e.preventDefault();
                }
            }

            handleButtonPress(button) {
                if (this.currentGame && this.gameRunning && this.currentGame.handleInput) {
                    this.currentGame.handleInput(button, true);
                }
            }

            handleButtonRelease(button) {
                if (this.currentGame && this.gameRunning && this.currentGame.handleInput) {
                    this.currentGame.handleInput(button, false);
                }
            }

            loadDefaultGames() {
                // Snake 2.0
                this.gameLibrary['snake-2.0'] = {
                    id: 'snake-2.0',
                    name: 'Snake 2.0',
                    description: 'Classic snake game with power-ups',
                    icon: '🐍',
                    gameData: {
                        width: 20,
                        height: 18,
                        initialSpeed: 150,
                        snakeColor: '#223344',
                        foodColor: '#e42c64',
                        powerupColor: '#44aabb',
                        backgroundColor: '#8bac0f'
                    },
                    initialize: function(display) {
                        this.display = display;
                        this.canvas = document.createElement('canvas');
                        this.canvas.width = 280;
                        this.canvas.height = 248;
                        display.appendChild(this.canvas);
                        this.ctx = this.canvas.getContext('2d');
                        
                        this.width = this.gameData.width;
                        this.height = this.gameData.height;
                        this.cellSize = this.canvas.width / this.width;
                        
                        this.snake = [
                            {x: Math.floor(this.width/2), y: Math.floor(this.height/2)},
                            {x: Math.floor(this.width/2)-1, y: Math.floor(this.height/2)},
                            {x: Math.floor(this.width/2)-2, y: Math.floor(this.height/2)}
                        ];
                        
                        this.direction = 'right';
                        this.nextDirection = 'right';
                        this.score = 0;
                        this.food = this.generateFood();
                        this.powerup = null;
                        this.powerupActive = false;
                        this.powerupType = null;
                        this.powerupTimer = 0;
                        this.gameOver = false;
                        this.speed = this.gameData.initialSpeed;
                        this.inputQueue = [];
                        
                        this.render();
                    },
                    
                    handleInput: function(button, isPressed) {
                        if (isPressed) {
                            switch(button) {
                                case 'up':
                                    if (this.direction !== 'down') {
                                        this.inputQueue.push('up');
                                    }
                                    break;
                                case 'right':
                                    if (this.direction !== 'left') {
                                        this.inputQueue.push('right');
                                    }
                                    break;
                                case 'down':
                                    if (this.direction !== 'up') {
                                        this.inputQueue.push('down');
                                    }
                                    break;
                                case 'left':
                                    if (this.direction !== 'right') {
                                        this.inputQueue.push('left');
                                    }
                                    break;
                                case 'a':
                                    if (this.gameOver) {
                                        this.restart();
                                    }
                                    break;
                            }
                        }
                    },
                    
                    update: function() {
                        if (this.gameOver) return;
                        
                        // Process the input queue
                        if (this.inputQueue.length > 0) {
                            const newDirection = this.inputQueue.shift();
                            // Check if the new direction is valid based on current direction
                            if ((this.direction === 'up' || this.direction === 'down') && 
                                (newDirection === 'left' || newDirection === 'right')) {
                                this.nextDirection = newDirection;
                            } else if ((this.direction === 'left' || this.direction === 'right') && 
                                      (newDirection === 'up' || newDirection === 'down')) {
                                this.nextDirection = newDirection;
                            }
                        }
                        
                        this.direction = this.nextDirection;
                        
                        // Calculate new head position
                        const head = {...this.snake[0]};
                        
                        switch(this.direction) {
                            case 'up': head.y--; break;
                            case 'right': head.x++; break;
                            case 'down': head.y++; break;
                            case 'left': head.x--; break;
                        }
                        
                        // Check collision with walls
                        if (head.x < 0 || head.x >= this.width || head.y < 0 || head.y >= this.height) {
                            this.gameOver = true;
                            return;
                        }
                        
                        // Check collision with self (except for ghost powerup)
                        if (!this.powerupActive || this.powerupType !== 'ghost') {
                            for (let i = 0; i < this.snake.length; i++) {
                                if (head.x === this.snake[i].x && head.y === this.snake[i].y) {
                                    this.gameOver = true;
                                    return;
                                }
                            }
                        }
                        
                        // Add new head
                        this.snake.unshift(head);
                        
                        // Check if food is eaten
                        if (head.x === this.food.x && head.y === this.food.y) {
                            this.score++;
                            this.food = this.generateFood();
                            
                            // Possibly spawn a powerup (20% chance)
                            if (!this.powerup && Math.random() < 0.2) {
                                this.powerup = this.generatePowerup();
                            }
                        } else {
                            // Remove tail if no food was eaten
                            this.snake.pop();
                        }
                        
                        // Check if powerup is eaten
                        if (this.powerup && head.x === this.powerup.x && head.y === this.powerup.y) {
                            this.activatePowerup(this.powerup.type);
                            this.powerup = null;
                        }
                        
                        // Update powerup timer
                        if (this.powerupActive) {
                            this.powerupTimer--;
                            if (this.powerupTimer <= 0) {
                                this.deactivatePowerup();
                            }
                        }
                    },
                    
                    render: function() {
                        // Clear canvas
                        this.ctx.fillStyle = this.gameData.backgroundColor;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Draw snake
                        for (let i = 0; i < this.snake.length; i++) {
                            const segment = this.snake[i];
                            
                            let color = this.gameData.snakeColor;
                            if (this.powerupActive) {
                                if (this.powerupType === 'speed') {
                                    color = '#ff9900';
                                } else if (this.powerupType === 'ghost') {
                                    color = 'rgba(34, 51, 68, 0.5)';
                                } else if (this.powerupType === 'magnet') {
                                    color = '#9900ff';
                                }
                            }
                            
                            this.ctx.fillStyle = i === 0 ? color : (color === 'rgba(34, 51, 68, 0.5)' ? color : `${color}88`);
                            this.ctx.fillRect(
                                segment.x * this.cellSize,
                                segment.y * this.cellSize,
                                this.cellSize,
                                this.cellSize
                            );
                        }
                        
                        // Draw food
                        this.ctx.fillStyle = this.gameData.foodColor;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            this.food.x * this.cellSize + this.cellSize/2,
                            this.food.y * this.cellSize + this.cellSize/2,
                            this.cellSize/2,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.fill();
                        
                        // Draw powerup if exists
                        if (this.powerup) {
                            this.ctx.fillStyle = this.gameData.powerupColor;
                            this.ctx.beginPath();
                            this.ctx.arc(
                                this.powerup.x * this.cellSize + this.cellSize/2,
                                this.powerup.y * this.cellSize + this.cellSize/2,
                                this.cellSize/2,
                                0,
                                Math.PI * 2
                            );
                            this.ctx.fill();
                            
                            // Add a special symbol based on the powerup type
                            this.ctx.fillStyle = 'white';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.font = `${this.cellSize * 0.7}px Arial`;
                            let symbol;
                            switch(this.powerup.type) {
                                case 'speed': symbol = '⚡'; break;
                                case 'ghost': symbol = '👻'; break;
                                case 'magnet': symbol = '🧲'; break;
                            }
                            this.ctx.fillText(
                                symbol,
                                this.powerup.x * this.cellSize + this.cellSize/2,
                                this.powerup.y * this.cellSize + this.cellSize/2
                            );
                        }
                        
                        // Draw score
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(0, 0, this.canvas.width, 20);
                        this.ctx.fillStyle = 'white';
                        this.ctx.textAlign = 'left';
                        this.ctx.textBaseline = 'top';
                        this.ctx.font = '12px "Press Start 2P"';
                        this.ctx.fillText(`SCORE: ${this.score}`, 10, 5);
                        
                        // Draw powerup timer if active
                        if (this.powerupActive) {
                            this.ctx.fillStyle = 'white';
                            this.ctx.textAlign = 'right';
                            this.ctx.fillText(`${this.powerupType.toUpperCase()}: ${Math.ceil(this.powerupTimer / 10)}`, this.canvas.width - 10, 5);
                        }
                        
                        // Draw game over message
                        if (this.gameOver) {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            
                            this.ctx.fillStyle = 'white';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.font = '16px "Press Start 2P"';
                            this.ctx.fillText('GAME OVER', this.canvas.width/2, this.canvas.height/2 - 20);
                            this.ctx.font = '12px "Press Start 2P"';
                            this.ctx.fillText(`SCORE: ${this.score}`, this.canvas.width/2, this.canvas.height/2 + 10);
                            this.ctx.fillText('PRESS A TO RESTART', this.canvas.width/2, this.canvas.height/2 + 40);
                        }
                    },
                    
                    generateFood: function() {
                        // Generate food in a random position (not occupied by snake)
                        let x, y;
                        let validPosition = false;
                        
                        while (!validPosition) {
                            x = Math.floor(Math.random() * this.width);
                            y = Math.floor(Math.random() * this.height);
                            validPosition = true;
                            
                            // Check if the position overlaps with the snake
                            for (let i = 0; i < this.snake.length; i++) {
                                if (x === this.snake[i].x && y === this.snake[i].y) {
                                    validPosition = false;
                                    break;
                                }
                            }
                            
                            // Check if the position overlaps with existing powerup
                            if (this.powerup && x === this.powerup.x && y === this.powerup.y) {
                                validPosition = false;
                            }
                        }
                        
                        return {x, y};
                    },
                    
                    generatePowerup: function() {
                        // Generate powerup in a random position (not occupied by snake or food)
                        let x, y, type;
                        let validPosition = false;
                        
                        // Determine the powerup type
                        const types = ['speed', 'ghost', 'magnet'];
                        type = types[Math.floor(Math.random() * types.length)];
                        
                        while (!validPosition) {
                            x = Math.floor(Math.random() * this.width);
                            y = Math.floor(Math.random() * this.height);
                            validPosition = true;
                            
                            // Check if the position overlaps with the snake
                            for (let i = 0; i < this.snake.length; i++) {
                                if (x === this.snake[i].x && y === this.snake[i].y) {
                                    validPosition = false;
                                    break;
                                }
                            }
                            
                            // Check if the position overlaps with the food
                            if (x === this.food.x && y === this.food.y) {
                                validPosition = false;
                            }
                        }
                        
                        return {x, y, type};
                    },
                    
                    activatePowerup: function(type) {
                        this.powerupActive = true;
                        this.powerupType = type;
                        this.powerupTimer = 100; // 10 seconds at 10 updates per second
                        
                        switch(type) {
                            case 'speed':
                                this.originalSpeed = this.speed;
                                this.speed = this.speed / 1.5;
                                break;
                            case 'ghost':
                                // Ghost mode is handled in update logic
                                break;
                            case 'magnet':
                                // Magnet attracts food - handled in update logic
                                this.food = this.attractFood();
                                break;
                        }
                    },
                    
                    deactivatePowerup: function() {
                        if (this.powerupType === 'speed') {
                            this.speed = this.originalSpeed;
                        }
                        
                        this.powerupActive = false;
                        this.powerupType = null;
                        this.powerupTimer = 0;
                    },
                    
                    attractFood: function() {
                        // Find a position near the snake head
                        const head = this.snake[0];
                        const positions = [];
                        
                        // Check all positions within 3 cells of the head
                        for (let x = Math.max(0, head.x - 3); x <= Math.min(this.width - 1, head.x + 3); x++) {
                            for (let y = Math.max(0, head.y - 3); y <= Math.min(this.height - 1, head.y + 3); y++) {
                                // Skip positions occupied by the snake
                                let isOccupied = false;
                                for (let i = 0; i < this.snake.length; i++) {
                                    if (x === this.snake[i].x && y === this.snake[i].y) {
                                        isOccupied = true;
                                        break;
                                    }
                                }
                                
                                if (!isOccupied) {
                                    positions.push({x, y});
                                }
                            }
                        }
                        
                        // Return a random position from the available ones,
                        // or a completely random position if none are available
                        if (positions.length > 0) {
                            return positions[Math.floor(Math.random() * positions.length)];
                        } else {
                            return this.generateFood();
                        }
                    },
                    
                    restart: function() {
                        this.snake = [
                            {x: Math.floor(this.width/2), y: Math.floor(this.height/2)},
                            {x: Math.floor(this.width/2)-1, y: Math.floor(this.height/2)},
                            {x: Math.floor(this.width/2)-2, y: Math.floor(this.height/2)}
                        ];
                        
                        this.direction = 'right';
                        this.nextDirection = 'right';
                        this.score = 0;
                        this.food = this.generateFood();
                        this.powerup = null;
                        this.powerupActive = false;
                        this.powerupType = null;
                        this.powerupTimer = 0;
                        this.gameOver = false;
                        this.speed = this.gameData.initialSpeed;
                        this.inputQueue = [];
                    },
                    
                    cleanup: function() {
                        if (this.canvas && this.canvas.parentNode) {
                            this.canvas.parentNode.removeChild(this.canvas);
                        }
                    }
                };

                // Puzzle Blocks Game
                this.gameLibrary['puzzle-blocks'] = {
                    id: 'puzzle-blocks',
                    name: 'Puzzle Blocks',
                    description: 'Arrange falling blocks to clear lines',
                    icon: '🧩',
                    gameData: {
                        boardWidth: 10,
                        boardHeight: 20,
                        backgroundColor: '#8bac0f',
                        blockColors: [
                            '#e42c64', // I
                            '#f49900', // J
                            '#0a84ff', // L
                            '#9a28d7', // O
                            '#38c5fe', // S
                            '#63d34c', // T
                            '#ffbc00'  // Z
                        ]
                    },
                    initialize: function(display) {
                        this.display = display;
                        this.canvas = document.createElement('canvas');
                        this.canvas.width = 280;
                        this.canvas.height = 248;
                        display.appendChild(this.canvas);
                        this.ctx = this.canvas.getContext('2d');
                        
                        this.width = this.gameData.boardWidth;
                        this.height = this.gameData.boardHeight;
                        this.cellSize = Math.min(
                            this.canvas.width / (this.width + 6), // +6 for next piece display
                            this.canvas.height / this.height
                        );
                        this.boardOffsetX = (this.canvas.width - this.width * this.cellSize) / 2;
                        this.boardOffsetY = (this.canvas.height - this.height * this.cellSize) / 2;
                        
                        // Block shapes (each represented as an array of positions relative to rotation center)
                        this.shapes = [
                            // I
                            [
                                [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:2, y:0}],
                                [{x:1, y:-1}, {x:1, y:0}, {x:1, y:1}, {x:1, y:2}],
                                [{x:-1, y:1}, {x:0, y:1}, {x:1, y:1}, {x:2, y:1}],
                                [{x:0, y:-1}, {x:0, y:0}, {x:0, y:1}, {x:0, y:2}]
                            ],
                            // J
                            [
                                [{x:-1, y:-1}, {x:-1, y:0}, {x:0, y:0}, {x:1, y:0}],
                                [{x:0, y:-1}, {x:1, y:-1}, {x:0, y:0}, {x:0, y:1}],
                                [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:1, y:1}],
                                [{x:0, y:-1}, {x:0, y:0}, {x:-1, y:1}, {x:0, y:1}]
                            ],
                            // L
                            [
                                [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:1, y:-1}],
                                [{x:0, y:-1}, {x:0, y:0}, {x:0, y:1}, {x:1, y:1}],
                                [{x:-1, y:1}, {x:-1, y:0}, {x:0, y:0}, {x:1, y:0}],
                                [{x:-1, y:-1}, {x:0, y:-1}, {x:0, y:0}, {x:0, y:1}]
                            ],
                            // O
                            [
                                [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}],
                                [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}],
                                [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}],
                                [{x:0, y:0}, {x:1, y:0}, {x:0, y:1}, {x:1, y:1}]
                            ],
                            // S
                            [
                                [{x:-1, y:0}, {x:0, y:0}, {x:0, y:-1}, {x:1, y:-1}],
                                [{x:0, y:-1}, {x:0, y:0}, {x:1, y:0}, {x:1, y:1}],
                                [{x:-1, y:1}, {x:0, y:1}, {x:0, y:0}, {x:1, y:0}],
                                [{x:-1, y:-1}, {x:-1, y:0}, {x:0, y:0}, {x:0, y:1}]
                            ],
                            // T
                            [
                                [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:0, y:-1}],
                                [{x:0, y:-1}, {x:0, y:0}, {x:0, y:1}, {x:1, y:0}],
                                [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}, {x:0, y:1}],
                                [{x:-1, y:0}, {x:0, y:-1}, {x:0, y:0}, {x:0, y:1}]
                            ],
                            // Z
                            [
                                [{x:-1, y:-1}, {x:0, y:-1}, {x:0, y:0}, {x:1, y:0}],
                                [{x:1, y:-1}, {x:0, y:0}, {x:1, y:0}, {x:0, y:1}],
                                [{x:-1, y:0}, {x:0, y:0}, {x:0, y:1}, {x:1, y:1}],
                                [{x:0, y:-1}, {x:-1, y:0}, {x:0, y:0}, {x:-1, y:1}]
                            ]
                        ];
                        
                        this.board = Array(this.height).fill().map(() => Array(this.width).fill(null));
                        this.currentPiece = null;
                        this.currentX = 0;
                        this.currentY = 0;
                        this.currentRotation = 0;
                        this.nextPiece = null;
                        this.score = 0;
                        this.level = 1;
                        this.linesCleared = 0;
                        this.gameOver = false;
                        this.dropCounter = 0;
                        this.dropInterval = 1000; // Initial drop speed (ms)
                        this.lastTime = 0;
                        this.keyState = {
                            left: false,
                            right: false,
                            down: false
                        };
                        this.keyRepeatDelay = 200; // Initial delay before key repeat (ms)
                        this.keyRepeatInterval = 100; // Interval for key repeats (ms)
                        this.keyTimer = null;
                        
                        this.generateNextPiece();
                        this.spawnPiece();
                        
                        this.render();
                    },
                    
                    handleInput: function(button, isPressed) {
                        if (this.gameOver) {
                            if (button === 'a' && isPressed) {
                                this.restart();
                            }
                            return;
                        }
                        
                        switch(button) {
                            case 'left':
                                this.keyState.left = isPressed;
                                if (isPressed) {
                                    this.moveLeft();
                                    // Start key repeat after delay
                                    clearTimeout(this.keyTimer);
                                    this.keyTimer = setTimeout(() => {
                                        const repeatFunc = () => {
                                            if (this.keyState.left) {
                                                this.moveLeft();
                                                this.keyTimer = setTimeout(repeatFunc, this.keyRepeatInterval);
                                            }
                                        };
                                        repeatFunc();
                                    }, this.keyRepeatDelay);
                                }
                                break;
                                
                            case 'right':
                                this.keyState.right = isPressed;
                                if (isPressed) {
                                    this.moveRight();
                                    // Start key repeat after delay
                                    clearTimeout(this.keyTimer);
                                    this.keyTimer = setTimeout(() => {
                                        const repeatFunc = () => {
                                            if (this.keyState.right) {
                                                this.moveRight();
                                                this.keyTimer = setTimeout(repeatFunc, this.keyRepeatInterval);
                                            }
                                        };
                                        repeatFunc();
                                    }, this.keyRepeatDelay);
                                }
                                break;
                                
                            case 'down':
                                this.keyState.down = isPressed;
                                if (isPressed) {
                                    this.moveDown();
                                    // Start key repeat after delay
                                    clearTimeout(this.keyTimer);
                                    this.keyTimer = setTimeout(() => {
                                        const repeatFunc = () => {
                                            if (this.keyState.down) {
                                                this.moveDown();
                                                this.keyTimer = setTimeout(repeatFunc, this.keyRepeatInterval);
                                            }
                                        };
                                        repeatFunc();
                                    }, this.keyRepeatDelay);
                                }
                                break;
                                
                            case 'up':
                                if (isPressed) {
                                    this.rotate();
                                }
                                break;
                                
                            case 'a':
                                if (isPressed) {
                                    this.rotate();
                                }
                                break;
                                
                            case 'b':
                                if (isPressed) {
                                    this.hardDrop();
                                }
                                break;
                        }
                    },
                    
                    update: function(time) {
                        if (this.gameOver) return;
                        
                        const deltaTime = time - this.lastTime;
                        this.lastTime = time;
                        
                        this.dropCounter += deltaTime;
                        if (this.dropCounter > this.dropInterval) {
                            this.moveDown();
                            this.dropCounter = 0;
                        }
                    },
                    
                    render: function() {
                        // Clear canvas
                        this.ctx.fillStyle = this.gameData.backgroundColor;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Draw border
                        this.ctx.strokeStyle = '#222222';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(
                            this.boardOffsetX - 1,
                            this.boardOffsetY - 1,
                            this.width * this.cellSize + 2,
                            this.height * this.cellSize + 2
                        );
                        
                        // Draw board
                        for (let y = 0; y < this.height; y++) {
                            for (let x = 0; x < this.width; x++) {
                                if (this.board[y][x] !== null) {
                                    this.drawBlock(
                                        x,
                                        y,
                                        this.gameData.blockColors[this.board[y][x]]
                                    );
                                }
                            }
                        }
                        
                        // Draw current piece
                        if (this.currentPiece !== null) {
                            const shape = this.shapes[this.currentPiece][this.currentRotation];
                            for (let i = 0; i < shape.length; i++) {
                                const x = this.currentX + shape[i].x;
                                const y = this.currentY + shape[i].y;
                                
                                if (y >= 0) { // Only draw if the block is visible on the board
                                    this.drawBlock(
                                        x,
                                        y,
                                        this.gameData.blockColors[this.currentPiece]
                                    );
                                }
                            }
                            
                            // Draw ghost piece (preview of where the piece will land)
                            let ghostY = this.currentY;
                            while (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, ghostY + 1)) {
                                ghostY++;
                            }
                            
                            if (ghostY !== this.currentY) {
                                for (let i = 0; i < shape.length; i++) {
                                    const x = this.currentX + shape[i].x;
                                    const y = ghostY + shape[i].y;
                                    
                                    if (y >= 0) { // Only draw if the block is visible on the board
                                        this.drawGhostBlock(
                                            x,
                                            y,
                                            this.gameData.blockColors[this.currentPiece]
                                        );
                                    }
                                }
                            }
                        }
                        
                        // Draw next piece preview
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(
                            this.boardOffsetX + this.width * this.cellSize + 10,
                            this.boardOffsetY,
                            80,
                            60
                        );
                        
                        this.ctx.fillStyle = 'white';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'top';
                        this.ctx.font = '10px "Press Start 2P"';
                        this.ctx.fillText(
                            'NEXT',
                            this.boardOffsetX + this.width * this.cellSize + 50,
                            this.boardOffsetY + 5
                        );
                        
                        if (this.nextPiece !== null) {
                            const shape = this.shapes[this.nextPiece][0];
                            const previewOffsetX = this.boardOffsetX + this.width * this.cellSize + 40;
                            const previewOffsetY = this.boardOffsetY + 25;
                            
                            for (let i = 0; i < shape.length; i++) {
                                this.ctx.fillStyle = this.gameData.blockColors[this.nextPiece];
                                this.ctx.fillRect(
                                    previewOffsetX + shape[i].x * (this.cellSize * 0.7),
                                    previewOffsetY + shape[i].y * (this.cellSize * 0.7),
                                    this.cellSize * 0.7,
                                    this.cellSize * 0.7
                                );
                                
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                                this.ctx.lineWidth = 1;
                                this.ctx.strokeRect(
                                    previewOffsetX + shape[i].x * (this.cellSize * 0.7),
                                    previewOffsetY + shape[i].y * (this.cellSize * 0.7),
                                    this.cellSize * 0.7,
                                    this.cellSize * 0.7
                                );
                            }
                        }
                        
                        // Draw score, level, and lines
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(
                            this.boardOffsetX + this.width * this.cellSize + 10,
                            this.boardOffsetY + 70,
                            80,
                            90
                        );
                        
                        this.ctx.fillStyle = 'white';
                        this.ctx.textAlign = 'left';
                        this.ctx.textBaseline = 'top';
                        this.ctx.font = '10px "Press Start 2P"';
                        
                        this.ctx.fillText(
                            'SCORE',
                            this.boardOffsetX + this.width * this.cellSize + 15,
                            this.boardOffsetY + 75
                        );
                        this.ctx.fillText(
                            this.score.toString(),
                            this.boardOffsetX + this.width * this.cellSize + 15,
                            this.boardOffsetY + 90
                        );
                        
                        this.ctx.fillText(
                            'LEVEL',
                            this.boardOffsetX + this.width * this.cellSize + 15,
                            this.boardOffsetY + 110
                        );
                        this.ctx.fillText(
                            this.level.toString(),
                            this.boardOffsetX + this.width * this.cellSize + 15,
                            this.boardOffsetY + 125
                        );
                        
                        this.ctx.fillText(
                            'LINES',
                            this.boardOffsetX + this.width * this.cellSize + 15,
                            this.boardOffsetY + 145
                        );
                        this.ctx.fillText(
                            this.linesCleared.toString(),
                            this.boardOffsetX + this.width * this.cellSize + 15,
                            this.boardOffsetY + 160
                        );
                        
                        // Draw game over message
                        if (this.gameOver) {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            this.ctx.fillRect(
                                this.boardOffsetX,
                                this.boardOffsetY + this.height * this.cellSize / 2 - 40,
                                this.width * this.cellSize,
                                80
                            );
                            
                            this.ctx.fillStyle = 'white';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.font = '16px "Press Start 2P"';
                            this.ctx.fillText(
                                'GAME OVER',
                                this.boardOffsetX + this.width * this.cellSize / 2,
                                this.boardOffsetY + this.height * this.cellSize / 2 - 15
                            );
                            
                            this.ctx.font = '10px "Press Start 2P"';
                            this.ctx.fillText(
                                'PRESS A TO RESTART',
                                this.boardOffsetX + this.width * this.cellSize / 2,
                                this.boardOffsetY + this.height * this.cellSize / 2 + 15
                            );
                        }
                    },
                    
                    drawBlock: function(x, y, color) {
                        const pixelX = this.boardOffsetX + x * this.cellSize;
                        const pixelY = this.boardOffsetY + y * this.cellSize;
                        
                        // Fill
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);
                        
                        // Highlight
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.beginPath();
                        this.ctx.moveTo(pixelX, pixelY);
                        this.ctx.lineTo(pixelX + this.cellSize, pixelY);
                        this.ctx.lineTo(pixelX, pixelY + this.cellSize);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Shadow
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.beginPath();
                        this.ctx.moveTo(pixelX + this.cellSize, pixelY);
                        this.ctx.lineTo(pixelX + this.cellSize, pixelY + this.cellSize);
                        this.ctx.lineTo(pixelX, pixelY + this.cellSize);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Border
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(pixelX, pixelY, this.cellSize, this.cellSize);
                    },
                    
                    drawGhostBlock: function(x, y, color) {
                        const pixelX = this.boardOffsetX + x * this.cellSize;
                        const pixelY = this.boardOffsetY + y * this.cellSize;
                        
                        // Draw outline
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(
                            pixelX + 2,
                            pixelY + 2,
                            this.cellSize - 4,
                            this.cellSize - 4
                        );
                    },
                    
                    generateNextPiece: function() {
                        this.nextPiece = Math.floor(Math.random() * this.shapes.length);
                    },
                    
                    spawnPiece: function() {
                        if (this.nextPiece === null) {
                            this.generateNextPiece();
                        }

                        this.currentPiece = this.nextPiece;
                        this.currentRotation = 0;
                        this.currentX = Math.floor(this.width / 2) - 1;
                        this.currentY = 0;
                        
                        this.generateNextPiece();
                        
                        // Check if the new piece immediately collides (game over)
                        if (this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, this.currentY)) {
                            this.gameOver = true;
                        }
                    },
                    
                    moveLeft: function() {
                        if (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX - 1, this.currentY)) {
                            this.currentX--;
                        }
                    },
                    
                    moveRight: function() {
                        if (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX + 1, this.currentY)) {
                            this.currentX++;
                        }
                    },
                    
                    moveDown: function() {
                        if (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, this.currentY + 1)) {
                            this.currentY++;
                        } else {
                            this.lockPiece();
                            this.clearLines();
                            this.spawnPiece();
                        }
                    },
                    
                    hardDrop: function() {
                        while (!this.checkCollision(this.currentPiece, this.currentRotation, this.currentX, this.currentY + 1)) {
                            this.currentY++;
                        }
                        this.lockPiece();
                        this.clearLines();
                        this.spawnPiece();
                    },
                    
                    rotate: function() {
                        const nextRotation = (this.currentRotation + 1) % 4;
                        
                        // Try normal rotation
                        if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX, this.currentY)) {
                            this.currentRotation = nextRotation;
                            return;
                        }
                        
                        // Try wall kick - left
                        if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX - 1, this.currentY)) {
                            this.currentRotation = nextRotation;
                            this.currentX--;
                            return;
                        }
                        
                        // Try wall kick - right
                        if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX + 1, this.currentY)) {
                            this.currentRotation = nextRotation;
                            this.currentX++;
                            return;
                        }
                        
                        // Try wall kick - up (for I piece mostly)
                        if (!this.checkCollision(this.currentPiece, nextRotation, this.currentX, this.currentY - 1)) {
                            this.currentRotation = nextRotation;
                            this.currentY--;
                            return;
                        }
                    },
                    
                    checkCollision: function(piece, rotation, x, y) {
                        const shape = this.shapes[piece][rotation];
                        
                        for (let i = 0; i < shape.length; i++) {
                            const blockX = x + shape[i].x;
                            const blockY = y + shape[i].y;
                            
                            // Check if out of bounds
                            if (blockX < 0 || blockX >= this.width || blockY >= this.height) {
                                return true;
                            }
                            
                            // Check if overlaps with existing blocks on the board
                            if (blockY >= 0 && this.board[blockY][blockX] !== null) {
                                return true;
                            }
                        }
                        
                        return false;
                    },
                    
                    lockPiece: function() {
                        const shape = this.shapes[this.currentPiece][this.currentRotation];
                        
                        for (let i = 0; i < shape.length; i++) {
                            const blockX = this.currentX + shape[i].x;
                            const blockY = this.currentY + shape[i].y;
                            
                            if (blockY >= 0) { // Only place on the board if visible
                                this.board[blockY][blockX] = this.currentPiece;
                            }
                        }
                        
                        // Add points for placing a piece
                        this.score += 10;
                    },
                    
                    clearLines: function() {
                        let linesCleared = 0;
                        
                        for (let y = this.height - 1; y >= 0; y--) {
                            let isLineFull = true;
                            
                            for (let x = 0; x < this.width; x++) {
                                if (this.board[y][x] === null) {
                                    isLineFull = false;
                                    break;
                                }
                            }
                            
                            if (isLineFull) {
                                // Remove the line
                                for (let yy = y; yy > 0; yy--) {
                                    for (let x = 0; x < this.width; x++) {
                                        this.board[yy][x] = this.board[yy - 1][x];
                                    }
                                }
                                
                                // Clear the top line
                                for (let x = 0; x < this.width; x++) {
                                    this.board[0][x] = null;
                                }
                                
                                // Since we removed a line, we need to check the same position again
                                y++;
                                linesCleared++;
                            }
                        }
                        
                        if (linesCleared > 0) {
                            // Add points for clearing lines (more points for clearing multiple lines at once)
                            const points = [0, 100, 300, 500, 800];
                            this.score += points[linesCleared];
                            
                            this.linesCleared += linesCleared;
                            
                            // Increase level every 10 lines
                            const newLevel = Math.floor(this.linesCleared / 10) + 1;
                            if (newLevel > this.level) {
                                this.level = newLevel;
                                this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100); // Speed up as level increases
                            }
                        }
                    },
                    
                    restart: function() {
                        this.board = Array(this.height).fill().map(() => Array(this.width).fill(null));
                        this.currentPiece = null;
                        this.currentX = 0;
                        this.currentY = 0;
                        this.currentRotation = 0;
                        this.nextPiece = null;
                        this.score = 0;
                        this.level = 1;
                        this.linesCleared = 0;
                        this.gameOver = false;
                        this.dropCounter = 0;
                        this.dropInterval = 1000;
                        this.lastTime = 0;
                        
                        this.generateNextPiece();
                        this.spawnPiece();
                    },
                    
                    cleanup: function() {
                        if (this.canvas && this.canvas.parentNode) {
                            this.canvas.parentNode.removeChild(this.canvas);
                        }
                        
                        clearTimeout(this.keyTimer);
                    }
                };

                // Racing Game
                this.gameLibrary['pixel-racer'] = {
                    id: 'pixel-racer',
                    name: 'Pixel Racer',
                    description: 'Top-down racing game',
                    icon: '🏎️',
                    gameData: {
                        trackWidth: 20,
                        trackHeight: 25,
                        backgroundColor: '#8bac0f',
                        roadColor: '#333333',
                        grassColor: '#4e8d0f',
                        carColor: '#e42c64',
                        obstacleColor: '#f49900',
                        finishLineColor: '#ffffff'
                    },
                    initialize: function(display) {
                        this.display = display;
                        this.canvas = document.createElement('canvas');
                        this.canvas.width = 280;
                        this.canvas.height = 248;
                        display.appendChild(this.canvas);
                        this.ctx = this.canvas.getContext('2d');
                        
                        this.width = this.gameData.trackWidth;
                        this.height = this.gameData.trackHeight;
                        this.cellSize = Math.min(
                            this.canvas.width / this.width,
                            this.canvas.height / this.height
                        );
                        this.trackOffsetX = (this.canvas.width - this.width * this.cellSize) / 2;
                        this.trackOffsetY = (this.canvas.height - this.height * this.cellSize) / 2;
                        
                        this.car = {
                            x: Math.floor(this.width / 2), // Center of the track
                            y: this.height - 2, // Near the bottom
                            speed: 0,
                            maxSpeed: 0.2,
                            acceleration: 0.001,
                            deceleration: 0.0005,
                            turnSpeed: 0.1,
                            direction: Math.PI * 1.5, // Pointing up
                            width: 2,
                            height: 3
                        };
                        
                        this.track = this.generateTrack();
                        this.obstacles = this.generateObstacles();
                        this.gameOver = false;
                        this.finished = false;
                        this.score = 0;
                        this.time = 0;
                        this.bestTime = Infinity;
                        this.inputState = {
                            up: false,
                            down: false,
                            left: false,
                            right: false
                        };
                        
                        this.render();
                    },
                    
                    handleInput: function(button, isPressed) {
                        if (this.gameOver || this.finished) {
                            if (button === 'a' && isPressed) {
                                this.restart();
                            }
                            return;
                        }
                        
                        switch(button) {
                            case 'up':
                                this.inputState.up = isPressed;
                                break;
                            case 'down':
                                this.inputState.down = isPressed;
                                break;
                            case 'left':
                                this.inputState.left = isPressed;
                                break;
                            case 'right':
                                this.inputState.right = isPressed;
                                break;
                        }
                    },
                    
                    update: function(deltaTime) {
                        if (this.gameOver || this.finished) return;
                        
                        // Update time
                        this.time += deltaTime;
                        
                        // Handle acceleration
                        if (this.inputState.up) {
                            this.car.speed += this.car.acceleration * deltaTime;
                            if (this.car.speed > this.car.maxSpeed) {
                                this.car.speed = this.car.maxSpeed;
                            }
                        } else if (this.inputState.down) {
                            this.car.speed -= this.car.acceleration * deltaTime;
                            if (this.car.speed < -this.car.maxSpeed / 2) { // Reverse is slower
                                this.car.speed = -this.car.maxSpeed / 2;
                            }
                        } else {
                            // Natural deceleration
                            if (this.car.speed > 0) {
                                this.car.speed -= this.car.deceleration * deltaTime;
                                if (this.car.speed < 0) this.car.speed = 0;
                            } else if (this.car.speed < 0) {
                                this.car.speed += this.car.deceleration * deltaTime;
                                if (this.car.speed > 0) this.car.speed = 0;
                            }
                        }
                        
                        // Handle turning (only if moving)
                        if (Math.abs(this.car.speed) > 0.01) {
                            if (this.inputState.left) {
                                this.car.direction -= this.car.turnSpeed * (this.car.speed / this.car.maxSpeed) * (deltaTime / 100);
                            } else if (this.inputState.right) {
                                this.car.direction += this.car.turnSpeed * (this.car.speed / this.car.maxSpeed) * (deltaTime / 100);
                            }
                        }
                        
                        // Update position
                        const newX = this.car.x + Math.sin(this.car.direction) * this.car.speed * (deltaTime / 10);
                        const newY = this.car.y - Math.cos(this.car.direction) * this.car.speed * (deltaTime / 10);
                        
                        // Check collision with track boundaries
                        if (this.checkTrackCollision(newX, newY)) {
                            // Collision - stop the car
                            this.car.speed = 0;
                        } else {
                            // No collision - update position
                            this.car.x = newX;
                            this.car.y = newY;
                        }
                        
                        // Check collision with obstacles
                        if (this.checkObstacleCollision()) {
                            this.gameOver = true;
                        }
                        
                        // Check if finished the race
                        if (this.checkFinishLine()) {
                            this.finished = true;
                            if (this.time < this.bestTime) {
                                this.bestTime = this.time;
                            }
                        }
                        
                        // Update score based on distance traveled
                        this.score = Math.floor(this.height - this.car.y); // Higher up the track = higher score
                        if (this.score < 0) this.score = 0;
                    },
                    
                    render: function() {
                        // Clear canvas
                        this.ctx.fillStyle = this.gameData.backgroundColor;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Draw track
                        for (let y = 0; y < this.height; y++) {
                            for (let x = 0; x < this.width; x++) {
                                const cell = this.track[y][x];
                                const pixelX = this.trackOffsetX + x * this.cellSize;
                                const pixelY = this.trackOffsetY + y * this.cellSize;
                                
                                if (cell === 1) { // Road
                                    this.ctx.fillStyle = this.gameData.roadColor;
                                } else if (cell === 2) { // Finish line
                                    this.ctx.fillStyle = this.gameData.finishLineColor;
                                } else { // Grass or out of bounds
                                    this.ctx.fillStyle = this.gameData.grassColor;
                                }
                                
                                this.ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);
                            }
                        }
                        
                        // Draw obstacles
                        for (let i = 0; i < this.obstacles.length; i++) {
                            const obs = this.obstacles[i];
                            const pixelX = this.trackOffsetX + obs.x * this.cellSize;
                            const pixelY = this.trackOffsetY + obs.y * this.cellSize;
                            
                            this.ctx.fillStyle = this.gameData.obstacleColor;
                            this.ctx.fillRect(pixelX, pixelY, this.cellSize, this.cellSize);
                        }
                        
                        // Draw car
                        this.ctx.save();
                        this.ctx.translate(
                            this.trackOffsetX + this.car.x * this.cellSize,
                            this.trackOffsetY + this.car.y * this.cellSize
                        );
                        this.ctx.rotate(this.car.direction);
                        
                        this.ctx.fillStyle = this.gameData.carColor;
                        this.ctx.fillRect(
                            -this.car.width * this.cellSize / 2,
                            -this.car.height * this.cellSize / 2,
                            this.car.width * this.cellSize,
                            this.car.height * this.cellSize
                        );
                        
                        this.ctx.restore();
                        
                        // Draw HUD
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(0, 0, this.canvas.width, 20);
                        
                        this.ctx.fillStyle = 'white';
                        this.ctx.textAlign = 'left';
                        this.ctx.textBaseline = 'top';
                        this.ctx.font = '10px "Press Start 2P"';
                        this.ctx.fillText(`TIME: ${(this.time / 1000).toFixed(1)}s`, 10, 5);
                        
                        this.ctx.textAlign = 'right';
                        this.ctx.fillText(`SCORE: ${this.score}`, this.canvas.width - 10, 5);
                        
                        // Draw game over or finished message
                        if (this.gameOver || this.finished) {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            this.ctx.fillRect(
                                this.trackOffsetX,
                                this.trackOffsetY + this.height * this.cellSize / 2 - 40,
                                this.width * this.cellSize,
                                80
                            );
                            
                            this.ctx.fillStyle = 'white';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.font = '16px "Press Start 2P"';
                            
                            if (this.gameOver) {
                                this.ctx.fillText(
                                    'CRASH!',
                                    this.trackOffsetX + this.width * this.cellSize / 2,
                                    this.trackOffsetY + this.height * this.cellSize / 2 - 15
                                );
                            } else {
                                this.ctx.fillText(
                                    'FINISH!',
                                    this.trackOffsetX + this.width * this.cellSize / 2,
                                    this.trackOffsetY + this.height * this.cellSize / 2 - 15
                                );
                                
                                this.ctx.font = '10px "Press Start 2P"';
                                this.ctx.fillText(
                                    `TIME: ${(this.time / 1000).toFixed(1)}s`,
                                    this.trackOffsetX + this.width * this.cellSize / 2,
                                    this.trackOffsetY + this.height * this.cellSize / 2 + 5
                                );
                                
                                if (this.bestTime < Infinity) {
                                    this.ctx.fillText(
                                        `BEST: ${(this.bestTime / 1000).toFixed(1)}s`,
                                        this.trackOffsetX + this.width * this.cellSize / 2,
                                        this.trackOffsetY + this.height * this.cellSize / 2 + 20
                                    );
                                }
                            }
                            
                            this.ctx.font = '10px "Press Start 2P"';
                            this.ctx.fillText(
                                'PRESS A TO RESTART',
                                this.trackOffsetX + this.width * this.cellSize / 2,
                                this.trackOffsetY + this.height * this.cellSize / 2 + 40
                            );
                        }
                    },
                    
                    generateTrack: function() {
                        // Create a basic oval track
                        const track = Array(this.height).fill().map(() => Array(this.width).fill(0));
                        
                        const trackWidth = 6; // Width of the road
                        const centerX = Math.floor(this.width / 2);
                        
                        for (let y = 0; y < this.height; y++) {
                            const roadLeft = centerX - Math.floor(trackWidth / 2);
                            const roadRight = centerX + Math.floor(trackWidth / 2);
                            
                            for (let x = roadLeft; x <= roadRight; x++) {
                                track[y][x] = 1; // Road
                            }
                        }
                        
                        // Add finish line near the top
                        const finishY = 2;
                        for (let x = 0; x < this.width; x++) {
                            if (track[finishY][x] === 1) {
                                track[finishY][x] = 2; // Finish line
                            }
                        }
                        
                        return track;
                    },
                    
                    generateObstacles: function() {
                        const obstacles = [];
                        const numObstacles = 15;
                        
                        for (let i = 0; i < numObstacles; i++) {
                            // Place obstacles on the road, but not near start or finish
                            let validPosition = false;
                            let x, y;
                            
                            while (!validPosition) {
                                x = Math.floor(Math.random() * this.width);
                                y = Math.floor(Math.random() * (this.height - 5));
                                
                                // Ensure it's on the road
                                if (this.track[y][x] === 1) {
                                    // Avoid finish line and start position
                                    if (y > 3 && y < this.height - 5) {
                                        validPosition = true;
                                        
                                        // Check if too close to another obstacle
                                        for (let j = 0; j < obstacles.length; j++) {
                                            const dx = Math.abs(x - obstacles[j].x);
                                            const dy = Math.abs(y - obstacles[j].y);
                                            if (dx < 3 && dy < 3) {
                                                validPosition = false;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            obstacles.push({x, y});
                        }
                        
                        return obstacles;
                    },
                    
                    checkTrackCollision: function(x, y) {
                        // Convert car position to grid coordinates
                        const gridX = Math.floor(x);
                        const gridY = Math.floor(y);
                        
                        // Check surrounding cells
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const checkX = gridX + dx;
                                const checkY = gridY + dy;
                                
                                // Check if within bounds
                                if (checkX >= 0 && checkX < this.width && checkY >= 0 && checkY < this.height) {
                                    // Check if not on road
                                    if (this.track[checkY][checkX] === 0) {
                                        // Calculate distance from car center to this cell center
                                        const cellCenterX = checkX + 0.5;
                                        const cellCenterY = checkY + 0.5;
                                        const dx = x - cellCenterX;
                                        const dy = y - cellCenterY;
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        
                                        // If close enough, consider it a collision
                                        if (distance < 0.7) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        
                        return false;
                    },
                    
                    checkObstacleCollision: function() {
                        const gridX = Math.floor(this.car.x);
                        const gridY = Math.floor(this.car.y);
                        
                        for (let i = 0; i < this.obstacles.length; i++) {
                            const dx = Math.abs(this.car.x - this.obstacles[i].x);
                            const dy = Math.abs(this.car.y - this.obstacles[i].y);
                            
                            if (dx < 0.8 && dy < 0.8) {
                                return true;
                            }
                        }
                        
                        return false;
                    },
                    
                    checkFinishLine: function() {
                        const gridX = Math.floor(this.car.x);
                        const gridY = Math.floor(this.car.y);
                        
                        // Check if car is on finish line
                        for (let dx = -1; dx <= 1; dx++) {
                            const checkX = gridX + dx;
                            
                            if (checkX >= 0 && checkX < this.width) {
                                if (this.track[2][checkX] === 2 && gridY <= 2.5) {
                                    return true;
                                }
                            }
                        }
                        
                        return false;
                    },
                    
                    restart: function() {
                        this.car.x = Math.floor(this.width / 2);
                        this.car.y = this.height - 2;
                        this.car.speed = 0;
                        this.car.direction = Math.PI * 1.5;
                        
                        this.obstacles = this.generateObstacles();
                        this.gameOver = false;
                        this.finished = false;
                        this.score = 0;
                        this.time = 0;
                    },
                    
                    cleanup: function() {
                        if (this.canvas && this.canvas.parentNode) {
                            this.canvas.parentNode.removeChild(this.canvas);
                        }
                    }
                };
            }

            displayMainMenu() {
                // Clear the game display
                this.gameDisplay.innerHTML = '';
                
                // Create menu content
                const menuContent = document.createElement('div');
                menuContent.style.width = '100%';
                menuContent.style.height = '100%';
                menuContent.style.display = 'flex';
                menuContent.style.flexDirection = 'column';
                menuContent.style.justifyContent = 'center';
                menuContent.style.alignItems = 'center';
                menuContent.style.color = 'black';
                menuContent.style.textAlign = 'center';
                menuContent.style.fontFamily = '"Press Start 2P", cursive';
                
                menuContent.innerHTML = `
                    <h2 style="font-size: 14px; margin-bottom: 20px;">RetroPlay</h2>
                    <p style="font-size: 10px; margin-bottom: 10px;">Press START to open game library</p>
                    <p style="font-size: 10px;">Use D-Pad to navigate</p>
                `;
                
                this.gameDisplay.appendChild(menuContent);
            }

            loadGameList() {
                const gamesGrid = document.getElementById('games-grid');
                gamesGrid.innerHTML = '';
                
                Object.values(this.gameLibrary).forEach(game => {
                    const gameCard = document.createElement('div');
                    gameCard.className = 'game-card';
                    gameCard.dataset.gameId = game.id;
                    
                    gameCard.innerHTML = `
                        <div class="game-icon">${game.icon || '🎮'}</div>
                        <div class="game-name">${game.name}</div>
                        <div class="game-description">${game.description}</div>
                    `;
                    
                    gameCard.addEventListener('click', () => {
                        this.loadGame(game.id);
                        document.getElementById('game-menu').style.display = 'none';
                    });
                    
                    gamesGrid.appendChild(gameCard);
                });
            }

            loadGame(gameId) {
                // Stop any current game
                if (this.currentGame) {
                    clearInterval(this.gameLoop);
                    this.gameRunning = false;
                    
                    if (this.currentGame.cleanup) {
                        this.currentGame.cleanup();
                    }
                }
                
                // Clear the display
                this.gameDisplay.innerHTML = '';
                
                // Initialize the new game
                this.currentGame = this.gameLibrary[gameId];
                if (this.currentGame) {
                    this.currentGame.initialize(this.gameDisplay);
                    
                    let lastTime = performance.now();
                    this.gameRunning = true;
                    
                    // Set up game loop
                    this.gameLoop = setInterval(() => {
                        const currentTime = performance.now();
                        const deltaTime = currentTime - lastTime;
                        
                        if (this.currentGame.update) {
                            this.currentGame.update(deltaTime);
                        }
                        
                        if (this.currentGame.render) {
                            this.currentGame.render();
                        }
                        
                        lastTime = currentTime;
                    }, 1000 / 60); // 60 FPS
                }
            }

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameData = JSON.parse(e.target.result);
                        
                        // Validate that it has the minimum required properties
                        if (!gameData.id || !gameData.name || !gameData.gameData) {
                            alert('Invalid game data: Missing required properties');
                            return;
                        }
                        
                        // Add the game to the library
                        this.gameLibrary[gameData.id] = gameData;
                        
                        // Refresh the game list
                        this.loadGameList();
                        
                        alert(`Game "${gameData.name}" has been added to your library!`);
                    } catch (error) {
                        alert('Error loading game: Invalid JSON format');
                        console.error(error);
                    }
                };
                
                reader.readAsText(file);
                
                // Reset the input value so the same file can be loaded again if needed
                event.target.value = '';
            }

            exportCurrentGame() {
                if (!this.currentGame) return;
                
                // Create a copy of the game object (without circular references)
                const gameExport = {
                    id: this.currentGame.id,
                    name: this.currentGame.name,
                    description: this.currentGame.description,
                    icon: this.currentGame.icon,
                    gameData: this.currentGame.gameData,
                    // We don't export the entire game object with functions, just the data needed to recreate it
                };
                
                // Convert to JSON
                const gameJson = JSON.stringify(gameExport, null, 2);
                
                // Create a downloadable file
                const blob = new Blob([gameJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create a link and trigger the download
                const a = document.createElement('a');
                a.href = url;
                a.download = `${gameExport.id}.json`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // Initialize the RetroConsole on page load
        document.addEventListener('DOMContentLoaded', () => {
            const retroConsole = new RetroConsole();
            
            // When the START button is clicked, load the game list
            document.getElementById('btn-start').addEventListener('click', () => {
                retroConsole.loadGameList();
            });
        });
    </script>
</body>
</html>