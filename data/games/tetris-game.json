{
  "id": "tetris-game",
  "name": "Tetris",
  "description": "Classic block stacking puzzle game",
  "icon": "🧱",
  "gameData": {
    "blockSize": 12,
    "boardWidth": 10,
    "boardHeight": 20,
    "colors": [
      "#FF0000", "#00FF00", "#0000FF", "#FFFF00",
      "#FF00FF", "#00FFFF", "#FF8000"
    ],
    "initialLevel": 1,
    "levelUpLines": 10,
    "initialSpeed": 1000,
    "speedFactor": 0.8,
    "tetrominos": [
      [[1, 1, 1, 1]], // I
      [[1, 1], [1, 1]], // O
      [[0, 1, 0], [1, 1, 1]], // T
      [[0, 1, 1], [1, 1, 0]], // S
      [[1, 1, 0], [0, 1, 1]], // Z
      [[1, 0, 0], [1, 1, 1]], // J
      [[0, 0, 1], [1, 1, 1]] // L
    ]
  },
  "initializeCode": "function(display) {\n  this.display = display;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = 280;\n  this.canvas.height = 248;\n  display.appendChild(this.canvas);\n  this.ctx = this.canvas.getContext('2d');\n  \n  this.blockSize = this.gameData.blockSize;\n  this.boardWidth = this.gameData.boardWidth;\n  this.boardHeight = this.gameData.boardHeight;\n  \n  // Calculate offsets to center the game board\n  this.boardPixelWidth = this.boardWidth * this.blockSize;\n  this.boardPixelHeight = this.boardHeight * this.blockSize;\n  this.offsetX = (this.canvas.width - this.boardPixelWidth) / 2;\n  this.offsetY = (this.canvas.height - this.boardPixelHeight) / 2;\n  \n  this.resetGame();\n  \n  // Initialize key handlers for continuous movement\n  this.keyStates = {\n    left: false,\n    right: false,\n    down: false\n  };\n  \n  this.keyRepeatDelay = 100; // ms\n  this.lastKeyTime = 0;\n  \n  // Start game loop\n  this.lastTime = performance.now();\n  this.dropCounter = 0;\n  this.gameOverAnimationCounter = 0;\n  \n  this.render();\n}",
  "handleInputCode": "function(button, isPressed) {\n  if (this.gameOver) {\n    if (isPressed && button === 'a') {\n      this.resetGame();\n    }\n    return;\n  }\n  \n  if (this.paused) {\n    if (isPressed && button === 'b') {\n      this.paused = false;\n    }\n    return;\n  }\n  \n  if (isPressed && button === 'b') {\n    this.paused = true;\n    return;\n  }\n  \n  if (button === 'left') {\n    this.keyStates.left = isPressed;\n    if (isPressed) {\n      this.moveCurrentPiece(-1, 0);\n      this.lastKeyTime = performance.now();\n    }\n  } else if (button === 'right') {\n    this.keyStates.right = isPressed;\n    if (isPressed) {\n      this.moveCurrentPiece(1, 0);\n      this.lastKeyTime = performance.now();\n    }\n  } else if (button === 'down') {\n    this.keyStates.down = isPressed;\n    if (isPressed) {\n      this.moveCurrentPiece(0, 1);\n      this.lastKeyTime = performance.now();\n      // Award points for manually dropping\n      this.score += 1;\n    }\n  } else if (isPressed && button === 'up') {\n    this.rotatePiece();\n  } else if (isPressed && button === 'a') {\n    this.hardDrop();\n  }\n}",
  "updateCode": "function(deltaTime) {\n  if (this.gameOver || this.paused) {\n    return;\n  }\n  \n  const now = performance.now();\n  \n  // Handle continuous key presses with repeat rate\n  if (now - this.lastKeyTime > this.keyRepeatDelay) {\n    if (this.keyStates.left) {\n      this.moveCurrentPiece(-1, 0);\n      this.lastKeyTime = now;\n    } else if (this.keyStates.right) {\n      this.moveCurrentPiece(1, 0);\n      this.lastKeyTime = now;\n    } else if (this.keyStates.down) {\n      this.moveCurrentPiece(0, 1);\n      this.lastKeyTime = now;\n      // Award points for manually dropping\n      this.score += 1;\n    }\n  }\n  \n  // Update drop counter\n  this.dropCounter += deltaTime;\n  \n  // Get the current level drop speed\n  const dropInterval = this.gameData.initialSpeed * Math.pow(this.gameData.speedFactor, this.level - 1);\n  \n  // Automatically move piece down based on current level speed\n  if (this.dropCounter > dropInterval) {\n    this.dropCounter = 0;\n    this.moveCurrentPiece(0, 1) || this.lockPiece();\n  }\n  \n  // Update game over animation if needed\n  if (this.gameOver) {\n    this.gameOverAnimationCounter += deltaTime;\n  }\n}",
  "renderCode": "function() {\n  // Clear canvas\n  this.ctx.fillStyle = '#000000';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Draw background for board\n  this.ctx.fillStyle = '#111111';\n  this.ctx.fillRect(this.offsetX, this.offsetY, this.boardPixelWidth, this.boardPixelHeight);\n  \n  // Draw border around the board\n  this.ctx.strokeStyle = '#CCCCCC';\n  this.ctx.lineWidth = 1;\n  this.ctx.strokeRect(this.offsetX - 1, this.offsetY - 1, this.boardPixelWidth + 2, this.boardPixelHeight + 2);\n  \n  // Draw grid lines\n  this.ctx.strokeStyle = '#222222';\n  this.ctx.lineWidth = 0.5;\n  \n  // Vertical grid lines\n  for (let x = 1; x < this.boardWidth; x++) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.offsetX + x * this.blockSize, this.offsetY);\n    this.ctx.lineTo(this.offsetX + x * this.blockSize, this.offsetY + this.boardPixelHeight);\n    this.ctx.stroke();\n  }\n  \n  // Horizontal grid lines\n  for (let y = 1; y < this.boardHeight; y++) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.offsetX, this.offsetY + y * this.blockSize);\n    this.ctx.lineTo(this.offsetX + this.boardPixelWidth, this.offsetY + y * this.blockSize);\n    this.ctx.stroke();\n  }\n  \n  // Draw blocks on the board\n  this.drawBoard();\n  \n  // Draw current piece\n  if (!this.gameOver) {\n    this.drawPiece(this.currentPiece, this.currentX, this.currentY, this.currentColorIndex);\n  }\n  \n  // Draw ghost piece (preview of where piece will land)\n  if (!this.gameOver && !this.paused) {\n    this.drawGhostPiece();\n  }\n  \n  // Draw next piece preview\n  this.drawNextPiece();\n  \n  // Draw UI elements\n  this.drawUI();\n  \n  // Draw pause overlay\n  if (this.paused) {\n    this.drawPauseScreen();\n  }\n  \n  // Draw game over overlay\n  if (this.gameOver) {\n    this.drawGameOverScreen();\n  }\n}",
  "cleanupCode": "function() {\n  if (this.canvas && this.canvas.parentNode) {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n}",
  "additionalFunctions": {
    "resetGame": "function() {\n  // Initialize game board (0 = empty cell)\n  this.board = Array(this.boardHeight).fill().map(() => Array(this.boardWidth).fill(0));\n  \n  // Initialize game state\n  this.score = 0;\n  this.lines = 0;\n  this.level = this.gameData.initialLevel;\n  this.gameOver = false;\n  this.paused = false;\n  \n  // Spawn first piece\n  this.spawnPiece();\n  \n  // Create next piece\n  this.nextPieceIndex = Math.floor(Math.random() * this.gameData.tetrominos.length);\n  this.nextColorIndex = Math.floor(Math.random() * this.gameData.colors.length);\n}",
    "spawnPiece": "function() {\n  // If we have a nextPiece, use it, otherwise create a random one\n  if (this.nextPieceIndex !== undefined) {\n    this.currentPiece = this.gameData.tetrominos[this.nextPieceIndex];\n    this.currentColorIndex = this.nextColorIndex;\n  } else {\n    this.currentPiece = this.gameData.tetrominos[Math.floor(Math.random() * this.gameData.tetrominos.length)];\n    this.currentColorIndex = Math.floor(Math.random() * this.gameData.colors.length);\n  }\n  \n  // Create the next piece\n  this.nextPieceIndex = Math.floor(Math.random() * this.gameData.tetrominos.length);\n  this.nextColorIndex = Math.floor(Math.random() * this.gameData.colors.length);\n  \n  // Set the starting position (center top)\n  this.currentX = Math.floor((this.boardWidth - this.currentPiece[0].length) / 2);\n  this.currentY = 0;\n  \n  // Check if the new piece overlaps with existing pieces (game over condition)\n  if (!this.isValidMove(this.currentPiece, this.currentX, this.currentY)) {\n    this.gameOver = true;\n  }\n}",
    "drawBoard": "function() {\n  for (let y = 0; y < this.boardHeight; y++) {\n    for (let x = 0; x < this.boardWidth; x++) {\n      const cell = this.board[y][x];\n      if (cell) {\n        this.drawBlock(x, y, cell - 1);\n      }\n    }\n  }\n}",
    "drawPiece": "function(piece, x, y, colorIndex) {\n  for (let row = 0; row < piece.length; row++) {\n    for (let col = 0; col < piece[row].length; col++) {\n      if (piece[row][col]) {\n        this.drawBlock(x + col, y + row, colorIndex);\n      }\n    }\n  }\n}",
    "drawBlock": "function(x, y, colorIndex) {\n  const screenX = this.offsetX + x * this.blockSize;\n  const screenY = this.offsetY + y * this.blockSize;\n  \n  // Draw filled block\n  this.ctx.fillStyle = this.gameData.colors[colorIndex];\n  this.ctx.fillRect(screenX, screenY, this.blockSize, this.blockSize);\n  \n  // Draw highlight (3D effect)\n  this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n  this.ctx.fillRect(screenX, screenY, this.blockSize, 2);\n  this.ctx.fillRect(screenX, screenY, 2, this.blockSize);\n  \n  // Draw shadow\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n  this.ctx.fillRect(screenX + this.blockSize - 2, screenY, 2, this.blockSize);\n  this.ctx.fillRect(screenX, screenY + this.blockSize - 2, this.blockSize, 2);\n}",
    "drawGhostBlock": "function(x, y) {\n  const screenX = this.offsetX + x * this.blockSize;\n  const screenY = this.offsetY + y * this.blockSize;\n  \n  // Draw ghost block outline\n  this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n  this.ctx.lineWidth = 1;\n  this.ctx.strokeRect(screenX + 1, screenY + 1, this.blockSize - 2, this.blockSize - 2);\n}",
    "drawGhostPiece": "function() {\n  const dropY = this.getDropPosition();\n  \n  // Only draw ghost if it's different from current position\n  if (dropY > this.currentY) {\n    for (let row = 0; row < this.currentPiece.length; row++) {\n      for (let col = 0; col < this.currentPiece[row].length; col++) {\n        if (this.currentPiece[row][col]) {\n          this.drawGhostBlock(this.currentX + col, dropY + row);\n        }\n      }\n    }\n  }\n}",
    "getDropPosition": "function() {\n  let testY = this.currentY;\n  \n  // Move the piece down until it collides\n  while (this.isValidMove(this.currentPiece, this.currentX, testY + 1)) {\n    testY++;\n  }\n  \n  return testY;\n}",
    "drawNextPiece": "function() {\n  const nextPiece = this.gameData.tetrominos[this.nextPieceIndex];\n  const pieceWidth = nextPiece[0].length * this.blockSize;\n  const pieceHeight = nextPiece.length * this.blockSize;\n  \n  // Draw next piece box\n  const boxX = this.offsetX + this.boardPixelWidth + 10;\n  const boxY = this.offsetY;\n  const boxWidth = 60;\n  const boxHeight = 60;\n  \n  // Draw background\n  this.ctx.fillStyle = '#111111';\n  this.ctx.fillRect(boxX, boxY, boxWidth, boxHeight);\n  \n  // Draw border\n  this.ctx.strokeStyle = '#CCCCCC';\n  this.ctx.lineWidth = 1;\n  this.ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);\n  \n  // Draw label\n  this.ctx.fillStyle = '#FFFFFF';\n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.fillText('NEXT', boxX + boxWidth / 2, boxY - 5);\n  \n  // Draw next piece\n  const pieceX = boxX + (boxWidth - pieceWidth) / 2;\n  const pieceY = boxY + (boxHeight - pieceHeight) / 2;\n  \n  for (let row = 0; row < nextPiece.length; row++) {\n    for (let col = 0; col < nextPiece[row].length; col++) {\n      if (nextPiece[row][col]) {\n        const blockX = pieceX + col * this.blockSize;\n        const blockY = pieceY + row * this.blockSize;\n        \n        // Draw block\n        this.ctx.fillStyle = this.gameData.colors[this.nextColorIndex];\n        this.ctx.fillRect(blockX, blockY, this.blockSize, this.blockSize);\n        \n        // Draw highlight\n        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n        this.ctx.fillRect(blockX, blockY, this.blockSize, 2);\n        this.ctx.fillRect(blockX, blockY, 2, this.blockSize);\n        \n        // Draw shadow\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n        this.ctx.fillRect(blockX + this.blockSize - 2, blockY, 2, this.blockSize);\n        this.ctx.fillRect(blockX, blockY + this.blockSize - 2, this.blockSize, 2);\n      }\n    }\n  }\n}",
    "drawUI": "function() {\n  // Draw score, level, and lines\n  this.ctx.fillStyle = '#FFFFFF';\n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.textAlign = 'left';\n  \n  const textX = this.offsetX - 80;\n  let textY = this.offsetY;\n  \n  // Draw score\n  this.ctx.fillText('SCORE', textX, textY);\n  this.ctx.fillText(this.score.toString().padStart(6, '0'), textX, textY + 12);\n  \n  // Draw level\n  textY += 30;\n  this.ctx.fillText('LEVEL', textX, textY);\n  this.ctx.fillText(this.level.toString().padStart(2, '0'), textX, textY + 12);\n  \n  // Draw lines\n  textY += 30;\n  this.ctx.fillText('LINES', textX, textY);\n  this.ctx.fillText(this.lines.toString().padStart(3, '0'), textX, textY + 12);\n  \n  // Draw controls hint\n  textY = this.offsetY + this.boardPixelHeight - 60;\n  this.ctx.fillText('CONTROLS:', textX, textY);\n  this.ctx.fillText('←→↓: MOVE', textX, textY + 15);\n  this.ctx.fillText('↑: ROTATE', textX, textY + 30);\n  this.ctx.fillText('A: DROP', textX, textY + 45);\n  this.ctx.fillText('B: PAUSE', textX, textY + 60);\n}",
    "drawPauseScreen": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Pause text\n  this.ctx.fillStyle = '#FFFFFF';\n  this.ctx.font = '16px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);\n  \n  // Instructions\n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.fillText('PRESS B TO RESUME', this.canvas.width / 2, this.canvas.height / 2 + 30);\n}",
    "drawGameOverScreen": "function() {\n  // Semi-transparent overlay with animation\n  const rows = Math.min(this.boardHeight, Math.floor(this.gameOverAnimationCounter / 50));\n  \n  // Draw overlay one row at a time for animation effect\n  this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';\n  for (let y = 0; y < rows; y++) {\n    this.ctx.fillRect(\n      this.offsetX,\n      this.offsetY + y * this.blockSize,\n      this.boardPixelWidth,\n      this.blockSize\n    );\n  }\n  \n  // Only show game over text after animation finishes\n  if (rows >= this.boardHeight) {\n    // Game over text\n    this.ctx.fillStyle = '#FFFFFF';\n    this.ctx.font = '16px \"Press Start 2P\"';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);\n    \n    // Final score\n    this.ctx.font = '8px \"Press Start 2P\"';\n    this.ctx.fillText(`SCORE: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);\n    \n    // Restart instructions\n    this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + 30);\n  }\n}",
    "moveCurrentPiece": "function(dx, dy) {\n  if (this.isValidMove(this.currentPiece, this.currentX + dx, this.currentY + dy)) {\n    this.currentX += dx;\n    this.currentY += dy;\n    return true;\n  }\n  return false;\n}",
    "rotatePiece": "function() {\n  const rotated = this.rotateMatrix(this.currentPiece);\n  if (this.isValidMove(rotated, this.currentX, this.currentY)) {\n    this.currentPiece = rotated;\n  } else {\n    // Try wall kicks (offset rotated piece to find a valid position)\n    const kicks = [-1, 1, -2, 2];\n    for (let kick of kicks) {\n      if (this.isValidMove(rotated, this.currentX + kick, this.currentY)) {\n        this.currentPiece = rotated;\n        this.currentX += kick;\n        break;\n      }\n    }\n  }\n}",
    "rotateMatrix": "function(matrix) {\n  const N = matrix.length;\n  const result = [];\n  \n  // Create a new rotated matrix\n  for (let i = 0; i < matrix[0].length; i++) {\n    result[i] = [];\n    for (let j = 0; j < N; j++) {\n      result[i][j] = matrix[N - 1 - j][i];\n    }\n  }\n  \n  return result;\n}",
    "isValidMove": "function(piece, x, y) {\n  for (let row = 0; row < piece.length; row++) {\n    for (let col = 0; col < piece[row].length; col++) {\n      if (piece[row][col]) {\n        const newX = x + col;\n        const newY = y + row;\n        \n        // Check bounds\n        if (newX < 0 || newX >= this.boardWidth || newY < 0 || newY >= this.boardHeight) {\n          return false;\n        }\n        \n        // Check collision with existing blocks\n        if (newY >= 0 && this.board[newY][newX]) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}",
    "hardDrop": "function() {\n  const startY = this.currentY;\n  while (this.moveCurrentPiece(0, 1)) {\n    // Keep moving down until collision\n  }\n  \n  // Award points based on the distance dropped\n  this.score += 2 * (this.currentY - startY);\n  \n  // Lock the piece immediately\n  this.lockPiece();\n}",
    "lockPiece": "function() {\n  // Add current piece to the board\n  for (let row = 0; row < this.currentPiece.length; row++) {\n    for (let col = 0; col < this.currentPiece[row].length; col++) {\n      if (this.currentPiece[row][col]) {\n        const boardY = this.currentY + row;\n        const boardX = this.currentX + col;\n        if (boardY >= 0) {\n          this.board[boardY][boardX] = this.currentColorIndex + 1; // +1 because 0 is empty\n        }\n      }\n    }\n  }\n  \n  // Check for completed lines\n  this.checkLines();\n  \n  // Spawn a new piece\n  this.spawnPiece();\n}",
    "checkLines": "function() {\n  let linesCleared = 0;\n  \n  for (let y = 0; y < this.boardHeight; y++) {\n    // Check if this line is full\n    const isLineFull = this.board[y].every(cell => cell !== 0);\n    \n    if (isLineFull) {\n      // Remove this line\n      this.board.splice(y, 1);\n      // Add empty line at the top\n      this.board.unshift(Array(this.boardWidth).fill(0));\n      // Increment counters\n      linesCleared++;\n      this.lines++;\n    }\n  }\n  \n  // Award points based on number of lines cleared at once\n  if (linesCleared > 0) {\n    // Scoring: 100 * level for 1 line, 300 * level for 2, 500 for 3, 800 for 4 (Tetris)\n    const pointValues = [0, 100, 300, 500, 800];\n    this.score += pointValues[linesCleared] * this.level;\n    \n    // Level up every this.gameData.levelUpLines lines\n    if (Math.floor(this.lines / this.gameData.levelUpLines) + 1 > this.level) {\n      this.level = Math.floor(this.lines / this.gameData.levelUpLines) + 1;\n    }\n  }\n}"
  }
}