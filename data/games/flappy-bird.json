{
  "id": "flappy-bird",
  "name": "Flappy Bird",
  "description": "Fly through pipes without hitting them",
  "icon": "üê¶",
  "gameData": {
    "gravity": 0.25,
    "jumpVelocity": -4.6,
    "birdWidth": 34,
    "birdHeight": 24,
    "pipeWidth": 52,
    "pipeGap": 100,
    "pipeMinHeight": 40,
    "pipeDistance": 180,
    "scrollSpeed": 2,
    "groundHeight": 30,
    "colors": {
      "background": "#4EC0CA",
      "ground": "#DED895",
      "pipe": "#74BF2E",
      "bird": [
        "#FFFF00",
        "#FF6600",
        "#FF0000"
      ],
      "text": "#FFFFFF",
      "shadow": "#000000"
    }
  },
  "initializeCode": "function(display) {\n  this.display = display;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = 280;\n  this.canvas.height = 248;\n  display.appendChild(this.canvas);\n  this.ctx = this.canvas.getContext('2d');\n  \n  // Load and cache images\n  this.images = {};\n  this.imagesLoaded = 0;\n  this.totalImages = 0;\n  \n  // Initialize game state\n  this.resetGame();\n  \n  // Start rendering\n  this.render();\n}",
  "handleInputCode": "function(button, isPressed) {\n  if (this.gameOver && isPressed && button === 'a') {\n    this.resetGame();\n    return;\n  }\n  \n  if (isPressed) {\n    if (button === 'a' || button === 'up') {\n      if (!this.gameStarted) {\n        this.gameStarted = true;\n      }\n      this.jump();\n    } else if (button === 'b') {\n      if (this.paused) {\n        this.paused = false;\n      } else if (this.gameStarted && !this.gameOver) {\n        this.paused = true;\n      }\n    }\n  }\n}",
  "updateCode": "function(deltaTime) {\n  if (this.gameOver || this.paused || !this.gameStarted) {\n    return;\n  }\n  \n  // Normalize deltaTime to prevent large jumps if frame rate drops\n  const dt = Math.min(deltaTime, 32) / 16.67; // Cap at ~60fps\n  \n  // Update bird velocity and position\n  this.birdVelocity += this.gameData.gravity * dt;\n  this.birdY += this.birdVelocity * dt;\n  \n  // Update bird rotation based on velocity\n  this.birdRotation = Math.max(-25, Math.min(90, this.birdVelocity * 4));\n  \n  // Update pipe positions\n  for (let i = 0; i < this.pipes.length; i++) {\n    this.pipes[i].x -= this.gameData.scrollSpeed * dt;\n  }\n  \n  // Create new pipes as needed\n  if (this.pipes.length === 0 || this.pipes[this.pipes.length - 1].x < this.canvas.width - this.gameData.pipeDistance) {\n    this.addPipe();\n  }\n  \n  // Remove pipes that are offscreen\n  if (this.pipes.length > 0 && this.pipes[0].x < -this.gameData.pipeWidth) {\n    this.pipes.shift();\n  }\n  \n  // Update ground position\n  this.groundPos = (this.groundPos - this.gameData.scrollSpeed * dt) % 20;\n  \n  // Check for collisions with pipes or ground\n  this.checkCollisions();\n  \n  // Check for passing through pipes to award points\n  this.checkForPoints();\n  \n  // Animate bird flapping\n  this.birdFrameCounter += dt;\n  if (this.birdFrameCounter >= 10) {\n    this.birdFrameCounter = 0;\n    this.birdFrame = (this.birdFrame + 1) % 3;\n  }\n}",
  "renderCode": "function() {\n  // Clear canvas\n  this.ctx.fillStyle = this.gameData.colors.background;\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Draw clouds (background)\n  this.drawClouds();\n  \n  // Draw pipes\n  this.drawPipes();\n  \n  // Draw ground\n  this.drawGround();\n  \n  // Draw bird\n  this.drawBird();\n  \n  // Draw score\n  this.drawScore();\n  \n  // Draw start message\n  if (!this.gameStarted) {\n    this.drawStartMessage();\n  }\n  \n  // Draw pause overlay\n  if (this.paused) {\n    this.drawPauseScreen();\n  }\n  \n  // Draw game over screen\n  if (this.gameOver) {\n    this.drawGameOverScreen();\n  }\n}",
  "cleanupCode": "function() {\n  if (this.canvas && this.canvas.parentNode) {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n}",
  "additionalFunctions": {
    "resetGame": "function() {\n  // Reset game state\n  this.gameStarted = false;\n  this.gameOver = false;\n  this.paused = false;\n  this.score = 0;\n  this.bestScore = this.bestScore || 0;\n  \n  // Bird properties\n  this.birdX = 60;\n  this.birdY = this.canvas.height / 2 - this.gameData.birdHeight / 2;\n  this.birdVelocity = 0;\n  this.birdRotation = 0;\n  this.birdFrame = 0;\n  this.birdFrameCounter = 0;\n  \n  // Pipes\n  this.pipes = [];\n  \n  // Ground animation\n  this.groundPos = 0;\n  \n  // Cloud positions\n  this.clouds = this.initClouds();\n}",
    "initClouds": "function() {\n  const clouds = [];\n  const numClouds = 3 + Math.floor(Math.random() * 3);\n  \n  for (let i = 0; i < numClouds; i++) {\n    clouds.push({\n      x: Math.random() * this.canvas.width,\n      y: 20 + Math.random() * 60,\n      width: 30 + Math.random() * 50,\n      height: 15 + Math.random() * 20,\n      speed: 0.2 + Math.random() * 0.3\n    });\n  }\n  \n  return clouds;\n}",
    "jump": "function() {\n  if (this.gameOver) return;\n  \n  this.birdVelocity = this.gameData.jumpVelocity;\n}",
    "addPipe": "function() {\n  const minHeight = this.gameData.pipeMinHeight;\n  const maxHeight = this.canvas.height - this.gameData.groundHeight - this.gameData.pipeGap - minHeight;\n  const height = minHeight + Math.random() * (maxHeight - minHeight);\n  \n  this.pipes.push({\n    x: this.canvas.width,\n    topHeight: height,\n    bottomY: height + this.gameData.pipeGap,\n    passed: false\n  });\n}",
    "checkCollisions": "function() {\n  // Bird rectangle (simplified hit box, slightly smaller than actual bird for better gameplay)\n  const birdLeft = this.birdX + 5;\n  const birdRight = this.birdX + this.gameData.birdWidth - 5;\n  const birdTop = this.birdY + 5;\n  const birdBottom = this.birdY + this.gameData.birdHeight - 5;\n  \n  // Check ground collision\n  if (birdBottom > this.canvas.height - this.gameData.groundHeight) {\n    this.gameOver = true;\n    this.birdY = this.canvas.height - this.gameData.groundHeight - this.gameData.birdHeight;\n    return;\n  }\n  \n  // Check ceiling collision\n  if (birdTop < 0) {\n    this.birdY = 0;\n    this.birdVelocity = 0;\n  }\n  \n  // Check pipe collisions\n  for (let i = 0; i < this.pipes.length; i++) {\n    const pipe = this.pipes[i];\n    \n    // If bird is within pipe's x-range\n    if (birdRight > pipe.x && birdLeft < pipe.x + this.gameData.pipeWidth) {\n      // Check collision with top pipe\n      if (birdTop < pipe.topHeight) {\n        this.gameOver = true;\n        return;\n      }\n      \n      // Check collision with bottom pipe\n      if (birdBottom > pipe.bottomY) {\n        this.gameOver = true;\n        return;\n      }\n    }\n  }\n}",
    "checkForPoints": "function() {\n  for (let i = 0; i < this.pipes.length; i++) {\n    const pipe = this.pipes[i];\n    \n    if (!pipe.passed && this.birdX > pipe.x + this.gameData.pipeWidth) {\n      pipe.passed = true;\n      this.score++;\n      \n      // Update best score\n      if (this.score > this.bestScore) {\n        this.bestScore = this.score;\n      }\n    }\n  }\n}",
    "drawClouds": "function() {\n  this.ctx.fillStyle = '#FFFFFF';\n  \n  for (let i = 0; i < this.clouds.length; i++) {\n    const cloud = this.clouds[i];\n    \n    // Update cloud position\n    if (!this.gameOver && !this.paused && this.gameStarted) {\n      cloud.x -= cloud.speed;\n      if (cloud.x < -cloud.width) {\n        cloud.x = this.canvas.width + Math.random() * 50;\n        cloud.y = 20 + Math.random() * 60;\n      }\n    }\n    \n    // Draw cloud (simple oval shape)\n    this.ctx.beginPath();\n    this.ctx.ellipse(cloud.x + cloud.width / 2, cloud.y + cloud.height / 2, \n                     cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);\n    this.ctx.fill();\n  }\n}",
    "drawPipes": "function() {\n  this.ctx.fillStyle = this.gameData.colors.pipe;\n  \n  for (let i = 0; i < this.pipes.length; i++) {\n    const pipe = this.pipes[i];\n    \n    // Draw top pipe\n    this.ctx.fillRect(pipe.x, 0, this.gameData.pipeWidth, pipe.topHeight);\n    \n    // Draw pipe cap (top)\n    this.ctx.fillRect(pipe.x - 3, pipe.topHeight - 10, this.gameData.pipeWidth + 6, 10);\n    \n    // Draw bottom pipe\n    this.ctx.fillRect(pipe.x, pipe.bottomY, this.gameData.pipeWidth, \n                      this.canvas.height - pipe.bottomY - this.gameData.groundHeight);\n    \n    // Draw pipe cap (bottom)\n    this.ctx.fillRect(pipe.x - 3, pipe.bottomY, this.gameData.pipeWidth + 6, 10);\n  }\n}",
    "drawGround": "function() {\n  this.ctx.fillStyle = this.gameData.colors.ground;\n  this.ctx.fillRect(0, this.canvas.height - this.gameData.groundHeight, \n                   this.canvas.width, this.gameData.groundHeight);\n  \n  // Draw ground pattern\n  this.ctx.fillStyle = '#C0A080';\n  for (let i = 0; i < this.canvas.width / 20 + 1; i++) {\n    const x = (i * 20 + this.groundPos) % this.canvas.width;\n    this.ctx.fillRect(x, this.canvas.height - this.gameData.groundHeight + 5, 10, 5);\n  }\n}",
    "drawBird": "function() {\n  this.ctx.save();\n  \n  // Position at the center of the bird\n  this.ctx.translate(this.birdX + this.gameData.birdWidth / 2, \n                     this.birdY + this.gameData.birdHeight / 2);\n  \n  // Apply rotation\n  this.ctx.rotate(this.birdRotation * Math.PI / 180);\n  \n  // Draw bird\n  const birdColor = this.gameData.colors.bird[this.birdFrame];\n  this.ctx.fillStyle = birdColor;\n  \n  // Draw bird body\n  this.ctx.beginPath();\n  this.ctx.ellipse(0, 0, this.gameData.birdWidth / 2, this.gameData.birdHeight / 2, 0, 0, Math.PI * 2);\n  this.ctx.fill();\n  \n  // Draw wing\n  this.ctx.fillStyle = this.darkenColor(birdColor, 0.8);\n  this.ctx.beginPath();\n  const wingOffset = Math.sin(this.birdFrameCounter * 0.8) * 2;\n  this.ctx.ellipse(-2, wingOffset, this.gameData.birdWidth / 4, \n                   this.gameData.birdHeight / 3, 0.5, 0, Math.PI * 2);\n  this.ctx.fill();\n  \n  // Draw eye\n  this.ctx.fillStyle = 'white';\n  this.ctx.beginPath();\n  this.ctx.arc(this.gameData.birdWidth / 4, -this.gameData.birdHeight / 6, 3, 0, Math.PI * 2);\n  this.ctx.fill();\n  \n  // Draw pupil\n  this.ctx.fillStyle = 'black';\n  this.ctx.beginPath();\n  this.ctx.arc(this.gameData.birdWidth / 4 + 1, -this.gameData.birdHeight / 6, 1.5, 0, Math.PI * 2);\n  this.ctx.fill();\n  \n  // Draw beak\n  this.ctx.fillStyle = '#FF8800';\n  this.ctx.beginPath();\n  this.ctx.moveTo(this.gameData.birdWidth / 2, 0);\n  this.ctx.lineTo(this.gameData.birdWidth / 2 + 8, -4);\n  this.ctx.lineTo(this.gameData.birdWidth / 2 + 8, 4);\n  this.ctx.closePath();\n  this.ctx.fill();\n  \n  this.ctx.restore();\n}",
    "drawScore": "function() {\n  const scoreText = this.score.toString();\n  \n  // Draw score with shadow\n  this.ctx.font = '24px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText(scoreText, this.canvas.width / 2 + 2, 42);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText(scoreText, this.canvas.width / 2, 40);\n}",
    "drawStartMessage": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Title\n  this.ctx.font = '24px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('FLAPPY BIRD', this.canvas.width / 2 + 2, this.canvas.height / 2 - 40 + 2);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('FLAPPY BIRD', this.canvas.width / 2, this.canvas.height / 2 - 40);\n  \n  // Instructions\n  this.ctx.font = '10px \"Press Start 2P\"';\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('PRESS A OR UP TO START', this.canvas.width / 2 + 1, this.canvas.height / 2 + 1);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('PRESS A OR UP TO START', this.canvas.width / 2, this.canvas.height / 2);\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('PRESS A OR UP TO FLAP', this.canvas.width / 2 + 1, this.canvas.height / 2 + 20 + 1);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('PRESS A OR UP TO FLAP', this.canvas.width / 2, this.canvas.height / 2 + 20);\n}",
    "drawPauseScreen": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Pause text\n  this.ctx.font = '20px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('PAUSED', this.canvas.width / 2 + 2, this.canvas.height / 2 - 10 + 2);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2 - 10);\n  \n  // Instructions\n  this.ctx.font = '10px \"Press Start 2P\"';\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('PRESS B TO RESUME', this.canvas.width / 2 + 1, this.canvas.height / 2 + 20 + 1);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('PRESS B TO RESUME', this.canvas.width / 2, this.canvas.height / 2 + 20);\n}",
    "drawGameOverScreen": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Game over text\n  this.ctx.font = '20px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('GAME OVER', this.canvas.width / 2 + 2, this.canvas.height / 2 - 50 + 2);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 50);\n  \n  // Score display\n  this.ctx.font = '10px \"Press Start 2P\"';\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('SCORE: ' + this.score, this.canvas.width / 2 + 1, this.canvas.height / 2 - 15 + 1);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('SCORE: ' + this.score, this.canvas.width / 2, this.canvas.height / 2 - 15);\n  \n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('BEST: ' + this.bestScore, this.canvas.width / 2 + 1, this.canvas.height / 2 + 5 + 1);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('BEST: ' + this.bestScore, this.canvas.width / 2, this.canvas.height / 2 + 5);\n  \n  // Restart instructions\n  this.ctx.fillStyle = this.gameData.colors.shadow;\n  this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2 + 1, this.canvas.height / 2 + 30 + 1);\n  \n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + 30);\n}",
    "darkenColor": "function(color, factor) {\n  // Simple utility to darken a hex color\n  if (color.startsWith('#')) {\n    const r = parseInt(color.substr(1, 2), 16);\n    const g = parseInt(color.substr(3, 2), 16);\n    const b = parseInt(color.substr(5, 2), 16);\n    \n    const newR = Math.floor(r * factor);\n    const newG = Math.floor(g * factor);\n    const newB = Math.floor(b * factor);\n    \n    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n  }\n  return color;\n}"
  }
}