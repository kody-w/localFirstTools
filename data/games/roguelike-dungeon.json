{
  "id": "roguelike-dungeon",
  "name": "Roguelike Dungeon",
  "description": "Procedurally generated dungeon crawler with infinite levels",
  "icon": "⚔️",
  "gameData": {
    "tileSize": 16,
    "gridWidth": 16,
    "gridHeight": 14,
    "playerColor": "#5E9EFF",
    "wallColor": "#555555",
    "floorColor": "#222222",
    "enemyColors": ["#FF5252", "#FF9800", "#8BC34A", "#9C27B0"],
    "itemColors": ["#FFEB3B", "#4CAF50", "#2196F3"],
    "exitColor": "#FFFFFF",
    "fogColor": "rgba(0, 0, 0, 0.7)",
    "textColor": "#FFFFFF",
    "maxLevel": 99
  },
  "initializeCode": "function(display) {\n  this.display = display;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = 280;\n  this.canvas.height = 248;\n  display.appendChild(this.canvas);\n  this.ctx = this.canvas.getContext('2d');\n  \n  this.tileSize = this.gameData.tileSize;\n  this.gridWidth = this.gameData.gridWidth;\n  this.gridHeight = this.gameData.gridHeight;\n  \n  this.screenOffsetX = (this.canvas.width - (this.gridWidth * this.tileSize)) / 2;\n  this.screenOffsetY = (this.canvas.height - (this.gridHeight * this.tileSize)) / 2;\n  \n  this.gameOver = false;\n  this.level = 1;\n  this.player = {\n    x: 0,\n    y: 0,\n    hp: 10,\n    maxHp: 10,\n    attack: 3,\n    defense: 1,\n    xp: 0,\n    nextLevelXp: 10,\n    hasKey: false,\n    items: []\n  };\n  \n  this.map = [];\n  this.enemies = [];\n  this.items = [];\n  this.exit = { x: 0, y: 0 };\n  this.fogOfWar = [];\n  \n  this.generateLevel();\n  this.initFogOfWar();\n  this.updateVisibility();\n  \n  this.inputState = {\n    up: false,\n    down: false,\n    left: false,\n    right: false\n  };\n  \n  this.actionLog = [];\n  this.logMessage('Welcome to level ' + this.level);\n  \n  this.render();\n}",
  "handleInputCode": "function(button, isPressed) {\n  if (this.gameOver && isPressed && button === 'a') {\n    this.restart();\n    return;\n  }\n  \n  if (!isPressed) return; // Only handle button presses\n  \n  let moved = false;\n  let newX = this.player.x;\n  let newY = this.player.y;\n  \n  switch(button) {\n    case 'up':\n      newY--;\n      moved = true;\n      break;\n    case 'down':\n      newY++;\n      moved = true;\n      break;\n    case 'left':\n      newX--;\n      moved = true;\n      break;\n    case 'right':\n      newX++;\n      moved = true;\n      break;\n    case 'a':\n      // Use item if available\n      if (this.player.items.length > 0) {\n        this.useItem(0);\n      }\n      break;\n    case 'b':\n      // Wait a turn\n      this.logMessage('You wait...');\n      this.updateEnemies();\n      this.updateVisibility();\n      break;\n  }\n  \n  if (moved) {\n    this.handlePlayerMove(newX, newY);\n  }\n}",
  "updateCode": "function(deltaTime) {\n  // Most logic is driven by input in this turn-based game\n  // We don't need frame-by-frame updates\n}",
  "renderCode": "function() {\n  // Clear canvas\n  this.ctx.fillStyle = '#000000';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Draw map\n  for (let y = 0; y < this.gridHeight; y++) {\n    for (let x = 0; x < this.gridWidth; x++) {\n      const screenX = this.screenOffsetX + x * this.tileSize;\n      const screenY = this.screenOffsetY + y * this.tileSize;\n      \n      // Draw tile if visible or previously seen\n      if (this.fogOfWar[y][x] !== 0) {\n        // Draw floor or wall\n        this.ctx.fillStyle = this.map[y][x] === 0 ? this.gameData.floorColor : this.gameData.wallColor;\n        this.ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\n        \n        // Draw exit\n        if (x === this.exit.x && y === this.exit.y && this.map[y][x] === 0) {\n          this.ctx.fillStyle = this.gameData.exitColor;\n          this.ctx.beginPath();\n          this.ctx.moveTo(screenX + this.tileSize/2, screenY + 2);\n          this.ctx.lineTo(screenX + this.tileSize - 2, screenY + this.tileSize - 2);\n          this.ctx.lineTo(screenX + 2, screenY + this.tileSize - 2);\n          this.ctx.closePath();\n          this.ctx.fill();\n        }\n        \n        // Draw fog of war for partially visible tiles\n        if (this.fogOfWar[y][x] === 1) {\n          this.ctx.fillStyle = this.gameData.fogColor;\n          this.ctx.fillRect(screenX, screenY, this.tileSize, this.tileSize);\n        }\n      }\n    }\n  }\n  \n  // Draw items (only if visible)\n  for (let i = 0; i < this.items.length; i++) {\n    const item = this.items[i];\n    if (this.fogOfWar[item.y][item.x] === 2) {\n      const screenX = this.screenOffsetX + item.x * this.tileSize;\n      const screenY = this.screenOffsetY + item.y * this.tileSize;\n      \n      this.ctx.fillStyle = this.gameData.itemColors[item.type];\n      this.ctx.beginPath();\n      this.ctx.arc(screenX + this.tileSize/2, screenY + this.tileSize/2, this.tileSize/4, 0, Math.PI * 2);\n      this.ctx.fill();\n    }\n  }\n  \n  // Draw enemies (only if visible)\n  for (let i = 0; i < this.enemies.length; i++) {\n    const enemy = this.enemies[i];\n    if (this.fogOfWar[enemy.y][enemy.x] === 2) {\n      const screenX = this.screenOffsetX + enemy.x * this.tileSize;\n      const screenY = this.screenOffsetY + enemy.y * this.tileSize;\n      \n      this.ctx.fillStyle = this.gameData.enemyColors[enemy.type];\n      this.ctx.fillRect(screenX + 3, screenY + 3, this.tileSize - 6, this.tileSize - 6);\n    }\n  }\n  \n  // Draw player\n  const playerScreenX = this.screenOffsetX + this.player.x * this.tileSize;\n  const playerScreenY = this.screenOffsetY + this.player.y * this.tileSize;\n  this.ctx.fillStyle = this.gameData.playerColor;\n  this.ctx.fillRect(playerScreenX + 2, playerScreenY + 2, this.tileSize - 4, this.tileSize - 4);\n  \n  // Draw UI\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n  this.ctx.fillRect(0, 0, this.canvas.width, 30);\n  \n  // Draw health bar\n  this.ctx.fillStyle = '#FF5252';\n  const healthWidth = (this.player.hp / this.player.maxHp) * 50;\n  this.ctx.fillRect(10, 10, healthWidth, 10);\n  this.ctx.strokeStyle = 'white';\n  this.ctx.strokeRect(10, 10, 50, 10);\n  \n  // Draw status text\n  this.ctx.fillStyle = this.gameData.textColor;\n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.textAlign = 'left';\n  this.ctx.textBaseline = 'top';\n  this.ctx.fillText(`LVL:${this.level} ATK:${this.player.attack} DEF:${this.player.defense}`, 70, 12);\n  \n  // Draw XP bar\n  this.ctx.fillStyle = '#4CAF50';\n  const xpWidth = (this.player.xp / this.player.nextLevelXp) * 50;\n  this.ctx.fillRect(this.canvas.width - 60, 10, xpWidth, 10);\n  this.ctx.strokeStyle = 'white';\n  this.ctx.strokeRect(this.canvas.width - 60, 10, 50, 10);\n  \n  // Draw action log\n  if (this.actionLog.length > 0) {\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    this.ctx.fillRect(0, this.canvas.height - 20, this.canvas.width, 20);\n    \n    this.ctx.fillStyle = this.gameData.textColor;\n    this.ctx.textAlign = 'left';\n    this.ctx.fillText(this.actionLog[this.actionLog.length - 1], 10, this.canvas.height - 15);\n  }\n  \n  // Draw game over screen\n  if (this.gameOver) {\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    this.ctx.fillStyle = 'white';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.font = '16px \"Press Start 2P\"';\n    this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);\n    \n    this.ctx.font = '10px \"Press Start 2P\"';\n    this.ctx.fillText(`YOU REACHED LEVEL ${this.level}`, this.canvas.width / 2, this.canvas.height / 2 + 10);\n    this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + 40);\n  }\n}",
  "cleanupCode": "function() {\n  if (this.canvas && this.canvas.parentNode) {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n}",
  "additionalFunctions": {
    "generateLevel": "function() {\n  // Initialize empty map with walls\n  this.map = [];\n  for (let y = 0; y < this.gridHeight; y++) {\n    this.map[y] = [];\n    for (let x = 0; x < this.gridWidth; x++) {\n      this.map[y][x] = 1; // 1 = wall\n    }\n  }\n  \n  // Generate random rooms\n  const rooms = [];\n  const numRooms = 3 + Math.floor(Math.random() * 3);\n  \n  for (let i = 0; i < numRooms; i++) {\n    const roomWidth = 3 + Math.floor(Math.random() * 4);\n    const roomHeight = 3 + Math.floor(Math.random() * 4);\n    const roomX = Math.floor(Math.random() * (this.gridWidth - roomWidth - 2)) + 1;\n    const roomY = Math.floor(Math.random() * (this.gridHeight - roomHeight - 2)) + 1;\n    \n    // Check for collisions with existing rooms\n    let collides = false;\n    for (let j = 0; j < rooms.length; j++) {\n      const existingRoom = rooms[j];\n      if (roomX <= existingRoom.x + existingRoom.width + 1 &&\n          roomX + roomWidth + 1 >= existingRoom.x &&\n          roomY <= existingRoom.y + existingRoom.height + 1 &&\n          roomY + roomHeight + 1 >= existingRoom.y) {\n        collides = true;\n        break;\n      }\n    }\n    \n    // Create room if no collision\n    if (!collides) {\n      const room = {\n        x: roomX,\n        y: roomY,\n        width: roomWidth,\n        height: roomHeight\n      };\n      rooms.push(room);\n      \n      // Carve out room\n      for (let y = roomY; y < roomY + roomHeight; y++) {\n        for (let x = roomX; x < roomX + roomWidth; x++) {\n          this.map[y][x] = 0; // 0 = floor\n        }\n      }\n    }\n  }\n  \n  // Connect rooms with corridors\n  for (let i = 0; i < rooms.length - 1; i++) {\n    const roomA = rooms[i];\n    const roomB = rooms[i + 1];\n    \n    // Get center points of each room\n    const roomACenterX = Math.floor(roomA.x + roomA.width / 2);\n    const roomACenterY = Math.floor(roomA.y + roomA.height / 2);\n    const roomBCenterX = Math.floor(roomB.x + roomB.width / 2);\n    const roomBCenterY = Math.floor(roomB.y + roomB.height / 2);\n    \n    // Create horizontal corridor\n    const minX = Math.min(roomACenterX, roomBCenterX);\n    const maxX = Math.max(roomACenterX, roomBCenterX);\n    for (let x = minX; x <= maxX; x++) {\n      this.map[roomACenterY][x] = 0; // floor\n    }\n    \n    // Create vertical corridor\n    const minY = Math.min(roomACenterY, roomBCenterY);\n    const maxY = Math.max(roomACenterY, roomBCenterY);\n    for (let y = minY; y <= maxY; y++) {\n      this.map[y][roomBCenterX] = 0; // floor\n    }\n  }\n  \n  // Place player\n  if (rooms.length > 0) {\n    const startRoom = rooms[0];\n    this.player.x = startRoom.x + Math.floor(startRoom.width / 2);\n    this.player.y = startRoom.y + Math.floor(startRoom.height / 2);\n  } else {\n    // Fallback if no rooms were created\n    this.player.x = 1;\n    this.player.y = 1;\n    this.map[1][1] = 0; // ensure there's floor under the player\n  }\n  \n  // Place exit\n  if (rooms.length > 0) {\n    const exitRoom = rooms[rooms.length - 1];\n    this.exit.x = exitRoom.x + Math.floor(exitRoom.width / 2);\n    this.exit.y = exitRoom.y + Math.floor(exitRoom.height / 2);\n  } else {\n    this.exit.x = this.gridWidth - 2;\n    this.exit.y = this.gridHeight - 2;\n    this.map[this.exit.y][this.exit.x] = 0; // ensure there's floor at the exit\n  }\n  \n  // Place enemies\n  this.enemies = [];\n  const numEnemies = Math.min(5 + Math.floor(this.level / 2), 15);\n  \n  for (let i = 0; i < numEnemies; i++) {\n    let x, y;\n    do {\n      x = Math.floor(Math.random() * this.gridWidth);\n      y = Math.floor(Math.random() * this.gridHeight);\n    } while (this.map[y][x] !== 0 || // must be on floor\n             (x === this.player.x && y === this.player.y) || // not on player\n             (x === this.exit.x && y === this.exit.y)); // not on exit\n    \n    // Create enemy with stats scaled to level\n    const enemyType = Math.floor(Math.random() * this.gameData.enemyColors.length);\n    const enemy = {\n      x: x,\n      y: y,\n      type: enemyType,\n      hp: 2 + Math.floor(this.level / 3),\n      attack: 1 + Math.floor(this.level / 4),\n      defense: Math.floor(this.level / 5),\n      xpValue: 2 + enemyType + Math.floor(this.level / 3)\n    };\n    \n    this.enemies.push(enemy);\n  }\n  \n  // Place items\n  this.items = [];\n  const numItems = 2 + Math.floor(Math.random() * 3);\n  \n  for (let i = 0; i < numItems; i++) {\n    let x, y;\n    do {\n      x = Math.floor(Math.random() * this.gridWidth);\n      y = Math.floor(Math.random() * this.gridHeight);\n    } while (this.map[y][x] !== 0 || // must be on floor\n             (x === this.player.x && y === this.player.y) || // not on player\n             (x === this.exit.x && y === this.exit.y) || // not on exit\n             this.enemies.some(e => e.x === x && e.y === y)); // not on enemy\n    \n    // Create random item\n    const itemType = Math.floor(Math.random() * this.gameData.itemColors.length);\n    const item = {\n      x: x,\n      y: y,\n      type: itemType\n    };\n    \n    this.items.push(item);\n  }\n}",
    "initFogOfWar": "function() {\n  // Initialize fog of war array\n  // 0 = not seen, 1 = previously seen, 2 = currently visible\n  this.fogOfWar = [];\n  for (let y = 0; y < this.gridHeight; y++) {\n    this.fogOfWar[y] = [];\n    for (let x = 0; x < this.gridWidth; x++) {\n      this.fogOfWar[y][x] = 0;\n    }\n  }\n}",
    "updateVisibility": "function() {\n  // Update visibility based on player position\n  const visibilityRadius = 4;\n  \n  // First, mark all currently visible as previously seen\n  for (let y = 0; y < this.gridHeight; y++) {\n    for (let x = 0; x < this.gridWidth; x++) {\n      if (this.fogOfWar[y][x] === 2) {\n        this.fogOfWar[y][x] = 1;\n      }\n    }\n  }\n  \n  // Then, update currently visible tiles\n  for (let dy = -visibilityRadius; dy <= visibilityRadius; dy++) {\n    for (let dx = -visibilityRadius; dx <= visibilityRadius; dx++) {\n      const x = this.player.x + dx;\n      const y = this.player.y + dy;\n      \n      // Check bounds\n      if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {\n        // Check distance\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance <= visibilityRadius) {\n          // Ray casting to check line of sight\n          if (this.hasLineOfSight(this.player.x, this.player.y, x, y)) {\n            this.fogOfWar[y][x] = 2; // Currently visible\n          }\n        }\n      }\n    }\n  }\n}",
    "hasLineOfSight": "function(x0, y0, x1, y1) {\n  // Bresenham's line algorithm to check line of sight\n  let dx = Math.abs(x1 - x0);\n  let dy = Math.abs(y1 - y0);\n  let sx = (x0 < x1) ? 1 : -1;\n  let sy = (y0 < y1) ? 1 : -1;\n  let err = dx - dy;\n  \n  while (x0 !== x1 || y0 !== y1) {\n    // If we hit a wall before reaching the target, no line of sight\n    if (this.map[y0][x0] === 1 && !(x0 === this.player.x && y0 === this.player.y)) {\n      return false;\n    }\n    \n    let e2 = 2 * err;\n    if (e2 > -dy) {\n      err -= dy;\n      x0 += sx;\n    }\n    if (e2 < dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n  \n  return true;\n}",
    "handlePlayerMove": "function(newX, newY) {\n  // Check bounds\n  if (newX < 0 || newX >= this.gridWidth || newY < 0 || newY >= this.gridHeight) {\n    return;\n  }\n  \n  // Check for wall collision\n  if (this.map[newY][newX] === 1) {\n    return;\n  }\n  \n  // Check for enemy at the new position\n  const enemyIndex = this.enemies.findIndex(e => e.x === newX && e.y === newY);\n  if (enemyIndex !== -1) {\n    // Combat with enemy\n    this.combatWithEnemy(enemyIndex);\n    return;\n  }\n  \n  // Check for item at the new position\n  const itemIndex = this.items.findIndex(i => i.x === newX && i.y === newY);\n  if (itemIndex !== -1) {\n    // Pick up item\n    this.pickUpItem(itemIndex);\n  }\n  \n  // Check for exit\n  if (newX === this.exit.x && newY === this.exit.y) {\n    this.nextLevel();\n    return;\n  }\n  \n  // Move player\n  this.player.x = newX;\n  this.player.y = newY;\n  \n  // Update enemies after player moves\n  this.updateEnemies();\n  \n  // Update visibility\n  this.updateVisibility();\n}",
    "combatWithEnemy": "function(enemyIndex) {\n  const enemy = this.enemies[enemyIndex];\n  \n  // Player attacks enemy\n  const playerDamage = Math.max(1, this.player.attack - enemy.defense);\n  enemy.hp -= playerDamage;\n  \n  this.logMessage(`You hit the enemy for ${playerDamage} damage!`);\n  \n  // Check if enemy defeated\n  if (enemy.hp <= 0) {\n    this.logMessage(`You defeated the enemy and gained ${enemy.xpValue} XP!`);\n    this.player.xp += enemy.xpValue;\n    \n    // Check for level up\n    if (this.player.xp >= this.player.nextLevelXp) {\n      this.levelUp();\n    }\n    \n    // Remove defeated enemy\n    this.enemies.splice(enemyIndex, 1);\n  } else {\n    // Enemy attacks player\n    const enemyDamage = Math.max(1, enemy.attack - this.player.defense);\n    this.player.hp -= enemyDamage;\n    \n    this.logMessage(`Enemy hits you for ${enemyDamage} damage!`);\n    \n    // Check if player defeated\n    if (this.player.hp <= 0) {\n      this.gameOver = true;\n      this.logMessage('You have been defeated!');\n    }\n  }\n}",
    "updateEnemies": "function() {\n  // Simple AI: move enemies towards player if in line of sight\n  for (let i = 0; i < this.enemies.length; i++) {\n    const enemy = this.enemies[i];\n    \n    // Check if player is visible from enemy position\n    if (this.hasLineOfSight(enemy.x, enemy.y, this.player.x, this.player.y)) {\n      // Move towards player\n      let dx = 0;\n      let dy = 0;\n      \n      if (enemy.x < this.player.x) dx = 1;\n      else if (enemy.x > this.player.x) dx = -1;\n      \n      if (enemy.y < this.player.y) dy = 1;\n      else if (enemy.y > this.player.y) dy = -1;\n      \n      // Randomly choose horizontal or vertical movement\n      if (Math.random() < 0.5 && dx !== 0) {\n        dy = 0;\n      } else if (dy !== 0) {\n        dx = 0;\n      }\n      \n      const newX = enemy.x + dx;\n      const newY = enemy.y + dy;\n      \n      // Check if new position is valid\n      if (newX >= 0 && newX < this.gridWidth && newY >= 0 && newY < this.gridHeight &&\n          this.map[newY][newX] === 0 && // Must be floor\n          !(newX === this.player.x && newY === this.player.y) && // Not on player\n          !this.enemies.some(e => e !== enemy && e.x === newX && e.y === newY)) { // Not on another enemy\n        enemy.x = newX;\n        enemy.y = newY;\n        \n        // Check if enemy is next to player for attack\n        if ((Math.abs(enemy.x - this.player.x) === 1 && enemy.y === this.player.y) ||\n            (Math.abs(enemy.y - this.player.y) === 1 && enemy.x === this.player.x)) {\n          // Enemy attacks player\n          const enemyDamage = Math.max(1, enemy.attack - this.player.defense);\n          this.player.hp -= enemyDamage;\n          \n          this.logMessage(`Enemy hits you for ${enemyDamage} damage!`);\n          \n          // Check if player defeated\n          if (this.player.hp <= 0) {\n            this.gameOver = true;\n            this.logMessage('You have been defeated!');\n          }\n        }\n      }\n    }\n  }\n}",
    "pickUpItem": "function(itemIndex) {\n  const item = this.items[itemIndex];\n  \n  // Different effects based on item type\n  switch(item.type) {\n    case 0: // Health potion\n      this.player.hp = Math.min(this.player.maxHp, this.player.hp + 5);\n      this.logMessage('You found a health potion! +5 HP');\n      break;\n    case 1: // Attack boost\n      this.player.attack += 1;\n      this.logMessage('You found an attack boost! +1 ATK');\n      break;\n    case 2: // Defense boost\n      this.player.defense += 1;\n      this.logMessage('You found a defense boost! +1 DEF');\n      break;\n  }\n  \n  // Remove item from map\n  this.items.splice(itemIndex, 1);\n}",
    "useItem": "function(itemIndex) {\n  if (itemIndex >= this.player.items.length) {\n    return;\n  }\n  \n  const item = this.player.items[itemIndex];\n  \n  // Use item effect\n  switch(item.type) {\n    case 0: // Health potion\n      this.player.hp = Math.min(this.player.maxHp, this.player.hp + 5);\n      this.logMessage('You used a health potion! +5 HP');\n      break;\n  }\n  \n  // Remove used item\n  this.player.items.splice(itemIndex, 1);\n  \n  // This doesn't count as a turn\n}",
    "levelUp": "function() {\n  this.player.hp = this.player.maxHp = this.player.maxHp + 2;\n  this.player.attack += 1;\n  this.player.defense += 1;\n  \n  // Set new XP threshold\n  this.player.xp -= this.player.nextLevelXp;\n  this.player.nextLevelXp = Math.floor(this.player.nextLevelXp * 1.5);\n  \n  this.logMessage('Level up! You feel stronger.');\n}",
    "nextLevel": "function() {\n  // Go to next dungeon level\n  this.level++;\n  \n  if (this.level > this.gameData.maxLevel) {\n    // Win the game if reached max level\n    this.gameOver = true;\n    this.logMessage('Congratulations! You escaped the dungeon!');\n    return;\n  }\n  \n  // Reset map and entities\n  this.generateLevel();\n  this.initFogOfWar();\n  this.updateVisibility();\n  \n  this.logMessage('Welcome to level ' + this.level);\n}",
    "logMessage": "function(message) {\n  this.actionLog.push(message);\n  \n  // Keep only the last 5 messages\n  if (this.actionLog.length > 5) {\n    this.actionLog.shift();\n  }\n}",
    "restart": "function() {\n  // Reset game state\n  this.gameOver = false;\n  this.level = 1;\n  this.player = {\n    x: 0,\n    y: 0,\n    hp: 10,\n    maxHp: 10,\n    attack: 3,\n    defense: 1,\n    xp: 0,\n    nextLevelXp: 10,\n    hasKey: false,\n    items: []\n  };\n  \n  this.map = [];\n  this.enemies = [];\n  this.items = [];\n  this.exit = { x: 0, y: 0 };\n  this.fogOfWar = [];\n  \n  this.generateLevel();\n  this.initFogOfWar();\n  this.updateVisibility();\n  \n  this.actionLog = [];\n  this.logMessage('Welcome to level ' + this.level);\n  \n  this.render();\n}"
  }
}