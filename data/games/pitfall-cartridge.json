{
  "metadata": {
    "title": "Pitfall Classic",
    "description": "Navigate through the jungle as Pitfall Harry, collecting treasures while avoiding dangerous obstacles.",
    "author": "GameCartridgeGPT",
    "version": "1.0.0",
    "createdAt": "2025-03-24",
    "tags": [
      "platformer",
      "adventure",
      "retro",
      "2D",
      "sidescroller"
    ],
    "thumbnailUrl": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=="
  },
  "config": {
    "width": 800,
    "height": 600,
    "fps": 60,
    "backgroundColor": "#87CEEB"
  },
  "assets": {
    "images": [
      {
        "id": "player",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Pitfall Harry"
      },
      {
        "id": "jungle_background",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Jungle Background"
      },
      {
        "id": "ground",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Ground Tile"
      },
      {
        "id": "log",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Rolling Log"
      },
      {
        "id": "crocodile",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Crocodile"
      },
      {
        "id": "scorpion",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Scorpion"
      },
      {
        "id": "quicksand",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Quicksand"
      },
      {
        "id": "pit",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Pit"
      },
      {
        "id": "treasure_gold",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Gold Bar"
      },
      {
        "id": "treasure_silver",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Silver Bar"
      },
      {
        "id": "treasure_diamond",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Diamond Ring"
      },
      {
        "id": "vine",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Swinging Vine"
      },
      {
        "id": "ladder",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Ladder"
      },
      {
        "id": "underground",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Underground Passage"
      },
      {
        "id": "player_run",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Pitfall Harry Running"
      },
      {
        "id": "player_jump",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Pitfall Harry Jumping"
      },
      {
        "id": "player_swing",
        "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==",
        "name": "Pitfall Harry Swinging"
      }
    ],
    "audio": [
      {
        "id": "jump_sound",
        "url": "data:audio/wav;base64,UklGRiXuAgBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQHuAgCA",
        "name": "Jump Sound",
        "volume": 0.7,
        "loop": false
      },
      {
        "id": "collect_sound",
        "url": "data:audio/wav;base64,UklGRiXuAgBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQHuAgCA",
        "name": "Collect Treasure Sound",
        "volume": 0.7,
        "loop": false
      },
      {
        "id": "death_sound",
        "url": "data:audio/wav;base64,UklGRiXuAgBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQHuAgCA",
        "name": "Death Sound",
        "volume": 0.7,
        "loop": false
      },
      {
        "id": "background_music",
        "url": "data:audio/wav;base64,UklGRiXuAgBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQHuAgCA",
        "name": "Jungle Background Music",
        "volume": 0.5,
        "loop": true
      }
    ],
    "fonts": [
      {
        "id": "game_font",
        "url": "data:font/ttf;base64,AAEAAAAOAIAAAwBgRkZUTWNJJVkAAAZcAAAAHEdERUYAJwANAAAGPAAAAB5PUy8yVe2E3gAAAWgAAABgY21hcGr5Db4AAAHcAAABSmdhc3D//wADAAAGNAAAAAhnbHlmMIJYzAAAAzQAAAD0aGVhZBPS+0MAAADsAAAANmhoZWEHUAOFAAABJAAAACRobXR4B9AAAAAAAcgAAAAQbG9jYQBaAGoAAAMoAAAACm1heHAATQAnAAABSAAAACBuYW1lRX5ackAAA6gAAAFJcG9zdGECpOYAAAT0AAAAQAABAAAAAQAArusHOF8PPPUACwPoAAAAANa6nBwAAAAA1rqcHAAA/2AEAALsAAAACAACAAAAAAAAAAEAAANi/2AAXgQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAEAAEAAAAEACYAAwAAAAAAAgAAAAoACgAAAP8AAAAAAAAAAQPpAZAABQAAAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABAAEEAQQNi/2AAXgNgAKAAAAABAAAAAAAABAAAAAPo/2AAAAQAAAAAAAAAAAAAAJAAAAAAAAIAAAADZAAAAAAAAAAAAAAAKAABAAMAAAADAAEAAQAAAAAAAQAAAAQAAAAAAAQAAwABAAAACgAEAGAAAAAUABAAAwAEAAEAAAAAQf//AAAAAABBAAEAAAABAAEAAEAAAAEAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF7AAAAAQAA/2AD6ANgAAIAABEBIQPo/BgDYPwYAAAAAAAMAAAAAAwAA2AAAwAHAAsAADczNSMRMzUjETM1I0DAwMDAwMBAQAEAQAEAQAAAAAABAAAAAQAAxDRkR18PPPUACwQAAAAAANa6nCAAAAAA1rqcIAAA/2AEAANgAAAACAACAAAAAAAAAAEAAANi/2AAXgQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAEBAAAAAAAApgAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAASAEQAAQAAAAAAAAAAAAAAAAAAAAEAAgAAAAAAAAAAAAAAAAAAAAAA//////////8AAv//AAIAAQAAAAoAHAAeAAFERkxUAAgABAAAAAD//wAAAAAAAAABAAAAAwAAACQAAAAWAAAACgABAAEAAwABAAQABQAGAAcACAABAAAACgAcAB4AAURGTFQACAAEAAAAAf//AAAAAAAAAAABAAAAAQAAAAAAAAAA",
        "name": "Game Font"
      }
    ]
  },
  "entities": [
    {
      "id": "player",
      "name": "Pitfall Harry",
      "type": "player",
      "components": {
        "position": {
          "x": 100,
          "y": 450
        },
        "sprite": {
          "assetId": "player",
          "width": 32,
          "height": 64,
          "animations": {
            "idle": {
              "frames": [
                0
              ],
              "frameRate": 1
            },
            "run": {
              "frames": [
                0,
                1,
                2,
                3
              ],
              "frameRate": 12
            },
            "jump": {
              "frames": [
                4
              ],
              "frameRate": 1
            },
            "swing": {
              "frames": [
                5,
                6
              ],
              "frameRate": 8
            },
            "climb": {
              "frames": [
                7,
                8
              ],
              "frameRate": 8
            }
          }
        },
        "physics": {
          "bodyType": "dynamic",
          "mass": 70,
          "friction": 0.2,
          "restitution": 0.1,
          "collisionGroups": [
            "player"
          ]
        },
        "input": {
          "mappings": {
            "moveLeft": [
              "a",
              "arrowleft"
            ],
            "moveRight": [
              "d",
              "arrowright"
            ],
            "jump": [
              "w",
              "arrowup",
              "space"
            ],
            "climbDown": [
              "s",
              "arrowdown"
            ]
          }
        },
        "script": {
          "update": "function(entity, dt) {\n  const input = entity.getComponent('input');\n  const physics = entity.getComponent('physics');\n  const sprite = entity.getComponent('sprite');\n  const position = entity.getComponent('position');\n  \n  // Default state\n  let state = 'idle';\n  let velocityX = 0;\n  const maxSpeed = 200;\n  const jumpForce = 400;\n  \n  // Check if player is on ground\n  const isGrounded = physics.isColliding('ground');\n  \n  // Movement logic\n  if (input.isPressed('moveLeft')) {\n    velocityX = -maxSpeed;\n    state = 'run';\n    sprite.flipX = true;\n  } else if (input.isPressed('moveRight')) {\n    velocityX = maxSpeed;\n    state = 'run';\n    sprite.flipX = false;\n  }\n  \n  // Apply movement\n  physics.velocity.x = velocityX;\n  \n  // Jumping logic\n  if (input.isJustPressed('jump') && isGrounded) {\n    physics.velocity.y = -jumpForce;\n    game.playSound('jump_sound');\n  }\n  \n  // Update animation state\n  if (!isGrounded) {\n    state = 'jump';\n  } else if (entity.isSwinging) {\n    state = 'swing';\n  } else if (entity.isClimbing) {\n    state = 'climb';\n  }\n  \n  // Set animation\n  sprite.setAnimation(state);\n  \n  // Check for vine interaction\n  const nearbyVine = game.findEntitiesInRadius(position.x, position.y, 30)\n    .find(e => e.type === 'vine');\n  \n  if (nearbyVine && input.isJustPressed('jump')) {\n    entity.isSwinging = true;\n    // Attach to vine\n    position.x = nearbyVine.position.x;\n    physics.velocity.x = 0;\n    physics.gravity = 0;\n  } else if (entity.isSwinging && input.isJustPressed('jump')) {\n    // Release from vine with a jump\n    entity.isSwinging = false;\n    physics.gravity = 1;\n    physics.velocity.y = -jumpForce;\n    game.playSound('jump_sound');\n  }\n  \n  // Check for ladder interaction\n  const nearbyLadder = game.findEntitiesInRadius(position.x, position.y, 30)\n    .find(e => e.type === 'ladder');\n  \n  if (nearbyLadder) {\n    if (input.isPressed('climbDown')) {\n      entity.isClimbing = true;\n      position.y += 100 * dt; // Move down ladder\n    } else if (input.isPressed('jump')) {\n      entity.isClimbing = true;\n      position.y -= 100 * dt; // Move up ladder\n    }\n  } else {\n    entity.isClimbing = false;\n  }\n  \n  // Check for treasure collection\n  const treasures = game.findEntitiesInRadius(position.x, position.y, 30)\n    .filter(e => e.type === 'treasure');\n  \n  treasures.forEach(treasure => {\n    game.playSound('collect_sound');\n    game.addScore(treasure.value);\n    game.removeEntity(treasure.id);\n  });\n  \n  // Check for hazard collision\n  const hazards = game.findEntitiesInRadius(position.x, position.y, 20)\n    .filter(e => ['log', 'crocodile', 'scorpion', 'pit', 'quicksand'].includes(e.type));\n  \n  if (hazards.length > 0) {\n    game.playerDeath();\n  }\n  \n  // Screen boundaries\n  if (position.x < 0) position.x = 0;\n  if (position.x > game.config.width) position.x = game.config.width;\n}",
          "onCollision": "function(entity, other) {\n  // Handle collisions with different objects\n  if (other.type === 'pit' || other.type === 'quicksand') {\n    game.playerDeath();\n  }\n}"
        }
      }
    },
    {
      "id": "ground",
      "name": "Ground",
      "type": "ground",
      "components": {
        "position": {
          "x": 400,
          "y": 550
        },
        "sprite": {
          "assetId": "ground",
          "width": 800,
          "height": 100
        },
        "physics": {
          "bodyType": "static",
          "friction": 0.8,
          "restitution": 0,
          "collisionGroups": [
            "ground"
          ]
        }
      }
    },
    {
      "id": "rolling_log_generator",
      "name": "Rolling Log Generator",
      "type": "generator",
      "components": {
        "position": {
          "x": 850,
          "y": 500
        },
        "script": {
          "update": "function(entity, dt) {\n  // Generate rolling logs at random intervals\n  entity.timer = (entity.timer || 0) + dt;\n  \n  if (entity.timer > entity.spawnInterval) {\n    entity.timer = 0;\n    entity.spawnInterval = 3 + Math.random() * 5; // 3-8 seconds between logs\n    \n    // Create a new rolling log\n    const log = {\n      id: 'log_' + Date.now(),\n      type: 'log',\n      components: {\n        position: {\n          x: 850,\n          y: 520\n        },\n        sprite: {\n          assetId: 'log',\n          width: 64,\n          height: 32,\n          animations: {\n            roll: {\n              frames: [0, 1, 2, 3],\n              frameRate: 12\n            }\n          }\n        },\n        physics: {\n          bodyType: 'dynamic',\n          mass: 100,\n          friction: 0.1,\n          restitution: 0.2,\n          collisionGroups: ['hazard']\n        },\n        script: {\n          update: function(log, dt) {\n            // Roll the log from right to left\n            log.getComponent('position').x -= 150 * dt;\n            log.getComponent('sprite').setAnimation('roll');\n            \n            // Remove when off screen\n            if (log.getComponent('position').x < -50) {\n              game.removeEntity(log.id);\n            }\n          }\n        }\n      }\n    };\n    \n    game.addEntity(log);\n  }\n}"
        }
      }
    },
    {
      "id": "crocodile_pond",
      "name": "Crocodile Pond",
      "type": "water",
      "components": {
        "position": {
          "x": 400,
          "y": 525
        },
        "sprite": {
          "assetId": "quicksand",
          "width": 200,
          "height": 50
        },
        "script": {
          "init": "function(entity) {\n  // Create crocodiles in the pond\n  const spawnCrocodile = function(x) {\n    const crocodile = {\n      id: 'crocodile_' + Date.now() + '_' + x,\n      type: 'crocodile',\n      components: {\n        position: {\n          x: x,\n          y: 520\n        },\n        sprite: {\n          assetId: 'crocodile',\n          width: 80,\n          height: 30,\n          animations: {\n            idle: {\n              frames: [0],\n              frameRate: 1\n            },\n            snap: {\n              frames: [1, 2, 3, 2, 1],\n              frameRate: 12\n            }\n          }\n        },\n        physics: {\n          bodyType: 'kinematic',\n          collisionGroups: ['hazard']\n        },\n        script: {\n          update: function(crocodile, dt) {\n            // Crocodile behavior - snap jaws when player is nearby\n            const player = game.getEntityById('player');\n            const distanceToPlayer = Math.abs(player.getComponent('position').x - crocodile.getComponent('position').x);\n            \n            if (distanceToPlayer < 60) {\n              crocodile.getComponent('sprite').setAnimation('snap');\n            } else {\n              crocodile.getComponent('sprite').setAnimation('idle');\n            }\n          }\n        }\n      }\n    };\n    \n    game.addEntity(crocodile);\n  };\n  \n  // Add three crocodiles to the pond\n  spawnCrocodile(350);\n  spawnCrocodile(400);\n  spawnCrocodile(450);\n}"
        }
      }
    },
    {
      "id": "pit_trap",
      "name": "Pit Trap",
      "type": "pit",
      "components": {
        "position": {
          "x": 600,
          "y": 525
        },
        "sprite": {
          "assetId": "pit",
          "width": 80,
          "height": 50
        },
        "physics": {
          "bodyType": "static",
          "collisionGroups": [
            "hazard"
          ]
        }
      }
    },
    {
      "id": "quicksand_trap",
      "name": "Quicksand Trap",
      "type": "quicksand",
      "components": {
        "position": {
          "x": 200,
          "y": 525
        },
        "sprite": {
          "assetId": "quicksand",
          "width": 80,
          "height": 50
        },
        "physics": {
          "bodyType": "static",
          "collisionGroups": [
            "hazard"
          ]
        }
      }
    },
    {
      "id": "vine_1",
      "name": "Swinging Vine 1",
      "type": "vine",
      "components": {
        "position": {
          "x": 350,
          "y": 300
        },
        "sprite": {
          "assetId": "vine",
          "width": 10,
          "height": 200
        },
        "script": {
          "update": "function(entity, dt) {\n  // Animate the vine slightly\n  entity.swingPhase = (entity.swingPhase || 0) + dt;\n  const swingAmount = Math.sin(entity.swingPhase) * 5;\n  entity.getComponent('position').x = 350 + swingAmount;\n}"
        }
      }
    },
    {
      "id": "ladder_1",
      "name": "Ladder to Underground",
      "type": "ladder",
      "components": {
        "position": {
          "x": 700,
          "y": 500
        },
        "sprite": {
          "assetId": "ladder",
          "width": 40,
          "height": 100
        }
      }
    },
    {
      "id": "gold_treasure_1",
      "name": "Gold Bar 1",
      "type": "treasure",
      "components": {
        "position": {
          "x": 550,
          "y": 500
        },
        "sprite": {
          "assetId": "treasure_gold",
          "width": 30,
          "height": 20
        },
        "physics": {
          "bodyType": "static",
          "collisionGroups": [
            "collectible"
          ]
        },
        "value": 5000
      }
    },
    {
      "id": "silver_treasure_1",
      "name": "Silver Bar 1",
      "type": "treasure",
      "components": {
        "position": {
          "x": 300,
          "y": 500
        },
        "sprite": {
          "assetId": "treasure_silver",
          "width": 30,
          "height": 20
        },
        "physics": {
          "bodyType": "static",
          "collisionGroups": [
            "collectible"
          ]
        },
        "value": 2000
      }
    },
    {
      "id": "diamond_treasure_1",
      "name": "Diamond Ring 1",
      "type": "treasure",
      "components": {
        "position": {
          "x": 700,
          "y": 450
        },
        "sprite": {
          "assetId": "treasure_diamond",
          "width": 20,
          "height": 20
        },
        "physics": {
          "bodyType": "static",
          "collisionGroups": [
            "collectible"
          ]
        },
        "value": 10000
      }
    },
    {
      "id": "scorpion_1",
      "name": "Scorpion 1",
      "type": "scorpion",
      "components": {
        "position": {
          "x": 250,
          "y": 515
        },
        "sprite": {
          "assetId": "scorpion",
          "width": 30,
          "height": 15,
          "animations": {
            "crawl": {
              "frames": [
                0,
                1
              ],
              "frameRate": 6
            }
          }
        },
        "physics": {
          "bodyType": "kinematic",
          "collisionGroups": [
            "hazard"
          ]
        },
        "script": {
          "update": "function(entity, dt) {\n  // Scorpion movement pattern\n  entity.timer = (entity.timer || 0) + dt;\n  entity.direction = entity.direction || -1;\n  \n  // Move back and forth\n  entity.getComponent('position').x += entity.direction * 50 * dt;\n  entity.getComponent('sprite').setAnimation('crawl');\n  entity.getComponent('sprite').flipX = entity.direction > 0;\n  \n  // Reverse direction at limits\n  if (entity.timer > 4) {\n    entity.timer = 0;\n    entity.direction *= -1;\n  }\n}"
        }
      }
    },
    {
      "id": "hud",
      "name": "Heads Up Display",
      "type": "ui",
      "components": {
        "position": {
          "x": 0,
          "y": 0
        },
        "script": {
          "update": "function(entity, dt) {\n  // Render score, time, and lives on screen\n  const ctx = game.renderer.getContext();\n  ctx.font = '24px game_font';\n  ctx.fillStyle = 'white';\n  ctx.fillText('SCORE: ' + game.variables.score, 20, 30);\n  ctx.fillText('TIME: ' + Math.floor(game.variables.timeRemaining), 300, 30);\n  ctx.fillText('LIVES: ' + game.variables.lives, 550, 30);\n}"
        }
      }
    }
  ],
  "systems": [
    {
      "id": "physics_system",
      "type": "physics",
      "priority": 1,
      "config": {
        "gravity": 980,
        "iterations": 3
      },
      "script": "function(entities, dt) {\n  // Simple physics implementation\n  entities.forEach(entity => {\n    const physics = entity.getComponent('physics');\n    const position = entity.getComponent('position');\n    \n    if (!physics || !position) return;\n    \n    // Only apply physics to dynamic bodies\n    if (physics.bodyType === 'dynamic') {\n      // Apply gravity\n      physics.velocity = physics.velocity || { x: 0, y: 0 };\n      physics.velocity.y += game.systems.get('physics_system').config.gravity * dt;\n      \n      // Apply velocity\n      position.x += physics.velocity.x * dt;\n      position.y += physics.velocity.y * dt;\n      \n      // Check ground collision\n      const groundEntities = entities.filter(e => \n        e.getComponent('physics') && \n        e.getComponent('physics').collisionGroups.includes('ground')\n      );\n      \n      // Simple AABB collision detection\n      groundEntities.forEach(ground => {\n        const groundPos = ground.getComponent('position');\n        const groundSprite = ground.getComponent('sprite');\n        \n        const entitySprite = entity.getComponent('sprite');\n        \n        // Calculate bounding boxes\n        const entityBox = {\n          left: position.x - entitySprite.width / 2,\n          right: position.x + entitySprite.width / 2,\n          top: position.y - entitySprite.height / 2,\n          bottom: position.y + entitySprite.height / 2\n        };\n        \n        const groundBox = {\n          left: groundPos.x - groundSprite.width / 2,\n          right: groundPos.x + groundSprite.width / 2,\n          top: groundPos.y - groundSprite.height / 2,\n          bottom: groundPos.y + groundSprite.height / 2\n        };\n        \n        // Check for collision\n        if (entityBox.right > groundBox.left && \n            entityBox.left < groundBox.right && \n            entityBox.bottom > groundBox.top && \n            entityBox.top < groundBox.bottom) {\n          \n          // Resolve ground collision\n          if (physics.velocity.y > 0 && \n              entityBox.bottom - physics.velocity.y * dt <= groundBox.top) {\n            position.y = groundBox.top - entitySprite.height / 2;\n            physics.velocity.y = 0;\n            physics.isColliding = physics.isColliding || {};\n            physics.isColliding.ground = true;\n          }\n        }\n      });\n      \n      // Check hazard collisions\n      const hazardEntities = entities.filter(e => \n        e.getComponent('physics') && \n        e.getComponent('physics').collisionGroups.includes('hazard')\n      );\n      \n      hazardEntities.forEach(hazard => {\n        const hazardPos = hazard.getComponent('position');\n        const hazardSprite = hazard.getComponent('sprite');\n        \n        const entitySprite = entity.getComponent('sprite');\n        \n        // Calculate bounding boxes\n        const entityBox = {\n          left: position.x - entitySprite.width / 3, // Using smaller collision box for better gameplay\n          right: position.x + entitySprite.width / 3,\n          top: position.y - entitySprite.height / 2,\n          bottom: position.y + entitySprite.height / 2\n        };\n        \n        const hazardBox = {\n          left: hazardPos.x - hazardSprite.width / 2,\n          right: hazardPos.x + hazardSprite.width / 2,\n          top: hazardPos.y - hazardSprite.height / 2,\n          bottom: hazardPos.y + hazardSprite.height / 2\n        };\n        \n        // Check for collision\n        if (entityBox.right > hazardBox.left && \n            entityBox.left < hazardBox.right && \n            entityBox.bottom > hazardBox.top && \n            entityBox.top < hazardBox.bottom) {\n          \n          // Trigger collision callbacks\n          if (entity.getComponent('script') && entity.getComponent('script').onCollision) {\n            entity.getComponent('script').onCollision(entity, hazard);\n          }\n        }\n      });\n      \n      // Check collectible collisions\n      const collectibleEntities = entities.filter(e => \n        e.getComponent('physics') && \n        e.getComponent('physics').collisionGroups.includes('collectible')\n      );\n      \n      collectibleEntities.forEach(collectible => {\n        const collectiblePos = collectible.getComponent('position');\n        const collectibleSprite = collectible.getComponent('sprite');\n        \n        const entitySprite = entity.getComponent('sprite');\n        \n        // Calculate bounding boxes\n        const entityBox = {\n          left: position.x - entitySprite.width / 3,\n          right: position.x + entitySprite.width / 3,\n          top: position.y - entitySprite.height / 2,\n          bottom: position.y + entitySprite.height / 2\n        };\n        \n        const collectibleBox = {\n          left: collectiblePos.x - collectibleSprite.width / 2,\n          right: collectiblePos.x + collectibleSprite.width / 2,\n          top: collectiblePos.y - collectibleSprite.height / 2,\n          bottom: collectiblePos.y + collectibleSprite.height / 2\n        };\n        \n        // Check for collision\n        if (entityBox.right > collectibleBox.left && \n            entityBox.left < collectibleBox.right && \n            entityBox.bottom > collectibleBox.top && \n            entityBox.top < collectibleBox.bottom) {\n          \n          // Collect the item\n          game.addScore(collectible.components.value || 100);\n          game.playSound('collect_sound');\n          game.removeEntity(collectible.id);\n        }\n      });\n    }\n  });\n}"
    },
    {
      "id": "rendering_system",
      "type": "render",
      "priority": 2,
      "config": {
        "clearColor": "#87CEEB",
        "sortingLayers": [
          "background",
          "default",
          "foreground",
          "ui"
        ]
      },
      "script": "function(entities, dt) {\n  // Sort entities by type for layered rendering\n  const backgroundEntities = entities.filter(e => e.type === 'background');\n  const characterEntities = entities.filter(e => ['player', 'crocodile', 'scorpion', 'log'].includes(e.type));\n  const gameObjectEntities = entities.filter(e => \n    !['background', 'player', 'crocodile', 'scorpion', 'log', 'ui'].includes(e.type)\n  );\n  const uiEntities = entities.filter(e => e.type === 'ui');\n  \n  // Clear canvas\n  const ctx = game.renderer.getContext();\n  ctx.fillStyle = game.systems.get('rendering_system').config.clearColor;\n  ctx.fillRect(0, 0, game.config.width, game.config.height);\n  \n  // Render background\n  backgroundEntities.forEach(entity => {\n    const position = entity.getComponent('position');\n    const sprite = entity.getComponent('sprite');\n    \n    if (!position || !sprite) return;\n    \n    game.renderer.drawSprite(sprite.assetId, position.x, position.y, sprite.width, sprite.height);\n  });\n  \n  // Render game objects\n  gameObjectEntities.forEach(entity => {\n    const position = entity.getComponent('position');\n    const sprite = entity.getComponent('sprite');\n    \n    if (!position || !sprite) return;\n    \n    game.renderer.drawSprite(sprite.assetId, position.x, position.y, sprite.width, sprite.height);\n  });\n  \n  // Render characters\n  characterEntities.forEach(entity => {\n    const position = entity.getComponent('position');\n    const sprite = entity.getComponent('sprite');\n    \n    if (!position || !sprite) return;\n    \n    // Get current animation frame\n    const currentAnimation = sprite.currentAnimation || 'idle';\n    const animationData = sprite.animations ? sprite.animations[currentAnimation] : null;\n    \n    if (animationData) {\n      entity.animTimer = (entity.animTimer || 0) + dt;\n      const frameIndex = Math.floor(entity.animTimer * animationData.frameRate) % animationData.frames.length;\n      const frame = animationData.frames[frameIndex];\n      \n      game.renderer.drawSpriteFrame(sprite.assetId, frame, position.x, position.y, sprite.width, sprite.height, sprite.flipX);\n    } else {\n      game.renderer.drawSprite(sprite.assetId, position.x, position.y, sprite.width, sprite.height, sprite.flipX);\n    }\n  });\n  \n  // Render UI\n  uiEntities.forEach(entity => {\n    if (entity.getComponent('script') && entity.getComponent('script').update) {\n      entity.getComponent('script').update(entity, dt);\n    }\n  });\n}"
    },
    {
      "id": "camera_system",
      "type": "camera",
      "priority": 0,
      "config": {
        "followTarget": "player",
        "followLerpFactor": 0.1,
        "boundaryLeft": 0,
        "boundaryRight": 3200
      },
      "script": "function(entities, dt) {\n  const player = game.getEntityById(this.config.followTarget);\n  if (!player) return;\n  \n  const playerPosition = player.getComponent('position');\n  \n  // Set camera position to follow player horizontally\n  game.cameraPosition = game.cameraPosition || { x: playerPosition.x, y: 0 };\n  \n  // Smooth camera movement\n  game.cameraPosition.x += (playerPosition.x - game.config.width / 2 - game.cameraPosition.x) * this.config.followLerpFactor;\n  \n  // Enforce boundaries\n  game.cameraPosition.x = Math.max(this.config.boundaryLeft, game.cameraPosition.x);\n  game.cameraPosition.x = Math.min(this.config.boundaryRight - game.config.width, game.cameraPosition.x);\n  \n  // Apply camera offset to all entities\n  entities.forEach(entity => {\n    const position = entity.getComponent('position');\n    if (position && entity.type !== 'ui') {\n      position.renderX = position.x - game.cameraPosition.x;\n    }\n  });\n}"
    },
    {
      "id": "level_generator",
      "type": "generator",
      "priority": 0,
      "config": {
        "levelLength": 3200,
        "screenWidth": 800
      },
      "script": "function(entities, dt) {\n  // Generate level elements as the player progresses\n  const player = game.getEntityById('player');\n  if (!player) return;\n  \n  const playerPosition = player.getComponent('position');\n  \n  // Generate new level elements when player approaches the edge of the current level\n  if (playerPosition.x > game.variables.generatedUpTo - 800) {\n    // Create the next screen of level elements\n    const nextScreenX = game.variables.generatedUpTo;\n    \n    // Randomize obstacles and treasures\n    const obstacles = ['pit', 'crocodiles', 'quicksand', 'logs', 'scorpions'];\n    const selectedObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];\n    \n    // Add ground for the next screen\n    game.addEntity({\n      id: 'ground_' + nextScreenX,\n      type: 'ground',\n      components: {\n        position: {\n          x: nextScreenX + 400,\n          y: 550\n        },\n        sprite: {\n          assetId: 'ground',\n          width: 800,\n          height: 100\n        },\n        physics: {\n          bodyType: 'static',\n          friction: 0.8,\n          restitution: 0,\n          collisionGroups: ['ground']\n        }\n      }\n    });\n    \n    // Add obstacle based on selection\n    switch (selectedObstacle) {\n      case 'pit':\n        game.addEntity({\n          id: 'pit_' + nextScreenX,\n          type: 'pit',\n          components: {\n            position: {\n              x: nextScreenX + 400,\n              y: 525\n            },\n            sprite: {\n              assetId: 'pit',\n              width: 80,\n              height: 50\n            },\n            physics: {\n              bodyType: 'static',\n              collisionGroups: ['hazard']\n            }\n          }\n        });\n        break;\n        \n      case 'crocodiles':\n        game.addEntity({\n          id: 'croc_pond_' + nextScreenX,\n          type: 'water',\n          components: {\n            position: {\n              x: nextScreenX + 400,\n              y: 525\n            },\n            sprite: {\n              assetId: 'quicksand',\n              width: 200,\n              height: 50\n            },\n            script: {\n              init: function(entity) {\n                // Create crocodiles\n                for (let i = 0; i < 3; i++) {\n                  game.addEntity({\n                    id: 'croc_' + nextScreenX + '_' + i,\n                    type: 'crocodile',\n                    components: {\n                      position: {\n                        x: nextScreenX + 350 + i * 50,\n                        y: 520\n                      },\n                      sprite: {\n                        assetId: 'crocodile',\n                        width: 80,\n                        height: 30,\n                        animations: {\n                          idle: {\n                            frames: [0],\n                            frameRate: 1\n                          },\n                          snap: {\n                            frames: [1, 2, 3, 2, 1],\n                            frameRate: 12\n                          }\n                        }\n                      },\n                      physics: {\n                        bodyType: 'kinematic',\n                        collisionGroups: ['hazard']\n                      },\n                      script: {\n                        update: function(crocodile, dt) {\n                          const player = game.getEntityById('player');\n                          const distanceToPlayer = Math.abs(\n                            player.getComponent('position').x - \n                            crocodile.getComponent('position').x\n                          );\n                          \n                          if (distanceToPlayer < 60) {\n                            crocodile.getComponent('sprite').setAnimation('snap');\n                          } else {\n                            crocodile.getComponent('sprite').setAnimation('idle');\n                          }\n                        }\n                      }\n                    }\n                  });\n                }\n              }\n            }\n          }\n        });\n        break;\n        \n      case 'quicksand':\n        game.addEntity({\n          id: 'quicksand_' + nextScreenX,\n          type: 'quicksand',\n          components: {\n            position: {\n              x: nextScreenX + 400,\n              y: 525\n            },\n            sprite: {\n              assetId: 'quicksand',\n              width: 120,\n              height: 50\n            },\n            physics: {\n              bodyType: 'static',\n              collisionGroups: ['hazard']\n            }\n          }\n        });\n        break;\n        \n      case 'logs':\n        // Just add the log generator\n        game.addEntity({\n          id: 'log_gen_' + nextScreenX,\n          type: 'generator',\n          components: {\n            position: {\n              x: nextScreenX + 850,\n              y: 500\n            },\n            script: {\n              update: function(entity, dt) {\n                entity.timer = (entity.timer || 0) + dt;\n                entity.spawnInterval = entity.spawnInterval || 3;\n                \n                if (entity.timer > entity.spawnInterval) {\n                  entity.timer = 0;\n                  \n                  // Create a rolling log\n                  game.addEntity({\n                    id: 'log_' + Date.now(),\n                    type: 'log',\n                    components: {\n                      position: {\n                        x: entity.getComponent('position').x,\n                        y: 520\n                      },\n                      sprite: {\n                        assetId: 'log',\n                        width: 64,\n                        height: 32,\n                        animations: {\n                          roll: {\n                            frames: [0, 1, 2, 3],\n                            frameRate: 12\n                          }\n                        }\n                      },\n                      physics: {\n                        bodyType: 'dynamic',\n                        mass: 100,\n                        friction: 0.1,\n                        restitution: 0.2,\n                        collisionGroups: ['hazard']\n                      },\n                      script: {\n                        update: function(log, dt) {\n                          log.getComponent('position').x -= 150 * dt;\n                          log.getComponent('sprite').setAnimation('roll');\n                          \n                          if (log.getComponent('position').x < nextScreenX - 400) {\n                            game.removeEntity(log.id);\n                          }\n                        }\n                      }\n                    }\n                  });\n                }\n              }\n            }\n          }\n        });\n        break;\n        \n      case 'scorpions':\n        for (let i = 0; i < 2; i++) {\n          game.addEntity({\n            id: 'scorpion_' + nextScreenX + '_' + i,\n            type: 'scorpion',\n            components: {\n              position: {\n                x: nextScreenX + 300 + i * 200,\n                y: 515\n              },\n              sprite: {\n                assetId: 'scorpion',\n                width: 30,\n                height: 15,\n                animations: {\n                  crawl: {\n                    frames: [0, 1],\n                    frameRate: 6\n                  }\n                }\n              },\n              physics: {\n                bodyType: 'kinematic',\n                collisionGroups: ['hazard']\n              },\n              script: {\n                update: function(entity, dt) {\n                  entity.timer = (entity.timer || 0) + dt;\n                  entity.direction = entity.direction || -1;\n                  \n                  entity.getComponent('position').x += entity.direction * 50 * dt;\n                  entity.getComponent('sprite').setAnimation('crawl');\n                  entity.getComponent('sprite').flipX = entity.direction > 0;\n                  \n                  if (entity.timer > 4) {\n                    entity.timer = 0;\n                    entity.direction *= -1;\n                  }\n                }\n              }\n            }\n          });\n        }\n        break;\n    }\n    \n    // Add vines occasionally\n    if (Math.random() < 0.3) {\n      game.addEntity({\n        id: 'vine_' + nextScreenX,\n        type: 'vine',\n        components: {\n          position: {\n            x: nextScreenX + 400,\n            y: 300\n          },\n          sprite: {\n            assetId: 'vine',\n            width: 10,\n            height: 200\n          },\n          script: {\n            update: function(entity, dt) {\n              entity.swingPhase = (entity.swingPhase || 0) + dt;\n              const swingAmount = Math.sin(entity.swingPhase) * 5;\n              entity.getComponent('position').x = nextScreenX + 400 + swingAmount;\n            }\n          }\n        }\n      });\n    }\n    \n    // Add treasure with some probability\n    if (Math.random() < 0.5) {\n      const treasureTypes = [\n        { assetId: 'treasure_gold', value: 5000 },\n        { assetId: 'treasure_silver', value: 2000 },\n        { assetId: 'treasure_diamond', value: 10000 }\n      ];\n      \n      const treasure = treasureTypes[Math.floor(Math.random() * treasureTypes.length)];\n      \n      game.addEntity({\n        id: 'treasure_' + nextScreenX,\n        type: 'treasure',\n        components: {\n          position: {\n            x: nextScreenX + 200 + Math.random() * 400,\n            y: 500\n          },\n          sprite: {\n            assetId: treasure.assetId,\n            width: 30,\n            height: 20\n          },\n          physics: {\n            bodyType: 'static',\n            collisionGroups: ['collectible']\n          },\n          value: treasure.value\n        }\n      });\n    }\n    \n    // Add underground passage occasionally\n    if (Math.random() < 0.2) {\n      game.addEntity({\n        id: 'ladder_' + nextScreenX,\n        type: 'ladder',\n        components: {\n          position: {\n            x: nextScreenX + 600,\n            y: 500\n          },\n          sprite: {\n            assetId: 'ladder',\n            width: 40,\n            height: 100\n          }\n        }\n      });\n    }\n    \n    // Update the generated position marker\n    game.variables.generatedUpTo += this.config.screenWidth;\n  }\n}"
    }
  ],
  "scenes": [
    {
      "id": "main_scene",
      "name": "Main Game Scene",
      "entities": [
        "player",
        "ground",
        "rolling_log_generator",
        "crocodile_pond",
        "pit_trap",
        "quicksand_trap",
        "vine_1",
        "ladder_1",
        "gold_treasure_1",
        "silver_treasure_1",
        "diamond_treasure_1",
        "scorpion_1",
        "hud"
      ],
      "systems": [
        "physics_system",
        "rendering_system",
        "camera_system",
        "level_generator"
      ],
      "background": {
        "color": "#87CEEB",
        "assetId": "jungle_background"
      }
    },
    {
      "id": "title_scene",
      "name": "Title Screen",
      "entities": [
        "title_display"
      ],
      "systems": [
        "rendering_system"
      ],
      "background": {
        "color": "#000000"
      }
    },
    {
      "id": "game_over_scene",
      "name": "Game Over Screen",
      "entities": [
        "game_over_display"
      ],
      "systems": [
        "rendering_system"
      ],
      "background": {
        "color": "#000000"
      }
    }
  ],
  "gameLogic": {
    "init": "function() {\n  // Initialize game state\n  game.variables = {\n    score: 0,\n    lives: 3,\n    timeRemaining: 1200, // 20 minutes in seconds\n    currentScene: 'title_scene',\n    generatedUpTo: 800 // First screen is pre-generated\n  };\n  \n  // Add title screen entities\n  game.addEntity({\n    id: 'title_display',\n    type: 'ui',\n    components: {\n      position: {\n        x: 400,\n        y: 300\n      },\n      script: {\n        update: function(entity, dt) {\n          const ctx = game.renderer.getContext();\n          \n          // Draw title\n          ctx.fillStyle = '#FFFFFF';\n          ctx.font = '48px game_font';\n          ctx.textAlign = 'center';\n          ctx.fillText('PITFALL CLASSIC', 400, 200);\n          \n          ctx.font = '24px game_font';\n          ctx.fillText('NAVIGATE THE JUNGLE AND COLLECT TREASURES', 400, 250);\n          ctx.fillText('AVOID HAZARDS AND SURVIVE FOR 20 MINUTES', 400, 280);\n          ctx.fillText('CONTROLS: ARROW KEYS TO MOVE, SPACE TO JUMP', 400, 310);\n          \n          ctx.font = '32px game_font';\n          ctx.fillText('PRESS ANY KEY TO START', 400, 400);\n          \n          // Check for key press to start game\n          if (game.input.anyKeyPressed()) {\n            game.startGame();\n          }\n        }\n      }\n    }\n  });\n  \n  // Add game over screen entities\n  game.addEntity({\n    id: 'game_over_display',\n    type: 'ui',\n    components: {\n      position: {\n        x: 400,\n        y: 300\n      },\n      script: {\n        update: function(entity, dt) {\n          const ctx = game.renderer.getContext();\n          \n          ctx.fillStyle = '#FFFFFF';\n          ctx.font = '48px game_font';\n          ctx.textAlign = 'center';\n          \n          if (game.variables.timeRemaining <= 0) {\n            // Win condition\n            ctx.fillText('CONGRATULATIONS!', 400, 200);\n            ctx.font = '32px game_font';\n            ctx.fillText('YOU SURVIVED THE JUNGLE', 400, 250);\n          } else {\n            // Loss condition\n            ctx.fillText('GAME OVER', 400, 200);\n          }\n          \n          ctx.font = '24px game_font';\n          ctx.fillText('FINAL SCORE: ' + game.variables.score, 400, 300);\n          \n          ctx.font = '32px game_font';\n          ctx.fillText('PRESS ANY KEY TO PLAY AGAIN', 400, 400);\n          \n          // Check for key press to restart\n          if (game.input.anyKeyPressed()) {\n            game.resetGame();\n          }\n        }\n      }\n    }\n  });\n  \n  // Start background music\n  game.playSound('background_music');\n}",
    "update": "function(dt) {\n  // Main game loop logic\n  if (game.variables.currentScene === 'main_scene') {\n    // Update timer\n    game.variables.timeRemaining -= dt;\n    \n    // Check win condition\n    if (game.variables.timeRemaining <= 0) {\n      game.gameOver();\n    }\n  }\n}",
    "rules": [
      {
        "condition": "function() { return game.variables.lives <= 0; }",
        "action": "function() { game.gameOver(); }"
      }
    ],
    "startGame": "function() {\n  // Switch to main game scene\n  game.variables.currentScene = 'main_scene';\n  game.setActiveScene('main_scene');\n}",
    "resetGame": "function() {\n  // Reset game state\n  game.variables = {\n    score: 0,\n    lives: 3,\n    timeRemaining: 1200,\n    currentScene: 'title_scene',\n    generatedUpTo: 800\n  };\n  \n  // Clean up dynamic entities\n  const dynamicEntityTypes = ['log', 'crocodile', 'scorpion'];\n  game.entities.filter(e => dynamicEntityTypes.includes(e.type)).forEach(e => {\n    game.removeEntity(e.id);\n  });\n  \n  // Reset player position\n  const player = game.getEntityById('player');\n  if (player) {\n    const position = player.getComponent('position');\n    position.x = 100;\n    position.y = 450;\n    \n    const physics = player.getComponent('physics');\n    physics.velocity = { x: 0, y: 0 };\n  }\n  \n  // Switch back to title scene\n  game.setActiveScene('title_scene');\n}",
    "gameOver": "function() {\n  // Game over state\n  game.variables.currentScene = 'game_over_scene';\n  game.setActiveScene('game_over_scene');\n}",
    "playerDeath": "function() {\n  // Handle player death\n  game.variables.lives--;\n  game.playSound('death_sound');\n  \n  if (game.variables.lives > 0) {\n    // Reset player position\n    const player = game.getEntityById('player');\n    if (player) {\n      const position = player.getComponent('position');\n      position.x = Math.max(0, position.x - 200); // Move back a bit\n      position.y = 450;\n      \n      const physics = player.getComponent('physics');\n      physics.velocity = { x: 0, y: 0 };\n    }\n  }\n}",
    "addScore": "function(points) {\n  game.variables.score += points;\n}",
    "playSound": "function(soundId) {\n  // Play a sound\n  const audio = game.assets.audio.find(a => a.id === soundId);\n  if (audio) {\n    const sound = new Audio(audio.url);\n    sound.volume = audio.volume || 1.0;\n    sound.loop = audio.loop || false;\n    sound.play();\n  }\n}",
    "setActiveScene": "function(sceneId) {\n  // Change active scene\n  const scene = game.scenes.find(s => s.id === sceneId);\n  if (scene) {\n    // Hide entities from other scenes\n    game.entities.forEach(entity => {\n      entity.active = scene.entities.includes(entity.id);\n    });\n    \n    // Set active systems\n    game.systems.forEach(system => {\n      system.active = scene.systems.includes(system.id);\n    });\n    \n    // Set background\n    if (scene.background) {\n      game.renderer.setBackgroundColor(scene.background.color);\n      if (scene.background.assetId) {\n        game.renderer.setBackgroundImage(scene.background.assetId);\n      }\n    }\n  }\n}",
    "findEntitiesInRadius": "function(x, y, radius) {\n  // Find entities within a radius of a point\n  return game.entities.filter(entity => {\n    const position = entity.getComponent('position');\n    if (position) {\n      const dx = position.x - x;\n      const dy = position.y - y;\n      const distanceSquared = dx * dx + dy * dy;\n      return distanceSquared <= radius * radius;\n    }\n    return false;\n  });\n}",
    "getEntityById": "function(id) {\n  // Get entity by ID\n  return game.entities.find(entity => entity.id === id);\n}",
    "variables": {
      "score": 0,
      "lives": 3,
      "timeRemaining": 1200,
      "currentScene": "title_scene",
      "generatedUpTo": 800
    }
  }
}