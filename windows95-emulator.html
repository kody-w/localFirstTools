<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windows 95 Desktop Simulator - Interactive Edition</title>
    <meta name="description" content="Fully interactive Windows 95 desktop simulator with working programs, draggable windows, and authentic UI">
    <style>
        /* Windows 95 Color Palette - Enhanced vibrancy while staying authentic */
        :root {
            --desktop-teal: #008585;
            --button-face: #c3c3c3;
            --button-shadow: #808080;
            --button-dark-shadow: #000000;
            --button-highlight: #ffffff;
            --button-light: #e3e3e3;
            --active-title-bar: #000088;
            --inactive-title-bar: #838383;
            --window-background: #ffffff;
            --text-color: #000000;
            --menu-highlight: #000088;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'MS Sans Serif', 'Microsoft Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: var(--desktop-teal);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #fff;
            overflow: hidden;
            user-select: none;
            /* Enhanced text rendering for modern displays */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .header {
            background: linear-gradient(180deg, #0055d4 0%, #0040a8 100%);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow:
                0 2px 4px rgba(0,0,0,0.3),
                0 4px 8px rgba(0,0,0,0.2);
            border-bottom: 2px solid var(--button-face);
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            text-shadow:
                1px 1px 2px rgba(0,0,0,0.7),
                0 0 10px rgba(255,255,255,0.2);
        }

        .logo {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            display: inline-block;
            position: relative;
            transform: perspective(10px) rotateY(-5deg);
            box-shadow:
                2px 2px 4px rgba(0,0,0,0.4),
                4px 4px 8px rgba(0,0,0,0.2),
                inset -1px -1px 2px rgba(0,0,0,0.3),
                inset 1px 1px 2px rgba(255,255,255,0.3);
            border: 1px solid rgba(0,0,0,0.2);
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Authentic Windows 95 3D button effect - Enhanced */
        .btn {
            padding: 3px 8px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset 2px 2px 0 var(--button-light),
                inset -1px -1px 0 var(--button-dark-shadow),
                inset -2px -2px 0 var(--button-shadow),
                /* Subtle outer shadow for depth */
                1px 1px 0 rgba(0,0,0,0.1);
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            outline: none;
            position: relative;
            min-height: 22px;
            transition: transform 0.05s ease;
        }

        /* Pressed button effect */
        .btn:active {
            box-shadow:
                inset -1px -1px 0 var(--button-highlight),
                inset -2px -2px 0 var(--button-light),
                inset 1px 1px 0 var(--button-dark-shadow),
                inset 2px 2px 0 var(--button-shadow);
            padding: 4px 7px 2px 9px;
        }

        /* Focus state for accessibility */
        .btn:focus-visible {
            outline: 1px dotted var(--text-color);
            outline-offset: -4px;
        }

        .btn:hover:not(:disabled) {
            background: var(--button-light);
        }

        .btn:disabled {
            color: var(--button-shadow);
            text-shadow: 1px 1px 0 var(--button-highlight);
            cursor: default;
            opacity: 0.8;
        }

        .btn.primary {
            background: var(--active-title-bar);
            color: white;
            font-weight: bold;
            border: 1px solid #000;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            overflow: auto;
        }

        .emulator-frame {
            background: var(--button-face);
            border: none;
            box-shadow: none;
            padding: 0;
            margin: 0;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        /* Fullscreen mode styling */
        .emulator-frame.fullscreen-mode {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }

        .emulator-frame.fullscreen-mode #screen_container {
            background: #008080; /* Match desktop teal background */
            align-items: stretch;
            justify-content: stretch;
        }

        .emulator-frame.fullscreen-mode #screen {
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
            object-fit: fill;
        }

        .emulator-titlebar {
            display: none !important; /* Hide the titlebar for fullscreen experience */
            background: var(--active-title-bar);
            color: white;
            padding: 2px 4px;
            justify-content: space-between;
            align-items: center;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            font-weight: bold;
            user-select: none;
            height: 18px;
            cursor: default;
        }

        .emulator-titlebar.inactive {
            background: var(--inactive-title-bar);
        }

        .titlebar-buttons {
            display: flex;
            gap: 2px;
        }

        .titlebar-btn {
            width: 16px;
            height: 14px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset -1px -1px 0 var(--button-dark-shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 10px;
            font-weight: bold;
            color: var(--text-color);
            transition: background-color 0.08s ease;
        }

        .titlebar-btn:active {
            box-shadow:
                inset -1px -1px 0 var(--button-highlight),
                inset 1px 1px 0 var(--button-dark-shadow);
            padding-top: 1px;
            padding-left: 1px;
            background: var(--button-shadow);
        }

        .titlebar-btn:hover {
            background: var(--button-light);
        }

        .titlebar-btn:focus-visible {
            outline: 1px dotted var(--text-color);
            outline-offset: -3px;
        }

        #screen_container {
            background: #000;
            position: relative;
            display: flex;
            align-items: stretch;
            justify-content: stretch;
            overflow: hidden;
            flex: 1;
            min-height: 0;
            width: 100%;
            height: 100%;
        }

        #screen {
            /* Fill entire viewport - no aspect ratio preservation */
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            object-fit: fill !important;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            /* Width and height controlled by #screen selector for proper scaling */
            /* High-DPI optimization */
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        .status-bar {
            background: var(--button-face);
            border-top: 1px solid var(--button-highlight);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-section {
            border-left: 1px solid var(--button-shadow);
            border-right: 1px solid var(--button-highlight);
            padding: 0 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-section:first-child {
            border-left: none;
            padding-left: 0;
        }

        .led {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: #404040;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.6), 0 1px 1px rgba(255,255,255,0.3);
            transition: all 0.15s ease;
            border: 1px solid rgba(0,0,0,0.3);
        }

        .led.active {
            background: #00ff00;
            box-shadow:
                0 0 6px #00ff00,
                0 0 10px rgba(0,255,0,0.5),
                inset 0 1px 2px rgba(255,255,255,0.6),
                0 1px 1px rgba(255,255,255,0.3);
            border-color: #00cc00;
        }

        .led.hdd {
            background: #800000;
        }

        .led.hdd.active {
            background: #ff6600;
            box-shadow:
                0 0 6px #ff6600,
                0 0 10px rgba(255,102,0,0.5),
                inset 0 1px 2px rgba(255,255,255,0.6),
                0 1px 1px rgba(255,255,255,0.3);
            border-color: #cc5500;
        }

        .setup-screen {
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            box-shadow:
                inset 1px 1px 0 var(--button-light),
                inset -1px -1px 0 var(--button-shadow),
                3px 3px 2px rgba(0,0,0,0.15),
                6px 6px 6px rgba(0,0,0,0.1),
                0 0 30px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: dialogFadeIn 0.15s ease-out;
        }

        @keyframes dialogFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .setup-screen h2 {
            background: var(--active-title-bar);
            color: white;
            padding: 4px 8px;
            margin: -20px -20px 15px -20px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 14px;
        }

        .setup-content {
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .setup-content p {
            margin: 8px 0;
            line-height: 1.4;
        }

        .setup-option {
            margin: 15px 0;
            padding: 10px;
            background: var(--window-background);
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
        }

        .setup-option h3 {
            margin-bottom: 8px;
            font-size: 12px;
            color: var(--active-title-bar);
        }

        .setup-option p {
            margin: 5px 0;
            line-height: 1.4;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-top: 10px;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }

        .file-input-label {
            display: inline-block;
            padding: 3px 8px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset 2px 2px 0 var(--button-light),
                inset -1px -1px 0 var(--button-dark-shadow),
                inset -2px -2px 0 var(--button-shadow);
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
        }

        input[type="text"],
        select {
            padding: 3px 4px;
            border: 2px solid;
            border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: var(--window-background);
            transition: border-color 0.1s ease;
        }

        input[type="text"]:focus,
        select:focus {
            outline: 1px dotted var(--text-color);
            outline-offset: -3px;
            background: #fffff0;
        }

        input[type="text"]:hover:not(:focus),
        select:hover:not(:focus) {
            border-color: var(--button-shadow) var(--button-light) var(--button-light) var(--button-shadow);
        }

        label {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 2px 0;
        }

        input[type="checkbox"] {
            width: 13px;
            height: 13px;
            cursor: pointer;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .loading-screen.active {
            display: flex;
        }

        .boot-logo {
            width: 200px;
            height: 150px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            margin-bottom: 30px;
            position: relative;
            animation: bootWave 2s infinite;
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        @keyframes bootWave {
            0%, 100% { transform: perspective(100px) rotateY(0deg); }
            50% { transform: perspective(100px) rotateY(10deg); }
        }

        .loading-text {
            color: #c0c0c0;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: #000;
            border: 2px solid #c0c0c0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.8);
        }

        .progress-fill {
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                #000080 0px,
                #000080 10px,
                #1084d0 10px,
                #1084d0 20px
            );
            width: 0%;
            transition: width 0.3s ease;
            animation: slide 1s linear infinite;
        }

        @keyframes slide {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffffee 0%, #ffffcc 100%);
            border: 2px solid var(--text-color);
            padding: 12px;
            max-width: 320px;
            box-shadow:
                3px 3px 2px rgba(0,0,0,0.2),
                5px 5px 5px rgba(0,0,0,0.15);
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            animation: infoPanelSlide 0.25s ease-out;
        }

        @keyframes infoPanelSlide {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .info-panel h4 {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .info-panel ul {
            margin-left: 20px;
            margin-top: 5px;
        }

        .info-panel li {
            margin: 3px 0;
            line-height: 1.3;
        }

        .warning-icon {
            color: #ff0000;
            font-weight: bold;
            font-size: 14px;
        }

        .hidden {
            display: none !important;
        }

        /* Desktop icons styling - Enhanced readability */
        .desktop-icon {
            position: absolute;
            width: 64px;
            text-align: center;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s ease;
        }

        .desktop-icon:hover {
            transform: translateY(-1px);
        }

        .desktop-icon:hover .icon-image {
            filter: brightness(1.1);
        }

        .desktop-icon.selected .icon-text {
            background: var(--menu-highlight);
            color: white;
        }

        .icon-image {
            width: 32px;
            height: 32px;
            margin: 0 auto 4px;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
            transition: filter 0.1s ease;
        }

        .icon-text {
            font-size: 11px;
            padding: 1px 2px;
            word-wrap: break-word;
            color: white;
            /* Enhanced text shadow for better readability on any background */
            text-shadow:
                1px 1px 2px rgba(0,0,0,0.9),
                -1px -1px 2px rgba(0,0,0,0.9),
                1px -1px 2px rgba(0,0,0,0.9),
                -1px 1px 2px rgba(0,0,0,0.9),
                0 0 3px rgba(0,0,0,0.8);
        }

        /* Window styling improvements - Enhanced depth and shadows */
        .window {
            position: absolute;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            box-shadow:
                /* Authentic Windows 95 shadow */
                1px 1px 0 var(--button-shadow),
                /* Enhanced depth shadows */
                2px 2px 1px rgba(0,0,0,0.15),
                4px 4px 3px rgba(0,0,0,0.1),
                6px 6px 5px rgba(0,0,0,0.05);
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            z-index: 10;
            /* Subtle fade-in animation */
            animation: windowFadeIn 0.08s ease-out;
        }

        @keyframes windowFadeIn {
            from {
                opacity: 0;
                transform: scale(0.98);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .window.minimized {
            display: none;
        }

        .window.active {
            z-index: 1000;
        }

        /* AI-controlled window indicator */
        .window.ai-controlled {
            border-color: #00ff00 !important;
            box-shadow:
                0 0 10px rgba(0, 255, 0, 0.5),
                0 0 20px rgba(0, 255, 0, 0.3),
                1px 1px 0 var(--button-shadow),
                2px 2px 1px rgba(0,0,0,0.15),
                4px 4px 3px rgba(0,0,0,0.1),
                6px 6px 5px rgba(0,0,0,0.05);
        }

        .window.ai-controlled .window-titlebar {
            background: linear-gradient(180deg, #00aa00 0%, #006600 100%);
        }

        .window-titlebar {
            background: linear-gradient(180deg, #0055d4 0%, #0040a8 100%);
            color: white;
            padding: 2px 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            cursor: move;
            height: 18px;
            user-select: none;
            /* Enhanced text legibility */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .window-titlebar.inactive {
            background: linear-gradient(180deg, #909090 0%, #707070 100%);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }

        .window-content {
            background: var(--window-background);
            padding: 8px;
            overflow: auto;
            flex: 1;
            color: var(--text-color);
        }

        .resize-handle {
            position: absolute;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .window:hover .resize-handle {
            opacity: 1;
        }

        .resize-n, .resize-s {
            left: 0;
            right: 0;
            height: 6px;
            cursor: ns-resize;
        }

        .resize-n { top: 0; }
        .resize-s { bottom: 0; }

        .resize-e, .resize-w {
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
        }

        .resize-e { right: 0; }
        .resize-w { left: 0; }

        .resize-ne, .resize-nw, .resize-se, .resize-sw {
            width: 12px;
            height: 12px;
        }

        .resize-ne {
            top: 0;
            right: 0;
            cursor: nesw-resize;
        }

        .resize-nw {
            top: 0;
            left: 0;
            cursor: nwse-resize;
        }

        .resize-se {
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
            /* Visual indicator for resize corner */
            background: linear-gradient(135deg, transparent 0%, transparent 50%, rgba(0,0,0,0.1) 50%);
        }

        .resize-sw {
            bottom: 0;
            left: 0;
            cursor: nesw-resize;
        }

        .taskbar-button {
            min-width: 100px;
            max-width: 200px;
            padding: 2px 4px;
            margin: 2px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            cursor: pointer;
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: background-color 0.1s ease;
            box-shadow: 1px 1px 0 rgba(0,0,0,0.1);
        }

        .taskbar-button:hover {
            background: var(--button-light);
        }

        .taskbar-button.active {
            border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
            padding: 3px 3px 1px 5px;
            background: var(--button-shadow);
        }

        .start-menu {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 200px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            display: none;
            z-index: 10000;
            box-shadow:
                2px 2px 1px rgba(0,0,0,0.15),
                4px 4px 3px rgba(0,0,0,0.1);
            animation: startMenuSlide 0.12s ease-out;
        }

        @keyframes startMenuSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .start-menu.active {
            display: block;
        }

        .start-menu-sidebar {
            background: var(--inactive-title-bar);
            color: white;
            padding: 20px 4px;
            writing-mode: vertical-lr;
            transform: rotate(180deg);
            font-weight: bold;
            font-size: 16px;
        }

        .start-menu-items {
            padding: 2px;
        }

        .start-menu-item {
            padding: 4px 30px 4px 8px;
            cursor: pointer;
            position: relative;
            font-size: 11px;
            transition: background-color 0.08s ease;
        }

        .start-menu-item:hover {
            background: var(--menu-highlight);
            color: white;
        }

        .start-menu-item:active {
            background: #000060;
        }

        .start-menu-item::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
        }

        .context-menu {
            position: absolute;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            padding: 2px;
            min-width: 150px;
            display: none;
            z-index: 10001;
            box-shadow:
                2px 2px 1px rgba(0,0,0,0.15),
                4px 4px 3px rgba(0,0,0,0.1);
            animation: contextMenuFade 0.1s ease-out;
        }

        @keyframes contextMenuFade {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.08s ease;
        }

        .context-menu-item:hover {
            background: var(--menu-highlight);
            color: white;
        }

        .context-menu-item:active {
            background: #000060;
        }

        .context-menu-item.disabled {
            color: var(--button-shadow);
            cursor: default;
            pointer-events: none;
        }

        .context-menu-separator {
            height: 1px;
            background: var(--button-shadow);
            margin: 2px 4px;
        }

        /* Scrollbar styling for Windows 95 authenticity - Enhanced */
        .setup-screen::-webkit-scrollbar,
        .window-content::-webkit-scrollbar {
            width: 17px;
            height: 17px;
        }

        .setup-screen::-webkit-scrollbar-track,
        .window-content::-webkit-scrollbar-track {
            background: var(--button-face);
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1);
        }

        .setup-screen::-webkit-scrollbar-thumb,
        .window-content::-webkit-scrollbar-thumb {
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            box-shadow: 1px 1px 0 rgba(0,0,0,0.05);
        }

        .setup-screen::-webkit-scrollbar-thumb:hover,
        .window-content::-webkit-scrollbar-thumb:hover {
            background: var(--button-light);
        }

        .setup-screen::-webkit-scrollbar-thumb:active,
        .window-content::-webkit-scrollbar-thumb:active {
            border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
        }

        .setup-screen::-webkit-scrollbar-button,
        .window-content::-webkit-scrollbar-button {
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            height: 17px;
            width: 17px;
        }

        .setup-screen::-webkit-scrollbar-button:hover,
        .window-content::-webkit-scrollbar-button:hover {
            background: var(--button-light);
        }

        .setup-screen::-webkit-scrollbar-button:active,
        .window-content::-webkit-scrollbar-button:active {
            border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
        }

        /* Reduced motion support for accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.2rem;
            }

            .btn {
                min-height: 44px;
                min-width: 44px;
                padding: 0.6rem 1rem;
                font-size: 12px;
            }

            .info-panel {
                position: static;
                margin-top: 1rem;
                max-width: 100%;
            }

            .controls {
                width: 100%;
                justify-content: center;
            }
        }

        /* Tooltip styling - Enhanced */
        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, #ffffee 0%, #ffffcc 100%);
            border: 1px solid var(--text-color);
            padding: 3px 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
            display: none;
            box-shadow:
                2px 2px 2px rgba(0,0,0,0.2),
                3px 3px 4px rgba(0,0,0,0.1);
            animation: tooltipFade 0.15s ease-out;
        }

        @keyframes tooltipFade {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Single Morphing Clippy Assistant System */
        .clippy-container {
            position: fixed;
            bottom: 80px;
            right: 30px;
            z-index: 9999;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            pointer-events: auto;
        }

        .clippy-character {
            width: 80px;
            height: 100px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 50% 50% 40% 40%;
            position: relative;
            cursor: pointer;
            transition: all 0.4s ease;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
        }

        .clippy-character:hover {
            transform: scale(1.05) rotate(2deg);
        }

        .clippy-character:active {
            transform: scale(0.95);
        }

        /* Mode-specific colors for Clippy body */
        .clippy-character.mode-helper {
            background: linear-gradient(135deg, #ffffff 0%, #f0f0ff 100%);
            border-color: #0000ff;
        }

        .clippy-character.mode-expert {
            background: linear-gradient(135deg, #ffffff 0%, #fff0f0 100%);
            border-color: #ff0000;
        }

        .clippy-character.mode-entertainer {
            background: linear-gradient(135deg, #ffffff 0%, #ffffdd 100%);
            border-color: #ffaa00;
        }

        .clippy-character.mode-coach {
            background: linear-gradient(135deg, #ffffff 0%, #f0fff0 100%);
            border-color: #00aa00;
        }

        .clippy-character.mode-organizer {
            background: linear-gradient(135deg, #ffffff 0%, #fff0ff 100%);
            border-color: #aa00aa;
        }

        .clippy-icon {
            font-size: 50px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.4s ease;
        }

        .clippy-mode-indicator {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--button-face);
            border: 1px solid #000;
            padding: 2px 6px;
            font-size: 9px;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            transition: all 0.3s ease;
        }

        .clippy-bubble {
            display: none;
            position: absolute;
            bottom: 130px;
            right: 0;
            max-width: 280px;
            background: linear-gradient(135deg, #ffffee 0%, #ffffd0 100%);
            border: 2px solid #000;
            border-radius: 8px;
            padding: 12px 14px;
            box-shadow:
                2px 2px 4px rgba(0,0,0,0.2),
                4px 4px 8px rgba(0,0,0,0.15),
                inset 0 1px 0 rgba(255,255,255,0.5);
            animation: bubbleAppear 0.3s ease-out;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .clippy-bubble.active {
            display: block;
        }

        .bubble-arrow {
            position: absolute;
            bottom: -20px;
            right: 30px;
            border: 8px solid transparent;
            border-top-color: #000;
            z-index: 1;
        }

        .bubble-close {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #c0c0c0;
            border: 1px solid #000;
            width: 16px;
            height: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }

        .bubble-close:hover {
            background: #ff0000;
            color: #fff;
        }

        .clippy-message {
            font-size: 12px;
            line-height: 1.4;
            color: #000;
            margin-top: 4px;
            text-shadow: 0 1px 0 rgba(255,255,255,0.5);
        }

        @keyframes bubbleAppear {
            from {
                opacity: 0;
                transform: scale(0.85) translateY(10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes modeChange {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(5deg); }
        }

        .clippy-character.morphing {
            animation: modeChange 0.5s ease;
        }

        /* LocalFirst Tools Browser Styles */
        .tools-browser-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 10px;
            background: var(--button-face);
            overflow: hidden;
        }

        .tools-browser-header {
            background: white;
            border: 2px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            padding: 10px;
            margin-bottom: 10px;
        }

        .tools-search-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .tools-search-input {
            flex: 1;
            min-width: 200px;
            padding: 4px 6px;
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .tools-category-select {
            padding: 3px 6px;
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: white;
        }

        .tools-results-counter {
            font-size: 11px;
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }

        .tools-grid {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: white;
            border: 2px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
            align-content: start;
        }

        .tool-card {
            background: white;
            border: 2px solid #dfdfdf;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: fit-content;
        }

        .tool-card:hover {
            transform: translateY(-2px);
            box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
            border-color: var(--active-title-bar);
        }

        .tool-card-title {
            font-weight: bold;
            font-size: 12px;
            color: var(--text-color);
            margin-bottom: 4px;
            word-wrap: break-word;
        }

        .tool-card-description {
            font-size: 10px;
            color: #555;
            line-height: 1.4;
            margin-bottom: 8px;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .tool-card-meta {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .category-badge {
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
            font-weight: bold;
            text-align: center;
            width: fit-content;
        }

        .tool-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .tag-pill {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            color: #555;
            border: 1px solid #ddd;
        }

        .tool-card-button {
            margin-top: 4px;
            width: 100%;
        }

        .tools-status-bar {
            background: var(--button-face);
            border-top: 1px solid var(--button-highlight);
            padding: 6px 10px;
            font-size: 11px;
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            text-align: center;
        }

        .tools-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 15px;
        }

        .tools-loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--button-light);
            border-top: 4px solid var(--active-title-bar);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tools-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 15px;
            text-align: center;
        }

        .tools-error-icon {
            font-size: 48px;
        }

        .tools-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            color: #808080;
        }

        /* Screen Saver System */
        .screensaver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 99999;
            display: none;
            overflow: hidden;
        }

        .screensaver.active {
            display: block;
        }

        .screensaver-canvas {
            width: 100%;
            height: 100%;
        }

        /* Starfield screensaver */
        .starfield-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
        }

        /* Pipes screensaver */
        .pipes-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Matrix screensaver */
        .matrix-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Flying Windows logo */
        .flying-logo {
            position: absolute;
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            animation: floatAround 20s infinite ease-in-out;
        }

        @keyframes floatAround {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(80vw, 20vh) rotate(90deg); }
            50% { transform: translate(60vw, 70vh) rotate(180deg); }
            75% { transform: translate(10vw, 50vh) rotate(270deg); }
        }

        /* Toast notification system */
        .toast-notification {
            position: fixed;
            bottom: 50px;
            right: 20px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            padding: 12px 16px;
            min-width: 200px;
            max-width: 300px;
            z-index: 10002;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease-out;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-title {
            font-weight: bold;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toast-message {
            color: var(--text-color);
            line-height: 1.3;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span class="logo"></span> Windows 95 Desktop Simulator</h1>
        <div class="controls" role="toolbar" aria-label="Desktop controls">
            <button class="btn" id="pause-btn" onclick="emulator.togglePause()" aria-label="Pause desktop" title="Pause/Resume">
                <span aria-hidden="true">⏸</span> Pause
            </button>
            <button class="btn" onclick="emulator.restart()" aria-label="Restart desktop" title="Restart desktop">
                <span aria-hidden="true">🔄</span> Restart
            </button>
            <button class="btn" onclick="emulator.fullscreen()" aria-label="Enter fullscreen mode" title="Toggle fullscreen">
                <span aria-hidden="true">🖥</span> Fullscreen
            </button>
            <button class="btn" onclick="emulator.screenshot()" aria-label="Take screenshot" title="Save screenshot">
                <span aria-hidden="true">📷</span> Screenshot
            </button>
            <button class="btn" onclick="emulator.showHelp()" aria-label="Show help information" title="Help & Information">
                <span aria-hidden="true">❓</span> Help
            </button>
            <button class="btn primary" onclick="emulator.openAbout()" aria-label="About this simulator" title="About">
                <span aria-hidden="true">ℹ️</span> About
            </button>
        </div>
    </div>

    <div class="main-container">
        <div id="setup-screen" class="setup-screen" role="dialog" aria-labelledby="setup-title">
            <h2 id="setup-title">Windows 95 Desktop Simulator</h2>
            <div class="setup-content">
                <p><strong>Welcome to the Interactive Windows 95 Desktop Simulator!</strong></p>
                <p>Experience a fully functional Windows 95 desktop environment right in your browser.</p>

                <div class="setup-option">
                    <h3><span aria-hidden="true">🎮</span> Start Desktop Experience</h3>
                    <p>Launch the interactive desktop with working programs and classic Windows 95 interface.</p>
                    <p><strong>Features:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><strong>Chromium Browser</strong> - Full browser engine with DevTools! ⭐ NEW!</li>
                        <li><strong>Internet Explorer</strong> - Browse real websites!</li>
                        <li>Draggable, resizable windows</li>
                        <li>Working Notepad, Calculator, and Minesweeper</li>
                        <li>Functional Start menu</li>
                        <li>Clickable desktop icons</li>
                        <li>Right-click context menus</li>
                        <li>Authentic Windows 95 aesthetics</li>
                    </ul>
                    <button class="btn primary" onclick="emulator.loadDemo()" style="margin-top: 10px;">Start Windows 95 Desktop</button>
                </div>

                <div class="setup-option" style="background: #e0e0e0;">
                    <h3><span aria-hidden="true">⚙️</span> Emulator Settings</h3>
                    <div style="display: grid; gap: 8px;">
                        <label>
                            <input type="checkbox" id="enable-mouse"> Enable Mouse Lock (Leave OFF for interactive desktop)
                        </label>
                        <label>
                            <input type="checkbox" id="enable-sound"> Enable Sound Emulation
                        </label>
                        <label>
                            <input type="checkbox" id="enable-network" checked> Enable Network
                        </label>
                        <label style="display: block; margin-top: 8px;">
                            <strong>Memory Allocation:</strong>
                            <select id="memory-size" style="width: 100%; margin-top: 4px;">
                                <option value="8">8 MB (Minimum)</option>
                                <option value="16">16 MB (Low)</option>
                                <option value="32" selected>32 MB (Recommended)</option>
                                <option value="64">64 MB (High)</option>
                                <option value="128">128 MB (Maximum)</option>
                            </select>
                        </label>
                        <label style="display: block; margin-top: 8px;">
                            <strong>CPU Speed:</strong>
                            <select id="cpu-speed" style="width: 100%; margin-top: 4px;">
                                <option value="1">1x (Authentic)</option>
                                <option value="2" selected>2x (Balanced)</option>
                                <option value="4">4x (Fast)</option>
                                <option value="8">8x (Maximum)</option>
                            </select>
                        </label>
                    </div>
                </div>

                <div class="setup-option" style="background: #fff8dc;">
                    <h3><span aria-hidden="true">ℹ️</span> System Information</h3>
                    <p><strong>Browser:</strong> <span id="browser-info">Detecting...</span></p>
                    <p><strong>WebAssembly:</strong> <span id="wasm-support">Checking...</span></p>
                    <p><strong>Screen:</strong> <span id="screen-info">Detecting...</span></p>
                </div>
            </div>
        </div>

        <div id="emulator-container" class="emulator-frame hidden">
            <div class="emulator-titlebar" id="emulator-titlebar">
                <span>Windows 95 Desktop - Interactive Mode</span>
                <div class="titlebar-buttons">
                    <div class="titlebar-btn" onclick="emulator.minimize()" role="button" aria-label="Minimize" title="Minimize">_</div>
                    <div class="titlebar-btn" onclick="emulator.maximize()" role="button" aria-label="Maximize" title="Maximize">□</div>
                    <div class="titlebar-btn" onclick="emulator.close()" role="button" aria-label="Close" title="Close">X</div>
                </div>
            </div>
            <div id="screen_container">
                <canvas id="screen" role="img" aria-label="Windows 95 emulator screen" tabindex="0"></canvas>
            </div>
            <div class="status-bar" role="status" aria-live="polite" aria-atomic="false">
                <div class="status-section">
                    <span id="cpu-status-label">CPU:</span>
                    <span id="cpu-status" aria-labelledby="cpu-status-label">Idle</span>
                    <div class="led" id="cpu-led" role="status" aria-label="CPU activity indicator" title="CPU Activity"></div>
                </div>
                <div class="status-section">
                    <span>HDD:</span>
                    <div class="led hdd" id="hdd-led" role="status" aria-label="Hard drive activity indicator" title="HDD Activity"></div>
                </div>
                <div class="status-section">
                    <span>FPS:</span>
                    <span id="fps-counter" aria-label="Frames per second">0</span>
                </div>
                <div class="status-section">
                    <span>MEM:</span>
                    <span id="memory-usage" aria-label="Memory usage">0 MB</span>
                </div>
                <div class="status-section">
                    <span id="time-display" aria-label="Uptime" title="Uptime">00:00:00</span>
                </div>
            </div>
        </div>

        <div class="info-panel" id="info-panel">
            <h4><span class="warning-icon" aria-hidden="true">💡</span> Quick Start Guide</h4>
            <ul>
                <li><strong>Try Internet Explorer!</strong> Browse real websites (try wikipedia.org)</li>
                <li><strong>Double-click</strong> desktop icons to launch programs</li>
                <li><strong>Drag</strong> windows by their title bars to move them</li>
                <li><strong>Click</strong> the Start button for the program menu</li>
                <li><strong>Right-click</strong> the desktop for context menu</li>
                <li><strong>Minimize</strong> windows to the taskbar</li>
                <li>Press <strong>F11</strong> for fullscreen mode</li>
                <li><strong>Note:</strong> Mouse lock is disabled for free movement</li>
            </ul>
            <button class="btn" onclick="document.getElementById('info-panel').classList.add('hidden')" style="margin-top: 8px; width: 100%;">Got it!</button>
        </div>
    </div>

    <div class="loading-screen" id="loading-screen" role="alert" aria-live="assertive">
        <div class="boot-logo" aria-hidden="true"></div>
        <div class="loading-text" id="loading-text">Starting Windows 95 Desktop...</div>
        <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        /** @ts-nocheck */
        // Polyfill for String.padStart (IE11, Safari < 10)
        if (!String.prototype.padStart) {
            String.prototype.padStart = function padStart(targetLength, padString) {
                targetLength = targetLength >> 0;
                padString = String(typeof padString !== 'undefined' ? padString : ' ');
                if (this.length >= targetLength) {
                    return String(this);
                }
                targetLength = targetLength - this.length;
                if (targetLength > padString.length) {
                    padString += padString.repeat(targetLength / padString.length);
                }
                return padString.slice(0, targetLength) + String(this);
            };
        }

        // Configuration constants
        const CONFIG = {
            DISPLAY: {
                WIDTH: 640,
                HEIGHT: 480,
                TASKBAR_HEIGHT: 30
            },
            COLORS: {
                DESKTOP: '#008080',
                TASKBAR: '#c0c0c0',
                TITLE_BAR: '#000080',
                WINDOW_BG: '#ffffff'
            },
            ANIMATION: {
                FPS_UPDATE_INTERVAL: 1000,
                LED_THROTTLE_FRAMES: 10,
                BOOT_MESSAGE_DELAY: 150
            },
            PERFORMANCE: {
                MAX_FPS: 60,
                FRAME_TIME: 16.67
            }
        };

        // Window Manager - handles all window operations
        class WindowManager {
            constructor(desktop) {
                this.desktop = desktop;
                this.windows = [];
                this.nextZIndex = 1000;
                this.draggedWindow = null;
                this.dragOffset = { x: 0, y: 0 };
                this.resizingWindow = null;
                this.resizeDirection = null;
                this.resizeStart = { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0 };
                this.snapThreshold = 20; // pixels from edge to trigger snap
            }

            createWindow(title, content, options = {}) {
                const windowId = 'win-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                // Load saved position if available
                const savedPosition = this.loadWindowPosition(title);
                const defaultX = 100 + this.windows.length * 30;
                const defaultY = 100 + this.windows.length * 30;

                const windowEl = document.createElement('div');
                windowEl.className = 'window active';
                windowEl.id = windowId;
                windowEl.style.left = (options.x || savedPosition?.x || defaultX) + 'px';
                windowEl.style.top = (options.y || savedPosition?.y || defaultY) + 'px';
                windowEl.style.width = (options.width || savedPosition?.width || 400) + 'px';
                windowEl.style.height = (options.height || savedPosition?.height || 300) + 'px';
                windowEl.style.zIndex = this.nextZIndex++;
                windowEl.dataset.windowTitle = title; // Store title for position saving

                const titleBar = document.createElement('div');
                titleBar.className = 'window-titlebar';
                titleBar.innerHTML = `
                    <span>${title}</span>
                    <div class="titlebar-buttons">
                        <div class="titlebar-btn minimize-btn" title="Minimize">_</div>
                        <div class="titlebar-btn maximize-btn" title="Maximize">□</div>
                        <div class="titlebar-btn close-btn" title="Close">X</div>
                    </div>
                `;

                const contentEl = document.createElement('div');
                contentEl.className = 'window-content';
                if (typeof content === 'string') {
                    contentEl.innerHTML = content;
                } else {
                    contentEl.appendChild(content);
                }

                // Add resize handles
                const resizeHandles = document.createElement('div');
                resizeHandles.innerHTML = `
                    <div class="resize-handle resize-n" data-direction="n"></div>
                    <div class="resize-handle resize-s" data-direction="s"></div>
                    <div class="resize-handle resize-e" data-direction="e"></div>
                    <div class="resize-handle resize-w" data-direction="w"></div>
                    <div class="resize-handle resize-ne" data-direction="ne"></div>
                    <div class="resize-handle resize-nw" data-direction="nw"></div>
                    <div class="resize-handle resize-se" data-direction="se"></div>
                    <div class="resize-handle resize-sw" data-direction="sw"></div>
                `;

                windowEl.appendChild(titleBar);
                windowEl.appendChild(contentEl);
                windowEl.appendChild(resizeHandles);

                // Add to desktop
                const screenContainer = document.getElementById('screen_container');
                screenContainer.appendChild(windowEl);

                // Setup event listeners
                this.setupWindowEvents(windowEl, titleBar);

                // Store window reference
                const windowObj = {
                    id: windowId,
                    element: windowEl,
                    title: title,
                    minimized: false
                };
                this.windows.push(windowObj);

                // Add taskbar button
                this.desktop.addTaskbarButton(windowObj);

                // Focus window
                this.focusWindow(windowEl);

                // Play window open sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('window-open');
                }

                return windowObj;
            }

            setupWindowEvents(windowEl, titleBar) {
                // Make titlebar draggable
                titleBar.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.titlebar-btn')) return;

                    this.draggedWindow = windowEl;
                    this.dragOffset = {
                        x: e.clientX - windowEl.offsetLeft,
                        y: e.clientY - windowEl.offsetTop
                    };
                    this.focusWindow(windowEl);
                });

                // Right-click on title bar for system menu
                titleBar.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.showWindowSystemMenu(e.clientX, e.clientY, windowEl);
                });

                // Close button
                const closeBtn = windowEl.querySelector('.close-btn');
                closeBtn.addEventListener('click', () => this.closeWindow(windowEl));

                // Minimize button
                const minimizeBtn = windowEl.querySelector('.minimize-btn');
                minimizeBtn.addEventListener('click', () => this.minimizeWindow(windowEl));

                // Maximize button
                const maximizeBtn = windowEl.querySelector('.maximize-btn');
                maximizeBtn.addEventListener('click', () => this.maximizeWindow(windowEl));

                // Focus on click
                windowEl.addEventListener('mousedown', () => this.focusWindow(windowEl));

                // Resize handles
                const resizeHandles = windowEl.querySelectorAll('.resize-handle');
                resizeHandles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.resizingWindow = windowEl;
                        this.resizeDirection = handle.dataset.direction;
                        this.resizeStart = {
                            x: e.clientX,
                            y: e.clientY,
                            width: windowEl.offsetWidth,
                            height: windowEl.offsetHeight,
                            left: windowEl.offsetLeft,
                            top: windowEl.offsetTop
                        };
                        this.focusWindow(windowEl);
                    });
                });
            }

            focusWindow(windowEl) {
                // Remove active class from all windows
                this.windows.forEach(win => {
                    win.element.classList.remove('active');
                    const titlebar = win.element.querySelector('.window-titlebar');
                    if (titlebar) titlebar.classList.add('inactive');
                });

                // Set active window
                windowEl.classList.add('active');
                windowEl.style.zIndex = this.nextZIndex++;
                const titlebar = windowEl.querySelector('.window-titlebar');
                if (titlebar) titlebar.classList.remove('inactive');

                // Update taskbar buttons
                this.desktop.updateTaskbarButtons();
            }

            minimizeWindow(windowEl) {
                const windowObj = this.windows.find(w => w.element === windowEl);
                if (windowObj) {
                    windowObj.minimized = true;
                    windowEl.classList.add('minimized');
                    this.desktop.updateTaskbarButtons();

                    // Play minimize sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('minimize');
                    }
                }
            }

            maximizeWindow(windowEl) {
                const isMaximized = windowEl.dataset.maximized === 'true';

                if (isMaximized) {
                    // Restore
                    windowEl.style.left = windowEl.dataset.restoreLeft;
                    windowEl.style.top = windowEl.dataset.restoreTop;
                    windowEl.style.width = windowEl.dataset.restoreWidth;
                    windowEl.style.height = windowEl.dataset.restoreHeight;
                    windowEl.dataset.maximized = 'false';

                    // Save restored position
                    const title = windowEl.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(windowEl.style.left),
                            y: parseInt(windowEl.style.top),
                            width: parseInt(windowEl.style.width),
                            height: parseInt(windowEl.style.height)
                        });
                    }

                    // Play minimize sound (for restore)
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('minimize');
                    }
                } else {
                    // Store current position
                    windowEl.dataset.restoreLeft = windowEl.style.left;
                    windowEl.dataset.restoreTop = windowEl.style.top;
                    windowEl.dataset.restoreWidth = windowEl.style.width;
                    windowEl.dataset.restoreHeight = windowEl.style.height;

                    // Maximize
                    windowEl.style.left = '0px';
                    windowEl.style.top = '0px';
                    windowEl.style.width = '640px';
                    windowEl.style.height = '450px';
                    windowEl.dataset.maximized = 'true';

                    // Play maximize sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('maximize');
                    }
                }
            }

            restoreWindow(windowEl) {
                const windowObj = this.windows.find(w => w.element === windowEl);
                if (windowObj && windowObj.minimized) {
                    windowObj.minimized = false;
                    windowEl.classList.remove('minimized');
                    this.focusWindow(windowEl);
                    this.desktop.updateTaskbarButtons();
                }
            }

            closeWindow(windowEl) {
                const index = this.windows.findIndex(w => w.element === windowEl);
                if (index > -1) {
                    const windowObj = this.windows[index];
                    this.desktop.removeTaskbarButton(windowObj);
                    windowEl.remove();
                    this.windows.splice(index, 1);

                    // Play window close sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('window-close');
                    }
                }
            }

            handleMouseMove(e) {
                // Handle window resizing
                if (this.resizingWindow) {
                    const deltaX = e.clientX - this.resizeStart.x;
                    const deltaY = e.clientY - this.resizeStart.y;
                    const dir = this.resizeDirection;
                    const win = this.resizingWindow;
                    const minWidth = 200;
                    const minHeight = 150;

                    let newWidth = this.resizeStart.width;
                    let newHeight = this.resizeStart.height;
                    let newLeft = this.resizeStart.left;
                    let newTop = this.resizeStart.top;

                    // Calculate new dimensions based on resize direction
                    if (dir.includes('e')) {
                        newWidth = Math.max(minWidth, this.resizeStart.width + deltaX);
                    }
                    if (dir.includes('w')) {
                        newWidth = Math.max(minWidth, this.resizeStart.width - deltaX);
                        if (newWidth > minWidth) newLeft = this.resizeStart.left + deltaX;
                    }
                    if (dir.includes('s')) {
                        newHeight = Math.max(minHeight, this.resizeStart.height + deltaY);
                    }
                    if (dir.includes('n')) {
                        newHeight = Math.max(minHeight, this.resizeStart.height - deltaY);
                        if (newHeight > minHeight) newTop = this.resizeStart.top + deltaY;
                    }

                    win.style.width = newWidth + 'px';
                    win.style.height = newHeight + 'px';
                    win.style.left = newLeft + 'px';
                    win.style.top = newTop + 'px';
                }

                // Handle window dragging
                if (this.draggedWindow) {
                    const screenContainer = document.getElementById('screen_container');
                    const containerRect = screenContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;

                    let newX = e.clientX - this.dragOffset.x;
                    let newY = e.clientY - this.dragOffset.y;

                    // Keep within bounds
                    newX = Math.max(0, Math.min(containerWidth - 100, newX));
                    newY = Math.max(0, Math.min(containerHeight - 30, newY));

                    this.draggedWindow.style.left = newX + 'px';
                    this.draggedWindow.style.top = newY + 'px';

                    // Show snap preview
                    this.showSnapPreview(e.clientX, e.clientY, containerWidth, containerHeight);
                }
            }

            handleMouseUp(e) {
                // Handle resize end
                if (this.resizingWindow) {
                    const title = this.resizingWindow.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(this.resizingWindow.style.left),
                            y: parseInt(this.resizingWindow.style.top),
                            width: parseInt(this.resizingWindow.style.width),
                            height: parseInt(this.resizingWindow.style.height)
                        });
                    }
                    this.resizingWindow = null;
                    this.resizeDirection = null;
                }

                // Handle drag end with snap
                if (this.draggedWindow) {
                    const screenContainer = document.getElementById('screen_container');
                    const containerRect = screenContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;

                    // Check for snap zones
                    const snapPosition = this.getSnapPosition(e.clientX, e.clientY, containerWidth, containerHeight);
                    if (snapPosition) {
                        this.snapWindow(this.draggedWindow, snapPosition, containerWidth, containerHeight);
                    }

                    // Save window position after dragging
                    const title = this.draggedWindow.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(this.draggedWindow.style.left),
                            y: parseInt(this.draggedWindow.style.top),
                            width: parseInt(this.draggedWindow.style.width),
                            height: parseInt(this.draggedWindow.style.height)
                        });
                    }
                    this.draggedWindow = null;
                    this.hideSnapPreview();
                }
            }

            showSnapPreview(mouseX, mouseY, containerWidth, containerHeight) {
                const snapPosition = this.getSnapPosition(mouseX, mouseY, containerWidth, containerHeight);
                let preview = document.getElementById('snap-preview');

                if (!preview) {
                    preview = document.createElement('div');
                    preview.id = 'snap-preview';
                    preview.style.cssText = 'position: absolute; border: 3px solid #0066cc; background: rgba(0, 102, 204, 0.1); pointer-events: none; z-index: 9999; display: none;';
                    document.getElementById('screen_container').appendChild(preview);
                }

                if (snapPosition) {
                    const pos = this.calculateSnapDimensions(snapPosition, containerWidth, containerHeight);
                    preview.style.left = pos.left + 'px';
                    preview.style.top = pos.top + 'px';
                    preview.style.width = pos.width + 'px';
                    preview.style.height = pos.height + 'px';
                    preview.style.display = 'block';
                } else {
                    preview.style.display = 'none';
                }
            }

            hideSnapPreview() {
                const preview = document.getElementById('snap-preview');
                if (preview) {
                    preview.style.display = 'none';
                }
            }

            getSnapPosition(mouseX, mouseY, containerWidth, containerHeight) {
                const threshold = this.snapThreshold;

                // Left edge
                if (mouseX < threshold) {
                    if (mouseY < threshold) return 'top-left';
                    if (mouseY > containerHeight - threshold) return 'bottom-left';
                    return 'left';
                }

                // Right edge
                if (mouseX > containerWidth - threshold) {
                    if (mouseY < threshold) return 'top-right';
                    if (mouseY > containerHeight - threshold) return 'bottom-right';
                    return 'right';
                }

                // Top edge
                if (mouseY < threshold) {
                    return 'top';
                }

                // Bottom edge
                if (mouseY > containerHeight - threshold) {
                    return 'bottom';
                }

                return null;
            }

            calculateSnapDimensions(position, containerWidth, containerHeight) {
                const taskbarHeight = 30;
                const workHeight = containerHeight - taskbarHeight;

                const positions = {
                    'left': { left: 0, top: 0, width: containerWidth / 2, height: workHeight },
                    'right': { left: containerWidth / 2, top: 0, width: containerWidth / 2, height: workHeight },
                    'top': { left: 0, top: 0, width: containerWidth, height: workHeight },
                    'bottom': { left: 0, top: workHeight / 2, width: containerWidth, height: workHeight / 2 },
                    'top-left': { left: 0, top: 0, width: containerWidth / 2, height: workHeight / 2 },
                    'top-right': { left: containerWidth / 2, top: 0, width: containerWidth / 2, height: workHeight / 2 },
                    'bottom-left': { left: 0, top: workHeight / 2, width: containerWidth / 2, height: workHeight / 2 },
                    'bottom-right': { left: containerWidth / 2, top: workHeight / 2, width: containerWidth / 2, height: workHeight / 2 }
                };

                return positions[position] || null;
            }

            snapWindow(windowEl, position, containerWidth, containerHeight) {
                const dims = this.calculateSnapDimensions(position, containerWidth, containerHeight);
                if (dims) {
                    windowEl.style.left = dims.left + 'px';
                    windowEl.style.top = dims.top + 'px';
                    windowEl.style.width = dims.width + 'px';
                    windowEl.style.height = dims.height + 'px';
                    windowEl.dataset.maximized = 'false';
                }
            }

            updateBounds(width, height) {
                // This is called when the canvas/screen is resized (e.g., fullscreen mode)
                // We don't need to do anything special here since windows use absolute positioning
                // and the snap calculations already use current dimensions
            }

            showWindowSystemMenu(x, y, windowEl) {
                // Remove existing context menu
                const existing = document.getElementById('window-system-menu');
                if (existing) existing.remove();

                const isMaximized = windowEl.dataset.maximized === 'true';
                const isMinimized = windowEl.style.display === 'none';

                const contextMenu = document.createElement('div');
                contextMenu.id = 'window-system-menu';
                contextMenu.className = 'context-menu active';
                contextMenu.style.position = 'fixed';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.innerHTML = `
                    ${isMaximized ? `
                    <div class="context-menu-item" onclick="emulator.windowManager.restoreWindowFromMenu(); document.getElementById('window-system-menu').remove();">
                        ↩️ Restore
                    </div>
                    ` : ''}
                    <div class="context-menu-item ${isMinimized ? 'disabled' : ''}" onclick="if(!this.classList.contains('disabled')){emulator.windowManager.minimizeWindowFromMenu(); document.getElementById('window-system-menu').remove();}">
                        _ Minimize
                    </div>
                    <div class="context-menu-item ${isMaximized ? 'disabled' : ''}" onclick="if(!this.classList.contains('disabled')){emulator.windowManager.maximizeWindowFromMenu(); document.getElementById('window-system-menu').remove();}">
                        □ Maximize
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.windowManager.closeWindowFromMenu(); document.getElementById('window-system-menu').remove();">
                        ✕ Close     <span style="float: right; opacity: 0.6;">Alt+F4</span>
                    </div>
                `;

                // Store reference to window for menu actions
                this.contextMenuWindow = windowEl;

                document.body.appendChild(contextMenu);

                // Close on next click
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        if (contextMenu.parentNode) contextMenu.remove();
                        document.removeEventListener('click', closeMenu);
                    }, { once: true });
                }, 100);
            }

            minimizeWindowFromMenu() {
                if (this.contextMenuWindow) {
                    this.minimizeWindow(this.contextMenuWindow);
                    this.contextMenuWindow = null;
                }
            }

            maximizeWindowFromMenu() {
                if (this.contextMenuWindow) {
                    this.maximizeWindow(this.contextMenuWindow);
                    this.contextMenuWindow = null;
                }
            }

            restoreWindowFromMenu() {
                if (this.contextMenuWindow) {
                    this.maximizeWindow(this.contextMenuWindow); // Toggle maximize
                    this.contextMenuWindow = null;
                }
            }

            closeWindowFromMenu() {
                if (this.contextMenuWindow) {
                    this.closeWindow(this.contextMenuWindow);
                    this.contextMenuWindow = null;
                }
            }

            loadWindowPosition(title) {
                try {
                    const positions = SafeStorage.getItem('win95-window-positions');
                    if (positions) {
                        const allPositions = JSON.parse(positions);
                        return allPositions[title];
                    }
                } catch (e) {
                    console.warn('Failed to load window position:', e);
                }
                return null;
            }

            saveWindowPosition(title, position) {
                try {
                    let positions = {};
                    const saved = SafeStorage.getItem('win95-window-positions');
                    if (saved) {
                        positions = JSON.parse(saved);
                    }
                    positions[title] = position;
                    SafeStorage.setItem('win95-window-positions', JSON.stringify(positions));
                } catch (e) {
                    console.warn('Failed to save window position:', e);
                }
            }

            // Cascade all windows (authentic Windows 95 feature)
            cascadeWindows() {
                const visibleWindows = this.windows.filter(w => !w.minimized);
                if (visibleWindows.length === 0) return;

                const startX = 30;
                const startY = 30;
                const offsetX = 30;
                const offsetY = 30;
                const defaultWidth = 500;
                const defaultHeight = 400;

                visibleWindows.forEach((win, index) => {
                    win.element.style.left = (startX + index * offsetX) + 'px';
                    win.element.style.top = (startY + index * offsetY) + 'px';
                    win.element.style.width = defaultWidth + 'px';
                    win.element.style.height = defaultHeight + 'px';
                    win.element.dataset.maximized = 'false';
                });

                // Focus the last window
                if (visibleWindows.length > 0) {
                    this.focusWindow(visibleWindows[visibleWindows.length - 1].element);
                }

                // Play window arrange sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('maximize');
                }
            }

            // Tile windows horizontally
            tileHorizontally() {
                const visibleWindows = this.windows.filter(w => !w.minimized);
                if (visibleWindows.length === 0) return;

                const screenContainer = document.getElementById('screen_container');
                const containerWidth = screenContainer.offsetWidth;
                const containerHeight = screenContainer.offsetHeight - 30; // Account for taskbar

                const windowWidth = containerWidth / visibleWindows.length;
                const windowHeight = containerHeight;

                visibleWindows.forEach((win, index) => {
                    win.element.style.left = (index * windowWidth) + 'px';
                    win.element.style.top = '0px';
                    win.element.style.width = windowWidth + 'px';
                    win.element.style.height = windowHeight + 'px';
                    win.element.dataset.maximized = 'false';
                });

                // Play window arrange sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('maximize');
                }
            }

            // Tile windows vertically
            tileVertically() {
                const visibleWindows = this.windows.filter(w => !w.minimized);
                if (visibleWindows.length === 0) return;

                const screenContainer = document.getElementById('screen_container');
                const containerWidth = screenContainer.offsetWidth;
                const containerHeight = screenContainer.offsetHeight - 30; // Account for taskbar

                const windowWidth = containerWidth;
                const windowHeight = containerHeight / visibleWindows.length;

                visibleWindows.forEach((win, index) => {
                    win.element.style.left = '0px';
                    win.element.style.top = (index * windowHeight) + 'px';
                    win.element.style.width = windowWidth + 'px';
                    win.element.style.height = windowHeight + 'px';
                    win.element.dataset.maximized = 'false';
                });

                // Play window arrange sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('maximize');
                }
            }

            // Minimize all windows (show desktop)
            minimizeAllWindows() {
                this.windows.forEach(win => {
                    if (!win.minimized) {
                        this.minimizeWindow(win.element);
                    }
                });

                // Play minimize sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('minimize');
                }
            }
        }

        // ============================================================================
        // CHROMIUM BROWSER ENGINE - Complete Implementation
        // ============================================================================

        class ChromiumBrowserEngine {
            constructor(emulator) {
                this.emulator = emulator;
                this.tabs = [];
                this.activeTab = null;
                this.nextTabId = 1;
                this.history = [];
                this.bookmarks = this.loadBookmarks();
                this.extensions = [];
                this.downloads = [];
                this.networkRequests = [];
                this.consoleHistory = [];

                // Process simulation
                this.processes = {
                    browser: { pid: 1, memory: 0, cpu: 0 },
                    renderer: new Map(), // Tab ID -> Process info
                    gpu: { pid: 2, memory: 0, cpu: 0 },
                    network: { pid: 3, memory: 0, cpu: 0 }
                };

                // Performance monitoring
                this.performanceMetrics = {
                    fps: 60,
                    paintTime: 0,
                    layoutTime: 0,
                    scriptTime: 0
                };

                // DevTools state
                this.devToolsOpen = false;
                this.devToolsPanel = 'elements';
                this.breakpoints = [];

                this.initializeEngine();
            }

            initializeEngine() {
                // Initialize network interception
                this.setupNetworkInterception();

                // Load extensions
                this.loadExtensions();

                // Initialize performance monitoring
                this.startPerformanceMonitoring();
            }

            createBrowserWindow() {
                const content = document.createElement('div');
                content.className = 'chromium-browser';
                content.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    height: 100%;
                    background: #f1f3f4;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
                    overflow: hidden;
                `;

                // Create title bar with tabs
                const titleBar = this.createTitleBar();
                const tabBar = this.createTabBar();
                const addressBar = this.createAddressBar();
                const contentArea = document.createElement('div');
                contentArea.id = 'chrome-content-area';
                contentArea.style.cssText = 'flex: 1; position: relative; background: white; overflow: hidden;';

                const statusBar = this.createStatusBar();

                content.appendChild(titleBar);
                content.appendChild(tabBar);
                content.appendChild(addressBar);
                content.appendChild(contentArea);
                content.appendChild(statusBar);

                const win = this.emulator.windowManager.createWindow('Chromium', content, {
                    width: 1000,
                    height: 700,
                    x: 60,
                    y: 60
                });

                this.browserWindow = win;
                this.contentArea = contentArea;

                // Create initial tab
                this.createNewTab('chrome://newtab');
            }

            createTitleBar() {
                const titleBar = document.createElement('div');
                titleBar.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 4px 8px;
                    background: linear-gradient(180deg, #e8eaed 0%, #dee1e6 100%);
                    border-bottom: 1px solid #ccc;
                    font-size: 12px;
                `;

                titleBar.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 20px; height: 20px; background: linear-gradient(45deg, #4285F4, #34A853, #FBBC05, #EA4335); border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        <span style="font-weight: 500; color: #202124;">Chromium</span>
                    </div>
                    <div style="flex: 1;"></div>
                    <button class="btn" onclick="chromiumEngine.openSettings()" style="font-size: 10px;">⚙️ Settings</button>
                `;

                return titleBar;
            }

            createTabBar() {
                const tabBar = document.createElement('div');
                tabBar.id = 'chrome-tab-bar';
                tabBar.style.cssText = `
                    display: flex;
                    align-items: flex-end;
                    background: #dee1e6;
                    padding: 4px 4px 0 4px;
                    gap: 2px;
                    overflow-x: auto;
                    overflow-y: hidden;
                `;

                const newTabBtn = document.createElement('button');
                newTabBtn.className = 'btn';
                newTabBtn.innerHTML = '+';
                newTabBtn.style.cssText = 'margin-left: 4px; min-width: 28px; height: 28px; font-size: 18px; line-height: 1;';
                newTabBtn.onclick = () => this.createNewTab('chrome://newtab');

                tabBar.appendChild(newTabBtn);

                return tabBar;
            }

            createAddressBar() {
                const addressBar = document.createElement('div');
                addressBar.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    padding: 8px;
                    background: white;
                    border-bottom: 1px solid #e0e0e0;
                `;

                addressBar.innerHTML = `
                    <button class="btn" onclick="chromiumEngine.navigate('back')" title="Back" style="min-width: 32px;">◀</button>
                    <button class="btn" onclick="chromiumEngine.navigate('forward')" title="Forward" style="min-width: 32px;">▶</button>
                    <button class="btn" onclick="chromiumEngine.navigate('reload')" title="Reload" style="min-width: 32px;">🔄</button>
                    <button class="btn" onclick="chromiumEngine.navigate('home')" title="Home" style="min-width: 32px;">🏠</button>
                    <div style="flex: 1; display: flex; align-items: center; background: white; border: 1px solid #dadce0; border-radius: 24px; padding: 4px 12px; gap: 8px;">
                        <span style="font-size: 14px; color: #5f6368;">🔒</span>
                        <input type="text" id="chrome-omnibox" placeholder="Search or enter website"
                            style="flex: 1; border: none; outline: none; font-size: 13px; font-family: inherit;"
                            onkeypress="if(event.key==='Enter') chromiumEngine.navigate('go')"
                            onfocus="chromiumEngine.showOmniboxSuggestions()"
                            oninput="chromiumEngine.updateOmniboxSuggestions()">
                        <span style="font-size: 16px; color: #5f6368; cursor: pointer;" onclick="chromiumEngine.toggleBookmark()">⭐</span>
                    </div>
                    <button class="btn" onclick="chromiumEngine.openExtensions()" title="Extensions" style="min-width: 32px;">🧩</button>
                    <button class="btn" onclick="chromiumEngine.toggleDevTools()" title="Developer Tools" style="min-width: 32px;">🔧</button>
                    <button class="btn" onclick="chromiumEngine.openMenu()" title="Menu" style="min-width: 32px;">⋮</button>
                `;

                return addressBar;
            }

            createStatusBar() {
                const statusBar = document.createElement('div');
                statusBar.id = 'chrome-status-bar';
                statusBar.style.cssText = `
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 2px 8px;
                    background: #f1f3f4;
                    border-top: 1px solid #e0e0e0;
                    font-size: 11px;
                    color: #5f6368;
                    height: 24px;
                `;

                statusBar.innerHTML = `
                    <div id="chrome-status-text"></div>
                    <div id="chrome-status-info">Process: <span id="chrome-process-count">1</span> | Memory: <span id="chrome-memory">0</span> MB | FPS: <span id="chrome-fps">60</span></div>
                `;

                return statusBar;
            }

            createNewTab(url = 'chrome://newtab') {
                const tab = {
                    id: this.nextTabId++,
                    url: url,
                    title: 'New Tab',
                    favicon: '🌐',
                    history: [url],
                    historyIndex: 0,
                    loading: false,
                    canGoBack: false,
                    canGoForward: false,
                    dom: null,
                    process: {
                        pid: 1000 + this.nextTabId,
                        memory: Math.random() * 50 + 20,
                        cpu: 0
                    }
                };

                this.tabs.push(tab);
                this.processes.renderer.set(tab.id, tab.process);

                // Create tab UI element
                this.createTabElement(tab);

                // Switch to new tab
                this.switchToTab(tab.id);

                return tab;
            }

            createTabElement(tab) {
                const tabBar = document.getElementById('chrome-tab-bar');
                if (!tabBar) return;

                const tabEl = document.createElement('div');
                tabEl.id = `chrome-tab-${tab.id}`;
                tabEl.className = 'chrome-tab';
                tabEl.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    background: #dadce0;
                    border-radius: 8px 8px 0 0;
                    padding: 6px 12px;
                    min-width: 150px;
                    max-width: 220px;
                    cursor: pointer;
                    font-size: 12px;
                    position: relative;
                `;

                tabEl.innerHTML = `
                    <span style="font-size: 14px;">${tab.favicon}</span>
                    <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${tab.title}</span>
                    <span onclick="event.stopPropagation(); chromiumEngine.closeTab(${tab.id})" style="cursor: pointer; font-size: 16px; opacity: 0.6; hover: opacity: 1;">×</span>
                `;

                tabEl.onclick = () => this.switchToTab(tab.id);

                // Insert before the + button
                const newTabBtn = tabBar.querySelector('button');
                tabBar.insertBefore(tabEl, newTabBtn);
            }

            switchToTab(tabId) {
                const tab = this.tabs.find(t => t.id === tabId);
                if (!tab) return;

                // Update active tab
                this.activeTab = tab;

                // Update tab UI
                document.querySelectorAll('.chrome-tab').forEach(el => {
                    el.style.background = '#dadce0';
                    el.style.borderBottom = '1px solid #ccc';
                });
                const activeTabEl = document.getElementById(`chrome-tab-${tabId}`);
                if (activeTabEl) {
                    activeTabEl.style.background = 'white';
                    activeTabEl.style.borderBottom = 'none';
                }

                // Update omnibox
                const omnibox = document.getElementById('chrome-omnibox');
                if (omnibox) omnibox.value = tab.url;

                // Update navigation buttons
                // (Back/Forward state would be updated here)

                // Render tab content
                this.renderTabContent(tab);
            }

            closeTab(tabId) {
                const index = this.tabs.findIndex(t => t.id === tabId);
                if (index === -1) return;

                // Remove tab
                const tab = this.tabs[index];
                this.tabs.splice(index, 1);
                this.processes.renderer.delete(tabId);

                // Remove tab UI
                const tabEl = document.getElementById(`chrome-tab-${tabId}`);
                if (tabEl) tabEl.remove();

                // Switch to another tab or close window
                if (this.tabs.length === 0) {
                    // Close browser window if no tabs left
                    if (this.browserWindow) {
                        this.emulator.windowManager.closeWindow(this.browserWindow);
                    }
                } else {
                    // Switch to previous tab or first tab
                    const newIndex = Math.max(0, index - 1);
                    this.switchToTab(this.tabs[newIndex].id);
                }
            }

            navigate(action) {
                if (!this.activeTab) return;

                const omnibox = document.getElementById('chrome-omnibox');

                switch (action) {
                    case 'back':
                        if (this.activeTab.historyIndex > 0) {
                            this.activeTab.historyIndex--;
                            this.activeTab.url = this.activeTab.history[this.activeTab.historyIndex];
                            this.loadURL(this.activeTab.url);
                        }
                        break;

                    case 'forward':
                        if (this.activeTab.historyIndex < this.activeTab.history.length - 1) {
                            this.activeTab.historyIndex++;
                            this.activeTab.url = this.activeTab.history[this.activeTab.historyIndex];
                            this.loadURL(this.activeTab.url);
                        }
                        break;

                    case 'reload':
                        this.loadURL(this.activeTab.url);
                        break;

                    case 'home':
                        this.loadURL('chrome://newtab');
                        break;

                    case 'go':
                        if (omnibox) {
                            let url = omnibox.value.trim();

                            // Check if it's a search query or URL
                            if (!url.includes('.') && !url.startsWith('chrome://')) {
                                // Search query - use DuckDuckGo
                                url = 'https://duckduckgo.com/?q=' + encodeURIComponent(url);
                            } else if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('chrome://')) {
                                url = 'https://' + url;
                            }

                            this.loadURL(url);
                        }
                        break;
                }
            }

            async loadURL(url) {
                if (!this.activeTab) return;

                // Update tab
                this.activeTab.url = url;
                this.activeTab.loading = true;

                // Add to history if navigating forward
                if (this.activeTab.historyIndex < this.activeTab.history.length - 1) {
                    this.activeTab.history = this.activeTab.history.slice(0, this.activeTab.historyIndex + 1);
                }
                this.activeTab.history.push(url);
                this.activeTab.historyIndex = this.activeTab.history.length - 1;

                // Update UI
                const omnibox = document.getElementById('chrome-omnibox');
                if (omnibox) omnibox.value = url;

                const statusText = document.getElementById('chrome-status-text');
                if (statusText) statusText.textContent = 'Loading...';

                // Handle special chrome:// URLs
                if (url.startsWith('chrome://')) {
                    this.loadChromeURL(url);
                } else {
                    // Try to load real web content
                    await this.loadWebContent(url);
                }

                this.activeTab.loading = false;
            }

            loadChromeURL(url) {
                const page = url.replace('chrome://', '');
                let content = '';

                switch (page) {
                    case 'newtab':
                        content = this.renderNewTabPage();
                        break;
                    case 'settings':
                        content = this.renderSettingsPage();
                        break;
                    case 'history':
                        content = this.renderHistoryPage();
                        break;
                    case 'bookmarks':
                        content = this.renderBookmarksPage();
                        break;
                    case 'downloads':
                        content = this.renderDownloadsPage();
                        break;
                    case 'extensions':
                        content = this.renderExtensionsPage();
                        break;
                    case 'flags':
                        content = this.renderFlagsPage();
                        break;
                    case 'version':
                        content = this.renderVersionPage();
                        break;
                    case 'internals':
                        content = this.renderInternalsPage();
                        break;
                    default:
                        content = this.render404Page();
                }

                this.activeTab.title = this.getPageTitle(page);
                this.updateTabTitle();

                const contentArea = document.getElementById('chrome-content-area');
                if (contentArea) {
                    contentArea.innerHTML = content;
                }
            }

            async loadWebContent(url) {
                const contentArea = document.getElementById('chrome-content-area');
                if (!contentArea) return;

                // Clear previous content
                contentArea.innerHTML = '';

                // Strategy 1: Try iframe with sandbox
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
                iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox';

                let loadTimeout;
                let loadSuccess = false;

                iframe.onload = () => {
                    loadSuccess = true;
                    clearTimeout(loadTimeout);
                    this.activeTab.title = this.extractTitle(iframe) || url;
                    this.updateTabTitle();
                    const statusText = document.getElementById('chrome-status-text');
                    if (statusText) statusText.textContent = 'Done';
                };

                iframe.onerror = () => {
                    loadSuccess = false;
                    clearTimeout(loadTimeout);
                    this.showCORSError(url);
                };

                contentArea.appendChild(iframe);

                // Check if iframe loads within 3 seconds
                loadTimeout = setTimeout(() => {
                    if (!loadSuccess) {
                        // Try proxy fallback
                        this.tryProxyLoad(url);
                    }
                }, 3000);
            }

            async tryProxyLoad(url) {
                try {
                    const proxyURL = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
                    const response = await fetch(proxyURL);
                    const html = await response.text();

                    // Create sandboxed iframe with srcdoc
                    const contentArea = document.getElementById('chrome-content-area');
                    if (!contentArea) return;

                    contentArea.innerHTML = '';

                    const iframe = document.createElement('iframe');
                    iframe.sandbox = 'allow-scripts';
                    iframe.srcdoc = this.rewriteHTML(html, url);
                    iframe.style.cssText = 'width: 100%; height: 100%; border: none;';

                    contentArea.appendChild(iframe);

                    this.activeTab.title = this.extractTitleFromHTML(html) || url;
                    this.updateTabTitle();

                    const statusText = document.getElementById('chrome-status-text');
                    if (statusText) statusText.textContent = 'Done (via proxy)';
                } catch (error) {
                    this.showCORSError(url);
                }
            }

            rewriteHTML(html, baseURL) {
                // Rewrite relative URLs to absolute
                const base = new URL(baseURL);

                // Replace relative links
                html = html.replace(/href=["'](?!http|\/\/|#)([^"']+)["']/g, (match, url) => {
                    const absolute = new URL(url, base).href;
                    return `href="${absolute}"`;
                });

                // Replace relative images
                html = html.replace(/src=["'](?!http|\/\/|data:)([^"']+)["']/g, (match, url) => {
                    const absolute = new URL(url, base).href;
                    return `src="${absolute}"`;
                });

                return html;
            }

            showCORSError(url) {
                const contentArea = document.getElementById('chrome-content-area');
                if (!contentArea) return;

                contentArea.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 40px; text-align: center; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;">
                        <div style="font-size: 64px; margin-bottom: 20px;">🔒</div>
                        <h2 style="font-size: 24px; font-weight: 500; color: #202124; margin-bottom: 12px;">This site can't be reached</h2>
                        <p style="color: #5f6368; margin-bottom: 24px;">The website <strong>${url}</strong> blocks embedding in iframes (X-Frame-Options).</p>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn" onclick="window.open('${url.replace(/'/g, "\\'")}', '_blank')" style="padding: 8px 20px;">Open in New Window</button>
                            <button class="btn" onclick="chromiumEngine.tryProxyLoad('${url.replace(/'/g, "\\'")}');" style="padding: 8px 20px;">Try Proxy Load</button>
                        </div>
                        <div style="margin-top: 32px; padding: 16px; background: #f8f9fa; border-radius: 8px; max-width: 500px;">
                            <p style="font-size: 12px; color: #5f6368; text-align: left;">
                                <strong>Why this happens:</strong><br>
                                • Website security policy prevents iframe embedding<br>
                                • CORS (Cross-Origin Resource Sharing) restrictions<br>
                                • X-Frame-Options header blocks embedded access
                            </p>
                        </div>
                    </div>
                `;

                const statusText = document.getElementById('chrome-status-text');
                if (statusText) statusText.textContent = 'Failed to load (CORS blocked)';
            }

            extractTitle(iframe) {
                try {
                    return iframe.contentDocument?.title || null;
                } catch (e) {
                    return null;
                }
            }

            extractTitleFromHTML(html) {
                const match = html.match(/<title[^>]*>([^<]+)<\/title>/i);
                return match ? match[1] : null;
            }

            updateTabTitle() {
                if (!this.activeTab) return;

                const tabEl = document.getElementById(`chrome-tab-${this.activeTab.id}`);
                if (tabEl) {
                    const titleSpan = tabEl.querySelector('span:nth-child(2)');
                    if (titleSpan) titleSpan.textContent = this.activeTab.title;
                }
            }

            getPageTitle(page) {
                const titles = {
                    'newtab': 'New Tab',
                    'settings': 'Settings',
                    'history': 'History',
                    'bookmarks': 'Bookmarks',
                    'downloads': 'Downloads',
                    'extensions': 'Extensions',
                    'flags': 'Experiments',
                    'version': 'About Chromium',
                    'internals': 'Browser Internals'
                };
                return titles[page] || 'Chromium';
            }

            renderNewTabPage() {
                return `
                    <div style="display: flex; flex-direction: column; align-items: center; padding: 60px 40px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto;">
                        <div style="width: 100%; max-width: 600px; margin-bottom: 40px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 24px;">
                                <div style="width: 40px; height: 40px; background: linear-gradient(45deg, #4285F4, #34A853, #FBBC05, #EA4335); border-radius: 50%;"></div>
                                <h1 style="font-size: 32px; font-weight: 300; color: #202124;">Chromium</h1>
                            </div>
                            <div style="position: relative; margin-bottom: 32px;">
                                <input type="text" placeholder="Search or enter website"
                                    style="width: 100%; padding: 12px 16px; border: 1px solid #dadce0; border-radius: 24px; font-size: 14px; font-family: inherit; outline: none;"
                                    onkeypress="if(event.key==='Enter') { document.getElementById('chrome-omnibox').value = this.value; chromiumEngine.navigate('go'); }"
                                    onfocus="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)'"
                                    onblur="this.style.boxShadow='none'">
                            </div>
                        </div>

                        <div style="width: 100%; max-width: 900px;">
                            <h2 style="font-size: 16px; font-weight: 500; color: #202124; margin-bottom: 16px;">Quick Links</h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 16px; margin-bottom: 40px;">
                                ${this.renderQuickLinks()}
                            </div>
                        </div>

                        <div style="width: 100%; max-width: 900px;">
                            <h2 style="font-size: 16px; font-weight: 500; color: #202124; margin-bottom: 16px;">Bookmarks</h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                ${this.renderBookmarksPreview()}
                            </div>
                        </div>
                    </div>
                `;
            }

            renderQuickLinks() {
                const links = [
                    { name: 'History', icon: '📜', url: 'chrome://history' },
                    { name: 'Downloads', icon: '💾', url: 'chrome://downloads' },
                    { name: 'Bookmarks', icon: '⭐', url: 'chrome://bookmarks' },
                    { name: 'Settings', icon: '⚙️', url: 'chrome://settings' },
                    { name: 'Extensions', icon: '🧩', url: 'chrome://extensions' },
                    { name: 'Flags', icon: '🚩', url: 'chrome://flags' },
                    { name: 'Internals', icon: '🔧', url: 'chrome://internals' },
                    { name: 'Version', icon: 'ℹ️', url: 'chrome://version' }
                ];

                return links.map(link => `
                    <div onclick="chromiumEngine.loadURL('${link.url}')" style="
                        display: flex; flex-direction: column; align-items: center; justify-content: center;
                        padding: 16px; background: white; border: 1px solid #e0e0e0; border-radius: 8px;
                        cursor: pointer; transition: all 0.2s;
                    " onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.boxShadow='none'">
                        <div style="font-size: 32px; margin-bottom: 8px;">${link.icon}</div>
                        <div style="font-size: 12px; color: #5f6368; text-align: center;">${link.name}</div>
                    </div>
                `).join('');
            }

            renderBookmarksPreview() {
                if (this.bookmarks.length === 0) {
                    return '<div style="color: #5f6368; padding: 20px; text-align: center;">No bookmarks yet. Start browsing and bookmark your favorite sites!</div>';
                }

                return this.bookmarks.slice(0, 6).map(bookmark => `
                    <div onclick="chromiumEngine.loadURL('${bookmark.url}')" style="
                        padding: 12px; background: white; border: 1px solid #e0e0e0; border-radius: 8px;
                        cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 8px;
                    " onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.boxShadow='none'">
                        <div style="font-size: 20px;">${bookmark.favicon || '🌐'}</div>
                        <div style="flex: 1; overflow: hidden;">
                            <div style="font-size: 13px; font-weight: 500; color: #202124; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${bookmark.title}</div>
                            <div style="font-size: 11px; color: #5f6368; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${bookmark.url}</div>
                        </div>
                    </div>
                `).join('');
            }

            renderSettingsPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
                            <h1 style="font-size: 28px; font-weight: 400; color: #202124; margin-bottom: 32px;">Settings</h1>

                            ${this.renderSettingsSection('Search engine', [
                                { label: 'Default search engine', value: 'DuckDuckGo', type: 'select', options: ['DuckDuckGo', 'Google', 'Bing'] }
                            ])}

                            ${this.renderSettingsSection('Appearance', [
                                { label: 'Show bookmarks bar', value: true, type: 'toggle' },
                                { label: 'Show home button', value: true, type: 'toggle' },
                                { label: 'Theme', value: 'System default', type: 'select', options: ['System default', 'Light', 'Dark'] }
                            ])}

                            ${this.renderSettingsSection('Privacy and security', [
                                { label: 'Block third-party cookies', value: true, type: 'toggle' },
                                { label: 'Send "Do Not Track" request', value: true, type: 'toggle' },
                                { label: 'Safe Browsing', value: 'Enhanced', type: 'select', options: ['Enhanced', 'Standard', 'Off'] }
                            ])}

                            ${this.renderSettingsSection('Performance', [
                                { label: 'Use hardware acceleration', value: true, type: 'toggle' },
                                { label: 'Continue running apps when browser is closed', value: false, type: 'toggle' }
                            ])}

                            <div style="margin-top: 40px; padding-top: 24px; border-top: 1px solid #e0e0e0;">
                                <button class="btn" onclick="chromiumEngine.loadURL('chrome://flags')" style="padding: 8px 20px;">Advanced Settings (Flags)</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderSettingsSection(title, settings) {
                return `
                    <div style="margin-bottom: 32px;">
                        <h2 style="font-size: 18px; font-weight: 500; color: #202124; margin-bottom: 16px;">${title}</h2>
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 16px;">
                            ${settings.map(setting => this.renderSettingItem(setting)).join('')}
                        </div>
                    </div>
                `;
            }

            renderSettingItem(setting) {
                if (setting.type === 'toggle') {
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid #e0e0e0;">
                            <span style="font-size: 14px; color: #202124;">${setting.label}</span>
                            <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                                <input type="checkbox" ${setting.value ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: ${setting.value ? '#4285F4' : '#ccc'}; border-radius: 24px; transition: 0.3s;"></span>
                                <span style="position: absolute; content: ''; height: 18px; width: 18px; left: ${setting.value ? '23px' : '3px'}; bottom: 3px; background: white; border-radius: 50%; transition: 0.3s;"></span>
                            </label>
                        </div>
                    `;
                } else if (setting.type === 'select') {
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid #e0e0e0;">
                            <span style="font-size: 14px; color: #202124;">${setting.label}</span>
                            <select style="padding: 6px 12px; border: 1px solid #dadce0; border-radius: 4px; background: white; font-size: 13px; cursor: pointer;">
                                ${setting.options.map(opt => `<option ${opt === setting.value ? 'selected' : ''}>${opt}</option>`).join('')}
                            </select>
                        </div>
                    `;
                }
                return '';
            }

            renderHistoryPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px;">
                                <h1 style="font-size: 28px; font-weight: 400; color: #202124;">History</h1>
                                <button class="btn" onclick="chromiumEngine.clearHistory()" style="padding: 8px 20px;">Clear browsing data</button>
                            </div>

                            <div style="margin-bottom: 24px;">
                                <input type="text" placeholder="Search history"
                                    style="width: 100%; padding: 12px 16px; border: 1px solid #dadce0; border-radius: 24px; font-size: 14px;">
                            </div>

                            ${this.history.length === 0 ?
                                '<div style="text-align: center; color: #5f6368; padding: 60px 20px;">No browsing history yet</div>' :
                                this.history.slice().reverse().map(item => `
                                    <div style="padding: 12px 16px; border-bottom: 1px solid #e0e0e0; cursor: pointer; transition: background 0.2s;"
                                        onclick="chromiumEngine.loadURL('${item.url}')"
                                        onmouseover="this.style.background='#f8f9fa'"
                                        onmouseout="this.style.background='white'">
                                        <div style="font-size: 14px; color: #1a73e8; margin-bottom: 4px;">${item.title}</div>
                                        <div style="font-size: 12px; color: #5f6368;">${item.url} • ${new Date(item.timestamp).toLocaleString()}</div>
                                    </div>
                                `).join('')
                            }
                        </div>
                    </div>
                `;
            }

            renderBookmarksPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
                            <h1 style="font-size: 28px; font-weight: 400; color: #202124; margin-bottom: 32px;">Bookmarks</h1>

                            ${this.bookmarks.length === 0 ?
                                '<div style="text-align: center; color: #5f6368; padding: 60px 20px;">No bookmarks yet. Click the star in the address bar to bookmark a page!</div>' :
                                this.bookmarks.map((bookmark, index) => `
                                    <div style="display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-bottom: 1px solid #e0e0e0; transition: background 0.2s;"
                                        onmouseover="this.style.background='#f8f9fa'"
                                        onmouseout="this.style.background='white'">
                                        <div style="font-size: 24px;">${bookmark.favicon || '🌐'}</div>
                                        <div style="flex: 1; cursor: pointer;" onclick="chromiumEngine.loadURL('${bookmark.url}')">
                                            <div style="font-size: 14px; color: #1a73e8; margin-bottom: 4px;">${bookmark.title}</div>
                                            <div style="font-size: 12px; color: #5f6368;">${bookmark.url}</div>
                                        </div>
                                        <button class="btn" onclick="chromiumEngine.removeBookmark(${index})" style="padding: 4px 12px;">Remove</button>
                                    </div>
                                `).join('')
                            }
                        </div>
                    </div>
                `;
            }

            renderDownloadsPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px;">
                                <h1 style="font-size: 28px; font-weight: 400; color: #202124;">Downloads</h1>
                                <button class="btn" onclick="chromiumEngine.clearDownloads()" style="padding: 8px 20px;">Clear all</button>
                            </div>

                            ${this.downloads.length === 0 ?
                                '<div style="text-align: center; color: #5f6368; padding: 60px 20px;">No downloads yet</div>' :
                                this.downloads.map(download => `
                                    <div style="display: flex; align-items: center; gap: 12px; padding: 16px; background: #f8f9fa; border-radius: 8px; margin-bottom: 12px;">
                                        <div style="font-size: 32px;">📄</div>
                                        <div style="flex: 1;">
                                            <div style="font-size: 14px; color: #202124; font-weight: 500; margin-bottom: 4px;">${download.filename}</div>
                                            <div style="font-size: 12px; color: #5f6368;">${download.url} • ${download.size}</div>
                                            <div style="margin-top: 8px; height: 4px; background: #e0e0e0; border-radius: 2px;">
                                                <div style="height: 100%; background: #4285F4; border-radius: 2px; width: ${download.progress}%;"></div>
                                            </div>
                                        </div>
                                        <button class="btn" style="padding: 4px 12px;">${download.progress === 100 ? 'Open' : 'Cancel'}</button>
                                    </div>
                                `).join('')
                            }
                        </div>
                    </div>
                `;
            }

            renderExtensionsPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 900px; margin: 0 auto; padding: 40px;">
                            <h1 style="font-size: 28px; font-weight: 400; color: #202124; margin-bottom: 32px;">Extensions</h1>

                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                                ${this.renderSampleExtensions()}
                            </div>
                        </div>
                    </div>
                `;
            }

            renderSampleExtensions() {
                const sampleExtensions = [
                    { name: 'uBlock Origin', icon: '🛡️', description: 'Free, open-source ad content blocker', enabled: true },
                    { name: 'Dark Reader', icon: '🌙', description: 'Dark mode for every website', enabled: false },
                    { name: 'JSON Formatter', icon: '📋', description: 'Makes JSON easy to read', enabled: true },
                    { name: 'ColorZilla', icon: '🎨', description: 'Advanced Eyedropper & Color Picker', enabled: false }
                ];

                return sampleExtensions.map(ext => `
                    <div style="padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <div style="font-size: 32px;">${ext.icon}</div>
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: 500; color: #202124;">${ext.name}</div>
                            </div>
                            <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                                <input type="checkbox" ${ext.enabled ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: ${ext.enabled ? '#4285F4' : '#ccc'}; border-radius: 24px;"></span>
                                <span style="position: absolute; height: 18px; width: 18px; left: ${ext.enabled ? '23px' : '3px'}; bottom: 3px; background: white; border-radius: 50%;"></span>
                            </label>
                        </div>
                        <p style="font-size: 13px; color: #5f6368; margin-bottom: 12px;">${ext.description}</p>
                        <button class="btn" style="padding: 6px 16px; font-size: 12px;">Details</button>
                    </div>
                `).join('');
            }

            renderFlagsPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
                            <div style="background: #fef7e0; border: 1px solid #f9ab00; border-radius: 8px; padding: 16px; margin-bottom: 32px;">
                                <strong style="color: #ea8600;">⚠️ Warning</strong>
                                <p style="margin-top: 8px; color: #5f6368; font-size: 13px;">These experiments may change, break, or disappear at any time. Use at your own risk.</p>
                            </div>

                            <h1 style="font-size: 28px; font-weight: 400; color: #202124; margin-bottom: 32px;">Experiments</h1>

                            ${this.renderExperimentalFlags()}
                        </div>
                    </div>
                `;
            }

            renderExperimentalFlags() {
                const flags = [
                    { name: 'Smooth Scrolling', description: 'Animate smoothly when scrolling page content', status: 'Enabled' },
                    { name: 'Parallel downloading', description: 'Enable parallel downloading to accelerate download speed', status: 'Default' },
                    { name: 'GPU rasterization', description: 'Use GPU to rasterize web content', status: 'Enabled' },
                    { name: 'Experimental QUIC protocol', description: 'Enable experimental QUIC protocol support', status: 'Default' },
                    { name: 'Tab Hover Cards', description: 'Enables a hover card to appear when hovering over a tab', status: 'Enabled' }
                ];

                return flags.map(flag => `
                    <div style="padding: 20px; background: #f8f9fa; border-radius: 8px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: 500; color: #202124; margin-bottom: 6px;">${flag.name}</div>
                                <div style="font-size: 13px; color: #5f6368;">${flag.description}</div>
                            </div>
                            <select style="padding: 6px 12px; border: 1px solid #dadce0; border-radius: 4px; background: white; font-size: 13px;">
                                <option ${flag.status === 'Default' ? 'selected' : ''}>Default</option>
                                <option ${flag.status === 'Enabled' ? 'selected' : ''}>Enabled</option>
                                <option ${flag.status === 'Disabled' ? 'selected' : ''}>Disabled</option>
                            </select>
                        </div>
                    </div>
                `).join('');
            }

            renderVersionPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 800px; margin: 0 auto; padding: 40px;">
                            <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 32px;">
                                <div style="width: 64px; height: 64px; background: linear-gradient(45deg, #4285F4, #34A853, #FBBC05, #EA4335); border-radius: 50%;"></div>
                                <div>
                                    <h1 style="font-size: 32px; font-weight: 300; color: #202124; margin-bottom: 4px;">Chromium</h1>
                                    <p style="font-size: 14px; color: #5f6368;">Simulated Browser Engine</p>
                                </div>
                            </div>

                            <div style="background: #f8f9fa; border-radius: 8px; padding: 24px; margin-bottom: 24px;">
                                <table style="width: 100%; border-collapse: collapse;">
                                    <tr style="border-bottom: 1px solid #e0e0e0;">
                                        <td style="padding: 12px 0; font-weight: 500; color: #202124;">Version</td>
                                        <td style="padding: 12px 0; color: #5f6368;">95.0.4638.69 (Simulated)</td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid #e0e0e0;">
                                        <td style="padding: 12px 0; font-weight: 500; color: #202124;">JavaScript Engine</td>
                                        <td style="padding: 12px 0; color: #5f6368;">V8 Emulation (Native Browser Engine)</td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid #e0e0e0;">
                                        <td style="padding: 12px 0; font-weight: 500; color: #202124;">Rendering Engine</td>
                                        <td style="padding: 12px 0; color: #5f6368;">Blink Emulation</td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid #e0e0e0;">
                                        <td style="padding: 12px 0; font-weight: 500; color: #202124;">User Agent</td>
                                        <td style="padding: 12px 0; color: #5f6368; font-size: 11px; word-break: break-all;">${navigator.userAgent}</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 12px 0; font-weight: 500; color: #202124;">Platform</td>
                                        <td style="padding: 12px 0; color: #5f6368;">${navigator.platform}</td>
                                    </tr>
                                </table>
                            </div>

                            <div style="text-align: center; padding: 20px;">
                                <p style="font-size: 13px; color: #5f6368; margin-bottom: 12px;">
                                    This is a simulated Chromium browser engine built entirely in JavaScript,<br>
                                    demonstrating browser architecture concepts within the Windows 95 emulator.
                                </p>
                                <button class="btn" onclick="chromiumEngine.loadURL('chrome://internals')" style="padding: 8px 20px;">View Browser Internals</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderInternalsPage() {
                return `
                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; height: 100%; overflow-y: auto; background: white;">
                        <div style="max-width: 1000px; margin: 0 auto; padding: 40px;">
                            <h1 style="font-size: 28px; font-weight: 400; color: #202124; margin-bottom: 32px;">Browser Internals</h1>

                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 32px;">
                                ${this.renderProcessCard('Browser Process', this.processes.browser, '🖥️')}
                                ${this.renderProcessCard('GPU Process', this.processes.gpu, '🎮')}
                                ${this.renderProcessCard('Network Process', this.processes.network, '🌐')}
                            </div>

                            <h2 style="font-size: 20px; font-weight: 500; color: #202124; margin-bottom: 16px;">Renderer Processes (Tabs)</h2>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 32px;">
                                ${Array.from(this.processes.renderer.entries()).map(([tabId, process]) => {
                                    const tab = this.tabs.find(t => t.id === tabId);
                                    return this.renderProcessCard(`Tab: ${tab?.title || 'Unknown'}`, process, '📄');
                                }).join('')}
                            </div>

                            <h2 style="font-size: 20px; font-weight: 500; color: #202124; margin-bottom: 16px;">Performance Metrics</h2>
                            <div style="background: #f8f9fa; border-radius: 8px; padding: 24px;">
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                    ${this.renderMetricCard('FPS', this.performanceMetrics.fps, '🎯')}
                                    ${this.renderMetricCard('Paint Time', this.performanceMetrics.paintTime.toFixed(2) + 'ms', '🎨')}
                                    ${this.renderMetricCard('Layout Time', this.performanceMetrics.layoutTime.toFixed(2) + 'ms', '📐')}
                                    ${this.renderMetricCard('Script Time', this.performanceMetrics.scriptTime.toFixed(2) + 'ms', '⚙️')}
                                </div>
                            </div>

                            <h2 style="font-size: 20px; font-weight: 500; color: #202124; margin: 32px 0 16px;">Network Requests</h2>
                            <div style="background: #f8f9fa; border-radius: 8px; padding: 16px;">
                                ${this.networkRequests.length === 0 ?
                                    '<div style="text-align: center; color: #5f6368; padding: 20px;">No network requests recorded yet</div>' :
                                    this.networkRequests.slice(-10).map(req => `
                                        <div style="padding: 8px; border-bottom: 1px solid #e0e0e0; font-size: 12px;">
                                            <span style="color: ${req.status === 200 ? '#34A853' : '#EA4335'}; font-weight: bold;">${req.status}</span>
                                            <span style="margin-left: 8px; color: #5f6368;">${req.method}</span>
                                            <span style="margin-left: 8px; color: #202124;">${req.url}</span>
                                            <span style="margin-left: 8px; color: #5f6368;">${req.time}ms</span>
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                    </div>
                `;
            }

            renderProcessCard(name, process, icon) {
                return `
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; border: 1px solid #e0e0e0;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <div style="font-size: 32px;">${icon}</div>
                            <div>
                                <div style="font-size: 14px; font-weight: 500; color: #202124;">${name}</div>
                                <div style="font-size: 12px; color: #5f6368;">PID: ${process.pid}</div>
                            </div>
                        </div>
                        <div style="font-size: 12px; color: #5f6368;">
                            <div style="margin-bottom: 4px;">Memory: ${process.memory.toFixed(1)} MB</div>
                            <div>CPU: ${process.cpu.toFixed(1)}%</div>
                        </div>
                    </div>
                `;
            }

            renderMetricCard(label, value, icon) {
                return `
                    <div style="text-align: center;">
                        <div style="font-size: 32px; margin-bottom: 8px;">${icon}</div>
                        <div style="font-size: 24px; font-weight: 500; color: #202124; margin-bottom: 4px;">${value}</div>
                        <div style="font-size: 12px; color: #5f6368;">${label}</div>
                    </div>
                `;
            }

            render404Page() {
                return `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 40px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;">
                        <div style="font-size: 64px; margin-bottom: 20px;">🔍</div>
                        <h2 style="font-size: 24px; font-weight: 500; color: #202124; margin-bottom: 12px;">Page not found</h2>
                        <p style="color: #5f6368;">The page you're looking for doesn't exist.</p>
                    </div>
                `;
            }

            renderTabContent(tab) {
                // This method is called when switching tabs
                // Re-render the current URL
                this.loadURL(tab.url);
            }

            toggleDevTools() {
                this.devToolsOpen = !this.devToolsOpen;

                if (this.devToolsOpen) {
                    this.openDevTools();
                } else {
                    this.closeDevTools();
                }
            }

            openDevTools() {
                const contentArea = document.getElementById('chrome-content-area');
                if (!contentArea) return;

                // Create DevTools panel
                const devToolsPanel = document.createElement('div');
                devToolsPanel.id = 'chrome-devtools';
                devToolsPanel.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 40%;
                    background: #242424;
                    border-top: 1px solid #e0e0e0;
                    display: flex;
                    flex-direction: column;
                    font-family: 'Courier New', monospace;
                    z-index: 1000;
                `;

                // DevTools tabs
                const devToolsTabs = document.createElement('div');
                devToolsTabs.style.cssText = `
                    display: flex;
                    background: #2d2d2d;
                    border-bottom: 1px solid #3e3e3e;
                    padding: 0 8px;
                `;

                const tabs = ['Elements', 'Console', 'Sources', 'Network', 'Performance', 'Application'];
                tabs.forEach(tab => {
                    const tabBtn = document.createElement('button');
                    tabBtn.textContent = tab;
                    tabBtn.style.cssText = `
                        background: none;
                        border: none;
                        color: ${this.devToolsPanel === tab.toLowerCase() ? '#4285F4' : '#999'};
                        padding: 8px 12px;
                        font-size: 12px;
                        cursor: pointer;
                        border-bottom: 2px solid ${this.devToolsPanel === tab.toLowerCase() ? '#4285F4' : 'transparent'};
                    `;
                    tabBtn.onclick = () => this.switchDevToolsPanel(tab.toLowerCase());
                    devToolsTabs.appendChild(tabBtn);
                });

                // DevTools content
                const devToolsContent = document.createElement('div');
                devToolsContent.id = 'chrome-devtools-content';
                devToolsContent.style.cssText = `
                    flex: 1;
                    overflow-y: auto;
                    padding: 8px;
                    color: #ccc;
                    font-size: 12px;
                `;

                devToolsPanel.appendChild(devToolsTabs);
                devToolsPanel.appendChild(devToolsContent);
                contentArea.appendChild(devToolsPanel);

                this.renderDevToolsPanel();
            }

            closeDevTools() {
                const devTools = document.getElementById('chrome-devtools');
                if (devTools) devTools.remove();
            }

            switchDevToolsPanel(panel) {
                this.devToolsPanel = panel;

                // Update tab styles
                const tabs = document.querySelectorAll('#chrome-devtools button');
                tabs.forEach((tab, index) => {
                    const panels = ['elements', 'console', 'sources', 'network', 'performance', 'application'];
                    if (panels[index] === panel) {
                        tab.style.color = '#4285F4';
                        tab.style.borderBottom = '2px solid #4285F4';
                    } else {
                        tab.style.color = '#999';
                        tab.style.borderBottom = '2px solid transparent';
                    }
                });

                this.renderDevToolsPanel();
            }

            renderDevToolsPanel() {
                const content = document.getElementById('chrome-devtools-content');
                if (!content) return;

                switch (this.devToolsPanel) {
                    case 'elements':
                        content.innerHTML = this.renderElementsPanel();
                        break;
                    case 'console':
                        content.innerHTML = this.renderConsolePanel();
                        break;
                    case 'sources':
                        content.innerHTML = this.renderSourcesPanel();
                        break;
                    case 'network':
                        content.innerHTML = this.renderNetworkPanel();
                        break;
                    case 'performance':
                        content.innerHTML = this.renderPerformancePanel();
                        break;
                    case 'application':
                        content.innerHTML = this.renderApplicationPanel();
                        break;
                }
            }

            renderElementsPanel() {
                return `
                    <div style="color: #ccc;">
                        <div style="margin-bottom: 8px; color: #999;">▼ <span style="color: #4285F4;">&lt;html&gt;</span></div>
                        <div style="margin-left: 20px;">
                            <div style="margin-bottom: 8px; color: #999;">▼ <span style="color: #4285F4;">&lt;head&gt;</span></div>
                            <div style="margin-left: 20px; color: #888;">...</div>
                            <div style="margin-bottom: 8px; color: #999;"><span style="color: #4285F4;">&lt;/head&gt;</span></div>

                            <div style="margin-bottom: 8px; color: #999;">▼ <span style="color: #4285F4;">&lt;body&gt;</span></div>
                            <div style="margin-left: 20px;">
                                <div style="padding: 4px 8px; background: #3e3e3e; border-left: 2px solid #4285F4; margin-bottom: 4px;">
                                    <span style="color: #4285F4;">&lt;div</span>
                                    <span style="color: #999;"> class=</span>
                                    <span style="color: #a5d6a7;">"content"</span>
                                    <span style="color: #4285F4;">&gt;</span>
                                </div>
                                <div style="margin-left: 20px; color: #888;">Page content...</div>
                                <div style="padding: 4px 8px;"><span style="color: #4285F4;">&lt;/div&gt;</span></div>
                            </div>
                            <div style="margin-bottom: 8px; color: #999;"><span style="color: #4285F4;">&lt;/body&gt;</span></div>
                        </div>
                        <div style="margin-bottom: 8px; color: #999;"><span style="color: #4285F4;">&lt;/html&gt;</span></div>
                    </div>
                `;
            }

            renderConsolePanel() {
                const consoleOutput = this.consoleHistory.length > 0 ?
                    this.consoleHistory.map(log => `<div style="margin-bottom: 8px; padding: 4px; border-bottom: 1px solid #3e3e3e;">
                        <span style="color: ${log.type === 'error' ? '#f48fb1' : log.type === 'warn' ? '#ffb74d' : '#4285F4'};">${log.type}:</span>
                        <span style="margin-left: 8px;">${log.message}</span>
                    </div>`).join('') :
                    '<div style="color: #888;">Console is empty. Run JavaScript commands to see output.</div>';

                return `
                    <div style="display: flex; flex-direction: column; height: 100%;">
                        <div style="flex: 1; overflow-y: auto; margin-bottom: 8px;">
                            ${consoleOutput}
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: #2d2d2d; border-top: 1px solid #3e3e3e;">
                            <span style="color: #4285F4;">&gt;</span>
                            <input type="text" id="console-input" placeholder="Execute JavaScript..."
                                style="flex: 1; background: transparent; border: none; color: #ccc; outline: none; font-family: 'Courier New', monospace; font-size: 12px;"
                                onkeypress="if(event.key==='Enter') chromiumEngine.executeConsoleCommand(this.value)">
                        </div>
                    </div>
                `;
            }

            renderSourcesPanel() {
                return `
                    <div style="color: #ccc;">
                        <div style="margin-bottom: 12px; color: #999;">📁 Page Resources</div>
                        <div style="margin-left: 20px;">
                            <div style="margin-bottom: 8px; cursor: pointer;" onclick="chromiumEngine.showSource('index.html')">
                                📄 index.html
                            </div>
                            <div style="margin-bottom: 8px; cursor: pointer;" onclick="chromiumEngine.showSource('styles.css')">
                                🎨 styles.css
                            </div>
                            <div style="margin-bottom: 8px; cursor: pointer;" onclick="chromiumEngine.showSource('script.js')">
                                ⚙️ script.js
                            </div>
                        </div>
                        <div style="margin-top: 20px; padding: 12px; background: #2d2d2d; border-radius: 4px;">
                            <div style="margin-bottom: 8px; color: #999;">// Click a file to view source</div>
                            <div style="color: #888;">No file selected</div>
                        </div>
                    </div>
                `;
            }

            renderNetworkPanel() {
                if (this.networkRequests.length === 0) {
                    return '<div style="color: #888; text-align: center; padding: 40px;">No network activity recorded yet. Navigate to a page to see network requests.</div>';
                }

                return `
                    <div style="color: #ccc;">
                        <div style="display: flex; font-weight: bold; padding: 8px; background: #2d2d2d; border-bottom: 1px solid #3e3e3e;">
                            <div style="flex: 0 0 60px;">Status</div>
                            <div style="flex: 0 0 80px;">Method</div>
                            <div style="flex: 1;">URL</div>
                            <div style="flex: 0 0 80px;">Time</div>
                            <div style="flex: 0 0 80px;">Size</div>
                        </div>
                        ${this.networkRequests.map(req => `
                            <div style="display: flex; padding: 8px; border-bottom: 1px solid #3e3e3e; font-size: 11px;">
                                <div style="flex: 0 0 60px; color: ${req.status === 200 ? '#4caf50' : '#f44336'};">${req.status}</div>
                                <div style="flex: 0 0 80px; color: #4285F4;">${req.method}</div>
                                <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${req.url}</div>
                                <div style="flex: 0 0 80px; color: #999;">${req.time}ms</div>
                                <div style="flex: 0 0 80px; color: #999;">${req.size || 'N/A'}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            renderPerformancePanel() {
                return `
                    <div style="color: #ccc;">
                        <div style="margin-bottom: 16px;">
                            <button class="btn" onclick="chromiumEngine.startPerformanceRecording()" style="margin-right: 8px;">⏺ Record</button>
                            <button class="btn" onclick="chromiumEngine.clearPerformanceData()">🗑️ Clear</button>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #4285F4; margin-bottom: 12px;">Current Metrics</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                                <div style="background: #2d2d2d; padding: 12px; border-radius: 4px;">
                                    <div style="color: #999; font-size: 11px; margin-bottom: 4px;">FPS</div>
                                    <div style="font-size: 20px; font-weight: bold; color: #4caf50;">${this.performanceMetrics.fps}</div>
                                </div>
                                <div style="background: #2d2d2d; padding: 12px; border-radius: 4px;">
                                    <div style="color: #999; font-size: 11px; margin-bottom: 4px;">Paint Time</div>
                                    <div style="font-size: 20px; font-weight: bold; color: #4285F4;">${this.performanceMetrics.paintTime.toFixed(2)}ms</div>
                                </div>
                                <div style="background: #2d2d2d; padding: 12px; border-radius: 4px;">
                                    <div style="color: #999; font-size: 11px; margin-bottom: 4px;">Layout Time</div>
                                    <div style="font-size: 20px; font-weight: bold; color: #ff9800;">${this.performanceMetrics.layoutTime.toFixed(2)}ms</div>
                                </div>
                                <div style="background: #2d2d2d; padding: 12px; border-radius: 4px;">
                                    <div style="color: #999; font-size: 11px; margin-bottom: 4px;">Script Time</div>
                                    <div style="font-size: 20px; font-weight: bold; color: #9c27b0;">${this.performanceMetrics.scriptTime.toFixed(2)}ms</div>
                                </div>
                            </div>
                        </div>

                        <div>
                            <h3 style="color: #4285F4; margin-bottom: 12px;">Timeline</h3>
                            <div style="background: #2d2d2d; padding: 20px; border-radius: 4px; text-align: center; color: #888;">
                                Click Record to capture performance timeline
                            </div>
                        </div>
                    </div>
                `;
            }

            renderApplicationPanel() {
                const localStorage = this.getLocalStorageInfo();
                const sessionStorage = this.getSessionStorageInfo();

                return `
                    <div style="color: #ccc;">
                        <h3 style="color: #4285F4; margin-bottom: 16px;">Storage</h3>

                        <div style="margin-bottom: 20px;">
                            <div style="font-weight: bold; margin-bottom: 8px;">Local Storage</div>
                            <div style="background: #2d2d2d; padding: 12px; border-radius: 4px;">
                                ${localStorage.length > 0 ?
                                    localStorage.map(item => `
                                        <div style="padding: 4px 0; border-bottom: 1px solid #3e3e3e; font-size: 11px;">
                                            <span style="color: #4285F4;">${item.key}</span>:
                                            <span style="color: #ccc;">${item.value}</span>
                                        </div>
                                    `).join('') :
                                    '<div style="color: #888;">No data in Local Storage</div>'
                                }
                            </div>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <div style="font-weight: bold; margin-bottom: 8px;">Session Storage</div>
                            <div style="background: #2d2d2d; padding: 12px; border-radius: 4px;">
                                ${sessionStorage.length > 0 ?
                                    sessionStorage.map(item => `
                                        <div style="padding: 4px 0; border-bottom: 1px solid #3e3e3e; font-size: 11px;">
                                            <span style="color: #4285F4;">${item.key}</span>:
                                            <span style="color: #ccc;">${item.value}</span>
                                        </div>
                                    `).join('') :
                                    '<div style="color: #888;">No data in Session Storage</div>'
                                }
                            </div>
                        </div>

                        <div>
                            <div style="font-weight: bold; margin-bottom: 8px;">Cookies</div>
                            <div style="background: #2d2d2d; padding: 12px; border-radius: 4px; color: #888;">
                                ${document.cookie || 'No cookies found'}
                            </div>
                        </div>
                    </div>
                `;
            }

            getLocalStorageInfo() {
                const items = [];
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        items.push({ key, value: value.substring(0, 100) + (value.length > 100 ? '...' : '') });
                    }
                } catch (e) {
                    // Handle storage access errors
                }
                return items;
            }

            getSessionStorageInfo() {
                const items = [];
                try {
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        const value = sessionStorage.getItem(key);
                        items.push({ key, value: value.substring(0, 100) + (value.length > 100 ? '...' : '') });
                    }
                } catch (e) {
                    // Handle storage access errors
                }
                return items;
            }

            executeConsoleCommand(command) {
                if (!command.trim()) return;

                try {
                    const result = eval(command);
                    this.consoleHistory.push({
                        type: 'log',
                        message: `> ${command}\n${result !== undefined ? result : ''}`
                    });
                } catch (error) {
                    this.consoleHistory.push({
                        type: 'error',
                        message: `> ${command}\nError: ${error.message}`
                    });
                }

                // Clear input
                const input = document.getElementById('console-input');
                if (input) input.value = '';

                // Re-render console
                this.renderDevToolsPanel();
            }

            toggleBookmark() {
                if (!this.activeTab) return;

                const existingIndex = this.bookmarks.findIndex(b => b.url === this.activeTab.url);

                if (existingIndex >= 0) {
                    // Remove bookmark
                    this.bookmarks.splice(existingIndex, 1);
                    this.emulator.showToast('Bookmark Removed', `Removed ${this.activeTab.title}`);
                } else {
                    // Add bookmark
                    this.bookmarks.push({
                        title: this.activeTab.title,
                        url: this.activeTab.url,
                        favicon: this.activeTab.favicon,
                        timestamp: Date.now()
                    });
                    this.emulator.showToast('Bookmarked', `Added ${this.activeTab.title} to bookmarks`);
                }

                this.saveBookmarks();
            }

            removeBookmark(index) {
                this.bookmarks.splice(index, 1);
                this.saveBookmarks();
                this.loadURL('chrome://bookmarks'); // Refresh page
            }

            loadBookmarks() {
                try {
                    const saved = localStorage.getItem('chromium-bookmarks');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) {
                    return [];
                }
            }

            saveBookmarks() {
                try {
                    localStorage.setItem('chromium-bookmarks', JSON.stringify(this.bookmarks));
                } catch (e) {
                    console.error('Failed to save bookmarks:', e);
                }
            }

            clearHistory() {
                this.history = [];
                this.emulator.showToast('History Cleared', 'All browsing history has been removed');
                this.loadURL('chrome://history');
            }

            clearDownloads() {
                this.downloads = [];
                this.loadURL('chrome://downloads');
            }

            setupNetworkInterception() {
                // Intercept fetch requests
                const originalFetch = window.fetch;
                const self = this;

                window.fetch = function(...args) {
                    const startTime = performance.now();
                    const url = args[0];
                    const options = args[1] || {};

                    return originalFetch.apply(this, args).then(response => {
                        const endTime = performance.now();

                        self.networkRequests.push({
                            url: url,
                            method: options.method || 'GET',
                            status: response.status,
                            time: (endTime - startTime).toFixed(2),
                            size: response.headers.get('content-length') || 'unknown',
                            timestamp: new Date().toISOString()
                        });

                        return response;
                    });
                };
            }

            loadExtensions() {
                // Simulated extensions - in a real implementation, these would load from storage
                this.extensions = [];
            }

            startPerformanceMonitoring() {
                // Simulate performance metrics updates
                setInterval(() => {
                    this.performanceMetrics.fps = 60 + Math.random() * 5 - 2.5;
                    this.performanceMetrics.paintTime = Math.random() * 2 + 1;
                    this.performanceMetrics.layoutTime = Math.random() * 1.5 + 0.5;
                    this.performanceMetrics.scriptTime = Math.random() * 3 + 0.5;

                    // Update process memory/CPU
                    this.processes.browser.memory = 50 + Math.random() * 10;
                    this.processes.browser.cpu = Math.random() * 15;
                    this.processes.gpu.memory = 100 + Math.random() * 20;
                    this.processes.gpu.cpu = Math.random() * 25;
                    this.processes.network.memory = 20 + Math.random() * 5;
                    this.processes.network.cpu = Math.random() * 10;

                    this.processes.renderer.forEach(process => {
                        process.cpu = Math.random() * 30;
                        process.memory = process.memory + (Math.random() - 0.5) * 2;
                    });

                    // Update status bar
                    this.updateStatusBar();
                }, 1000);
            }

            updateStatusBar() {
                const processCount = document.getElementById('chrome-process-count');
                const memory = document.getElementById('chrome-memory');
                const fps = document.getElementById('chrome-fps');

                if (processCount) {
                    processCount.textContent = 3 + this.processes.renderer.size;
                }

                if (memory) {
                    const totalMemory = this.processes.browser.memory +
                                      this.processes.gpu.memory +
                                      this.processes.network.memory +
                                      Array.from(this.processes.renderer.values()).reduce((sum, p) => sum + p.memory, 0);
                    memory.textContent = totalMemory.toFixed(0);
                }

                if (fps) {
                    fps.textContent = Math.round(this.performanceMetrics.fps);
                }
            }

            openSettings() {
                this.loadURL('chrome://settings');
            }

            openExtensions() {
                this.loadURL('chrome://extensions');
            }

            openMenu() {
                // Show Chrome menu
                this.emulator.showToast('Menu', 'Chrome menu would appear here');
            }

            showOmniboxSuggestions() {
                // Show suggestions when omnibox is focused
                // In a full implementation, this would show search history and bookmarks
            }

            updateOmniboxSuggestions() {
                // Update suggestions as user types
            }

            startPerformanceRecording() {
                this.emulator.showToast('Performance', 'Recording started...');
            }

            clearPerformanceData() {
                this.emulator.showToast('Performance', 'Performance data cleared');
            }

            showSource(filename) {
                this.emulator.showToast('Sources', `Viewing ${filename}`);
            }
        }

        // Make ChromiumEngine accessible globally for onclick handlers
        let chromiumEngine;

        class Windows95Emulator {
            constructor() {
                this.v86 = null;
                this.isRunning = false;
                this.isPaused = false;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.lastFrameTime = 0;
                this.hddLedTimeout = null;
                this.canvas = null;
                this.ctx = null;
                this.domCache = null;
                this.memoryUsage = 0;
                this.cpuUsage = 0;

                this.settings = {
                    memory: 32 * 1024 * 1024,
                    enableMouse: false,
                    enableSound: false,
                    enableNetwork: true,
                    cpuSpeed: 2
                };

                this.desktop = {
                    icons: [],
                    windows: []
                };

                this.windowManager = new WindowManager(this);
                this.taskbarButtons = [];

                // WAVE 4 ENHANCEMENT #2: Clipboard System
                this.clipboard = {
                    items: [],
                    operation: null, // 'copy' or 'cut'
                    source: null // source path for file operations
                };

                this.initEmulatorCore();
                this.detectSystemInfo();
                this.initAudioContext();
            }

            // Audio system for games
            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.audioContext = null;
                }

                // Initialize sound settings
                this.soundMuted = SafeStorage.getItem('win95-sound-muted') === 'true' || false;
                this.soundVolume = parseInt(SafeStorage.getItem('win95-sound-volume') || '50');
            }

            playSoundEffect(type) {
                if (!this.audioContext) return;

                const ctx = this.audioContext;
                const now = ctx.currentTime;

                switch(type) {
                    case 'flip':
                    case 'deal':
                        // Quick click sound
                        const flipOsc = ctx.createOscillator();
                        const flipGain = ctx.createGain();
                        flipOsc.connect(flipGain);
                        flipGain.connect(ctx.destination);
                        flipOsc.frequency.setValueAtTime(800, now);
                        flipOsc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                        flipGain.gain.setValueAtTime(0.1, now);
                        flipGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        flipOsc.start(now);
                        flipOsc.stop(now + 0.05);
                        break;

                    case 'place':
                        // Satisfying placement sound
                        const placeOsc = ctx.createOscillator();
                        const placeGain = ctx.createGain();
                        placeOsc.connect(placeGain);
                        placeGain.connect(ctx.destination);
                        placeOsc.frequency.setValueAtTime(400, now);
                        placeOsc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                        placeGain.gain.setValueAtTime(0.15, now);
                        placeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        placeOsc.start(now);
                        placeOsc.stop(now + 0.1);
                        break;

                    case 'invalid':
                        // Error buzz
                        const errOsc = ctx.createOscillator();
                        const errGain = ctx.createGain();
                        errOsc.connect(errGain);
                        errGain.connect(ctx.destination);
                        errOsc.type = 'square';
                        errOsc.frequency.setValueAtTime(150, now);
                        errGain.gain.setValueAtTime(0.08, now);
                        errGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        errOsc.start(now);
                        errOsc.stop(now + 0.1);
                        break;

                    case 'win':
                        // Victory fanfare
                        const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C
                        notes.forEach((freq, i) => {
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();
                            osc.connect(gain);
                            gain.connect(ctx.destination);
                            osc.frequency.setValueAtTime(freq, now + i * 0.15);
                            gain.gain.setValueAtTime(0.1, now + i * 0.15);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.3);
                            osc.start(now + i * 0.15);
                            osc.stop(now + i * 0.15 + 0.3);
                        });
                        break;

                    case 'window-open':
                        // Window opening sound - ascending chirp
                        const openOsc = ctx.createOscillator();
                        const openGain = ctx.createGain();
                        openOsc.connect(openGain);
                        openGain.connect(ctx.destination);
                        openOsc.frequency.setValueAtTime(400, now);
                        openOsc.frequency.exponentialRampToValueAtTime(800, now + 0.08);
                        openGain.gain.setValueAtTime(0.08, now);
                        openGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        openOsc.start(now);
                        openOsc.stop(now + 0.08);
                        break;

                    case 'window-close':
                        // Window closing sound - descending chirp
                        const closeOsc = ctx.createOscillator();
                        const closeGain = ctx.createGain();
                        closeOsc.connect(closeGain);
                        closeGain.connect(ctx.destination);
                        closeOsc.frequency.setValueAtTime(800, now);
                        closeOsc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
                        closeGain.gain.setValueAtTime(0.08, now);
                        closeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        closeOsc.start(now);
                        closeOsc.stop(now + 0.08);
                        break;

                    case 'button-click':
                        // Button click sound - short tap
                        const btnOsc = ctx.createOscillator();
                        const btnGain = ctx.createGain();
                        btnOsc.connect(btnGain);
                        btnGain.connect(ctx.destination);
                        btnOsc.type = 'sine';
                        btnOsc.frequency.setValueAtTime(600, now);
                        btnGain.gain.setValueAtTime(0.05, now);
                        btnGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                        btnOsc.start(now);
                        btnOsc.stop(now + 0.03);
                        break;

                    case 'minimize':
                        // Minimize sound - quick descending tone
                        const minOsc = ctx.createOscillator();
                        const minGain = ctx.createGain();
                        minOsc.connect(minGain);
                        minGain.connect(ctx.destination);
                        minOsc.frequency.setValueAtTime(700, now);
                        minOsc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                        minGain.gain.setValueAtTime(0.07, now);
                        minGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        minOsc.start(now);
                        minOsc.stop(now + 0.1);
                        break;

                    case 'maximize':
                        // Maximize sound - expanding tone
                        const maxOsc = ctx.createOscillator();
                        const maxGain = ctx.createGain();
                        maxOsc.connect(maxGain);
                        maxGain.connect(ctx.destination);
                        maxOsc.frequency.setValueAtTime(500, now);
                        maxOsc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
                        maxGain.gain.setValueAtTime(0.07, now);
                        maxGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        maxOsc.start(now);
                        maxOsc.stop(now + 0.1);
                        break;

                    case 'start-menu':
                        // Start menu sound - pleasant two-tone
                        const sm1 = ctx.createOscillator();
                        const sm2 = ctx.createOscillator();
                        const smGain = ctx.createGain();
                        sm1.connect(smGain);
                        sm2.connect(smGain);
                        smGain.connect(ctx.destination);
                        sm1.frequency.setValueAtTime(600, now);
                        sm2.frequency.setValueAtTime(800, now + 0.05);
                        smGain.gain.setValueAtTime(0.06, now);
                        smGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                        sm1.start(now);
                        sm1.stop(now + 0.06);
                        sm2.start(now + 0.05);
                        sm2.stop(now + 0.12);
                        break;
                }

                // Apply mute setting
                if (this.soundMuted) return;
            }

            toggleMute() {
                this.soundMuted = !this.soundMuted;
                SafeStorage.setItem('win95-sound-muted', this.soundMuted.toString());
                this.drawSystemTray();
                if (window.toastManager) {
                    window.toastManager.show('Sound', this.soundMuted ? '🔇 Muted' : '🔊 Unmuted');
                }
            }

            setVolume(volume) {
                this.soundVolume = Math.max(0, Math.min(100, volume));
                SafeStorage.setItem('win95-sound-volume', this.soundVolume.toString());
            }

            showVolumeControl() {
                // Create volume control popup
                const existing = document.getElementById('volume-control-popup');
                if (existing) {
                    existing.remove();
                    return; // Toggle off
                }

                const popup = document.createElement('div');
                popup.id = 'volume-control-popup';
                popup.style.cssText = `
                    position: fixed;
                    bottom: 50px;
                    right: 20px;
                    width: 50px;
                    height: 150px;
                    background: var(--button-face);
                    border: 2px outset;
                    box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                    padding: 10px;
                    z-index: 10000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 8px;
                `;

                const muteBtn = document.createElement('button');
                muteBtn.className = 'btn';
                muteBtn.textContent = this.soundMuted ? '🔇' : '🔊';
                muteBtn.style.cssText = 'width: 35px; padding: 4px;';
                muteBtn.onclick = () => {
                    this.toggleMute();
                    muteBtn.textContent = this.soundMuted ? '🔇' : '🔊';
                };

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = '0';
                slider.max = '100';
                slider.value = this.soundVolume.toString();
                slider.orient = 'vertical';
                slider.style.cssText = 'writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 30px; height: 100px;';
                slider.oninput = (e) => {
                    this.setVolume(parseInt(e.target.value));
                    volumeLabel.textContent = this.soundVolume + '%';
                };

                const volumeLabel = document.createElement('div');
                volumeLabel.style.cssText = 'font-size: 9px; text-align: center;';
                volumeLabel.textContent = this.soundVolume + '%';

                popup.appendChild(muteBtn);
                popup.appendChild(slider);
                popup.appendChild(volumeLabel);
                document.body.appendChild(popup);

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', function closeVolume(e) {
                        if (!popup.contains(e.target)) {
                            popup.remove();
                            document.removeEventListener('click', closeVolume);
                        }
                    });
                }, 100);
            }

            showClockInfo() {
                // Create clock info popup
                const existing = document.getElementById('clock-info-popup');
                if (existing) {
                    existing.remove();
                    return; // Toggle off
                }

                const now = new Date();
                const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit' };

                const popup = document.createElement('div');
                popup.id = 'clock-info-popup';
                popup.style.cssText = `
                    position: fixed;
                    bottom: 50px;
                    right: 10px;
                    min-width: 200px;
                    background: var(--button-face);
                    border: 2px outset;
                    box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                    padding: 12px;
                    z-index: 10000;
                    font-size: 11px;
                `;

                popup.innerHTML = `
                    <div style="margin-bottom: 8px; font-weight: bold; text-align: center; border-bottom: 1px solid #808080; padding-bottom: 4px;">
                        🕐 Date & Time
                    </div>
                    <div style="margin-bottom: 6px;">
                        <strong>Date:</strong><br>
                        ${now.toLocaleDateString('en-US', dateOptions)}
                    </div>
                    <div style="margin-bottom: 6px;">
                        <strong>Time:</strong><br>
                        ${now.toLocaleTimeString('en-US', timeOptions)}
                    </div>
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #808080; font-size: 9px; color: #808080;">
                        Click to close
                    </div>
                `;

                document.body.appendChild(popup);

                // Update time every second while open
                const updateInterval = setInterval(() => {
                    if (!document.getElementById('clock-info-popup')) {
                        clearInterval(updateInterval);
                        return;
                    }
                    const now = new Date();
                    popup.innerHTML = `
                        <div style="margin-bottom: 8px; font-weight: bold; text-align: center; border-bottom: 1px solid #808080; padding-bottom: 4px;">
                            🕐 Date & Time
                        </div>
                        <div style="margin-bottom: 6px;">
                            <strong>Date:</strong><br>
                            ${now.toLocaleDateString('en-US', dateOptions)}
                        </div>
                        <div style="margin-bottom: 6px;">
                            <strong>Time:</strong><br>
                            ${now.toLocaleTimeString('en-US', timeOptions)}
                        </div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #808080; font-size: 9px; color: #808080;">
                            Click to close
                        </div>
                    `;
                }, 1000);

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', function closeClock(e) {
                        if (!popup.contains(e.target)) {
                            popup.remove();
                            clearInterval(updateInterval);
                            document.removeEventListener('click', closeClock);
                        }
                    });
                }, 100);
            }

            // Programs
            openNotepad() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%;';

                // Menu bar
                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; flex-wrap: wrap;';
                menuBar.innerHTML = `
                    <button class="btn" onclick="emulator.notepadNew()">New</button>
                    <button class="btn" onclick="emulator.notepadSave()">Save</button>
                    <button class="btn" onclick="emulator.notepadLoad()">Load</button>
                    <button class="btn" onclick="emulator.notepadDownload()">Download</button>
                    <button class="btn" onclick="emulator.notepadUpload()">Upload File</button>
                    <div style="width: 1px; background: #808080; margin: 0 4px;"></div>
                    <button class="btn" onclick="emulator.notepadFind()" title="Find (Ctrl+F)">Find</button>
                    <button class="btn" onclick="emulator.notepadReplace()" title="Replace (Ctrl+H)">Replace</button>
                    <button class="btn" onclick="emulator.notepadWordWrap()" id="notepad-wordwrap-btn" title="Toggle Word Wrap">Word Wrap: OFF</button>
                `;

                // Textarea
                const textarea = document.createElement('textarea');
                textarea.id = 'notepad-textarea';
                textarea.style.cssText = 'flex: 1; border: none; font-family: "Courier New", monospace; font-size: 12px; padding: 4px; resize: none; outline: none; width: 100%; box-sizing: border-box;';

                // Load autosaved content
                const autosaved = SafeStorage.getItem('notepad-autosave');
                if (autosaved) {
                    textarea.value = autosaved;
                }

                // Autosave on input
                textarea.addEventListener('input', () => {
                    SafeStorage.setItem('notepad-autosave', textarea.value);
                });

                // File input (hidden)
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.txt';
                fileInput.style.display = 'none';
                fileInput.id = 'notepad-file-input';
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            textarea.value = event.target.result;
                            SafeStorage.setItem('notepad-autosave', textarea.value);
                        };
                        reader.readAsText(file);
                    }
                });

                content.appendChild(menuBar);
                content.appendChild(textarea);
                content.appendChild(fileInput);

                this.notepadState = { currentFile: 'Untitled' };
                this.windowManager.createWindow('Untitled - Notepad', content, { width: 500, height: 400 });
            }

            notepadNew() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    if (textarea.value) {
                        window.dialogManager.confirm(
                            'Clear current document? Any unsaved changes will be lost.',
                            'Notepad',
                            (button) => {
                                if (button === 'Yes') {
                                    textarea.value = '';
                                    SafeStorage.setItem('notepad-autosave', '');
                                    this.notepadState.currentFile = null;
                                }
                            }
                        );
                        return;
                    }
                    textarea.value = '';
                    SafeStorage.setItem('notepad-autosave', '');
                    this.notepadState.currentFile = 'Untitled';
                }
            }

            notepadSave() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const filename = prompt('Enter filename:', this.notepadState?.currentFile || 'document');
                    if (filename) {
                        SafeStorage.setItem('notepad-file-' + filename, textarea.value);
                        this.notepadState.currentFile = filename;
                        window.dialogManager.info(`Saved as: ${filename}`, 'Notepad');
                    }
                }
            }

            notepadLoad() {
                const filename = prompt('Enter filename to load:');
                if (filename) {
                    const content = SafeStorage.getItem('notepad-file-' + filename);
                    if (content !== null) {
                        const textarea = document.getElementById('notepad-textarea');
                        if (textarea) {
                            textarea.value = content;
                            SafeStorage.setItem('notepad-autosave', content);
                            this.notepadState.currentFile = filename;
                            window.dialogManager.info(`Loaded: ${filename}`, 'Notepad');
                        }
                    } else {
                        window.dialogManager.error(`File not found: ${filename}`, 'Notepad');
                    }
                }
            }

            notepadDownload() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const blob = new Blob([textarea.value], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (this.notepadState?.currentFile || 'document') + '.txt';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }

            notepadUpload() {
                const fileInput = document.getElementById('notepad-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            notepadFind() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const searchTerm = prompt('Find what:');
                    if (searchTerm) {
                        const text = textarea.value;
                        const index = text.indexOf(searchTerm);
                        if (index !== -1) {
                            textarea.focus();
                            textarea.setSelectionRange(index, index + searchTerm.length);
                            textarea.scrollTop = 0; // Reset scroll to show selection
                        } else {
                            window.dialogManager.info(`Cannot find "${searchTerm}"`, 'Find');
                        }
                    }
                }
            }

            notepadReplace() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const searchTerm = prompt('Find what:');
                    if (searchTerm) {
                        const replaceTerm = prompt('Replace with:');
                        if (replaceTerm !== null) {
                            window.dialogManager.confirm(
                                'Replace all occurrences?\n\nYes = Replace All\nNo = Replace First Only',
                                'Replace',
                                (button) => {
                                    if (button === 'Yes') {
                                        // Replace all
                                        const regex = new RegExp(searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                                        textarea.value = textarea.value.replace(regex, replaceTerm);
                                    } else if (button === 'No') {
                                        // Replace first occurrence
                                        textarea.value = textarea.value.replace(searchTerm, replaceTerm);
                                    }
                                    SafeStorage.setItem('notepad-autosave', textarea.value);
                                }
                            );
                        }
                    }
                }
            }

            notepadWordWrap() {
                const textarea = document.getElementById('notepad-textarea');
                const btn = document.getElementById('notepad-wordwrap-btn');
                if (textarea && btn) {
                    const currentWrap = textarea.style.whiteSpace !== 'pre';
                    if (currentWrap) {
                        // Turn OFF word wrap
                        textarea.style.whiteSpace = 'pre';
                        textarea.style.overflowX = 'auto';
                        btn.textContent = 'Word Wrap: OFF';
                    } else {
                        // Turn ON word wrap
                        textarea.style.whiteSpace = 'pre-wrap';
                        textarea.style.overflowX = 'hidden';
                        btn.textContent = 'Word Wrap: ON';
                    }
                }
            }

            openCalculator() {
                const content = document.createElement('div');
                content.innerHTML = `
                    <div style="padding: 10px;">
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                            <button class="btn" onclick="emulator.toggleCalcMode()" id="calc-mode-btn" style="font-size: 9px;">Scientific</button>
                            <input type="text" id="calc-display" readonly style="flex: 1; text-align: right; font-size: 18px; padding: 5px; border: 2px inset; background: white;" value="0">
                        </div>
                        <div id="calc-scientific" style="display: none; margin-bottom: 8px;">
                            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px; margin-bottom: 4px;">
                                <button class="btn" onclick="emulator.calcFunction('Math.sqrt')" title="Square root">√</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.pow', 2)" title="Square">x²</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.pow', 3)" title="Cube">x³</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.sin')" title="Sine">sin</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.cos')" title="Cosine">cos</button>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px;">
                                <button class="btn" onclick="emulator.calcFunction('Math.tan')" title="Tangent">tan</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.log10')" title="Logarithm base 10">log</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.log')" title="Natural logarithm">ln</button>
                                <button class="btn" onclick="emulator.calcConstant('Math.PI')" title="Pi">π</button>
                                <button class="btn" onclick="emulator.calcConstant('Math.E')" title="Euler's number">e</button>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                            <button class="btn" onclick="emulator.calcInput('7')">7</button>
                            <button class="btn" onclick="emulator.calcInput('8')">8</button>
                            <button class="btn" onclick="emulator.calcInput('9')">9</button>
                            <button class="btn" onclick="emulator.calcInput('/')">/</button>
                            <button class="btn" onclick="emulator.calcInput('4')">4</button>
                            <button class="btn" onclick="emulator.calcInput('5')">5</button>
                            <button class="btn" onclick="emulator.calcInput('6')">6</button>
                            <button class="btn" onclick="emulator.calcInput('*')">*</button>
                            <button class="btn" onclick="emulator.calcInput('1')">1</button>
                            <button class="btn" onclick="emulator.calcInput('2')">2</button>
                            <button class="btn" onclick="emulator.calcInput('3')">3</button>
                            <button class="btn" onclick="emulator.calcInput('-')">-</button>
                            <button class="btn" onclick="emulator.calcInput('0')" style="grid-column: span 2;">0</button>
                            <button class="btn" onclick="emulator.calcInput('.')">.</button>
                            <button class="btn" onclick="emulator.calcInput('+')">+</button>
                            <button class="btn" onclick="emulator.calcBackspace()" title="Backspace">←</button>
                            <button class="btn" onclick="emulator.calcInput('(')">(</button>
                            <button class="btn" onclick="emulator.calcInput(')')">)</button>
                            <button class="btn primary" onclick="emulator.calcEquals()">=</button>
                            <button class="btn" onclick="emulator.calcClear()" style="grid-column: span 4;">C</button>
                        </div>
                    </div>
                `;
                this.windowManager.createWindow('Calculator', content, { width: 280, height: 420 });
                this.calcExpression = '';
                this.calcScientificMode = false;
            }

            calcInput(value) {
                const display = document.getElementById('calc-display');
                if (display) {
                    if (this.calcExpression === '' || this.calcExpression === '0') {
                        this.calcExpression = value;
                    } else {
                        this.calcExpression += value;
                    }
                    display.value = this.calcExpression;
                }
            }

            calcEquals() {
                const display = document.getElementById('calc-display');
                if (display && this.calcExpression) {
                    try {
                        const result = eval(this.calcExpression);
                        display.value = result;
                        this.calcExpression = result.toString();
                    } catch (e) {
                        display.value = 'Error';
                        this.calcExpression = '';
                    }
                }
            }

            calcClear() {
                const display = document.getElementById('calc-display');
                if (display) {
                    display.value = '0';
                    this.calcExpression = '';
                }
            }

            toggleCalcMode() {
                this.calcScientificMode = !this.calcScientificMode;
                const scientificDiv = document.getElementById('calc-scientific');
                const modeBtn = document.getElementById('calc-mode-btn');
                if (scientificDiv && modeBtn) {
                    scientificDiv.style.display = this.calcScientificMode ? 'block' : 'none';
                    modeBtn.textContent = this.calcScientificMode ? 'Standard' : 'Scientific';
                }
            }

            calcBackspace() {
                const display = document.getElementById('calc-display');
                if (display && this.calcExpression.length > 0) {
                    this.calcExpression = this.calcExpression.slice(0, -1);
                    display.value = this.calcExpression || '0';
                }
            }

            calcFunction(func, param) {
                const display = document.getElementById('calc-display');
                if (display) {
                    try {
                        let value = this.calcExpression ? eval(this.calcExpression) : 0;
                        let result;
                        if (param !== undefined) {
                            // Functions with parameters like pow
                            result = eval(`${func}(${value}, ${param})`);
                        } else {
                            // Single parameter functions
                            result = eval(`${func}(${value})`);
                        }
                        display.value = result;
                        this.calcExpression = result.toString();
                    } catch (e) {
                        display.value = 'Error';
                        this.calcExpression = '';
                    }
                }
            }

            calcConstant(constant) {
                const display = document.getElementById('calc-display');
                if (display) {
                    const value = eval(constant);
                    this.calcExpression = value.toString();
                    display.value = this.calcExpression;
                }
            }

            openMinesweeper() {
                // Show difficulty selection dialog
                const difficultyDialog = document.createElement('div');
                difficultyDialog.style.cssText = 'padding: 20px; text-align: center;';
                difficultyDialog.innerHTML = `
                    <h3 style="margin-top: 0;">Select Difficulty</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin: 20px 0;">
                        <button class="btn primary" onclick="emulator.startMinesweeper('easy')" style="padding: 12px;">Easy (8x8, 10 mines)</button>
                        <button class="btn primary" onclick="emulator.startMinesweeper('medium')" style="padding: 12px;">Medium (16x16, 40 mines)</button>
                        <button class="btn primary" onclick="emulator.startMinesweeper('hard')" style="padding: 12px;">Hard (24x24, 99 mines)</button>
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #808080; text-align: left; font-size: 11px;">
                        <strong>Statistics:</strong><br>
                        Easy - Wins: <span id="stats-easy-wins">0</span> | Best: <span id="stats-easy-time">-</span><br>
                        Medium - Wins: <span id="stats-medium-wins">0</span> | Best: <span id="stats-medium-time">-</span><br>
                        Hard - Wins: <span id="stats-hard-wins">0</span> | Best: <span id="stats-hard-time">-</span>
                    </div>
                `;

                // Load and display stats
                const stats = this.loadMinesweeperStats();
                setTimeout(() => {
                    ['easy', 'medium', 'hard'].forEach(diff => {
                        const winsEl = document.getElementById(`stats-${diff}-wins`);
                        const timeEl = document.getElementById(`stats-${diff}-time`);
                        if (winsEl) winsEl.textContent = stats[diff].wins;
                        if (timeEl) timeEl.textContent = stats[diff].bestTime ? `${stats[diff].bestTime}s` : '-';
                    });
                }, 50);

                this.windowManager.createWindow('Minesweeper', difficultyDialog, { width: 400, height: 360 });
            }

            loadMinesweeperStats() {
                const saved = SafeStorage.getItem('win95-minesweeper-stats');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return this.getDefaultMinesweeperStats();
                    }
                }
                return this.getDefaultMinesweeperStats();
            }

            getDefaultMinesweeperStats() {
                return {
                    easy: { wins: 0, losses: 0, bestTime: null },
                    medium: { wins: 0, losses: 0, bestTime: null },
                    hard: { wins: 0, losses: 0, bestTime: null }
                };
            }

            saveMinesweeperStats(stats) {
                SafeStorage.setItem('win95-minesweeper-stats', JSON.stringify(stats));
            }

            startMinesweeper(difficulty) {
                const configs = {
                    easy: { rows: 8, cols: 8, mines: 10 },
                    medium: { rows: 16, cols: 16, mines: 40 },
                    hard: { rows: 24, cols: 24, mines: 99 }
                };

                const config = configs[difficulty];
                const content = document.createElement('div');
                let board = this.createMinesweeperBoard(config.rows, config.cols, config.mines);
                let gameStarted = false;
                let gameOver = false;
                let startTime = null;
                let timerInterval = null;
                let flagCount = 0;

                content.innerHTML = `
                    <div style="padding: 10px; text-align: center;">
                        <div style="background: var(--button-face); padding: 8px; margin-bottom: 10px; border: 2px inset; display: flex; justify-content: space-between; align-items: center;">
                            <div><strong>💣 ${config.mines}</strong></div>
                            <div><strong>🚩 <span id="flag-count">0</span></strong></div>
                            <div><strong>⏱️ <span id="timer">0</span>s</strong></div>
                            <button class="btn" onclick="emulator.startMinesweeper('${difficulty}')" style="padding: 4px 8px;">New Game</button>
                        </div>
                        <div id="minesweeper-board" style="display: inline-grid; grid-template-columns: repeat(${config.cols}, 22px); gap: 0; border: 2px outset var(--button-face);"></div>
                    </div>
                `;

                const boardEl = content.querySelector('#minesweeper-board');
                const flagCountEl = content.querySelector('#flag-count');
                const timerEl = content.querySelector('#timer');

                board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const cellBtn = document.createElement('button');
                        cellBtn.className = 'btn';
                        cellBtn.style.cssText = 'width: 22px; height: 22px; padding: 0; font-size: 10px; font-weight: bold;';
                        cellBtn.dataset.row = r;
                        cellBtn.dataset.col = c;

                        cellBtn.onclick = () => {
                            if (!gameStarted) {
                                gameStarted = true;
                                startTime = Date.now();
                                timerInterval = setInterval(() => {
                                    if (!gameOver) {
                                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                                        timerEl.textContent = elapsed;
                                    }
                                }, 1000);
                            }
                            if (!gameOver) {
                                this.revealMinesweeperCell(boardEl, board, r, c, config, difficulty, timerInterval, () => {
                                    gameOver = true;
                                    clearInterval(timerInterval);
                                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                                    this.updateMinesweeperStats(difficulty, true, elapsed);
                                }, () => {
                                    gameOver = true;
                                    clearInterval(timerInterval);
                                    this.updateMinesweeperStats(difficulty, false, null);
                                });
                            }
                        };

                        cellBtn.oncontextmenu = (e) => {
                            e.preventDefault();
                            if (!gameOver && !cellBtn.disabled) {
                                if (cellBtn.textContent === '🚩') {
                                    cellBtn.textContent = '';
                                    flagCount--;
                                } else if (cellBtn.textContent === '') {
                                    cellBtn.textContent = '🚩';
                                    flagCount++;
                                }
                                flagCountEl.textContent = flagCount;
                            }
                            return false;
                        };

                        boardEl.appendChild(cellBtn);
                    });
                });

                const width = Math.max(320, config.cols * 22 + 40);
                const height = Math.max(380, config.rows * 22 + 100);
                this.windowManager.createWindow(`Minesweeper - ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`, content, { width, height });
            }

            updateMinesweeperStats(difficulty, won, time) {
                const stats = this.loadMinesweeperStats();
                if (won) {
                    stats[difficulty].wins++;
                    if (!stats[difficulty].bestTime || time < stats[difficulty].bestTime) {
                        stats[difficulty].bestTime = time;
                    }
                } else {
                    stats[difficulty].losses++;
                }
                this.saveMinesweeperStats(stats);
            }

            createMinesweeperBoard(rows, cols, mines) {
                const board = Array(rows).fill().map(() => Array(cols).fill(0));
                let placedMines = 0;

                while (placedMines < mines) {
                    const r = Math.floor(Math.random() * rows);
                    const c = Math.floor(Math.random() * cols);
                    if (board[r][c] !== -1) {
                        board[r][c] = -1;
                        placedMines++;

                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc] !== -1) {
                                    board[nr][nc]++;
                                }
                            }
                        }
                    }
                }
                return board;
            }

            revealMinesweeperCell(boardEl, board, row, col, config, difficulty, timerInterval, onWin, onLoss) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === '🚩') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === -1) {
                    // Hit a mine - game over
                    cellBtn.textContent = '💣';
                    cellBtn.style.background = 'red';

                    // Reveal all mines
                    const allCells = boardEl.querySelectorAll('button');
                    allCells.forEach(btn => {
                        const r = parseInt(btn.dataset.row);
                        const c = parseInt(btn.dataset.col);
                        if (board[r][c] === -1) {
                            btn.textContent = '💣';
                            btn.disabled = true;
                            btn.style.background = '#c0c0c0';
                        }
                    });

                    setTimeout(() => {
                        window.dialogManager.error('Game Over! You hit a mine!', 'Minesweeper', () => {
                            onLoss();
                        });
                    }, 100);
                } else if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                                this.revealMinesweeperCellSimple(boardEl, board, nr, nc);
                            }
                        }
                    }
                    // Check for win after revealing
                    this.checkMinesweeperWin(boardEl, board, config, onWin);
                } else {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                    // Check for win
                    this.checkMinesweeperWin(boardEl, board, config, onWin);
                }
            }

            revealMinesweeperCellSimple(boardEl, board, row, col) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === '🚩') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length) {
                                this.revealMinesweeperCellSimple(boardEl, board, nr, nc);
                            }
                        }
                    }
                } else if (value > 0) {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                }
            }

            checkMinesweeperWin(boardEl, board, config, onWin) {
                const allCells = boardEl.querySelectorAll('button');
                let revealedCount = 0;
                let totalCells = config.rows * config.cols;

                allCells.forEach(btn => {
                    if (btn.disabled && btn.textContent !== '💣') {
                        revealedCount++;
                    }
                });

                // Win if all non-mine cells are revealed
                if (revealedCount === totalCells - config.mines) {
                    setTimeout(() => {
                        window.dialogManager.info('🎉 Congratulations! You won!', 'Minesweeper', () => {
                            onWin();
                        });
                    }, 100);
                }
            }

            revealCell(boardEl, board, row, col) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === '🚩') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === -1) {
                    cellBtn.textContent = '💣';
                    window.dialogManager.error('Game Over! You hit a mine!', 'Minesweeper');
                } else if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            this.revealCell(boardEl, board, row + dr, col + dc);
                        }
                    }
                } else {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                }
            }

            toggleFlag(cellBtn) {
                if (cellBtn.disabled) return;
                const flagCount = document.getElementById('flag-count');
                if (cellBtn.textContent === '🚩') {
                    cellBtn.textContent = '';
                    if (flagCount) flagCount.textContent = parseInt(flagCount.textContent) - 1;
                } else {
                    cellBtn.textContent = '🚩';
                    if (flagCount) flagCount.textContent = parseInt(flagCount.textContent) + 1;
                }
            }

            openInternetExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Create IE toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.ieNavigate('back')" title="Back">◀</button>
                    <button class="btn" onclick="emulator.ieNavigate('forward')" title="Forward">▶</button>
                    <button class="btn" onclick="emulator.ieNavigate('refresh')" title="Refresh">🔄</button>
                    <button class="btn" onclick="emulator.ieNavigate('home')" title="Home">🏠</button>
                    <button class="btn" onclick="emulator.ieNavigate('stop')" title="Stop">⏹</button>
                    <div style="flex: 1; display: flex; align-items: center; gap: 4px; margin-left: 4px;">
                        <span style="font-size: 11px; font-weight: bold;">Address:</span>
                        <input type="text" id="ie-address-bar" value="https://www.wikipedia.org"
                            style="flex: 1; padding: 2px 4px; border: 1px solid var(--button-shadow); font-size: 11px;"
                            onkeypress="if(event.key==='Enter') emulator.ieNavigate('go')">
                        <button class="btn" onclick="emulator.ieNavigate('go')">Go</button>
                        <button class="btn" onclick="emulator.ieNavigate('popup')" title="Open in Full Browser Window" style="padding: 4px 8px;">
                            🌐 Browser
                        </button>
                    </div>
                `;

                // Create status bar
                const statusBar = document.createElement('div');
                statusBar.style.cssText = 'background: var(--button-face); border-top: 1px solid var(--button-highlight); padding: 2px 4px; font-size: 11px; display: flex; align-items: center; gap: 8px;';
                statusBar.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div class="led" id="ie-status-led"></div>
                        <span id="ie-status-text">Ready</span>
                    </div>
                    <div style="flex: 1;"></div>
                    <span style="font-size: 10px;">Internet zone</span>
                `;

                // Create iframe container
                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = 'flex: 1; background: white; position: relative; overflow: hidden;';

                const iframe = document.createElement('iframe');
                iframe.id = 'ie-browser-frame';
                iframe.src = 'https://www.wikipedia.org';
                iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
                iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox';

                // Detect if iframe fails to load (X-Frame-Options block)
                let loadTimeout = setTimeout(() => {
                    const loading = document.getElementById('ie-loading');
                    const statusText = document.getElementById('ie-status-text');
                    const currentUrl = iframe.src;

                    // Check if iframe is actually blocked
                    try {
                        const test = iframe.contentWindow.location.href;
                        // Success - iframe works
                        if (loading) loading.style.display = 'none';
                    } catch (e) {
                        // Blocked - offer to open in real browser
                        if (loading && currentUrl) {
                            loading.style.background = '#ffffcc';
                            loading.style.padding = '12px 8px';
                            loading.innerHTML = `
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <span>⚠️ <strong>Site blocks iframe.</strong> Click to open in full browser:</span>
                                    <button class="btn" onclick="window.open('${currentUrl.replace(/'/g, "\\'")}', '_blank', 'width=1024,height=768'); document.getElementById('ie-loading').style.display='none';" style="padding: 4px 12px; margin-left: 8px;">
                                        🌐 Open in Browser
                                    </button>
                                </div>
                            `;
                            loading.style.display = 'block';
                            if (statusText) statusText.textContent = 'Click to open in browser';
                        }
                    }
                }, 3000);

                // Loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'ie-loading';
                loadingDiv.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; background: #ffffcc; padding: 4px 8px; font-size: 11px; border-bottom: 1px solid #808080; display: none;';
                loadingDiv.innerHTML = '⏳ Loading page...';

                iframeContainer.appendChild(loadingDiv);
                iframeContainer.appendChild(iframe);

                // Assemble the browser
                content.appendChild(toolbar);
                content.appendChild(iframeContainer);
                content.appendChild(statusBar);

                // Create window
                const win = this.windowManager.createWindow('Internet Explorer', content, {
                    width: 600,
                    height: 500,
                    x: 50,
                    y: 50
                });

                // Store current window ID for navigation
                this.currentIEWindowId = win.id;

                // Setup iframe event listeners
                iframe.addEventListener('load', () => {
                    clearTimeout(loadTimeout); // Clear the timeout when page loads successfully
                    const led = document.getElementById('ie-status-led');
                    const statusText = document.getElementById('ie-status-text');
                    const loading = document.getElementById('ie-loading');

                    if (led) led.classList.remove('active');
                    if (statusText) statusText.textContent = 'Done';
                    if (loading) loading.style.display = 'none';

                    // Try to update address bar with current URL (won't work for cross-origin)
                    try {
                        const addressBar = document.getElementById('ie-address-bar');
                        if (addressBar && iframe.contentWindow) {
                            addressBar.value = iframe.contentWindow.location.href;
                        }
                    } catch (e) {
                        // Cross-origin, can't access
                    }
                });

                // Add error handler for blocked content
                iframe.addEventListener('error', () => {
                    const loading = document.getElementById('ie-loading');
                    const statusText = document.getElementById('ie-status-text');
                    const led = document.getElementById('ie-status-led');

                    if (loading) {
                        loading.style.background = '#ffcccc';
                        loading.innerHTML = '⚠️ This page cannot be displayed. Many sites (like google.com) block iframe embedding for security.';
                        loading.style.display = 'block';
                    }
                    if (statusText) statusText.textContent = 'Page cannot be displayed';
                    if (led) led.classList.remove('active');
                });

                // Show loading state
                const led = document.getElementById('ie-status-led');
                const statusText = document.getElementById('ie-status-text');
                const loading = document.getElementById('ie-loading');
                if (led) led.classList.add('active');
                if (statusText) statusText.textContent = 'Loading...';
                if (loading) loading.style.display = 'block';
            }

            ieNavigate(action) {
                const iframe = document.getElementById('ie-browser-frame');
                const addressBar = document.getElementById('ie-address-bar');
                const led = document.getElementById('ie-status-led');
                const statusText = document.getElementById('ie-status-text');
                const loading = document.getElementById('ie-loading');

                if (!iframe) return;

                try {
                    switch (action) {
                        case 'back':
                            window.history.back();
                            break;
                        case 'forward':
                            window.history.forward();
                            break;
                        case 'refresh':
                            iframe.src = iframe.src;
                            if (led) led.classList.add('active');
                            if (statusText) statusText.textContent = 'Refreshing...';
                            if (loading) loading.style.display = 'block';
                            break;
                        case 'home':
                            iframe.src = 'https://www.wikipedia.org';
                            if (addressBar) addressBar.value = 'https://www.wikipedia.org';
                            if (led) led.classList.add('active');
                            if (statusText) statusText.textContent = 'Loading home page...';
                            if (loading) loading.style.display = 'block';
                            break;
                        case 'stop':
                            iframe.src = '';
                            if (led) led.classList.remove('active');
                            if (statusText) statusText.textContent = 'Stopped';
                            if (loading) loading.style.display = 'none';
                            break;
                        case 'go':
                            if (addressBar) {
                                let url = addressBar.value.trim();

                                // Add protocol if missing
                                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                                    url = 'https://' + url;
                                }

                                iframe.src = url;
                                if (led) led.classList.add('active');
                                if (statusText) statusText.textContent = 'Connecting...';
                                if (loading) loading.style.display = 'block';
                            }
                            break;
                        case 'popup':
                            // Open current URL in a full browser popup window
                            if (addressBar) {
                                let url = addressBar.value.trim();

                                // Add protocol if missing
                                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                                    url = 'https://' + url;
                                }

                                // Open in popup window with decent size
                                window.open(url, '_blank', 'width=1200,height=800,menubar=yes,toolbar=yes,location=yes,status=yes,scrollbars=yes,resizable=yes');

                                if (statusText) statusText.textContent = 'Opened in browser window';
                                this.showToast('🌐 Browser Window', 'Page opened in new window');
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Navigation error:', error);
                    if (statusText) statusText.textContent = 'Error loading page';
                    if (led) led.classList.remove('active');
                    if (loading) loading.style.display = 'none';
                }
            }

            // ============================================================================
            // CHROMIUM BROWSER ENGINE - Full Implementation
            // ============================================================================

            openChromiumBrowser() {
                // Initialize Chromium Browser Engine
                if (!this.chromiumEngine) {
                    this.chromiumEngine = new ChromiumBrowserEngine(this);
                }
                this.chromiumEngine.createBrowserWindow();
            }

            openPaint() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Paint toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; flex-wrap: wrap;';
                toolbar.innerHTML = `
                    <button class="btn" id="tool-pencil" title="Pencil" onclick="emulator.paintSetTool('pencil')" style="background: #e0e0e0;">✏️</button>
                    <button class="btn" id="tool-brush" title="Brush" onclick="emulator.paintSetTool('brush')">🖌️</button>
                    <button class="btn" id="tool-spray" title="Spray Paint" onclick="emulator.paintSetTool('spray')">💨</button>
                    <button class="btn" id="tool-line" title="Line" onclick="emulator.paintSetTool('line')">📏</button>
                    <button class="btn" id="tool-rect" title="Rectangle" onclick="emulator.paintSetTool('rect')">▭</button>
                    <button class="btn" id="tool-filled-rect" title="Filled Rectangle" onclick="emulator.paintSetTool('filled-rect')">◼️</button>
                    <button class="btn" id="tool-circle" title="Circle" onclick="emulator.paintSetTool('circle')">○</button>
                    <button class="btn" id="tool-filled-circle" title="Filled Circle" onclick="emulator.paintSetTool('filled-circle')">⬤</button>
                    <button class="btn" id="tool-fill" title="Fill" onclick="emulator.paintSetTool('fill')">🪣</button>
                    <button class="btn" id="tool-eraser" title="Eraser" onclick="emulator.paintSetTool('eraser')">🧹</button>
                    <button class="btn" onclick="emulator.paintUndo()" title="Undo (Ctrl+Z)">↶ Undo</button>
                    <button class="btn" onclick="emulator.paintRedo()" title="Redo (Ctrl+Y)">↷ Redo</button>
                    <button class="btn" onclick="emulator.paintClear()">Clear</button>
                    <button class="btn" onclick="emulator.paintSave()">💾 Save</button>
                    <div style="display: flex; gap: 2px; align-items: center; margin-left: auto;">
                        <span style="font-size: 11px;">Color:</span>
                        <input type="color" id="paint-color" value="#000000" style="width: 40px; height: 22px; border: 1px solid var(--button-shadow);">
                        <span style="font-size: 11px;">Size:</span>
                        <input type="range" id="paint-size" min="1" max="30" value="3" style="width: 80px;">
                        <span id="paint-size-display" style="font-size: 11px; min-width: 25px;">3px</span>
                    </div>
                `;

                // Canvas container
                const canvasContainer = document.createElement('div');
                canvasContainer.style.cssText = 'flex: 1; background: white; overflow: auto; position: relative;';

                const canvas = document.createElement('canvas');
                canvas.id = 'paint-canvas';
                canvas.width = 640;
                canvas.height = 480;
                canvas.style.cssText = 'display: block; cursor: crosshair; background: white;';

                canvasContainer.appendChild(canvas);
                content.appendChild(toolbar);
                content.appendChild(canvasContainer);

                this.windowManager.createWindow('Paint', content, { width: 680, height: 560 });

                // Initialize paint
                this.initPaint(canvas);
            }

            initPaint(canvas) {
                const ctx = canvas.getContext('2d');
                let isDrawing = false;
                let startX, startY;
                let currentTool = 'pencil';
                let tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;

                // Undo/Redo history
                let history = [];
                let historyStep = -1;
                const MAX_HISTORY = 50; // Limit to prevent memory issues

                // Initialize white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Save initial state
                this.paintSaveHistory = () => {
                    historyStep++;
                    if (historyStep < history.length) {
                        history.length = historyStep; // Remove forward history
                    }
                    history.push(canvas.toDataURL());
                    // Limit history size
                    if (history.length > MAX_HISTORY) {
                        history.shift();
                        historyStep--;
                    }
                };
                this.paintSaveHistory();

                this.paintSetTool = (tool) => {
                    currentTool = tool;
                    // Highlight selected tool
                    document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                        btn.style.background = '';
                    });
                    const toolBtn = document.getElementById(`tool-${tool}`);
                    if (toolBtn) toolBtn.style.background = '#e0e0e0';
                };

                this.paintClear = () => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    this.paintSaveHistory();
                };

                this.paintUndo = () => {
                    if (historyStep > 0) {
                        historyStep--;
                        const img = new Image();
                        img.src = history[historyStep];
                        img.onload = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                        };
                    }
                };

                this.paintRedo = () => {
                    if (historyStep < history.length - 1) {
                        historyStep++;
                        const img = new Image();
                        img.src = history[historyStep];
                        img.onload = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                        };
                    }
                };

                this.paintSave = () => {
                    const dataURL = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'paint-' + Date.now() + '.png';
                    link.href = dataURL;
                    link.click();
                };

                // Update size display
                const sizeInput = document.getElementById('paint-size');
                const sizeDisplay = document.getElementById('paint-size-display');
                if (sizeInput && sizeDisplay) {
                    sizeInput.addEventListener('input', (e) => {
                        sizeDisplay.textContent = e.target.value + 'px';
                    });
                }

                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;

                    // Save current canvas state
                    tempCanvas.getContext('2d').drawImage(canvas, 0, 0);

                    const colorInput = document.getElementById('paint-color');
                    const sizeInput = document.getElementById('paint-size');
                    if (colorInput) ctx.strokeStyle = colorInput.value;
                    if (colorInput) ctx.fillStyle = colorInput.value;
                    if (sizeInput) ctx.lineWidth = parseInt(sizeInput.value);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    if (currentTool === 'pencil' || currentTool === 'brush') {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!isDrawing) return;

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (currentTool === 'pencil' || currentTool === 'brush') {
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    } else if (currentTool === 'spray') {
                        // Spray paint effect
                        const density = ctx.lineWidth * 2;
                        for (let i = 0; i < density; i++) {
                            const offsetX = (Math.random() - 0.5) * ctx.lineWidth * 2;
                            const offsetY = (Math.random() - 0.5) * ctx.lineWidth * 2;
                            ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
                        }
                    } else if (currentTool === 'eraser') {
                        ctx.clearRect(x - ctx.lineWidth/2, y - ctx.lineWidth/2, ctx.lineWidth, ctx.lineWidth);
                    } else {
                        // For shapes, restore canvas and draw preview
                        ctx.putImageData(tempCanvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height), 0, 0);

                        if (currentTool === 'line') {
                            ctx.beginPath();
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        } else if (currentTool === 'rect') {
                            ctx.strokeRect(startX, startY, x - startX, y - startY);
                        } else if (currentTool === 'filled-rect') {
                            ctx.fillRect(startX, startY, x - startX, y - startY);
                        } else if (currentTool === 'circle') {
                            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            ctx.beginPath();
                            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        } else if (currentTool === 'filled-circle') {
                            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            ctx.beginPath();
                            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    if (!isDrawing) return;
                    isDrawing = false;

                    const rect = canvas.getBoundingClientRect();
                    const x = Math.floor(e.clientX - rect.left);
                    const y = Math.floor(e.clientY - rect.top);

                    if (currentTool === 'fill') {
                        // Flood fill algorithm
                        const colorInput = document.getElementById('paint-color');
                        if (!colorInput) return;

                        const fillColor = this.hexToRgb(colorInput.value);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const targetColor = this.getPixelColor(imageData, x, y);

                        // Don't fill if target color is same as fill color
                        if (this.colorsMatch(targetColor, fillColor)) return;

                        this.floodFill(imageData, x, y, targetColor, fillColor, canvas.width, canvas.height);
                        ctx.putImageData(imageData, 0, 0);
                    }

                    // Save state for undo/redo after any drawing action
                    this.paintSaveHistory();
                });

                canvas.addEventListener('mouseleave', () => {
                    isDrawing = false;
                });

                // Keyboard shortcuts for Paint
                const paintKeyHandler = (e) => {
                    // Ctrl+Z - Undo
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.paintUndo();
                    }
                    // Ctrl+Y - Redo
                    if (e.ctrlKey && e.key === 'y') {
                        e.preventDefault();
                        this.paintRedo();
                    }
                };
                document.addEventListener('keydown', paintKeyHandler);

                // Clear canvas initially (this saves the initial white state to history)
                // No need to call paintClear() as the initial state is already saved
            }

            // Paint helper functions
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16),
                    a: 255
                } : null;
            }

            getPixelColor(imageData, x, y) {
                const index = (y * imageData.width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }

            setPixelColor(imageData, x, y, color) {
                const index = (y * imageData.width + x) * 4;
                imageData.data[index] = color.r;
                imageData.data[index + 1] = color.g;
                imageData.data[index + 2] = color.b;
                imageData.data[index + 3] = color.a;
            }

            colorsMatch(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
            }

            floodFill(imageData, x, y, targetColor, fillColor, width, height) {
                // Stack-based flood fill to avoid recursion stack overflow
                const stack = [[x, y]];
                const visited = new Set();

                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    const key = `${cx},${cy}`;

                    if (visited.has(key)) continue;
                    if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;

                    visited.add(key);

                    const currentColor = this.getPixelColor(imageData, cx, cy);
                    if (!this.colorsMatch(currentColor, targetColor)) continue;

                    this.setPixelColor(imageData, cx, cy, fillColor);

                    // Add neighboring pixels
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            openFileExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.explorerNavigate('back')" title="Back">◀</button>
                    <button class="btn" onclick="emulator.explorerNavigate('up')" title="Up">⬆</button>
                    <div style="flex: 1; margin: 0 4px; padding: 2px 4px; border: 1px solid var(--button-shadow); background: white; font-size: 11px;" id="explorer-path">
                        C:\\
                    </div>
                    <button class="btn" onclick="emulator.explorerDeleteSelected()" title="Delete" id="explorer-delete-btn">🗑️ Delete</button>
                `;

                // Main container with splitter
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; flex: 1; overflow: hidden;';

                // Tree view (left panel)
                const treePanel = document.createElement('div');
                treePanel.id = 'explorer-tree';
                treePanel.style.cssText = 'width: 200px; background: white; border-right: 1px solid #808080; border-top: 2px inset; overflow-y: auto; font-size: 11px; padding: 4px;';

                // Content area (right panel)
                const contentArea = document.createElement('div');
                contentArea.id = 'explorer-content';
                contentArea.style.cssText = 'flex: 1; background: white; padding: 8px; overflow: auto; border-top: 2px inset;';

                mainContainer.appendChild(treePanel);
                mainContainer.appendChild(contentArea);

                content.appendChild(toolbar);
                content.appendChild(mainContainer);

                this.windowManager.createWindow('Windows Explorer', content, { width: 600, height: 450 });

                this.initFileExplorer();
            }

            initFileExplorer() {
                // WAVE 5 ENHANCEMENT: Multi-drive file system with proper drive metadata
                this.fileSystem = {
                    'MY_COMPUTER': {
                        type: 'drives',
                        drives: {
                            'A:\\': {
                                icon: '💾',
                                label: '3½ Floppy (A:)',
                                type: 'Floppy Disk Drive',
                                total: '1.44 MB',
                                free: '0 bytes',
                                used: '1.44 MB'
                            },
                            'C:\\': {
                                icon: '💻',
                                label: 'Windows 95 (C:)',
                                type: 'Local Disk',
                                total: '10.0 GB',
                                free: '4.2 GB',
                                used: '5.8 GB'
                            },
                            'D:\\': {
                                icon: '💽',
                                label: 'Data (D:)',
                                type: 'Local Disk',
                                total: '20.0 GB',
                                free: '15.8 GB',
                                used: '4.2 GB'
                            },
                            'E:\\': {
                                icon: '📀',
                                label: 'CD-ROM (E:)',
                                type: 'CD-ROM Drive',
                                total: '650 MB',
                                free: '0 bytes',
                                used: '650 MB'
                            }
                        }
                    },
                    'C:\\': {
                        type: 'folder',
                        contents: {
                            'Windows': { type: 'folder', contents: {} },
                            'Program Files': { type: 'folder', contents: {} },
                            'My Documents': {
                                type: 'folder',
                                contents: {
                                    'readme.txt': { type: 'file', size: '1 KB' },
                                    'notes.txt': { type: 'file', size: '2 KB' }
                                }
                            },
                            'autoexec.bat': { type: 'file', size: '156 bytes' },
                            'config.sys': { type: 'file', size: '89 bytes' }
                        }
                    },
                    'D:\\': {
                        type: 'folder',
                        contents: {
                            'Backup': { type: 'folder', contents: {} },
                            'Downloads': { type: 'folder', contents: {} },
                            'Media': { type: 'folder', contents: {} }
                        }
                    },
                    'A:\\': {
                        type: 'folder',
                        contents: {}
                    },
                    'E:\\': {
                        type: 'folder',
                        contents: {
                            'setup.exe': { type: 'file', size: '1.2 MB' },
                            'readme.txt': { type: 'file', size: '4 KB' }
                        }
                    }
                };

                this.currentPath = 'MY_COMPUTER';
                this.explorerHistory = ['C:\\'];
                this.explorerHistoryIndex = 0;

                this.explorerNavigate = (action) => {
                    if (action === 'back' && this.explorerHistoryIndex > 0) {
                        this.explorerHistoryIndex--;
                        this.currentPath = this.explorerHistory[this.explorerHistoryIndex];
                        this.renderExplorer();
                    } else if (action === 'up') {
                        const parts = this.currentPath.split('\\').filter(p => p);
                        if (parts.length > 1) {
                            parts.pop();
                            this.currentPath = parts.join('\\') + '\\';
                            if (!this.currentPath.includes(':\\')) {
                                this.currentPath = parts[0] + ':\\' + this.currentPath.split(':\\')[1];
                            }
                            this.addToHistory(this.currentPath);
                            this.renderExplorer();
                        }
                    }
                };

                this.explorerOpenFolder = (name) => {
                    this.currentPath = this.currentPath + name + '\\';
                    this.addToHistory(this.currentPath);
                    this.renderExplorer();
                };

                this.addToHistory = (path) => {
                    this.explorerHistory = this.explorerHistory.slice(0, this.explorerHistoryIndex + 1);
                    this.explorerHistory.push(path);
                    this.explorerHistoryIndex = this.explorerHistory.length - 1;
                };

                this.renderExplorer();
                this.buildExplorerTree();
            }

            buildExplorerTree() {
                const treePanel = document.getElementById('explorer-tree');
                if (!treePanel) return;

                treePanel.innerHTML = '';

                const buildNode = (name, item, path, indent = 0) => {
                    const node = document.createElement('div');
                    node.style.cssText = `padding: 2px 2px 2px ${indent * 12 + 4}px; cursor: pointer; user-select: none;`;
                    node.innerHTML = (item.type === 'folder' ? '📁 ' : '📄 ') + name;

                    node.onclick = () => {
                        if (item.type === 'folder') {
                            this.currentPath = path;
                            this.addToHistory(path);
                            this.renderExplorer();

                            // Highlight selected
                            treePanel.querySelectorAll('div').forEach(d => d.style.background = 'white');
                            node.style.background = '#000080';
                            node.style.color = 'white';
                        }
                    };

                    treePanel.appendChild(node);

                    // Recursively build children
                    if (item.type === 'folder' && item.contents) {
                        Object.keys(item.contents).sort().forEach(childName => {
                            const childPath = path + childName + (item.contents[childName].type === 'folder' ? '\\' : '');
                            buildNode(childName, item.contents[childName], childPath, indent + 1);
                        });
                    }
                };

                // WAVE 5 ENHANCEMENT: Build root - My Computer
                const rootNode = document.createElement('div');
                rootNode.style.cssText = 'padding: 2px 4px; cursor: pointer; font-weight: bold; user-select: none; background: #000080; color: white;';
                rootNode.innerHTML = '💻 My Computer';
                rootNode.onclick = () => {
                    this.currentPath = 'MY_COMPUTER';
                    this.addToHistory('MY_COMPUTER');
                    this.renderExplorer();
                    // Highlight root
                    treePanel.querySelectorAll('div').forEach(d => d.style.background = 'white');
                    rootNode.style.background = '#000080';
                    rootNode.style.color = 'white';
                };
                treePanel.appendChild(rootNode);

                // WAVE 5 ENHANCEMENT: Build all drives
                const drives = this.fileSystem['MY_COMPUTER'].drives;
                Object.keys(drives).sort().forEach(driveLetter => {
                    const drive = drives[driveLetter];
                    const driveNode = document.createElement('div');
                    driveNode.style.cssText = 'padding: 2px 2px 2px 16px; cursor: pointer; user-select: none;';
                    driveNode.innerHTML = `${drive.icon} ${driveLetter}`;
                    driveNode.onclick = () => {
                        this.currentPath = driveLetter;
                        this.addToHistory(driveLetter);
                        this.renderExplorer();
                        // Highlight selected
                        treePanel.querySelectorAll('div').forEach(d => { d.style.background = 'white'; d.style.color = 'black'; });
                        driveNode.style.background = '#000080';
                        driveNode.style.color = 'white';
                    };
                    treePanel.appendChild(driveNode);

                    // Build drive contents
                    const driveData = this.fileSystem[driveLetter];
                    if (driveData && driveData.contents) {
                        Object.keys(driveData.contents).sort().forEach(name => {
                            const fullPath = driveLetter + name + (driveData.contents[name].type === 'folder' ? '\\' : '');
                            buildNode(name, driveData.contents[name], fullPath, 2);
                        });
                    }
                });
            }

            renderExplorer() {
                const contentArea = document.getElementById('explorer-content');
                const pathDisplay = document.getElementById('explorer-path');

                if (!contentArea || !pathDisplay) return;

                pathDisplay.textContent = this.currentPath === 'MY_COMPUTER' ? 'My Computer' : this.currentPath;

                // WAVE 5 ENHANCEMENT: Special handling for MY_COMPUTER drive view
                if (this.currentPath === 'MY_COMPUTER') {
                    this.renderMyComputerView(contentArea);
                    return;
                }

                // Get current folder contents
                const parts = this.currentPath.split('\\').filter(p => p);
                let current = this.fileSystem[parts[0] + ':\\'];

                for (let i = 1; i < parts.length; i++) {
                    if (current.contents && current.contents[parts[i]]) {
                        current = current.contents[parts[i]];
                    }
                }

                // Render contents as detailed list
                contentArea.innerHTML = '';

                // Header
                const header = document.createElement('div');
                header.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 4px; background: #c0c0c0; border-bottom: 1px solid #808080; font-weight: bold;';
                header.innerHTML = `
                    <div>Name</div>
                    <div>Type</div>
                    <div>Size</div>
                `;
                contentArea.appendChild(header);

                if (current.contents) {
                    Object.keys(current.contents).sort().forEach(name => {
                        const item = current.contents[name];
                        const itemEl = document.createElement('div');
                        itemEl.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        itemEl.innerHTML = `
                            <div>${item.type === 'folder' ? '📁' : '📄'} ${name}</div>
                            <div>${item.type === 'folder' ? 'File Folder' : 'Text Document'}</div>
                            <div>${item.size || ''}</div>
                        `;

                        itemEl.onclick = () => {
                            // Highlight selected
                            contentArea.querySelectorAll('div[style*="grid"]').forEach(d => {
                                if (d !== header) d.style.background = 'white';
                            });
                            itemEl.style.background = '#000080';
                            itemEl.style.color = 'white';

                            // Track selected item for deletion
                            this.selectedExplorerItem = { name, item };
                        };

                        if (item.type === 'folder') {
                            itemEl.addEventListener('dblclick', () => this.explorerOpenFolder(name));
                        } else {
                            itemEl.addEventListener('dblclick', () => {
                                this.openNotepad();
                            });
                        }

                        // Right-click context menu for file/folder
                        itemEl.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            // Select the item
                            contentArea.querySelectorAll('div[style*="grid"]').forEach(d => {
                                if (d !== header) d.style.background = 'white';
                            });
                            itemEl.style.background = '#000080';
                            itemEl.style.color = 'white';
                            this.selectedExplorerItem = { name, item };

                            // Show context menu
                            this.showExplorerContextMenu(e.clientX, e.clientY, name, item);
                        });

                        contentArea.appendChild(itemEl);
                    });
                } else {
                    contentArea.innerHTML += '<div style="padding: 20px; color: #808080;">Folder is empty</div>';
                }
            }

            // WAVE 5 ENHANCEMENT: My Computer drive view with capacity bars
            renderMyComputerView(contentArea) {
                contentArea.innerHTML = '';

                // Header
                const header = document.createElement('div');
                header.style.cssText = 'display: grid; grid-template-columns: 2.5fr 1.5fr 1fr 1fr; padding: 4px; background: #c0c0c0; border-bottom: 1px solid #808080; font-weight: bold;';
                header.innerHTML = `
                    <div>Name</div>
                    <div>Type</div>
                    <div>Total Size</div>
                    <div>Free Space</div>
                `;
                contentArea.appendChild(header);

                const drives = this.fileSystem['MY_COMPUTER'].drives;
                Object.keys(drives).sort().forEach(driveLetter => {
                    const drive = drives[driveLetter];
                    const itemEl = document.createElement('div');
                    itemEl.style.cssText = 'display: grid; grid-template-columns: 2.5fr 1.5fr 1fr 1fr; padding: 8px 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer; align-items: center;';

                    // Calculate percentage for capacity bar
                    const totalBytes = this.parseSizeToBytes(drive.total);
                    const freeBytes = this.parseSizeToBytes(drive.free);
                    const usedPercent = totalBytes > 0 ? Math.round(((totalBytes - freeBytes) / totalBytes) * 100) : 0;

                    itemEl.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 24px;">${drive.icon}</span>
                            <div>
                                <div style="font-weight: bold;">${drive.label}</div>
                                <div style="font-size: 9px; color: #666; margin-top: 2px;">
                                    <div style="background: #808080; height: 8px; width: 120px; border: 1px solid #000; position: relative;">
                                        <div style="background: ${usedPercent > 90 ? '#ff0000' : '#0000ff'}; height: 100%; width: ${usedPercent}%;"></div>
                                    </div>
                                    <div style="margin-top: 2px;">${usedPercent}% used</div>
                                </div>
                            </div>
                        </div>
                        <div>${drive.type}</div>
                        <div>${drive.total}</div>
                        <div>${drive.free}</div>
                    `;

                    itemEl.onclick = () => {
                        contentArea.querySelectorAll('div[style*="grid"]').forEach(d => {
                            if (d !== header) d.style.background = 'white';
                        });
                        itemEl.style.background = '#000080';
                        itemEl.style.color = 'white';
                    };

                    itemEl.ondblclick = () => {
                        this.currentPath = driveLetter;
                        this.addToHistory(driveLetter);
                        this.renderExplorer();
                        this.buildExplorerTree();
                    };

                    // Right-click for drive properties
                    itemEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.showDriveProperties(drive, driveLetter);
                    });

                    contentArea.appendChild(itemEl);
                });
            }

            // Helper: Parse size strings to bytes for calculations
            parseSizeToBytes(sizeStr) {
                const units = {
                    'bytes': 1,
                    'KB': 1024,
                    'MB': 1024 * 1024,
                    'GB': 1024 * 1024 * 1024
                };
                const match = sizeStr.match(/([0-9.]+)\s*(bytes|KB|MB|GB)/);
                if (match) {
                    return parseFloat(match[1]) * (units[match[2]] || 1);
                }
                return 0;
            }

            // WAVE 5 ENHANCEMENT: Drive properties dialog
            showDriveProperties(drive, driveLetter) {
                const totalBytes = this.parseSizeToBytes(drive.total);
                const freeBytes = this.parseSizeToBytes(drive.free);
                const usedBytes = totalBytes - freeBytes;
                const usedPercent = totalBytes > 0 ? Math.round((usedBytes / totalBytes) * 100) : 0;

                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: var(--button-face); min-width: 300px;';
                content.innerHTML = `
                    <div style="text-align: center; margin-bottom: 16px;">
                        <div style="font-size: 48px; margin-bottom: 8px;">${drive.icon}</div>
                        <div style="font-weight: bold; font-size: 14px;">${drive.label}</div>
                    </div>
                    <div style="background: white; border: 2px inset; padding: 12px;">
                        <div style="margin-bottom: 8px;"><strong>Type:</strong> ${drive.type}</div>
                        <div style="border-top: 1px solid #808080; margin: 12px 0;"></div>
                        <div style="margin-bottom: 4px;"><strong>Used space:</strong> ${drive.used} (${usedPercent}%)</div>
                        <div style="margin-bottom: 4px;"><strong>Free space:</strong> ${drive.free}</div>
                        <div style="margin-bottom: 8px;"><strong>Capacity:</strong> ${drive.total}</div>
                        <div style="background: #808080; height: 24px; border: 1px solid #000; position: relative; margin: 8px 0;">
                            <div style="background: #0000ff; height: 100%; width: ${usedPercent}%;"></div>
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-weight: bold; text-shadow: 1px 1px 2px #000; font-size: 10px;">
                                ${usedPercent}% Used
                            </div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 16px;">
                        <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px;">OK</button>
                    </div>
                `;

                this.windowManager.createWindow(`${driveLetter} Properties`, content, { width: 350, height: 400 });
            }

            showExplorerContextMenu(x, y, name, item) {
                // Remove existing context menu
                const existing = document.getElementById('explorer-context-menu');
                if (existing) existing.remove();

                const hasClipboard = this.clipboard.items.length > 0;

                const contextMenu = document.createElement('div');
                contextMenu.id = 'explorer-context-menu';
                contextMenu.className = 'context-menu active';
                contextMenu.style.position = 'fixed';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="emulator.explorerOpenItem(); document.getElementById('explorer-context-menu').remove();">
                        📂 Open
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.explorerCopy(); document.getElementById('explorer-context-menu').remove();">
                        📄 Copy     <span style="float: right; opacity: 0.6;">Ctrl+C</span>
                    </div>
                    <div class="context-menu-item" onclick="emulator.explorerCut(); document.getElementById('explorer-context-menu').remove();">
                        ✂️ Cut      <span style="float: right; opacity: 0.6;">Ctrl+X</span>
                    </div>
                    <div class="context-menu-item ${!hasClipboard ? 'disabled' : ''}" onclick="if(!this.classList.contains('disabled')){emulator.explorerPaste(); document.getElementById('explorer-context-menu').remove();}">
                        📋 Paste    <span style="float: right; opacity: 0.6;">Ctrl+V</span>
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.explorerDeleteSelected(); document.getElementById('explorer-context-menu').remove();">
                        🗑️ Delete  <span style="float: right; opacity: 0.6;">Del</span>
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.explorerShowProperties('${name}'); document.getElementById('explorer-context-menu').remove();">
                        📋 Properties
                    </div>
                `;
                document.body.appendChild(contextMenu);

                // Close on next click
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        if (contextMenu.parentNode) contextMenu.remove();
                        document.removeEventListener('click', closeMenu);
                    }, { once: true });
                }, 100);
            }

            explorerOpenItem() {
                if (!this.selectedExplorerItem) return;
                const { name, item } = this.selectedExplorerItem;

                if (item.type === 'folder') {
                    this.explorerOpenFolder(name);
                } else {
                    this.openNotepad();
                }
            }

            explorerShowProperties(name) {
                if (!this.selectedExplorerItem) return;
                const { item } = this.selectedExplorerItem;

                const content = document.createElement('div');
                content.style.cssText = 'padding: 20px; font-size: 11px;';
                content.innerHTML = `
                    <div style="margin-bottom: 12px;"><strong>Name:</strong> ${name}</div>
                    <div style="margin-bottom: 12px;"><strong>Type:</strong> ${item.type === 'folder' ? 'File Folder' : 'Text Document'}</div>
                    <div style="margin-bottom: 12px;"><strong>Size:</strong> ${item.size || 'Unknown'}</div>
                    <div style="margin-bottom: 12px;"><strong>Location:</strong> ${this.currentPath}</div>
                    <hr style="margin: 12px 0; border: none; border-top: 1px solid #808080;">
                    <button class="btn" onclick="emulator.windowManager.getActiveWindow().close()" style="margin-top: 8px;">OK</button>
                `;

                this.windowManager.createWindow(`${name} Properties`, content, { width: 350, height: 250 });
            }

            // ============================================
            // WAVE 4 ENHANCEMENT #2: Clipboard Operations
            // ============================================

            explorerCopy() {
                if (!this.selectedExplorerItem) {
                    if (window.dialogManager) {
                        window.dialogManager.warning('Please select a file or folder to copy.', 'Copy');
                    }
                    return;
                }

                const { name, item } = this.selectedExplorerItem;

                // Copy to clipboard
                this.clipboard.items = [{ name, item: JSON.parse(JSON.stringify(item)) }];
                this.clipboard.operation = 'copy';
                this.clipboard.source = this.currentPath;

                if (window.toastManager) {
                    window.toastManager.show('Copied', `"${name}" copied to clipboard.`);
                }
            }

            explorerCut() {
                if (!this.selectedExplorerItem) {
                    if (window.dialogManager) {
                        window.dialogManager.warning('Please select a file or folder to cut.', 'Cut');
                    }
                    return;
                }

                const { name, item } = this.selectedExplorerItem;

                // Cut to clipboard
                this.clipboard.items = [{ name, item: JSON.parse(JSON.stringify(item)) }];
                this.clipboard.operation = 'cut';
                this.clipboard.source = this.currentPath;

                if (window.toastManager) {
                    window.toastManager.show('Cut', `"${name}" cut to clipboard.`);
                }

                // Visual feedback - gray out cut item
                const contentArea = document.getElementById('explorer-content');
                if (contentArea) {
                    const items = contentArea.querySelectorAll('div[style*="grid"]');
                    items.forEach(el => {
                        if (el.textContent.includes(name)) {
                            el.style.opacity = '0.5';
                        }
                    });
                }
            }

            explorerPaste() {
                if (this.clipboard.items.length === 0) {
                    if (window.dialogManager) {
                        window.dialogManager.warning('Clipboard is empty.', 'Paste');
                    }
                    return;
                }

                // Get current folder
                const parts = this.currentPath.split('\\').filter(p => p);
                let current = this.fileSystem['C:\\'];

                for (let i = 1; i < parts.length; i++) {
                    if (current.contents && current.contents[parts[i]]) {
                        current = current.contents[parts[i]];
                    }
                }

                if (!current.contents) {
                    current.contents = {};
                }

                // Paste each item from clipboard
                this.clipboard.items.forEach(({ name, item }) => {
                    let targetName = name;

                    // Handle duplicate names
                    if (current.contents[targetName]) {
                        let counter = 1;
                        const ext = name.includes('.') ? name.substring(name.lastIndexOf('.')) : '';
                        const baseName = ext ? name.substring(0, name.lastIndexOf('.')) : name;

                        while (current.contents[targetName]) {
                            targetName = `${baseName} (${counter})${ext}`;
                            counter++;
                        }
                    }

                    // Add to current folder
                    current.contents[targetName] = JSON.parse(JSON.stringify(item));

                    // If cut operation, remove from source
                    if (this.clipboard.operation === 'cut' && this.clipboard.source) {
                        const sourceParts = this.clipboard.source.split('\\').filter(p => p);
                        let sourceFolder = this.fileSystem['C:\\'];

                        for (let i = 1; i < sourceParts.length; i++) {
                            if (sourceFolder.contents && sourceFolder.contents[sourceParts[i]]) {
                                sourceFolder = sourceFolder.contents[sourceParts[i]];
                            }
                        }

                        if (sourceFolder.contents && sourceFolder.contents[name]) {
                            delete sourceFolder.contents[name];
                        }
                    }

                    if (window.toastManager) {
                        const operation = this.clipboard.operation === 'cut' ? 'Moved' : 'Copied';
                        window.toastManager.show(operation, `"${targetName}" pasted successfully.`);
                    }
                });

                // Clear clipboard if cut operation
                if (this.clipboard.operation === 'cut') {
                    this.clipboard.items = [];
                    this.clipboard.operation = null;
                    this.clipboard.source = null;
                }

                // Refresh explorer
                this.renderExplorer();
            }

            explorerDeleteSelected() {
                if (!this.selectedExplorerItem) {
                    if (window.dialogManager) {
                        window.dialogManager.warning('Please select a file or folder to delete.', 'Delete');
                    }
                    return;
                }

                const { name, item } = this.selectedExplorerItem;
                const itemType = item.type === 'folder' ? 'Folder' : 'File';

                // Show confirmation dialog
                window.dialogManager.confirm(
                    `Are you sure you want to send "${name}" to the Recycle Bin?`,
                    'Confirm Delete',
                    (result) => {
                        if (result === 'Yes') {
                            this.performDeleteOperation(name, item, itemType);
                        }
                    }
                );
            }

            performDeleteOperation(name, item, itemType) {

                // Get current folder contents for deletion
                const parts = this.currentPath.split('\\').filter(p => p);
                let current = this.fileSystem['C:\\'];

                for (let i = 1; i < parts.length; i++) {
                    if (current.contents && current.contents[parts[i]]) {
                        current = current.contents[parts[i]];
                    }
                }

                // Move to recycle bin
                const icon = item.type === 'folder' ? '📁' : '📄';
                const size = item.size || (item.type === 'folder' ? `${Object.keys(item.contents || {}).length} items` : '0 KB');
                this.moveToRecycleBin(name, itemType, size, icon);

                // Remove from file system
                if (current.contents && current.contents[name]) {
                    delete current.contents[name];
                }

                // Clear selection and refresh
                this.selectedExplorerItem = null;
                this.renderExplorer();

                if (window.toastManager) {
                    window.toastManager.show('Deleted', `"${name}" moved to Recycle Bin.`);
                }
            }

            // ============================================
            // RECYCLE BIN - Simulated deleted files system
            // ============================================

            openRecycleBin() {
                const deletedItems = this.loadRecycleBin();
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px 4px; border-bottom: 1px solid #808080; font-size: 11px;';
                menuBar.innerHTML = `<span style="padding: 2px 8px;">File</span><span style="padding: 2px 8px;">Edit</span><span style="padding: 2px 8px;">View</span>`;

                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 1px solid #808080; display: flex; gap: 4px;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.recycleBinRestore()">↩️ Restore</button>
                    <button class="btn" onclick="emulator.recycleBinDelete()">🗑️ Delete</button>
                    <button class="btn" onclick="emulator.recycleBinEmpty()">🧹 Empty</button>
                    <button class="btn" onclick="emulator.recycleBinRefresh()">🔄 Refresh</button>
                `;

                const fileList = document.createElement('div');
                fileList.id = 'recycle-bin-list';
                fileList.style.cssText = 'flex: 1; background: white; border: 2px inset; margin: 8px; overflow-y: auto; font-size: 11px;';

                const statusBar = document.createElement('div');
                statusBar.id = 'recycle-bin-status';
                statusBar.style.cssText = 'background: var(--button-face); border-top: 1px solid #808080; padding: 4px 8px; font-size: 11px;';
                statusBar.innerHTML = `${deletedItems.length} item(s)`;

                content.appendChild(menuBar);
                content.appendChild(toolbar);
                content.appendChild(fileList);
                content.appendChild(statusBar);

                this.windowManager.createWindow('Recycle Bin', content, { width: 600, height: 400 });
                this.recycleBinRefresh();
            }

            loadRecycleBin() {
                const saved = SafeStorage.getItem('win95-recycle-bin');
                return saved ? (JSON.parse(saved) || []) : [];
            }

            saveRecycleBin(items) {
                SafeStorage.setItem('win95-recycle-bin', JSON.stringify(items));
            }

            recycleBinRefresh() {
                const fileList = document.getElementById('recycle-bin-list');
                if (!fileList) return;
                const deletedItems = this.loadRecycleBin();
                fileList.innerHTML = `<div style="background: #000080; color: white; padding: 6px; font-weight: bold; display: grid; grid-template-columns: 2fr 1fr 1fr 2fr; border-bottom: 1px solid #808080;"><div>Name</div><div>Type</div><div>Size</div><div>Date Deleted</div></div>`;
                if (deletedItems.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'padding: 40px; text-align: center; color: #808080;';
                    emptyMsg.innerHTML = `<div style="font-size: 48px; margin-bottom: 12px;">🗑️</div><div>Recycle Bin is empty</div>`;
                    fileList.appendChild(emptyMsg);
                } else {
                    deletedItems.forEach((item, index) => {
                        const row = document.createElement('div');
                        row.className = 'recycle-bin-row';
                        row.dataset.index = index;
                        row.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr 2fr; padding: 6px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        row.innerHTML = `<div>${item.icon || '📄'} ${item.name}</div><div>${item.type}</div><div>${item.size}</div><div>${item.dateDeleted}</div>`;
                        row.onclick = () => {
                            fileList.querySelectorAll('.recycle-bin-row').forEach(r => { r.style.background = 'white'; r.style.color = 'black'; });
                            row.style.background = '#000080';
                            row.style.color = 'white';
                            this.selectedRecycleBinItem = index;
                        };
                        row.ondblclick = () => this.recycleBinRestore();
                        fileList.appendChild(row);
                    });
                }
                const statusBar = document.getElementById('recycle-bin-status');
                if (statusBar) statusBar.innerHTML = `${deletedItems.length} item(s)`;
            }

            recycleBinRestore() {
                if (this.selectedRecycleBinItem === undefined) {
                    window.dialogManager.warning('Please select an item to restore.', 'Recycle Bin');
                    return;
                }
                const deletedItems = this.loadRecycleBin();
                const item = deletedItems[this.selectedRecycleBinItem];
                if (item) {
                    window.dialogManager.confirm(`Restore "${item.name}"?`, 'Recycle Bin', (button) => {
                        if (button === 'Yes') {
                            deletedItems.splice(this.selectedRecycleBinItem, 1);
                            this.saveRecycleBin(deletedItems);
                            this.selectedRecycleBinItem = undefined;
                            this.recycleBinRefresh();
                            if (window.toastManager) window.toastManager.show('Restored', `"${item.name}" has been restored.`);
                        }
                    });
                }
            }

            recycleBinDelete() {
                if (this.selectedRecycleBinItem === undefined) {
                    window.dialogManager.warning('Please select an item to delete.', 'Recycle Bin');
                    return;
                }
                const deletedItems = this.loadRecycleBin();
                const item = deletedItems[this.selectedRecycleBinItem];
                if (item) {
                    window.dialogManager.confirm(`Permanently delete "${item.name}"?`, 'Recycle Bin', (button) => {
                        if (button === 'Yes') {
                            deletedItems.splice(this.selectedRecycleBinItem, 1);
                            this.saveRecycleBin(deletedItems);
                            this.selectedRecycleBinItem = undefined;
                            this.recycleBinRefresh();
                            if (window.toastManager) window.toastManager.show('Deleted', `"${item.name}" permanently deleted.`);
                        }
                    });
                }
            }

            recycleBinEmpty() {
                const deletedItems = this.loadRecycleBin();
                if (deletedItems.length === 0) {
                    window.dialogManager.info('Recycle Bin is already empty.', 'Recycle Bin');
                    return;
                }
                window.dialogManager.confirm(`Empty Recycle Bin? (${deletedItems.length} items)`, 'Recycle Bin', (button) => {
                    if (button === 'Yes') {
                        this.saveRecycleBin([]);
                        this.selectedRecycleBinItem = undefined;
                        this.recycleBinRefresh();
                        if (window.toastManager) window.toastManager.show('Emptied', 'Recycle Bin has been emptied.');
                    }
                });
            }

            moveToRecycleBin(name, type = 'File', size = '1 KB', icon = '📄') {
                const deletedItems = this.loadRecycleBin();
                const now = new Date();
                deletedItems.push({ name, type, size, icon, dateDeleted: now.toLocaleString() });
                this.saveRecycleBin(deletedItems);
                if (document.getElementById('recycle-bin-list')) this.recycleBinRefresh();
            }

            openDOSPrompt() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';

                const output = document.createElement('div');
                output.id = 'terminal-output';
                output.style.cssText = 'flex: 1; padding: 8px; overflow-y: auto; white-space: pre-wrap;';
                output.innerHTML = `Linux Terminal Emulator v1.0
Type 'help' for available commands

user@win95:~$ `;

                const inputLine = document.createElement('div');
                inputLine.style.cssText = 'display: flex; padding: 0 8px 8px 8px;';
                inputLine.innerHTML = `
                    <span id="terminal-prompt" style="margin-right: 4px; color: #0f0;">user@win95:~$</span>
                    <input type="text" id="terminal-input" style="flex: 1; background: #000; color: #0f0; border: none; outline: none; font-family: 'Courier New', monospace; font-size: 13px;">
                `;

                content.appendChild(output);
                content.appendChild(inputLine);

                this.windowManager.createWindow('Linux Terminal', content, { width: 700, height: 450 });

                // Initialize Linux terminal
                this.initLinuxTerminal();
            }

            initLinuxTerminal() {
                // Load filesystem from localStorage or use default
                const savedFS = SafeStorage.getItem('win95-linux-filesystem');

                if (savedFS) {
                    try {
                        this.linuxFS = JSON.parse(savedFS);
                    } catch (error) {
                        console.error('Failed to load filesystem, using default:', error);
                        this.initDefaultLinuxFS();
                    }
                } else {
                    this.initDefaultLinuxFS();
                }

                // Load terminal history
                const savedHistory = SafeStorage.getItem('win95-terminal-history');
                if (savedHistory) {
                    try {
                        this.terminalHistory = JSON.parse(savedHistory);
                    } catch (error) {
                        this.terminalHistory = [];
                    }
                } else {
                    this.terminalHistory = [];
                }

                this.terminalCwd = '/home/user';
                this.terminalHistoryIndex = -1;
                this.terminalEnv = {
                    USER: 'user',
                    HOME: '/home/user',
                    PATH: '/bin:/usr/bin',
                    PWD: '/home/user'
                };

                const input = document.getElementById('terminal-input');
                const prompt = document.getElementById('terminal-prompt');

                if (input) {
                    input.focus();

                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            const command = input.value.trim();
                            if (command) {
                                this.terminalHistory.push(command);
                                this.terminalHistoryIndex = this.terminalHistory.length;
                                this.saveTerminalHistory(); // Save history after each command
                                this.executeLinuxCommand(command);
                            } else {
                                this.terminalPrint('');
                            }
                            input.value = '';
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            if (this.terminalHistoryIndex > 0) {
                                this.terminalHistoryIndex--;
                                input.value = this.terminalHistory[this.terminalHistoryIndex];
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (this.terminalHistoryIndex < this.terminalHistory.length - 1) {
                                this.terminalHistoryIndex++;
                                input.value = this.terminalHistory[this.terminalHistoryIndex];
                            } else {
                                this.terminalHistoryIndex = this.terminalHistory.length;
                                input.value = '';
                            }
                        } else if (e.key === 'Tab') {
                            e.preventDefault();
                            // Tab completion could be added here
                        }
                    });
                }
            }

            initDefaultLinuxFS() {
                // Initialize default filesystem structure
                this.linuxFS = {
                    '/': {
                        type: 'dir',
                        contents: {
                            'home': {
                                type: 'dir',
                                contents: {
                                    'user': {
                                        type: 'dir',
                                        contents: {
                                            'welcome.txt': { type: 'file', content: 'Welcome to the Linux Terminal Emulator!\nType commands like ls, cat, echo, etc.\nFiles you create will be saved automatically.' },
                                            'notes.txt': { type: 'file', content: 'This is a persistent text file.\nYour changes are saved automatically!' }
                                        }
                                    }
                                }
                            },
                            'bin': { type: 'dir', contents: {} },
                            'etc': { type: 'dir', contents: {} },
                            'var': { type: 'dir', contents: {} },
                            'tmp': { type: 'dir', contents: {} }
                        }
                    }
                };
                this.saveLinuxFilesystem();
            }

            saveLinuxFilesystem() {
                // Save filesystem to localStorage
                try {
                    SafeStorage.setItem('win95-linux-filesystem', JSON.stringify(this.linuxFS));
                } catch (error) {
                    console.error('Failed to save filesystem:', error);
                }
            }

            saveTerminalHistory() {
                // Save terminal history to localStorage
                try {
                    // Keep only last 100 commands to avoid storage limits
                    const historyToSave = this.terminalHistory.slice(-100);
                    SafeStorage.setItem('win95-terminal-history', JSON.stringify(historyToSave));
                } catch (error) {
                    console.error('Failed to save terminal history:', error);
                }
            }

            resetLinuxFilesystem() {
                // Reset to default filesystem (utility command)
                window.dialogManager.confirm(
                    'Reset filesystem to default? All files will be lost.',
                    'Terminal',
                    (button) => {
                        if (button === 'Yes') {
                            this.initDefaultLinuxFS();
                            this.terminalPrint('Filesystem reset to default', '#0f0');
                        } else {
                            this.terminalPrint('Reset cancelled', '#ff0');
                        }
                    }
                );
                return '';
            }

            terminalPrint(text, color = '#0f0') {
                const output = document.getElementById('terminal-output');
                if (!output) return;

                const promptText = this.getTerminalPrompt();
                output.innerHTML += `<span style="color: ${color}">${text}</span>\n${promptText}`;
                output.scrollTop = output.scrollHeight;
            }

            getTerminalPrompt() {
                const shortPath = this.terminalCwd.replace('/home/user', '~');
                return `<span style="color: #0f0;">user@win95</span>:<span style="color: #00f;">${shortPath}</span>$ `;
            }

            executeLinuxCommand(cmdLine) {
                const output = document.getElementById('terminal-output');
                const prompt = document.getElementById('terminal-prompt');

                if (!output) return;

                // Echo command
                output.innerHTML += cmdLine + '\n';

                const parts = cmdLine.trim().split(/\s+/);
                const cmd = parts[0];
                const args = parts.slice(1);

                let response = '';

                switch (cmd) {
                    case 'help':
                        response = `Available commands:

File Operations:
  ls [-la]          - List directory contents
  cd <dir>          - Change directory
  pwd               - Print working directory
  cat <file>        - Display file contents
  mkdir <dir>       - Create directory
  touch <file>      - Create empty file
  rm <file>         - Remove file
  tree              - Show directory tree
  find <dir>        - Search for files
  grep <pat> <file> - Search in files

System Info:
  whoami            - Print current user
  hostname          - Print system name
  uname [-a]        - Print system information
  date              - Display date and time
  uptime            - Show system uptime
  env               - Show environment variables
  export VAR=value  - Set environment variable

Process Management:
  ps                - Show processes
  top               - Display system resource usage
  df                - Show disk usage
  free              - Display memory usage
  which <cmd>       - Locate command

Utilities:
  echo <text>       - Print text
  history           - Show command history
  cal               - Display calendar
  cowsay <text>     - ASCII cow speaks
  fortune           - Random fortune cookie
  clear             - Clear screen
  reset             - Reset filesystem to default
  exit              - Close terminal`;
                        break;

                    case 'ls':
                        response = this.terminalLs(args);
                        break;

                    case 'cd':
                        response = this.terminalCd(args[0] || this.terminalEnv.HOME);
                        break;

                    case 'pwd':
                        response = this.terminalCwd;
                        break;

                    case 'cat':
                        response = this.terminalCat(args[0]);
                        break;

                    case 'echo':
                        response = args.join(' ');
                        break;

                    case 'mkdir':
                        response = this.terminalMkdir(args[0]);
                        break;

                    case 'touch':
                        response = this.terminalTouch(args[0]);
                        break;

                    case 'rm':
                        response = this.terminalRm(args[0]);
                        break;

                    case 'clear':
                        output.innerHTML = this.getTerminalPrompt();
                        if (prompt) prompt.innerHTML = this.getTerminalPrompt();
                        return;

                    case 'whoami':
                        response = this.terminalEnv.USER;
                        break;

                    case 'uname':
                        if (args[0] === '-a') {
                            response = 'Linux win95 5.15.0 #1 SMP x86_64 GNU/Linux';
                        } else {
                            response = 'Linux';
                        }
                        break;

                    case 'date':
                        response = new Date().toString();
                        break;

                    case 'env':
                        response = Object.entries(this.terminalEnv)
                            .map(([k, v]) => `${k}=${v}`)
                            .join('\n');
                        break;

                    case 'export':
                        if (args[0]) {
                            const [key, value] = args[0].split('=');
                            this.terminalEnv[key] = value || '';
                            response = '';
                        } else {
                            response = 'Usage: export VAR=value';
                        }
                        break;

                    case 'tree':
                        response = this.terminalTree();
                        break;

                    case 'grep':
                        response = this.terminalGrep(args);
                        break;

                    case 'find':
                        response = this.terminalFind(args[0] || this.terminalCwd);
                        break;

                    case 'ps':
                        response = this.terminalPs();
                        break;

                    case 'top':
                        response = this.terminalTop();
                        break;

                    case 'df':
                        response = this.terminalDf();
                        break;

                    case 'free':
                        response = this.terminalFree();
                        break;

                    case 'history':
                        response = this.terminalHistory.map((h, i) => `  ${i + 1}  ${h}`).join('\n');
                        break;

                    case 'hostname':
                        response = 'win95';
                        break;

                    case 'uptime':
                        const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                        const hours = Math.floor(uptime / 3600);
                        const mins = Math.floor((uptime % 3600) / 60);
                        response = `up ${hours}:${String(mins).padStart(2, '0')}, 1 user, load average: 0.15, 0.10, 0.05`;
                        break;

                    case 'which':
                        if (args[0]) {
                            const cmds = ['ls', 'cd', 'pwd', 'cat', 'echo', 'mkdir', 'touch', 'rm', 'clear', 'help'];
                            response = cmds.includes(args[0]) ? `/bin/${args[0]}` : `${args[0]} not found`;
                        } else {
                            response = 'which: missing argument';
                        }
                        break;

                    case 'cal':
                        response = this.terminalCal();
                        break;

                    case 'cowsay':
                        response = this.terminalCowsay(args.join(' '));
                        break;

                    case 'fortune':
                        const fortunes = [
                            'You will have a pleasant surprise today.',
                            'A new opportunity is coming your way.',
                            'Good things come to those who code.',
                            'Your hard work will pay off soon.',
                            'Today is a perfect day to learn something new.'
                        ];
                        response = fortunes[Math.floor(Math.random() * fortunes.length)];
                        break;

                    case 'reset':
                        response = this.resetLinuxFilesystem();
                        break;

                    case 'exit':
                        const win = output?.closest('.window');
                        if (win) this.windowManager.closeWindow(win);
                        return;

                    case '':
                        response = '';
                        break;

                    default:
                        response = `bash: ${cmd}: command not found`;
                        break;
                }

                this.terminalPrint(response);

                // Update prompt
                if (prompt) {
                    const shortPath = this.terminalCwd.replace('/home/user', '~');
                    prompt.innerHTML = `<span style="color: #0f0;">user@win95</span>:<span style="color: #00f;">${shortPath}</span>$ `;
                }
            }

            terminalLs(args) {
                const showAll = args.includes('-a') || args.includes('-la');
                const longFormat = args.includes('-l') || args.includes('-la');

                const current = this.terminalGetDir(this.terminalCwd);
                if (!current || current.type !== 'dir') {
                    return 'ls: cannot access directory';
                }

                const items = Object.keys(current.contents || {});
                if (items.length === 0) return '';

                if (longFormat) {
                    return items.map(name => {
                        const item = current.contents[name];
                        const type = item.type === 'dir' ? 'd' : '-';
                        const perms = item.type === 'dir' ? 'rwxr-xr-x' : 'rw-r--r--';
                        const size = item.type === 'file' ? (item.content?.length || 0) : 4096;
                        const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        return `${type}${perms} 1 user user ${size.toString().padStart(5)} ${date} ${name}`;
                    }).join('\n');
                } else {
                    return items.join('  ');
                }
            }

            terminalCd(path) {
                if (!path) path = this.terminalEnv.HOME;

                let newPath;
                if (path.startsWith('/')) {
                    newPath = path;
                } else if (path === '..') {
                    const parts = this.terminalCwd.split('/').filter(p => p);
                    parts.pop();
                    newPath = '/' + parts.join('/');
                    if (newPath === '/') newPath = '/';
                } else if (path === '.') {
                    return '';
                } else if (path === '~') {
                    newPath = this.terminalEnv.HOME;
                } else {
                    newPath = this.terminalCwd + (this.terminalCwd.endsWith('/') ? '' : '/') + path;
                }

                const dir = this.terminalGetDir(newPath);
                if (!dir || dir.type !== 'dir') {
                    return `cd: ${path}: No such file or directory`;
                }

                this.terminalCwd = newPath === '' ? '/' : newPath;
                this.terminalEnv.PWD = this.terminalCwd;
                return '';
            }

            terminalCat(filename) {
                if (!filename) return 'cat: missing file operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const file = this.terminalGetDir(path);

                if (!file) {
                    return `cat: ${filename}: No such file or directory`;
                }

                if (file.type === 'dir') {
                    return `cat: ${filename}: Is a directory`;
                }

                return file.content || '';
            }

            terminalMkdir(dirname) {
                if (!dirname) return 'mkdir: missing operand';

                const path = dirname.startsWith('/') ? dirname : this.terminalCwd + '/' + dirname;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `mkdir: cannot create directory '${dirname}': No such file or directory`;
                }

                if (parent.contents[name]) {
                    return `mkdir: cannot create directory '${dirname}': File exists`;
                }

                parent.contents[name] = { type: 'dir', contents: {} };
                this.saveLinuxFilesystem(); // Save after modification
                return '';
            }

            terminalTouch(filename) {
                if (!filename) return 'touch: missing file operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `touch: cannot touch '${filename}': No such file or directory`;
                }

                if (!parent.contents[name]) {
                    parent.contents[name] = { type: 'file', content: '' };
                    this.saveLinuxFilesystem(); // Save after modification
                }

                return '';
            }

            terminalRm(filename) {
                if (!filename) return 'rm: missing operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `rm: cannot remove '${filename}': No such file or directory`;
                }

                if (!parent.contents[name]) {
                    return `rm: cannot remove '${filename}': No such file or directory`;
                }

                if (parent.contents[name].type === 'dir') {
                    return `rm: cannot remove '${filename}': Is a directory`;
                }

                delete parent.contents[name];
                this.saveLinuxFilesystem(); // Save after modification
                return '';
            }

            terminalTree(dir = this.terminalCwd, prefix = '', isLast = true) {
                const current = this.terminalGetDir(dir);
                if (!current || current.type !== 'dir') return '';

                let result = '';
                const items = Object.keys(current.contents || {});

                items.forEach((name, index) => {
                    const item = current.contents[name];
                    const isLastItem = index === items.length - 1;
                    const connector = isLastItem ? '└── ' : '├── ';
                    const icon = item.type === 'dir' ? '📁' : '📄';

                    result += prefix + connector + icon + ' ' + name + '\n';

                    if (item.type === 'dir') {
                        const newPrefix = prefix + (isLastItem ? '    ' : '│   ');
                        const subPath = dir + (dir.endsWith('/') ? '' : '/') + name;
                        result += this.terminalTree(subPath, newPrefix, isLastItem);
                    }
                });

                return result;
            }

            terminalGetDir(path) {
                if (!path || path === '/') return this.linuxFS['/'];

                const parts = path.split('/').filter(p => p);
                let current = this.linuxFS['/'];

                for (const part of parts) {
                    if (!current.contents || !current.contents[part]) {
                        return null;
                    }
                    current = current.contents[part];
                }

                return current;
            }

            terminalGrep(args) {
                if (args.length < 2) return 'grep: usage: grep PATTERN FILE';

                const pattern = args[0];
                const filename = args[1];

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const file = this.terminalGetDir(path);

                if (!file) return `grep: ${filename}: No such file or directory`;
                if (file.type === 'dir') return `grep: ${filename}: Is a directory`;

                const lines = (file.content || '').split('\n');
                const matches = lines.filter(line => line.includes(pattern));

                return matches.length > 0 ? matches.join('\n') : '';
            }

            terminalFind(dir) {
                const results = [];
                const search = (path, item) => {
                    results.push(path);
                    if (item.type === 'dir' && item.contents) {
                        Object.keys(item.contents).forEach(name => {
                            const newPath = path + (path.endsWith('/') ? '' : '/') + name;
                            search(newPath, item.contents[name]);
                        });
                    }
                };

                const startDir = this.terminalGetDir(dir);
                if (startDir) {
                    search(dir, startDir);
                }

                return results.join('\n');
            }

            terminalPs() {
                const processes = [
                    '  PID TTY          TIME CMD',
                    '    1 ?        00:00:01 init',
                    '    2 ?        00:00:00 kthreadd',
                    '  123 pts/0    00:00:00 bash',
                    '  456 pts/0    00:00:00 ps'
                ];
                return processes.join('\n');
            }

            terminalTop() {
                return `top - ${new Date().toLocaleTimeString()} up ${Math.floor((Date.now() - this.startTime) / 60000)} min, 1 user, load average: 0.15, 0.10, 0.05

Tasks:  85 total,   1 running,  84 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.3 us,  1.0 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  ${this.settings.memory / 1024 / 1024} total,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.6)} free,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.3)} used,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.1)} buff/cache

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0    2048    512    448 S   0.0   0.1   0:01.23 init
  123 user      20   0    4096   1024    896 S   0.0   0.3   0:00.45 bash
  456 user      20   0    2560    768    640 R   1.3   0.2   0:00.01 top`;
            }

            terminalDf() {
                return `Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda1       ${Math.floor(this.settings.memory / 1024)}    ${Math.floor(this.settings.memory / 1024 * 0.4)}    ${Math.floor(this.settings.memory / 1024 * 0.6)}  40% /
tmpfs               1024     128       896  13% /tmp`;
            }

            terminalFree() {
                const total = Math.floor(this.settings.memory / 1024);
                const used = Math.floor(total * 0.3);
                const free = total - used;

                return `              total        used        free      shared  buff/cache   available
Mem:          ${total}        ${used}        ${free}           0           0        ${free}
Swap:             0           0           0`;
            }

            terminalCal() {
                const now = new Date();
                const month = now.toLocaleString('default', { month: 'long' });
                const year = now.getFullYear();
                const firstDay = new Date(year, now.getMonth(), 1).getDay();
                const daysInMonth = new Date(year, now.getMonth() + 1, 0).getDate();

                let cal = `   ${month} ${year}\n`;
                cal += 'Su Mo Tu We Th Fr Sa\n';

                let day = 1;
                let week = '';

                // Add spaces for days before first day of month
                for (let i = 0; i < firstDay; i++) {
                    week += '   ';
                }

                // Add days
                for (let d = firstDay; d < 7 && day <= daysInMonth; d++) {
                    week += String(day).padStart(2, ' ') + ' ';
                    day++;
                }
                cal += week + '\n';

                // Rest of the weeks
                while (day <= daysInMonth) {
                    week = '';
                    for (let d = 0; d < 7 && day <= daysInMonth; d++) {
                        week += String(day).padStart(2, ' ') + ' ';
                        day++;
                    }
                    cal += week + '\n';
                }

                return cal;
            }

            terminalCowsay(message) {
                if (!message) message = 'Moo!';

                const len = message.length;
                const border = '-'.repeat(len + 2);

                return ` ${border}
< ${message} >
 ${border}
        \\   ^__^
         \\  (oo)\\_______
            (__)\\       )\\/\\
                ||----w |
                ||     ||`;
            }

            openSolitaire() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: linear-gradient(135deg, #0a5f0a 0%, #0d7d0d 100%); display: flex; flex-direction: column; height: 100%;';

                content.innerHTML = `
                    <style>
                        .sol-card {
                            transition: transform 0.2s, box-shadow 0.2s;
                            cursor: pointer;
                        }
                        .sol-card:hover {
                            transform: translateY(-5px);
                            box-shadow: 3px 3px 10px rgba(0,0,0,0.5) !important;
                        }
                        .sol-card.selected {
                            transform: translateY(-10px);
                            box-shadow: 0 0 15px rgba(255,255,100,0.8) !important;
                        }
                        .sol-pile.valid-drop {
                            background: rgba(100,255,100,0.3) !important;
                            border-color: #0f0 !important;
                        }
                    </style>
                    <div style="background: var(--button-face); padding: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border: 2px outset;">
                        <div>
                            <button class="btn" onclick="emulator.solitaireNewGame()">New Game</button>
                            <button class="btn" onclick="emulator.solitaireUndo()">Undo</button>
                            <button class="btn" onclick="emulator.solitaireHint()">Hint</button>
                        </div>
                        <div style="display: flex; gap: 12px; font-weight: bold;">
                            <span>Score: <span id="sol-score">0</span></span>
                            <span>Moves: <span id="sol-moves">0</span></span>
                            <span>Time: <span id="sol-time">0:00</span></span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 16px; justify-content: space-between;">
                        <div style="display: flex; gap: 10px;">
                            <div id="sol-stock" class="sol-pile" style="width: 70px; height: 100px; border: 2px dashed white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer;">🂠</div>
                            <div id="sol-waste" class="sol-pile" style="width: 70px; height: 100px; border: 2px dashed white; background: rgba(0,0,0,0.2); border-radius: 4px; position: relative;"></div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <div class="sol-foundation" data-suit="spades" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♠</div>
                            <div class="sol-foundation" data-suit="hearts" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♥</div>
                            <div class="sol-foundation" data-suit="clubs" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♣</div>
                            <div class="sol-foundation" data-suit="diamonds" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♦</div>
                        </div>
                    </div>

                    <div id="sol-tableau" style="display: flex; gap: 10px; flex: 1;">
                        ${Array.from({length: 7}, (_, i) => `
                            <div class="sol-column" data-column="${i}" style="flex: 1; min-height: 300px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 4px; padding: 4px; cursor: pointer; position: relative;">
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 12px; color: white; text-align: center; font-size: 11px;">
                        Goal: Move all cards to foundations (top right), building from Ace to King by suit.<br>
                        Build tableau in descending order, alternating colors. Double-click to auto-move to foundation.
                    </div>
                `;

                this.windowManager.createWindow('Solitaire', content, { width: 750, height: 600 });
                this.initSolitaire();
            }

            initSolitaire() {
                this.solitaireState = {
                    stock: [],
                    waste: [],
                    foundations: { spades: [], hearts: [], clubs: [], diamonds: [] },
                    tableau: Array.from({length: 7}, () => []),
                    selected: null,
                    moves: 0,
                    score: 0,
                    history: [],
                    startTime: Date.now(),
                    timerInterval: null
                };

                this.solitaireState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.solitaireState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    const timeEl = document.getElementById('sol-time');
                    if (timeEl) timeEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                this.solitaireNewGame();
            }

            solitaireNewGame() {
                if (!this.solitaireState) return;

                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const suitSymbols = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
                const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let deck = [];

                suits.forEach(suit => {
                    values.forEach((value, index) => {
                        deck.push({
                            suit, value,
                            rank: index + 1,
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            symbol: suitSymbols[suit],
                            faceUp: false
                        });
                    });
                });

                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                this.solitaireState.stock = [];
                this.solitaireState.waste = [];
                this.solitaireState.foundations = { spades: [], hearts: [], clubs: [], diamonds: [] };
                this.solitaireState.tableau = Array.from({length: 7}, () => []);
                this.solitaireState.selected = null;
                this.solitaireState.moves = 0;
                this.solitaireState.score = 0;
                this.solitaireState.history = [];
                this.solitaireState.startTime = Date.now();

                let cardIndex = 0;
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row <= col; row++) {
                        const card = deck[cardIndex++];
                        card.faceUp = (row === col);
                        this.solitaireState.tableau[col].push(card);
                    }
                }

                this.solitaireState.stock = deck.slice(cardIndex);
                this.playSoundEffect('deal');
                this.renderSolitaire();
            }

            solitaireUndo() {
                if (!this.solitaireState || this.solitaireState.history.length === 0) {
                    this.playSoundEffect('invalid');
                    return;
                }

                const lastState = this.solitaireState.history.pop();
                this.solitaireState.stock = JSON.parse(JSON.stringify(lastState.stock));
                this.solitaireState.waste = JSON.parse(JSON.stringify(lastState.waste));
                this.solitaireState.foundations = JSON.parse(JSON.stringify(lastState.foundations));
                this.solitaireState.tableau = JSON.parse(JSON.stringify(lastState.tableau));
                this.solitaireState.selected = null;
                this.solitaireState.moves = lastState.moves;
                this.solitaireState.score = lastState.score;
                this.playSoundEffect('place');
                this.renderSolitaire();
            }

            solitaireHint() {
                if (!this.solitaireState) return;

                for (let col = 0; col < 7; col++) {
                    const column = this.solitaireState.tableau[col];
                    if (column.length > 0) {
                        const card = column[column.length - 1];
                        if (card.faceUp && this.canMoveToFoundation(card)) {
                            window.dialogManager.info(`Try moving the ${card.value}${card.symbol} from column ${col + 1} to its foundation!`, 'Hint');
                            return;
                        }
                    }
                }

                if (this.solitaireState.waste.length > 0) {
                    const card = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                    if (this.canMoveToFoundation(card)) {
                        window.dialogManager.info(`Try moving the ${card.value}${card.symbol} from the waste pile to its foundation!`, 'Hint');
                        return;
                    }
                }

                window.dialogManager.info('Try dealing from the stock, or look for cards that can be moved between tableau columns!', 'Hint');
            }

            renderSolitaire() {
                if (!this.solitaireState) return;

                const scoreEl = document.getElementById('sol-score');
                const movesEl = document.getElementById('sol-moves');
                if (scoreEl) scoreEl.textContent = this.solitaireState.score;
                if (movesEl) movesEl.textContent = this.solitaireState.moves;

                const stockEl = document.getElementById('sol-stock');
                if (stockEl) {
                    if (this.solitaireState.stock.length > 0) {
                        stockEl.innerHTML = '🂠';
                        stockEl.style.cursor = 'pointer';
                        stockEl.onclick = () => this.solitaireDealFromStock();
                    } else {
                        stockEl.innerHTML = '↻';
                        stockEl.style.cursor = 'pointer';
                        stockEl.onclick = () => this.solitaireResetStock();
                    }
                }

                const wasteEl = document.getElementById('sol-waste');
                if (wasteEl) {
                    wasteEl.innerHTML = '';
                    if (this.solitaireState.waste.length > 0) {
                        const topCard = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                        const cardEl = document.createElement('div');
                        cardEl.innerHTML = this.renderCard(topCard);
                        cardEl.onclick = () => this.solitaireClickWaste();
                        cardEl.ondblclick = () => this.solitaireAutoMoveToFoundation('waste', -1);
                        wasteEl.appendChild(cardEl);
                    }
                }

                document.querySelectorAll('.sol-foundation').forEach(foundationEl => {
                    const suit = foundationEl.dataset.suit;
                    const cards = this.solitaireState.foundations[suit];
                    const topCard = cards[cards.length - 1];
                    if (topCard) {
                        foundationEl.innerHTML = this.renderCard(topCard);
                    } else {
                        const symbols = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
                        const color = (suit === 'hearts' || suit === 'diamonds') ? '#ff4444' : 'white';
                        foundationEl.innerHTML = `<span style="color: ${color}; font-size: 30px;">${symbols[suit]}</span>`;
                    }
                    foundationEl.onclick = () => this.solitaireClickFoundation(suit);
                });

                document.querySelectorAll('.sol-column').forEach((columnEl, colIndex) => {
                    const cards = this.solitaireState.tableau[colIndex];
                    columnEl.innerHTML = '';

                    if (cards.length === 0) {
                        columnEl.onclick = () => this.solitaireClickColumn(colIndex);
                    } else {
                        cards.forEach((card, cardIndex) => {
                            const cardEl = document.createElement('div');
                            cardEl.style.cssText = `position: absolute; top: ${cardIndex * 25}px; left: 4px;`;
                            cardEl.className = 'sol-card';

                            if (card.faceUp) {
                                cardEl.innerHTML = this.renderCard(card);
                                cardEl.onclick = (e) => {
                                    e.stopPropagation();
                                    this.solitaireClickTableauCard(colIndex, cardIndex);
                                };
                                cardEl.ondblclick = (e) => {
                                    e.stopPropagation();
                                    this.solitaireAutoMoveToFoundation('tableau', colIndex);
                                };
                            } else {
                                cardEl.innerHTML = `<div style="width: 60px; height: 85px; background: linear-gradient(135deg, #1e3a8a, #1e40af); border: 2px solid #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);"><div style="font-size: 40px; color: rgba(255,255,255,0.3);">🂠</div></div>`;
                            }
                            columnEl.appendChild(cardEl);
                        });
                    }
                });

                const totalInFoundations = Object.values(this.solitaireState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundations === 52) {
                    clearInterval(this.solitaireState.timerInterval);
                    this.playSoundEffect('win');
                    setTimeout(() => {
                        window.dialogManager.info(`🎉 You Won! Score: ${this.solitaireState.score}, Moves: ${this.solitaireState.moves}`, 'Solitaire');
                    }, 300);
                }
            }

            solitaireDealFromStock() {
                if (!this.solitaireState || this.solitaireState.stock.length === 0) return;
                this.saveHistory();
                const card = this.solitaireState.stock.pop();
                card.faceUp = true;
                this.solitaireState.waste.push(card);
                this.playSoundEffect('flip');
                this.renderSolitaire();
            }

            solitaireResetStock() {
                if (!this.solitaireState || this.solitaireState.waste.length === 0) return;
                this.saveHistory();
                this.solitaireState.stock = this.solitaireState.waste.reverse().map(card => {
                    card.faceUp = false;
                    return card;
                });
                this.solitaireState.waste = [];
                this.playSoundEffect('place');
                this.renderSolitaire();
            }

            solitaireClickWaste() {
                if (!this.solitaireState || this.solitaireState.waste.length === 0) return;
                const topCard = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                if (this.solitaireState.selected) {
                    this.solitaireState.selected = null;
                } else {
                    this.solitaireState.selected = { type: 'waste', card: topCard };
                }
                this.renderSolitaire();
            }

            solitaireClickFoundation(suit) {
                if (!this.solitaireState || !this.solitaireState.selected) return;
                const card = this.solitaireState.selected.card;
                const foundation = this.solitaireState.foundations[suit];
                if (card.suit === suit) {
                    const expectedRank = foundation.length + 1;
                    if (card.rank === expectedRank) {
                        this.saveHistory();
                        this.solitaireMoveCardToFoundation(this.solitaireState.selected, suit);
                        this.solitaireState.score += 10;
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                }
                this.renderSolitaire();
            }

            solitaireClickColumn(colIndex) {
                if (!this.solitaireState || !this.solitaireState.selected) return;
                const card = this.solitaireState.selected.card;
                if (card.rank === 13) {
                    this.saveHistory();
                    this.solitaireMoveCard(this.solitaireState.selected, { type: 'tableau', index: colIndex });
                    this.playSoundEffect('place');
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderSolitaire();
            }

            solitaireClickTableauCard(colIndex, cardIndex) {
                if (!this.solitaireState) return;
                const column = this.solitaireState.tableau[colIndex];
                const card = column[cardIndex];
                if (!card.faceUp) return;

                if (this.solitaireState.selected) {
                    const selectedCard = this.solitaireState.selected.card;
                    const targetCard = column[column.length - 1];
                    if (selectedCard.rank === targetCard.rank - 1 && selectedCard.color !== targetCard.color) {
                        this.saveHistory();
                        this.solitaireMoveCard(this.solitaireState.selected, { type: 'tableau', index: colIndex });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    if (cardIndex === column.length - 1) {
                        this.solitaireState.selected = { type: 'tableau', index: colIndex, card: card };
                    }
                }
                this.renderSolitaire();
            }

            solitaireAutoMoveToFoundation(type, index) {
                if (!this.solitaireState) return;
                let card;
                if (type === 'waste') {
                    if (this.solitaireState.waste.length === 0) return;
                    card = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                } else if (type === 'tableau') {
                    const column = this.solitaireState.tableau[index];
                    if (column.length === 0) return;
                    card = column[column.length - 1];
                    if (!card.faceUp) return;
                }

                if (this.canMoveToFoundation(card)) {
                    this.saveHistory();
                    const source = { type, index, card };
                    this.solitaireMoveCardToFoundation(source, card.suit);
                    this.solitaireState.score += 10;
                    this.playSoundEffect('place');
                    this.renderSolitaire();
                } else {
                    this.playSoundEffect('invalid');
                }
            }

            canMoveToFoundation(card) {
                const foundation = this.solitaireState.foundations[card.suit];
                const expectedRank = foundation.length + 1;
                return card.rank === expectedRank;
            }

            solitaireMoveCard(from, to) {
                if (from.type === 'waste') {
                    this.solitaireState.waste.pop();
                } else if (from.type === 'tableau') {
                    this.solitaireState.tableau[from.index].pop();
                    const column = this.solitaireState.tableau[from.index];
                    if (column.length > 0) {
                        column[column.length - 1].faceUp = true;
                    }
                }

                this.solitaireState.tableau[to.index].push(from.card);
                this.solitaireState.selected = null;
                this.solitaireState.moves++;
            }

            solitaireMoveCardToFoundation(from, suit) {
                if (from.type === 'waste') {
                    this.solitaireState.waste.pop();
                } else if (from.type === 'tableau') {
                    this.solitaireState.tableau[from.index].pop();
                    const column = this.solitaireState.tableau[from.index];
                    if (column.length > 0) {
                        column[column.length - 1].faceUp = true;
                    }
                }

                this.solitaireState.foundations[suit].push(from.card);
                this.solitaireState.selected = null;
                this.solitaireState.moves++;
            }

            saveHistory() {
                if (!this.solitaireState) return;
                if (this.solitaireState.history.length >= 20) {
                    this.solitaireState.history.shift();
                }
                this.solitaireState.history.push({
                    stock: JSON.parse(JSON.stringify(this.solitaireState.stock)),
                    waste: JSON.parse(JSON.stringify(this.solitaireState.waste)),
                    foundations: JSON.parse(JSON.stringify(this.solitaireState.foundations)),
                    tableau: JSON.parse(JSON.stringify(this.solitaireState.tableau)),
                    moves: this.solitaireState.moves,
                    score: this.solitaireState.score
                });
            }

            openFreeCell() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: linear-gradient(135deg, #0a5f0a 0%, #0d7d0d 100%); display: flex; flex-direction: column; height: 100%;';

                content.innerHTML = `
                    <div style="background: var(--button-face); padding: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border: 2px outset;">
                        <div>
                            <button class="btn" onclick="emulator.freeCellNewGame()">New Game</button>
                            <button class="btn" onclick="emulator.freeCellUndo()">Undo</button>
                            <button class="btn" onclick="emulator.freeCellHint()">Hint</button>
                        </div>
                        <div style="display: flex; gap: 12px; font-weight: bold;">
                            <span>Moves: <span id="freecell-moves">0</span></span>
                            <span>Time: <span id="freecell-time">0:00</span></span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 8px; margin-bottom: 16px; justify-content: space-between;">
                        <!-- Free Cells -->
                        <div style="display: flex; gap: 8px;">
                            <div class="freecell-cell" data-cell="0" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="1" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="2" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="3" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                        </div>

                        <!-- Foundation Piles -->
                        <div style="display: flex; gap: 8px;">
                            <div class="freecell-foundation" data-suit="spades" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♠</div>
                            <div class="freecell-foundation" data-suit="hearts" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♥</div>
                            <div class="freecell-foundation" data-suit="clubs" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♣</div>
                            <div class="freecell-foundation" data-suit="diamonds" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♦</div>
                        </div>
                    </div>

                    <!-- Tableau (8 columns) -->
                    <div id="freecell-tableau" style="display: flex; gap: 8px; flex: 1;">
                        ${Array.from({length: 8}, (_, i) => `
                            <div class="freecell-column" data-column="${i}" style="flex: 1; min-height: 300px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 4px; padding: 4px; cursor: pointer;">
                            </div>
                        `).join('')}
                    </div>
                `;

                this.windowManager.createWindow('FreeCell', content, { width: 750, height: 600 });
                this.initFreeCell();
            }

            // ============================================
            // KEEN EXPLORER - Commander Keen-style Platformer
            // ============================================
            openKeenExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000;';

                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                canvas.style.cssText = 'width: 100%; height: 100%; image-rendering: pixelated;';

                const controls = document.createElement('div');
                controls.style.cssText = 'background: var(--button-face); padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;';
                controls.innerHTML = `
                    <div><strong>Lives:</strong> <span id="keen-lives">3</span> | <strong>Score:</strong> <span id="keen-score">0</span></div>
                    <button class="btn" onclick="emulator.startKeenExplorer()">New Game</button>
                    <div><strong>Keys:</strong> Arrow Keys = Move, Space = Jump, P = Pause</div>
                `;

                content.appendChild(canvas);
                content.appendChild(controls);

                this.windowManager.createWindow('Keen Explorer', content, { width: 660, height: 560 });

                setTimeout(() => this.startKeenExplorer(), 100);
            }

            startKeenExplorer() {
                const canvas = document.querySelector('#emulator canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const livesEl = document.getElementById('keen-lives');
                const scoreEl = document.getElementById('keen-score');

                // Game state
                const game = {
                    player: { x: 100, y: 350, width: 24, height: 32, vx: 0, vy: 0, onGround: false, direction: 1 },
                    platforms: [
                        { x: 0, y: 450, width: 640, height: 30 }, // Ground
                        { x: 200, y: 380, width: 120, height: 20 },
                        { x: 380, y: 310, width: 100, height: 20 },
                        { x: 150, y: 240, width: 100, height: 20 },
                        { x: 420, y: 200, width: 120, height: 20 },
                        { x: 300, y: 130, width: 80, height: 20 }
                    ],
                    gems: [
                        { x: 240, y: 350, collected: false },
                        { x: 410, y: 280, collected: false },
                        { x: 180, y: 210, collected: false },
                        { x: 450, y: 170, collected: false },
                        { x: 320, y: 100, collected: false },
                        { x: 500, y: 420, collected: false },
                        { x: 50, y: 420, collected: false }
                    ],
                    enemies: [
                        { x: 220, y: 350, width: 20, height: 20, vx: 1.5, patrolMin: 200, patrolMax: 320 },
                        { x: 400, y: 280, width: 20, height: 20, vx: 1.5, patrolMin: 380, patrolMax: 480 },
                        { x: 430, y: 170, width: 20, height: 20, vx: 1.5, patrolMin: 420, patrolMax: 540 }
                    ],
                    flag: { x: 580, y: 350, width: 30, height: 60 },
                    keys: {},
                    lives: 3,
                    score: 0,
                    paused: false,
                    gameOver: false,
                    won: false,
                    gravity: 0.6,
                    jumpPower: -12,
                    moveSpeed: 4,
                    animFrame: 0
                };

                // Event listeners
                const keydownHandler = (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        game.paused = !game.paused;
                        e.preventDefault();
                        return;
                    }
                    game.keys[e.key] = true;
                    e.preventDefault();
                };

                const keyupHandler = (e) => {
                    game.keys[e.key] = false;
                    e.preventDefault();
                };

                document.addEventListener('keydown', keydownHandler);
                document.addEventListener('keyup', keyupHandler);

                // Game loop
                let animationId;
                const gameLoop = () => {
                    animationId = requestAnimationFrame(gameLoop);

                    if (game.paused || game.gameOver || game.won) {
                        render();
                        return;
                    }

                    update();
                    render();
                    game.animFrame++;
                };

                function update() {
                    const p = game.player;

                    // Input handling
                    if (game.keys['ArrowLeft']) {
                        p.vx = -game.moveSpeed;
                        p.direction = -1;
                    } else if (game.keys['ArrowRight']) {
                        p.vx = game.moveSpeed;
                        p.direction = 1;
                    } else {
                        p.vx *= 0.8; // Friction
                    }

                    if (game.keys[' '] && p.onGround) {
                        p.vy = game.jumpPower;
                        p.onGround = false;
                        emulator.playSoundEffect('flip');
                    }

                    // Apply gravity
                    p.vy += game.gravity;
                    p.vy = Math.min(p.vy, 15); // Terminal velocity

                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;

                    // Boundary check
                    if (p.x < 0) p.x = 0;
                    if (p.x + p.width > canvas.width) p.x = canvas.width - p.width;

                    // Platform collision
                    p.onGround = false;
                    game.platforms.forEach(platform => {
                        if (p.x + p.width > platform.x && p.x < platform.x + platform.width &&
                            p.y + p.height > platform.y && p.y + p.height < platform.y + platform.height &&
                            p.vy >= 0) {
                            p.y = platform.y - p.height;
                            p.vy = 0;
                            p.onGround = true;
                        }
                    });

                    // Gem collection
                    game.gems.forEach(gem => {
                        if (!gem.collected &&
                            Math.abs(p.x + p.width/2 - gem.x) < 20 &&
                            Math.abs(p.y + p.height/2 - gem.y) < 20) {
                            gem.collected = true;
                            game.score += 10;
                            scoreEl.textContent = game.score;
                            emulator.playSoundEffect('place');
                        }
                    });

                    // Enemy movement and collision
                    game.enemies.forEach(enemy => {
                        enemy.x += enemy.vx;
                        if (enemy.x <= enemy.patrolMin || enemy.x >= enemy.patrolMax) {
                            enemy.vx *= -1;
                        }

                        // Check collision with player
                        if (p.x + p.width > enemy.x && p.x < enemy.x + enemy.width &&
                            p.y + p.height > enemy.y && p.y < enemy.y + enemy.height) {
                            // Player hit enemy
                            game.lives--;
                            livesEl.textContent = game.lives;
                            emulator.playSoundEffect('invalid');

                            // Reset player position
                            p.x = 100;
                            p.y = 350;
                            p.vx = 0;
                            p.vy = 0;

                            if (game.lives <= 0) {
                                game.gameOver = true;
                                setTimeout(() => window.dialogManager.info('Game Over! Final Score: ' + game.score, 'Snake'), 100);
                            }
                        }
                    });

                    // Flag/goal collision
                    if (p.x + p.width > game.flag.x && p.x < game.flag.x + game.flag.width &&
                        p.y + p.height > game.flag.y && p.y < game.flag.y + game.flag.height) {
                        game.won = true;
                        emulator.playSoundEffect('win');
                        setTimeout(() => window.dialogManager.info('🎉 Level Complete! Score: ' + game.score, 'Snake'), 100);
                    }

                    // Fall off screen
                    if (p.y > canvas.height) {
                        game.lives--;
                        livesEl.textContent = game.lives;
                        p.x = 100;
                        p.y = 350;
                        p.vx = 0;
                        p.vy = 0;

                        if (game.lives <= 0) {
                            game.gameOver = true;
                            setTimeout(() => window.dialogManager.info('Game Over! Final Score: ' + game.score, 'Snake'), 100);
                        }
                    }
                }

                function render() {
                    // Clear
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Platforms
                    ctx.fillStyle = '#654321';
                    game.platforms.forEach(platform => {
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                        ctx.strokeStyle = '#8b6914';
                        ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                    });

                    // Gems
                    game.gems.forEach(gem => {
                        if (!gem.collected) {
                            const pulse = Math.sin(game.animFrame * 0.1) * 2;
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(gem.x, gem.y, 8 + pulse, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#ffed4e';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    });

                    // Enemies
                    game.enemies.forEach(enemy => {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(enemy.x + 5, enemy.y + 5, 4, 4);
                        ctx.fillRect(enemy.x + 11, enemy.y + 5, 4, 4);
                    });

                    // Flag/Goal
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(game.flag.x, game.flag.y, 5, game.flag.height);
                    ctx.fillRect(game.flag.x, game.flag.y, 25, 20);

                    // Player
                    const p = game.player;
                    ctx.fillStyle = '#00aaff';
                    ctx.fillRect(p.x, p.y, p.width, p.height);

                    // Player face (direction-based)
                    ctx.fillStyle = '#000';
                    if (p.direction === 1) {
                        ctx.fillRect(p.x + 15, p.y + 8, 4, 4); // Eye
                    } else {
                        ctx.fillRect(p.x + 5, p.y + 8, 4, 4); // Eye
                    }

                    // Legs (animated)
                    if (Math.abs(p.vx) > 0.5 && p.onGround) {
                        const legOffset = Math.sin(game.animFrame * 0.3) * 3;
                        ctx.fillStyle = '#0088cc';
                        ctx.fillRect(p.x + 5, p.y + p.height - 8, 6, 8 + legOffset);
                        ctx.fillRect(p.x + 13, p.y + p.height - 8, 6, 8 - legOffset);
                    }

                    // Paused overlay
                    if (game.paused) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                        ctx.font = '16px Arial';
                        ctx.fillText('Press P to Resume', canvas.width/2, canvas.height/2 + 40);
                    }
                }

                gameLoop();

                // Cleanup on window close
                const checkInterval = setInterval(() => {
                    if (!document.body.contains(canvas)) {
                        cancelAnimationFrame(animationId);
                        document.removeEventListener('keydown', keydownHandler);
                        document.removeEventListener('keyup', keyupHandler);
                        clearInterval(checkInterval);
                    }
                }, 1000);
            }

            // ============================================
            // GALACTIC DEFENDER - Space Shooter
            // ============================================
            openGalacticDefender() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000;';

                const canvas = document.createElement('canvas');
                canvas.width = 480;
                canvas.height = 640;
                canvas.style.cssText = 'width: 100%; height: 100%; image-rendering: pixelated;';

                const controls = document.createElement('div');
                controls.style.cssText = 'background: var(--button-face); padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;';
                controls.innerHTML = `
                    <div><strong>Lives:</strong> <span id="galactic-lives">3</span> | <strong>Score:</strong> <span id="galactic-score">0</span></div>
                    <button class="btn" onclick="emulator.startGalacticDefender()">New Game</button>
                    <div><strong>Wave:</strong> <span id="galactic-wave">1</span> | <strong>Keys:</strong> Arrows = Move, Space = Shoot</div>
                `;

                content.appendChild(canvas);
                content.appendChild(controls);

                this.windowManager.createWindow('Galactic Defender', content, { width: 500, height: 720 });

                setTimeout(() => this.startGalacticDefender(), 100);
            }

            startGalacticDefender() {
                const canvas = document.querySelector('#emulator canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const livesEl = document.getElementById('galactic-lives');
                const scoreEl = document.getElementById('galactic-score');
                const waveEl = document.getElementById('galactic-wave');

                // Game state
                const game = {
                    player: { x: 220, y: 560, width: 40, height: 40, speed: 6 },
                    bullets: [],
                    enemies: [],
                    powerups: [],
                    particles: [],
                    keys: {},
                    lives: 3,
                    score: 0,
                    wave: 1,
                    enemiesInWave: 0,
                    enemiesKilled: 0,
                    paused: false,
                    gameOver: false,
                    rapidFire: false,
                    rapidFireEnd: 0,
                    shield: false,
                    shieldEnd: 0,
                    lastShot: 0,
                    shootCooldown: 200,
                    animFrame: 0
                };

                // Spawn wave
                function spawnWave() {
                    game.enemiesInWave = 5 + game.wave * 2;
                    game.enemiesKilled = 0;

                    for (let i = 0; i < game.enemiesInWave; i++) {
                        setTimeout(() => {
                            const type = Math.random() < 0.7 ? 'basic' : 'fast';
                            game.enemies.push({
                                x: Math.random() * (canvas.width - 30),
                                y: -30,
                                width: 30,
                                height: 30,
                                speed: type === 'basic' ? 1.5 : 3,
                                health: type === 'basic' ? 1 : 2,
                                type: type,
                                vx: (Math.random() - 0.5) * 2
                            });
                        }, i * 1000);
                    }

                    // Boss every 5 waves
                    if (game.wave % 5 === 0) {
                        setTimeout(() => {
                            game.enemies.push({
                                x: canvas.width / 2 - 40,
                                y: -80,
                                width: 80,
                                height: 80,
                                speed: 0.5,
                                health: 20,
                                type: 'boss',
                                vx: 2
                            });
                        }, game.enemiesInWave * 1000);
                    }
                }

                spawnWave();

                // Event listeners
                const keydownHandler = (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        game.paused = !game.paused;
                        e.preventDefault();
                        return;
                    }
                    game.keys[e.key] = true;
                    e.preventDefault();
                };

                const keyupHandler = (e) => {
                    game.keys[e.key] = false;
                    e.preventDefault();
                };

                document.addEventListener('keydown', keydownHandler);
                document.addEventListener('keyup', keyupHandler);

                // Game loop
                let animationId;
                const gameLoop = () => {
                    animationId = requestAnimationFrame(gameLoop);

                    if (game.paused || game.gameOver) {
                        render();
                        return;
                    }

                    update();
                    render();
                    game.animFrame++;
                };

                function update() {
                    const now = Date.now();

                    // Player movement
                    if (game.keys['ArrowLeft']) game.player.x -= game.player.speed;
                    if (game.keys['ArrowRight']) game.player.x += game.player.speed;
                    if (game.keys['ArrowUp']) game.player.y -= game.player.speed;
                    if (game.keys['ArrowDown']) game.player.y += game.player.speed;

                    // Boundaries
                    game.player.x = Math.max(0, Math.min(canvas.width - game.player.width, game.player.x));
                    game.player.y = Math.max(canvas.height / 2, Math.min(canvas.height - game.player.height, game.player.y));

                    // Shooting
                    const cooldown = game.rapidFire ? 100 : game.shootCooldown;
                    if (game.keys[' '] && now - game.lastShot > cooldown) {
                        game.bullets.push({
                            x: game.player.x + game.player.width / 2 - 2,
                            y: game.player.y,
                            width: 4,
                            height: 15,
                            speed: -10
                        });
                        game.lastShot = now;
                        emulator.playSoundEffect('flip');
                    }

                    // Update bullets
                    game.bullets = game.bullets.filter(bullet => {
                        bullet.y += bullet.speed;
                        return bullet.y > -20;
                    });

                    // Update enemies
                    game.enemies.forEach(enemy => {
                        enemy.y += enemy.speed;
                        enemy.x += enemy.vx;

                        // Boss side-to-side movement
                        if (enemy.type === 'boss') {
                            if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
                                enemy.vx *= -1;
                            }
                        }

                        // Boundary bounce
                        if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
                            enemy.vx *= -1;
                        }

                        // Check collision with player
                        if (!game.shield &&
                            game.player.x < enemy.x + enemy.width &&
                            game.player.x + game.player.width > enemy.x &&
                            game.player.y < enemy.y + enemy.height &&
                            game.player.y + game.player.height > enemy.y) {
                            game.lives--;
                            livesEl.textContent = game.lives;
                            enemy.health = 0; // Destroy enemy
                            emulator.playSoundEffect('invalid');
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                            if (game.lives <= 0) {
                                game.gameOver = true;
                                setTimeout(() => window.dialogManager.info('Game Over! Final Score: ' + game.score, 'Space Invaders'), 100);
                            }
                        }
                    });

                    // Bullet-enemy collision
                    game.bullets.forEach((bullet, bi) => {
                        game.enemies.forEach((enemy, ei) => {
                            if (bullet.x < enemy.x + enemy.width &&
                                bullet.x + bullet.width > enemy.x &&
                                bullet.y < enemy.y + enemy.height &&
                                bullet.y + bullet.height > enemy.y) {
                                enemy.health--;
                                bullet.y = -100; // Remove bullet

                                if (enemy.health <= 0) {
                                    const points = enemy.type === 'boss' ? 100 : enemy.type === 'fast' ? 20 : 10;
                                    game.score += points;
                                    scoreEl.textContent = game.score;
                                    game.enemiesKilled++;
                                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                    emulator.playSoundEffect('place');

                                    // Drop powerup chance
                                    if (Math.random() < 0.15) {
                                        const types = ['rapidfire', 'shield', 'life'];
                                        game.powerups.push({
                                            x: enemy.x,
                                            y: enemy.y,
                                            width: 20,
                                            height: 20,
                                            type: types[Math.floor(Math.random() * types.length)]
                                        });
                                    }
                                }
                            }
                        });
                    });

                    // Remove dead enemies
                    game.enemies = game.enemies.filter(e => e.health > 0 && e.y < canvas.height + 50);

                    // Update powerups
                    game.powerups = game.powerups.filter(powerup => {
                        powerup.y += 2;

                        // Check collection
                        if (game.player.x < powerup.x + powerup.width &&
                            game.player.x + game.player.width > powerup.x &&
                            game.player.y < powerup.y + powerup.height &&
                            game.player.y + game.player.height > powerup.y) {

                            if (powerup.type === 'rapidfire') {
                                game.rapidFire = true;
                                game.rapidFireEnd = now + 5000;
                            } else if (powerup.type === 'shield') {
                                game.shield = true;
                                game.shieldEnd = now + 5000;
                            } else if (powerup.type === 'life') {
                                game.lives++;
                                livesEl.textContent = game.lives;
                            }
                            emulator.playSoundEffect('place');
                            return false;
                        }

                        return powerup.y < canvas.height;
                    });

                    // Update particles
                    game.particles = game.particles.filter(p => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                        return p.life > 0;
                    });

                    // Check powerup expiration
                    if (game.rapidFire && now > game.rapidFireEnd) game.rapidFire = false;
                    if (game.shield && now > game.shieldEnd) game.shield = false;

                    // Check wave completion
                    if (game.enemies.length === 0 && game.enemiesKilled >= game.enemiesInWave) {
                        game.wave++;
                        waveEl.textContent = game.wave;
                        spawnWave();
                    }
                }

                function createExplosion(x, y) {
                    for (let i = 0; i < 20; i++) {
                        game.particles.push({
                            x: x,
                            y: y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 30,
                            color: Math.random() < 0.5 ? '#ff6600' : '#ffff00'
                        });
                    }
                }

                function render() {
                    // Clear with star field
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Stars
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 50; i++) {
                        const x = (i * 37) % canvas.width;
                        const y = ((i * 57 + game.animFrame * 2) % canvas.height);
                        ctx.fillRect(x, y, 1, 1);
                    }

                    // Powerups
                    game.powerups.forEach(powerup => {
                        const colors = { rapidfire: '#00ff00', shield: '#00ffff', life: '#ff00ff' };
                        ctx.fillStyle = colors[powerup.type];
                        ctx.fillRect(powerup.x, powerup.y, powerup.width, powerup.height);
                        ctx.strokeStyle = '#fff';
                        ctx.strokeRect(powerup.x, powerup.y, powerup.width, powerup.height);
                    });

                    // Particles
                    game.particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.fillRect(p.x, p.y, 3, 3);
                    });

                    // Bullets
                    ctx.fillStyle = '#00ff00';
                    game.bullets.forEach(bullet => {
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    });

                    // Enemies
                    game.enemies.forEach(enemy => {
                        if (enemy.type === 'boss') {
                            ctx.fillStyle = '#ff0000';
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(enemy.x + 15, enemy.y + 20, 20, 20);
                            ctx.fillRect(enemy.x + 45, enemy.y + 20, 20, 20);
                            // Health bar
                            ctx.fillStyle = '#ff0000';
                            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                            ctx.fillStyle = '#00ff00';
                            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / 20), 5);
                        } else {
                            ctx.fillStyle = enemy.type === 'fast' ? '#ff00ff' : '#ff6600';
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(enemy.x + 5, enemy.y + 8, 8, 8);
                            ctx.fillRect(enemy.x + 17, enemy.y + 8, 8, 8);
                        }
                    });

                    // Player
                    ctx.fillStyle = game.shield ? '#00ffff' : '#00aaff';
                    ctx.beginPath();
                    ctx.moveTo(game.player.x + game.player.width / 2, game.player.y);
                    ctx.lineTo(game.player.x, game.player.y + game.player.height);
                    ctx.lineTo(game.player.x + game.player.width, game.player.y + game.player.height);
                    ctx.closePath();
                    ctx.fill();

                    // Shield effect
                    if (game.shield) {
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(game.player.x + game.player.width/2, game.player.y + game.player.height/2,
                               game.player.width/2 + 10 + Math.sin(game.animFrame * 0.2) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Rapid fire indicator
                    if (game.rapidFire) {
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText('RAPID FIRE', 10, canvas.height - 10);
                    }

                    // Paused overlay
                    if (game.paused) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                    }
                }

                gameLoop();

                // Cleanup on window close
                const checkInterval = setInterval(() => {
                    if (!document.body.contains(canvas)) {
                        cancelAnimationFrame(animationId);
                        document.removeEventListener('keydown', keydownHandler);
                        document.removeEventListener('keyup', keyupHandler);
                        clearInterval(checkInterval);
                    }
                }, 1000);
            }

            // ============================================
            // SNAKE CLASSIC
            // ============================================
            openSnakeClassic() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 20px; text-align: center;';

                content.innerHTML = `
                    <h3 style="margin-top: 0;">Select Difficulty</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin: 20px 0;">
                        <button class="btn primary" onclick="emulator.startSnakeGame('easy')" style="padding: 12px;">Easy (Slow)</button>
                        <button class="btn primary" onclick="emulator.startSnakeGame('medium')" style="padding: 12px;">Medium (Normal)</button>
                        <button class="btn primary" onclick="emulator.startSnakeGame('hard')" style="padding: 12px;">Hard (Fast)</button>
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #808080; text-align: left; font-size: 11px;">
                        <strong>High Scores:</strong><br>
                        Easy: <span id="snake-high-easy">0</span><br>
                        Medium: <span id="snake-high-medium">0</span><br>
                        Hard: <span id="snake-high-hard">0</span>
                    </div>
                `;

                // Load high scores
                const scores = this.loadSnakeHighScores();
                setTimeout(() => {
                    document.getElementById('snake-high-easy').textContent = scores.easy;
                    document.getElementById('snake-high-medium').textContent = scores.medium;
                    document.getElementById('snake-high-hard').textContent = scores.hard;
                }, 50);

                this.windowManager.createWindow('Snake Classic', content, { width: 400, height: 340 });
            }

            loadSnakeHighScores() {
                const saved = SafeStorage.getItem('win95-snake-scores');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return { easy: 0, medium: 0, hard: 0 };
                    }
                }
                return { easy: 0, medium: 0, hard: 0 };
            }

            saveSnakeHighScore(difficulty, score) {
                const scores = this.loadSnakeHighScores();
                if (score > scores[difficulty]) {
                    scores[difficulty] = score;
                    SafeStorage.setItem('win95-snake-scores', JSON.stringify(scores));
                }
            }

            startSnakeGame(difficulty) {
                const speeds = { easy: 150, medium: 100, hard: 60 };
                const speed = speeds[difficulty];

                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000;';

                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                canvas.style.cssText = 'width: 100%; height: 100%; image-rendering: pixelated;';

                const controls = document.createElement('div');
                controls.style.cssText = 'background: var(--button-face); padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;';
                controls.innerHTML = `
                    <div><strong>Score:</strong> <span id="snake-score">0</span></div>
                    <button class="btn" onclick="emulator.startSnakeGame('${difficulty}')">New Game</button>
                    <div><strong>High:</strong> <span id="snake-high">${this.loadSnakeHighScores()[difficulty]}</span></div>
                `;

                content.appendChild(canvas);
                content.appendChild(controls);

                this.windowManager.createWindow(`Snake Classic - ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`,
                                               content, { width: 420, height: 480 });

                setTimeout(() => this.runSnakeGame(canvas, difficulty, speed), 100);
            }

            runSnakeGame(canvas, difficulty, speed) {
                const ctx = canvas.getContext('2d');
                const scoreEl = document.getElementById('snake-score');
                const highEl = document.getElementById('snake-high');

                const gridSize = 20;
                const tileCount = canvas.width / gridSize;

                const game = {
                    snake: [{ x: 10, y: 10 }],
                    food: { x: 15, y: 15 },
                    dx: 1,
                    dy: 0,
                    score: 0,
                    gameOver: false,
                    nextDirection: null
                };

                function placeFood() {
                    game.food = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };

                    // Make sure food doesn't spawn on snake
                    const onSnake = game.snake.some(segment =>
                        segment.x === game.food.x && segment.y === game.food.y
                    );
                    if (onSnake) placeFood();
                }

                const keydownHandler = (e) => {
                    if (game.gameOver) return;

                    switch(e.key) {
                        case 'ArrowUp':
                            if (game.dy === 0) game.nextDirection = { dx: 0, dy: -1 };
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            if (game.dy === 0) game.nextDirection = { dx: 0, dy: 1 };
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                            if (game.dx === 0) game.nextDirection = { dx: -1, dy: 0 };
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            if (game.dx === 0) game.nextDirection = { dx: 1, dy: 0 };
                            e.preventDefault();
                            break;
                    }
                };

                document.addEventListener('keydown', keydownHandler);

                function update() {
                    if (game.gameOver) return;

                    // Apply next direction
                    if (game.nextDirection) {
                        game.dx = game.nextDirection.dx;
                        game.dy = game.nextDirection.dy;
                        game.nextDirection = null;
                    }

                    // Move snake
                    const head = {
                        x: game.snake[0].x + game.dx,
                        y: game.snake[0].y + game.dy
                    };

                    // Check wall collision
                    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                        game.gameOver = true;
                        emulator.playSoundEffect('invalid');
                        emulator.saveSnakeHighScore(difficulty, game.score);
                        setTimeout(() => window.dialogManager.info('Game Over! Score: ' + game.score, 'Snake Game'), 100);
                        return;
                    }

                    // Check self collision
                    const hitSelf = game.snake.some(segment =>
                        segment.x === head.x && segment.y === head.y
                    );
                    if (hitSelf) {
                        game.gameOver = true;
                        emulator.playSoundEffect('invalid');
                        emulator.saveSnakeHighScore(difficulty, game.score);
                        setTimeout(() => window.dialogManager.info('Game Over! Score: ' + game.score, 'Snake Game'), 100);
                        return;
                    }

                    game.snake.unshift(head);

                    // Check food collision
                    if (head.x === game.food.x && head.y === game.food.y) {
                        game.score++;
                        scoreEl.textContent = game.score;

                        // Update high score display
                        const currentHigh = parseInt(highEl.textContent);
                        if (game.score > currentHigh) {
                            highEl.textContent = game.score;
                        }

                        placeFood();
                        emulator.playSoundEffect('place');
                    } else {
                        game.snake.pop();
                    }
                }

                function render() {
                    // Background
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Grid
                    ctx.strokeStyle = '#1a1a1a';
                    for (let i = 0; i < tileCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * gridSize, 0);
                        ctx.lineTo(i * gridSize, canvas.height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, i * gridSize);
                        ctx.lineTo(canvas.width, i * gridSize);
                        ctx.stroke();
                    }

                    // Food
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(game.food.x * gridSize + 2, game.food.y * gridSize + 2,
                                gridSize - 4, gridSize - 4);

                    // Snake
                    game.snake.forEach((segment, index) => {
                        ctx.fillStyle = index === 0 ? '#00ff00' : '#00aa00';
                        ctx.fillRect(segment.x * gridSize + 1, segment.y * gridSize + 1,
                                    gridSize - 2, gridSize - 2);
                    });

                    // Game over overlay
                    if (game.gameOver) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 32px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                        ctx.font = '16px Arial';
                        ctx.fillText('Score: ' + game.score, canvas.width/2, canvas.height/2 + 40);
                    }
                }

                const gameInterval = setInterval(() => {
                    update();
                    render();
                }, speed);

                render();

                // Cleanup on window close
                const checkInterval = setInterval(() => {
                    if (!document.body.contains(canvas)) {
                        clearInterval(gameInterval);
                        document.removeEventListener('keydown', keydownHandler);
                        clearInterval(checkInterval);
                    }
                }, 1000);
            }

            initFreeCell() {
                this.freeCellState = {
                    cells: [null, null, null, null], // 4 free cells
                    foundations: { spades: [], hearts: [], clubs: [], diamonds: [] }, // 4 foundation piles
                    tableau: Array.from({length: 8}, () => []), // 8 columns
                    selected: null, // Selected card {from: 'cell'|'column'|'foundation', index: number, card: object}
                    moves: 0,
                    history: [],
                    startTime: Date.now(),
                    timerInterval: null
                };

                // Start timer
                this.freeCellState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.freeCellState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    const timeEl = document.getElementById('freecell-time');
                    if (timeEl) timeEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                // Generate and shuffle deck
                this.freeCellNewGame();
            }

            freeCellNewGame() {
                if (!this.freeCellState) return;

                // Create deck
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const suitSymbols = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
                const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let deck = [];

                suits.forEach(suit => {
                    values.forEach((value, index) => {
                        deck.push({
                            suit: suit,
                            value: value,
                            rank: index + 1,
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            symbol: suitSymbols[suit]
                        });
                    });
                });

                // Shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                // Reset state
                this.freeCellState.cells = [null, null, null, null];
                this.freeCellState.foundations = { spades: [], hearts: [], clubs: [], diamonds: [] };
                this.freeCellState.tableau = Array.from({length: 8}, () => []);
                this.freeCellState.selected = null;
                this.freeCellState.moves = 0;
                this.freeCellState.startTime = Date.now();

                // Deal cards to tableau (first 4 columns get 7 cards, last 4 get 6)
                let cardIndex = 0;
                for (let col = 0; col < 8; col++) {
                    const cardsInColumn = col < 4 ? 7 : 6;
                    for (let i = 0; i < cardsInColumn; i++) {
                        this.freeCellState.tableau[col].push(deck[cardIndex++]);
                    }
                }

                this.renderFreeCell();
            }

            renderFreeCell() {
                if (!this.freeCellState) return;

                // Update moves counter
                const movesEl = document.getElementById('freecell-moves');
                if (movesEl) movesEl.textContent = this.freeCellState.moves;

                // Render free cells with double-click auto-move
                document.querySelectorAll('.freecell-cell').forEach((cellEl, index) => {
                    const card = this.freeCellState.cells[index];
                    cellEl.innerHTML = card ? this.renderCard(card) : '';
                    cellEl.onclick = () => this.freeCellClickCell(index);
                    if (card) {
                        cellEl.ondblclick = () => this.freeCellAutoMoveToFoundation('cell', index);
                    }
                });

                // Render foundations
                document.querySelectorAll('.freecell-foundation').forEach(foundationEl => {
                    const suit = foundationEl.dataset.suit;
                    const cards = this.freeCellState.foundations[suit];
                    const topCard = cards[cards.length - 1];
                    foundationEl.innerHTML = topCard ? this.renderCard(topCard) : foundationEl.textContent;
                    foundationEl.onclick = () => this.freeCellClickFoundation(suit);
                });

                // Render tableau columns with double-click auto-move
                document.querySelectorAll('.freecell-column').forEach((columnEl, colIndex) => {
                    const cards = this.freeCellState.tableau[colIndex];
                    columnEl.innerHTML = '';

                    if (cards.length === 0) {
                        columnEl.onclick = () => this.freeCellClickColumn(colIndex);
                    } else {
                        cards.forEach((card, cardIndex) => {
                            const cardEl = document.createElement('div');
                            cardEl.style.cssText = 'margin-bottom: 20px; transition: transform 0.2s, box-shadow 0.2s; cursor: pointer;';
                            cardEl.innerHTML = this.renderCard(card);

                            // Add hover effect for last card
                            if (cardIndex === cards.length - 1) {
                                cardEl.onmouseover = () => {
                                    cardEl.style.transform = 'translateY(-5px)';
                                };
                                cardEl.onmouseout = () => {
                                    cardEl.style.transform = 'translateY(0)';
                                };
                            }

                            cardEl.onclick = (e) => {
                                e.stopPropagation();
                                this.freeCellClickTableauCard(colIndex, cardIndex);
                            };

                            // Double-click auto-move for last card
                            if (cardIndex === cards.length - 1) {
                                cardEl.ondblclick = (e) => {
                                    e.stopPropagation();
                                    this.freeCellAutoMoveToFoundation('column', colIndex);
                                };
                            }

                            columnEl.appendChild(cardEl);
                        });
                    }
                });

                // Check for win
                const totalInFoundations = Object.values(this.freeCellState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundations === 52) {
                    clearInterval(this.freeCellState.timerInterval);
                    this.playSoundEffect('win');
                    setTimeout(() => {
                        window.dialogManager.info(`🎉 You Won! Moves: ${this.freeCellState.moves}`, 'FreeCell');
                    }, 300);
                }
            }

            renderCard(card) {
                const color = card.color === 'red' ? '#ff4444' : '#000';
                return `
                    <div style="width: 50px; height: 70px; background: white; border: 2px solid #333; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 20px; color: ${color}; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-weight: bold;">
                        <div>${card.value}</div>
                        <div style="font-size: 24px;">${card.symbol}</div>
                    </div>
                `;
            }

            freeCellClickCell(index) {
                if (!this.freeCellState) return;

                if (this.freeCellState.selected) {
                    // Try to move selected card to this cell
                    if (!this.freeCellState.cells[index]) {
                        this.freeCellMoveCard(this.freeCellState.selected, { type: 'cell', index });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else if (this.freeCellState.cells[index]) {
                    // Select card from cell
                    this.freeCellState.selected = { type: 'cell', index, card: this.freeCellState.cells[index] };
                }
                this.renderFreeCell();
            }

            freeCellClickFoundation(suit) {
                if (!this.freeCellState || !this.freeCellState.selected) return;

                const selected = this.freeCellState.selected;
                const card = selected.card;
                const foundation = this.freeCellState.foundations[suit];

                // Check if card can be placed on foundation
                if (card.suit === suit) {
                    const expectedRank = foundation.length + 1;
                    if (card.rank === expectedRank) {
                        this.freeCellMoveCard(selected, { type: 'foundation', suit });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderFreeCell();
            }

            freeCellClickColumn(colIndex) {
                if (!this.freeCellState || !this.freeCellState.selected) return;

                // Try to move selected card to empty column
                if (this.freeCellState.tableau[colIndex].length === 0) {
                    this.freeCellMoveCard(this.freeCellState.selected, { type: 'column', index: colIndex });
                    this.playSoundEffect('place');
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderFreeCell();
            }

            freeCellClickTableauCard(colIndex, cardIndex) {
                if (!this.freeCellState) return;

                const column = this.freeCellState.tableau[colIndex];

                // Can only select the last card in a column
                if (cardIndex !== column.length - 1) return;

                if (this.freeCellState.selected) {
                    // Try to move selected card here
                    const targetCard = column[column.length - 1];
                    const selectedCard = this.freeCellState.selected.card;

                    // Check if move is valid (descending rank, alternating color)
                    if (selectedCard.rank === targetCard.rank - 1 && selectedCard.color !== targetCard.color) {
                        this.freeCellMoveCard(this.freeCellState.selected, { type: 'column', index: colIndex });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    // Select this card
                    this.freeCellState.selected = { type: 'column', index: colIndex, card: column[cardIndex] };
                }
                this.renderFreeCell();
            }

            freeCellAutoMoveToFoundation(type, index) {
                if (!this.freeCellState) return;

                let card;
                if (type === 'cell') {
                    card = this.freeCellState.cells[index];
                    if (!card) return;
                } else if (type === 'column') {
                    const column = this.freeCellState.tableau[index];
                    if (column.length === 0) return;
                    card = column[column.length - 1];
                }

                // Check if card can move to its foundation
                const foundation = this.freeCellState.foundations[card.suit];
                const expectedRank = foundation.length + 1;

                if (card.rank === expectedRank) {
                    const from = { type, index, card };
                    this.freeCellMoveCard(from, { type: 'foundation', suit: card.suit });
                    this.playSoundEffect('place');
                    this.renderFreeCell();
                } else {
                    this.playSoundEffect('invalid');
                }
            }

            freeCellMoveCard(from, to) {
                if (!this.freeCellState) return;

                const card = from.card;

                // Remove card from source
                if (from.type === 'cell') {
                    this.freeCellState.cells[from.index] = null;
                } else if (from.type === 'column') {
                    this.freeCellState.tableau[from.index].pop();
                } else if (from.type === 'foundation') {
                    this.freeCellState.foundations[from.suit].pop();
                }

                // Add card to destination
                if (to.type === 'cell') {
                    this.freeCellState.cells[to.index] = card;
                } else if (to.type === 'column') {
                    this.freeCellState.tableau[to.index].push(card);
                } else if (to.type === 'foundation') {
                    this.freeCellState.foundations[to.suit].push(card);
                }

                this.freeCellState.selected = null;
                this.freeCellState.moves++;
            }

            freeCellUndo() {
                this.playSoundEffect('invalid');
                window.dialogManager.info('Undo feature coming soon!', 'FreeCell');
            }

            freeCellHint() {
                window.dialogManager.info('Check if any cards can move to foundations, or try moving cards to free cells to unblock tableau columns!', 'Hint');
            }

            openMediaPlayer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                content.innerHTML = `
                    <div style="flex: 1; background: black; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <video id="media-player-video" style="max-width: 100%; max-height: 100%;" controls>
                            <source src="" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div id="media-visualization" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 48px; color: #00ff00;">
                            ♪♫♪
                        </div>
                    </div>
                    <div style="background: var(--button-face); padding: 8px; border-top: 1px solid var(--button-shadow);">
                        <div style="display: flex; gap: 4px; margin-bottom: 8px; justify-content: center;">
                            <button class="btn" onclick="emulator.mediaControl('prev')" title="Previous">⏮</button>
                            <button class="btn" onclick="emulator.mediaControl('play')" title="Play">▶</button>
                            <button class="btn" onclick="emulator.mediaControl('pause')" title="Pause">⏸</button>
                            <button class="btn" onclick="emulator.mediaControl('stop')" title="Stop">⏹</button>
                            <button class="btn" onclick="emulator.mediaControl('next')" title="Next">⏭</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 11px;">
                            <span>Volume:</span>
                            <input type="range" id="media-volume" min="0" max="100" value="70" style="flex: 1;" onchange="emulator.mediaSetVolume(this.value)">
                            <span id="media-volume-label">70%</span>
                        </div>
                        <div style="margin-top: 8px; padding: 4px; background: white; border: 1px inset; min-height: 20px; font-size: 11px;" id="media-status">
                            Ready - No media loaded
                        </div>
                    </div>
                    <div style="background: var(--button-face); padding: 4px; border-top: 1px solid var(--button-highlight); font-size: 10px; text-align: center;">
                        Drop audio/video files here to play (Feature demonstration - File API would be needed)
                    </div>
                `;

                this.windowManager.createWindow('Media Player', content, { width: 480, height: 400 });
            }

            mediaControl(action) {
                const video = document.getElementById('media-player-video');
                const status = document.getElementById('media-status');

                if (!video || !status) return;

                switch (action) {
                    case 'play':
                        if (video.src) {
                            video.play();
                            status.textContent = 'Playing...';
                        } else {
                            status.textContent = 'No media loaded';
                        }
                        break;
                    case 'pause':
                        video.pause();
                        status.textContent = 'Paused';
                        break;
                    case 'stop':
                        video.pause();
                        video.currentTime = 0;
                        status.textContent = 'Stopped';
                        break;
                    case 'prev':
                        status.textContent = 'Previous track (demo)';
                        break;
                    case 'next':
                        status.textContent = 'Next track (demo)';
                        break;
                }
            }

            mediaSetVolume(value) {
                const video = document.getElementById('media-player-video');
                const label = document.getElementById('media-volume-label');

                if (video) video.volume = value / 100;
                if (label) label.textContent = value + '%';
            }

            // WordPad - Rich Text Editor (Wave 6)
            openWordPad() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%;';

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; flex-wrap: wrap; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.wordpadNew()" title="New">📄 New</button>
                    <button class="btn" onclick="emulator.wordpadSave()" title="Save">💾 Save</button>
                    <button class="btn" onclick="emulator.wordpadLoad()" title="Load">📂 Load</button>
                    <div style="width: 1px; background: #808080; height: 20px; margin: 0 4px;"></div>
                    <button class="btn" id="wp-bold" onclick="emulator.wordpadFormat('bold')" title="Bold (Ctrl+B)" style="font-weight: bold;">B</button>
                    <button class="btn" id="wp-italic" onclick="emulator.wordpadFormat('italic')" title="Italic (Ctrl+I)" style="font-style: italic;">I</button>
                    <button class="btn" id="wp-underline" onclick="emulator.wordpadFormat('underline')" title="Underline (Ctrl+U)" style="text-decoration: underline;">U</button>
                    <div style="width: 1px; background: #808080; height: 20px; margin: 0 4px;"></div>
                    <select id="wp-font" onchange="emulator.wordpadChangeFont(this.value)" style="padding: 2px; font-family: 'MS Sans Serif', Arial, sans-serif; font-size: 11px;">
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New" selected>Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                    <select id="wp-size" onchange="emulator.wordpadChangeFontSize(this.value)" style="padding: 2px; font-family: 'MS Sans Serif', Arial, sans-serif; font-size: 11px;">
                        <option value="10">10</option>
                        <option value="12" selected>12</option>
                        <option value="14">14</option>
                        <option value="16">16</option>
                        <option value="18">18</option>
                        <option value="20">20</option>
                        <option value="24">24</option>
                    </select>
                    <div style="width: 1px; background: #808080; height: 20px; margin: 0 4px;"></div>
                    <button class="btn" onclick="emulator.wordpadAlign('left')" title="Align Left">⬅️</button>
                    <button class="btn" onclick="emulator.wordpadAlign('center')" title="Align Center">↔️</button>
                    <button class="btn" onclick="emulator.wordpadAlign('right')" title="Align Right">➡️</button>
                    <div style="width: 1px; background: #808080; height: 20px; margin: 0 4px;"></div>
                    <button class="btn" onclick="emulator.wordpadBullets()" title="Bullet Points">• List</button>
                `;

                // Editor (contenteditable div)
                const editor = document.createElement('div');
                editor.id = 'wordpad-editor';
                editor.contentEditable = 'true';
                editor.style.cssText = 'flex: 1; padding: 12px; background: white; border: none; font-family: "Courier New", monospace; font-size: 12px; outline: none; overflow-y: auto;';
                editor.innerHTML = '<p>Welcome to WordPad!</p><p>This is a rich text editor with formatting capabilities.</p>';

                // Load autosaved content if available
                const autosaved = SafeStorage.getItem('wordpad-autosave');
                if (autosaved) {
                    editor.innerHTML = autosaved;
                }

                // Autosave on input
                editor.addEventListener('input', () => {
                    SafeStorage.setItem('wordpad-autosave', editor.innerHTML);
                });

                // Handle keyboard shortcuts
                editor.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key.toLowerCase()) {
                            case 'b':
                                e.preventDefault();
                                document.execCommand('bold');
                                break;
                            case 'i':
                                e.preventDefault();
                                document.execCommand('italic');
                                break;
                            case 'u':
                                e.preventDefault();
                                document.execCommand('underline');
                                break;
                        }
                    }
                });

                // Status bar
                const statusBar = document.createElement('div');
                statusBar.style.cssText = 'background: var(--button-face); padding: 4px 8px; border-top: 1px solid var(--button-shadow); font-size: 11px; display: flex; justify-content: space-between;';
                statusBar.innerHTML = `
                    <span>Ready</span>
                    <span id="wordpad-status">Press Ctrl+B/I/U for formatting</span>
                `;

                content.appendChild(toolbar);
                content.appendChild(editor);
                content.appendChild(statusBar);

                this.windowManager.createWindow('Document - WordPad', content, { width: 600, height: 450 });
            }

            wordpadNew() {
                const editor = document.getElementById('wordpad-editor');
                if (editor && editor.textContent.trim()) {
                    window.dialogManager.confirm(
                        'Clear current document? Any unsaved changes will be lost.',
                        'WordPad',
                        (button) => {
                            if (button === 'Yes') {
                                editor.innerHTML = '<p>New document</p>';
                                SafeStorage.setItem('wordpad-autosave', editor.innerHTML);
                            }
                        }
                    );
                } else if (editor) {
                    editor.innerHTML = '<p>New document</p>';
                    SafeStorage.setItem('wordpad-autosave', editor.innerHTML);
                }
            }

            wordpadSave() {
                const editor = document.getElementById('wordpad-editor');
                if (editor) {
                    const filename = prompt('Enter filename:', 'document');
                    if (filename) {
                        SafeStorage.setItem('wordpad-file-' + filename, editor.innerHTML);
                        window.dialogManager.info(`Saved as: ${filename}`, 'WordPad');
                    }
                }
            }

            wordpadLoad() {
                const filename = prompt('Enter filename to load:');
                if (filename) {
                    const content = SafeStorage.getItem('wordpad-file-' + filename);
                    if (content !== null) {
                        const editor = document.getElementById('wordpad-editor');
                        if (editor) {
                            editor.innerHTML = content;
                            SafeStorage.setItem('wordpad-autosave', content);
                            window.dialogManager.info(`Loaded: ${filename}`, 'WordPad');
                        }
                    } else {
                        window.dialogManager.error(`File not found: ${filename}`, 'WordPad');
                    }
                }
            }

            wordpadFormat(command) {
                document.execCommand(command);
                const editor = document.getElementById('wordpad-editor');
                if (editor) {
                    editor.focus();
                }
            }

            wordpadChangeFont(font) {
                document.execCommand('fontName', false, font);
                const editor = document.getElementById('wordpad-editor');
                if (editor) {
                    editor.focus();
                }
            }

            wordpadChangeFontSize(size) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const span = document.createElement('span');
                    span.style.fontSize = size + 'px';
                    range.surroundContents(span);
                }
                const editor = document.getElementById('wordpad-editor');
                if (editor) {
                    editor.focus();
                }
            }

            wordpadAlign(alignment) {
                const alignCommands = {
                    'left': 'justifyLeft',
                    'center': 'justifyCenter',
                    'right': 'justifyRight'
                };
                document.execCommand(alignCommands[alignment]);
                const editor = document.getElementById('wordpad-editor');
                if (editor) {
                    editor.focus();
                }
            }

            wordpadBullets() {
                document.execCommand('insertUnorderedList');
                const editor = document.getElementById('wordpad-editor');
                if (editor) {
                    editor.focus();
                }
            }

            // Character Map (Wave 6)
            openCharacterMap() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; padding: 8px;';

                // Font selector
                const fontSelector = document.createElement('div');
                fontSelector.style.cssText = 'margin-bottom: 8px; display: flex; align-items: center; gap: 8px;';
                fontSelector.innerHTML = `
                    <label style="font-weight: bold;">Font:</label>
                    <select id="charmap-font" onchange="emulator.charmapChangeFont(this.value)" style="flex: 1; padding: 4px;">
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                        <option value="Wingdings">Wingdings</option>
                        <option value="Symbol">Symbol</option>
                    </select>
                `;

                // Character grid
                const gridContainer = document.createElement('div');
                gridContainer.style.cssText = 'flex: 1; overflow-y: auto; border: 2px inset; background: white; padding: 4px;';

                const grid = document.createElement('div');
                grid.id = 'charmap-grid';
                grid.style.cssText = 'display: grid; grid-template-columns: repeat(16, 1fr); gap: 2px;';

                // Generate character grid (32-255 for standard ASCII/Extended)
                for (let i = 32; i <= 255; i++) {
                    const charBtn = document.createElement('button');
                    charBtn.className = 'btn';
                    charBtn.style.cssText = 'padding: 8px 4px; font-size: 16px; min-height: 36px; font-family: Arial;';
                    charBtn.textContent = String.fromCharCode(i);
                    charBtn.title = `Code: ${i} (0x${i.toString(16).toUpperCase()})`;
                    charBtn.onclick = () => this.charmapSelectChar(String.fromCharCode(i), i);
                    grid.appendChild(charBtn);
                }

                gridContainer.appendChild(grid);

                // Selected character display
                const selectedDisplay = document.createElement('div');
                selectedDisplay.style.cssText = 'margin-top: 8px; padding: 12px; border: 2px inset; background: white; display: flex; align-items: center; gap: 12px;';
                selectedDisplay.innerHTML = `
                    <div style="flex: 1;">
                        <div style="margin-bottom: 4px; font-weight: bold;">Selected Character:</div>
                        <div id="charmap-preview" style="font-size: 48px; text-align: center; min-height: 60px; font-family: Arial;">?</div>
                    </div>
                    <div style="flex: 1;">
                        <div style="margin-bottom: 4px;"><strong>Character:</strong> <span id="charmap-char">-</span></div>
                        <div style="margin-bottom: 4px;"><strong>Dec Code:</strong> <span id="charmap-dec">-</span></div>
                        <div style="margin-bottom: 4px;"><strong>Hex Code:</strong> <span id="charmap-hex">-</span></div>
                    </div>
                `;

                // Copy button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn primary';
                copyBtn.style.cssText = 'margin-top: 8px; padding: 8px 16px; width: 100%;';
                copyBtn.textContent = '📋 Copy to Clipboard';
                copyBtn.onclick = () => this.charmapCopy();

                content.appendChild(fontSelector);
                content.appendChild(gridContainer);
                content.appendChild(selectedDisplay);
                content.appendChild(copyBtn);

                this.charmapSelectedChar = null;
                this.windowManager.createWindow('Character Map', content, { width: 520, height: 500 });
            }

            charmapChangeFont(font) {
                const grid = document.getElementById('charmap-grid');
                const preview = document.getElementById('charmap-preview');
                if (grid) {
                    const buttons = grid.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.style.fontFamily = font;
                    });
                }
                if (preview) {
                    preview.style.fontFamily = font;
                }
            }

            charmapSelectChar(char, code) {
                this.charmapSelectedChar = char;
                const preview = document.getElementById('charmap-preview');
                const charDisplay = document.getElementById('charmap-char');
                const decDisplay = document.getElementById('charmap-dec');
                const hexDisplay = document.getElementById('charmap-hex');

                if (preview) preview.textContent = char;
                if (charDisplay) charDisplay.textContent = char;
                if (decDisplay) decDisplay.textContent = code;
                if (hexDisplay) hexDisplay.textContent = '0x' + code.toString(16).toUpperCase();
            }

            charmapCopy() {
                if (this.charmapSelectedChar) {
                    // Copy to clipboard
                    navigator.clipboard.writeText(this.charmapSelectedChar).then(() => {
                        window.toastManager.show(`Copied: ${this.charmapSelectedChar}`, 'success');
                    }).catch(() => {
                        // Fallback for older browsers
                        const textarea = document.createElement('textarea');
                        textarea.value = this.charmapSelectedChar;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        window.toastManager.show(`Copied: ${this.charmapSelectedChar}`, 'success');
                    });
                } else {
                    window.dialogManager.warning('Please select a character first.', 'Character Map');
                }
            }

            // Sound Recorder (Wave 6)
            openSoundRecorder() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; padding: 12px; background: var(--button-face);';

                content.innerHTML = `
                    <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <div style="background: black; width: 100%; height: 120px; margin-bottom: 16px; border: 2px inset; position: relative; overflow: hidden;">
                            <canvas id="soundrec-waveform" width="400" height="120" style="width: 100%; height: 100%;"></canvas>
                        </div>

                        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                            <button class="btn" id="soundrec-record" onclick="emulator.soundRecControl('record')" style="padding: 8px 16px;">
                                🔴 Record
                            </button>
                            <button class="btn" id="soundrec-stop" onclick="emulator.soundRecControl('stop')" style="padding: 8px 16px;" disabled>
                                ⏹️ Stop
                            </button>
                            <button class="btn" id="soundrec-play" onclick="emulator.soundRecControl('play')" style="padding: 8px 16px;" disabled>
                                ▶️ Play
                            </button>
                        </div>

                        <div style="width: 100%; margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 4px; font-weight: bold;">Volume:</label>
                            <input type="range" id="soundrec-volume" min="0" max="100" value="80"
                                   oninput="emulator.soundRecVolume(this.value)"
                                   style="width: 100%;">
                            <div style="text-align: center; font-size: 10px;" id="soundrec-volume-label">80%</div>
                        </div>

                        <div style="padding: 12px; background: white; border: 2px inset; width: 100%; text-align: center;">
                            <div style="margin-bottom: 4px;"><strong>Status:</strong> <span id="soundrec-status">Ready</span></div>
                            <div style="margin-bottom: 4px;"><strong>Length:</strong> <span id="soundrec-length">0:00</span></div>
                            <div style="font-size: 9px; color: #666; margin-top: 8px;">
                                Note: This is a simulated sound recorder for demonstration purposes.
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #808080;">
                        <div style="display: flex; gap: 8px; justify-content: center;">
                            <button class="btn" onclick="emulator.soundRecNew()">📄 New</button>
                            <button class="btn" onclick="emulator.soundRecSave()">💾 Save</button>
                            <button class="btn" onclick="emulator.soundRecLoad()">📂 Load</button>
                        </div>
                    </div>
                `;

                this.windowManager.createWindow('Sound Recorder', content, { width: 450, height: 400 });

                // Initialize waveform
                this.soundRecState = {
                    isRecording: false,
                    isPlaying: false,
                    recordedData: [],
                    startTime: 0,
                    animationId: null
                };

                this.soundRecDrawWaveform();
            }

            soundRecControl(action) {
                const recordBtn = document.getElementById('soundrec-record');
                const stopBtn = document.getElementById('soundrec-stop');
                const playBtn = document.getElementById('soundrec-play');
                const status = document.getElementById('soundrec-status');

                switch(action) {
                    case 'record':
                        this.soundRecState.isRecording = true;
                        this.soundRecState.startTime = Date.now();
                        recordBtn.disabled = true;
                        stopBtn.disabled = false;
                        playBtn.disabled = true;
                        status.textContent = 'Recording...';
                        this.soundRecAnimate();
                        break;

                    case 'stop':
                        this.soundRecState.isRecording = false;
                        this.soundRecState.isPlaying = false;
                        if (this.soundRecState.animationId) {
                            cancelAnimationFrame(this.soundRecState.animationId);
                        }
                        recordBtn.disabled = false;
                        stopBtn.disabled = true;
                        playBtn.disabled = false;
                        status.textContent = 'Stopped';
                        break;

                    case 'play':
                        this.soundRecState.isPlaying = true;
                        this.soundRecState.startTime = Date.now();
                        recordBtn.disabled = true;
                        stopBtn.disabled = false;
                        playBtn.disabled = true;
                        status.textContent = 'Playing...';
                        this.soundRecAnimate();

                        // Auto-stop after 3 seconds
                        setTimeout(() => {
                            if (this.soundRecState.isPlaying) {
                                this.soundRecControl('stop');
                            }
                        }, 3000);
                        break;
                }
            }

            soundRecAnimate() {
                if (!this.soundRecState.isRecording && !this.soundRecState.isPlaying) return;

                const elapsed = Math.floor((Date.now() - this.soundRecState.startTime) / 1000);
                const lengthDisplay = document.getElementById('soundrec-length');
                if (lengthDisplay) {
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    lengthDisplay.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                this.soundRecDrawWaveform();
                this.soundRecState.animationId = requestAnimationFrame(() => this.soundRecAnimate());
            }

            soundRecDrawWaveform() {
                const canvas = document.getElementById('soundrec-waveform');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);

                // Draw grid
                ctx.strokeStyle = '#003300';
                ctx.lineWidth = 1;
                for (let i = 0; i < width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, height);
                    ctx.stroke();
                }
                for (let i = 0; i < height; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }

                // Draw waveform
                if (this.soundRecState.isRecording || this.soundRecState.isPlaying) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const time = Date.now() / 100;
                    for (let x = 0; x < width; x++) {
                        const y = height / 2 + Math.sin((x + time) * 0.05) * 30 * Math.sin(x * 0.02);
                        if (x === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
            }

            soundRecVolume(value) {
                const label = document.getElementById('soundrec-volume-label');
                if (label) label.textContent = value + '%';
            }

            soundRecNew() {
                window.dialogManager.confirm(
                    'Clear current recording?',
                    'Sound Recorder',
                    (button) => {
                        if (button === 'Yes') {
                            this.soundRecState.recordedData = [];
                            const length = document.getElementById('soundrec-length');
                            if (length) length.textContent = '0:00';
                            window.toastManager.show('New recording ready', 'success');
                        }
                    }
                );
            }

            soundRecSave() {
                const filename = prompt('Enter filename:', 'recording');
                if (filename) {
                    SafeStorage.setItem('soundrec-' + filename, JSON.stringify(this.soundRecState.recordedData));
                    window.dialogManager.info(`Saved as: ${filename}`, 'Sound Recorder');
                }
            }

            soundRecLoad() {
                const filename = prompt('Enter filename to load:');
                if (filename) {
                    const data = SafeStorage.getItem('soundrec-' + filename);
                    if (data) {
                        this.soundRecState.recordedData = JSON.parse(data);
                        window.dialogManager.info(`Loaded: ${filename}`, 'Sound Recorder');
                    } else {
                        window.dialogManager.error(`File not found: ${filename}`, 'Sound Recorder');
                    }
                }
            }

            // ========================================
            // WAVE 7: DISK DEFRAGMENTER
            // ========================================
            openDiskDefragmenter() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'padding: 8px; border-bottom: 2px groove; display: flex; gap: 8px; align-items: center;';
                toolbar.innerHTML = `
                    <label style="font-weight: bold;">Drive:</label>
                    <select id="defrag-drive" style="padding: 4px; font-family: inherit; font-size: 11px;">
                        <option value="C:">C: (System)</option>
                        <option value="D:">D: (Data)</option>
                        <option value="E:">E: (Storage)</option>
                    </select>
                    <button class="btn" id="defrag-analyze" onclick="emulator.defragAnalyze()" style="min-width: 80px;">Analyze</button>
                    <button class="btn" id="defrag-start" onclick="emulator.defragStart()" disabled style="min-width: 80px;">Defragment</button>
                `;

                // Visualization area
                const vizArea = document.createElement('div');
                vizArea.style.cssText = 'flex: 1; padding: 12px; display: flex; flex-direction: column; gap: 12px;';

                // Canvas for disk visualization (30x20 grid = 600 blocks)
                const canvas = document.createElement('canvas');
                canvas.id = 'defrag-canvas';
                canvas.width = 600;
                canvas.height = 400;
                canvas.style.cssText = 'border: 2px inset; background: white; width: 100%; max-height: 300px; image-rendering: pixelated;';

                // Legend
                const legend = document.createElement('div');
                legend.style.cssText = 'display: flex; gap: 16px; flex-wrap: wrap; font-size: 11px;';
                legend.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div style="width: 16px; height: 16px; background: #0000ff; border: 1px solid #000;"></div>
                        <span>Contiguous files</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div style="width: 16px; height: 16px; background: #ff0000; border: 1px solid #000;"></div>
                        <span>Fragmented files</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div style="width: 16px; height: 16px; background: #00ff00; border: 1px solid #000;"></div>
                        <span>Being defragmented</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div style="width: 16px; height: 16px; background: #ffffff; border: 1px solid #000;"></div>
                        <span>Free space</span>
                    </div>
                `;

                // Progress bar
                const progressArea = document.createElement('div');
                progressArea.style.cssText = 'padding: 8px; background: white; border: 2px inset;';
                progressArea.innerHTML = `
                    <div style="margin-bottom: 4px; font-weight: bold;" id="defrag-status">Ready to analyze</div>
                    <div style="border: 1px solid #000; height: 24px; background: white; position: relative;">
                        <div id="defrag-progress" style="height: 100%; background: #000080; width: 0%; transition: width 0.3s;"></div>
                        <div id="defrag-percent" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: white; text-shadow: 1px 1px 1px #000;">0%</div>
                    </div>
                `;

                // Statistics
                const stats = document.createElement('div');
                stats.id = 'defrag-stats';
                stats.style.cssText = 'font-size: 10px; padding: 8px; background: white; border: 2px inset; display: none;';
                stats.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div><strong>Total blocks:</strong> <span id="stat-total">600</span></div>
                        <div><strong>Used blocks:</strong> <span id="stat-used">0</span></div>
                        <div><strong>Free blocks:</strong> <span id="stat-free">0</span></div>
                        <div><strong>Fragmented:</strong> <span id="stat-fragmented">0</span>%</div>
                    </div>
                `;

                vizArea.appendChild(canvas);
                vizArea.appendChild(legend);
                vizArea.appendChild(progressArea);
                vizArea.appendChild(stats);
                content.appendChild(toolbar);
                content.appendChild(vizArea);

                this.windowManager.createWindow('Disk Defragmenter', content, { width: 640, height: 520 });

                // Initialize defrag state
                if (!this.defragState) {
                    this.defragState = {
                        blocks: [],
                        analyzing: false,
                        defragging: false,
                        progress: 0
                    };
                }

                // Initialize blocks
                this.defragInitBlocks();
            }

            defragInitBlocks() {
                // 30 columns x 20 rows = 600 blocks
                const blocks = [];
                for (let i = 0; i < 600; i++) {
                    // Randomly assign block types
                    const rand = Math.random();
                    if (rand < 0.4) {
                        blocks.push({ type: 'contiguous', color: '#0000ff' }); // Blue
                    } else if (rand < 0.6) {
                        blocks.push({ type: 'fragmented', color: '#ff0000' }); // Red
                    } else {
                        blocks.push({ type: 'free', color: '#ffffff' }); // White
                    }
                }
                this.defragState.blocks = blocks;
                this.defragDrawBlocks();
            }

            defragDrawBlocks() {
                const canvas = document.getElementById('defrag-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const cols = 30;
                const rows = 20;
                const blockWidth = canvas.width / cols;
                const blockHeight = canvas.height / rows;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                this.defragState.blocks.forEach((block, index) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    const x = col * blockWidth;
                    const y = row * blockHeight;

                    ctx.fillStyle = block.color;
                    ctx.fillRect(x, y, blockWidth, blockHeight);

                    // Draw border
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, blockWidth, blockHeight);
                });
            }

            defragAnalyze() {
                if (this.defragState.analyzing || this.defragState.defragging) return;

                const analyzeBtn = document.getElementById('defrag-analyze');
                const startBtn = document.getElementById('defrag-start');
                const status = document.getElementById('defrag-status');
                const progress = document.getElementById('defrag-progress');
                const percent = document.getElementById('defrag-percent');
                const stats = document.getElementById('defrag-stats');

                analyzeBtn.disabled = true;
                this.defragState.analyzing = true;
                this.defragState.progress = 0;

                status.textContent = 'Analyzing disk...';
                stats.style.display = 'none';

                // Simulate analysis
                const interval = setInterval(() => {
                    this.defragState.progress += 5;
                    progress.style.width = this.defragState.progress + '%';
                    percent.textContent = this.defragState.progress + '%';

                    if (this.defragState.progress >= 100) {
                        clearInterval(interval);
                        this.defragState.analyzing = false;

                        // Calculate statistics
                        const total = this.defragState.blocks.length;
                        const used = this.defragState.blocks.filter(b => b.type !== 'free').length;
                        const free = total - used;
                        const fragmented = this.defragState.blocks.filter(b => b.type === 'fragmented').length;
                        const fragPercent = Math.round((fragmented / used) * 100);

                        document.getElementById('stat-total').textContent = total;
                        document.getElementById('stat-used').textContent = used;
                        document.getElementById('stat-free').textContent = free;
                        document.getElementById('stat-fragmented').textContent = fragPercent;

                        stats.style.display = 'block';
                        status.textContent = `Analysis complete. ${fragPercent}% fragmented.`;
                        analyzeBtn.disabled = false;
                        startBtn.disabled = false;

                        progress.style.width = '0%';
                        percent.textContent = '0%';
                        this.defragState.progress = 0;
                    }
                }, 100);
            }

            defragStart() {
                if (this.defragState.analyzing || this.defragState.defragging) return;

                const analyzeBtn = document.getElementById('defrag-analyze');
                const startBtn = document.getElementById('defrag-start');
                const status = document.getElementById('defrag-status');
                const progress = document.getElementById('defrag-progress');
                const percent = document.getElementById('defrag-percent');

                analyzeBtn.disabled = true;
                startBtn.disabled = true;
                this.defragState.defragging = true;
                this.defragState.progress = 0;

                status.textContent = 'Defragmenting disk...';

                // Find all fragmented blocks
                const fragmentedIndices = [];
                this.defragState.blocks.forEach((block, index) => {
                    if (block.type === 'fragmented') {
                        fragmentedIndices.push(index);
                    }
                });

                let currentIndex = 0;
                const interval = setInterval(() => {
                    if (currentIndex < fragmentedIndices.length) {
                        const idx = fragmentedIndices[currentIndex];

                        // Highlight block being defragmented
                        this.defragState.blocks[idx].color = '#00ff00'; // Green
                        this.defragDrawBlocks();

                        setTimeout(() => {
                            // Convert to contiguous
                            this.defragState.blocks[idx].type = 'contiguous';
                            this.defragState.blocks[idx].color = '#0000ff'; // Blue
                            this.defragDrawBlocks();
                        }, 50);

                        currentIndex++;
                        this.defragState.progress = Math.round((currentIndex / fragmentedIndices.length) * 100);
                        progress.style.width = this.defragState.progress + '%';
                        percent.textContent = this.defragState.progress + '%';
                    } else {
                        clearInterval(interval);
                        this.defragState.defragging = false;

                        status.textContent = 'Defragmentation complete!';
                        analyzeBtn.disabled = false;
                        startBtn.disabled = true;

                        // Show completion dialog
                        setTimeout(() => {
                            window.dialogManager.info(
                                'Defragmentation complete. Your disk has been optimized for better performance.',
                                'Disk Defragmenter'
                            );
                        }, 500);
                    }
                }, 60);
            }

            // ========================================
            // WAVE 7: NETWORK NEIGHBORHOOD
            // ========================================
            openNetworkNeighborhood() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%;';

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 2px groove; display: flex; gap: 4px;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.netNeighborRefresh()" title="Refresh">🔄 Refresh</button>
                    <button class="btn" onclick="emulator.netNeighborUp()" title="Up One Level">⬆️ Up</button>
                `;

                // Address bar
                const addressBar = document.createElement('div');
                addressBar.style.cssText = 'background: var(--button-face); padding: 4px 8px; border-bottom: 1px solid var(--button-shadow); display: flex; align-items: center; gap: 8px;';
                addressBar.innerHTML = `
                    <label style="font-weight: bold;">Address:</label>
                    <input type="text" id="netneigh-address" value="Network Neighborhood" readonly style="flex: 1; padding: 2px 4px; border: 2px inset; font-family: inherit; font-size: 11px; background: white;">
                `;

                // Content area
                const contentArea = document.createElement('div');
                contentArea.id = 'netneigh-content';
                contentArea.style.cssText = 'flex: 1; padding: 16px; background: white; overflow-y: auto;';

                // Status bar
                const statusBar = document.createElement('div');
                statusBar.style.cssText = 'background: var(--button-face); padding: 4px 8px; border-top: 2px groove; font-size: 11px;';
                statusBar.innerHTML = `<span id="netneigh-status">Network Neighborhood</span>`;

                content.appendChild(toolbar);
                content.appendChild(addressBar);
                content.appendChild(contentArea);
                content.appendChild(statusBar);

                this.windowManager.createWindow('Network Neighborhood', content, { width: 500, height: 400 });

                // Initialize network state
                if (!this.networkState) {
                    this.networkState = {
                        currentPath: [],
                        computers: [
                            { name: 'DESKTOP-PC', status: 'online', isLocal: true, icon: '💻' },
                            { name: 'LAPTOP-USER', status: 'online', isLocal: false, icon: '💻' },
                            { name: 'SERVER-01', status: 'online', isLocal: false, icon: '🖥️' },
                            { name: 'FILESERVER', status: 'online', isLocal: false, icon: '🗄️' },
                            { name: 'WORKSTATION-05', status: 'offline', isLocal: false, icon: '💻' }
                        ]
                    };
                }

                this.netNeighborShowRoot();
            }

            netNeighborShowRoot() {
                const contentArea = document.getElementById('netneigh-content');
                const addressBar = document.getElementById('netneigh-address');
                const statusBar = document.getElementById('netneigh-status');

                if (!contentArea) return;

                addressBar.value = 'Network Neighborhood';
                this.networkState.currentPath = [];

                contentArea.innerHTML = `
                    <div style="display: flex; flex-wrap: wrap; gap: 32px; padding: 16px;">
                        <div onclick="emulator.netNeighborOpenEntireNetwork()" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">🌐</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">Entire Network</div>
                        </div>
                        <div onclick="emulator.netNeighborOpenWorkgroup()" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">👥</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">Workgroup</div>
                        </div>
                    </div>
                `;

                statusBar.textContent = '2 item(s)';
            }

            netNeighborOpenEntireNetwork() {
                const contentArea = document.getElementById('netneigh-content');
                const addressBar = document.getElementById('netneigh-address');
                const statusBar = document.getElementById('netneigh-status');

                addressBar.value = 'Network Neighborhood\\Entire Network';
                this.networkState.currentPath = ['Entire Network'];

                contentArea.innerHTML = `
                    <div style="display: flex; flex-wrap: wrap; gap: 32px; padding: 16px;">
                        <div onclick="emulator.netNeighborOpenWorkgroup()" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">👥</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">WORKGROUP</div>
                        </div>
                    </div>
                `;

                statusBar.textContent = '1 workgroup(s)';
            }

            netNeighborOpenWorkgroup() {
                const contentArea = document.getElementById('netneigh-content');
                const addressBar = document.getElementById('netneigh-address');
                const statusBar = document.getElementById('netneigh-status');

                addressBar.value = 'Network Neighborhood\\Entire Network\\WORKGROUP';
                this.networkState.currentPath = ['Entire Network', 'WORKGROUP'];

                let html = '<div style="display: flex; flex-wrap: wrap; gap: 32px; padding: 16px;">';

                this.networkState.computers.forEach(computer => {
                    const opacity = computer.status === 'offline' ? '0.5' : '1';
                    html += `
                        <div onclick="emulator.netNeighborOpenComputer('${computer.name}')"
                             style="cursor: pointer; text-align: center; width: 80px; opacity: ${opacity};">
                            <div style="font-size: 48px;">${computer.icon}</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">${computer.name}</div>
                            ${computer.isLocal ? '<div style="font-size: 9px; color: #666;">(This computer)</div>' : ''}
                        </div>
                    `;
                });

                html += '</div>';
                contentArea.innerHTML = html;
                statusBar.textContent = `${this.networkState.computers.length} computer(s)`;
            }

            netNeighborOpenComputer(computerName) {
                const computer = this.networkState.computers.find(c => c.name === computerName);

                if (computer.status === 'offline') {
                    window.dialogManager.error(
                        `${computerName} is not accessible. The computer may be turned off or not connected to the network.`,
                        'Network Neighborhood'
                    );
                    return;
                }

                const contentArea = document.getElementById('netneigh-content');
                const addressBar = document.getElementById('netneigh-address');
                const statusBar = document.getElementById('netneigh-status');

                addressBar.value = `Network Neighborhood\\Entire Network\\WORKGROUP\\${computerName}`;
                this.networkState.currentPath = ['Entire Network', 'WORKGROUP', computerName];

                contentArea.innerHTML = `
                    <div style="display: flex; flex-wrap: wrap; gap: 32px; padding: 16px;">
                        <div onclick="emulator.netNeighborOpenShare('C$')" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">💾</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">C$</div>
                        </div>
                        <div onclick="emulator.netNeighborOpenShare('ADMIN$')" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">🔧</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">ADMIN$</div>
                        </div>
                        <div onclick="emulator.netNeighborOpenShare('Users')" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">👤</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">Users</div>
                        </div>
                        <div onclick="emulator.netNeighborOpenShare('Shared')" style="cursor: pointer; text-align: center; width: 80px;">
                            <div style="font-size: 48px;">📁</div>
                            <div style="margin-top: 4px; word-wrap: break-word;">Shared</div>
                        </div>
                    </div>
                `;

                statusBar.textContent = '4 share(s)';
            }

            netNeighborOpenShare(shareName) {
                if (shareName === 'C$' || shareName === 'ADMIN$') {
                    window.dialogManager.error(
                        `Access to ${shareName} is denied. You do not have permission to access this resource.`,
                        'Network Neighborhood'
                    );
                    return;
                }

                const contentArea = document.getElementById('netneigh-content');
                const computerName = this.networkState.currentPath[2];
                const addressBar = document.getElementById('netneigh-address');
                const statusBar = document.getElementById('netneigh-status');

                addressBar.value = `\\\\${computerName}\\${shareName}`;

                contentArea.innerHTML = `
                    <div style="padding: 32px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">📂</div>
                        <div style="font-size: 14px; margin-bottom: 8px;">${shareName}</div>
                        <div style="font-size: 11px; color: #666;">
                            This folder contains shared files and documents.
                        </div>
                        <div style="margin-top: 24px; padding: 12px; background: #ffffcc; border: 1px solid #808080; text-align: left;">
                            <strong>Network Share Simulation</strong><br>
                            In a real Windows 95 network, you would see:<br>
                            • Shared documents and folders<br>
                            • Network permissions and access controls<br>
                            • File transfer capabilities<br>
                            • Network printer access
                        </div>
                    </div>
                `;

                statusBar.textContent = 'Network share';
            }

            netNeighborRefresh() {
                const currentPath = this.networkState.currentPath;

                if (currentPath.length === 0) {
                    this.netNeighborShowRoot();
                } else if (currentPath.length === 1) {
                    this.netNeighborOpenEntireNetwork();
                } else if (currentPath.length === 2) {
                    this.netNeighborOpenWorkgroup();
                } else if (currentPath.length === 3) {
                    this.netNeighborOpenComputer(currentPath[2]);
                }

                window.toastManager.show('Network refreshed', 'info');
            }

            netNeighborUp() {
                const currentPath = this.networkState.currentPath;

                if (currentPath.length === 0) return;

                if (currentPath.length === 1) {
                    this.netNeighborShowRoot();
                } else if (currentPath.length === 2) {
                    this.netNeighborOpenEntireNetwork();
                } else if (currentPath.length === 3) {
                    this.netNeighborOpenWorkgroup();
                } else if (currentPath.length > 3) {
                    this.netNeighborOpenComputer(currentPath[2]);
                }
            }

            openSystemProperties() {
                const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                const hours = Math.floor(uptime / 3600);
                const mins = Math.floor((uptime % 3600) / 60);
                const secs = uptime % 60;

                const content = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 48px; margin-bottom: 10px;">⚙️</div>
                            <h3 style="margin: 0;">System Properties</h3>
                        </div>

                        <div style="background: white; padding: 12px; border: 2px inset; margin-bottom: 12px;">
                            <table style="width: 100%; font-size: 11px;">
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">System:</td>
                                    <td style="padding: 4px;">Microsoft Windows 95</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Version:</td>
                                    <td style="padding: 4px;">4.00.950 (Simulator)</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Computer:</td>
                                    <td style="padding: 4px;">win95-simulator</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Processor:</td>
                                    <td style="padding: 4px;">Browser JavaScript Engine</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Memory:</td>
                                    <td style="padding: 4px;">${Math.floor(this.settings.memory / 1024 / 1024)} MB RAM</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">User:</td>
                                    <td style="padding: 4px;">user</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Uptime:</td>
                                    <td style="padding: 4px;">${hours}h ${mins}m ${secs}s</td>
                                </tr>
                            </table>
                        </div>

                        <div style="background: #ffffc0; padding: 8px; border: 1px solid #808080; font-size: 10px; margin-bottom: 12px;">
                            <strong>ℹ️ Note:</strong> This is a browser-based simulator. System information reflects the simulated environment.
                        </div>

                        <div style="text-align: center;">
                            <button class="btn primary" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 100px;">OK</button>
                        </div>
                    </div>
                `;

                this.windowManager.createWindow('System Properties', content, { width: 420, height: 440 });
            }

            openRegistryEditor() {
                // Load or initialize registry from localStorage
                const registry = this.loadRegistry();

                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Menu bar
                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px 4px; border-bottom: 1px solid #808080; font-size: 11px;';
                menuBar.innerHTML = `
                    <span style="padding: 2px 8px; cursor: pointer;">Registry</span>
                    <span style="padding: 2px 8px; cursor: pointer;">Edit</span>
                    <span style="padding: 2px 8px; cursor: pointer;">View</span>
                    <span style="padding: 2px 8px; cursor: pointer;">Help</span>
                `;

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 1px solid #808080; display: flex; gap: 4px;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.registryAddKey()" title="New Key">📁+</button>
                    <button class="btn" onclick="emulator.registryAddValue()" title="New Value">📝+</button>
                    <button class="btn" onclick="emulator.registryDelete()" title="Delete">🗑️</button>
                    <button class="btn" onclick="emulator.registryRefresh()" title="Refresh">🔄</button>
                `;

                // Main container
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; flex: 1; overflow: hidden;';

                // Tree view (left panel)
                const treePanel = document.createElement('div');
                treePanel.id = 'registry-tree';
                treePanel.style.cssText = 'width: 250px; background: white; border: 2px inset; overflow-y: auto; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';

                // Details view (right panel)
                const detailsPanel = document.createElement('div');
                detailsPanel.id = 'registry-details';
                detailsPanel.style.cssText = 'flex: 1; margin-left: 4px; background: white; border: 2px inset; overflow-y: auto;';

                // Build tree view
                this.buildRegistryTree(treePanel, registry);

                // Build details view header
                detailsPanel.innerHTML = `
                    <div style="background: #000080; color: white; padding: 4px; font-size: 11px; display: flex; border-bottom: 1px solid #808080;">
                        <div style="flex: 1; padding: 2px;">Name</div>
                        <div style="flex: 1; padding: 2px;">Type</div>
                        <div style="flex: 2; padding: 2px;">Data</div>
                    </div>
                    <div id="registry-values" style="font-size: 11px;"></div>
                `;

                mainContainer.appendChild(treePanel);
                mainContainer.appendChild(detailsPanel);

                content.appendChild(menuBar);
                content.appendChild(toolbar);
                content.appendChild(mainContainer);

                this.registryState = { currentKey: null, registry: registry };
                this.windowManager.createWindow('Registry Editor', content, { width: 700, height: 500 });
            }

            loadRegistry() {
                const saved = SafeStorage.getItem('win95-registry');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return this.getDefaultRegistry();
                    }
                }
                return this.getDefaultRegistry();
            }

            getDefaultRegistry() {
                return {
                    'HKEY_CLASSES_ROOT': {
                        '.txt': { '(Default)': 'txtfile' },
                        'txtfile': { '(Default)': 'Text Document' }
                    },
                    'HKEY_CURRENT_USER': {
                        'Software': {
                            'Microsoft': {
                                'Windows': { 'CurrentVersion': 'Windows 95 Simulator' }
                            }
                        },
                        'Control Panel': {
                            'Desktop': { 'Wallpaper': 'None' },
                            'Mouse': { 'DoubleClickSpeed': '500' }
                        }
                    },
                    'HKEY_LOCAL_MACHINE': {
                        'SOFTWARE': {
                            'Microsoft': {
                                'Windows': {
                                    'CurrentVersion': { 'Version': '4.00.950' }
                                }
                            }
                        },
                        'SYSTEM': {
                            'CurrentControlSet': { 'Control': { 'ComputerName': 'WIN95-SIM' } }
                        }
                    },
                    'HKEY_USERS': {
                        '.DEFAULT': { '(Default)': 'Default User Settings' }
                    },
                    'HKEY_CURRENT_CONFIG': {
                        'Software': { 'Fonts': { '(Default)': 'MS Sans Serif' } }
                    }
                };
            }

            saveRegistry(registry) {
                try {
                    SafeStorage.setItem('win95-registry', JSON.stringify(registry));
                } catch (e) {
                    window.dialogManager.error('Error saving registry: ' + e.message, 'Registry Editor');
                }
            }

            buildRegistryTree(container, registry, path = []) {
                container.innerHTML = '';

                const buildNode = (obj, parent, currentPath) => {
                    Object.keys(obj).sort().forEach(key => {
                        const fullPath = [...currentPath, key];
                        const pathStr = fullPath.join('\\');

                        const nodeDiv = document.createElement('div');
                        nodeDiv.style.cssText = 'padding: 2px 2px 2px ' + (currentPath.length * 16 + 4) + 'px; cursor: pointer; user-select: none;';

                        const hasChildren = typeof obj[key] === 'object' && obj[key] !== null && !obj[key].hasOwnProperty('(Default)') && Object.keys(obj[key]).length > 0;

                        nodeDiv.innerHTML = (hasChildren ? '📁 ' : '📄 ') + key;

                        nodeDiv.onclick = (e) => {
                            e.stopPropagation();
                            // Highlight selected
                            container.querySelectorAll('div').forEach(d => d.style.background = 'white');
                            nodeDiv.style.background = '#000080';
                            nodeDiv.style.color = 'white';

                            // Update details panel
                            this.registryState.currentKey = fullPath;
                            this.displayRegistryValues(obj[key]);
                        };

                        parent.appendChild(nodeDiv);

                        // Recursively build child nodes
                        if (typeof obj[key] === 'object' && obj[key] !== null) {
                            buildNode(obj[key], parent, fullPath);
                        }
                    });
                };

                // Build root nodes
                Object.keys(registry).sort().forEach(rootKey => {
                    const rootDiv = document.createElement('div');
                    rootDiv.style.cssText = 'padding: 2px 4px; cursor: pointer; font-weight: bold; user-select: none;';
                    rootDiv.innerHTML = '🖥️ ' + rootKey;

                    rootDiv.onclick = (e) => {
                        e.stopPropagation();
                        container.querySelectorAll('div').forEach(d => {
                            d.style.background = 'white';
                            d.style.color = 'black';
                        });
                        rootDiv.style.background = '#000080';
                        rootDiv.style.color = 'white';

                        this.registryState.currentKey = [rootKey];
                        this.displayRegistryValues(registry[rootKey]);
                    };

                    container.appendChild(rootDiv);

                    if (typeof registry[rootKey] === 'object') {
                        buildNode(registry[rootKey], container, [rootKey]);
                    }
                });
            }

            displayRegistryValues(keyData) {
                const valuesContainer = document.getElementById('registry-values');
                if (!valuesContainer) return;

                valuesContainer.innerHTML = '';

                if (!keyData || typeof keyData !== 'object') return;

                // Display values (leaf nodes)
                Object.keys(keyData).forEach(valueName => {
                    const valueData = keyData[valueName];

                    if (typeof valueData === 'string' || typeof valueData === 'number') {
                        const row = document.createElement('div');
                        row.style.cssText = 'display: flex; padding: 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        row.innerHTML = `
                            <div style="flex: 1; padding: 2px;">${valueName}</div>
                            <div style="flex: 1; padding: 2px;">REG_SZ</div>
                            <div style="flex: 2; padding: 2px;">${valueData}</div>
                        `;

                        row.onclick = () => {
                            const newValue = prompt('Edit value for: ' + valueName, valueData);
                            if (newValue !== null) {
                                this.registryUpdateValue(valueName, newValue);
                            }
                        };

                        valuesContainer.appendChild(row);
                    }
                });
            }

            registryAddKey() {
                if (!this.registryState || !this.registryState.currentKey) {
                    window.dialogManager.warning('Please select a location in the registry tree first.', 'Registry Editor');
                    return;
                }

                const keyName = prompt('Enter new key name:');
                if (keyName && keyName.trim()) {
                    let current = this.registryState.registry;
                    this.registryState.currentKey.forEach(part => {
                        if (!current[part]) current[part] = {};
                        current = current[part];
                    });

                    current[keyName.trim()] = {};
                    this.saveRegistry(this.registryState.registry);
                    this.registryRefresh();
                }
            }

            registryAddValue() {
                if (!this.registryState || !this.registryState.currentKey) {
                    window.dialogManager.warning('Please select a location in the registry tree first.', 'Registry Editor');
                    return;
                }

                const valueName = prompt('Enter value name:');
                if (valueName !== null) {
                    const valueData = prompt('Enter value data:');
                    if (valueData !== null) {
                        let current = this.registryState.registry;
                        this.registryState.currentKey.forEach(part => {
                            if (!current[part]) current[part] = {};
                            current = current[part];
                        });

                        current[valueName || '(Default)'] = valueData;
                        this.saveRegistry(this.registryState.registry);
                        this.displayRegistryValues(current);
                    }
                }
            }

            registryUpdateValue(valueName, newValue) {
                if (!this.registryState || !this.registryState.currentKey) return;

                let current = this.registryState.registry;
                this.registryState.currentKey.forEach(part => {
                    current = current[part];
                });

                current[valueName] = newValue;
                this.saveRegistry(this.registryState.registry);
                this.displayRegistryValues(current);
            }

            registryDelete() {
                if (!this.registryState || !this.registryState.currentKey) {
                    window.dialogManager.warning('Please select an item to delete.', 'Registry Editor');
                    return;
                }

                window.dialogManager.confirm(
                    'Are you sure you want to delete this key and all its subkeys?',
                    'Confirm Delete',
                    (button) => {
                        if (button === 'Yes') {
                            let parent = this.registryState.registry;
                            const path = [...this.registryState.currentKey];
                            const keyToDelete = path.pop();

                            path.forEach(part => {
                                parent = parent[part];
                            });

                            delete parent[keyToDelete];
                            this.saveRegistry(this.registryState.registry);
                            this.registryRefresh();
                        }
                    }
                );
            }

            registryRefresh() {
                const treePanel = document.getElementById('registry-tree');
                if (treePanel) {
                    this.registryState.registry = this.loadRegistry();
                    this.buildRegistryTree(treePanel, this.registryState.registry);
                }
            }

            openTaskManager() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Title bar area
                const header = document.createElement('div');
                header.style.cssText = 'background: var(--button-face); padding: 8px; border-bottom: 2px solid #808080;';
                header.innerHTML = `
                    <h3 style="margin: 0; font-size: 13px;">Task Manager</h3>
                    <div style="font-size: 10px; color: #666; margin-top: 4px;">Windows 95 Simulator</div>
                `;

                // Task list container
                const taskList = document.createElement('div');
                taskList.id = 'task-manager-list';
                taskList.style.cssText = 'flex: 1; overflow-y: auto; background: white; border: 2px inset; margin: 8px;';

                // Buttons
                const buttons = document.createElement('div');
                buttons.style.cssText = 'padding: 8px; border-top: 1px solid #808080; display: flex; gap: 8px; justify-content: flex-end; background: var(--button-face);';
                buttons.innerHTML = `
                    <button class="btn" onclick="emulator.taskManagerRefresh()" style="min-width: 80px;">Refresh</button>
                    <button class="btn" onclick="emulator.taskManagerEndTask()" style="min-width: 80px;">End Task</button>
                    <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px;">Close</button>
                `;

                content.appendChild(header);
                content.appendChild(taskList);
                content.appendChild(buttons);

                const win = this.windowManager.createWindow('Task Manager', content, { width: 450, height: 400 });

                // Populate task list
                this.taskManagerRefresh();

                // Auto-refresh every 2 seconds
                this.taskManagerInterval = setInterval(() => {
                    if (document.getElementById('task-manager-list')) {
                        this.taskManagerRefresh();
                    } else {
                        clearInterval(this.taskManagerInterval);
                    }
                }, 2000);
            }

            taskManagerRefresh() {
                const taskList = document.getElementById('task-manager-list');
                if (!taskList) return;

                taskList.innerHTML = `
                    <div style="background: #000080; color: white; padding: 6px; font-size: 11px; display: grid; grid-template-columns: 2fr 1fr 1fr; font-weight: bold; border-bottom: 1px solid #808080;">
                        <div>Task</div>
                        <div style="text-align: center;">Status</div>
                        <div style="text-align: center;">CPU</div>
                    </div>
                `;

                // Add running windows
                this.windowManager.windows.forEach((win, index) => {
                    const row = document.createElement('div');
                    row.className = 'task-manager-row';
                    row.dataset.windowId = win.id;
                    row.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 6px; font-size: 11px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                    row.innerHTML = `
                        <div>${win.title}</div>
                        <div style="text-align: center;">${win.minimized ? 'Minimized' : 'Running'}</div>
                        <div style="text-align: center;">${Math.floor(Math.random() * 15 + 1)}%</div>
                    `;

                    row.onclick = () => {
                        // Highlight selected
                        taskList.querySelectorAll('.task-manager-row').forEach(r => r.style.background = 'white');
                        row.style.background = '#000080';
                        row.style.color = 'white';
                        this.selectedTaskId = win.id;
                    };

                    taskList.appendChild(row);
                });

                // Add system process
                const systemRow = document.createElement('div');
                systemRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 6px; font-size: 11px; border-bottom: 1px solid #e0e0e0; color: #666;';
                systemRow.innerHTML = `
                    <div>System Idle Process</div>
                    <div style="text-align: center;">Running</div>
                    <div style="text-align: center;">${Math.floor(100 - this.windowManager.windows.length * 5)}%</div>
                `;
                taskList.appendChild(systemRow);
            }

            taskManagerEndTask() {
                if (!this.selectedTaskId) {
                    window.dialogManager.warning('Please select a task to end.', 'Task Manager');
                    return;
                }

                const windowObj = this.windowManager.windows.find(w => w.id === this.selectedTaskId);
                if (windowObj) {
                    window.dialogManager.confirm(
                        `End task "${windowObj.title}"?`,
                        'Task Manager',
                        (button) => {
                            if (button === 'Yes') {
                                this.windowManager.closeWindow(windowObj.element);
                                this.selectedTaskId = null;
                                this.taskManagerRefresh();
                            }
                        }
                    );
                }
            }

            openControlPanel() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Tabs
                const tabs = document.createElement('div');
                tabs.style.cssText = 'display: flex; border-bottom: 2px solid #808080; background: var(--button-face);';
                tabs.innerHTML = `
                    <button class="cp-tab active" data-tab="display" style="padding: 8px 16px; background: white; border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Display</button>
                    <button class="cp-tab" data-tab="screensaver" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Screen Saver</button>
                    <button class="cp-tab" data-tab="desktop" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Desktop</button>
                    <button class="cp-tab" data-tab="mouse" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Mouse</button>
                    <button class="cp-tab" data-tab="sound" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Sound</button>
                    <button class="cp-tab" data-tab="clippy" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">📎 Clippy</button>
                `;

                // Tab content container
                const tabContent = document.createElement('div');
                tabContent.style.cssText = 'flex: 1; overflow-y: auto; padding: 16px;';
                tabContent.innerHTML = this.getControlPanelTabContent('display');

                // Tab switching logic
                tabs.querySelectorAll('.cp-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        tabs.querySelectorAll('.cp-tab').forEach(t => {
                            t.classList.remove('active');
                            t.style.background = 'var(--button-face)';
                        });
                        tab.classList.add('active');
                        tab.style.background = 'white';
                        const tabName = tab.dataset.tab;
                        tabContent.innerHTML = this.getControlPanelTabContent(tabName);
                        this.initControlPanelHandlers(tabName);
                    });
                });

                // Bottom buttons
                const buttons = document.createElement('div');
                buttons.style.cssText = 'padding: 12px; border-top: 2px solid #808080; text-align: right; background: var(--button-face);';
                buttons.innerHTML = `
                    <button class="btn" onclick="emulator.saveControlPanelSettings(); emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px; margin-left: 4px;">OK</button>
                    <button class="btn" onclick="emulator.saveControlPanelSettings()" style="min-width: 80px; margin-left: 4px;">Apply</button>
                    <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px; margin-left: 4px;">Cancel</button>
                `;

                content.appendChild(tabs);
                content.appendChild(tabContent);
                content.appendChild(buttons);

                this.windowManager.createWindow('Control Panel', content, { width: 500, height: 450 });
                this.initControlPanelHandlers('display');
            }

            getControlPanelTabContent(tab) {
                const bgColor = SafeStorage.getItem('win95-desktop-color') || '#008080';
                const iconSpacing = SafeStorage.getItem('win95-icon-spacing') || '80';

                switch (tab) {
                    case 'display':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Display Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Desktop Background Color:</label>
                                    <input type="color" id="cp-bg-color" value="${bgColor}" style="width: 100px; height: 30px; cursor: pointer;">
                                    <span id="cp-bg-preview" style="margin-left: 12px; padding: 4px 12px; background: ${bgColor}; border: 1px solid #000; color: white;">${bgColor}</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Screen Resolution:</label>
                                    <select id="cp-resolution" style="padding: 4px;">
                                        <option value="640x480">640 x 480 (Default)</option>
                                        <option value="800x600">800 x 600</option>
                                        <option value="1024x768">1024 x 768</option>
                                    </select>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ℹ️ Resolution changes require restart
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'desktop':
                        const currentWallpaper = SafeStorage.getItem('win95-wallpaper-type') || 'none';
                        const wallpaperEnabled = SafeStorage.getItem('win95-wallpaper-enabled') === 'true';
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Desktop Customization</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Built-in Wallpapers:</label>
                                    <select id="cp-wallpaper" style="padding: 4px; width: 100%; margin-bottom: 8px;">
                                        <option value="none" ${currentWallpaper === 'none' ? 'selected' : ''}>None (Solid Color)</option>
                                        <option value="clouds" ${currentWallpaper === 'clouds' ? 'selected' : ''}>☁️ Clouds (Classic Windows 95)</option>
                                        <option value="pattern1" ${currentWallpaper === 'pattern1' ? 'selected' : ''}>🟦 Teal Pattern</option>
                                        <option value="pattern2" ${currentWallpaper === 'pattern2' ? 'selected' : ''}>📐 Diagonal Lines</option>
                                        <option value="pattern3" ${currentWallpaper === 'pattern3' ? 'selected' : ''}>◼️ Checkerboard</option>
                                        <option value="pattern4" ${currentWallpaper === 'pattern4' ? 'selected' : ''}>🔷 Honeycomb</option>
                                        <option value="pattern5" ${currentWallpaper === 'pattern5' ? 'selected' : ''}>🔺 Triangles</option>
                                        <option value="pattern6" ${currentWallpaper === 'pattern6' ? 'selected' : ''}>⚫ Dots</option>
                                        <option value="pattern7" ${currentWallpaper === 'pattern7' ? 'selected' : ''}>🟥 Red Rings</option>
                                        <option value="pattern8" ${currentWallpaper === 'pattern8' ? 'selected' : ''}>🍃 Leaves</option>
                                        <option value="gradient1" ${currentWallpaper === 'gradient1' ? 'selected' : ''}>🌊 Blue Gradient</option>
                                        <option value="gradient2" ${currentWallpaper === 'gradient2' ? 'selected' : ''}>🌈 Rainbow Gradient</option>
                                        <option value="gradient3" ${currentWallpaper === 'gradient3' ? 'selected' : ''}>🌅 Sunset</option>
                                        <option value="gradient4" ${currentWallpaper === 'gradient4' ? 'selected' : ''}>🌌 Space</option>
                                    </select>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn" onclick="emulator.previewWallpaper()">👁️ Preview</button>
                                        <button class="btn" onclick="emulator.removeWallpaper()">🗑️ Remove</button>
                                    </div>
                                    <div style="margin-top: 8px; padding: 8px; background: #e0e0ff; border: 1px solid #808080; font-size: 10px;">
                                        💡 Tip: Choose a wallpaper pattern to personalize your desktop!
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Icon Spacing:</label>
                                    <input type="range" id="cp-icon-spacing" min="60" max="120" value="${iconSpacing}" style="width: 200px;">
                                    <span id="cp-spacing-value" style="margin-left: 12px;">${iconSpacing}px</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-show-icons" checked style="margin-right: 8px;">
                                        <span>Show desktop icons</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-show-clock" checked style="margin-right: 8px;">
                                        <span>Show taskbar clock</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <button class="btn" onclick="emulator.arrangeIconsGrid()">
                                        🔲 Arrange Icons in Grid
                                    </button>
                                </div>
                            </div>
                        `;

                    case 'mouse':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Mouse Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-enable-mouse-lock" style="margin-right: 8px;">
                                        <span>Enable Mouse Lock (for FPS navigation)</span>
                                    </label>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ℹ️ Keep OFF for normal desktop interaction
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Double-Click Speed:</label>
                                    <input type="range" id="cp-dblclick-speed" min="200" max="800" value="400" style="width: 200px;">
                                    <div style="display: inline-block; margin-left: 12px;">
                                        <span style="margin: 0 8px;">Fast</span>
                                        <span>⟷</span>
                                        <span style="margin: 0 8px;">Slow</span>
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'screensaver':
                        // WAVE 5 ENHANCEMENT: Screen Saver configuration tab
                        const savedTimeout = SafeStorage.getItem('win95-screensaver-timeout') || '120';
                        const timeoutMinutes = Math.floor(parseInt(savedTimeout) / 60);
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Screen Saver Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Screen Saver:</label>
                                    <select id="cp-screensaver-type" style="padding: 4px; width: 100%;">
                                        <option value="random">Random (Default)</option>
                                        <option value="starfield">⭐ Starfield</option>
                                        <option value="pipes">🔧 3D Pipes</option>
                                        <option value="matrix">🔢 Matrix Rain</option>
                                        <option value="flying-logo">🪟 Flying Windows Logo</option>
                                        <option value="beziers">🎨 Bezier Curves</option>
                                        <option value="marquee">📜 Scrolling Marquee</option>
                                    </select>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Wait: <span id="cp-ss-timeout-display">${timeoutMinutes}</span> minutes</label>
                                    <input type="range" id="cp-screensaver-timeout" min="1" max="30" value="${timeoutMinutes}" style="width: 200px;">
                                    <div style="margin-top: 8px; padding: 8px; background: #e0e0ff; border: 1px solid #808080; font-size: 10px;">
                                        ℹ️ Screen saver activates after this period of inactivity
                                    </div>
                                </div>

                                <div style="margin: 16px 0; text-align: center;">
                                    <button class="btn" onclick="window.screenSaverManager.activate()" style="min-width: 120px;">
                                        👁️ Preview
                                    </button>
                                    <div style="margin-top: 8px; font-size: 10px; color: #666;">
                                        Click Preview to test the screen saver. Press any key or move mouse to exit.
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'sound':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Sound Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-enable-sound" style="margin-right: 8px;">
                                        <span>Enable system sounds</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Volume:</label>
                                    <input type="range" id="cp-volume" min="0" max="100" value="70" style="width: 200px;">
                                    <span id="cp-volume-value" style="margin-left: 12px;">70%</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-sound-startup" checked style="margin-right: 8px;">
                                        <span>Play Windows startup sound</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-sound-shutdown" checked style="margin-right: 8px;">
                                        <span>Play Windows shutdown sound</span>
                                    </label>
                                </div>
                            </div>
                        `;

                    case 'clippy':
                        const apiKey = SafeStorage.getItem('clippy_api_key') || '';
                        const apiEndpoint = SafeStorage.getItem('clippy_api_endpoint') || 'https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function';
                        const aiEnabled = SafeStorage.getItem('clippy_ai_enabled') !== 'false';
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">📎 Clippy Assistant Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-clippy-ai-enabled" ${aiEnabled ? 'checked' : ''} style="margin-right: 8px;">
                                        <span><strong>Enable AI-Powered Responses</strong></span>
                                    </label>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ℹ️ When enabled, Clippy uses AI for contextual help. Falls back to offline mode if unavailable.
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">API Endpoint:</label>
                                    <input type="text" id="cp-clippy-api-endpoint" value="${apiEndpoint}" placeholder="https://your-azure-function.azurewebsites.net/api/your-function"
                                        style="width: 100%; padding: 6px; border: 1px solid #808080; font-family: monospace; font-size: 10px;">
                                    <div style="margin-top: 8px; padding: 8px; background: #f0f0ff; border: 1px solid #808080; font-size: 10px;">
                                        🌐 <strong>API Endpoint URL</strong><br>
                                        Default: Azure Function endpoint<br>
                                        Customize this to use your own AI service
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">API Key (Optional):</label>
                                    <input type="password" id="cp-clippy-api-key" value="${apiKey}" placeholder="Enter your Azure Function API key..."
                                        style="width: 100%; padding: 6px; border: 1px solid #808080; font-family: monospace; font-size: 10px;">
                                    <div style="margin-top: 8px; padding: 8px; background: #e0e0ff; border: 1px solid #808080; font-size: 10px;">
                                        🔐 <strong>How to get an API key:</strong><br>
                                        1. Contact your system administrator<br>
                                        2. Or use offline mode (predefined helpful tips)<br>
                                        3. Your key is stored locally and never shared
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <h4>Current Status:</h4>
                                    <div id="clippy-status-info" style="padding: 8px; background: #f0f0f0; border: 1px solid #808080; font-size: 11px;">
                                        ${aiEnabled && apiKey ? '✅ AI Mode: Active' : '📴 Offline Mode: Using predefined tips'}
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <h4>🔊 Voice Output:</h4>
                                    <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                                        <input type="checkbox" id="cp-clippy-voice-enabled" ${SafeStorage.getItem('clippy_voice_enabled') !== 'false' ? 'checked' : ''} style="margin-right: 8px;">
                                        <span><strong>Enable Voice Responses</strong></span>
                                    </label>
                                    <div style="padding: 8px; background: #f0f0ff; border: 1px solid #808080; font-size: 10px;">
                                        🎤 <strong>Text-to-Speech</strong><br>
                                        When enabled, Clippy will speak responses aloud using your browser's voice synthesis.<br>
                                        Voice uses the "voice_response" field from AI responses for natural speaking.
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <h4>About Clippy's Emotions:</h4>
                                    <div style="padding: 8px; background: #f0f0f0; border: 1px solid #808080; font-size: 10px;">
                                        Clippy changes colors based on emotional context:<br>
                                        🔵 <span style="color: #0078D7; font-weight: bold;">Helpful/Neutral</span> - Ready to assist<br>
                                        🟢 <span style="color: #10893E; font-weight: bold;">Excited</span> - Happy about your progress<br>
                                        🟣 <span style="color: #8E44AD; font-weight: bold;">Curious</span> - Asking questions<br>
                                        🟡 <span style="color: #F7A400; font-weight: bold;">Thinking</span> - Processing information<br>
                                        🟠 <span style="color: #E67E22; font-weight: bold;">Proud</span> - Celebrating achievements
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <button class="btn" onclick="if(window.clippy){window.clippy.show('👋 Hi! I\\'m testing my connection! How can I help you today?', 'helper', {greeting: true})}">
                                        Test Clippy
                                    </button>
                                </div>
                            </div>
                        `;

                    default:
                        return '<div>Unknown tab</div>';
                }
            }

            initControlPanelHandlers(tab) {
                if (tab === 'display') {
                    const bgColorInput = document.getElementById('cp-bg-color');
                    const bgPreview = document.getElementById('cp-bg-preview');

                    if (bgColorInput && bgPreview) {
                        bgColorInput.addEventListener('input', (e) => {
                            bgPreview.style.background = e.target.value;
                            bgPreview.textContent = e.target.value;
                        });
                    }
                } else if (tab === 'desktop') {
                    const spacingInput = document.getElementById('cp-icon-spacing');
                    const spacingValue = document.getElementById('cp-spacing-value');

                    if (spacingInput && spacingValue) {
                        spacingInput.addEventListener('input', (e) => {
                            spacingValue.textContent = e.target.value + 'px';
                        });
                    }

                    // Wallpaper file input handler
                    const wallpaperInput = document.getElementById('wallpaper-file-input');
                    if (wallpaperInput) {
                        wallpaperInput.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file && file.type.startsWith('image/')) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    const imageData = event.target.result;
                                    SafeStorage.setItem('win95-wallpaper', imageData);
                                    this.updateWallpaperPreview(imageData);
                                    this.applyWallpaper(imageData);
                                };
                                reader.readAsDataURL(file);
                            }
                        });
                    }

                    // Load and display current wallpaper preview
                    const savedWallpaper = SafeStorage.getItem('win95-wallpaper');
                    if (savedWallpaper) {
                        this.updateWallpaperPreview(savedWallpaper);
                    }
                } else if (tab === 'screensaver') {
                    // WAVE 5 ENHANCEMENT: Screen saver timeout handler
                    const timeoutInput = document.getElementById('cp-screensaver-timeout');
                    const timeoutDisplay = document.getElementById('cp-ss-timeout-display');

                    if (timeoutInput && timeoutDisplay) {
                        timeoutInput.addEventListener('input', (e) => {
                            timeoutDisplay.textContent = e.target.value;
                        });
                    }
                } else if (tab === 'sound') {
                    const volumeInput = document.getElementById('cp-volume');
                    const volumeValue = document.getElementById('cp-volume-value');

                    if (volumeInput && volumeValue) {
                        volumeInput.addEventListener('input', (e) => {
                            volumeValue.textContent = e.target.value + '%';
                        });
                    }
                } else if (tab === 'clippy') {
                    const aiEnabledCheckbox = document.getElementById('cp-clippy-ai-enabled');
                    const apiKeyInput = document.getElementById('cp-clippy-api-key');

                    if (aiEnabledCheckbox) {
                        aiEnabledCheckbox.addEventListener('change', (e) => {
                            const status = document.getElementById('clippy-status-info');
                            const isEnabled = e.target.checked;
                            const hasKey = apiKeyInput && apiKeyInput.value.trim().length > 0;

                            if (status) {
                                status.textContent = isEnabled && hasKey ? '✅ AI Mode: Active' : '📴 Offline Mode: Using predefined tips';
                            }
                        });
                    }

                    if (apiKeyInput) {
                        apiKeyInput.addEventListener('input', (e) => {
                            const status = document.getElementById('clippy-status-info');
                            const hasKey = e.target.value.trim().length > 0;
                            const isEnabled = aiEnabledCheckbox && aiEnabledCheckbox.checked;

                            if (status) {
                                status.textContent = isEnabled && hasKey ? '✅ AI Mode: Active' : '📴 Offline Mode: Using predefined tips';
                            }
                        });
                    }
                }
            }

            saveControlPanelSettings() {
                // Display settings
                const bgColor = document.getElementById('cp-bg-color')?.value;
                if (bgColor) {
                    SafeStorage.setItem('win95-desktop-color', bgColor);
                    const desktop = document.querySelector('.desktop');
                    if (desktop) desktop.style.background = bgColor;
                }

                // WAVE 4 ENHANCEMENT #3: Wallpaper settings
                const wallpaperSelect = document.getElementById('cp-wallpaper');
                if (wallpaperSelect) {
                    const wallpaperType = wallpaperSelect.value;
                    SafeStorage.setItem('win95-wallpaper-type', wallpaperType);
                    SafeStorage.setItem('win95-wallpaper-enabled', wallpaperType !== 'none' ? 'true' : 'false');
                    // Redraw desktop to apply wallpaper
                    this.drawDesktop();
                    this.desktop.icons.forEach(icon => {
                        this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                    });
                }

                // Desktop settings
                const iconSpacing = document.getElementById('cp-icon-spacing')?.value;
                if (iconSpacing) {
                    SafeStorage.setItem('win95-icon-spacing', iconSpacing);
                }

                const showIcons = document.getElementById('cp-show-icons')?.checked;
                if (showIcons !== undefined) {
                    const desktopIcons = document.getElementById('desktop-icons');
                    if (desktopIcons) {
                        desktopIcons.style.display = showIcons ? 'flex' : 'none';
                    }
                }

                // WAVE 5 ENHANCEMENT: Screen saver settings
                const screensaverTimeout = document.getElementById('cp-screensaver-timeout')?.value;
                const screensaverType = document.getElementById('cp-screensaver-type')?.value;
                if (screensaverTimeout) {
                    const timeoutSeconds = parseInt(screensaverTimeout) * 60;
                    SafeStorage.setItem('win95-screensaver-timeout', timeoutSeconds.toString());
                    if (window.screenSaverManager) {
                        window.screenSaverManager.idleTimeout = timeoutSeconds * 1000;
                        window.screenSaverManager.resetIdleTimer();
                    }
                }
                if (screensaverType) {
                    SafeStorage.setItem('win95-screensaver-type', screensaverType);
                    if (window.screenSaverManager && screensaverType !== 'random') {
                        window.screenSaverManager.currentSaver = screensaverType;
                    }
                }

                // Clippy settings
                const clippyAiEnabled = document.getElementById('cp-clippy-ai-enabled');
                const clippyApiEndpoint = document.getElementById('cp-clippy-api-endpoint');
                const clippyApiKey = document.getElementById('cp-clippy-api-key');
                const clippyVoiceEnabled = document.getElementById('cp-clippy-voice-enabled');

                if (clippyAiEnabled !== null) {
                    const isEnabled = clippyAiEnabled.checked;
                    SafeStorage.setItem('clippy_ai_enabled', isEnabled.toString());
                    if (window.clippy && window.clippy.aiManager) {
                        window.clippy.aiManager.setAIEnabled(isEnabled);
                    }
                }

                if (clippyApiEndpoint) {
                    const endpoint = clippyApiEndpoint.value.trim();
                    SafeStorage.setItem('clippy_api_endpoint', endpoint);
                    if (window.clippy && window.clippy.aiManager) {
                        window.clippy.aiManager.setAPIEndpoint(endpoint);
                    }
                }

                if (clippyApiKey) {
                    const apiKey = clippyApiKey.value.trim();
                    SafeStorage.setItem('clippy_api_key', apiKey);
                    console.log('💾 Saved API Key (length):', apiKey.length);
                    if (window.clippy && window.clippy.aiManager) {
                        window.clippy.aiManager.setAPIKey(apiKey);
                    }
                }

                if (clippyVoiceEnabled !== null) {
                    const voiceEnabled = clippyVoiceEnabled.checked;
                    SafeStorage.setItem('clippy_voice_enabled', voiceEnabled ? 'true' : 'false');

                    // Update voice toggle button if chat window is open
                    const voiceBtn = document.getElementById('voice-toggle-btn');
                    if (voiceBtn) {
                        voiceBtn.textContent = voiceEnabled ? '🔊 Voice On' : '🔇 Voice Off';
                    }
                }

                // Refresh any open chat windows to show updated status
                const chatStatus = document.getElementById('clippy-chat-status');
                if (chatStatus && window.clippy?.aiManager) {
                    chatStatus.textContent = window.clippy.aiManager.hasAPIKey() && window.clippy.aiManager.aiEnabled ?
                        '✅ AI Mode Active' : '📴 Offline Mode (Configure in Control Panel)';
                }

                window.dialogManager.info('Settings have been applied!', 'Control Panel');
            }

            arrangeIconsGrid() {
                // Arrange desktop icons in a neat grid
                const icons = document.querySelectorAll('.desktop-icon');
                const spacing = parseInt(SafeStorage.getItem('win95-icon-spacing') || '80');
                let x = 20, y = 20;

                icons.forEach((icon, index) => {
                    icon.style.left = x + 'px';
                    icon.style.top = y + 'px';

                    y += spacing;
                    if (y > 400) {
                        y = 20;
                        x += spacing + 20;
                    }
                });

                window.dialogManager.info('Icons arranged in grid!', 'Desktop');
            }

            uploadWallpaper() {
                const fileInput = document.getElementById('wallpaper-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            // WAVE 4 ENHANCEMENT #3: Wallpaper preview
            previewWallpaper() {
                const wallpaperSelect = document.getElementById('cp-wallpaper');
                if (!wallpaperSelect) return;

                const wallpaperType = wallpaperSelect.value;
                SafeStorage.setItem('win95-wallpaper-type', wallpaperType);
                SafeStorage.setItem('win95-wallpaper-enabled', wallpaperType !== 'none' ? 'true' : 'false');

                // Redraw desktop with new wallpaper
                this.drawDesktop();
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });

                if (window.toastManager) {
                    const wallpaperNames = {
                        'none': 'Wallpaper removed',
                        'clouds': 'Clouds wallpaper applied',
                        'pattern1': 'Teal pattern applied',
                        'pattern2': 'Diagonal lines applied',
                        'pattern3': 'Checkerboard applied',
                        'pattern4': 'Honeycomb pattern applied',
                        'pattern5': 'Triangles pattern applied',
                        'pattern6': 'Dots pattern applied',
                        'pattern7': 'Red rings pattern applied',
                        'pattern8': 'Leaves pattern applied',
                        'gradient1': 'Blue gradient applied',
                        'gradient2': 'Rainbow gradient applied',
                        'gradient3': 'Sunset gradient applied',
                        'gradient4': 'Space gradient applied'
                    };
                    window.toastManager.show('Wallpaper', wallpaperNames[wallpaperType] || 'Wallpaper applied');
                }
            }

            removeWallpaper() {
                SafeStorage.setItem('win95-wallpaper-type', 'none');
                SafeStorage.setItem('win95-wallpaper-enabled', 'false');

                // Update dropdown if visible
                const wallpaperSelect = document.getElementById('cp-wallpaper');
                if (wallpaperSelect) {
                    wallpaperSelect.value = 'none';
                }

                // Redraw desktop without wallpaper
                this.drawDesktop();
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });

                if (window.toastManager) {
                    window.toastManager.show('Wallpaper', 'Wallpaper removed');
                }
            }

            updateWallpaperPreview(imageData) {
                const preview = document.getElementById('wallpaper-preview');
                if (preview) {
                    preview.innerHTML = `<img src="${imageData}" style="max-width: 100%; max-height: 100px; object-fit: contain;">`;
                }
            }

            applyWallpaper(imageData) {
                const screenContainer = document.getElementById('screen_container');
                if (screenContainer && imageData) {
                    screenContainer.style.backgroundImage = `url(${imageData})`;
                    screenContainer.style.backgroundSize = 'cover';
                    screenContainer.style.backgroundPosition = 'center';
                    screenContainer.style.backgroundRepeat = 'no-repeat';
                }
            }

            loadWallpaper() {
                const wallpaper = SafeStorage.getItem('win95-wallpaper');
                if (wallpaper) {
                    this.applyWallpaper(wallpaper);
                }
            }

            openAbout() {
                const content = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">💻</div>
                        <h3 style="margin: 10px 0;">Windows 95 Desktop Simulator</h3>
                        <p style="margin: 10px 0;">Interactive Edition v7.0 - COMPLETE</p>
                        <hr style="margin: 15px 0;">
                        <p style="margin: 10px 0; text-align: left;">
                            <strong>Programs & Apps (23+):</strong><br>
                            • <strong>Chromium Browser - Real browser engine with DevTools! (NEW!) ⭐</strong><br>
                            • Internet Explorer - Browse real websites<br>
                            • LocalFirst Tools - Browse 150+ web tools<br>
                            • Paint - Drawing application<br>
                            • Media Player - Audio/Video player<br>
                            • File Explorer - Multi-drive file system (A:, C:, D:, E:)<br>
                            • Linux Terminal - Full bash emulation<br>
                            • Notepad - Text editor with Find/Replace<br>
                            • WordPad - Rich text editor<br>
                            • Character Map - Special characters<br>
                            • Sound Recorder - Audio simulation<br>
                            • Calculator - Scientific & Standard modes<br>
                            • Minesweeper - Classic game with 3 difficulties<br>
                            • Solitaire - Klondike card game<br>
                            • FreeCell - Card puzzle game<br>
                            • 3 Additional Games (Keen, Galactic, Snake)<br>
                            • Control Panel - Desktop customization<br>
                            • Registry Editor - System configuration<br>
                            • Task Manager - Process monitoring<br>
                            • System Properties - System information<br>
                            • Recycle Bin - File recovery system<br>
                            • <strong>Network Neighborhood - Network browser (NEW!)</strong><br>
                            • <strong>Disk Defragmenter - Visual disk optimizer (NEW!)</strong>
                        </p>
                        <hr style="margin: 15px 0;">
                        <p style="margin: 10px 0; text-align: left;">
                            <strong>Features:</strong><br>
                            • Draggable, resizable, minimizable windows<br>
                            • Alt+Tab window switching<br>
                            • Window menu bars (minimize, maximize, close)<br>
                            • Professional dialog system<br>
                            • Full clipboard (Copy/Cut/Paste)<br>
                            • Desktop context menus<br>
                            • 14 Wallpaper patterns & gradients<br>
                            • <strong>7 Screen savers (Starfield, Pipes, Matrix, Logo, Beziers, Marquee) (NEW!)</strong><br>
                            • Volume control & sound effects<br>
                            • Multi-drive file system<br>
                            • Real-time clock with info popup<br>
                            • Keyboard shortcuts (Ctrl+C/V/X, F2, Delete)<br>
                            • 20+ Linux Terminal commands<br>
                            • Command history (↑/↓ arrows)<br>
                            • Authentic Windows 95 aesthetics
                        </p>
                        <hr style="margin: 15px 0;">
                        <p style="font-size: 10px; color: #808080;">
                            Built with pure HTML, CSS, and JavaScript<br>
                            No external dependencies • Local-first design<br>
                            13,100+ lines of code • 100% self-contained<br>
                            <br>
                            Waves 1-7 Complete (2024)<br>
                            Created by Claude Code
                        </p>
                    </div>
                `;
                this.windowManager.createWindow('About Windows 95', content, { width: 450, height: 680 });
            }

            // Simple Markdown renderer
            renderMarkdown(text) {
                if (!text) return '';

                let html = this.escapeHtml(text);

                // Code blocks with ```
                html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                    return `<pre style="background: #f5f5f5; padding: 8px; border: 1px solid #ccc; border-radius: 4px; overflow-x: auto; margin: 8px 0;"><code>${code.trim()}</code></pre>`;
                });

                // Inline code with `
                html = html.replace(/`([^`]+)`/g, '<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 10px;">$1</code>');

                // Bold **text**
                html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

                // Italic *text*
                html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

                // Links [text](url)
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: #0000ff; text-decoration: underline;">$1</a>');

                // Headers
                html = html.replace(/^### (.+)$/gm, '<h3 style="margin: 8px 0 4px 0; font-size: 12px;">$1</h3>');
                html = html.replace(/^## (.+)$/gm, '<h2 style="margin: 10px 0 6px 0; font-size: 14px;">$1</h2>');
                html = html.replace(/^# (.+)$/gm, '<h1 style="margin: 12px 0 8px 0; font-size: 16px;">$1</h1>');

                // Bullet lists
                html = html.replace(/^\- (.+)$/gm, '<li style="margin-left: 20px;">$1</li>');
                html = html.replace(/^\* (.+)$/gm, '<li style="margin-left: 20px;">$1</li>');

                // Numbered lists
                html = html.replace(/^\d+\. (.+)$/gm, '<li style="margin-left: 20px; list-style-type: decimal;">$1</li>');

                // Line breaks
                html = html.replace(/\n/g, '<br>');

                return html;
            }

            // Clippy Chat Window
            openClippyChat() {
                // Generate unique chat window ID
                const chatId = `chat-${Date.now()}`;

                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Store chatId on the container
                content.dataset.chatId = chatId;

                // Chat header with actions
                const header = document.createElement('div');
                header.style.cssText = 'padding: 12px; background: white; border-bottom: 2px solid #808080;';
                header.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="flex: 1; text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 4px;">📎</div>
                            <div style="font-weight: bold; margin-bottom: 4px;">Chat with Clippy</div>
                            <div style="font-size: 10px; color: #666;">Your friendly Windows 95 assistant</div>
                        </div>
                        <div style="display: flex; gap: 4px; flex-direction: column;">
                            <button class="btn" style="padding: 4px 8px; font-size: 10px;" onclick="window.emulator.openClippyChat()" title="Open new chat window">
                                📄 New Chat
                            </button>
                            <button class="btn" style="padding: 4px 8px; font-size: 10px;" onclick="window.emulator.clearChatHistory('${chatId}')" title="Clear this chat">
                                🗑️ Clear Chat
                            </button>
                        </div>
                    </div>
                `;

                // Chat history area with unique ID
                const chatHistory = document.createElement('div');
                chatHistory.id = `clippy-chat-history-${chatId}`;
                chatHistory.dataset.chatId = chatId;
                chatHistory.style.cssText = 'flex: 1; padding: 12px; background: white; overflow-y: auto; border: 2px inset; margin: 8px;';

                // Welcome message
                chatHistory.innerHTML = `
                    <div style="padding: 8px; background: #ffffc0; border: 1px solid #808080; margin-bottom: 8px; border-radius: 4px;">
                        <strong>📎 Clippy:</strong> Hi! I'm Clippit, your Windows 95 assistant! I'm here to help you with anything you need. What can I help you with today?
                        <div style="margin-top: 8px; padding: 6px; background: #f0f0ff; border-left: 3px solid #0078D7; font-size: 10px;">
                            💡 <strong>Tip:</strong> Click any message to select it for context in your next question!
                        </div>
                    </div>
                `;

                // Selection toolbar
                const selectionToolbar = document.createElement('div');
                selectionToolbar.id = `clippy-selection-toolbar-${chatId}`;
                selectionToolbar.dataset.chatId = chatId;
                selectionToolbar.style.cssText = 'padding: 6px 8px; background: #f0f0f0; border-top: 1px solid #808080; display: flex; align-items: center; gap: 8px; font-size: 10px;';

                const voiceEnabled = window.clippy?.aiManager?.isVoiceEnabled() !== false;
                selectionToolbar.innerHTML = `
                    <span id="selection-count-${chatId}" style="flex: 1; color: #666;">📋 0 messages selected</span>
                    <button id="voice-toggle-btn-${chatId}" class="btn" style="padding: 2px 8px; font-size: 10px;" onclick="window.emulator.toggleClippyVoice()" title="Toggle voice output">
                        ${voiceEnabled ? '🔊 Voice On' : '🔇 Voice Off'}
                    </button>
                    <button class="btn" style="padding: 2px 8px; font-size: 10px;" onclick="window.emulator.clearMessageSelections('${chatId}')">Clear Selection</button>
                `;

                // Input area
                const inputArea = document.createElement('div');
                inputArea.style.cssText = 'padding: 8px; background: var(--button-face); border-top: 2px solid #808080; display: flex; gap: 8px;';

                const input = document.createElement('input');
                input.type = 'text';
                input.id = `clippy-chat-input-${chatId}`;
                input.dataset.chatId = chatId;
                input.placeholder = 'Type your message here...';
                input.style.cssText = 'flex: 1; padding: 6px; border: 2px inset; font-family: inherit; font-size: 11px;';

                const sendBtn = document.createElement('button');
                sendBtn.className = 'btn primary';
                sendBtn.textContent = 'Send';
                sendBtn.style.cssText = 'padding: 6px 16px; min-width: 70px;';
                sendBtn.onclick = () => this.sendClippyMessage(chatId);

                // Handle Enter key
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendClippyMessage(chatId);
                    }
                });

                inputArea.appendChild(input);
                inputArea.appendChild(sendBtn);

                // Status bar
                const statusBar = document.createElement('div');
                statusBar.id = `clippy-chat-status-${chatId}`;
                statusBar.dataset.chatId = chatId;
                statusBar.style.cssText = 'padding: 4px 8px; background: var(--button-face); border-top: 2px groove; font-size: 10px; color: #666;';
                statusBar.textContent = window.clippy?.aiManager?.hasAPIKey() && window.clippy?.aiManager?.aiEnabled ?
                    '✅ AI Mode Active' : '📴 Offline Mode (Configure in Control Panel)';

                content.appendChild(header);
                content.appendChild(chatHistory);
                content.appendChild(selectionToolbar);
                content.appendChild(inputArea);
                content.appendChild(statusBar);

                this.windowManager.createWindow('Chat with Clippy', content, { width: 450, height: 500 });

                // Focus input
                setTimeout(() => input.focus(), 100);
            }

            async sendClippyMessage(chatId) {
                const input = document.getElementById(`clippy-chat-input-${chatId}`);
                const history = document.getElementById(`clippy-chat-history-${chatId}`);
                const status = document.getElementById(`clippy-chat-status-${chatId}`);

                if (!input || !history) return;

                const message = input.value.trim();
                if (!message) return;

                // Generate unique message IDs
                const userMsgId = `msg-${Date.now()}-user`;
                const timestamp = new Date().toLocaleTimeString();

                // Initialize conversation histories object if needed
                if (!this.chatConversationHistories) {
                    this.chatConversationHistories = {};
                }

                // Initialize this chat's history if needed
                if (!this.chatConversationHistories[chatId]) {
                    this.chatConversationHistories[chatId] = [];
                }

                // Add user message to history with metadata
                const userMsg = document.createElement('div');
                userMsg.className = 'chat-message chat-message-user';
                userMsg.dataset.messageId = userMsgId;
                userMsg.dataset.sender = 'user';
                userMsg.dataset.timestamp = timestamp;
                userMsg.dataset.content = message;
                userMsg.style.cssText = 'padding: 8px; background: #e0e0ff; border: 1px solid #808080; margin-bottom: 8px; border-radius: 4px; text-align: right; cursor: pointer; transition: background 0.2s;';
                userMsg.innerHTML = `
                    <div style="font-size: 9px; color: #666; margin-bottom: 4px;">You • ${timestamp}</div>
                    <strong>You:</strong> ${this.escapeHtml(message)}
                `;

                // Make message selectable for context
                userMsg.addEventListener('click', () => this.toggleMessageSelection(userMsg));
                userMsg.addEventListener('mouseenter', () => {
                    if (!userMsg.classList.contains('selected')) {
                        userMsg.style.background = '#d0d0ff';
                    }
                });
                userMsg.addEventListener('mouseleave', () => {
                    if (!userMsg.classList.contains('selected')) {
                        userMsg.style.background = '#e0e0ff';
                    }
                });

                history.appendChild(userMsg);

                // Store in this chat's conversation history
                this.chatConversationHistories[chatId].push({
                    id: userMsgId,
                    sender: 'user',
                    message: message,
                    timestamp: timestamp
                });

                // Clear input
                input.value = '';

                // Scroll to bottom
                history.scrollTop = history.scrollHeight;

                // Show thinking indicator
                const thinkingMsg = document.createElement('div');
                thinkingMsg.id = 'clippy-thinking';
                thinkingMsg.style.cssText = 'padding: 8px; background: #ffffc0; border: 1px solid #808080; margin-bottom: 8px; border-radius: 4px;';
                thinkingMsg.innerHTML = '<strong>📎 Clippy:</strong> <em>Thinking...</em>';
                history.appendChild(thinkingMsg);
                history.scrollTop = history.scrollHeight;

                // Get AI response
                try {
                    if (status) status.textContent = '⏳ Getting response...';

                    // Get selected messages for context from this chat window
                    const selectedMessages = this.getSelectedMessagesContext(chatId);

                    const context = {
                        program: 'Chat Window',
                        action: 'conversation',
                        pattern: 'chatting',
                        userMessage: message,
                        selectedContext: selectedMessages,
                        conversationHistory: this.chatConversationHistories[chatId].slice(-10), // Last 10 messages from this chat
                        windowCount: this.windowManager?.windows?.length || 0
                    };

                    let response = null;

                    if (window.clippy && window.clippy.aiManager) {
                        response = await window.clippy.aiManager.getClippyResponse(context);
                    }

                    // Remove thinking indicator
                    thinkingMsg.remove();

                    // Generate Clippy message ID
                    const clippyMsgId = `msg-${Date.now()}-clippy`;
                    const clippyTimestamp = new Date().toLocaleTimeString();

                    // Add Clippy response with metadata
                    const clippyMsg = document.createElement('div');
                    clippyMsg.className = 'chat-message chat-message-clippy';
                    clippyMsg.dataset.messageId = clippyMsgId;
                    clippyMsg.dataset.sender = 'clippy';
                    clippyMsg.dataset.timestamp = clippyTimestamp;
                    clippyMsg.style.cssText = 'padding: 8px; background: #ffffc0; border: 1px solid #808080; margin-bottom: 8px; border-radius: 4px; cursor: pointer; transition: background 0.2s;';

                    let responseText = '';
                    if (response && response.message) {
                        responseText = response.message;
                        clippyMsg.dataset.content = responseText;
                        clippyMsg.innerHTML = `
                            <div style="font-size: 9px; color: #666; margin-bottom: 4px;">📎 Clippy • ${clippyTimestamp}</div>
                            <div style="margin-top: 4px;"><strong>📎 Clippy:</strong></div>
                            <div style="margin-top: 6px;">${this.renderMarkdown(responseText)}</div>
                        `;
                    } else {
                        // Offline fallback responses
                        const fallbacks = [
                            "I'm here to help! Since I'm in offline mode, my responses are limited, but I can still provide general Windows 95 tips!",
                            "Great question! To enable my full AI capabilities, configure the API endpoint in Control Panel → Clippy settings.",
                            "I'd love to help with that! For now, I'm running in offline mode. Check out the Start menu to explore all the programs available!",
                            "That's interesting! While I can't give detailed answers in offline mode, I can help you navigate Windows 95. Try opening File Explorer or any of the programs!"
                        ];
                        responseText = fallbacks[Math.floor(Math.random() * fallbacks.length)];
                        clippyMsg.dataset.content = responseText;
                        clippyMsg.innerHTML = `
                            <div style="font-size: 9px; color: #666; margin-bottom: 4px;">📎 Clippy • ${clippyTimestamp}</div>
                            <strong>📎 Clippy:</strong> ${responseText}
                        `;
                    }

                    // Make Clippy message selectable too
                    clippyMsg.addEventListener('click', () => this.toggleMessageSelection(clippyMsg));
                    clippyMsg.addEventListener('mouseenter', () => {
                        if (!clippyMsg.classList.contains('selected')) {
                            clippyMsg.style.background = '#ffffb0';
                        }
                    });
                    clippyMsg.addEventListener('mouseleave', () => {
                        if (!clippyMsg.classList.contains('selected')) {
                            clippyMsg.style.background = '#ffffc0';
                        }
                    });

                    history.appendChild(clippyMsg);
                    history.scrollTop = history.scrollHeight;

                    // Store in this chat's conversation history
                    this.chatConversationHistories[chatId].push({
                        id: clippyMsgId,
                        sender: 'clippy',
                        message: responseText,
                        timestamp: clippyTimestamp
                    });

                    // Speak the response using voice_response if available
                    if (window.clippy && window.clippy.aiManager) {
                        const voiceText = response?.voiceMessage || responseText;
                        if (voiceText) {
                            // Add a small delay to ensure message is visible before speaking
                            setTimeout(() => {
                                window.clippy.aiManager.speak(voiceText);
                            }, 300);
                        }
                    }

                    if (status) {
                        status.textContent = window.clippy?.aiManager?.hasAPIKey() && window.clippy?.aiManager?.aiEnabled ?
                            '✅ AI Mode Active' : '📴 Offline Mode (Configure in Control Panel)';
                    }

                } catch (error) {
                    console.error('Clippy chat error:', error);
                    thinkingMsg.remove();

                    const errorMsg = document.createElement('div');
                    errorMsg.style.cssText = 'padding: 8px; background: #ffe0e0; border: 1px solid #ff0000; margin-bottom: 8px; border-radius: 4px;';
                    errorMsg.innerHTML = '<strong>📎 Clippy:</strong> Oops! I encountered an error. Please try again or check your AI settings in Control Panel.';
                    history.appendChild(errorMsg);
                    history.scrollTop = history.scrollHeight;

                    if (status) status.textContent = '❌ Error - Check settings';
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Message selection for context
            toggleMessageSelection(messageElement) {
                if (!messageElement) return;

                const isSelected = messageElement.classList.contains('selected');

                if (isSelected) {
                    // Deselect
                    messageElement.classList.remove('selected');
                    const sender = messageElement.dataset.sender;
                    if (sender === 'user') {
                        messageElement.style.background = '#e0e0ff';
                        messageElement.style.borderColor = '#808080';
                    } else {
                        messageElement.style.background = '#ffffc0';
                        messageElement.style.borderColor = '#808080';
                    }
                    messageElement.style.borderWidth = '1px';
                } else {
                    // Select
                    messageElement.classList.add('selected');
                    messageElement.style.background = '#b0e0b0'; // Green highlight
                    messageElement.style.borderColor = '#0078D7';
                    messageElement.style.borderWidth = '2px';

                    // Show notification
                    if (window.toastManager) {
                        window.toastManager.show('Message selected for context', 'info');
                    }
                }

                // Update selection count display for this chat
                // Find the chatId from the message's parent history element
                const historyElement = messageElement.closest('[id^="clippy-chat-history-"]');
                if (historyElement) {
                    const chatId = historyElement.id.replace('clippy-chat-history-', '');
                    this.updateSelectionCount(chatId);
                }
            }

            updateSelectionCount(chatId) {
                // Find the chat window by chatId - check all selection count elements
                const countElement = chatId ?
                    document.getElementById(`selection-count-${chatId}`) :
                    document.querySelector('[id^="selection-count-"]');

                if (!countElement) return;

                // Get the chatId from the element if not provided
                const actualChatId = chatId || countElement.id.replace('selection-count-', '');
                const history = document.getElementById(`clippy-chat-history-${actualChatId}`);
                if (!history) return;

                const selectedMessages = history.querySelectorAll('.chat-message.selected');
                const count = selectedMessages.length;

                if (count === 0) {
                    countElement.textContent = '📋 0 messages selected';
                    countElement.style.color = '#666';
                } else if (count === 1) {
                    countElement.textContent = '📋 1 message selected for context';
                    countElement.style.color = '#0078D7';
                    countElement.style.fontWeight = 'bold';
                } else {
                    countElement.textContent = `📋 ${count} messages selected for context`;
                    countElement.style.color = '#0078D7';
                    countElement.style.fontWeight = 'bold';
                }
            }

            getSelectedMessagesContext(chatId) {
                const history = document.getElementById(`clippy-chat-history-${chatId}`);
                if (!history) return [];

                const selectedMessages = history.querySelectorAll('.chat-message.selected');
                const context = [];

                selectedMessages.forEach(msg => {
                    context.push({
                        id: msg.dataset.messageId,
                        sender: msg.dataset.sender,
                        content: msg.dataset.content,
                        timestamp: msg.dataset.timestamp
                    });
                });

                return context;
            }

            clearMessageSelections(chatId) {
                const history = document.getElementById(`clippy-chat-history-${chatId}`);
                if (!history) return;

                const selectedMessages = history.querySelectorAll('.chat-message.selected');
                selectedMessages.forEach(msg => {
                    this.toggleMessageSelection(msg); // Toggle to deselect
                });

                if (selectedMessages.length > 0 && window.toastManager) {
                    window.toastManager.show('Selection cleared', 'info');
                }

                this.updateSelectionCount(chatId);
            }

            clearChatHistory(chatId) {
                const history = document.getElementById(`clippy-chat-history-${chatId}`);
                if (!history) {
                    console.error(`Chat history not found for chatId: ${chatId}`);
                    return;
                }

                // Confirm with user
                if (window.dialogManager) {
                    window.dialogManager.confirm(
                        'Are you sure you want to clear this chat? This cannot be undone.',
                        'Clear Chat',
                        (result) => {
                            if (result === 'Yes') {
                                // Clear the history display
                                history.innerHTML = `
                                    <div style="padding: 8px; background: #ffffc0; border: 1px solid #808080; margin-bottom: 8px; border-radius: 4px;">
                                        <strong>📎 Clippy:</strong> Chat cleared! How can I help you today?
                                        <div style="margin-top: 8px; padding: 6px; background: #f0f0ff; border-left: 3px solid #0078D7; font-size: 10px;">
                                            💡 <strong>Tip:</strong> Click any message to select it for context in your next question!
                                        </div>
                                    </div>
                                `;

                                // Clear the conversation history for this chat
                                if (this.chatConversationHistories && this.chatConversationHistories[chatId]) {
                                    this.chatConversationHistories[chatId] = [];
                                }

                                // Show confirmation
                                if (window.toastManager) {
                                    window.toastManager.show('Chat history cleared', 'success');
                                }

                            }
                        }
                    );
                } else {
                    // Fallback if dialog manager not available
                    if (confirm('Are you sure you want to clear this chat?')) {
                        history.innerHTML = '<div style="padding: 8px; background: #ffffc0; border: 1px solid #808080; margin-bottom: 8px; border-radius: 4px;"><strong>📎 Clippy:</strong> Chat cleared! How can I help you today?</div>';

                        if (this.chatConversationHistories && this.chatConversationHistories[chatId]) {
                            this.chatConversationHistories[chatId] = [];
                        }
                    }
                }
            }

            toggleClippyVoice() {
                if (!window.clippy || !window.clippy.aiManager) {
                    console.error('Clippy AI Manager not available');
                    return;
                }

                const newState = window.clippy.aiManager.toggleVoice();
                const btn = document.getElementById('voice-toggle-btn');

                if (btn) {
                    btn.textContent = newState ? '🔊 Voice On' : '🔇 Voice Off';
                }

                if (window.toastManager) {
                    window.toastManager.show(
                        newState ? 'Voice responses enabled' : 'Voice responses disabled',
                        'info'
                    );
                }

            }

            // ========================================
            // VIRTUAL FLOPPY - Save State System
            // ========================================

            exportSystemState() {

                const state = {
                    version: '1.0.0',
                    timestamp: new Date().toISOString(),
                    displayName: `Windows 95 Session - ${new Date().toLocaleString()}`,

                    // All localStorage data
                    storage: {},

                    // Chat histories
                    chatHistories: this.chatConversationHistories || {},

                    // Window manager state
                    windows: [],

                    // Desktop state
                    desktop: {
                        iconPositions: {},
                        wallpaper: SafeStorage.getItem('win95-wallpaper'),
                        wallpaperCustom: SafeStorage.getItem('win95-custom-wallpaper')
                    },

                    // Settings
                    settings: {
                        volume: SafeStorage.getItem('win95-volume'),
                        screensaverType: SafeStorage.getItem('win95-screensaver-type'),
                        screensaverTimeout: SafeStorage.getItem('win95-screensaver-timeout'),
                        iconSpacing: SafeStorage.getItem('win95-icon-spacing'),
                        clippyAiEnabled: SafeStorage.getItem('clippy_ai_enabled'),
                        clippyVoiceEnabled: SafeStorage.getItem('clippy_voice_enabled'),
                        clippyApiEndpoint: SafeStorage.getItem('clippy_api_endpoint'),
                        clippyApiKey: SafeStorage.getItem('clippy_api_key')
                    }
                };

                // Capture all localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    state.storage[key] = localStorage.getItem(key);
                }

                // Capture desktop icon positions
                const icons = document.querySelectorAll('.desktop-icon');
                icons.forEach(icon => {
                    const id = icon.id || icon.querySelector('.icon-label')?.textContent;
                    if (id) {
                        state.desktop.iconPositions[id] = {
                            left: icon.style.left,
                            top: icon.style.top
                        };
                    }
                });

                // Capture open windows (basic info)
                if (this.windowManager && this.windowManager.windows) {
                    this.windowManager.windows.forEach(win => {
                        state.windows.push({
                            title: win.title,
                            width: win.width,
                            height: win.height,
                            x: win.x,
                            y: win.y,
                            minimized: win.minimized,
                            maximized: win.maximized
                        });
                    });
                }

                return state;
            }

            importSystemState(state) {

                if (!state || !state.version) {
                    throw new Error('Invalid save file format');
                }

                try {
                    // Save the entire state to a special localStorage key for restoration after reload
                    SafeStorage.setItem('win95-pending-state-restore', JSON.stringify(state));

                    // Restore localStorage
                    if (state.storage) {
                        Object.keys(state.storage).forEach(key => {
                            // Skip the pending restore key to avoid conflicts
                            if (key !== 'win95-pending-state-restore') {
                                localStorage.setItem(key, state.storage[key]);
                            }
                        });
                    }

                    // Restore settings
                    if (state.settings) {
                        Object.keys(state.settings).forEach(key => {
                            if (state.settings[key] !== null && state.settings[key] !== undefined) {
                                const storageKey = key.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
                                if (key.startsWith('clippy')) {
                                    SafeStorage.setItem(storageKey, state.settings[key]);
                                } else {
                                    SafeStorage.setItem(`win95-${storageKey}`, state.settings[key]);
                                }
                            }
                        });
                    }

                    if (window.toastManager) {
                        window.toastManager.show('💾 Reloading with saved state...', 'success');
                    }

                    // Reload page to apply all settings
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);

                } catch (error) {
                    console.error('Import failed:', error.message);
                    if (window.toastManager) {
                        window.toastManager.show('Failed to import state: ' + error.message, 'error');
                    }
                    throw error;
                }
            }

            restorePendingState() {
                // Check if there's a pending state restore
                const pendingStateJson = SafeStorage.getItem('win95-pending-state-restore');
                if (!pendingStateJson) return;

                try {
                    const state = JSON.parse(pendingStateJson);

                    // Restore chat histories to runtime
                    if (state.chatHistories) {
                        this.chatConversationHistories = state.chatHistories;
                    }

                    // Restore desktop wallpaper
                    if (state.desktop && state.desktop.wallpaper) {
                        setTimeout(() => {
                            this.applyWallpaper(state.desktop.wallpaper);
                        }, 500);
                    }

                    // Restore icon positions
                    if (state.desktop && state.desktop.iconPositions) {
                        setTimeout(() => {
                            Object.keys(state.desktop.iconPositions).forEach(iconId => {
                                const icon = document.getElementById(iconId) ||
                                             Array.from(document.querySelectorAll('.desktop-icon'))
                                                  .find(el => el.querySelector('.icon-label')?.textContent === iconId);
                                if (icon) {
                                    const pos = state.desktop.iconPositions[iconId];
                                    icon.style.left = pos.left;
                                    icon.style.top = pos.top;
                                }
                            });
                        }, 1000);
                    }

                    // Clear the pending restore flag
                    SafeStorage.removeItem('win95-pending-state-restore');

                    // Show success notification
                    setTimeout(() => {
                        if (window.toastManager) {
                            window.toastManager.show('💾 System state fully restored!', 'success');
                        }
                    }, 1500);

                } catch (error) {
                    console.error('Failed to restore pending state:', error.message);
                    SafeStorage.removeItem('win95-pending-state-restore');
                    if (window.toastManager) {
                        window.toastManager.show('Warning: Some state could not be restored', 'warning');
                    }
                }
            }

            downloadFloppyDisk() {
                try {
                    const state = this.exportSystemState();

                    // Generate floppy disk label (8.3 format)
                    const date = new Date();
                    const diskLabel = `WIN95_${String(date.getMonth()+1).padStart(2,'0')}${String(date.getDate()).padStart(2,'0')}`;
                    const volumeSerial = Math.random().toString(16).substr(2, 4).toUpperCase() + '-' +
                                        Math.random().toString(16).substr(2, 4).toUpperCase();

                    // Create authentic floppy disk file structure with ASCII art
                    const floppyContent = `╔════════════════════════════════════════════════════════════════════════════╗
║                                                                            ║
║   ██████╗ ██╗███████╗██╗  ██╗███████╗████████╗████████╗███████╗          ║
║   ██╔══██╗██║██╔════╝██║ ██╔╝██╔════╝╚══██╔══╝╚══██╔══╝██╔════╝          ║
║   ██║  ██║██║███████╗█████╔╝ █████╗     ██║      ██║   █████╗            ║
║   ██║  ██║██║╚════██║██╔═██╗ ██╔══╝     ██║      ██║   ██╔══╝            ║
║   ██████╔╝██║███████║██║  ██╗███████╗   ██║      ██║   ███████╗          ║
║   ╚═════╝ ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝      ╚═╝   ╚══════╝          ║
║                                                                            ║
║                    ╔═══════════════════════════════╗                       ║
║                    ║    3.5" FLOPPY DISK IMAGE    ║                       ║
║                    ║       1.44 MB (HD)           ║                       ║
║                    ╚═══════════════════════════════╝                       ║
║                                                                            ║
║   ┌─────────────────────────────────────────────────────────────────┐    ║
║   │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │    ║
║   │  ▓ [========================================]           ▓  │    ║
║   │  ▓ [                                        ]           ▓  │    ║
║   │  ▓ [        WINDOWS 95 SAVE STATE          ]           ▓  │    ║
║   │  ▓ [                                        ]           ▓  │    ║
║   │  ▓ [========================================]   ┌────┐  ▓  │    ║
║   │  ▓                                              │▓▓▓▓│  ▓  │    ║
║   │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓│▓▓▓▓│▓▓▓  │    ║
║   │                                                └────┘      │    ║
║   └─────────────────────────────────────────────────────────────────┘    ║
║                                                                            ║
╚════════════════════════════════════════════════════════════════════════════╝

╔══════════════════════════════════════════════════════════════════════════╗
║                           BOOT SECTOR INFORMATION                        ║
╚══════════════════════════════════════════════════════════════════════════╝

  Volume Label:    ${diskLabel.padEnd(11)}
  File System:     FAT12
  Volume Serial:   ${volumeSerial}
  Format Date:     ${date.toLocaleString()}
  Sectors/Track:   18
  Heads:           2
  Cylinders:       80
  Bytes/Sector:    512
  Total Sectors:   2880
  Capacity:        1,474,560 bytes (1.44 MB)

╔══════════════════════════════════════════════════════════════════════════╗
║                              DIRECTORY LISTING                           ║
╚══════════════════════════════════════════════════════════════════════════╝

  Filename         Ext   Size      Date         Time    Attr
  ──────────────────────────────────────────────────────────────────────────
  AUTOEXEC     BAT     128  ${date.toLocaleDateString().padEnd(12)} ${date.toLocaleTimeString().padEnd(8)} R--
  CONFIG       SYS      64  ${date.toLocaleDateString().padEnd(12)} ${date.toLocaleTimeString().padEnd(8)} R--
  SAVEDATA     DAT   ${String(JSON.stringify(state).length).padStart(6)}  ${date.toLocaleDateString().padEnd(12)} ${date.toLocaleTimeString().padEnd(8)} ---
  README       TXT     512  ${date.toLocaleDateString().padEnd(12)} ${date.toLocaleTimeString().padEnd(8)} R--

  4 File(s)    ${String(JSON.stringify(state).length + 704).padStart(10)} bytes
  ${String(1474560 - JSON.stringify(state).length - 704).padStart(10)} bytes free

╔══════════════════════════════════════════════════════════════════════════╗
║                              README.TXT                                  ║
╚══════════════════════════════════════════════════════════════════════════╝

  WINDOWS 95 SESSION SAVE STATE - VIRTUAL FLOPPY DISK
  ═══════════════════════════════════════════════════

  This is a genuine Windows 95 session save state stored in the classic
  3.5" floppy disk format. This file contains a complete snapshot of your
  Windows 95 desktop environment at the time of saving.

  CONTENTS:
  ─────────
  • Desktop icon positions and customizations
  • All open window states and positions
  • Clippy AI chat conversation histories
  • Control Panel settings and configurations
  • Wallpaper, theme, and visual preferences
  • Volume, screensaver, and system preferences
  • Complete localStorage data snapshot

  TO RESTORE THIS SESSION:
  ────────────────────────
  1. Open Windows 95 Emulator
  2. Click the "💾 Save State" desktop icon
  3. Select "Load from Virtual Floppy"
  4. Choose this .img file
  5. System will reload with your saved state

  FILE FORMAT:
  ────────────
  Standard 3.5" High Density Floppy Disk Image
  Capacity: 1.44 MB (1,474,560 bytes)
  File System: FAT12
  Compatible with all Windows 95 emulator instances

  TECHNICAL DETAILS:
  ──────────────────
  Save Format Version: ${state.version}
  Created: ${state.timestamp}
  Display Name: ${state.displayName}

  This file is portable and can be shared with others or moved between
  devices. It will work on any browser running the Windows 95 emulator.

  ═══════════════════════════════════════════════════════════════════════

╔══════════════════════════════════════════════════════════════════════════╗
║                           [SAVEDATA.DAT BEGIN]                           ║
╚══════════════════════════════════════════════════════════════════════════╝

${JSON.stringify(state, null, 2)}

╔══════════════════════════════════════════════════════════════════════════╗
║                            [SAVEDATA.DAT END]                            ║
╚══════════════════════════════════════════════════════════════════════════╝

╔══════════════════════════════════════════════════════════════════════════╗
║                              END OF DISK                                 ║
║                   This is a genuine Windows 95 artifact                  ║
║                     Created with love and nostalgia                      ║
╚══════════════════════════════════════════════════════════════════════════╝`;

                    const blob = new Blob([floppyContent], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);

                    // Use authentic floppy disk filename format (8.3 DOS format)
                    const filename = `${diskLabel}.IMG`;
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    if (window.toastManager) {
                        window.toastManager.show(`💾 Floppy disk "${filename}" created!`, 'success');
                    }
                } catch (error) {
                    console.error('Download failed:', error.message);
                    if (window.toastManager) {
                        window.toastManager.show('Failed to save: ' + error.message, 'error');
                    }
                }
            }

            loadFloppyDisk() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.IMG,.img,.win95save,.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            let content = event.target.result;
                            let state;

                            // Check if this is the new .IMG format with ASCII art wrapper
                            if (content.includes('[SAVEDATA.DAT BEGIN]') && content.includes('[SAVEDATA.DAT END]')) {
                                // Extract JSON from between the markers
                                const beginMarker = '[SAVEDATA.DAT BEGIN]';
                                const endMarker = '[SAVEDATA.DAT END]';
                                const startIdx = content.indexOf(beginMarker) + beginMarker.length;
                                const endIdx = content.indexOf(endMarker);

                                if (startIdx > beginMarker.length && endIdx > startIdx) {
                                    const jsonContent = content.substring(startIdx, endIdx).trim();
                                    state = JSON.parse(jsonContent);
                                } else {
                                    throw new Error('Invalid floppy disk format: markers found but data extraction failed');
                                }
                            } else {
                                // Legacy format - pure JSON
                                state = JSON.parse(content);
                            }

                            this.importSystemState(state);
                        } catch (error) {
                            console.error('Failed to parse save file:', error.message);
                            if (window.toastManager) {
                                window.toastManager.show('Invalid save file format: ' + error.message, 'error');
                            }
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            openSaveStateManager() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: var(--button-face);';

                content.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="font-size: 48px; margin-bottom: 10px;">💾</div>
                        <h2 style="margin: 0 0 8px 0;">Virtual Floppy Disk Manager</h2>
                        <p style="margin: 0; color: #666; font-size: 11px;">Save and restore your Windows 95 session</p>
                    </div>

                    <div style="background: white; padding: 16px; border: 2px inset; margin-bottom: 16px;">
                        <h3 style="margin-top: 0;">💾 Save Current State</h3>
                        <p style="font-size: 11px; margin-bottom: 12px;">
                            Export your entire Windows 95 session to a virtual floppy disk file:
                        </p>
                        <ul style="font-size: 11px; margin: 8px 0; padding-left: 20px;">
                            <li>All open windows and their positions</li>
                            <li>Chat conversation histories</li>
                            <li>Desktop icon positions</li>
                            <li>Wallpaper and theme settings</li>
                            <li>Control Panel configurations</li>
                            <li>Clippy AI settings</li>
                        </ul>
                        <button class="btn primary" onclick="window.emulator.downloadFloppyDisk()" style="width: 100%; padding: 8px; margin-top: 8px;">
                            💾 Save to Virtual Floppy
                        </button>
                    </div>

                    <div style="background: white; padding: 16px; border: 2px inset; margin-bottom: 16px;">
                        <h3 style="margin-top: 0;">📂 Load Saved State</h3>
                        <p style="font-size: 11px; margin-bottom: 12px;">
                            Restore a previously saved Windows 95 session from a virtual floppy disk (.IMG file):
                        </p>
                        <div style="padding: 8px; background: #ffffc0; border: 1px solid #808080; margin-bottom: 12px; font-size: 10px;">
                            ⚠️ <strong>Warning:</strong> Loading a save will replace your current session and reload the page.
                        </div>
                        <button class="btn" onclick="window.emulator.loadFloppyDisk()" style="width: 100%; padding: 8px;">
                            📂 Load from Virtual Floppy
                        </button>
                        <p style="font-size: 10px; margin-top: 8px; color: #666;">
                            Supports: .IMG (authentic floppy), .win95save (legacy), .json
                        </p>
                    </div>

                    <div style="background: #f0f0ff; padding: 12px; border: 1px solid #808080; font-size: 10px;">
                        <strong>💡 Pro Tips:</strong><br>
                        • Save your session before closing the browser<br>
                        • Share save files with others to replicate your setup<br>
                        • Keep backups of important configurations<br>
                        • Files are stored locally - take them anywhere!<br>
                        • Compatible across all devices and browsers
                    </div>
                `;

                this.windowManager.createWindow('Virtual Floppy Manager', content, { width: 500, height: 600 });
            }

            // LocalFirst Tools Browser
            openLocalFirstBrowser() {
                const content = document.createElement('div');
                content.className = 'tools-browser-container';

                // Create header with search and filter
                const header = document.createElement('div');
                header.className = 'tools-browser-header';

                const title = document.createElement('div');
                title.style.cssText = 'font-weight: bold; margin-bottom: 8px; font-size: 12px;';
                title.textContent = '🌐 LocalFirst Tools Browser';
                header.appendChild(title);

                const searchRow = document.createElement('div');
                searchRow.className = 'tools-search-row';

                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.className = 'tools-search-input';
                searchInput.placeholder = 'Search tools...';
                searchInput.id = 'tools-search-input';
                searchRow.appendChild(searchInput);

                const categorySelect = document.createElement('select');
                categorySelect.className = 'tools-category-select';
                categorySelect.id = 'tools-category-select';
                categorySelect.innerHTML = '<option value="">All Categories</option>';
                searchRow.appendChild(categorySelect);

                header.appendChild(searchRow);

                const resultsCounter = document.createElement('div');
                resultsCounter.className = 'tools-results-counter';
                resultsCounter.id = 'tools-results-counter';
                resultsCounter.textContent = 'Loading tools...';
                header.appendChild(resultsCounter);

                content.appendChild(header);

                // Create tools grid container
                const toolsGrid = document.createElement('div');
                toolsGrid.className = 'tools-grid';
                toolsGrid.id = 'tools-grid';

                // Show loading state
                toolsGrid.innerHTML = `
                    <div class="tools-loading" style="grid-column: 1 / -1;">
                        <div class="tools-loading-spinner"></div>
                        <div>Loading LocalFirst Tools...</div>
                    </div>
                `;

                content.appendChild(toolsGrid);

                // Create status bar
                const statusBar = document.createElement('div');
                statusBar.className = 'tools-status-bar';
                statusBar.id = 'tools-status-bar';
                statusBar.textContent = 'Connecting to GitHub Pages...';
                content.appendChild(statusBar);

                this.windowManager.createWindow('LocalFirst Tools Browser', content, { width: 800, height: 600 });

                // Fetch and display tools
                this.fetchAndDisplayTools();
            }

            async fetchAndDisplayTools() {
                // Try multiple sources in order
                const SOURCES = [
                    {
                        name: 'Local',
                        url: './vibe_gallery_config.json',
                        baseUrl: './',
                        fallback: './tools-manifest.json'
                    },
                    {
                        name: 'GitHub Pages',
                        url: 'https://kody-w.github.io/localFirstTools3/vibe_gallery_config.json',
                        baseUrl: 'https://kody-w.github.io/localFirstTools3/',
                        fallback: 'https://kody-w.github.io/localFirstTools3/tools-manifest.json'
                    },
                    {
                        name: 'GitHub Raw',
                        url: 'https://raw.githubusercontent.com/kody-w/localFirstTools3/main/vibe_gallery_config.json',
                        baseUrl: 'https://raw.githubusercontent.com/kody-w/localFirstTools3/main/',
                        fallback: 'https://raw.githubusercontent.com/kody-w/localFirstTools3/main/tools-manifest.json'
                    }
                ];

                const toolsGrid = document.getElementById('tools-grid');
                const statusBar = document.getElementById('tools-status-bar');
                const resultsCounter = document.getElementById('tools-results-counter');
                const categorySelect = document.getElementById('tools-category-select');
                const searchInput = document.getElementById('tools-search-input');

                if (!toolsGrid || !statusBar) return;

                let lastError = null;
                let successfulSource = null;

                // Try each source until one works
                for (const source of SOURCES) {
                    try {
                        statusBar.textContent = `Fetching from ${source.name}...`;

                        // Try primary config first
                        let response = await fetch(source.url);
                        let config = null;
                        let usedFallback = false;

                        if (!response.ok) {
                            // Try fallback manifest
                            if (source.fallback) {
                                statusBar.textContent = `Trying fallback for ${source.name}...`;
                                response = await fetch(source.fallback);
                                usedFallback = true;
                            }

                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                        }

                        config = await response.json();

                        // Process based on config type
                        let allTools = [];
                        let categories = new Map();

                        if (usedFallback) {
                            // Process tools-manifest.json format
                            allTools = this.processFallbackManifest(config, source.baseUrl);

                            // Create a default category
                            categories.set('all', {
                                title: 'All Tools',
                                name: 'All Tools',
                                color: '#06ffa5'
                            });
                        } else {
                            // Process vibe_gallery_config.json format
                            const gallery = config.vibeGallery || config;
                            const categoriesData = gallery.categories || {};

                            // Extract all tools from all categories
                            for (const [categoryKey, categoryData] of Object.entries(categoriesData)) {
                                categories.set(categoryKey, categoryData);

                                // Handle both 'apps' (vibeGallery) and 'tools' (legacy) arrays
                                const toolsList = categoryData.apps || categoryData.tools || [];

                                if (Array.isArray(toolsList)) {
                                    toolsList.forEach(tool => {
                                        allTools.push({
                                            ...tool,
                                            // Ensure we have a path field (use filename if path not present)
                                            path: tool.path || tool.filename || tool.file || '',
                                            category: categoryKey,
                                            categoryName: categoryData.title || categoryData.name || categoryKey,
                                            categoryColor: categoryData.color || '#666666',
                                            baseUrl: source.baseUrl
                                        });
                                    });
                                }
                            }
                        }

                        // Success! Use this source
                        successfulSource = source;
                        lastError = null;

                        // Store for filtering
                        this.toolsBrowserState = {
                            allTools: allTools,
                            categories: categories,
                            baseUrl: source.baseUrl,
                            currentSearch: '',
                            currentCategory: ''
                        };

                        // Clear and populate category dropdown
                        categorySelect.innerHTML = '<option value="">All Categories</option>';

                        const sortedCategories = Array.from(categories.entries()).sort((a, b) => {
                            const aName = a[1].title || a[1].name || a[0];
                            const bName = b[1].title || b[1].name || b[0];
                            return aName.localeCompare(bName);
                        });

                        sortedCategories.forEach(([key, data]) => {
                            const option = document.createElement('option');
                            option.value = key;
                            option.textContent = data.title || data.name || key;
                            categorySelect.appendChild(option);
                        });

                        // Set up search with debounce (only if not already set up)
                        if (!searchInput.dataset.initialized) {
                            let searchTimeout;
                            searchInput.addEventListener('input', (e) => {
                                clearTimeout(searchTimeout);
                                searchTimeout = setTimeout(() => {
                                    this.toolsBrowserState.currentSearch = e.target.value.toLowerCase();
                                    this.filterAndDisplayTools();
                                }, 250);
                            });
                            searchInput.dataset.initialized = 'true';
                        }

                        // Set up category filter (only if not already set up)
                        if (!categorySelect.dataset.initialized) {
                            categorySelect.addEventListener('change', (e) => {
                                this.toolsBrowserState.currentCategory = e.target.value;
                                this.filterAndDisplayTools();
                            });
                            categorySelect.dataset.initialized = 'true';
                        }

                        // Initial display
                        this.filterAndDisplayTools();

                        const sourceLabel = usedFallback ? `${source.name} (fallback)` : source.name;
                        statusBar.textContent = `✅ Loaded ${allTools.length} tools from ${categories.size} categories (${sourceLabel})`;

                        // Break out of loop on success
                        break;

                    } catch (error) {
                        console.warn(`Failed to load from ${source.name}:`, error);
                        lastError = error;
                        // Continue to next source
                    }
                }

                // If all sources failed, try one more fallback - scan current directory
                if (lastError && !successfulSource) {
                    statusBar.textContent = 'Trying local scan fallback...';
                    const scanResult = await this.tryLocalScan();
                    if (scanResult) {
                        return; // Successfully loaded from scan
                    }
                }

                // If everything failed, show helpful error
                if (lastError && !successfulSource) {
                    console.error('Failed to fetch tools from all sources:', lastError);
                    toolsGrid.innerHTML = `
                        <div class="tools-error" style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                            <div class="tools-error-icon" style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                            <div style="font-weight: bold; margin-bottom: 8px; font-size: 16px;">Failed to Load Tools</div>
                            <div style="margin-bottom: 16px; color: #666;">Tried Local, GitHub Pages, and GitHub Raw sources</div>
                            <div style="margin-bottom: 8px; font-size: 14px; color: #999;">
                                ${lastError.message === 'Failed to fetch' ?
                                    'Network error or CORS restriction. Try running from a web server:' :
                                    lastError.message}
                            </div>
                            ${lastError.message === 'Failed to fetch' ? `
                                <div style="margin-bottom: 16px; font-size: 12px; color: #888; font-family: monospace;">
                                    python3 -m http.server 8000<br>
                                    Then open: http://localhost:8000/windows95-emulator.html
                                </div>
                            ` : ''}
                            <button class="btn" onclick="emulator.fetchAndDisplayTools()" style="padding: 8px 16px;">
                                🔄 Retry
                            </button>
                        </div>
                    `;
                    statusBar.textContent = '❌ Error: Could not load tools from any source';
                    if (resultsCounter) {
                        resultsCounter.textContent = 'Failed to load tools';
                    }
                }
            }

            // Process tools-manifest.json format
            processFallbackManifest(manifest, baseUrl) {
                if (!manifest || !manifest.tools) return [];

                return manifest.tools.map(file => ({
                    filename: file.name || file,
                    title: this.formatTitle(file.name || file),
                    path: file.name || file,
                    description: `Interactive ${this.formatTitle(file.name || file)} application`,
                    tags: this.extractTagsFromFilename(file.name || file),
                    category: 'all',
                    categoryKey: 'all',
                    categoryName: 'All Tools',
                    categoryColor: '#06ffa5',
                    featured: false,
                    complexity: 'intermediate',
                    interactionType: 'interface',
                    baseUrl: baseUrl
                }));
            }

            // Extract tags from filename
            extractTagsFromFilename(filename) {
                const name = filename.replace('.html', '').replace(/-/g, ' ');
                const words = name.split(' ');
                return words.filter(w => w.length > 3).slice(0, 5);
            }

            // Format title from filename
            formatTitle(filename) {
                return filename
                    .replace('.html', '')
                    .replace(/-/g, ' ')
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
            }

            // Try to scan local directory as last resort
            async tryLocalScan() {
                try {
                    // Use embedded fallback list - works even from file:// protocol
                    const embeddedTools = [
                        "3d-particle-physics-simulator.html", "3d-world-navigation.html", "agent-browser.html",
                        "ai-companion-hub-enhanced.html", "ai-simulation-sales-demo.html", "algorithm-visualizer-pro.html",
                        "api-request-tester.html", "artifact-converter.html", "audio-spectrum-visualizer.html",
                        "autonomous-book-factory.html", "book-factory-world.html", "breathwork-guide.html",
                        "budget-tracker-expense-manager.html", "canvas-svg-graphics-workshop.html", "card-counting-trainer.html",
                        "cdn-file-manager.html", "chart-builder-pro.html", "cityofHeroes.html",
                        "claude-subagents-tutorial.html", "color-palette-generator.html", "color-picker-palette-generator.html",
                        "complete-retroplay-console.html", "compressed-book-factory.html", "consolidated-ai-tools.html",
                        "copilot-agent-store.html", "crystal-caves-world.html", "css-animation-builder.html",
                        "data-structures-visualizer.html", "database-designer-erd.html", "digital-twin-keeper.html",
                        "drone-simulator.html", "drum-machine-808.html", "dual-camera-recorder.html",
                        "dynamic-agent-workflow.html", "emdr-complete.html", "executive-memory-visualizer.html",
                        "feedShyworm4.html", "fpspic.html", "gameboy-emulator.html", "gameoflife.html",
                        "github-gallery-setup.html", "github-sync-manager.html", "ghostwriter.html",
                        "hearthstone-card-battle.html", "hologram-camera-recorder.html", "index.html",
                        "jim-rohn-journal-app.html", "linux-terminal-emulator.html", "local-browser.html",
                        "mcp-registry.html", "mermaid-viewer.html", "monster-truck-game.html",
                        "nexus-holographic-companion.html", "nexus.html", "NexusWorlds.html",
                        "omni-writer.html", "physics-playground-lab.html", "pipboy-interface.html",
                        "poker-trainer-continued.html", "presentation_app_complete.html", "prompt-library.html",
                        "racing.html", "rainbow-svg-path.html", "record-review-app.html",
                        "severance-refiner.html", "sky-realms-game.html", "snake3.html", "solitaire-tutorial-game.html",
                        "snap-message-app.html", "sneaker-net-social.html", "steamdeck-game.html",
                        "teacher-learner-app.html", "terminal-viewer.html", "text-file-splitter.html",
                        "tile-room-3d.html", "timezone-converter-tool.html", "vibe-terminal.html",
                        "windows95-emulator.html", "wordpress-crawler.html", "workshop.html",
                        "wristAI.html", "youtube-webcam-recorder.html"
                    ];

                    const allTools = embeddedTools.map(filename => ({
                        filename: filename,
                        title: this.formatTitle(filename),
                        path: filename,
                        description: `Interactive ${this.formatTitle(filename)} application`,
                        tags: this.extractTagsFromFilename(filename),
                        category: 'all',
                        categoryKey: 'all',
                        categoryName: 'All Tools',
                        categoryColor: '#06ffa5',
                        featured: false,
                        complexity: 'intermediate',
                        interactionType: 'interface',
                        baseUrl: './'
                    }));

                    // Create working state with embedded tools
                    this.toolsBrowserState = {
                        allTools: allTools,
                        categories: new Map([['all', { title: 'All Tools', color: '#06ffa5' }]]),
                        baseUrl: './',
                        currentSearch: '',
                        currentCategory: ''
                    };

                    // Populate category dropdown
                    const categorySelect = document.getElementById('tools-category-select');
                    if (categorySelect) {
                        categorySelect.innerHTML = '<option value="">All Categories</option>';
                        const option = document.createElement('option');
                        option.value = 'all';
                        option.textContent = 'All Tools';
                        categorySelect.appendChild(option);
                    }

                    this.filterAndDisplayTools();

                    const statusBar = document.getElementById('tools-status-bar');
                    if (statusBar) {
                        statusBar.textContent = `✅ Loaded ${allTools.length} tools (embedded fallback)`;
                    }

                    return true;
                } catch (error) {
                    console.error('Fallback load failed:', error);
                    return false;
                }
            }

            filterAndDisplayTools() {
                const state = this.toolsBrowserState;
                if (!state) return;

                const toolsGrid = document.getElementById('tools-grid');
                const resultsCounter = document.getElementById('tools-results-counter');
                if (!toolsGrid) return;

                // Filter tools
                let filteredTools = state.allTools;

                // Apply category filter
                if (state.currentCategory) {
                    filteredTools = filteredTools.filter(tool => tool.category === state.currentCategory);
                }

                // Apply search filter
                if (state.currentSearch) {
                    filteredTools = filteredTools.filter(tool => {
                        const searchStr = state.currentSearch;
                        return (
                            (tool.title || '').toLowerCase().includes(searchStr) ||
                            (tool.description || '').toLowerCase().includes(searchStr) ||
                            (tool.path || '').toLowerCase().includes(searchStr) ||
                            (tool.tags || []).some(tag => tag.toLowerCase().includes(searchStr))
                        );
                    });
                }

                // Update counter
                if (resultsCounter) {
                    resultsCounter.textContent = `Showing ${filteredTools.length} tool${filteredTools.length !== 1 ? 's' : ''}`;
                }

                // Display tools
                if (filteredTools.length === 0) {
                    toolsGrid.innerHTML = `
                        <div class="tools-empty" style="grid-column: 1 / -1;">
                            <div style="font-size: 48px; margin-bottom: 12px;">📭</div>
                            <div style="font-weight: bold; margin-bottom: 8px;">No Tools Found</div>
                            <div>Try adjusting your search or filter</div>
                        </div>
                    `;
                    return;
                }

                toolsGrid.innerHTML = '';

                filteredTools.forEach(tool => {
                    const card = this.createToolCard(tool);
                    toolsGrid.appendChild(card);
                });
            }

            createToolCard(tool) {
                const card = document.createElement('div');
                card.className = 'tool-card';

                // Title
                const title = document.createElement('div');
                title.className = 'tool-card-title';
                title.textContent = tool.title || 'Untitled Tool';
                card.appendChild(title);

                // Description
                const description = document.createElement('div');
                description.className = 'tool-card-description';
                const desc = tool.description || 'No description available';
                description.textContent = desc.length > 100 ? desc.substring(0, 100) + '...' : desc;
                card.appendChild(description);

                // Meta container
                const meta = document.createElement('div');
                meta.className = 'tool-card-meta';

                // Category badge
                const badge = document.createElement('div');
                badge.className = 'category-badge';
                badge.textContent = tool.categoryName || tool.category || 'Uncategorized';
                badge.style.backgroundColor = tool.categoryColor || '#808080';
                meta.appendChild(badge);

                // Tags (first 3)
                if (tool.tags && tool.tags.length > 0) {
                    const tagsContainer = document.createElement('div');
                    tagsContainer.className = 'tool-tags';

                    const displayTags = tool.tags.slice(0, 3);
                    displayTags.forEach(tag => {
                        const tagPill = document.createElement('span');
                        tagPill.className = 'tag-pill';
                        tagPill.textContent = tag;
                        tagsContainer.appendChild(tagPill);
                    });

                    if (tool.tags.length > 3) {
                        const morePill = document.createElement('span');
                        morePill.className = 'tag-pill';
                        morePill.textContent = `+${tool.tags.length - 3} more`;
                        morePill.style.fontStyle = 'italic';
                        tagsContainer.appendChild(morePill);
                    }

                    meta.appendChild(tagsContainer);
                }

                card.appendChild(meta);

                // Open button
                const button = document.createElement('button');
                button.className = 'btn tool-card-button';
                button.textContent = '🚀 Open Tool';
                button.onclick = (e) => {
                    e.stopPropagation();
                    this.openToolInWindow(tool);
                };
                card.appendChild(button);

                // Make entire card clickable
                card.onclick = () => {
                    this.openToolInWindow(tool);
                };

                return card;
            }

            async openToolInWindow(tool) {
                const state = this.toolsBrowserState;
                if (!state) return;

                // Construct proper URL
                let toolUrl = tool.path || tool.filename || tool.file || '';

                // Remove leading slash if present to avoid double slashes
                toolUrl = toolUrl.replace(/^\/+/, '');

                // Construct full URL
                const fullUrl = state.baseUrl + toolUrl;

                // Show loading notification
                if (window.toastManager) {
                    window.toastManager.show(`Loading ${tool.title}...`, 'info');
                }

                try {
                    // Fetch the raw HTML content
                    const response = await fetch(fullUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const htmlContent = await response.text();

                    // Create container for the tool
                    const toolWindow = document.createElement('div');
                    toolWindow.style.cssText = 'width: 100%; height: 100%; background: white; overflow: hidden;';

                    // Create iframe with relaxed sandbox to allow full functionality
                    const iframe = document.createElement('iframe');
                    iframe.style.cssText = 'width: 100%; height: 100%; border: none; display: block;';
                    iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups allow-modals allow-downloads';

                    toolWindow.appendChild(iframe);

                    // Create window first with reasonable default size
                    const windowWidth = Math.min(1000, window.innerWidth - 100);
                    const windowHeight = Math.min(700, window.innerHeight - 100);

                    this.windowManager.createWindow(
                        tool.title || 'LocalFirst Tool',
                        toolWindow,
                        { width: windowWidth, height: windowHeight }
                    );

                    // Write content to iframe document after window is created
                    // This avoids CORS issues by creating a same-origin document
                    iframe.contentDocument.open();
                    iframe.contentDocument.write(htmlContent);
                    iframe.contentDocument.close();

                    // Success notification
                    if (window.toastManager) {
                        window.toastManager.show(`Loaded ${tool.title}`, 'success');
                    }

                } catch (error) {
                    console.error('Failed to load tool:', error);
                    if (window.toastManager) {
                        window.toastManager.show(`Failed to load ${tool.title}: ${error.message}`, 'error');
                    }
                }

            }

            // Taskbar management
            addTaskbarButton(windowObj) {
                const button = document.createElement('button');
                button.className = 'taskbar-button';
                button.textContent = windowObj.title;
                button.dataset.windowId = windowObj.id;
                button.onclick = () => {
                    if (windowObj.minimized) {
                        this.windowManager.restoreWindow(windowObj.element);
                    } else {
                        this.windowManager.focusWindow(windowObj.element);
                    }
                };

                // Insert before system tray
                const canvas = document.getElementById('screen');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    // Add to taskbar visually (this is a simplification)
                }

                this.taskbarButtons.push({ windowObj, button });
            }

            removeTaskbarButton(windowObj) {
                const index = this.taskbarButtons.findIndex(tb => tb.windowObj.id === windowObj.id);
                if (index > -1) {
                    this.taskbarButtons.splice(index, 1);
                }
            }

            updateTaskbarButtons() {
                // Update active state of taskbar buttons
                this.taskbarButtons.forEach(tb => {
                    const isActive = tb.windowObj.element.classList.contains('active');
                    if (isActive) {
                        tb.button.classList.add('active');
                    } else {
                        tb.button.classList.remove('active');
                    }
                });
            }

            initEmulatorCore() {
                console.log("Initializing x86 emulator core...");

                // Load saved desktop customization
                this.loadDesktopCustomization();
            }

            loadDesktopCustomization() {
                // Apply saved desktop background color
                const savedBgColor = SafeStorage.getItem('win95-desktop-color');
                if (savedBgColor) {
                    setTimeout(() => {
                        const screenContainer = document.getElementById('screen_container');
                        if (screenContainer) {
                            screenContainer.style.background = savedBgColor;
                        }
                    }, 100);
                }

                // Load and apply wallpaper
                setTimeout(() => {
                    this.loadWallpaper();
                }, 150);
            }

            detectSystemInfo() {
                // Detect browser
                const ua = navigator.userAgent;
                let browser = 'Unknown';
                if (ua.indexOf('Firefox') > -1) browser = 'Mozilla Firefox';
                else if (ua.indexOf('Chrome') > -1) browser = 'Google Chrome';
                else if (ua.indexOf('Safari') > -1) browser = 'Apple Safari';
                else if (ua.indexOf('Edge') > -1) browser = 'Microsoft Edge';
                else if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) browser = 'Internet Explorer';

                // Check WebAssembly support
                const wasmSupport = typeof WebAssembly !== 'undefined' ? 
                    '<span style="color: green;">✓ Supported</span>' : 
                    '<span style="color: red;">✗ Not Supported</span>';

                // Get screen info
                const screenInfo = `${window.screen.width}x${window.screen.height}`;

                // Update UI
                setTimeout(() => {
                    const browserInfo = document.getElementById('browser-info');
                    const wasmInfo = document.getElementById('wasm-support');
                    const screenInfoEl = document.getElementById('screen-info');
                    
                    if (browserInfo) browserInfo.innerHTML = browser;
                    if (wasmInfo) wasmInfo.innerHTML = wasmSupport;
                    if (screenInfoEl) screenInfoEl.textContent = screenInfo;
                }, 100);
            }

            initDOMCache() {
                if (this.domCache) return;

                try {
                    this.domCache = {
                        fpsCounter: document.getElementById('fps-counter'),
                        timeDisplay: document.getElementById('time-display'),
                        cpuLed: document.getElementById('cpu-led'),
                        cpuStatus: document.getElementById('cpu-status'),
                        hddLed: document.getElementById('hdd-led'),
                        loadingScreen: document.getElementById('loading-screen'),
                        loadingText: document.getElementById('loading-text'),
                        progressFill: document.getElementById('progress-fill'),
                        setupScreen: document.getElementById('setup-screen'),
                        emulatorContainer: document.getElementById('emulator-container'),
                        emulatorTitlebar: document.getElementById('emulator-titlebar'),
                        memoryUsage: document.getElementById('memory-usage'),
                        pauseBtn: document.getElementById('pause-btn')
                    };
                } catch (error) {
                    console.error('Failed to initialize DOM cache:', error);
                    throw new Error('Required DOM elements not found');
                }
            }

            async loadDemo() {
                try {
                    this.showLoading('Initializing emulator...');
                    this.initDOMCache();

                    // Read settings
                    this.updateSettings();

                    this.canvas = document.getElementById('screen');
                    if (!this.canvas) {
                        throw new Error('Canvas element not found');
                    }

                    this.ctx = this.canvas.getContext('2d', {
                        alpha: false,
                        desynchronized: true,
                        willReadFrequently: false
                    });

                    if (!this.ctx) {
                        throw new Error('Could not get 2D rendering context. Canvas may be disabled.');
                    }

                    // Calculate available viewport size dynamically
                    // Header will be hidden, so don't account for it
                    const statusBar = document.querySelector('.status-bar');
                    const statusBarHeight = statusBar ? statusBar.offsetHeight : 22;

                    const availableWidth = window.innerWidth;
                    const availableHeight = window.innerHeight - statusBarHeight;

                    // Set canvas to fill available space
                    this.canvas.width = availableWidth;
                    this.canvas.height = availableHeight;

                    // Update CONFIG to match actual dimensions
                    CONFIG.DISPLAY.WIDTH = availableWidth;
                    CONFIG.DISPLAY.HEIGHT = availableHeight;
                    CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(availableHeight * 0.0625));

                    this.domCache.setupScreen.classList.add('hidden');
                    this.domCache.emulatorContainer.classList.remove('hidden');

                    // Hide header and info panel for immersive OS experience
                    const header = document.querySelector('.header');
                    const infoPanel = document.getElementById('info-panel');
                    if (header) header.classList.add('hidden');
                    if (infoPanel) infoPanel.classList.add('hidden');

                    await this.simulateBoot();

                    this.hideLoading();
                    this.startEmulation();
                    
                    // Setup mouse capture
                    this.setupMouseCapture();
                } catch (error) {
                    console.error('Failed to load demo:', error);
                    window.dialogManager.error(`Failed to start emulator: ${error.message}\n\nPlease check console for details.`, 'Windows 95 Emulator');
                    this.hideLoading();
                }
            }

            updateSettings() {
                try {
                    const memorySelect = document.getElementById('memory-size');
                    const cpuSpeedSelect = document.getElementById('cpu-speed');
                    const enableMouse = document.getElementById('enable-mouse');
                    const enableSound = document.getElementById('enable-sound');
                    const enableNetwork = document.getElementById('enable-network');

                    this.settings.memory = parseInt(memorySelect.value) * 1024 * 1024;
                    this.settings.cpuSpeed = parseInt(cpuSpeedSelect.value);
                    this.settings.enableMouse = enableMouse.checked;
                    this.settings.enableSound = enableSound.checked;
                    this.settings.enableNetwork = enableNetwork.checked;

                } catch (error) {
                    console.error('Failed to update settings:', error);
                }
            }

            setupMouseCapture() {
                // Disabled pointer lock for interactive desktop mode
                // Users need free mouse movement to interact with windows and icons
                return;
            }

            async simulateBoot() {
                const bootMessages = [
                    'PhoenixBIOS 4.0 Release 6.0',
                    'Copyright 1985-1995 Phoenix Technologies Ltd.',
                    'All Rights Reserved',
                    '',
                    'CPU: Intel Pentium ' + (this.settings.cpuSpeed * 75) + 'MHz',
                    'Memory Test: ' + (this.settings.memory / 1024) + 'K OK',
                    'Cache: 256K',
                    '',
                    'Press DEL to enter SETUP, ESC to skip memory test',
                    '',
                    'Detecting IDE drives...',
                    'Primary Master: 540MB Hard Disk',
                    'Primary Slave: None',
                    'Secondary Master: CD-ROM Drive',
                    'Secondary Slave: None',
                    '',
                    'Starting MS-DOS...',
                    '',
                    'HIMEM is testing extended memory...done.',
                    'EMM386 Memory Manager v4.49',
                    '',
                    'C:\\>win',
                    '',
                    'Starting Windows 95...'
                ];

                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);
                this.ctx.font = '14px monospace';
                this.ctx.fillStyle = '#c0c0c0';

                for (let i = 0; i < bootMessages.length; i++) {
                    await this.delay(CONFIG.ANIMATION.BOOT_MESSAGE_DELAY);
                    this.ctx.fillText(bootMessages[i], 10, 20 + i * 16);
                    this.updateProgress((i + 1) / bootMessages.length * 50);
                    this.updateLoadingText('Loading BIOS...');
                }

                await this.delay(500);
                this.updateLoadingText('Loading Windows 95...');

                // Clear screen
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);

                // Draw Windows logo with gradient
                const gradient = this.ctx.createLinearGradient(200, 200, 440, 280);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.25, '#ffff00');
                gradient.addColorStop(0.5, '#00ff00');
                gradient.addColorStop(1, '#0000ff');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(220, 200, 200, 80);

                // Add shine effect
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.fillRect(220, 200, 200, 20);

                // Windows text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 24px Arial';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                this.ctx.shadowBlur = 4;
                this.ctx.fillText('Windows 95', 250, 320);
                this.ctx.shadowBlur = 0;

                // Progress bar
                this.ctx.strokeStyle = '#c0c0c0';
                this.ctx.strokeRect(220, 340, 200, 10);

                // Animate progress
                for (let i = 0; i <= 100; i += 5) {
                    await this.delay(40);
                    this.ctx.fillStyle = '#0000ff';
                    this.ctx.fillRect(221, 341, (198 * i) / 100, 8);
                    this.updateProgress(50 + i / 2);
                }

                this.updateLoadingText('Starting desktop...');
            }

            drawDesktop() {
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;

                // WAVE 4 ENHANCEMENT #3: Desktop Wallpaper System
                const wallpaperEnabled = SafeStorage.getItem('win95-wallpaper-enabled') === 'true';
                const wallpaperType = SafeStorage.getItem('win95-wallpaper-type') || 'none';
                const wallpaperMode = SafeStorage.getItem('win95-wallpaper-mode') || 'tile';

                // Draw desktop background color first
                const bgColor = SafeStorage.getItem('win95-desktop-color') || CONFIG.COLORS.DESKTOP;
                this.ctx.fillStyle = bgColor;
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);

                // Draw wallpaper if enabled
                if (wallpaperEnabled && wallpaperType !== 'none') {
                    this.drawWallpaper(wallpaperType, wallpaperMode, taskbarY);
                }

                // Draw taskbar with gradient
                const taskbarGrad = this.ctx.createLinearGradient(0, taskbarY, 0, CONFIG.DISPLAY.HEIGHT);
                taskbarGrad.addColorStop(0, '#dfdfdf');
                taskbarGrad.addColorStop(1, '#c0c0c0');
                this.ctx.fillStyle = taskbarGrad;
                this.ctx.fillRect(0, taskbarY, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.TASKBAR_HEIGHT);

                // Taskbar border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.moveTo(0, taskbarY);
                this.ctx.lineTo(CONFIG.DISPLAY.WIDTH, taskbarY);
                this.ctx.stroke();

                // Start button with gradient
                const startY = taskbarY + 2;
                const startHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 4;
                const startGrad = this.ctx.createLinearGradient(2, startY, 2, startY + startHeight);
                startGrad.addColorStop(0, '#ffffff');
                startGrad.addColorStop(0.5, '#c0c0c0');
                startGrad.addColorStop(1, '#808080');
                this.ctx.fillStyle = startGrad;
                this.ctx.fillRect(2, startY, 60, startHeight);

                // Start button border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(2, startY, 60, startHeight);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(3, startY + 1, 58, startHeight - 2);

                // Start text
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 11px Arial';
                const textY = startY + (startHeight / 2) + 4;
                this.ctx.fillText('Start', 20, textY);

                // Windows logo on button
                const logoY = startY + (startHeight / 2) - 4;
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(6, logoY, 4, 4);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(10, logoY, 4, 4);
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(6, logoY + 4, 4, 4);
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(10, logoY + 4, 4, 4);

                // System tray
                const trayY = taskbarY + 3;
                const trayHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 6;
                this.ctx.fillStyle = '#808080';
                this.ctx.fillRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);

                // Clock
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '11px Arial';
                const clockY = trayY + (trayHeight / 2) + 4;
                this.ctx.fillText(timeStr, CONFIG.DISPLAY.WIDTH - 50, clockY);
            }

            // WAVE 4 ENHANCEMENT #3: Wallpaper Rendering
            drawWallpaper(type, mode, taskbarY) {
                const patterns = {
                    'clouds': () => {
                        // Classic Windows 95 clouds pattern
                        for (let y = 0; y < taskbarY; y += 100) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += 120) {
                                // Draw fluffy cloud shapes
                                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                                this.ctx.beginPath();
                                this.ctx.arc(x + 30, y + 40, 20, 0, Math.PI * 2);
                                this.ctx.arc(x + 50, y + 35, 25, 0, Math.PI * 2);
                                this.ctx.arc(x + 70, y + 40, 20, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                    },
                    'pattern1': () => {
                        // Teal geometric pattern
                        this.ctx.fillStyle = '#006666';
                        for (let y = 0; y < taskbarY; y += 20) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += 20) {
                                if ((x + y) % 40 === 0) {
                                    this.ctx.fillRect(x, y, 10, 10);
                                }
                            }
                        }
                    },
                    'pattern2': () => {
                        // Diagonal lines
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        this.ctx.lineWidth = 2;
                        for (let i = 0; i < CONFIG.DISPLAY.WIDTH + taskbarY; i += 30) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(i, 0);
                            this.ctx.lineTo(i - taskbarY, taskbarY);
                            this.ctx.stroke();
                        }
                    },
                    'pattern3': () => {
                        // Checkerboard
                        const squareSize = 40;
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        for (let y = 0; y < taskbarY; y += squareSize) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += squareSize) {
                                if ((Math.floor(x / squareSize) + Math.floor(y / squareSize)) % 2 === 0) {
                                    this.ctx.fillRect(x, y, squareSize, squareSize);
                                }
                            }
                        }
                    },
                    'gradient1': () => {
                        // Vertical gradient
                        const grad = this.ctx.createLinearGradient(0, 0, 0, taskbarY);
                        grad.addColorStop(0, '#000080');
                        grad.addColorStop(1, '#008080');
                        this.ctx.fillStyle = grad;
                        this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, taskbarY);
                    },
                    'gradient2': () => {
                        // Diagonal gradient
                        const grad = this.ctx.createLinearGradient(0, 0, CONFIG.DISPLAY.WIDTH, taskbarY);
                        grad.addColorStop(0, '#800080');
                        grad.addColorStop(0.5, '#008080');
                        grad.addColorStop(1, '#008000');
                        this.ctx.fillStyle = grad;
                        this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, taskbarY);
                    },
                    // WAVE 6: Additional wallpaper patterns
                    'pattern4': () => {
                        // Honeycomb pattern
                        const hexSize = 30;
                        this.ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                        this.ctx.lineWidth = 2;
                        for (let y = 0; y < taskbarY; y += hexSize * 1.5) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += hexSize * 1.75) {
                                const offsetX = (Math.floor(y / (hexSize * 1.5)) % 2) * hexSize * 0.875;
                                this.ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (Math.PI / 3) * i;
                                    const hx = x + offsetX + hexSize * Math.cos(angle);
                                    const hy = y + hexSize * Math.sin(angle);
                                    if (i === 0) this.ctx.moveTo(hx, hy);
                                    else this.ctx.lineTo(hx, hy);
                                }
                                this.ctx.closePath();
                                this.ctx.stroke();
                            }
                        }
                    },
                    'pattern5': () => {
                        // Triangles pattern
                        const size = 40;
                        this.ctx.fillStyle = 'rgba(255, 200, 100, 0.15)';
                        this.ctx.strokeStyle = 'rgba(255, 150, 50, 0.3)';
                        this.ctx.lineWidth = 1;
                        for (let y = 0; y < taskbarY; y += size) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += size) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(x, y);
                                this.ctx.lineTo(x + size, y);
                                this.ctx.lineTo(x + size/2, y + size);
                                this.ctx.closePath();
                                this.ctx.fill();
                                this.ctx.stroke();
                            }
                        }
                    },
                    'pattern6': () => {
                        // Dots pattern
                        const spacing = 30;
                        const dotSize = 5;
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                        for (let y = 0; y < taskbarY; y += spacing) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += spacing) {
                                this.ctx.beginPath();
                                this.ctx.arc(x + spacing/2, y + spacing/2, dotSize, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                    },
                    'pattern7': () => {
                        // Red rings pattern
                        const spacing = 60;
                        const ringRadius = 20;
                        this.ctx.strokeStyle = 'rgba(200, 50, 50, 0.25)';
                        this.ctx.lineWidth = 3;
                        for (let y = 0; y < taskbarY; y += spacing) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += spacing) {
                                this.ctx.beginPath();
                                this.ctx.arc(x + spacing/2, y + spacing/2, ringRadius, 0, Math.PI * 2);
                                this.ctx.stroke();
                                this.ctx.beginPath();
                                this.ctx.arc(x + spacing/2, y + spacing/2, ringRadius * 0.6, 0, Math.PI * 2);
                                this.ctx.stroke();
                            }
                        }
                    },
                    'pattern8': () => {
                        // Leaves pattern
                        const spacing = 50;
                        this.ctx.fillStyle = 'rgba(50, 150, 50, 0.2)';
                        this.ctx.strokeStyle = 'rgba(30, 100, 30, 0.3)';
                        this.ctx.lineWidth = 1;
                        for (let y = 0; y < taskbarY; y += spacing) {
                            for (let x = 0; x < CONFIG.DISPLAY.WIDTH; x += spacing) {
                                // Draw leaf shape
                                this.ctx.beginPath();
                                this.ctx.moveTo(x, y + 20);
                                this.ctx.quadraticCurveTo(x + 15, y, x + 10, y - 10);
                                this.ctx.quadraticCurveTo(x + 5, y, x, y + 20);
                                this.ctx.fill();
                                this.ctx.stroke();
                            }
                        }
                    },
                    'gradient3': () => {
                        // Sunset gradient
                        const grad = this.ctx.createLinearGradient(0, 0, 0, taskbarY);
                        grad.addColorStop(0, '#FF6B35');
                        grad.addColorStop(0.5, '#F7931E');
                        grad.addColorStop(1, '#FDC830');
                        this.ctx.fillStyle = grad;
                        this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, taskbarY);
                    },
                    'gradient4': () => {
                        // Space gradient (dark to purple)
                        const grad = this.ctx.createLinearGradient(0, 0, 0, taskbarY);
                        grad.addColorStop(0, '#0F2027');
                        grad.addColorStop(0.5, '#203A43');
                        grad.addColorStop(1, '#2C5364');
                        this.ctx.fillStyle = grad;
                        this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, taskbarY);
                        // Add stars
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        for (let i = 0; i < 50; i++) {
                            const sx = Math.random() * CONFIG.DISPLAY.WIDTH;
                            const sy = Math.random() * taskbarY;
                            const size = Math.random() * 2;
                            this.ctx.fillRect(sx, sy, size, size);
                        }
                    }
                };

                if (patterns[type]) {
                    patterns[type]();
                }
            }

            startEmulation() {
                this.isRunning = true;
                this.startTime = Date.now();
                this.drawDesktop();

                // Create interactive desktop icons
                this.createDesktopIcon(20, 20, 'My Computer', '💻', () => this.openFileExplorer());
                this.createDesktopIcon(20, 90, 'Internet', '🌐', () => this.openInternetExplorer());
                this.createDesktopIcon(20, 160, 'Recycle Bin', '🗑️', () => this.openRecycleBin());
                this.createDesktopIcon(100, 20, 'MS-DOS Prompt', '⬛', () => this.openDOSPrompt());
                this.createDesktopIcon(100, 90, 'Paint', '🎨', () => this.openPaint());
                this.createDesktopIcon(100, 160, 'Notepad', '📝', () => this.openNotepad());
                this.createDesktopIcon(180, 20, 'Save State', '💾', () => this.openSaveStateManager());
                this.createDesktopIcon(180, 90, 'Chromium', '🌐', () => this.openChromiumBrowser());

                // Create Start menu
                this.createStartMenu();

                // Setup desktop click handlers
                this.setupDesktopInteractions();

                // Start animation loop
                this.updateStatus();
                this.animate();

                // Start clock update (every second)
                this.clockInterval = setInterval(() => {
                    this.updateSystemClock();
                }, 1000);

                // Initialize Recycle Bin with sample data (only on first load)
                if (!SafeStorage.getItem('win95-recycle-bin-initialized')) {
                    this.moveToRecycleBin('Old Document.txt', 'Text File', '3 KB', '📄');
                    this.moveToRecycleBin('Unused Image.bmp', 'Bitmap Image', '125 KB', '🖼️');
                    this.moveToRecycleBin('Temp Folder', 'File Folder', '2 items', '📁');
                    SafeStorage.setItem('win95-recycle-bin-initialized', 'true');
                }

                // Restore pending saved state if available
                setTimeout(() => {
                    this.restorePendingState();
                }, 1500);
            }

            createDesktopIcon(x, y, label, emoji, onClick) {
                // Load saved position from localStorage if available
                const savedPositions = SafeStorage.getItem('win95-icon-positions');
                let finalX = x;
                let finalY = y;

                if (savedPositions) {
                    try {
                        const positions = JSON.parse(savedPositions);
                        if (positions[label]) {
                            finalX = positions[label].x;
                            finalY = positions[label].y;
                        }
                    } catch (e) {
                        // If parsing fails, use default positions
                        console.warn('Failed to parse icon positions:', e);
                    }
                }

                const icon = {
                    x: finalX, y: finalY, label, emoji, onClick,
                    width: 48, height: 64,
                    selected: false
                };
                this.desktop.icons.push(icon);

                // Draw initial icon
                this.drawIcon(finalX, finalY, label, emoji, false);

                return icon;
            }

            setupDesktopInteractions() {
                const canvas = document.getElementById('screen');
                if (!canvas) return;

                // ICON DRAG STATE - Windows 95 authentic drag and drop
                let dragState = {
                    isDragging: false,
                    draggedIcon: null,
                    dragStartX: 0,
                    dragStartY: 0,
                    iconStartX: 0,
                    iconStartY: 0,
                    hasMoved: false,
                    // Rubber band selection state
                    isSelecting: false,
                    selectionStartX: 0,
                    selectionStartY: 0,
                    selectionEndX: 0,
                    selectionEndY: 0,
                    // Last clicked icon for shift+click range selection
                    lastClickedIcon: null
                };

                const GRID_SIZE = 75; // Windows 95 authentic grid spacing

                // Snap to grid function (authentic Windows 95 behavior)
                const snapToGrid = (value) => {
                    return Math.round(value / GRID_SIZE) * GRID_SIZE;
                };

                // Get icon at position
                const getIconAtPosition = (x, y) => {
                    for (const icon of this.desktop.icons) {
                        if (x >= icon.x && x <= icon.x + icon.width &&
                            y >= icon.y && y <= icon.y + icon.height) {
                            return icon;
                        }
                    }
                    return null;
                };

                // Check if icon intersects with selection rectangle
                const isIconInSelection = (icon, x1, y1, x2, y2) => {
                    const selLeft = Math.min(x1, x2);
                    const selRight = Math.max(x1, x2);
                    const selTop = Math.min(y1, y2);
                    const selBottom = Math.max(y1, y2);

                    const iconLeft = icon.x;
                    const iconRight = icon.x + icon.width;
                    const iconTop = icon.y;
                    const iconBottom = icon.y + icon.height;

                    // Check if rectangles overlap
                    return !(iconRight < selLeft ||
                             iconLeft > selRight ||
                             iconBottom < selTop ||
                             iconTop > selBottom);
                };

                // Redraw all desktop icons
                const redrawAllIcons = () => {
                    this.desktop.icons.forEach(icon => {
                        this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                    });
                };

                // Draw rubber band selection box (Windows 95 style)
                const drawSelectionBox = () => {
                    if (!dragState.isSelecting) return;

                    const x1 = dragState.selectionStartX;
                    const y1 = dragState.selectionStartY;
                    const x2 = dragState.selectionEndX;
                    const y2 = dragState.selectionEndY;

                    const left = Math.min(x1, x2);
                    const top = Math.min(y1, y2);
                    const width = Math.abs(x2 - x1);
                    const height = Math.abs(y2 - y1);

                    // Draw semi-transparent blue fill
                    this.ctx.fillStyle = 'rgba(0, 0, 128, 0.2)';
                    this.ctx.fillRect(left, top, width, height);

                    // Draw dotted border (Windows 95 style)
                    this.ctx.strokeStyle = 'rgba(0, 0, 128, 0.8)';
                    this.ctx.setLineDash([2, 2]);
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(left, top, width, height);
                    this.ctx.setLineDash([]);
                    this.ctx.lineWidth = 1;
                };

                // Save icon positions to localStorage
                const saveIconPositions = () => {
                    const positions = {};
                    this.desktop.icons.forEach(icon => {
                        positions[icon.label] = { x: icon.x, y: icon.y };
                    });
                    SafeStorage.setItem('win95-icon-positions', JSON.stringify(positions));
                };

                // MOUSEDOWN - Start dragging or selection
                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                    const clickedIcon = getIconAtPosition(x, y);

                    if (clickedIcon) {
                        // Handle Shift+Click for range selection
                        if (e.shiftKey && dragState.lastClickedIcon) {
                            e.preventDefault();
                            const lastIndex = this.desktop.icons.indexOf(dragState.lastClickedIcon);
                            const currentIndex = this.desktop.icons.indexOf(clickedIcon);
                            const startIndex = Math.min(lastIndex, currentIndex);
                            const endIndex = Math.max(lastIndex, currentIndex);

                            // Select all icons in range
                            this.desktop.icons.forEach((ic, idx) => {
                                if (idx >= startIndex && idx <= endIndex) {
                                    ic.selected = true;
                                }
                            });

                            this.drawDesktop();
                            redrawAllIcons();
                            return; // Don't start drag on Shift+Click
                        }

                        // Handle multi-select with Ctrl key (Windows 95 style)
                        if (e.ctrlKey || e.metaKey) {
                            // Toggle selection on this icon
                            clickedIcon.selected = !clickedIcon.selected;
                            dragState.lastClickedIcon = clickedIcon;
                            this.drawDesktop();
                            redrawAllIcons();
                            return; // Don't start drag on Ctrl+Click
                        }

                        // If clicking an already selected icon, keep multi-selection for group drag
                        if (!clickedIcon.selected) {
                            // Deselect all others if not holding Ctrl
                            this.desktop.icons.forEach(ic => {
                                ic.selected = (ic === clickedIcon);
                            });
                        }

                        // Update last clicked icon
                        dragState.lastClickedIcon = clickedIcon;

                        // Start drag operation
                        dragState.isDragging = true;
                        dragState.draggedIcon = clickedIcon;
                        dragState.dragStartX = x;
                        dragState.dragStartY = y;
                        dragState.iconStartX = clickedIcon.x;
                        dragState.iconStartY = clickedIcon.y;
                        dragState.hasMoved = false;

                        // Store initial positions for all selected icons (for multi-drag)
                        dragState.selectedIcons = this.desktop.icons.filter(ic => ic.selected);
                        dragState.selectedIconsStartPos = dragState.selectedIcons.map(ic => ({
                            icon: ic,
                            startX: ic.x,
                            startY: ic.y
                        }));

                        this.drawDesktop();
                        redrawAllIcons();

                        canvas.style.cursor = 'grabbing';
                    } else if (y < taskbarY) {
                        // Clicked on empty desktop space - start rubber band selection
                        dragState.isSelecting = true;
                        dragState.selectionStartX = x;
                        dragState.selectionStartY = y;
                        dragState.selectionEndX = x;
                        dragState.selectionEndY = y;

                        // Deselect all icons unless holding Ctrl
                        if (!e.ctrlKey && !e.metaKey) {
                            this.desktop.icons.forEach(ic => {
                                ic.selected = false;
                            });
                        }

                        canvas.style.cursor = 'crosshair';
                    }
                });

                // MOUSEMOVE - Drag icon(s) or update selection box
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (dragState.isDragging && dragState.draggedIcon) {
                        // Calculate new position
                        const deltaX = x - dragState.dragStartX;
                        const deltaY = y - dragState.dragStartY;

                        if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
                            dragState.hasMoved = true;
                        }

                        const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;

                        // Update ALL selected icons positions (multi-drag support)
                        if (dragState.selectedIconsStartPos) {
                            dragState.selectedIconsStartPos.forEach(({icon, startX, startY}) => {
                                const newX = Math.max(0, Math.min(CONFIG.DISPLAY.WIDTH - icon.width,
                                                      startX + deltaX));
                                const newY = Math.max(0, Math.min(taskbarY - icon.height,
                                                      startY + deltaY));
                                icon.x = newX;
                                icon.y = newY;
                            });
                        }

                        // Redraw desktop with icons in new positions
                        this.drawDesktop();
                        redrawAllIcons();
                    } else if (dragState.isSelecting) {
                        // Update selection box
                        const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                        dragState.selectionEndX = Math.max(0, Math.min(CONFIG.DISPLAY.WIDTH, x));
                        dragState.selectionEndY = Math.max(0, Math.min(taskbarY, y));

                        // Update icon selections based on what's in the box
                        // If Ctrl was held during mousedown, preserve previous selections
                        this.desktop.icons.forEach(icon => {
                            const inSelection = isIconInSelection(
                                icon,
                                dragState.selectionStartX,
                                dragState.selectionStartY,
                                dragState.selectionEndX,
                                dragState.selectionEndY
                            );
                            // Only update selection state if icon is in the selection box
                            // This allows Ctrl+drag to add to existing selection
                            if (inSelection) {
                                icon.selected = true;
                            }
                        });

                        // Redraw with selection box
                        this.drawDesktop();
                        redrawAllIcons();
                        drawSelectionBox();
                    }
                });

                // MOUSEUP - End dragging or selection
                canvas.addEventListener('mouseup', (e) => {
                    if (dragState.isDragging) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;

                        if (dragState.hasMoved && dragState.draggedIcon) {
                            // Snap ALL selected icons to grid (authentic Windows 95 behavior)
                            const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                            if (dragState.selectedIconsStartPos) {
                                dragState.selectedIconsStartPos.forEach(({icon}) => {
                                    icon.x = Math.max(0, Math.min(CONFIG.DISPLAY.WIDTH - icon.width,
                                                          snapToGrid(icon.x)));
                                    icon.y = Math.max(0, Math.min(taskbarY - icon.height,
                                                          snapToGrid(icon.y)));
                                });
                            }

                            // Save positions to localStorage
                            saveIconPositions();

                            // Redraw with snapped positions
                            this.drawDesktop();
                            redrawAllIcons();
                        } else if (!dragState.hasMoved && dragState.draggedIcon) {
                            // This was a click, not a drag - handle click logic
                            const now = Date.now();
                            if (dragState.draggedIcon.lastClick && now - dragState.draggedIcon.lastClick < 400) {
                                // Double-click
                                if (dragState.draggedIcon.onClick) {
                                    dragState.draggedIcon.onClick();
                                }
                            }
                            dragState.draggedIcon.lastClick = now;
                        }

                        dragState.isDragging = false;
                        dragState.draggedIcon = null;
                        dragState.selectedIconsStartPos = null;
                        canvas.style.cursor = 'default';
                    } else if (dragState.isSelecting) {
                        // End selection box operation
                        dragState.isSelecting = false;

                        // Final redraw without selection box
                        this.drawDesktop();
                        redrawAllIcons();

                        canvas.style.cursor = 'default';
                    }
                });

                // Handle icon clicks (for non-drag clicks on desktop)
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const clickedIcon = getIconAtPosition(x, y);

                    if (!clickedIcon) {
                        // Clicking on desktop background
                        const now = Date.now();
                        if (this.lastDesktopClick && now - this.lastDesktopClick < 400) {
                            // Double-click on desktop - minimize all windows (Show Desktop)
                            if (this.windowManager) {
                                this.windowManager.minimizeAllWindows();
                            }
                            this.lastDesktopClick = null; // Reset to prevent triple-click
                        } else {
                            // Single click - deselect all icons
                            this.desktop.icons.forEach(ic => {
                                if (ic.selected) {
                                    ic.selected = false;
                                    this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, false);
                                }
                            });
                            this.lastDesktopClick = now;
                        }

                        // Check if clicking on Start button
                        const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                        if (y >= taskbarY && y <= CONFIG.DISPLAY.HEIGHT && x >= 2 && x <= 62) {
                            this.toggleStartMenu();
                        } else if (y >= taskbarY && y <= CONFIG.DISPLAY.HEIGHT && x >= CONFIG.DISPLAY.WIDTH - 95 && x <= CONFIG.DISPLAY.WIDTH - 70) {
                            // Check if clicking on volume icon in system tray
                            this.showVolumeControl();
                        } else if (y >= taskbarY && y <= CONFIG.DISPLAY.HEIGHT && x >= CONFIG.DISPLAY.WIDTH - 70 && x <= CONFIG.DISPLAY.WIDTH - 4) {
                            // Check if clicking on clock in system tray
                            this.showClockInfo();
                        } else {
                            // Close start menu if clicking elsewhere
                            const startMenu = document.getElementById('start-menu');
                            if (startMenu && startMenu.classList.contains('active')) {
                                if (x < 0 || x > 200 || y < taskbarY - 200) {
                                    startMenu.classList.remove('active');
                                }
                            }
                        }
                    }
                });

                // Handle right-click for context menu
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const clickedIcon = getIconAtPosition(x, y);

                    if (clickedIcon) {
                        // Select the icon and show icon context menu
                        this.desktop.icons.forEach(ic => {
                            ic.selected = (ic === clickedIcon);
                            this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, ic.selected);
                        });
                        this.showDesktopIconContextMenu(e.clientX, e.clientY, clickedIcon);
                    } else {
                        // Show desktop context menu
                        this.showContextMenu(e.clientX, e.clientY);
                    }
                    return false;
                });

                // KEYBOARD SHORTCUTS - Windows 95 authentic shortcuts
                document.addEventListener('keydown', (e) => {
                    const selectedIcons = this.desktop.icons.filter(ic => ic.selected);

                    // Delete key - Remove selected icons (send to Recycle Bin)
                    if (e.key === 'Delete' && selectedIcons.length > 0) {
                        e.preventDefault();
                        selectedIcons.forEach(icon => {
                            const index = this.desktop.icons.indexOf(icon);
                            if (index > -1) {
                                this.desktop.icons.splice(index, 1);
                            }
                        });
                        this.drawDesktop();
                        this.desktop.icons.forEach(icon => {
                            this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                        });
                        saveIconPositions();
                        if (window.toastManager) {
                            window.toastManager.show('Desktop', `${selectedIcons.length} item(s) moved to Recycle Bin`);
                        }
                    }

                    // F2 key - Rename selected icon
                    if (e.key === 'F2' && selectedIcons.length === 1) {
                        e.preventDefault();
                        const icon = selectedIcons[0];
                        const newName = prompt('Rename icon:', icon.label);
                        if (newName && newName.trim()) {
                            icon.label = newName.trim();
                            this.drawDesktop();
                            this.desktop.icons.forEach(ic => {
                                this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, ic.selected);
                            });
                            saveIconPositions();
                        }
                    }

                    // Ctrl+A - Select all icons
                    if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                        e.preventDefault();
                        this.desktop.icons.forEach(ic => {
                            ic.selected = true;
                        });
                        this.drawDesktop();
                        this.desktop.icons.forEach(icon => {
                            this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                        });
                    }

                    // Escape - Deselect all icons
                    if (e.key === 'Escape') {
                        this.desktop.icons.forEach(ic => {
                            ic.selected = false;
                        });
                        this.drawDesktop();
                        this.desktop.icons.forEach(icon => {
                            this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                        });
                    }

                    // Ctrl+X - Cut (store selected icons)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'x' && selectedIcons.length > 0) {
                        e.preventDefault();
                        this.clipboardIcons = selectedIcons.map(ic => ({...ic}));
                        this.clipboardMode = 'cut';
                        if (window.toastManager) {
                            window.toastManager.show('Desktop', `${selectedIcons.length} item(s) cut`);
                        }
                    }

                    // Ctrl+C - Copy (store selected icons)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedIcons.length > 0) {
                        e.preventDefault();
                        this.clipboardIcons = selectedIcons.map(ic => ({...ic}));
                        this.clipboardMode = 'copy';
                        if (window.toastManager) {
                            window.toastManager.show('Desktop', `${selectedIcons.length} item(s) copied`);
                        }
                    }

                    // Ctrl+V - Paste (restore icons from clipboard)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'v' && this.clipboardIcons && this.clipboardIcons.length > 0) {
                        e.preventDefault();

                        if (this.clipboardMode === 'cut') {
                            // For cut, remove original icons
                            this.clipboardIcons.forEach(clipIcon => {
                                const originalIndex = this.desktop.icons.findIndex(ic =>
                                    ic.label === clipIcon.label && ic.x === clipIcon.x && ic.y === clipIcon.y
                                );
                                if (originalIndex > -1) {
                                    this.desktop.icons.splice(originalIndex, 1);
                                }
                            });
                        }

                        // Paste icons with slight offset
                        this.clipboardIcons.forEach(clipIcon => {
                            const newIcon = {
                                ...clipIcon,
                                x: clipIcon.x + 20,
                                y: clipIcon.y + 20,
                                selected: false
                            };
                            this.desktop.icons.push(newIcon);
                        });

                        if (this.clipboardMode === 'cut') {
                            this.clipboardIcons = null; // Clear clipboard after cut-paste
                        }

                        this.drawDesktop();
                        this.desktop.icons.forEach(icon => {
                            this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                        });
                        saveIconPositions();

                        if (window.toastManager) {
                            window.toastManager.show('Desktop', 'Items pasted');
                        }
                    }
                });
            }

            createStartMenu() {
                const screenContainer = document.getElementById('screen_container');
                if (!screenContainer) return;

                const startMenu = document.createElement('div');
                startMenu.id = 'start-menu';
                startMenu.className = 'start-menu';
                startMenu.style.cssText = 'display: none;';
                startMenu.innerHTML = `
                    <div style="display: flex; max-height: 480px;">
                        <div class="start-menu-sidebar">Windows 95</div>
                        <div style="flex: 1; display: flex; flex-direction: column;">
                            <div style="padding: 4px 8px; background: var(--button-face); border-bottom: 1px solid var(--button-shadow);">
                                <input type="text" id="start-menu-search" placeholder="🔍 Search programs..."
                                       style="width: 100%; padding: 4px 8px; border: 2px inset; font-family: 'MS Sans Serif', Arial, sans-serif; font-size: 11px; background: white;"
                                       autocomplete="off">
                            </div>
                            <div class="start-menu-items" id="start-menu-items" style="flex: 1; overflow-y: auto; max-height: 420px;">
                            <div class="start-menu-item" onclick="emulator.openInternetExplorer(); emulator.toggleStartMenu();">
                                🌐 Internet Explorer
                            </div>
                            <div class="start-menu-item" onclick="emulator.openChromiumBrowser(); emulator.toggleStartMenu();" style="background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.1)); font-weight: bold;">
                                🌐 Chromium Browser ⭐
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                📁 Programs ►
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openFileExplorer(); emulator.toggleStartMenu();">
                                    💻 My Computer
                                </div>
                                <div class="start-menu-item" onclick="emulator.openNetworkNeighborhood(); emulator.toggleStartMenu();">
                                    🌐 Network Neighborhood
                                </div>
                                <div class="start-menu-item" onclick="emulator.openPaint(); emulator.toggleStartMenu();">
                                    🎨 Paint
                                </div>
                                <div class="start-menu-item" onclick="emulator.openMediaPlayer(); emulator.toggleStartMenu();">
                                    🎵 Media Player
                                </div>
                                <div class="start-menu-item" onclick="emulator.openNotepad(); emulator.toggleStartMenu();">
                                    📝 Notepad
                                </div>
                                <div class="start-menu-item" onclick="emulator.openWordPad(); emulator.toggleStartMenu();">
                                    📄 WordPad
                                </div>
                                <div class="start-menu-item" onclick="emulator.openClippyChat(); emulator.toggleStartMenu();">
                                    📎 Chat with Clippy
                                </div>
                                <div class="start-menu-item" onclick="emulator.openCharacterMap(); emulator.toggleStartMenu();">
                                    🔤 Character Map
                                </div>
                                <div class="start-menu-item" onclick="emulator.openCalculator(); emulator.toggleStartMenu();">
                                    🧮 Calculator
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSoundRecorder(); emulator.toggleStartMenu();">
                                    🎙️ Sound Recorder
                                </div>
                                <div class="start-menu-item" onclick="emulator.openLocalFirstBrowser(); emulator.toggleStartMenu();">
                                    🌐 LocalFirst Tools
                                </div>
                                <div class="start-menu-item" onclick="emulator.openDOSPrompt(); emulator.toggleStartMenu();">
                                    ⬛ Linux Terminal
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                🎮 Games ►
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openMinesweeper(); emulator.toggleStartMenu();">
                                    💣 Minesweeper
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSolitaire(); emulator.toggleStartMenu();">
                                    🃏 Solitaire
                                </div>
                                <div class="start-menu-item" onclick="emulator.openFreeCell(); emulator.toggleStartMenu();">
                                    🎴 FreeCell
                                </div>
                                <div class="start-menu-item" onclick="emulator.openKeenExplorer(); emulator.toggleStartMenu();">
                                    🎮 Keen Explorer
                                </div>
                                <div class="start-menu-item" onclick="emulator.openGalacticDefender(); emulator.toggleStartMenu();">
                                    🚀 Galactic Defender
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSnakeClassic(); emulator.toggleStartMenu();">
                                    🐍 Snake Classic
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                ⚙️ Settings ►
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openControlPanel(); emulator.toggleStartMenu();">
                                    🎛️ Control Panel
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSystemProperties(); emulator.toggleStartMenu();">
                                    🖥️ System Properties
                                </div>
                                <div class="start-menu-item" onclick="emulator.openRegistryEditor(); emulator.toggleStartMenu();">
                                    📋 Registry Editor
                                </div>
                                <div class="start-menu-item" onclick="emulator.openTaskManager(); emulator.toggleStartMenu();">
                                    📊 Task Manager
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSaveStateManager(); emulator.toggleStartMenu();">
                                    💾 Virtual Floppy Manager
                                </div>
                                <div class="start-menu-item" style="font-weight: bold; margin-left: -10px;">
                                    🔧 System Tools ►
                                </div>
                                <div style="margin-left: 20px;">
                                    <div class="start-menu-item" onclick="emulator.openDiskDefragmenter(); emulator.toggleStartMenu();">
                                        💿 Disk Defragmenter
                                    </div>
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" onclick="emulator.openAbout(); emulator.toggleStartMenu();">
                                ℹ️ About
                            </div>
                            <div class="start-menu-item" onclick="emulator.showHelp(); emulator.toggleStartMenu();">
                                ❓ Help
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" onclick="emulator.restart();">
                                🔄 Shut Down...
                            </div>
                        </div>
                        </div>
                    </div>
                `;
                screenContainer.appendChild(startMenu);

                // Add search functionality
                const searchInput = document.getElementById('start-menu-search');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        this.filterStartMenu(e.target.value);
                    });

                    // Handle keyboard navigation
                    searchInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            this.toggleStartMenu();
                        } else if (e.key === 'Enter') {
                            // Launch first visible item
                            const firstVisible = document.querySelector('.start-menu-item:not([style*="display: none"])');
                            if (firstVisible) {
                                firstVisible.click();
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            const visibleItems = Array.from(document.querySelectorAll('.start-menu-item:not([style*="display: none"])'));
                            if (visibleItems.length > 0) {
                                visibleItems[0].focus();
                            }
                        }
                    });
                }
            }

            filterStartMenu(query) {
                const searchTerm = query.toLowerCase().trim();
                const menuItems = document.getElementById('start-menu-items');
                if (!menuItems) return;

                const allItems = menuItems.querySelectorAll('.start-menu-item, div[style*="height: 1px"]');

                allItems.forEach(item => {
                    if (item.classList.contains('start-menu-item')) {
                        const text = item.textContent.toLowerCase();

                        // Show all if search is empty
                        if (!searchTerm) {
                            item.style.display = '';
                        } else {
                            // Filter based on search term
                            if (text.includes(searchTerm)) {
                                item.style.display = '';
                                // Highlight matching items
                                item.style.background = 'rgba(0, 0, 128, 0.1)';
                            } else {
                                item.style.display = 'none';
                            }
                        }
                    } else {
                        // Hide separators when searching
                        item.style.display = searchTerm ? 'none' : '';
                    }
                });

                // Clear highlights when search is empty
                if (!searchTerm) {
                    const items = menuItems.querySelectorAll('.start-menu-item');
                    items.forEach(item => {
                        item.style.background = '';
                    });
                }
            }

            toggleStartMenu() {
                const startMenu = document.getElementById('start-menu');
                const searchInput = document.getElementById('start-menu-search');

                if (startMenu) {
                    if (startMenu.classList.contains('active')) {
                        startMenu.classList.remove('active');
                        startMenu.style.display = 'none';

                        // Clear search on close
                        if (searchInput) {
                            searchInput.value = '';
                            this.filterStartMenu('');
                        }
                    } else {
                        startMenu.classList.add('active');
                        startMenu.style.display = 'block';

                        // Focus search input after a brief delay
                        setTimeout(() => {
                            if (searchInput) {
                                searchInput.focus();
                            }
                        }, 100);

                        // Play start menu sound
                        this.playSoundEffect('start-menu');
                    }
                }
            }

            showDesktopIconContextMenu(x, y, icon) {
                // Remove existing context menu
                const existing = document.getElementById('icon-context-menu');
                if (existing) existing.remove();

                const contextMenu = document.createElement('div');
                contextMenu.id = 'icon-context-menu';
                contextMenu.className = 'context-menu active';
                contextMenu.style.position = 'fixed';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';

                // Different menu items based on icon type
                const isRecycleBin = icon.label === 'Recycle Bin';
                const isMyComputer = icon.label === 'My Computer';

                contextMenu.innerHTML = `
                    <div class="context-menu-item" style="font-weight: bold;" onclick="emulator.openDesktopIcon('${icon.label}'); document.getElementById('icon-context-menu').remove();">
                        📂 Open
                    </div>
                    <div class="context-menu-separator"></div>
                    ${isRecycleBin ? `
                    <div class="context-menu-item" onclick="emulator.recycleBinEmpty(); document.getElementById('icon-context-menu').remove();">
                        🧹 Empty Recycle Bin
                    </div>
                    <div class="context-menu-separator"></div>
                    ` : ''}
                    <div class="context-menu-item" onclick="emulator.showIconProperties('${icon.label}'); document.getElementById('icon-context-menu').remove();">
                        📋 Properties
                    </div>
                `;

                document.body.appendChild(contextMenu);

                // Close on next click
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        if (contextMenu.parentNode) contextMenu.remove();
                        document.removeEventListener('click', closeMenu);
                    }, { once: true });
                }, 100);
            }

            openDesktopIcon(label) {
                const icon = this.desktop.icons.find(ic => ic.label === label);
                if (icon && icon.onClick) {
                    icon.onClick();
                }
            }

            showIconProperties(label) {
                const icon = this.desktop.icons.find(ic => ic.label === label);
                if (!icon) return;

                const content = document.createElement('div');
                content.style.cssText = 'padding: 20px; font-size: 11px;';

                let description = 'Desktop shortcut';
                if (label === 'My Computer') description = 'Displays the contents of your computer';
                else if (label === 'Recycle Bin') description = 'Contains files and folders you have deleted';
                else if (label === 'Internet Explorer') description = 'Web browser application';
                else if (label === 'Notepad') description = 'Simple text editor';
                else if (label === 'Paint') description = 'Image editing application';

                content.innerHTML = `
                    <div style="text-align: center; margin-bottom: 16px; font-size: 32px;">${icon.emoji}</div>
                    <div style="margin-bottom: 12px;"><strong>Name:</strong> ${label}</div>
                    <div style="margin-bottom: 12px;"><strong>Type:</strong> Application</div>
                    <div style="margin-bottom: 12px;"><strong>Description:</strong> ${description}</div>
                    <div style="margin-bottom: 12px;"><strong>Location:</strong> Desktop</div>
                    <hr style="margin: 12px 0; border: none; border-top: 1px solid #808080;">
                    <button class="btn" onclick="emulator.windowManager.getActiveWindow().close()" style="margin-top: 8px;">OK</button>
                `;

                this.windowManager.createWindow(`${label} Properties`, content, { width: 350, height: 300 });
            }

            showContextMenu(x, y) {
                // Remove existing context menu
                const existing = document.getElementById('context-menu');
                if (existing) existing.remove();

                const screenContainer = document.getElementById('screen_container');
                if (!screenContainer) return;

                const hasWindows = this.windowManager && this.windowManager.windows.length > 0;
                const contextMenu = document.createElement('div');
                contextMenu.id = 'context-menu';
                contextMenu.className = 'context-menu active';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.innerHTML = `
                    <div class="context-menu-item" style="font-weight: bold;">Arrange Icons ►</div>
                    <div style="margin-left: 15px;">
                        <div class="context-menu-item" onclick="emulator.arrangeIconsByName(); document.getElementById('context-menu').remove();">
                            📝 by Name
                        </div>
                        <div class="context-menu-item" onclick="emulator.arrangeIconsByType(); document.getElementById('context-menu').remove();">
                            📁 by Type
                        </div>
                        <div class="context-menu-item" onclick="emulator.lineUpIcons(); document.getElementById('context-menu').remove();">
                            📐 Line up Icons
                        </div>
                        <div class="context-menu-item" onclick="emulator.autoArrangeIcons(); document.getElementById('context-menu').remove();">
                            🔄 Auto Arrange
                        </div>
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.openInternetExplorer(); document.getElementById('context-menu').remove();">
                        🌐 Open Internet Explorer
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.openNotepad(); document.getElementById('context-menu').remove();">
                        📝 New &gt; Text Document
                    </div>
                    <div class="context-menu-separator"></div>
                    ${hasWindows ? `
                    <div class="context-menu-item" style="font-weight: bold;">Window Arrangements ►</div>
                    <div style="margin-left: 15px;">
                        <div class="context-menu-item" onclick="emulator.windowManager.cascadeWindows(); document.getElementById('context-menu').remove();">
                            📊 Cascade Windows
                        </div>
                        <div class="context-menu-item" onclick="emulator.windowManager.tileHorizontally(); document.getElementById('context-menu').remove();">
                            ↔️ Tile Horizontally
                        </div>
                        <div class="context-menu-item" onclick="emulator.windowManager.tileVertically(); document.getElementById('context-menu').remove();">
                            ↕️ Tile Vertically
                        </div>
                        <div class="context-menu-item" onclick="emulator.windowManager.minimizeAllWindows(); document.getElementById('context-menu').remove();">
                            🖥️ Minimize All
                        </div>
                    </div>
                    <div class="context-menu-separator"></div>
                    ` : ''}
                    <div class="context-menu-item" onclick="emulator.refreshDesktop(); document.getElementById('context-menu').remove();">
                        🔄 Refresh
                    </div>
                    <div class="context-menu-item" onclick="emulator.openSystemProperties(); document.getElementById('context-menu').remove();">
                        🖥️ Properties
                    </div>
                `;
                screenContainer.appendChild(contextMenu);

                // Close on next click
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        contextMenu.remove();
                        document.removeEventListener('click', closeMenu);
                    }, { once: true });
                }, 100);
            }

            refreshDesktop() {
                // Redraw entire desktop
                this.drawDesktop();

                // Redraw icons
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }

            // WINDOWS 95 ICON ARRANGEMENT FUNCTIONS
            arrangeIconsByName() {
                // Sort icons alphabetically by label
                const sortedIcons = [...this.desktop.icons].sort((a, b) =>
                    a.label.localeCompare(b.label)
                );
                this.repositionIconsInGrid(sortedIcons);
            }

            arrangeIconsByType() {
                // Group icons by type (system, applications, files)
                const typeOrder = {
                    'My Computer': 0,
                    'Network Neighborhood': 0,
                    'Recycle Bin': 0,
                    'Internet': 1,
                    'MS-DOS Prompt': 2,
                    'Paint': 2,
                    'Notepad': 2,
                    'Save State': 3
                };

                const sortedIcons = [...this.desktop.icons].sort((a, b) => {
                    const orderA = typeOrder[a.label] !== undefined ? typeOrder[a.label] : 4;
                    const orderB = typeOrder[b.label] !== undefined ? typeOrder[b.label] : 4;
                    if (orderA !== orderB) return orderA - orderB;
                    return a.label.localeCompare(b.label);
                });
                this.repositionIconsInGrid(sortedIcons);
            }

            lineUpIcons() {
                // Snap all icons to grid without changing their relative positions
                const GRID_SIZE = 75;
                this.desktop.icons.forEach(icon => {
                    icon.x = Math.round(icon.x / GRID_SIZE) * GRID_SIZE;
                    icon.y = Math.round(icon.y / GRID_SIZE) * GRID_SIZE;
                });
                this.saveIconPositions();
                this.drawDesktop();
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }

            autoArrangeIcons() {
                // Auto arrange in grid (default Windows 95 layout)
                this.repositionIconsInGrid(this.desktop.icons);
            }

            repositionIconsInGrid(icons) {
                // Arrange icons in a vertical column grid (Windows 95 style)
                const GRID_SIZE = 75;
                const START_X = 20;
                const START_Y = 20;
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                const maxY = taskbarY - 64; // Icon height

                let currentX = START_X;
                let currentY = START_Y;

                icons.forEach(icon => {
                    icon.x = currentX;
                    icon.y = currentY;

                    // Move down for next icon
                    currentY += GRID_SIZE;

                    // If we've exceeded the height, move to next column
                    if (currentY > maxY) {
                        currentY = START_Y;
                        currentX += GRID_SIZE;
                    }
                });

                this.saveIconPositions();
                this.drawDesktop();
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }

            saveIconPositions() {
                // Save icon positions to localStorage
                const positions = {};
                this.desktop.icons.forEach(icon => {
                    positions[icon.label] = { x: icon.x, y: icon.y };
                });
                SafeStorage.setItem('win95-icon-positions', JSON.stringify(positions));
            }

            drawStartButton() {
                const startGrad = this.ctx.createLinearGradient(2, 452, 2, 478);
                startGrad.addColorStop(0, '#ffffff');
                startGrad.addColorStop(0.5, '#c0c0c0');
                startGrad.addColorStop(1, '#808080');
                this.ctx.fillStyle = startGrad;
                this.ctx.fillRect(2, 452, 60, 26);

                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(2, 452, 60, 26);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(3, 453, 58, 24);

                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText('Start', 20, 468);

                // Windows logo on button
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(6, 458, 4, 4);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(10, 458, 4, 4);
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(6, 462, 4, 4);
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(10, 462, 4, 4);
            }

            drawSystemTray() {
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                const trayY = taskbarY + 3;
                const trayHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 6;

                this.ctx.fillStyle = '#808080';
                this.ctx.fillRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);

                // Volume icon (speaker)
                const volumeIcon = this.soundMuted ? '🔇' : '🔊';
                this.ctx.font = '14px Arial';
                this.ctx.fillText(volumeIcon, CONFIG.DISPLAY.WIDTH - 90, trayY + 17);

                // Clock
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '11px Arial';
                const clockY = trayY + (trayHeight / 2) + 4;
                this.ctx.fillText(timeStr, CONFIG.DISPLAY.WIDTH - 50, clockY);
            }

            updateSystemClock() {
                // Redraw just the system tray area every second
                if (!this.ctx) return;
                this.drawSystemTray();
            }

            drawIcon(x, y, label, emoji, selected) {
                // Icon background (for selection)
                if (selected) {
                    this.ctx.fillStyle = 'rgba(0, 0, 128, 0.3)';
                    this.ctx.fillRect(x, y, 48, 64);
                    this.ctx.strokeStyle = 'rgba(0, 0, 128, 0.6)';
                    this.ctx.setLineDash([2, 2]);
                    this.ctx.strokeRect(x, y, 48, 64);
                    this.ctx.setLineDash([]);
                }

                // Draw icon image (simplified)
                this.ctx.font = '32px Arial';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText(emoji, x + 8, y + 32);

                // Icon label with background
                if (selected) {
                    this.ctx.fillStyle = '#000080';
                    const textWidth = this.ctx.measureText(label).width + 4;
                    this.ctx.fillRect(x + 24 - textWidth/2, y + 42, textWidth, 14);
                }

                // Icon label
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 2;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, x + 24, y + 53);
                this.ctx.shadowBlur = 0;
                this.ctx.textAlign = 'left';
            }

            drawWindow(x, y, width, height, title) {
                // Window outer border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(x, y, width, height);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);

                // Window background
                this.ctx.fillStyle = '#c0c0c0';
                this.ctx.fillRect(x + 2, y + 2, width - 4, height - 4);

                // Title bar
                const titleGrad = this.ctx.createLinearGradient(x + 2, y + 2, x + 2, y + 20);
                titleGrad.addColorStop(0, '#0000ff');
                titleGrad.addColorStop(1, '#000080');
                this.ctx.fillStyle = titleGrad;
                this.ctx.fillRect(x + 2, y + 2, width - 4, 18);

                // Title bar text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText(title, x + 6, y + 14);

                // Window control buttons
                const btnSize = 16;
                const btnY = y + 4;
                
                // Minimize button
                this.drawWindowButton(x + width - 60, btnY, btnSize, '_');
                // Maximize button
                this.drawWindowButton(x + width - 40, btnY, btnSize, '□');
                // Close button
                this.drawWindowButton(x + width - 20, btnY, btnSize, 'X');

                // Window content area
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(x + 3, y + 22, width - 6, height - 25);

                // Draw some content
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '12px Arial';
                this.ctx.fillText('Welcome to Windows 95 Emulator!', x + 10, y + 40);
                this.ctx.font = '11px Arial';
                this.ctx.fillText('This is a WebAssembly-powered x86 emulation.', x + 10, y + 60);
                this.ctx.fillText('', x + 10, y + 75);
                this.ctx.fillText('Features:', x + 10, y + 90);
                this.ctx.fillText('• Full desktop environment simulation', x + 20, y + 105);
                this.ctx.fillText('• Mouse and keyboard support', x + 20, y + 120);
                this.ctx.fillText('• Load custom disk images', x + 20, y + 135);
                this.ctx.fillText('• Save and restore state', x + 20, y + 150);
                this.ctx.fillText('', x + 10, y + 165);
                this.ctx.fillStyle = '#000080';
                this.ctx.fillText('Click "Load Disk" to load a Windows 95 image.', x + 10, y + 180);
            }

            drawWindowButton(x, y, size, label) {
                // Button background
                this.ctx.fillStyle = '#c0c0c0';
                this.ctx.fillRect(x, y, size, 14);
                
                // Button border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(x, y, size, 14);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(x + 1, y + 1, size - 2, 12);

                // Button label
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, x + size / 2, y + 10);
                this.ctx.textAlign = 'left';
            }

            animate() {
                if (!this.isRunning) return;

                const now = Date.now();
                const deltaTime = now - this.lastFrameTime;

                // Frame rate limiting
                if (deltaTime < CONFIG.PERFORMANCE.FRAME_TIME) {
                    requestAnimationFrame(() => this.animate());
                    return;
                }

                this.lastFrameTime = now;
                this.frameCount++;

                // Update FPS and stats
                if (now - this.lastFpsUpdate > CONFIG.ANIMATION.FPS_UPDATE_INTERVAL) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsUpdate));
                    this.domCache.fpsCounter.textContent = fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;

                    // Update uptime
                    const elapsed = Math.floor((now - this.startTime) / 1000);
                    const hours = Math.floor(elapsed / 3600);
                    const minutes = Math.floor((elapsed % 3600) / 60);
                    const seconds = elapsed % 60;

                    const pad = (num) => num < 10 ? '0' + num : '' + num;
                    this.domCache.timeDisplay.textContent =
                        `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;

                    // Update memory usage simulation
                    this.memoryUsage = Math.floor(this.settings.memory / 1024 / 1024 * (0.3 + Math.random() * 0.2));
                    this.domCache.memoryUsage.textContent = this.memoryUsage + ' MB';
                }

                // Update LED indicators (throttled)
                if (this.frameCount % CONFIG.ANIMATION.LED_THROTTLE_FRAMES === 0) {
                    // CPU activity
                    if (Math.random() > 0.6) {
                        this.domCache.cpuLed.classList.add('active');
                        this.domCache.cpuStatus.textContent = 'Active';
                        this.cpuUsage = Math.floor(Math.random() * 40 + 10);
                    } else {
                        this.domCache.cpuLed.classList.remove('active');
                        this.domCache.cpuStatus.textContent = 'Idle';
                        this.cpuUsage = Math.floor(Math.random() * 10);
                    }

                    // HDD activity
                    if (Math.random() > 0.85) {
                        if (this.hddLedTimeout) {
                            clearTimeout(this.hddLedTimeout);
                        }

                        this.domCache.hddLed.classList.add('active');
                        this.hddLedTimeout = setTimeout(() => {
                            this.domCache.hddLed.classList.remove('active');
                            this.hddLedTimeout = null;
                        }, 100);
                    }
                }

                requestAnimationFrame(() => this.animate());
            }

            updateStatus() {
                this.updateSettings();
            }

            updateProgress(percent) {
                if (this.domCache && this.domCache.progressFill) {
                    this.domCache.progressFill.style.width = Math.min(100, percent) + '%';
                    this.domCache.progressFill.parentElement.setAttribute('aria-valuenow', Math.round(percent));
                }
            }

            updateLoadingText(text) {
                if (this.domCache && this.domCache.loadingText) {
                    this.domCache.loadingText.textContent = text;
                }
            }

            showLoading(text = 'Starting Windows 95...') {
                this.initDOMCache();
                this.domCache.loadingScreen.classList.add('active');
                this.updateProgress(0);
                this.updateLoadingText(text);
            }

            hideLoading() {
                setTimeout(() => {
                    if (this.domCache && this.domCache.loadingScreen) {
                        this.domCache.loadingScreen.classList.remove('active');
                    }
                }, 500);
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    this.isRunning = false;
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">▶</span> Resume';
                    this.domCache.emulatorTitlebar.classList.add('inactive');
                    
                    // Show paused message
                    const pauseText = 'PAUSED';
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(pauseText, CONFIG.DISPLAY.WIDTH / 2, CONFIG.DISPLAY.HEIGHT / 2);
                    this.ctx.textAlign = 'left';
                } else {
                    this.isRunning = true;
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">⏸</span> Pause';
                    this.domCache.emulatorTitlebar.classList.remove('inactive');
                    this.lastFrameTime = Date.now();
                    this.animate();
                }
            }

            restart() {
                window.dialogManager.confirm(
                    'Are you sure you want to restart? Any unsaved changes will be lost.',
                    'Restart Windows 95',
                    (button) => {
                        if (button === 'Yes') {
                            this.isRunning = false;
                            this.isPaused = false;
                            this.startTime = Date.now();
                            this.frameCount = 0;
                            this.lastFrameTime = 0;

                            if (this.hddLedTimeout) {
                                clearTimeout(this.hddLedTimeout);
                                this.hddLedTimeout = null;
                            }

                            // Reset UI
                            this.initDOMCache();
                            this.domCache.emulatorContainer.classList.add('hidden');
                            this.domCache.setupScreen.classList.remove('hidden');

                            if (this.domCache.pauseBtn) {
                                this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">⏸</span> Pause';
                            }
                        }
                    }
                );
            }

            fullscreen() {
                try {
                    const container = document.getElementById('emulator-container');
                    const frame = document.querySelector('.emulator-frame');

                    if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled &&
                        !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                        window.dialogManager.warning('Fullscreen not supported in this browser', 'Windows 95');
                        return;
                    }

                    if (document.fullscreenElement || document.webkitFullscreenElement ||
                        document.mozFullScreenElement || document.msFullscreenElement) {
                        // Exit fullscreen
                        const exitFullscreen = document.exitFullscreen ||
                                             document.webkitExitFullscreen ||
                                             document.mozCancelFullScreen ||
                                             document.msExitFullscreen;
                        if (exitFullscreen) {
                            exitFullscreen.call(document);
                        }
                        // Remove fullscreen class
                        if (frame) {
                            frame.classList.remove('fullscreen-mode');
                        }
                        // Restore original canvas size
                        this.resizeCanvas(640, 480);
                    } else {
                        // Enter fullscreen
                        const requestFullscreen = container.requestFullscreen ||
                                                container.webkitRequestFullscreen ||
                                                container.webkitRequestFullScreen ||
                                                container.mozRequestFullScreen ||
                                                container.msRequestFullscreen;

                        if (requestFullscreen) {
                            requestFullscreen.call(container).then(() => {
                                // Add fullscreen class when successfully entered
                                if (frame) {
                                    frame.classList.add('fullscreen-mode');
                                }
                                // Resize canvas to fill screen
                                setTimeout(() => {
                                    const screenContainer = document.getElementById('screen_container');
                                    if (screenContainer) {
                                        const width = screenContainer.clientWidth;
                                        const height = screenContainer.clientHeight;
                                        this.resizeCanvas(width, height);
                                    }
                                }, 100);
                            }).catch(err => {
                                console.error('Fullscreen request failed:', err);
                                window.dialogManager.error('Could not enter fullscreen mode', 'Windows 95');
                            });
                        }
                    }
                } catch (error) {
                    console.error('Fullscreen error:', error);
                    window.dialogManager.error('Fullscreen failed: ' + error.message, 'Windows 95');
                }
            }

            resizeCanvas(width, height) {
                if (!this.canvas || !this.ctx) return;

                // Store old dimensions
                const oldWidth = this.canvas.width;
                const oldHeight = this.canvas.height;

                // Set new canvas dimensions
                this.canvas.width = width;
                this.canvas.height = height;

                // Update CONFIG for rendering
                CONFIG.DISPLAY.WIDTH = width;
                CONFIG.DISPLAY.HEIGHT = height;
                CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(height * 0.0625)); // 6.25% of height

                // Redraw desktop
                this.drawDesktop();

                // Update window manager bounds
                if (this.windowManager) {
                    this.windowManager.updateBounds(width, height);
                }
            }

            screenshot() {
                try {
                    const canvas = document.getElementById('screen');
                    if (!canvas) {
                        throw new Error('Canvas not found');
                    }

                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const link = document.createElement('a');
                    link.download = `windows95-screenshot-${timestamp}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    // Show feedback
                    this.showNotification('Screenshot saved!');
                } catch (error) {
                    console.error('Screenshot failed:', error);
                    window.dialogManager.error('Screenshot failed. Canvas may be tainted by cross-origin content.', 'Windows 95');
                }
            }

            showNotification(message) {
                // Simple notification in the emulator
                const prevFill = this.ctx.fillStyle;
                const prevFont = this.ctx.font;
                
                this.ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                this.ctx.fillRect(200, 200, 240, 80);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(200, 200, 240, 80);
                
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(message, 320, 240);
                this.ctx.textAlign = 'left';
                
                this.ctx.fillStyle = prevFill;
                this.ctx.font = prevFont;
            }

            showHelp() {
                window.dialogManager.info(`Windows 95 Desktop Simulator Help

DESKTOP INTERACTIONS:
• Single-click icons to select them
• Double-click icons to open programs
• Right-click desktop for context menu
• Click Start button to open program menu

WINDOWS:
• Drag windows by their title bars
• Click minimize (_) to minimize to taskbar
• Click maximize (□) to toggle full screen
• Click close (X) to close windows
• Click taskbar buttons to restore windows

KEYBOARD SHORTCUTS:
• F11 - Toggle fullscreen mode
• Ctrl+H - Toggle control toolbar
• Ctrl+P - Pause/Resume desktop
• Ctrl+R - Restart desktop
• Ctrl+S - Take screenshot
• ESC - Release mouse cursor (if locked)

PROGRAMS:
• Internet Explorer - Real web browser (loads live sites!)
• Notepad - Text editor with basic functionality
• Calculator - Working calculator with basic operations
• Minesweeper - Classic game (right-click to flag)
• About - Information about this simulator

FEATURES:
• All interactions happen locally in your browser
• No data is sent to any server
• State persists in browser storage
• Works completely offline
• Authentic Windows 95 look and feel

TIP: Try opening multiple windows and arranging them!`, 'Help');
            }

            loadDisk() {
                document.getElementById('disk-input').click();
            }

            handleDiskUpload(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) return;

                    const validExtensions = ['.img', '.iso', '.ima'];
                    const fileName = file.name.toLowerCase();
                    const isValid = validExtensions.some(ext => fileName.endsWith(ext));

                    if (!isValid) {
                        window.dialogManager.warning('Invalid file type. Please select an IMG, ISO, or IMA file.', 'Load Disk');
                        return;
                    }

                    if (file.size > 100 * 1024 * 1024) {
                        window.dialogManager.warning('File too large. Maximum size is 100MB for this demo.', 'Load Disk');
                        return;
                    }

                    // Show file name
                    const fileNameDisplay = document.getElementById('file-name');
                    if (fileNameDisplay) {
                        fileNameDisplay.textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                    }

                    window.dialogManager.info(`Disk image "${file.name}" selected.\n\nNote: Full Windows 95 emulation requires the v86 WASM library.\nThis demo shows a simulated environment.\n\nFor actual Windows 95, you would need:\n• A complete v86 library implementation\n• Valid Windows 95 disk image\n• Additional ROM files`, 'Load Disk');

                    this.loadDemo();
                } catch (error) {
                    console.error('Failed to handle disk upload:', error);
                    window.dialogManager.error('Failed to load disk image: ' + error.message, 'Load Disk');
                }
            }

            loadFromURL() {
                try {
                    const url = document.getElementById('disk-url').value.trim();
                    if (!url) {
                        window.dialogManager.warning('Please enter a URL', 'Load from URL');
                        return;
                    }

                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        window.dialogManager.warning('Invalid URL. Must start with http:// or https://', 'Load from URL');
                        return;
                    }

                    window.dialogManager.info(`Loading from URL: ${url}\n\nNote: Full emulation requires the v86 WASM library.\nThis demo shows a simulated environment.\n\nRequirements:\n• Server must support CORS\n• Valid disk image format (IMG/ISO)\n• Stable network connection`, 'Load from URL');

                    this.loadDemo();
                } catch (error) {
                    console.error('Failed to load from URL:', error);
                    window.dialogManager.error('Failed to load from URL: ' + error.message, 'Load from URL');
                }
            }

            minimize() {
                const container = document.getElementById('emulator-container');
                container.style.transition = 'transform 0.3s ease';
                container.style.transform = 'scale(0.1)';
                container.style.opacity = '0';
                
                setTimeout(() => {
                    container.style.transform = 'scale(1)';
                    container.style.opacity = '1';
                }, 300);
            }

            maximize() {
                this.fullscreen();
            }

            close() {
                window.dialogManager.confirm(
                    'Are you sure you want to close Windows 95?\n\nAny unsaved changes will be lost.',
                    'Shut Down Windows',
                    (button) => {
                        if (button === 'Yes') {
                            this.restart();
                        }
                    }
                );
            }
        }

        // Safe localStorage wrapper with error handling
        const SafeStorage = {
            getItem(key) {
                try {
                    return localStorage.getItem(key);
                } catch (e) {
                    console.warn('LocalStorage getItem failed:', e);
                    return null;
                }
            },
            setItem(key, value) {
                try {
                    localStorage.setItem(key, value);
                } catch (e) {
                    console.warn('LocalStorage setItem failed:', e);
                }
            },
            removeItem(key) {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    console.warn('LocalStorage removeItem failed:', e);
                }
            }
        };

        // Initialize emulator - make it globally accessible immediately
        window.emulator = null;
        // Create alias for convenience in this script
        var emulator = null;

        // Wait for DOM to be ready before initializing
        document.addEventListener('DOMContentLoaded', () => {
            window.emulator = new Windows95Emulator();
            emulator = window.emulator;

            // Initialize Chromium Engine (make accessible globally for onclick handlers)
            window.chromiumEngine = chromiumEngine = emulator.chromiumEngine;

            // Setup event listeners that require emulator
            setupEmulatorEventListeners();

            // Initialize and start AI State Controller
            aiController = new AIStateController(window.emulator);
            aiController.start();

            // Initialize Clippy with briefing context
            clippy = new ClippyAssistant(window.emulator, aiController);
            window.clippy = clippy; // Make globally accessible for onclick handlers
        });

        // Handle window resize to keep canvas fullscreen
        window.addEventListener('resize', () => {
            if (window.emulator && window.emulator.canvas && window.emulator.isRunning) {
                // Header is hidden when OS is running, don't account for it
                const statusBar = document.querySelector('.status-bar');
                const statusBarHeight = statusBar ? statusBar.offsetHeight : 22;

                const availableWidth = window.innerWidth;
                const availableHeight = window.innerHeight - statusBarHeight;

                // Update canvas dimensions
                window.emulator.canvas.width = availableWidth;
                window.emulator.canvas.height = availableHeight;

                // Update CONFIG
                CONFIG.DISPLAY.WIDTH = availableWidth;
                CONFIG.DISPLAY.HEIGHT = availableHeight;
                CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(availableHeight * 0.0625));

                // Redraw desktop
                window.emulator.drawDesktop();

                // Redraw icons
                window.emulator.desktop.icons.forEach(icon => {
                    window.emulator.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }
        });

        // WAVE 5 ENHANCEMENT: Throttle utility for performance optimization
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        function setupEmulatorEventListeners() {
            // WAVE 5 ENHANCEMENT: Throttled mouse handlers for better performance
            const throttledMouseMove = throttle((e) => {
                if (window.emulator && window.emulator.windowManager) {
                    window.emulator.windowManager.handleMouseMove(e);
                }
            }, 16); // ~60fps

            document.addEventListener('mousemove', throttledMouseMove);

            document.addEventListener('mouseup', (e) => {
                if (window.emulator && window.emulator.windowManager) {
                    window.emulator.windowManager.handleMouseUp(e);
                }
            });
        }

        // ============================================
        // AI STATE CONTROLLER - Intelligence Injection System
        // ============================================
        class AIStateController {
            constructor(emulator) {
                this.emulator = emulator;
                this.stateFilePath = '.ai/windows95-agent-state.json';
                this.pollInterval = 5000; // Check every 5 seconds
                this.lastStateVersion = null;
                this.executedCommands = new Set();
                this.isActive = false;
                this.pollTimer = null;

                this.log('AI State Controller initialized');
            }

            start() {
                if (this.isActive) return;
                this.isActive = true;
                this.log('AI State Controller starting...');
                this.pollState();
                this.pollTimer = setInterval(() => this.pollState(), this.pollInterval);
            }

            stop() {
                this.isActive = false;
                if (this.pollTimer) {
                    clearInterval(this.pollTimer);
                    this.pollTimer = null;
                }
                this.log('AI State Controller stopped');
            }

            async pollState() {
                if (!this.isActive) return;

                try {
                    const response = await fetch(this.stateFilePath, {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache'
                        }
                    });

                    if (!response.ok) {
                        // File might not exist yet, that's okay
                        return;
                    }

                    const state = await response.json();

                    // Check if this is a new state version
                    if (state.timestamp !== this.lastStateVersion) {
                        this.lastStateVersion = state.timestamp;
                        this.processState(state);
                    }
                } catch (error) {
                    // Silent fail - file might not exist yet or network error
                    // This is normal for a static file that may not be created yet
                }
            }

            processState(state) {
                this.log(`Processing AI state: ${state.goals ? state.goals[0] : 'unknown goal'}`);

                // Show AI indicator
                this.showAIIndicator();

                // Process commands if present
                if (state.commands && Array.isArray(state.commands)) {
                    state.commands.forEach(command => {
                        // Only execute if not already executed and not expired
                        if (!this.executedCommands.has(command.id)) {
                            if (!command.expiry || Date.now() < command.expiry) {
                                this.executeCommand(command);
                                this.executedCommands.add(command.id);
                            }
                        }
                    });
                }

                // Clean up old executed commands (keep last 100)
                if (this.executedCommands.size > 100) {
                    const commandsArray = Array.from(this.executedCommands);
                    this.executedCommands = new Set(commandsArray.slice(-100));
                }
            }

            executeCommand(command) {
                this.log(`Executing command: ${command.type}`);

                try {
                    switch(command.type) {
                        case 'createWindow':
                            this.cmdCreateWindow(command.params);
                            break;
                        case 'closeWindow':
                            this.cmdCloseWindow(command.params);
                            break;
                        case 'moveWindow':
                            this.cmdMoveWindow(command.params);
                            break;
                        case 'openProgram':
                            this.cmdOpenProgram(command.params);
                            break;
                        case 'notification':
                            this.cmdShowNotification(command.params);
                            break;
                        case 'executeScript':
                            this.cmdExecuteScript(command.params);
                            break;
                        default:
                            this.log(`Unknown command type: ${command.type}`);
                    }
                } catch (error) {
                    this.log(`Error executing command ${command.type}: ${error.message}`);
                }
            }

            cmdCreateWindow(params) {
                if (this.emulator && this.emulator.windowManager) {
                    const win = this.emulator.windowManager.createWindow(
                        params.title || 'AI Generated Window',
                        params.content || '<p>AI generated content</p>',
                        params.width || 400,
                        params.height || 300
                    );

                    if (win && (params.x !== undefined || params.y !== undefined)) {
                        win.style.left = (params.x || 100) + 'px';
                        win.style.top = (params.y || 100) + 'px';
                    }

                    // Mark as AI-controlled
                    if (win) {
                        win.classList.add('ai-controlled');
                    }
                }
            }

            cmdCloseWindow(params) {
                if (params.windowId && this.emulator && this.emulator.windowManager) {
                    const window = this.emulator.windowManager.windows.find(w => w.id === params.windowId);
                    if (window) {
                        this.emulator.windowManager.closeWindow(window);
                    }
                }
            }

            cmdMoveWindow(params) {
                if (params.windowId && this.emulator && this.emulator.windowManager) {
                    const window = this.emulator.windowManager.windows.find(w => w.id === params.windowId);
                    if (window) {
                        window.style.left = (params.x || 0) + 'px';
                        window.style.top = (params.y || 0) + 'px';
                    }
                }
            }

            cmdOpenProgram(params) {
                if (params.program && this.emulator) {
                    const methodName = `open${params.program}`;
                    if (typeof this.emulator[methodName] === 'function') {
                        this.emulator[methodName]();
                    }
                }
            }

            cmdShowNotification(params) {
                // Create a simple notification window
                this.cmdCreateWindow({
                    title: '🤖 AI Assistant',
                    content: `<div style="padding: 15px;">
                        <p style="margin-bottom: 10px;">${params.message || 'Notification from AI'}</p>
                        <button class="btn" onclick="this.closest('.window').querySelector('.window-close').click()">OK</button>
                    </div>`,
                    x: params.x || (window.innerWidth - 350) / 2,
                    y: params.y || 100,
                    width: 350,
                    height: 150
                });
            }

            cmdExecuteScript(params) {
                // Allow AI to execute arbitrary JavaScript (with caution)
                if (params.code) {
                    try {
                        const func = new Function('emulator', params.code);
                        func(this.emulator);
                    } catch (error) {
                        this.log(`Script execution error: ${error.message}`);
                    }
                }
            }

            showAIIndicator() {
                // Show a subtle AI activity indicator in taskbar
                const statusBar = document.querySelector('.status-bar');
                if (statusBar) {
                    let indicator = document.getElementById('ai-indicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'ai-indicator';
                        indicator.style.cssText = `
                            position: absolute;
                            right: 10px;
                            top: 50%;
                            transform: translateY(-50%);
                            width: 12px;
                            height: 12px;
                            background: #00ff00;
                            border-radius: 50%;
                            box-shadow: 0 0 10px #00ff00;
                            animation: pulse 2s infinite;
                        `;
                        indicator.title = 'AI Agent Active';
                        statusBar.appendChild(indicator);
                    }

                    // Flash the indicator
                    indicator.style.opacity = '1';
                    setTimeout(() => {
                        if (indicator) indicator.style.opacity = '0.5';
                    }, 500);
                }
            }

            log(message) {
                // Use a prefix to identify AI controller logs
                console.log(`[AI Controller] ${message}`);
            }
        }

        // ============================================
        // CLIPPY ASSISTANT - Context-Aware AI Helper
        // ============================================
        class ClippyAssistant {
            constructor(emulator, aiController) {
                this.emulator = emulator;
                this.aiController = aiController;
                this.briefingContext = null;
                this.isVisible = false;
                this.element = null;
                this.tipHistory = [];
                this.lastTipTime = 0;
                this.tipCooldown = 30000; // 30 seconds between tips

                this.createClippyUI();
                this.loadBriefingContext();
                this.log('Clippy initialized with briefing context');
            }

            async loadBriefingContext() {
                try {
                    // Try to load agent-generated briefing
                    const response = await fetch('.ai/windows95-agent-state.json', {
                        cache: 'no-cache'
                    });

                    let useAgentBriefing = false;

                    if (response.ok) {
                        const agentBriefing = await response.json();
                        const now = Date.now();
                        const briefingAge = now - (agentBriefing.timestamp || 0);
                        const twentyFourHours = 24 * 60 * 60 * 1000;

                        // Use agent briefing if it's less than 24 hours old
                        if (briefingAge < twentyFourHours) {
                            this.briefingContext = agentBriefing;
                            useAgentBriefing = true;
                            this.log('Using agent-generated briefing (age: ' + Math.round(briefingAge / 1000 / 60) + ' minutes)');
                        } else {
                            this.log('Agent briefing expired (age: ' + Math.round(briefingAge / 1000 / 60 / 60) + ' hours), generating live briefing');
                        }
                    }

                    // If no valid agent briefing, generate live one
                    if (!useAgentBriefing) {
                        this.briefingContext = this.generateLiveBriefing();
                        this.log('Generated live briefing with current dates');
                    }

                    // Determine personality based on time gap
                    this.calibratePersonality();

                    // Show initial greeting after a short delay
                    setTimeout(() => this.showInitialGreeting(), 3000);

                } catch (error) {
                    this.log('Error loading briefing, generating live one:', error);
                    this.briefingContext = this.generateLiveBriefing();
                    this.calibratePersonality();
                    setTimeout(() => this.showInitialGreeting(), 3000);
                }
            }

            generateLiveBriefing() {
                const now = new Date();
                const timestamp = now.getTime();

                // Get last visit from localStorage
                const lastVisit = localStorage.getItem('win95-last-visit');
                const lastVisitTime = lastVisit ? parseInt(lastVisit) : timestamp;
                const daysSinceLastVisit = Math.floor((timestamp - lastVisitTime) / (1000 * 60 * 60 * 24));

                // Save current visit
                localStorage.setItem('win95-last-visit', timestamp.toString());

                // Determine gap category
                let gapCategory, gapDescription;
                if (daysSinceLastVisit === 0) {
                    gapCategory = 'same_day';
                    gapDescription = 'earlier today';
                } else if (daysSinceLastVisit === 1) {
                    gapCategory = 'normal_daily';
                    gapDescription = '1 day';
                } else if (daysSinceLastVisit <= 3) {
                    gapCategory = 'weekend_return';
                    gapDescription = daysSinceLastVisit + ' days';
                } else if (daysSinceLastVisit <= 14) {
                    gapCategory = 'weekly_return';
                    gapDescription = daysSinceLastVisit + ' days';
                } else if (daysSinceLastVisit <= 60) {
                    gapCategory = 'monthly_return';
                    gapDescription = Math.round(daysSinceLastVisit / 7) + ' weeks';
                } else {
                    gapCategory = 'long_absence';
                    gapDescription = Math.round(daysSinceLastVisit / 30) + ' months';
                }

                // Format dates
                const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

                const dayName = daysOfWeek[now.getDay()];
                const monthName = months[now.getMonth()];
                const day = now.getDate();
                const year = now.getFullYear();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 || 12;
                const displayMinutes = minutes < 10 ? '0' + minutes : minutes;

                const publishedDate = year + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                const publishedTime = displayHours + ':' + displayMinutes + ' ' + ampm;
                const briefingTitle = 'Daily Intelligence Briefing - ' + dayName + ', ' + monthName + ' ' + day + ', ' + year;

                // Generate context-appropriate message
                let welcomeMessage, primaryFocus, keyPriorities, aiGuidance;

                if (gapCategory === 'same_day') {
                    welcomeMessage = "Welcome back! You were here earlier today.";
                    primaryFocus = "Continue your momentum";
                    keyPriorities = [
                        "📝 Complete pending tasks from earlier",
                        "✅ Check off items from your list",
                        "🎯 Stay focused on today's goals"
                    ];
                    aiGuidance = "You're in a good flow. Keep going!";
                } else if (gapCategory === 'long_absence') {
                    welcomeMessage = "Welcome back after " + gapDescription + "! Take it easy today.";
                    primaryFocus = "Gentle reintroduction";
                    keyPriorities = [
                        "🔍 Explore the interface again",
                        "📝 Start with something simple",
                        "🎯 No pressure - just get comfortable"
                    ];
                    aiGuidance = "After " + gapDescription + ", focus on comfort over productivity.";
                } else {
                    welcomeMessage = "Good " + (hours < 12 ? 'morning' : hours < 18 ? 'afternoon' : 'evening') + "! Welcome back.";
                    primaryFocus = "Productivity and progress";
                    keyPriorities = [
                        "🎯 Review your priorities",
                        "📝 Focus on key tasks",
                        "✨ Make meaningful progress"
                    ];
                    aiGuidance = "Let's make today count!";
                }

                return {
                    timestamp: timestamp,
                    publishedDate: publishedDate,
                    publishedTime: publishedTime,
                    version: "1.0.0",
                    agentId: "live-briefing-generator",
                    briefingTitle: briefingTitle,
                    timeGapContext: {
                        lastBriefingTimestamp: lastVisitTime,
                        lastBriefingDate: new Date(lastVisitTime).toISOString().split('T')[0],
                        daysSinceLastBriefing: daysSinceLastVisit,
                        gapCategory: gapCategory,
                        gapDescription: gapDescription,
                        returningUser: daysSinceLastVisit > 0,
                        welcomeBackMessage: welcomeMessage
                    },
                    todaysAgenda: {
                        greeting: welcomeMessage,
                        primaryFocus: primaryFocus,
                        contextualNote: "Briefing generated with live dates on " + dayName + ", " + monthName + " " + day + ", " + year,
                        keyPriorities: keyPriorities,
                        aiGuidance: aiGuidance
                    },
                    insights: {
                        suggestions: [
                            "💡 This briefing was generated automatically with current dates",
                            "🤖 An AI agent can override this with custom briefings",
                            "📅 Briefing updates every 24 hours"
                        ]
                    },
                    metadata: {
                        lastUpdate: timestamp,
                        updateFrequency: 86400000,
                        briefingType: "live_generated",
                        source: "emulator_javascript"
                    }
                };
            }

            calibratePersonality() {
                if (!this.briefingContext?.timeGapContext) return;

                const gap = this.briefingContext.timeGapContext.gapCategory;

                // Personality profiles based on time gap
                this.personalities = {
                    'same_day': {
                        tone: 'casual_encouraging',
                        helpfulness: 'high',
                        frequency: 'medium',
                        greeting: "Hey! You're back already. Let's keep the momentum going!"
                    },
                    'normal_daily': {
                        tone: 'energetic_supportive',
                        helpfulness: 'high',
                        frequency: 'medium',
                        greeting: "Good morning! Ready to tackle today's priorities?"
                    },
                    'weekend_return': {
                        tone: 'refreshed_welcoming',
                        helpfulness: 'high',
                        frequency: 'medium',
                        greeting: "Welcome back after the weekend! Feeling refreshed?"
                    },
                    'weekly_return': {
                        tone: 'gentle_reorienting',
                        helpfulness: 'medium',
                        frequency: 'low',
                        greeting: "It's been a week! Let me help you get back up to speed."
                    },
                    'monthly_return': {
                        tone: 'patient_guiding',
                        helpfulness: 'medium',
                        frequency: 'low',
                        greeting: "Welcome back! It's been a while. Want a quick tour?"
                    },
                    'long_absence': {
                        tone: 'extremely_gentle',
                        helpfulness: 'low',
                        frequency: 'very_low',
                        greeting: "Wow, it's been ages! No pressure today - I'm here if you need me."
                    }
                };

                this.currentPersonality = this.personalities[gap] || this.personalities['normal_daily'];
                this.log(`Personality calibrated: ${gap}`, this.currentPersonality);
            }

            createClippyUI() {
                // Create Clippy's visual representation
                this.element = document.createElement('div');
                this.element.id = 'clippy-assistant';
                this.element.style.cssText = `
                    position: fixed;
                    bottom: 60px;
                    right: 20px;
                    width: 280px;
                    background: var(--window-background);
                    border: 2px solid;
                    border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
                    box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
                    z-index: 10000;
                    display: none;
                    font-family: 'MS Sans Serif', Arial, sans-serif;
                    font-size: 11px;
                `;

                this.element.innerHTML = `
                    <div style="background: linear-gradient(180deg, #0055d4 0%, #0040a8 100%); color: white; padding: 3px 6px; display: flex; justify-content: space-between; align-items: center; cursor: move;">
                        <span style="font-weight: bold;">📎 Clippy</span>
                        <button onclick="clippy.hide()" style="background: var(--button-face); border: 1px outset; width: 16px; height: 14px; cursor: pointer; font-size: 9px; padding: 0;">×</button>
                    </div>
                    <div id="clippy-content" style="padding: 12px; color: black;">
                        <div id="clippy-avatar" style="font-size: 48px; text-align: center; margin-bottom: 8px;">📎</div>
                        <div id="clippy-message" style="line-height: 1.4; margin-bottom: 10px;">
                            Hi! I'm Clippy, your AI assistant.
                        </div>
                        <div id="clippy-actions" style="display: flex; flex-direction: column; gap: 6px;">
                        </div>
                    </div>
                `;

                document.body.appendChild(this.element);

                // Make draggable
                this.makeDraggable();

                // Add Clippy icon to taskbar
                this.addTaskbarIcon();
            }

            addTaskbarIcon() {
                const statusBar = document.querySelector('.status-bar');
                if (statusBar) {
                    const clippyIcon = document.createElement('div');
                    clippyIcon.style.cssText = `
                        position: absolute;
                        right: 35px;
                        top: 50%;
                        transform: translateY(-50%);
                        font-size: 16px;
                        cursor: pointer;
                        padding: 2px 6px;
                        border: 1px solid transparent;
                        user-select: none;
                    `;
                    clippyIcon.textContent = '📎';
                    clippyIcon.title = 'Clippy - AI Assistant';
                    clippyIcon.onclick = () => this.toggle();

                    clippyIcon.onmouseenter = () => {
                        clippyIcon.style.background = 'rgba(255,255,255,0.1)';
                        clippyIcon.style.borderColor = '#ccc';
                    };
                    clippyIcon.onmouseleave = () => {
                        clippyIcon.style.background = 'transparent';
                        clippyIcon.style.borderColor = 'transparent';
                    };

                    statusBar.appendChild(clippyIcon);
                }
            }

            makeDraggable() {
                const titleBar = this.element.querySelector('div');
                let isDragging = false;
                let currentX, currentY, initialX, initialY;

                titleBar.addEventListener('mousedown', (e) => {
                    if (e.target === titleBar || e.target.tagName === 'SPAN') {
                        isDragging = true;
                        initialX = e.clientX - this.element.offsetLeft;
                        initialY = e.clientY - this.element.offsetTop;
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        this.element.style.right = 'auto';
                        this.element.style.bottom = 'auto';
                        this.element.style.left = currentX + 'px';
                        this.element.style.top = currentY + 'px';
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }

            showInitialGreeting() {
                if (!this.briefingContext) return;

                const timeGap = this.briefingContext.timeGapContext;
                const agenda = this.briefingContext.todaysAgenda;

                let message = this.currentPersonality?.greeting || "Hi! I'm here to help.";

                // Add context-specific message
                if (timeGap?.gapCategory === 'long_absence') {
                    message += `\n\n💡 I see you've been away for ${timeGap.gapDescription}. Your daily briefing has been adjusted to be gentle and welcoming. No pressure today!`;
                } else if (timeGap?.gapCategory === 'weekly_return') {
                    message += `\n\n💡 It's been ${timeGap.daysSinceLastBriefing} days. Your briefing focuses on catching up and reorienting. Want me to summarize what you should focus on?`;
                } else if (agenda?.keyPriorities) {
                    message += `\n\n💡 Today's top priority: ${agenda.keyPriorities[0]}`;
                }

                this.show(message, [
                    {
                        label: '📋 Show Daily Briefing',
                        action: () => {
                            this.hide();
                            // Briefing should already be visible, but we can highlight it
                        }
                    },
                    {
                        label: '✨ Give me a tip',
                        action: () => this.giveContextualTip()
                    },
                    {
                        label: '👋 Maybe later',
                        action: () => this.hide()
                    }
                ]);
            }

            giveContextualTip() {
                if (!this.briefingContext) {
                    this.show("I don't have context yet. Let me load your briefing...", []);
                    this.loadBriefingContext();
                    return;
                }

                const timeGap = this.briefingContext.timeGapContext;
                const agenda = this.briefingContext.todaysAgenda;
                const insights = this.briefingContext.insights;

                // Generate contextual tip based on briefing
                let tips = [];

                // Time-gap specific tips
                if (timeGap?.gapCategory === 'long_absence') {
                    tips.push(
                        `💡 After ${timeGap.gapDescription}, I recommend spending 10-15 minutes just exploring. Click around, open programs, get comfortable.`,
                        `🎯 Your briefing suggests: "${agenda?.aiGuidance}"`,
                        `✨ No need to be productive today. Just showing up after ${timeGap.gapDescription} is an achievement!`
                    );
                } else if (timeGap?.gapCategory === 'same_day') {
                    tips.push(
                        `⚡ You've completed ${insights?.yesterdayStats?.completedTasks || 0} tasks already today. Keep going!`,
                        `💡 Your most productive time today has been around this hour. Stay focused!`,
                        `🎯 You have ${agenda?.keyPriorities?.length || 0} priorities left for today.`
                    );
                } else {
                    tips.push(
                        `🎯 Top priority: "${agenda?.keyPriorities?.[0] || 'Check your briefing'}"`,
                        `💡 ${agenda?.aiGuidance || 'Focus on your goals for today'}`,
                        `📊 Yesterday you completed ${insights?.yesterdayStats?.completedTasks || 'several'} tasks.`
                    );
                }

                // Add program-specific tips
                if (agenda?.recommendedPrograms?.length) {
                    tips.push(
                        `📝 Recommended programs for today: ${agenda.recommendedPrograms.join(', ')}`
                    );
                }

                // Pick a random tip
                const tip = tips[Math.floor(Math.random() * tips.length)];

                this.show(tip, [
                    {
                        label: '👍 Thanks!',
                        action: () => this.hide()
                    },
                    {
                        label: '💡 Another tip',
                        action: () => this.giveContextualTip()
                    }
                ]);

                this.tipHistory.push({ tip, timestamp: Date.now() });
                this.lastTipTime = Date.now();
            }

            // Proactive tip system - call this from user interactions
            maybeShowTip(context) {
                // Don't spam tips
                if (Date.now() - this.lastTipTime < this.tipCooldown) return;
                if (this.isVisible) return;

                // Check if we should show a tip based on context and briefing
                if (!this.briefingContext) return;

                // Examples of contextual tips:
                // - User opens Notepad → "I see you opened Notepad. Your briefing says to use it for task planning!"
                // - User hasn't done anything for 5 minutes → "Need help getting started? Your top priority is: ..."
                // - User completed a task → "Great! You're making progress on today's goals."

                // This would be called from various UI interactions
                // For now, we'll keep it simple and reactive
            }

            show(message, actions = []) {
                this.isVisible = true;
                this.element.style.display = 'block';

                const messageEl = this.element.querySelector('#clippy-message');
                const actionsEl = this.element.querySelector('#clippy-actions');

                messageEl.textContent = message;

                actionsEl.innerHTML = '';
                actions.forEach(action => {
                    const btn = document.createElement('button');
                    btn.className = 'btn';
                    btn.textContent = action.label;
                    btn.style.cssText = 'padding: 4px 8px; cursor: pointer; width: 100%; text-align: left;';
                    btn.onclick = action.action;
                    actionsEl.appendChild(btn);
                });
            }

            hide() {
                this.isVisible = false;
                this.element.style.display = 'none';
            }

            toggle() {
                if (this.isVisible) {
                    this.hide();
                } else {
                    this.giveContextualTip();
                }
            }

            log(message, data) {
                console.log(`[Clippy] ${message}`, data || '');
            }
        }

        // Initialize AI State Controller when emulator is ready
        let aiController = null;
        let clippy = null;

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!window.emulator) return; // Exit if emulator not ready

            // Ctrl+Esc or Windows key - Toggle Start menu
            if ((e.ctrlKey && e.key === 'Escape') || e.key === 'Meta' || e.key === 'OS') {
                e.preventDefault();
                if (window.emulator && window.emulator.toggleStartMenu) {
                    window.emulator.toggleStartMenu();
                }
                return;
            }

            // Ctrl+Shift+S - Quick Save State (Virtual Floppy)
            if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                if (window.emulator && window.emulator.downloadFloppyDisk) {
                    window.emulator.downloadFloppyDisk();
                }
                return;
            }

            // Ctrl+Shift+O - Quick Load State (Virtual Floppy)
            if (e.ctrlKey && e.shiftKey && e.key === 'O') {
                e.preventDefault();
                if (window.emulator && window.emulator.loadFloppyDisk) {
                    window.emulator.loadFloppyDisk();
                }
                return;
            }

            // Ctrl+H - Toggle header visibility
            if (e.ctrlKey && e.key === 'h') {
                e.preventDefault();
                const header = document.querySelector('.header');
                if (header) {
                    header.classList.toggle('hidden');
                    // Recalculate canvas size when header is toggled
                    if (window.emulator.canvas && window.emulator.isRunning) {
                        const statusBar = document.querySelector('.status-bar');
                        const headerHeight = header.classList.contains('hidden') ? 0 : header.offsetHeight;
                        const statusBarHeight = statusBar ? statusBar.offsetHeight : 22;

                        const availableWidth = window.innerWidth;
                        const availableHeight = window.innerHeight - headerHeight - statusBarHeight;

                        window.emulator.canvas.width = availableWidth;
                        window.emulator.canvas.height = availableHeight;

                        CONFIG.DISPLAY.WIDTH = availableWidth;
                        CONFIG.DISPLAY.HEIGHT = availableHeight;
                        CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(availableHeight * 0.0625));

                        window.emulator.drawDesktop();
                        window.emulator.desktop.icons.forEach(icon => {
                            window.emulator.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                        });
                    }
                }
                return;
            }

            // ESC - Release mouse
            if (e.key === 'Escape') {
                const isLocked = document.pointerLockElement ||
                                document.webkitPointerLockElement ||
                                document.mozPointerLockElement;

                if (isLocked) {
                    const exitPointerLock = document.exitPointerLock ||
                                          document.webkitExitPointerLock ||
                                          document.mozExitPointerLock;
                    if (exitPointerLock) {
                        exitPointerLock.call(document);
                    }
                }
            }

            // F11 - Fullscreen
            if (e.key === 'F11') {
                e.preventDefault();
                emulator.fullscreen();
            }

            // Ctrl+P - Pause
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                emulator.togglePause();
            }

            // Ctrl+S - Screenshot
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                emulator.screenshot();
            }

            // Ctrl+R - Restart
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                emulator.restart();
            }

            // Alt+Tab - Cycle through windows (Windows 95 style)
            if (e.altKey && e.key === 'Tab') {
                e.preventDefault();
                if (emulator.windowManager && emulator.windowManager.windows.length > 0) {
                    // Get visible (non-minimized) windows
                    const visibleWindows = emulator.windowManager.windows.filter(w => !w.minimized);
                    if (visibleWindows.length > 1) {
                        // Find current active window index
                        const activeIndex = visibleWindows.findIndex(w => w.element.classList.contains('active'));
                        // Cycle to next window (or first if none active)
                        const nextIndex = (activeIndex + 1) % visibleWindows.length;
                        emulator.windowManager.focusWindow(visibleWindows[nextIndex].element);
                    } else if (visibleWindows.length === 1) {
                        // Only one window, just focus it
                        emulator.windowManager.focusWindow(visibleWindows[0].element);
                    }
                }
            }

            // Alt+F4 - Close active window
            if (e.altKey && e.key === 'F4') {
                e.preventDefault();
                const activeWindow = document.querySelector('.window.active');
                if (activeWindow && emulator.windowManager) {
                    emulator.windowManager.closeWindow(activeWindow);
                }
            }

            // Ctrl+Escape or Windows key - Toggle Start Menu
            if ((e.ctrlKey && e.key === 'Escape') || e.key === 'Meta' || e.key === 'OS') {
                e.preventDefault();
                emulator.toggleStartMenu();
            }

            // F1 - Help
            if (e.key === 'F1') {
                e.preventDefault();
                emulator.showHelp();
            }

            // Ctrl+N - New Notepad
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                emulator.openNotepad();
            }

            // WAVE 4 ENHANCEMENT #2: Clipboard Keyboard Shortcuts
            // Ctrl+C - Copy (File Explorer)
            if (e.ctrlKey && e.key === 'c' && document.getElementById('explorer-content')) {
                e.preventDefault();
                if (emulator.selectedExplorerItem) {
                    emulator.explorerCopy();
                }
            }

            // Ctrl+X - Cut (File Explorer)
            if (e.ctrlKey && e.key === 'x' && document.getElementById('explorer-content')) {
                e.preventDefault();
                if (emulator.selectedExplorerItem) {
                    emulator.explorerCut();
                }
            }

            // Ctrl+V - Paste (File Explorer)
            if (e.ctrlKey && e.key === 'v' && document.getElementById('explorer-content')) {
                e.preventDefault();
                if (emulator.clipboard.items.length > 0) {
                    emulator.explorerPaste();
                }
            }

            // Delete key - Delete selected file (File Explorer)
            if (e.key === 'Delete' && document.getElementById('explorer-content')) {
                if (emulator.selectedExplorerItem) {
                    emulator.explorerDeleteSelected();
                }
            }

            // Ctrl+Shift+Esc - Task Manager
            if (e.ctrlKey && e.shiftKey && e.key === 'Escape') {
                e.preventDefault();
                emulator.openTaskManager();
            }

            // Windows+E - File Explorer
            if ((e.metaKey || e.key === 'OS') && e.key === 'e') {
                e.preventDefault();
                emulator.openFileExplorer();
            }

            // Windows+R - Run dialog (open DOS prompt for now)
            if ((e.metaKey || e.key === 'OS') && e.key === 'r') {
                e.preventDefault();
                emulator.openDOSPrompt();
            }

            // Windows+D - Show Desktop (minimize all windows)
            if ((e.metaKey || e.key === 'OS') && e.key === 'd') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.minimizeAllWindows();
                }
            }

            // Windows+Shift+F - Cascade windows
            if ((e.metaKey || e.key === 'OS') && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.cascadeWindows();
                }
            }

            // Windows+Shift+H - Tile windows horizontally
            if ((e.metaKey || e.key === 'OS') && e.shiftKey && e.key === 'H') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.tileHorizontally();
                }
            }

            // Windows+Shift+V - Tile windows vertically
            if ((e.metaKey || e.key === 'OS') && e.shiftKey && e.key === 'V') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.tileVertically();
                }
            }

            // F5 - Refresh desktop
            if (e.key === 'F5') {
                e.preventDefault();
                emulator.refreshDesktop();
            }

            // Delete key - Delete selected item in File Explorer
            if (e.key === 'Delete' && !e.ctrlKey && !e.altKey) {
                // Check if File Explorer window is active and has a selected item
                if (emulator.selectedExplorerItem) {
                    e.preventDefault();
                    emulator.explorerDeleteSelected();
                }
            }

            // Ctrl+Alt+Delete - Task Manager
            if (e.ctrlKey && e.altKey && e.key === 'Delete') {
                e.preventDefault();
                emulator.openTaskManager();
            }
        });

        // Auto-save settings
        window.addEventListener('beforeunload', () => {
            const settings = {
                memory: document.getElementById('memory-size').value,
                cpuSpeed: document.getElementById('cpu-speed').value,
                enableMouse: document.getElementById('enable-mouse').checked,
                enableSound: document.getElementById('enable-sound').checked,
                enableNetwork: document.getElementById('enable-network').checked
            };
            SafeStorage.setItem('win95-emulator-settings', JSON.stringify(settings));
        });

        // Load saved settings
        window.addEventListener('load', () => {
            const saved = SafeStorage.getItem('win95-emulator-settings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    document.getElementById('memory-size').value = settings.memory || '32';
                    document.getElementById('cpu-speed').value = settings.cpuSpeed || '2';
                    document.getElementById('enable-mouse').checked = settings.enableMouse !== false;
                    document.getElementById('enable-sound').checked = settings.enableSound !== false;
                    document.getElementById('enable-network').checked = settings.enableNetwork !== false;
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            }
        });

        // Handle file input label update (with null check)
        const diskInput = document.getElementById('disk-input');
        if (diskInput) {
            diskInput.addEventListener('change', function(e) {
                const fileName = e.target.files[0]?.name;
                if (fileName) {
                    const label = document.querySelector('.file-input-label');
                    if (label) {
                        label.textContent = fileName;
                    }
                }
            });
        }

        // Fullscreen change handler with cross-browser support
        function handleFullscreenChange() {
            const frame = document.querySelector('.emulator-frame');
            const isFullscreen = document.fullscreenElement ||
                               document.webkitFullscreenElement ||
                               document.mozFullScreenElement ||
                               document.msFullscreenElement;

            if (isFullscreen) {
                if (frame) {
                    frame.classList.add('fullscreen-mode');
                }
                // Resize canvas to fill screen
                setTimeout(() => {
                    if (emulator && emulator.resizeCanvas) {
                        const screenContainer = document.getElementById('screen_container');
                        if (screenContainer) {
                            const width = screenContainer.clientWidth;
                            const height = screenContainer.clientHeight;
                            emulator.resizeCanvas(width, height);
                        }
                    }
                }, 100);
            } else {
                if (frame) {
                    frame.classList.remove('fullscreen-mode');
                }
                // Restore original canvas size
                if (emulator && emulator.resizeCanvas) {
                    emulator.resizeCanvas(640, 480);
                }
            }
        }

        // Add event listeners for all browser prefixes
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        // Log initialization
        console.log('Windows 95 WASM Emulator initialized');
    </script>

    <!-- Single Morphing Clippy Assistant System -->
    <div id="clippy-container"></div>

    <!-- Screen Saver System -->
    <div id="screensaver" class="screensaver">
        <canvas id="screensaver-canvas" class="screensaver-canvas"></canvas>
    </div>

    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <script>
        /** @ts-nocheck */

        // ========================================
        // SCREEN SAVER MANAGER
        // ========================================

        class ScreenSaverManager {
            constructor() {
                this.container = document.getElementById('screensaver');
                this.canvas = document.getElementById('screensaver-canvas');
                this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
                this.active = false;
                this.idleTimeout = 120000; // 2 minutes of inactivity
                this.idleTimer = null;
                this.animationFrame = null;
                this.currentSaver = 'starfield'; // starfield, pipes, matrix, flying-logo
                this.lastActivity = Date.now();

                this.init();
            }

            init() {
                // Track user activity
                ['mousemove', 'mousedown', 'keydown', 'touchstart', 'wheel'].forEach(event => {
                    document.addEventListener(event, () => this.resetIdleTimer());
                });

                // Start idle timer
                this.resetIdleTimer();

                // Resize canvas to window size
                if (this.canvas) {
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());
                }
            }

            resizeCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            resetIdleTimer() {
                this.lastActivity = Date.now();

                if (this.active) {
                    this.deactivate();
                }

                clearTimeout(this.idleTimer);
                this.idleTimer = setTimeout(() => {
                    this.activate();
                }, this.idleTimeout);
            }

            activate() {
                if (this.active) return;

                this.active = true;
                this.container.classList.add('active');
                this.resizeCanvas();

                // Choose random screensaver
                const savers = ['starfield', 'pipes', 'matrix', 'flying-logo', 'beziers', 'marquee'];
                this.currentSaver = savers[Math.floor(Math.random() * savers.length)];

                // Initialize the chosen screensaver
                switch(this.currentSaver) {
                    case 'starfield':
                        this.startStarfield();
                        break;
                    case 'pipes':
                        this.startPipes();
                        break;
                    case 'matrix':
                        this.startMatrix();
                        break;
                    case 'flying-logo':
                        this.startFlyingLogo();
                        break;
                    case 'beziers':
                        this.startBeziers();
                        break;
                    case 'marquee':
                        this.startMarquee();
                        break;
                }

            }

            deactivate() {
                if (!this.active) return;

                this.active = false;
                this.container.classList.remove('active');

                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }

                // Clear canvas
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            // ========================================
            // STARFIELD SCREENSAVER
            // ========================================

            startStarfield() {
                const stars = [];
                const numStars = 200;
                const speed = 2;

                // Initialize stars
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * this.canvas.width,
                        size: Math.random() * 2 + 1
                    });
                }

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;

                    stars.forEach(star => {
                        star.z -= speed;

                        if (star.z <= 0) {
                            star.z = this.canvas.width;
                            star.x = Math.random() * this.canvas.width;
                            star.y = Math.random() * this.canvas.height;
                        }

                        const k = 128 / star.z;
                        const px = (star.x - cx) * k + cx;
                        const py = (star.y - cy) * k + cy;

                        const size = (1 - star.z / this.canvas.width) * star.size;
                        const brightness = Math.floor(255 * (1 - star.z / this.canvas.width));

                        this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                        this.ctx.fillRect(px, py, size, size);
                    });

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // 3D PIPES SCREENSAVER
            // ========================================

            startPipes() {
                const pipes = [];
                const numPipes = 5;
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

                class Pipe {
                    constructor(canvas) {
                        this.canvas = canvas;
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                        this.direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                        this.color = colors[Math.floor(Math.random() * colors.length)];
                        this.segments = [];
                        this.speed = 5;
                        this.maxSegments = 50;
                    }

                    update() {
                        // Occasionally change direction
                        if (Math.random() < 0.05) {
                            this.direction = Math.floor(Math.random() * 4);
                        }

                        // Move based on direction
                        switch(this.direction) {
                            case 0: this.y -= this.speed; break;
                            case 1: this.x += this.speed; break;
                            case 2: this.y += this.speed; break;
                            case 3: this.x -= this.speed; break;
                        }

                        // Wrap around edges
                        if (this.x < 0) this.x = this.canvas.width;
                        if (this.x > this.canvas.width) this.x = 0;
                        if (this.y < 0) this.y = this.canvas.height;
                        if (this.y > this.canvas.height) this.y = 0;

                        // Add current position to segments
                        this.segments.push({ x: this.x, y: this.y });
                        if (this.segments.length > this.maxSegments) {
                            this.segments.shift();
                        }
                    }

                    draw(ctx) {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        if (this.segments.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(this.segments[0].x, this.segments[0].y);
                            for (let i = 1; i < this.segments.length; i++) {
                                ctx.lineTo(this.segments[i].x, this.segments[i].y);
                            }
                            ctx.stroke();
                        }

                        // Draw joint at current position
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Create pipes
                for (let i = 0; i < numPipes; i++) {
                    pipes.push(new Pipe(this.canvas));
                }

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    pipes.forEach(pipe => {
                        pipe.update();
                        pipe.draw(this.ctx);
                    });

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // MATRIX SCREENSAVER
            // ========================================

            startMatrix() {
                const fontSize = 16;
                const columns = Math.floor(this.canvas.width / fontSize);
                const drops = [];

                for (let i = 0; i < columns; i++) {
                    drops[i] = Math.random() * this.canvas.height / fontSize;
                }

                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=[]{}|;:,.<>?';

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#0F0';
                    this.ctx.font = fontSize + 'px monospace';

                    for (let i = 0; i < drops.length; i++) {
                        const char = chars[Math.floor(Math.random() * chars.length)];
                        this.ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                        if (drops[i] * fontSize > this.canvas.height && Math.random() > 0.975) {
                            drops[i] = 0;
                        }

                        drops[i]++;
                    }

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // FLYING LOGO SCREENSAVER
            // ========================================

            startFlyingLogo() {
                let x = Math.random() * this.canvas.width;
                let y = Math.random() * this.canvas.height;
                let dx = (Math.random() - 0.5) * 4;
                let dy = (Math.random() - 0.5) * 4;
                const size = 80;
                let hue = 0;

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // Update position
                    x += dx;
                    y += dy;

                    // Bounce off edges
                    if (x <= 0 || x >= this.canvas.width - size) dx = -dx;
                    if (y <= 0 || y >= this.canvas.height - size) dy = -dy;

                    // Draw Windows 95 logo
                    const gradient = this.ctx.createLinearGradient(x, y, x + size, y + size);
                    hue = (hue + 1) % 360;
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                    gradient.addColorStop(0.33, `hsl(${(hue + 60) % 360}, 100%, 50%)`);
                    gradient.addColorStop(0.66, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
                    gradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);

                    this.ctx.fillStyle = gradient;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = 'white';
                    this.ctx.fillRect(x, y, size, size);
                    this.ctx.shadowBlur = 0;

                    // Add "Windows 95" text
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Windows 95', x + size/2, y + size + 20);

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // WAVE 7: BEZIERS SCREENSAVER
            // ========================================

            startBeziers() {
                const curves = [];
                const numCurves = 5;

                // Initialize bezier curves
                for (let i = 0; i < numCurves; i++) {
                    curves.push({
                        points: [
                            { x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height },
                            { x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height },
                            { x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height },
                            { x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height }
                        ],
                        velocities: [
                            { dx: (Math.random() - 0.5) * 2, dy: (Math.random() - 0.5) * 2 },
                            { dx: (Math.random() - 0.5) * 2, dy: (Math.random() - 0.5) * 2 },
                            { dx: (Math.random() - 0.5) * 2, dy: (Math.random() - 0.5) * 2 },
                            { dx: (Math.random() - 0.5) * 2, dy: (Math.random() - 0.5) * 2 }
                        ],
                        hue: Math.random() * 360
                    });
                }

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    curves.forEach(curve => {
                        // Update control points
                        curve.points.forEach((point, i) => {
                            point.x += curve.velocities[i].dx;
                            point.y += curve.velocities[i].dy;

                            // Bounce off edges
                            if (point.x <= 0 || point.x >= this.canvas.width) {
                                curve.velocities[i].dx = -curve.velocities[i].dx;
                            }
                            if (point.y <= 0 || point.y >= this.canvas.height) {
                                curve.velocities[i].dy = -curve.velocities[i].dy;
                            }
                        });

                        // Draw bezier curve
                        this.ctx.strokeStyle = `hsl(${curve.hue}, 100%, 50%)`;
                        this.ctx.lineWidth = 3;
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = `hsl(${curve.hue}, 100%, 50%)`;

                        this.ctx.beginPath();
                        this.ctx.moveTo(curve.points[0].x, curve.points[0].y);
                        this.ctx.bezierCurveTo(
                            curve.points[1].x, curve.points[1].y,
                            curve.points[2].x, curve.points[2].y,
                            curve.points[3].x, curve.points[3].y
                        );
                        this.ctx.stroke();

                        this.ctx.shadowBlur = 0;

                        // Slowly change hue
                        curve.hue = (curve.hue + 0.5) % 360;
                    });

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // WAVE 7: MARQUEE SCREENSAVER
            // ========================================

            startMarquee() {
                let x = this.canvas.width;
                const y = this.canvas.height / 2;
                const text = SafeStorage.getItem('screensaver-marquee-text') || 'Windows 95 - The Ultimate Operating System';
                const speed = parseInt(SafeStorage.getItem('screensaver-marquee-speed') || '3');

                this.ctx.font = 'bold 48px Arial';
                const textWidth = this.ctx.measureText(text).width;

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // Draw scrolling text with gradient
                    const gradient = this.ctx.createLinearGradient(x, y - 24, x + textWidth, y + 24);
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(0.25, '#ffff00');
                    gradient.addColorStop(0.5, '#00ff00');
                    gradient.addColorStop(0.75, '#0000ff');
                    gradient.addColorStop(1, '#ff00ff');

                    this.ctx.fillStyle = gradient;
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = 'white';
                    this.ctx.fillText(text, x, y);
                    this.ctx.shadowBlur = 0;

                    // Update position
                    x -= speed;

                    // Reset when off screen
                    if (x < -textWidth) {
                        x = this.canvas.width;
                    }

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }
        }

        // ========================================
        // TOAST NOTIFICATION SYSTEM
        // ========================================

        class ToastManager {
            constructor() {
                this.container = document.getElementById('toast-container');
                this.queue = [];
                this.showing = false;
            }

            show(title, message, duration = 5000) {
                this.queue.push({ title, message, duration });
                if (!this.showing) {
                    this.displayNext();
                }
            }

            displayNext() {
                if (this.queue.length === 0) {
                    this.showing = false;
                    return;
                }

                this.showing = true;
                const { title, message, duration } = this.queue.shift();

                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.innerHTML = `
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                `;

                this.container.appendChild(toast);

                setTimeout(() => {
                    toast.style.animation = 'slideIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        toast.remove();
                        this.displayNext();
                    }, 300);
                }, duration);
            }
        }

        // ========================================
        // WAVE 4 ENHANCEMENT #1: Windows 95 Dialog System
        // ========================================
        // Unified dialog system replacing all alert() calls with authentic Windows 95 dialogs
        class DialogManager {
            constructor() {
                this.activeDialog = null;
                this.modalOverlay = null;
            }

            /**
             * Show Windows 95 style dialog
             * @param {Object} options - Dialog configuration
             * @param {string} options.title - Dialog title
             * @param {string} options.message - Dialog message
             * @param {string} options.type - Dialog type: 'info', 'warning', 'error', 'question'
             * @param {Array} options.buttons - Button array: ['OK'], ['OK', 'Cancel'], ['Yes', 'No'], etc.
             * @param {Function} options.callback - Callback function(buttonClicked)
             */
            show(options) {
                const {
                    title = 'Windows 95',
                    message = '',
                    type = 'info',
                    buttons = ['OK'],
                    callback = null
                } = options;

                // Remove existing dialog if any
                if (this.activeDialog) {
                    this.close();
                }

                // Create modal overlay
                this.modalOverlay = document.createElement('div');
                this.modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.3);
                    z-index: 99999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                // Create dialog window
                const dialog = document.createElement('div');
                dialog.className = 'window active';
                dialog.style.cssText = `
                    position: relative;
                    width: 380px;
                    min-height: 150px;
                    z-index: 100000;
                    box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.5);
                `;

                // Icon map for dialog types
                const icons = {
                    'info': 'ℹ️',
                    'warning': '⚠️',
                    'error': '❌',
                    'question': '❓'
                };

                const icon = icons[type] || icons['info'];

                // Build dialog content
                dialog.innerHTML = `
                    <div class="window-titlebar">
                        <span>${this.escapeHtml(title)}</span>
                        <div class="titlebar-buttons">
                            <div class="titlebar-btn close-btn" title="Close">X</div>
                        </div>
                    </div>
                    <div class="window-content" style="display: flex; padding: 16px; gap: 12px; align-items: start;">
                        <div style="font-size: 32px; flex-shrink: 0;">${icon}</div>
                        <div style="flex: 1; padding-top: 8px;">
                            <div style="word-wrap: break-word; line-height: 1.4;">${this.escapeHtml(message)}</div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; justify-content: center; padding: 12px 16px 16px;">
                        ${buttons.map((btn, idx) => `
                            <button class="btn${idx === 0 ? ' primary' : ''}"
                                    style="min-width: 75px; padding: 4px 12px;"
                                    data-button="${btn}">
                                ${this.escapeHtml(btn)}
                            </button>
                        `).join('')}
                    </div>
                `;

                // Handle button clicks
                const buttonElements = dialog.querySelectorAll('button[data-button]');
                buttonElements.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const buttonValue = btn.dataset.button;
                        this.close();
                        if (callback) {
                            callback(buttonValue);
                        }
                    });
                });

                // Handle close button (X)
                const closeBtn = dialog.querySelector('.close-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        this.close();
                        if (callback) {
                            callback(null); // null indicates close button clicked
                        }
                    });
                }

                // Handle Enter key (default button)
                const handleKeyPress = (e) => {
                    if (e.key === 'Enter') {
                        const defaultBtn = buttonElements[0];
                        if (defaultBtn) {
                            defaultBtn.click();
                        }
                    } else if (e.key === 'Escape') {
                        closeBtn.click();
                    }
                };
                document.addEventListener('keydown', handleKeyPress);
                dialog._keyHandler = handleKeyPress;

                this.modalOverlay.appendChild(dialog);
                document.body.appendChild(this.modalOverlay);
                this.activeDialog = dialog;

                // Focus first button
                if (buttonElements.length > 0) {
                    setTimeout(() => buttonElements[0].focus(), 50);
                }

                return dialog;
            }

            // Helper method: show info dialog
            info(message, title = 'Information', callback = null) {
                return this.show({
                    title,
                    message,
                    type: 'info',
                    buttons: ['OK'],
                    callback
                });
            }

            // Helper method: show warning dialog
            warning(message, title = 'Warning', callback = null) {
                return this.show({
                    title,
                    message,
                    type: 'warning',
                    buttons: ['OK'],
                    callback
                });
            }

            // Helper method: show error dialog
            error(message, title = 'Error', callback = null) {
                return this.show({
                    title,
                    message,
                    type: 'error',
                    buttons: ['OK'],
                    callback
                });
            }

            // Helper method: show confirmation dialog
            confirm(message, title = 'Confirm', callback = null) {
                return this.show({
                    title,
                    message,
                    type: 'question',
                    buttons: ['Yes', 'No'],
                    callback
                });
            }

            // Helper method: show yes/no/cancel dialog
            yesNoCancel(message, title = 'Confirm', callback = null) {
                return this.show({
                    title,
                    message,
                    type: 'question',
                    buttons: ['Yes', 'No', 'Cancel'],
                    callback
                });
            }

            close() {
                if (this.activeDialog && this.activeDialog._keyHandler) {
                    document.removeEventListener('keydown', this.activeDialog._keyHandler);
                }
                if (this.modalOverlay) {
                    this.modalOverlay.remove();
                    this.modalOverlay = null;
                }
                this.activeDialog = null;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Initialize systems
        let screenSaverManager;
        let toastManager;
        let dialogManager;

        window.addEventListener('load', () => {
            screenSaverManager = new ScreenSaverManager();
            toastManager = new ToastManager();
            dialogManager = new DialogManager();
            window.screenSaverManager = screenSaverManager;
            window.toastManager = toastManager;
            window.dialogManager = dialogManager;
            console.log('Screen saver system initialized');
        });
        // ========================================
        // CLIPPY ASSISTANT - AI-Driven Emotion-Based System
        // ========================================

        // Emotion System for Clippy
        class ClippyEmotionSystem {
            constructor() {
                this.currentMood = 'neutral';
                this.moodColors = {
                    helpful: '#0078D7',    // Blue - helpful mode
                    excited: '#10893E',    // Green - excited/happy
                    curious: '#8E44AD',    // Purple - asking questions
                    thinking: '#F7A400',   // Gold - processing
                    calm: '#5BC0DE',       // Sky blue - peaceful
                    neutral: '#0078D7',    // Default blue
                    friendly: '#3498DB',   // Light blue - welcoming
                    proud: '#E67E22'       // Orange - achievements
                };
            }

            analyzeSentiment(text, context = {}) {
                const lowerText = text.toLowerCase();

                // Context-based mood detection
                if (context.achievement) return 'proud';
                if (context.greeting) return 'friendly';

                // Excited keywords
                if (/(great|awesome|amazing|wonderful|excellent|perfect|love|fantastic)/i.test(lowerText)) {
                    return 'excited';
                }

                // Curious keywords (questions)
                if (/(how|why|what|when|where|help|can you|should i)/i.test(lowerText)) {
                    return 'curious';
                }

                // Thinking keywords
                if (/(let me|thinking|processing|calculating|analyzing)/i.test(lowerText)) {
                    return 'thinking';
                }

                // Calm/helpful keywords
                if (/(tip|advice|suggest|recommend|try|consider)/i.test(lowerText)) {
                    return 'helpful';
                }

                return 'neutral';
            }

            updateMood(mood) {
                if (this.currentMood === mood) return;
                this.currentMood = mood;
                return this.moodColors[mood] || this.moodColors.neutral;
            }

            getMoodColor() {
                return this.moodColors[this.currentMood] || this.moodColors.neutral;
            }
        }

        // AI Manager for Clippy
        class ClippyAIManager {
            constructor() {
                // Load from localStorage with default fallback
                this.apiEndpoint = SafeStorage.getItem('clippy_api_endpoint') ||
                                   'https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function';
                this.apiKey = SafeStorage.getItem('clippy_api_key') || '';
                this.conversationHistory = [];
                this.emotionSystem = null;
                this.aiEnabled = SafeStorage.getItem('clippy_ai_enabled') !== 'false'; // Default true
                this.maxHistoryLength = 10; // Keep last 10 interactions

                // Debug logging
            }

            hasAPIKey() {
                return this.apiKey && this.apiKey.trim().length > 0;
            }

            setAPIKey(key) {
                this.apiKey = key;
                SafeStorage.setItem('clippy_api_key', key);
            }

            setAPIEndpoint(endpoint) {
                this.apiEndpoint = endpoint;
                SafeStorage.setItem('clippy_api_endpoint', endpoint);
            }

            setAIEnabled(enabled) {
                this.aiEnabled = enabled;
                SafeStorage.setItem('clippy_ai_enabled', enabled ? 'true' : 'false');
            }

            // Text-to-Speech functionality
            speak(text, options = {}) {
                // Check if speech synthesis is available
                if (!('speechSynthesis' in window)) {
                    console.warn('Speech synthesis not supported in this browser');
                    return;
                }

                // Check if voice is enabled
                const voiceEnabled = SafeStorage.getItem('clippy_voice_enabled') !== 'false'; // Default true
                if (!voiceEnabled) {
                    return;
                }

                // Cancel any ongoing speech
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);

                // Configure voice settings for robotic/synthetic sound
                utterance.rate = options.rate || 1.1; // Slightly faster for robotic feel
                utterance.pitch = options.pitch || 1.2; // Higher pitch for assistant voice
                utterance.volume = options.volume || 0.8;

                // Try to find a robotic-sounding voice
                const voices = window.speechSynthesis.getVoices();
                const preferredVoices = [
                    'Microsoft David Desktop',
                    'Microsoft Zira Desktop',
                    'Google UK English Male',
                    'Google US English',
                    'Alex',
                    'Fred'
                ];

                // Find a suitable voice
                let selectedVoice = null;
                for (const voiceName of preferredVoices) {
                    selectedVoice = voices.find(v => v.name.includes(voiceName));
                    if (selectedVoice) break;
                }

                // Fallback to first available voice
                if (!selectedVoice && voices.length > 0) {
                    selectedVoice = voices[0];
                }

                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }

                // Event handlers
                utterance.onerror = (event) => {
                    console.error('Speech error:', event.error);
                };

                // Speak the text
                window.speechSynthesis.speak(utterance);
            }

            stopSpeaking() {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                }
            }

            toggleVoice() {
                const currentState = SafeStorage.getItem('clippy_voice_enabled') !== 'false';
                const newState = !currentState;
                SafeStorage.setItem('clippy_voice_enabled', newState ? 'true' : 'false');
                return newState;
            }

            isVoiceEnabled() {
                return SafeStorage.getItem('clippy_voice_enabled') !== 'false'; // Default true
            }

            buildContextPrompt(context) {
                const { program, action, pattern, windowCount } = context;

                return `You are Clippit (Clippy), the friendly Microsoft Office Assistant from Windows 95.

CHARACTER TRAITS:
- Friendly, helpful, and enthusiastic
- Concise (1-2 sentences max)
- Use occasional emojis but not excessively
- Classic '90s helpfulness with modern awareness

CURRENT CONTEXT:
- Active Program: ${program || 'Desktop'}
- User Action: ${action || 'idle'}
- Activity Pattern: ${pattern || 'exploring'}
- Open Windows: ${windowCount || 0}

TASK:
Provide a brief, contextually relevant tip or comment. Be genuinely helpful, not annoying. Match the tone to the context (encouraging for games, technical for tools, creative for Paint/Notepad).`;
            }

            async getClippyResponse(context) {

                if (!this.hasAPIKey() || !this.aiEnabled) {
                    console.warn('Clippy AI not available - missing key or disabled');
                    return null; // Fall back to offline mode
                }

                const systemPrompt = this.buildContextPrompt(context);

                // Determine the actual message to send based on context
                let userMessage;
                if (context.userMessage) {
                    // Chat conversation - build message with context
                    userMessage = context.userMessage;

                    // Add conversation history if available
                    if (context.conversationHistory && context.conversationHistory.length > 0) {
                        const recentHistory = context.conversationHistory.slice(-5); // Last 5 messages
                        const historyText = recentHistory.map(msg =>
                            `${msg.sender === 'user' ? 'User' : 'Clippy'} (${msg.timestamp}): ${msg.message}`
                        ).join('\n');

                        userMessage = `[CONVERSATION HISTORY]\n${historyText}\n\n[CURRENT MESSAGE]\n${userMessage}`;
                    }

                    // Add selected message context if any
                    if (context.selectedContext && context.selectedContext.length > 0) {
                        const selectedText = context.selectedContext.map(msg =>
                            `${msg.sender === 'user' ? 'User' : 'Clippy'} (${msg.timestamp}): ${msg.content}`
                        ).join('\n');

                        userMessage = `[REFERENCED MESSAGES]\n${selectedText}\n\n${userMessage}`;
                    }
                } else {
                    // Passive tip - use program context
                    userMessage = `User just opened ${context.program}. Provide a helpful tip or comment.`;
                }


                try {
                    const response = await fetch(this.apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-functions-key': this.apiKey
                        },
                        body: JSON.stringify({
                            user_input: userMessage  // API expects 'user_input' field
                        })
                    });


                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Clippy AI request failed:', {
                            status: response.status,
                            statusText: response.statusText,
                            error: errorText
                        });

                        // Show error to user
                        if (window.toastManager) {
                            window.toastManager.show(`AI Error: ${response.status} - Check console for details`, 'error');
                        }
                        return null;
                    }

                    const data = await response.json();

                    // Check multiple possible response field names
                    const aiMessage = data.assistant_response || data.voice_response || data.response || data.message || data.text;
                    const voiceMessage = data.voice_response || aiMessage; // Prefer voice_response for TTS


                    if (aiMessage) {
                        // Update conversation history
                        this.conversationHistory.push({
                            context: context,
                            response: aiMessage,
                            timestamp: Date.now()
                        });

                        // Limit history size
                        if (this.conversationHistory.length > this.maxHistoryLength) {
                            this.conversationHistory.shift();
                        }

                        // Analyze sentiment and update mood
                        if (this.emotionSystem) {
                            const mood = this.emotionSystem.analyzeSentiment(aiMessage, context);
                            this.emotionSystem.updateMood(mood);
                        }

                        return {
                            message: aiMessage,
                            voiceMessage: voiceMessage, // Include voice version for TTS
                            mood: this.emotionSystem?.currentMood || 'neutral',
                            source: 'ai'
                        };
                    }
                } catch (error) {
                    console.error('Clippy AI error:', error);
                    console.error('   Error details:', {
                        name: error.name,
                        message: error.message,
                        stack: error.stack
                    });

                    // Show error to user
                    if (window.toastManager) {
                        window.toastManager.show(`AI Connection Error: ${error.message}`, 'error');
                    }
                    return null;
                }

                return null;
            }
        }

        // Main Clippy Controller
        class MorphingClippy {
            constructor() {
                // Current personality mode
                this.currentMode = 'helper';

                // User activity state tracking
                this.state = {
                    user: {
                        activity: 'idle',
                        focus: null,
                        mousePos: { x: 0, y: 0 },
                        lastAction: Date.now(),
                        openWindows: [],
                        keystrokes: 0,
                        clicks: 0,
                        pattern: 'exploring' // exploring, gaming, working, browsing
                    },
                    system: {
                        uptime: 0,
                        windowCount: 0,
                        lastWindowOpened: null
                    }
                };

                this.messageQueue = [];
                this.stateUpdateInterval = null;
                this.achievementsUnlocked = {};
                this.element = null;
                this.isActive = false;
                this.autoHideTimeout = null;
                this.lastTipTime = 0;
                this.tipCooldown = 30000; // 30 seconds between tips

                // Initialize AI and Emotion systems
                this.emotionSystem = new ClippyEmotionSystem();
                this.aiManager = new ClippyAIManager();
                this.aiManager.emotionSystem = this.emotionSystem;

                // Define personality modes
                this.modes = this.defineModes();

                // Initialize
                this.init();
            }

            defineModes() {
                return {
                    helper: {
                        name: 'Helper',
                        icon: '📎',
                        label: 'HELPER',
                        description: 'Friendly assistance mode',
                        traits: { helpfulness: 0.95, humor: 0.3, technical: 0.5, patience: 0.95 }
                    },
                    expert: {
                        name: 'Expert',
                        icon: '🤓',
                        label: 'EXPERT',
                        description: 'Technical tips and advanced features',
                        traits: { helpfulness: 0.7, humor: 0.2, technical: 0.95, precision: 0.95 }
                    },
                    entertainer: {
                        name: 'Entertainer',
                        icon: '🎭',
                        label: 'FUN',
                        description: 'Jokes and entertainment',
                        traits: { helpfulness: 0.6, humor: 0.95, spontaneity: 0.9 }
                    },
                    coach: {
                        name: 'Coach',
                        icon: '🏆',
                        label: 'COACH',
                        description: 'Motivation and encouragement',
                        traits: { helpfulness: 0.75, humor: 0.6, motivation: 0.95, enthusiasm: 0.9 }
                    },
                    organizer: {
                        name: 'Organizer',
                        icon: '📋',
                        label: 'ORGANIZER',
                        description: 'Productivity and file management',
                        traits: { helpfulness: 0.85, humor: 0.4, organization: 0.95, productivity: 0.9 }
                    }
                };
            }

            init() {
                // Create single Clippy DOM element
                this.createElement();

                // Start state monitoring
                this.startStateTracking();

                // Show initial greeting after user activity
                setTimeout(() => {
                    if (this.state.user.clicks > 2 || this.state.user.keystrokes > 3) {
                        this.show("👋 Hi! I'm Clippit, your Windows 95 assistant! Click me anytime for help!", null, { greeting: true });
                    }
                }, 15000);

                const aiStatus = this.aiManager.hasAPIKey() && this.aiManager.aiEnabled ? 'AI-powered' : 'offline mode';
                console.log(`📎 Clippy assistant initialized with 5 personality modes (${aiStatus})`);
            }

            createElement() {
                const container = document.createElement('div');
                container.className = 'clippy-container';
                container.innerHTML = `
                    <div class="clippy-bubble">
                        <div class="bubble-arrow"></div>
                        <div class="bubble-close">×</div>
                        <div class="clippy-message"></div>
                    </div>
                    <div class="clippy-character mode-${this.currentMode}">
                        <div class="clippy-icon">${this.modes[this.currentMode].icon}</div>
                        <div class="clippy-mode-indicator">${this.modes[this.currentMode].label}</div>
                    </div>
                `;

                document.getElementById('clippy-container').appendChild(container);
                this.element = container;

                // Attach event listeners
                this.element.querySelector('.clippy-character').addEventListener('click', () => {
                    // Open chat window when clicking Clippy
                    if (window.emulator && window.emulator.openClippyChat) {
                        window.emulator.openClippyChat();
                    }
                });
                this.element.querySelector('.bubble-close').addEventListener('click', () => this.hide());
            }

            morphTo(mode) {
                if (!this.modes[mode] || mode === this.currentMode) return;

                const character = this.element.querySelector('.clippy-character');
                const icon = this.element.querySelector('.clippy-icon');
                const indicator = this.element.querySelector('.clippy-mode-indicator');

                // Add morphing animation
                character.classList.add('morphing');

                // Remove old mode class
                character.classList.remove(`mode-${this.currentMode}`);

                // Update mode
                this.currentMode = mode;

                // Add new mode class
                character.classList.add(`mode-${this.currentMode}`);

                // Update icon and indicator
                icon.textContent = this.modes[mode].icon;
                indicator.textContent = this.modes[mode].label;

                // Remove morphing animation after completion
                setTimeout(() => {
                    character.classList.remove('morphing');
                }, 500);

            }

            updateEmotionColor(mood = null, context = {}) {
                const character = this.element.querySelector('.clippy-character');

                // Analyze sentiment if mood not provided
                if (!mood && context.message) {
                    mood = this.emotionSystem.analyzeSentiment(context.message, context);
                }

                const color = this.emotionSystem.updateMood(mood || 'neutral');

                // Apply smooth color transition to border
                if (color) {
                    character.style.transition = 'border-color 2s ease, box-shadow 2s ease';
                    character.style.borderColor = color;
                    character.style.boxShadow = `0 0 15px ${color}40, 2px 2px 6px rgba(0,0,0,0.2)`;
                }
            }

            show(message, mode = null, context = {}) {
                // Morph to new mode if specified
                if (mode && mode !== this.currentMode) {
                    this.morphTo(mode);
                }

                const bubble = this.element.querySelector('.clippy-bubble');
                const msgEl = this.element.querySelector('.clippy-message');

                msgEl.textContent = message;
                bubble.classList.add('active');
                this.isActive = true;

                // Update emotion-based color
                this.updateEmotionColor(null, { message, ...context });

                // Clear existing timeout
                if (this.autoHideTimeout) {
                    clearTimeout(this.autoHideTimeout);
                }

                // Auto-hide after 10 seconds
                this.autoHideTimeout = setTimeout(() => {
                    this.hide();
                }, 10000);
            }

            hide() {
                const bubble = this.element.querySelector('.clippy-bubble');
                bubble.classList.remove('active');
                this.isActive = false;

                if (this.autoHideTimeout) {
                    clearTimeout(this.autoHideTimeout);
                    this.autoHideTimeout = null;
                }
            }

            toggle() {
                if (this.isActive) {
                    this.hide();
                } else {
                    const tip = this.generateRandomTip();
                    this.show(tip);
                }
            }

            startStateTracking() {
                // WAVE 5 ENHANCEMENT: Throttled mouse tracking for better performance
                const throttledMouseTrack = throttle((e) => {
                    this.state.user.mousePos = { x: e.clientX, y: e.clientY };
                }, 100); // Update position every 100ms (10 times per second)

                document.addEventListener('mousemove', throttledMouseTrack);

                // Track clicks
                document.addEventListener('click', () => {
                    this.state.user.clicks++;
                    this.state.user.lastAction = Date.now();
                    this.updateUserPattern();
                });

                // Track keypresses
                document.addEventListener('keypress', () => {
                    this.state.user.keystrokes++;
                    this.state.user.lastAction = Date.now();
                    this.updateUserPattern();
                });

                // Track window changes
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('window')) {
                                const title = node.querySelector('.window-title')?.textContent || 'Unknown';
                                this.state.system.windowCount++;
                                this.state.system.lastWindowOpened = title;
                                this.state.user.openWindows.push(title);
                                this.reactToWindowOpen(title);
                            }
                        });
                        mutation.removedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('window')) {
                                this.state.system.windowCount--;
                            }
                        });
                    });
                });

                observer.observe(document.body, { childList: true, subtree: true });

                // Update state every 500ms
                this.stateUpdateInterval = setInterval(() => {
                    this.updateState();
                }, 500);
            }

            updateState() {
                const timeSinceAction = Date.now() - this.state.user.lastAction;

                if (timeSinceAction > 30000) {
                    this.state.user.activity = 'idle';
                } else if (timeSinceAction < 2000) {
                    this.state.user.activity = 'active';
                } else {
                    this.state.user.activity = 'moderate';
                }

                this.state.system.uptime = Math.floor((Date.now() - window.clippy.startTime) / 1000);
            }

            updateUserPattern() {
                const { clicks, keystrokes, openWindows } = this.state.user;

                // Detect patterns based on behavior
                if (openWindows.some(w => w.includes('FreeCell') || w.includes('Minesweeper') || w.includes('Solitaire'))) {
                    this.state.user.pattern = 'gaming';
                } else if (openWindows.some(w => w.includes('Terminal') || w.includes('Notepad'))) {
                    this.state.user.pattern = 'working';
                } else if (openWindows.some(w => w.includes('Internet Explorer'))) {
                    this.state.user.pattern = 'browsing';
                } else {
                    this.state.user.pattern = 'exploring';
                }
            }

            async reactToWindowOpen(title) {
                // React to different window types with appropriate mode
                // 40% chance to show to avoid being annoying
                if (Math.random() > 0.4) return;

                // Respect cooldown
                if (Date.now() - this.lastTipTime < this.tipCooldown) return;

                // Build context for AI
                const context = {
                    program: title,
                    action: 'opened',
                    pattern: this.state.user.pattern,
                    windowCount: this.state.system.windowCount
                };

                let mode = 'helper';
                let message = '';

                // Try AI-generated response first
                if (this.aiManager.hasAPIKey() && this.aiManager.aiEnabled) {
                    const aiResponse = await this.aiManager.getClippyResponse(context);
                    if (aiResponse) {
                        setTimeout(() => {
                            this.show(aiResponse.message, this.getModeForProgram(title));
                            this.lastTipTime = Date.now();
                        }, 2000);
                        return;
                    }
                }

                // Fall back to offline predefined messages
                message = this.getOfflineTipForProgram(title);
                mode = this.getModeForProgram(title);

                if (message) {
                    setTimeout(() => {
                        this.show(message, mode);
                        this.lastTipTime = Date.now();
                    }, 2000);
                }
            }

            getModeForProgram(title) {
                // Games - Coach or Entertainer mode
                if (title.includes('FreeCell') || title.includes('Solitaire') || title.includes('Minesweeper')) {
                    return Math.random() > 0.5 ? 'coach' : 'entertainer';
                }
                // Technical programs - Expert mode
                else if (title.includes('Terminal') || title.includes('Calculator')) {
                    return 'expert';
                }
                // Creative programs - Helper or Entertainer
                else if (title.includes('Paint') || title.includes('Notepad')) {
                    return Math.random() > 0.5 ? 'helper' : 'entertainer';
                }
                // Control Panel - Organizer mode
                else if (title.includes('Control Panel') || title.includes('Settings')) {
                    return 'organizer';
                }
                // Internet Explorer - Expert or Organizer
                else if (title.includes('Internet Explorer') || title.includes('Browser')) {
                    return Math.random() > 0.5 ? 'expert' : 'organizer';
                }
                // LocalFirst Tools - Organizer
                else if (title.includes('LocalFirst') || title.includes('Tools')) {
                    return 'organizer';
                }
                return 'helper';
            }

            getOfflineTipForProgram(title) {
                // Games
                if (title.includes('FreeCell') || title.includes('Solitaire') || title.includes('Minesweeper')) {
                    const gameMode = this.getModeForProgram(title);
                    if (gameMode === 'coach') {
                        return this.generateCoachGameMessage(title);
                    } else {
                        return this.generateEntertainerGameMessage(title);
                    }
                }
                // Technical programs
                else if (title.includes('Terminal') || title.includes('Calculator')) {
                    return this.generateExpertMessage(title);
                }
                // Creative programs
                else if (title.includes('Paint') || title.includes('Notepad')) {
                    if (Math.random() > 0.5) {
                        return title.includes('Paint') ?
                            "🎨 Working on some art? Paint has many tools in the toolbar!" :
                            "📝 It looks like you're writing something. Let me know if you need help!";
                    } else {
                        return title.includes('Paint') ?
                            "🎨 Ooh, art time! Paint me like one of your French... windows? 😄" :
                            "✍️ Writing the next great novel? Or just a grocery list? Either way, I'm here! 😊";
                    }
                }
                // Control Panel
                else if (title.includes('Control Panel') || title.includes('Settings')) {
                    return "📊 Control Panel opened! Let's optimize your system settings for maximum productivity!";
                }
                // Internet Explorer
                else if (title.includes('Internet Explorer') || title.includes('Browser')) {
                    return Math.random() > 0.5 ?
                        "🌐 Browsing mode activated. Pro tip: You can bookmark pages for faster access!" :
                        "🔍 Internet Explorer ready! Stay organized - bookmark your favorite sites!";
                }
                // LocalFirst Tools
                else if (title.includes('LocalFirst') || title.includes('Tools')) {
                    return "🛠️ Excellent choice! LocalFirst tools help you stay productive and organized!";
                }
                return null;
            }

            generateCoachGameMessage(title) {
                const messages = {
                    'FreeCell': [
                        "💪 FreeCell time! You're going to crush this! Strategic thinking is your superpower!",
                        "🏆 Ready to dominate FreeCell? Remember: plan ahead and victory is yours!",
                        "🔥 FreeCell challenge accepted! I believe in you! Keep those free cells clear!",
                        "⭐ Game on! FreeCell requires skill and you've got it! Show me what you got!"
                    ],
                    'Minesweeper': [
                        "💣 Minesweeper! Time to show those mines who's boss! You've got the logic!",
                        "🏅 Minesweeper challenge! Stay focused, use those numbers, you're doing AMAZING!",
                        "🎯 Mine hunting time! Every correct flag is a step toward victory! GO GO GO!",
                        "💪 Minesweeper master in action! Trust your instincts and flag those mines!"
                    ],
                    'Solitaire': [
                        "🃏 Solitaire! A true classic! Build those foundations and claim victory!",
                        "🏆 Patience and strategy! You're going to ace this game! Literally! 😄",
                        "⭐ Solitaire time! Every card in the right place is progress! Keep going!",
                        "💪 Card master activated! You've got the patience and skill to win this!"
                    ]
                };

                for (let key in messages) {
                    if (title.includes(key)) {
                        return messages[key][Math.floor(Math.random() * messages[key].length)];
                    }
                }
                return "🎮 Game time! You're going to rock this! I'm cheering for you! 🎉";
            }

            generateEntertainerGameMessage(title) {
                const messages = {
                    'FreeCell': [
                        "🎴 FreeCell! Or as I call it... 'Cell Phone' but with cards! 📱😂",
                        "🎪 FreeCell time! Warning: May cause extreme satisfaction upon winning! 🏆✨",
                        "🎉 FreeCell! Fun fact: It's called 'Free' but your time is the price! 😄⏰"
                    ],
                    'Minesweeper': [
                        "💣 Minesweeper! It's like a treasure hunt... where the treasure is NOT exploding! 💥😅",
                        "🎪 Minesweeper! Remember: when life gives you mines, flag them! 🚩😂",
                        "🎮 Minesweeper! The most stressful clicking game since... well, ever! Good luck! ✨"
                    ],
                    'Solitaire': [
                        "🃏 Solitaire! Perfect for when you want to feel productive while procrastinating! 😄",
                        "🎪 Solitaire! It's you vs. the deck! My money's on you! 💰😊",
                        "✨ Solitaire! The original 'one player mode' before it was cool! 🎮"
                    ]
                };

                for (let key in messages) {
                    if (title.includes(key)) {
                        return messages[key][Math.floor(Math.random() * messages[key].length)];
                    }
                }
                return "🎮 Game time! Let's have some fun! Remember: winning is fun, but so is losing... wait, no it's not! 😂";
            }

            generateExpertMessage(title) {
                if (title.includes('Terminal')) {
                    const messages = [
                        "⚡ Terminal accessed. Pro tip: Use 'ls -la' for detailed file listings with permissions.",
                        "🔧 Terminal mode. Advanced users know: Tab completion saves significant time.",
                        "💡 Terminal ready. Efficiency tip: Pipe commands together for powerful workflows.",
                        "⌨️ Terminal initialized. Power user trick: Use 'history' to recall previous commands.",
                        "📊 Terminal active. Performance note: Batch operations are faster than repeated single commands."
                    ];
                    return messages[Math.floor(Math.random() * messages.length)];
                } else if (title.includes('Calculator')) {
                    return "🔢 Calculator opened. Pro tip: Use keyboard for faster input. Number pad is your friend!";
                }
                return "💻 Advanced program detected. Optimize your workflow with keyboard shortcuts!";
            }

            generateRandomTip() {
                const tipsByMode = {
                    helper: [
                        "Need help? Click the Start button to see all programs!",
                        "Right-click the desktop to see more options.",
                        "You can drag windows by their title bars to move them.",
                        "Double-click desktop icons to open programs quickly!",
                        "The Start menu has all your programs organized by category.",
                        "Need to close a window? Click the X button in the top-right corner.",
                        "You can minimize windows to the taskbar to reduce clutter.",
                        "Stuck? Try right-clicking - it often shows helpful options!",
                        "The taskbar at the bottom shows all open windows.",
                        "Click and drag window edges to resize them!"
                    ],
                    entertainer: [
                        "🎮 Try the games in the Start menu! They're nostalgically awesome!",
                        "😄 Fun fact: Windows 95 was released on August 24, 1995!",
                        "🎪 Want to hear a joke? Why did the computer go to therapy? Too many bad memories! 😂",
                        "✨ Easter egg time! Try clicking me multiple times... just kidding, I don't bite!",
                        "🎉 Did you know? The Windows 95 startup sound was composed by Brian Eno!",
                        "🎭 Pro tip: Having fun is the most important optimization! 😊",
                        "🎨 Paint can make some seriously awesome pixel art! Get creative!",
                        "🎪 Life is too short for boring computers! Explore and have fun!",
                        "😂 Why was the computer cold? It left its Windows open! ...I'll see myself out.",
                        "✨ Remember: You're not just using Windows 95, you're experiencing history!"
                    ],
                    expert: [
                        "⚡ Pro tip: Right-click + drag for advanced window manipulation.",
                        "⌨️ Keyboard shortcut: Alt+F4 closes the active window instantly.",
                        "🔧 Terminal power: Chain commands with && for sequential execution.",
                        "💡 Efficiency: Use Tab to autocomplete in Terminal - saves 73% typing time.",
                        "📊 Advanced: Monitor system resources in the taskbar status area.",
                        "⚡ Speed tip: Keyboard navigation is 3x faster than mouse for power users.",
                        "🔧 Pro technique: Use Ctrl+C to copy, Ctrl+V to paste in most programs.",
                        "💻 Terminal ninja: Use 'clear' command to clean up the screen quickly.",
                        "⌨️ Advanced: Arrow keys navigate Terminal command history efficiently.",
                        "📊 Performance: Close unused windows to optimize memory usage."
                    ],
                    coach: [
                        "💪 You're doing great! Keep exploring and learning!",
                        "🏆 Every program you open is progress! You're leveling up!",
                        "🔥 Challenge yourself: Try opening 3 programs at once! You can do it!",
                        "⭐ Achievement idea: Win a game of Minesweeper! I believe in you!",
                        "🎯 Goal setting: Try to learn one new program today! You got this!",
                        "💪 Push yourself: Experiment with the Control Panel settings!",
                        "🏅 You're becoming a Windows 95 expert! Keep it up!",
                        "🔥 Next level: Master the keyboard shortcuts! You're ready!",
                        "⭐ Personal best incoming: Try to beat your game scores!",
                        "🎯 Daily challenge: Open every program at least once! Adventure awaits!"
                    ],
                    organizer: [
                        "📁 Organization tip: Group similar programs together in your workflow.",
                        "⏰ Time management: Close programs you're not using to stay focused.",
                        "📊 Productivity boost: Learn one keyboard shortcut per day for efficiency.",
                        "🗂️ File management: Use Notepad to keep track of your tasks and notes.",
                        "✅ Task prioritization: Start with important programs, then explore others.",
                        "📋 Workflow optimization: Arrange windows side-by-side for multitasking.",
                        "⏰ Time blocking: Dedicate specific time to games vs. work programs.",
                        "📊 Metrics matter: Track how many programs you've mastered!",
                        "🗂️ Best practice: Save your work frequently in Notepad and Paint.",
                        "✅ Daily routine: Start with Control Panel, end with something fun!"
                    ]
                };

                const tips = tipsByMode[this.currentMode] || tipsByMode.helper;
                return tips[Math.floor(Math.random() * tips.length)];
            }

            detectStruggle() {
                // If user has been clicking excessively, they might be struggling
                if (this.state.user.clicks > 80) {
                    this.show("Need help? Click me if you'd like assistance!", 'helper');
                    this.state.user.clicks = 0; // Reset counter
                }
            }

            checkAchievements() {
                const achievements = {
                    explorer: {
                        check: () => this.state.system.windowCount >= 5,
                        message: "🏆 Explorer! You've opened 5 programs!",
                        mode: 'coach'
                    },
                    multitasker: {
                        check: () => this.state.user.openWindows.length >= 3,
                        message: "🎯 Multitasker! Managing multiple windows like a pro!",
                        mode: 'coach'
                    },
                    gamer: {
                        check: () => this.state.user.pattern === 'gaming',
                        message: "🎮 Gamer! Time to have some fun!",
                        mode: 'coach'
                    },
                    powerUser: {
                        check: () => this.state.user.keystrokes > 100,
                        message: "⚡ Power User! Those keyboard skills are impressive!",
                        mode: 'expert'
                    }
                };

                for (let [key, achievement] of Object.entries(achievements)) {
                    if (achievement.check() && !this.achievementsUnlocked[key]) {
                        this.achievementsUnlocked[key] = true;
                        this.show(achievement.message, achievement.mode, { achievement: true });
                        break; // Only one achievement at a time
                    }
                }
            }
        }

        // ========================================
        // CLIPPY ASSISTANT (Initialized in DOMContentLoaded above)
        // ========================================
        // Clippy is now initialized with the ClippyAssistant class
        // which uses the AI briefing as its memory layer.
        // See initialization at line ~13287-13289
        // Clippy loads the briefing context and uses it to provide
        // intelligent, contextual guidance throughout the user's session.


        // ========================================
        // EASTER EGG SYSTEM
        // ========================================

        class EasterEggManager {
            constructor() {
                this.konami = [];
                this.konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
                this.clickSequence = [];
                this.secretClicks = 0;
                this.init();
            }

            init() {
                // Konami code listener
                document.addEventListener('keydown', (e) => {
                    this.konami.push(e.key);
                    if (this.konami.length > this.konamiCode.length) {
                        this.konami.shift();
                    }
                    if (this.checkKonami()) {
                        this.activateKonamiCode();
                    }
                });

                // Secret logo click counter
                const logos = document.querySelectorAll('.logo');
                logos.forEach(logo => {
                    logo.addEventListener('click', () => {
                        this.secretClicks++;
                        if (this.secretClicks === 10) {
                            this.activateLogoEasterEgg();
                            this.secretClicks = 0;
                        }
                    });
                });

                // Ctrl+Alt+Del easter egg
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.altKey && e.key === 'Delete') {
                        e.preventDefault();
                        this.showBlueScreen();
                    }
                });

                // Type "win95" anywhere easter egg
                let typeBuffer = '';
                document.addEventListener('keypress', (e) => {
                    typeBuffer += e.key;
                    if (typeBuffer.length > 5) typeBuffer = typeBuffer.slice(-5);
                    if (typeBuffer === 'win95') {
                        this.showWin95Facts();
                        typeBuffer = '';
                    }
                });

                // Triple-click taskbar easter egg
                let taskbarClicks = 0;
                const taskbar = document.getElementById('taskbar');
                if (taskbar) {
                    taskbar.addEventListener('click', () => {
                        taskbarClicks++;
                        setTimeout(() => { taskbarClicks = 0; }, 1000);
                        if (taskbarClicks === 3) {
                            this.showTaskbarEasterEgg();
                            taskbarClicks = 0;
                        }
                    });
                }

                console.log('Easter egg system activated! Try discovering hidden features...');
            }

            checkKonami() {
                return this.konami.join(',') === this.konamiCode.join(',');
            }

            activateKonamiCode() {
                if (window.toastManager) {
                    window.toastManager.show(
                        '🎮 Konami Code Activated!',
                        'You unlocked God Mode! All Clippies will now share their wisdom simultaneously! 🚀'
                    );
                }

                // Trigger all Clippies at once
                if (window.clippy) {
                    setTimeout(() => {
                        window.clippy.show("🎮 Konami Code detected! I'm here to help!", 'helper');
                    }, 500);
                    setTimeout(() => {
                        window.clippy.show("😄 Party time! Konami Code = Instant fun!", 'entertainer');
                    }, 1000);
                    setTimeout(() => {
                        window.clippy.show("⚡ Elite gamer detected. Maximum efficiency unlocked!", 'expert');
                    }, 1500);
                    setTimeout(() => {
                        window.clippy.show("💪 LEGENDARY! You're a true gaming master!", 'coach');
                    }, 2000);
                    setTimeout(() => {
                        window.clippy.show("📊 Achievement: Konami Code Master! Productivity +1000%!", 'organizer');
                    }, 2500);
                }

                // Activate special screen effect
                this.konamiScreenEffect();
            }

            konamiScreenEffect() {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: linear-gradient(45deg, red, yellow, green, blue, purple);
                    opacity: 0.3;
                    z-index: 9998;
                    pointer-events: none;
                    animation: rainbow 2s infinite;
                `;

                const style = document.createElement('style');
                style.textContent = `
                    @keyframes rainbow {
                        0% { filter: hue-rotate(0deg); }
                        100% { filter: hue-rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(overlay);

                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                }, 5000);
            }

            activateLogoEasterEgg() {
                if (window.toastManager) {
                    window.toastManager.show(
                        '🎨 Logo Master!',
                        'You clicked the Windows logo 10 times! The 90s called - they want their colors back! 🌈'
                    );
                }

                // Crazy spinning logos
                const logos = document.querySelectorAll('.logo');
                logos.forEach(logo => {
                    logo.style.animation = 'spin 1s linear 5';
                });
            }

            showBlueScreen() {
                const bsod = document.createElement('div');
                bsod.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: #0000aa;
                    color: white;
                    font-family: 'Courier New', monospace;
                    padding: 40px;
                    z-index: 999999;
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                `;

                bsod.innerHTML = `
                    <div style="font-size: 20px; text-align: center;">
                        Windows<br>
                        A fatal exception 0E has occurred at 0028:C0011E36 in VXD VMM(01) +<br>
                        00010E36. The current application will be terminated.
                    </div>
                    <div style="margin-top: 20px;">
                        * Press any key to terminate the current application.<br>
                        * Press CTRL+ALT+DEL again to restart your computer. You will<br>
                          lose any unsaved information in all applications.
                    </div>
                    <div style="margin-top: 20px; text-align: center;">
                        Press any key to continue _
                    </div>
                    <div style="margin-top: 40px; text-align: center; font-size: 12px; opacity: 0.7;">
                        (Just kidding! This is an Easter egg. Click anywhere to close.)
                    </div>
                `;

                document.body.appendChild(bsod);

                const close = () => {
                    bsod.remove();
                    document.removeEventListener('keydown', close);
                    bsod.removeEventListener('click', close);
                };

                document.addEventListener('keydown', close);
                bsod.addEventListener('click', close);

                if (window.toastManager) {
                    setTimeout(() => {
                        if (bsod.parentElement) {
                            window.toastManager.show(
                                '😨 BSOD Easter Egg',
                                "Don't panic! This is just for fun. Windows 95 users know this screen all too well!"
                            );
                        }
                    }, 2000);
                }
            }

            showWin95Facts() {
                const facts = [
                    'Windows 95 was released on August 24, 1995, with a massive $300 million marketing campaign!',
                    'The Windows 95 startup sound was composed by Brian Eno in just 3.25 seconds!',
                    'Windows 95 could run on just 4MB of RAM (imagine that today!).',
                    'The Rolling Stones "Start Me Up" was the theme song for Windows 95!',
                    'Windows 95 sold 7 million copies in the first 5 weeks!',
                    'Internet Explorer was not included in the original Windows 95 release.',
                    'Windows 95 introduced the Start button and taskbar - still used today!',
                    'The development codename for Windows 95 was "Chicago".',
                    'Windows 95 was the first Windows to include Plug and Play support.',
                    'Bill Gates and Jay Leno hosted the Windows 95 launch event!'
                ];

                const randomFact = facts[Math.floor(Math.random() * facts.length)];

                if (window.toastManager) {
                    window.toastManager.show(
                        '💡 Windows 95 Fun Fact',
                        randomFact,
                        8000
                    );
                }

                if (window.clippy) {
                    setTimeout(() => {
                        window.clippy.show(
                            '🎉 Fun fact unlocked! Type "win95" anytime for more nostalgic knowledge!',
                            'entertainer'
                        );
                    }, 500);
                }
            }

            showTaskbarEasterEgg() {
                if (window.toastManager) {
                    window.toastManager.show(
                        '🎯 Taskbar Master!',
                        'Triple-click discovery! The taskbar has been the heart of Windows since 1995. Keep clicking for productivity!'
                    );
                }

                // Taskbar wiggle animation
                const taskbar = document.getElementById('taskbar');
                if (taskbar) {
                    taskbar.style.animation = 'wiggle 0.5s ease-in-out 3';
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes wiggle {
                            0%, 100% { transform: translateX(0); }
                            25% { transform: translateX(-10px); }
                            75% { transform: translateX(10px); }
                        }
                    `;
                    document.head.appendChild(style);
                    setTimeout(() => {
                        if (taskbar) taskbar.style.animation = '';
                        style.remove();
                    }, 1500);
                }
            }

            // Hidden feature: Unlock advanced mode
            unlockAdvancedMode() {
                if (window.toastManager) {
                    window.toastManager.show(
                        '🔓 Advanced Mode Unlocked!',
                        'You have discovered advanced features! Check the console for developer tools.'
                    );
                }

                console.log(`
╔═══════════════════════════════════════════════════════════╗
║           WINDOWS 95 EMULATOR - ADVANCED MODE             ║
╠═══════════════════════════════════════════════════════════╣
║  Available global objects:                                ║
║  • emulator - Main emulator instance                      ║
║  • clippy - Morphing assistant system                     ║
║  • screenSaverManager - Screen saver controls             ║
║  • toastManager - Notification system                     ║
║                                                            ║
║  Hidden Commands:                                         ║
║  • emulator.showAllPrograms() - List all programs         ║
║  • clippy.morphTo('mode') - Change Clippy personality     ║
║  • screenSaverManager.activate() - Instant screensaver    ║
║  • toastManager.show('Title', 'Message') - Toast          ║
╚═══════════════════════════════════════════════════════════╝
                `);
            }
        }

        // Initialize Easter Egg system
        let easterEggManager;
        window.addEventListener('load', () => {
            setTimeout(() => {
                easterEggManager = new EasterEggManager();
                window.easterEggManager = easterEggManager;
                console.log('🥚 Easter eggs hidden throughout the system. Happy hunting!');
            }, 1500);
        });
    </script>
</body>
</html>
