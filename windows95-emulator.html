<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windows 95 Desktop Simulator - Interactive Edition</title>
    <meta name="description" content="Fully interactive Windows 95 desktop simulator with working programs, draggable windows, and authentic UI">
    <style>
        /* Windows 95 Color Palette - Authentic solid colors */
        :root {
            --desktop-teal: #008080;
            --button-face: #c0c0c0;
            --button-shadow: #808080;
            --button-dark-shadow: #000000;
            --button-highlight: #ffffff;
            --button-light: #dfdfdf;
            --active-title-bar: #000080;
            --inactive-title-bar: #808080;
            --window-background: #ffffff;
            --text-color: #000000;
            --menu-highlight: #000080;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'MS Sans Serif', 'Microsoft Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: var(--desktop-teal);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        .header {
            background: var(--active-title-bar);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            border-bottom: 2px solid var(--button-face);
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .logo {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            display: inline-block;
            position: relative;
            transform: perspective(10px) rotateY(-5deg);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Authentic Windows 95 3D button effect */
        .btn {
            padding: 3px 8px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset 2px 2px 0 var(--button-light),
                inset -1px -1px 0 var(--button-dark-shadow),
                inset -2px -2px 0 var(--button-shadow);
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            outline: none;
            position: relative;
            min-height: 22px;
        }

        /* Pressed button effect */
        .btn:active {
            box-shadow:
                inset -1px -1px 0 var(--button-highlight),
                inset -2px -2px 0 var(--button-light),
                inset 1px 1px 0 var(--button-dark-shadow),
                inset 2px 2px 0 var(--button-shadow);
            padding: 4px 7px 2px 9px;
        }

        /* Focus state for accessibility */
        .btn:focus-visible {
            outline: 1px dotted var(--text-color);
            outline-offset: -4px;
        }

        .btn:disabled {
            color: var(--button-shadow);
            text-shadow: 1px 1px 0 var(--button-highlight);
            cursor: default;
        }

        .btn.primary {
            background: var(--active-title-bar);
            color: white;
            font-weight: bold;
            border: 1px solid #000;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            overflow: auto;
        }

        .emulator-frame {
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-light),
                inset 2px 2px 0 var(--button-highlight),
                inset -1px -1px 0 var(--button-shadow),
                inset -2px -2px 0 var(--button-dark-shadow),
                0 0 30px rgba(0,0,0,0.5);
            padding: 3px;
            position: relative;
            max-width: 95vw;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
        }

        /* Fullscreen mode styling */
        .emulator-frame.fullscreen-mode {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }

        .emulator-frame.fullscreen-mode #screen_container {
            background: #008080; /* Match desktop teal background */
            align-items: stretch;
            justify-content: stretch;
        }

        .emulator-frame.fullscreen-mode #screen {
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
            object-fit: fill;
        }

        .emulator-titlebar {
            background: var(--active-title-bar);
            color: white;
            padding: 2px 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            font-weight: bold;
            user-select: none;
            height: 18px;
            cursor: default;
        }

        .emulator-titlebar.inactive {
            background: var(--inactive-title-bar);
        }

        .titlebar-buttons {
            display: flex;
            gap: 2px;
        }

        .titlebar-btn {
            width: 16px;
            height: 14px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset -1px -1px 0 var(--button-dark-shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 10px;
            font-weight: bold;
            color: var(--text-color);
        }

        .titlebar-btn:active {
            box-shadow:
                inset -1px -1px 0 var(--button-highlight),
                inset 1px 1px 0 var(--button-dark-shadow);
            padding-top: 1px;
            padding-left: 1px;
        }

        .titlebar-btn:hover {
            background: var(--button-light);
        }

        #screen_container {
            background: #000;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            flex: 1;
            min-height: 0;
        }

        #screen {
            /* Scale canvas to fit container while maintaining aspect ratio */
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            /* Width and height controlled by #screen selector for proper scaling */
        }

        .status-bar {
            background: var(--button-face);
            border-top: 1px solid var(--button-highlight);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-section {
            border-left: 1px solid var(--button-shadow);
            border-right: 1px solid var(--button-highlight);
            padding: 0 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-section:first-child {
            border-left: none;
            padding-left: 0;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--button-shadow);
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
            transition: all 0.1s ease;
        }

        .led.active {
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00, inset 0 0 2px rgba(255,255,255,0.5);
        }

        .led.hdd {
            background: #ff0000;
        }

        .led.hdd.active {
            background: #ff6600;
            box-shadow: 0 0 5px #ff6600, inset 0 0 2px rgba(255,255,255,0.5);
        }

        .setup-screen {
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-light),
                inset 2px 2px 0 var(--button-highlight),
                inset -1px -1px 0 var(--button-shadow),
                inset -2px -2px 0 var(--button-dark-shadow),
                0 0 20px rgba(0,0,0,0.5);
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .setup-screen h2 {
            background: var(--active-title-bar);
            color: white;
            padding: 4px 8px;
            margin: -20px -20px 15px -20px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 14px;
        }

        .setup-content {
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .setup-content p {
            margin: 8px 0;
            line-height: 1.4;
        }

        .setup-option {
            margin: 15px 0;
            padding: 10px;
            background: var(--window-background);
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
        }

        .setup-option h3 {
            margin-bottom: 8px;
            font-size: 12px;
            color: var(--active-title-bar);
        }

        .setup-option p {
            margin: 5px 0;
            line-height: 1.4;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-top: 10px;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }

        .file-input-label {
            display: inline-block;
            padding: 3px 8px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset 2px 2px 0 var(--button-light),
                inset -1px -1px 0 var(--button-dark-shadow),
                inset -2px -2px 0 var(--button-shadow);
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
        }

        input[type="text"],
        select {
            padding: 2px 4px;
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: var(--window-background);
        }

        input[type="text"]:focus,
        select:focus {
            outline: 1px dotted var(--text-color);
            outline-offset: -2px;
        }

        label {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 2px 0;
        }

        input[type="checkbox"] {
            width: 13px;
            height: 13px;
            cursor: pointer;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .loading-screen.active {
            display: flex;
        }

        .boot-logo {
            width: 200px;
            height: 150px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            margin-bottom: 30px;
            position: relative;
            animation: bootWave 2s infinite;
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        @keyframes bootWave {
            0%, 100% { transform: perspective(100px) rotateY(0deg); }
            50% { transform: perspective(100px) rotateY(10deg); }
        }

        .loading-text {
            color: #c0c0c0;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: #000;
            border: 2px solid #c0c0c0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.8);
        }

        .progress-fill {
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                #000080 0px,
                #000080 10px,
                #1084d0 10px,
                #1084d0 20px
            );
            width: 0%;
            transition: width 0.3s ease;
            animation: slide 1s linear infinite;
        }

        @keyframes slide {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #ffffcc;
            border: 2px solid var(--text-color);
            padding: 10px;
            max-width: 300px;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .info-panel h4 {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .info-panel ul {
            margin-left: 20px;
            margin-top: 5px;
        }

        .info-panel li {
            margin: 3px 0;
            line-height: 1.3;
        }

        .warning-icon {
            color: #ff0000;
            font-weight: bold;
            font-size: 14px;
        }

        .hidden {
            display: none !important;
        }

        /* Desktop icons styling */
        .desktop-icon {
            position: absolute;
            width: 64px;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }

        .desktop-icon.selected .icon-text {
            background: var(--menu-highlight);
            color: white;
        }

        .icon-image {
            width: 32px;
            height: 32px;
            margin: 0 auto 4px;
        }

        .icon-text {
            font-size: 11px;
            padding: 1px 2px;
            word-wrap: break-word;
        }

        /* Window styling improvements */
        .window {
            position: absolute;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            box-shadow: 1px 1px 0 var(--button-shadow);
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .window.minimized {
            display: none;
        }

        .window.active {
            z-index: 1000;
        }

        .window-titlebar {
            background: var(--active-title-bar);
            color: white;
            padding: 2px 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            cursor: move;
            height: 18px;
            user-select: none;
        }

        .window-titlebar.inactive {
            background: var(--inactive-title-bar);
        }

        .window-content {
            background: var(--window-background);
            padding: 8px;
            overflow: auto;
            flex: 1;
            color: var(--text-color);
        }

        .resize-handle {
            position: absolute;
            z-index: 10;
        }

        .resize-n, .resize-s {
            left: 0;
            right: 0;
            height: 5px;
            cursor: ns-resize;
        }

        .resize-n { top: 0; }
        .resize-s { bottom: 0; }

        .resize-e, .resize-w {
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: ew-resize;
        }

        .resize-e { right: 0; }
        .resize-w { left: 0; }

        .resize-ne, .resize-nw, .resize-se, .resize-sw {
            width: 10px;
            height: 10px;
        }

        .resize-ne {
            top: 0;
            right: 0;
            cursor: nesw-resize;
        }

        .resize-nw {
            top: 0;
            left: 0;
            cursor: nwse-resize;
        }

        .resize-se {
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }

        .resize-sw {
            bottom: 0;
            left: 0;
            cursor: nesw-resize;
        }

        .taskbar-button {
            min-width: 100px;
            max-width: 200px;
            padding: 2px 4px;
            margin: 2px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            cursor: pointer;
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .taskbar-button.active {
            border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
            padding: 3px 3px 1px 5px;
        }

        .start-menu {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 200px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            display: none;
            z-index: 10000;
        }

        .start-menu.active {
            display: block;
        }

        .start-menu-sidebar {
            background: var(--inactive-title-bar);
            color: white;
            padding: 20px 4px;
            writing-mode: vertical-lr;
            transform: rotate(180deg);
            font-weight: bold;
            font-size: 16px;
        }

        .start-menu-items {
            padding: 2px;
        }

        .start-menu-item {
            padding: 4px 30px 4px 8px;
            cursor: pointer;
            position: relative;
            font-size: 11px;
        }

        .start-menu-item:hover {
            background: var(--menu-highlight);
            color: white;
        }

        .start-menu-item::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
        }

        .context-menu {
            position: absolute;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            padding: 2px;
            min-width: 150px;
            display: none;
            z-index: 10001;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
        }

        .context-menu-item:hover {
            background: var(--menu-highlight);
            color: white;
        }

        .context-menu-separator {
            height: 1px;
            background: var(--button-shadow);
            margin: 2px 4px;
        }

        /* Scrollbar styling for Windows 95 authenticity */
        .setup-screen::-webkit-scrollbar {
            width: 16px;
            height: 16px;
        }

        .setup-screen::-webkit-scrollbar-track {
            background: var(--button-face);
        }

        .setup-screen::-webkit-scrollbar-thumb {
            background: var(--button-face);
            border: 1px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
        }

        .setup-screen::-webkit-scrollbar-button {
            background: var(--button-face);
            border: 1px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
        }

        /* Reduced motion support for accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.2rem;
            }

            .btn {
                min-height: 44px;
                min-width: 44px;
                padding: 0.6rem 1rem;
                font-size: 12px;
            }

            .info-panel {
                position: static;
                margin-top: 1rem;
                max-width: 100%;
            }

            .controls {
                width: 100%;
                justify-content: center;
            }
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            background: #ffffcc;
            border: 1px solid var(--text-color);
            padding: 2px 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            display: none;
        }

        /* Multi-Clippy Assistant System */
        .clippy-instance {
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .clippy-character {
            transition: transform 0.3s;
        }

        .clippy-character:hover {
            transform: scale(1.05) rotate(2deg);
        }

        .clippy-bubble {
            animation: bubbleAppear 0.3s ease-out;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .bubble-arrow {
            z-index: 1;
        }

        @keyframes bubbleAppear {
            from {
                opacity: 0;
                transform: scale(0.85) translateY(10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Ensure Clippies don't overlap with desktop UI */
        .clippy-instance {
            pointer-events: auto;
        }

        .clippy-character:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span class="logo"></span> Windows 95 Desktop Simulator</h1>
        <div class="controls" role="toolbar" aria-label="Desktop controls">
            <button class="btn" id="pause-btn" onclick="emulator.togglePause()" aria-label="Pause desktop" title="Pause/Resume">
                <span aria-hidden="true">⏸</span> Pause
            </button>
            <button class="btn" onclick="emulator.restart()" aria-label="Restart desktop" title="Restart desktop">
                <span aria-hidden="true">🔄</span> Restart
            </button>
            <button class="btn" onclick="emulator.fullscreen()" aria-label="Enter fullscreen mode" title="Toggle fullscreen">
                <span aria-hidden="true">🖥</span> Fullscreen
            </button>
            <button class="btn" onclick="emulator.screenshot()" aria-label="Take screenshot" title="Save screenshot">
                <span aria-hidden="true">📷</span> Screenshot
            </button>
            <button class="btn" onclick="emulator.showHelp()" aria-label="Show help information" title="Help & Information">
                <span aria-hidden="true">❓</span> Help
            </button>
            <button class="btn primary" onclick="emulator.openAbout()" aria-label="About this simulator" title="About">
                <span aria-hidden="true">ℹ️</span> About
            </button>
        </div>
    </div>

    <div class="main-container">
        <div id="setup-screen" class="setup-screen" role="dialog" aria-labelledby="setup-title">
            <h2 id="setup-title">Windows 95 Desktop Simulator</h2>
            <div class="setup-content">
                <p><strong>Welcome to the Interactive Windows 95 Desktop Simulator!</strong></p>
                <p>Experience a fully functional Windows 95 desktop environment right in your browser.</p>

                <div class="setup-option">
                    <h3><span aria-hidden="true">🎮</span> Start Desktop Experience</h3>
                    <p>Launch the interactive desktop with working programs and classic Windows 95 interface.</p>
                    <p><strong>Features:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><strong>Internet Explorer</strong> - Browse real websites!</li>
                        <li>Draggable, resizable windows</li>
                        <li>Working Notepad, Calculator, and Minesweeper</li>
                        <li>Functional Start menu</li>
                        <li>Clickable desktop icons</li>
                        <li>Right-click context menus</li>
                        <li>Authentic Windows 95 aesthetics</li>
                    </ul>
                    <button class="btn primary" onclick="emulator.loadDemo()" style="margin-top: 10px;">Start Windows 95 Desktop</button>
                </div>

                <div class="setup-option" style="background: #e0e0e0;">
                    <h3><span aria-hidden="true">⚙️</span> Emulator Settings</h3>
                    <div style="display: grid; gap: 8px;">
                        <label>
                            <input type="checkbox" id="enable-mouse"> Enable Mouse Lock (Leave OFF for interactive desktop)
                        </label>
                        <label>
                            <input type="checkbox" id="enable-sound"> Enable Sound Emulation
                        </label>
                        <label>
                            <input type="checkbox" id="enable-network" checked> Enable Network
                        </label>
                        <label style="display: block; margin-top: 8px;">
                            <strong>Memory Allocation:</strong>
                            <select id="memory-size" style="width: 100%; margin-top: 4px;">
                                <option value="8">8 MB (Minimum)</option>
                                <option value="16">16 MB (Low)</option>
                                <option value="32" selected>32 MB (Recommended)</option>
                                <option value="64">64 MB (High)</option>
                                <option value="128">128 MB (Maximum)</option>
                            </select>
                        </label>
                        <label style="display: block; margin-top: 8px;">
                            <strong>CPU Speed:</strong>
                            <select id="cpu-speed" style="width: 100%; margin-top: 4px;">
                                <option value="1">1x (Authentic)</option>
                                <option value="2" selected>2x (Balanced)</option>
                                <option value="4">4x (Fast)</option>
                                <option value="8">8x (Maximum)</option>
                            </select>
                        </label>
                    </div>
                </div>

                <div class="setup-option" style="background: #fff8dc;">
                    <h3><span aria-hidden="true">ℹ️</span> System Information</h3>
                    <p><strong>Browser:</strong> <span id="browser-info">Detecting...</span></p>
                    <p><strong>WebAssembly:</strong> <span id="wasm-support">Checking...</span></p>
                    <p><strong>Screen:</strong> <span id="screen-info">Detecting...</span></p>
                </div>
            </div>
        </div>

        <div id="emulator-container" class="emulator-frame hidden">
            <div class="emulator-titlebar" id="emulator-titlebar">
                <span>Windows 95 Desktop - Interactive Mode</span>
                <div class="titlebar-buttons">
                    <div class="titlebar-btn" onclick="emulator.minimize()" role="button" aria-label="Minimize" title="Minimize">_</div>
                    <div class="titlebar-btn" onclick="emulator.maximize()" role="button" aria-label="Maximize" title="Maximize">□</div>
                    <div class="titlebar-btn" onclick="emulator.close()" role="button" aria-label="Close" title="Close">X</div>
                </div>
            </div>
            <div id="screen_container">
                <canvas id="screen" role="img" aria-label="Windows 95 emulator screen" tabindex="0"></canvas>
            </div>
            <div class="status-bar" role="status" aria-live="polite" aria-atomic="false">
                <div class="status-section">
                    <span id="cpu-status-label">CPU:</span>
                    <span id="cpu-status" aria-labelledby="cpu-status-label">Idle</span>
                    <div class="led" id="cpu-led" role="status" aria-label="CPU activity indicator" title="CPU Activity"></div>
                </div>
                <div class="status-section">
                    <span>HDD:</span>
                    <div class="led hdd" id="hdd-led" role="status" aria-label="Hard drive activity indicator" title="HDD Activity"></div>
                </div>
                <div class="status-section">
                    <span>FPS:</span>
                    <span id="fps-counter" aria-label="Frames per second">0</span>
                </div>
                <div class="status-section">
                    <span>MEM:</span>
                    <span id="memory-usage" aria-label="Memory usage">0 MB</span>
                </div>
                <div class="status-section">
                    <span id="time-display" aria-label="Uptime" title="Uptime">00:00:00</span>
                </div>
            </div>
        </div>

        <div class="info-panel" id="info-panel">
            <h4><span class="warning-icon" aria-hidden="true">💡</span> Quick Start Guide</h4>
            <ul>
                <li><strong>Try Internet Explorer!</strong> Browse real websites (try wikipedia.org)</li>
                <li><strong>Double-click</strong> desktop icons to launch programs</li>
                <li><strong>Drag</strong> windows by their title bars to move them</li>
                <li><strong>Click</strong> the Start button for the program menu</li>
                <li><strong>Right-click</strong> the desktop for context menu</li>
                <li><strong>Minimize</strong> windows to the taskbar</li>
                <li>Press <strong>F11</strong> for fullscreen mode</li>
                <li><strong>Note:</strong> Mouse lock is disabled for free movement</li>
            </ul>
            <button class="btn" onclick="document.getElementById('info-panel').classList.add('hidden')" style="margin-top: 8px; width: 100%;">Got it!</button>
        </div>
    </div>

    <div class="loading-screen" id="loading-screen" role="alert" aria-live="assertive">
        <div class="boot-logo" aria-hidden="true"></div>
        <div class="loading-text" id="loading-text">Starting Windows 95 Desktop...</div>
        <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Polyfill for String.padStart (IE11, Safari < 10)
        if (!String.prototype.padStart) {
            String.prototype.padStart = function padStart(targetLength, padString) {
                targetLength = targetLength >> 0;
                padString = String(typeof padString !== 'undefined' ? padString : ' ');
                if (this.length >= targetLength) {
                    return String(this);
                }
                targetLength = targetLength - this.length;
                if (targetLength > padString.length) {
                    padString += padString.repeat(targetLength / padString.length);
                }
                return padString.slice(0, targetLength) + String(this);
            };
        }

        // Configuration constants
        const CONFIG = {
            DISPLAY: {
                WIDTH: 640,
                HEIGHT: 480,
                TASKBAR_HEIGHT: 30
            },
            COLORS: {
                DESKTOP: '#008080',
                TASKBAR: '#c0c0c0',
                TITLE_BAR: '#000080',
                WINDOW_BG: '#ffffff'
            },
            ANIMATION: {
                FPS_UPDATE_INTERVAL: 1000,
                LED_THROTTLE_FRAMES: 10,
                BOOT_MESSAGE_DELAY: 150
            },
            PERFORMANCE: {
                MAX_FPS: 60,
                FRAME_TIME: 16.67
            }
        };

        // Window Manager - handles all window operations
        class WindowManager {
            constructor(desktop) {
                this.desktop = desktop;
                this.windows = [];
                this.nextZIndex = 1000;
                this.draggedWindow = null;
                this.dragOffset = { x: 0, y: 0 };
                this.resizingWindow = null;
                this.resizeDirection = null;
                this.resizeStart = { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0 };
                this.snapThreshold = 20; // pixels from edge to trigger snap
            }

            createWindow(title, content, options = {}) {
                const windowId = 'win-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                // Load saved position if available
                const savedPosition = this.loadWindowPosition(title);
                const defaultX = 100 + this.windows.length * 30;
                const defaultY = 100 + this.windows.length * 30;

                const windowEl = document.createElement('div');
                windowEl.className = 'window active';
                windowEl.id = windowId;
                windowEl.style.left = (options.x || savedPosition?.x || defaultX) + 'px';
                windowEl.style.top = (options.y || savedPosition?.y || defaultY) + 'px';
                windowEl.style.width = (options.width || savedPosition?.width || 400) + 'px';
                windowEl.style.height = (options.height || savedPosition?.height || 300) + 'px';
                windowEl.style.zIndex = this.nextZIndex++;
                windowEl.dataset.windowTitle = title; // Store title for position saving

                const titleBar = document.createElement('div');
                titleBar.className = 'window-titlebar';
                titleBar.innerHTML = `
                    <span>${title}</span>
                    <div class="titlebar-buttons">
                        <div class="titlebar-btn minimize-btn" title="Minimize">_</div>
                        <div class="titlebar-btn maximize-btn" title="Maximize">□</div>
                        <div class="titlebar-btn close-btn" title="Close">X</div>
                    </div>
                `;

                const contentEl = document.createElement('div');
                contentEl.className = 'window-content';
                if (typeof content === 'string') {
                    contentEl.innerHTML = content;
                } else {
                    contentEl.appendChild(content);
                }

                // Add resize handles
                const resizeHandles = document.createElement('div');
                resizeHandles.innerHTML = `
                    <div class="resize-handle resize-n" data-direction="n"></div>
                    <div class="resize-handle resize-s" data-direction="s"></div>
                    <div class="resize-handle resize-e" data-direction="e"></div>
                    <div class="resize-handle resize-w" data-direction="w"></div>
                    <div class="resize-handle resize-ne" data-direction="ne"></div>
                    <div class="resize-handle resize-nw" data-direction="nw"></div>
                    <div class="resize-handle resize-se" data-direction="se"></div>
                    <div class="resize-handle resize-sw" data-direction="sw"></div>
                `;

                windowEl.appendChild(titleBar);
                windowEl.appendChild(contentEl);
                windowEl.appendChild(resizeHandles);

                // Add to desktop
                const screenContainer = document.getElementById('screen_container');
                screenContainer.appendChild(windowEl);

                // Setup event listeners
                this.setupWindowEvents(windowEl, titleBar);

                // Store window reference
                const windowObj = {
                    id: windowId,
                    element: windowEl,
                    title: title,
                    minimized: false
                };
                this.windows.push(windowObj);

                // Add taskbar button
                this.desktop.addTaskbarButton(windowObj);

                // Focus window
                this.focusWindow(windowEl);

                // Play window open sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('window-open');
                }

                return windowObj;
            }

            setupWindowEvents(windowEl, titleBar) {
                // Make titlebar draggable
                titleBar.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.titlebar-btn')) return;

                    this.draggedWindow = windowEl;
                    this.dragOffset = {
                        x: e.clientX - windowEl.offsetLeft,
                        y: e.clientY - windowEl.offsetTop
                    };
                    this.focusWindow(windowEl);
                });

                // Close button
                const closeBtn = windowEl.querySelector('.close-btn');
                closeBtn.addEventListener('click', () => this.closeWindow(windowEl));

                // Minimize button
                const minimizeBtn = windowEl.querySelector('.minimize-btn');
                minimizeBtn.addEventListener('click', () => this.minimizeWindow(windowEl));

                // Maximize button
                const maximizeBtn = windowEl.querySelector('.maximize-btn');
                maximizeBtn.addEventListener('click', () => this.maximizeWindow(windowEl));

                // Focus on click
                windowEl.addEventListener('mousedown', () => this.focusWindow(windowEl));

                // Resize handles
                const resizeHandles = windowEl.querySelectorAll('.resize-handle');
                resizeHandles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.resizingWindow = windowEl;
                        this.resizeDirection = handle.dataset.direction;
                        this.resizeStart = {
                            x: e.clientX,
                            y: e.clientY,
                            width: windowEl.offsetWidth,
                            height: windowEl.offsetHeight,
                            left: windowEl.offsetLeft,
                            top: windowEl.offsetTop
                        };
                        this.focusWindow(windowEl);
                    });
                });
            }

            focusWindow(windowEl) {
                // Remove active class from all windows
                this.windows.forEach(win => {
                    win.element.classList.remove('active');
                    const titlebar = win.element.querySelector('.window-titlebar');
                    if (titlebar) titlebar.classList.add('inactive');
                });

                // Set active window
                windowEl.classList.add('active');
                windowEl.style.zIndex = this.nextZIndex++;
                const titlebar = windowEl.querySelector('.window-titlebar');
                if (titlebar) titlebar.classList.remove('inactive');

                // Update taskbar buttons
                this.desktop.updateTaskbarButtons();
            }

            minimizeWindow(windowEl) {
                const windowObj = this.windows.find(w => w.element === windowEl);
                if (windowObj) {
                    windowObj.minimized = true;
                    windowEl.classList.add('minimized');
                    this.desktop.updateTaskbarButtons();

                    // Play minimize sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('minimize');
                    }
                }
            }

            maximizeWindow(windowEl) {
                const isMaximized = windowEl.dataset.maximized === 'true';

                if (isMaximized) {
                    // Restore
                    windowEl.style.left = windowEl.dataset.restoreLeft;
                    windowEl.style.top = windowEl.dataset.restoreTop;
                    windowEl.style.width = windowEl.dataset.restoreWidth;
                    windowEl.style.height = windowEl.dataset.restoreHeight;
                    windowEl.dataset.maximized = 'false';

                    // Save restored position
                    const title = windowEl.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(windowEl.style.left),
                            y: parseInt(windowEl.style.top),
                            width: parseInt(windowEl.style.width),
                            height: parseInt(windowEl.style.height)
                        });
                    }

                    // Play minimize sound (for restore)
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('minimize');
                    }
                } else {
                    // Store current position
                    windowEl.dataset.restoreLeft = windowEl.style.left;
                    windowEl.dataset.restoreTop = windowEl.style.top;
                    windowEl.dataset.restoreWidth = windowEl.style.width;
                    windowEl.dataset.restoreHeight = windowEl.style.height;

                    // Maximize
                    windowEl.style.left = '0px';
                    windowEl.style.top = '0px';
                    windowEl.style.width = '640px';
                    windowEl.style.height = '450px';
                    windowEl.dataset.maximized = 'true';

                    // Play maximize sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('maximize');
                    }
                }
            }

            restoreWindow(windowEl) {
                const windowObj = this.windows.find(w => w.element === windowEl);
                if (windowObj && windowObj.minimized) {
                    windowObj.minimized = false;
                    windowEl.classList.remove('minimized');
                    this.focusWindow(windowEl);
                    this.desktop.updateTaskbarButtons();
                }
            }

            closeWindow(windowEl) {
                const index = this.windows.findIndex(w => w.element === windowEl);
                if (index > -1) {
                    const windowObj = this.windows[index];
                    this.desktop.removeTaskbarButton(windowObj);
                    windowEl.remove();
                    this.windows.splice(index, 1);

                    // Play window close sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('window-close');
                    }
                }
            }

            handleMouseMove(e) {
                // Handle window resizing
                if (this.resizingWindow) {
                    const deltaX = e.clientX - this.resizeStart.x;
                    const deltaY = e.clientY - this.resizeStart.y;
                    const dir = this.resizeDirection;
                    const win = this.resizingWindow;
                    const minWidth = 200;
                    const minHeight = 150;

                    let newWidth = this.resizeStart.width;
                    let newHeight = this.resizeStart.height;
                    let newLeft = this.resizeStart.left;
                    let newTop = this.resizeStart.top;

                    // Calculate new dimensions based on resize direction
                    if (dir.includes('e')) {
                        newWidth = Math.max(minWidth, this.resizeStart.width + deltaX);
                    }
                    if (dir.includes('w')) {
                        newWidth = Math.max(minWidth, this.resizeStart.width - deltaX);
                        if (newWidth > minWidth) newLeft = this.resizeStart.left + deltaX;
                    }
                    if (dir.includes('s')) {
                        newHeight = Math.max(minHeight, this.resizeStart.height + deltaY);
                    }
                    if (dir.includes('n')) {
                        newHeight = Math.max(minHeight, this.resizeStart.height - deltaY);
                        if (newHeight > minHeight) newTop = this.resizeStart.top + deltaY;
                    }

                    win.style.width = newWidth + 'px';
                    win.style.height = newHeight + 'px';
                    win.style.left = newLeft + 'px';
                    win.style.top = newTop + 'px';
                }

                // Handle window dragging
                if (this.draggedWindow) {
                    const screenContainer = document.getElementById('screen_container');
                    const containerRect = screenContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;

                    let newX = e.clientX - this.dragOffset.x;
                    let newY = e.clientY - this.dragOffset.y;

                    // Keep within bounds
                    newX = Math.max(0, Math.min(containerWidth - 100, newX));
                    newY = Math.max(0, Math.min(containerHeight - 30, newY));

                    this.draggedWindow.style.left = newX + 'px';
                    this.draggedWindow.style.top = newY + 'px';

                    // Show snap preview
                    this.showSnapPreview(e.clientX, e.clientY, containerWidth, containerHeight);
                }
            }

            handleMouseUp(e) {
                // Handle resize end
                if (this.resizingWindow) {
                    const title = this.resizingWindow.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(this.resizingWindow.style.left),
                            y: parseInt(this.resizingWindow.style.top),
                            width: parseInt(this.resizingWindow.style.width),
                            height: parseInt(this.resizingWindow.style.height)
                        });
                    }
                    this.resizingWindow = null;
                    this.resizeDirection = null;
                }

                // Handle drag end with snap
                if (this.draggedWindow) {
                    const screenContainer = document.getElementById('screen_container');
                    const containerRect = screenContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;

                    // Check for snap zones
                    const snapPosition = this.getSnapPosition(e.clientX, e.clientY, containerWidth, containerHeight);
                    if (snapPosition) {
                        this.snapWindow(this.draggedWindow, snapPosition, containerWidth, containerHeight);
                    }

                    // Save window position after dragging
                    const title = this.draggedWindow.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(this.draggedWindow.style.left),
                            y: parseInt(this.draggedWindow.style.top),
                            width: parseInt(this.draggedWindow.style.width),
                            height: parseInt(this.draggedWindow.style.height)
                        });
                    }
                    this.draggedWindow = null;
                    this.hideSnapPreview();
                }
            }

            showSnapPreview(mouseX, mouseY, containerWidth, containerHeight) {
                const snapPosition = this.getSnapPosition(mouseX, mouseY, containerWidth, containerHeight);
                let preview = document.getElementById('snap-preview');

                if (!preview) {
                    preview = document.createElement('div');
                    preview.id = 'snap-preview';
                    preview.style.cssText = 'position: absolute; border: 3px solid #0066cc; background: rgba(0, 102, 204, 0.1); pointer-events: none; z-index: 9999; display: none;';
                    document.getElementById('screen_container').appendChild(preview);
                }

                if (snapPosition) {
                    const pos = this.calculateSnapDimensions(snapPosition, containerWidth, containerHeight);
                    preview.style.left = pos.left + 'px';
                    preview.style.top = pos.top + 'px';
                    preview.style.width = pos.width + 'px';
                    preview.style.height = pos.height + 'px';
                    preview.style.display = 'block';
                } else {
                    preview.style.display = 'none';
                }
            }

            hideSnapPreview() {
                const preview = document.getElementById('snap-preview');
                if (preview) {
                    preview.style.display = 'none';
                }
            }

            getSnapPosition(mouseX, mouseY, containerWidth, containerHeight) {
                const threshold = this.snapThreshold;

                // Left edge
                if (mouseX < threshold) {
                    if (mouseY < threshold) return 'top-left';
                    if (mouseY > containerHeight - threshold) return 'bottom-left';
                    return 'left';
                }

                // Right edge
                if (mouseX > containerWidth - threshold) {
                    if (mouseY < threshold) return 'top-right';
                    if (mouseY > containerHeight - threshold) return 'bottom-right';
                    return 'right';
                }

                // Top edge
                if (mouseY < threshold) {
                    return 'top';
                }

                // Bottom edge
                if (mouseY > containerHeight - threshold) {
                    return 'bottom';
                }

                return null;
            }

            calculateSnapDimensions(position, containerWidth, containerHeight) {
                const taskbarHeight = 30;
                const workHeight = containerHeight - taskbarHeight;

                const positions = {
                    'left': { left: 0, top: 0, width: containerWidth / 2, height: workHeight },
                    'right': { left: containerWidth / 2, top: 0, width: containerWidth / 2, height: workHeight },
                    'top': { left: 0, top: 0, width: containerWidth, height: workHeight },
                    'bottom': { left: 0, top: workHeight / 2, width: containerWidth, height: workHeight / 2 },
                    'top-left': { left: 0, top: 0, width: containerWidth / 2, height: workHeight / 2 },
                    'top-right': { left: containerWidth / 2, top: 0, width: containerWidth / 2, height: workHeight / 2 },
                    'bottom-left': { left: 0, top: workHeight / 2, width: containerWidth / 2, height: workHeight / 2 },
                    'bottom-right': { left: containerWidth / 2, top: workHeight / 2, width: containerWidth / 2, height: workHeight / 2 }
                };

                return positions[position] || null;
            }

            snapWindow(windowEl, position, containerWidth, containerHeight) {
                const dims = this.calculateSnapDimensions(position, containerWidth, containerHeight);
                if (dims) {
                    windowEl.style.left = dims.left + 'px';
                    windowEl.style.top = dims.top + 'px';
                    windowEl.style.width = dims.width + 'px';
                    windowEl.style.height = dims.height + 'px';
                    windowEl.dataset.maximized = 'false';
                }
            }

            updateBounds(width, height) {
                // This is called when the canvas/screen is resized (e.g., fullscreen mode)
                // We don't need to do anything special here since windows use absolute positioning
                // and the snap calculations already use current dimensions
                console.log('Window manager bounds updated:', width, height);
            }

            loadWindowPosition(title) {
                try {
                    const positions = SafeStorage.getItem('win95-window-positions');
                    if (positions) {
                        const allPositions = JSON.parse(positions);
                        return allPositions[title];
                    }
                } catch (e) {
                    console.warn('Failed to load window position:', e);
                }
                return null;
            }

            saveWindowPosition(title, position) {
                try {
                    let positions = {};
                    const saved = SafeStorage.getItem('win95-window-positions');
                    if (saved) {
                        positions = JSON.parse(saved);
                    }
                    positions[title] = position;
                    SafeStorage.setItem('win95-window-positions', JSON.stringify(positions));
                } catch (e) {
                    console.warn('Failed to save window position:', e);
                }
            }
        }

        class Windows95Emulator {
            constructor() {
                this.v86 = null;
                this.isRunning = false;
                this.isPaused = false;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.lastFrameTime = 0;
                this.hddLedTimeout = null;
                this.canvas = null;
                this.ctx = null;
                this.domCache = null;
                this.memoryUsage = 0;
                this.cpuUsage = 0;

                this.settings = {
                    memory: 32 * 1024 * 1024,
                    enableMouse: false,
                    enableSound: false,
                    enableNetwork: true,
                    cpuSpeed: 2
                };

                this.desktop = {
                    icons: [],
                    windows: []
                };

                this.windowManager = new WindowManager(this);
                this.taskbarButtons = [];

                this.initEmulatorCore();
                this.detectSystemInfo();
                this.initAudioContext();
            }

            // Audio system for games
            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.audioContext = null;
                }
            }

            playSoundEffect(type) {
                if (!this.audioContext) return;

                const ctx = this.audioContext;
                const now = ctx.currentTime;

                switch(type) {
                    case 'flip':
                    case 'deal':
                        // Quick click sound
                        const flipOsc = ctx.createOscillator();
                        const flipGain = ctx.createGain();
                        flipOsc.connect(flipGain);
                        flipGain.connect(ctx.destination);
                        flipOsc.frequency.setValueAtTime(800, now);
                        flipOsc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                        flipGain.gain.setValueAtTime(0.1, now);
                        flipGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        flipOsc.start(now);
                        flipOsc.stop(now + 0.05);
                        break;

                    case 'place':
                        // Satisfying placement sound
                        const placeOsc = ctx.createOscillator();
                        const placeGain = ctx.createGain();
                        placeOsc.connect(placeGain);
                        placeGain.connect(ctx.destination);
                        placeOsc.frequency.setValueAtTime(400, now);
                        placeOsc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                        placeGain.gain.setValueAtTime(0.15, now);
                        placeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        placeOsc.start(now);
                        placeOsc.stop(now + 0.1);
                        break;

                    case 'invalid':
                        // Error buzz
                        const errOsc = ctx.createOscillator();
                        const errGain = ctx.createGain();
                        errOsc.connect(errGain);
                        errGain.connect(ctx.destination);
                        errOsc.type = 'square';
                        errOsc.frequency.setValueAtTime(150, now);
                        errGain.gain.setValueAtTime(0.08, now);
                        errGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        errOsc.start(now);
                        errOsc.stop(now + 0.1);
                        break;

                    case 'win':
                        // Victory fanfare
                        const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C
                        notes.forEach((freq, i) => {
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();
                            osc.connect(gain);
                            gain.connect(ctx.destination);
                            osc.frequency.setValueAtTime(freq, now + i * 0.15);
                            gain.gain.setValueAtTime(0.1, now + i * 0.15);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.3);
                            osc.start(now + i * 0.15);
                            osc.stop(now + i * 0.15 + 0.3);
                        });
                        break;

                    case 'window-open':
                        // Window opening sound - ascending chirp
                        const openOsc = ctx.createOscillator();
                        const openGain = ctx.createGain();
                        openOsc.connect(openGain);
                        openGain.connect(ctx.destination);
                        openOsc.frequency.setValueAtTime(400, now);
                        openOsc.frequency.exponentialRampToValueAtTime(800, now + 0.08);
                        openGain.gain.setValueAtTime(0.08, now);
                        openGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        openOsc.start(now);
                        openOsc.stop(now + 0.08);
                        break;

                    case 'window-close':
                        // Window closing sound - descending chirp
                        const closeOsc = ctx.createOscillator();
                        const closeGain = ctx.createGain();
                        closeOsc.connect(closeGain);
                        closeGain.connect(ctx.destination);
                        closeOsc.frequency.setValueAtTime(800, now);
                        closeOsc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
                        closeGain.gain.setValueAtTime(0.08, now);
                        closeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        closeOsc.start(now);
                        closeOsc.stop(now + 0.08);
                        break;

                    case 'button-click':
                        // Button click sound - short tap
                        const btnOsc = ctx.createOscillator();
                        const btnGain = ctx.createGain();
                        btnOsc.connect(btnGain);
                        btnGain.connect(ctx.destination);
                        btnOsc.type = 'sine';
                        btnOsc.frequency.setValueAtTime(600, now);
                        btnGain.gain.setValueAtTime(0.05, now);
                        btnGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                        btnOsc.start(now);
                        btnOsc.stop(now + 0.03);
                        break;

                    case 'minimize':
                        // Minimize sound - quick descending tone
                        const minOsc = ctx.createOscillator();
                        const minGain = ctx.createGain();
                        minOsc.connect(minGain);
                        minGain.connect(ctx.destination);
                        minOsc.frequency.setValueAtTime(700, now);
                        minOsc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                        minGain.gain.setValueAtTime(0.07, now);
                        minGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        minOsc.start(now);
                        minOsc.stop(now + 0.1);
                        break;

                    case 'maximize':
                        // Maximize sound - expanding tone
                        const maxOsc = ctx.createOscillator();
                        const maxGain = ctx.createGain();
                        maxOsc.connect(maxGain);
                        maxGain.connect(ctx.destination);
                        maxOsc.frequency.setValueAtTime(500, now);
                        maxOsc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
                        maxGain.gain.setValueAtTime(0.07, now);
                        maxGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        maxOsc.start(now);
                        maxOsc.stop(now + 0.1);
                        break;

                    case 'start-menu':
                        // Start menu sound - pleasant two-tone
                        const sm1 = ctx.createOscillator();
                        const sm2 = ctx.createOscillator();
                        const smGain = ctx.createGain();
                        sm1.connect(smGain);
                        sm2.connect(smGain);
                        smGain.connect(ctx.destination);
                        sm1.frequency.setValueAtTime(600, now);
                        sm2.frequency.setValueAtTime(800, now + 0.05);
                        smGain.gain.setValueAtTime(0.06, now);
                        smGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                        sm1.start(now);
                        sm1.stop(now + 0.06);
                        sm2.start(now + 0.05);
                        sm2.stop(now + 0.12);
                        break;
                }
            }

            // Programs
            openNotepad() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%;';

                // Menu bar
                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px;';
                menuBar.innerHTML = `
                    <button class="btn" onclick="emulator.notepadNew()">New</button>
                    <button class="btn" onclick="emulator.notepadSave()">Save</button>
                    <button class="btn" onclick="emulator.notepadLoad()">Load</button>
                    <button class="btn" onclick="emulator.notepadDownload()">Download</button>
                    <button class="btn" onclick="emulator.notepadUpload()">Upload File</button>
                `;

                // Textarea
                const textarea = document.createElement('textarea');
                textarea.id = 'notepad-textarea';
                textarea.style.cssText = 'flex: 1; border: none; font-family: "Courier New", monospace; font-size: 12px; padding: 4px; resize: none; outline: none; width: 100%; box-sizing: border-box;';

                // Load autosaved content
                const autosaved = SafeStorage.getItem('notepad-autosave');
                if (autosaved) {
                    textarea.value = autosaved;
                }

                // Autosave on input
                textarea.addEventListener('input', () => {
                    SafeStorage.setItem('notepad-autosave', textarea.value);
                });

                // File input (hidden)
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.txt';
                fileInput.style.display = 'none';
                fileInput.id = 'notepad-file-input';
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            textarea.value = event.target.result;
                            SafeStorage.setItem('notepad-autosave', textarea.value);
                        };
                        reader.readAsText(file);
                    }
                });

                content.appendChild(menuBar);
                content.appendChild(textarea);
                content.appendChild(fileInput);

                this.notepadState = { currentFile: 'Untitled' };
                this.windowManager.createWindow('Untitled - Notepad', content, { width: 500, height: 400 });
            }

            notepadNew() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    if (textarea.value && !confirm('Clear current document?')) {
                        return;
                    }
                    textarea.value = '';
                    SafeStorage.setItem('notepad-autosave', '');
                    this.notepadState.currentFile = 'Untitled';
                }
            }

            notepadSave() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const filename = prompt('Enter filename:', this.notepadState?.currentFile || 'document');
                    if (filename) {
                        SafeStorage.setItem('notepad-file-' + filename, textarea.value);
                        this.notepadState.currentFile = filename;
                        alert('Saved as: ' + filename);
                    }
                }
            }

            notepadLoad() {
                const filename = prompt('Enter filename to load:');
                if (filename) {
                    const content = SafeStorage.getItem('notepad-file-' + filename);
                    if (content !== null) {
                        const textarea = document.getElementById('notepad-textarea');
                        if (textarea) {
                            textarea.value = content;
                            SafeStorage.setItem('notepad-autosave', content);
                            this.notepadState.currentFile = filename;
                            alert('Loaded: ' + filename);
                        }
                    } else {
                        alert('File not found: ' + filename);
                    }
                }
            }

            notepadDownload() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const blob = new Blob([textarea.value], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (this.notepadState?.currentFile || 'document') + '.txt';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }

            notepadUpload() {
                const fileInput = document.getElementById('notepad-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            openCalculator() {
                const content = document.createElement('div');
                content.innerHTML = `
                    <div style="padding: 10px;">
                        <input type="text" id="calc-display" readonly style="width: 100%; margin-bottom: 10px; text-align: right; font-size: 18px; padding: 5px; border: 2px inset; background: white;" value="0">
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                            <button class="btn" onclick="emulator.calcInput('7')">7</button>
                            <button class="btn" onclick="emulator.calcInput('8')">8</button>
                            <button class="btn" onclick="emulator.calcInput('9')">9</button>
                            <button class="btn" onclick="emulator.calcInput('/')">/</button>
                            <button class="btn" onclick="emulator.calcInput('4')">4</button>
                            <button class="btn" onclick="emulator.calcInput('5')">5</button>
                            <button class="btn" onclick="emulator.calcInput('6')">6</button>
                            <button class="btn" onclick="emulator.calcInput('*')">*</button>
                            <button class="btn" onclick="emulator.calcInput('1')">1</button>
                            <button class="btn" onclick="emulator.calcInput('2')">2</button>
                            <button class="btn" onclick="emulator.calcInput('3')">3</button>
                            <button class="btn" onclick="emulator.calcInput('-')">-</button>
                            <button class="btn" onclick="emulator.calcInput('0')" style="grid-column: span 2;">0</button>
                            <button class="btn" onclick="emulator.calcInput('.')">.</button>
                            <button class="btn" onclick="emulator.calcInput('+')">+</button>
                            <button class="btn primary" onclick="emulator.calcEquals()" style="grid-column: span 4;">=</button>
                            <button class="btn" onclick="emulator.calcClear()" style="grid-column: span 4;">C</button>
                        </div>
                    </div>
                `;
                this.windowManager.createWindow('Calculator', content, { width: 240, height: 320 });
                this.calcExpression = '';
            }

            calcInput(value) {
                const display = document.getElementById('calc-display');
                if (display) {
                    if (this.calcExpression === '' || this.calcExpression === '0') {
                        this.calcExpression = value;
                    } else {
                        this.calcExpression += value;
                    }
                    display.value = this.calcExpression;
                }
            }

            calcEquals() {
                const display = document.getElementById('calc-display');
                if (display && this.calcExpression) {
                    try {
                        const result = eval(this.calcExpression);
                        display.value = result;
                        this.calcExpression = result.toString();
                    } catch (e) {
                        display.value = 'Error';
                        this.calcExpression = '';
                    }
                }
            }

            calcClear() {
                const display = document.getElementById('calc-display');
                if (display) {
                    display.value = '0';
                    this.calcExpression = '';
                }
            }

            openMinesweeper() {
                // Show difficulty selection dialog
                const difficultyDialog = document.createElement('div');
                difficultyDialog.style.cssText = 'padding: 20px; text-align: center;';
                difficultyDialog.innerHTML = `
                    <h3 style="margin-top: 0;">Select Difficulty</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin: 20px 0;">
                        <button class="btn primary" onclick="emulator.startMinesweeper('easy')" style="padding: 12px;">Easy (8x8, 10 mines)</button>
                        <button class="btn primary" onclick="emulator.startMinesweeper('medium')" style="padding: 12px;">Medium (16x16, 40 mines)</button>
                        <button class="btn primary" onclick="emulator.startMinesweeper('hard')" style="padding: 12px;">Hard (24x24, 99 mines)</button>
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #808080; text-align: left; font-size: 11px;">
                        <strong>Statistics:</strong><br>
                        Easy - Wins: <span id="stats-easy-wins">0</span> | Best: <span id="stats-easy-time">-</span><br>
                        Medium - Wins: <span id="stats-medium-wins">0</span> | Best: <span id="stats-medium-time">-</span><br>
                        Hard - Wins: <span id="stats-hard-wins">0</span> | Best: <span id="stats-hard-time">-</span>
                    </div>
                `;

                // Load and display stats
                const stats = this.loadMinesweeperStats();
                setTimeout(() => {
                    ['easy', 'medium', 'hard'].forEach(diff => {
                        const winsEl = document.getElementById(`stats-${diff}-wins`);
                        const timeEl = document.getElementById(`stats-${diff}-time`);
                        if (winsEl) winsEl.textContent = stats[diff].wins;
                        if (timeEl) timeEl.textContent = stats[diff].bestTime ? `${stats[diff].bestTime}s` : '-';
                    });
                }, 50);

                this.windowManager.createWindow('Minesweeper', difficultyDialog, { width: 400, height: 360 });
            }

            loadMinesweeperStats() {
                const saved = SafeStorage.getItem('win95-minesweeper-stats');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return this.getDefaultMinesweeperStats();
                    }
                }
                return this.getDefaultMinesweeperStats();
            }

            getDefaultMinesweeperStats() {
                return {
                    easy: { wins: 0, losses: 0, bestTime: null },
                    medium: { wins: 0, losses: 0, bestTime: null },
                    hard: { wins: 0, losses: 0, bestTime: null }
                };
            }

            saveMinesweeperStats(stats) {
                SafeStorage.setItem('win95-minesweeper-stats', JSON.stringify(stats));
            }

            startMinesweeper(difficulty) {
                const configs = {
                    easy: { rows: 8, cols: 8, mines: 10 },
                    medium: { rows: 16, cols: 16, mines: 40 },
                    hard: { rows: 24, cols: 24, mines: 99 }
                };

                const config = configs[difficulty];
                const content = document.createElement('div');
                let board = this.createMinesweeperBoard(config.rows, config.cols, config.mines);
                let gameStarted = false;
                let gameOver = false;
                let startTime = null;
                let timerInterval = null;
                let flagCount = 0;

                content.innerHTML = `
                    <div style="padding: 10px; text-align: center;">
                        <div style="background: var(--button-face); padding: 8px; margin-bottom: 10px; border: 2px inset; display: flex; justify-content: space-between; align-items: center;">
                            <div><strong>💣 ${config.mines}</strong></div>
                            <div><strong>🚩 <span id="flag-count">0</span></strong></div>
                            <div><strong>⏱️ <span id="timer">0</span>s</strong></div>
                            <button class="btn" onclick="emulator.startMinesweeper('${difficulty}')" style="padding: 4px 8px;">New Game</button>
                        </div>
                        <div id="minesweeper-board" style="display: inline-grid; grid-template-columns: repeat(${config.cols}, 22px); gap: 0; border: 2px outset var(--button-face);"></div>
                    </div>
                `;

                const boardEl = content.querySelector('#minesweeper-board');
                const flagCountEl = content.querySelector('#flag-count');
                const timerEl = content.querySelector('#timer');

                board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const cellBtn = document.createElement('button');
                        cellBtn.className = 'btn';
                        cellBtn.style.cssText = 'width: 22px; height: 22px; padding: 0; font-size: 10px; font-weight: bold;';
                        cellBtn.dataset.row = r;
                        cellBtn.dataset.col = c;

                        cellBtn.onclick = () => {
                            if (!gameStarted) {
                                gameStarted = true;
                                startTime = Date.now();
                                timerInterval = setInterval(() => {
                                    if (!gameOver) {
                                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                                        timerEl.textContent = elapsed;
                                    }
                                }, 1000);
                            }
                            if (!gameOver) {
                                this.revealMinesweeperCell(boardEl, board, r, c, config, difficulty, timerInterval, () => {
                                    gameOver = true;
                                    clearInterval(timerInterval);
                                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                                    this.updateMinesweeperStats(difficulty, true, elapsed);
                                }, () => {
                                    gameOver = true;
                                    clearInterval(timerInterval);
                                    this.updateMinesweeperStats(difficulty, false, null);
                                });
                            }
                        };

                        cellBtn.oncontextmenu = (e) => {
                            e.preventDefault();
                            if (!gameOver && !cellBtn.disabled) {
                                if (cellBtn.textContent === '🚩') {
                                    cellBtn.textContent = '';
                                    flagCount--;
                                } else if (cellBtn.textContent === '') {
                                    cellBtn.textContent = '🚩';
                                    flagCount++;
                                }
                                flagCountEl.textContent = flagCount;
                            }
                            return false;
                        };

                        boardEl.appendChild(cellBtn);
                    });
                });

                const width = Math.max(320, config.cols * 22 + 40);
                const height = Math.max(380, config.rows * 22 + 100);
                this.windowManager.createWindow(`Minesweeper - ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`, content, { width, height });
            }

            updateMinesweeperStats(difficulty, won, time) {
                const stats = this.loadMinesweeperStats();
                if (won) {
                    stats[difficulty].wins++;
                    if (!stats[difficulty].bestTime || time < stats[difficulty].bestTime) {
                        stats[difficulty].bestTime = time;
                    }
                } else {
                    stats[difficulty].losses++;
                }
                this.saveMinesweeperStats(stats);
            }

            createMinesweeperBoard(rows, cols, mines) {
                const board = Array(rows).fill().map(() => Array(cols).fill(0));
                let placedMines = 0;

                while (placedMines < mines) {
                    const r = Math.floor(Math.random() * rows);
                    const c = Math.floor(Math.random() * cols);
                    if (board[r][c] !== -1) {
                        board[r][c] = -1;
                        placedMines++;

                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc] !== -1) {
                                    board[nr][nc]++;
                                }
                            }
                        }
                    }
                }
                return board;
            }

            revealMinesweeperCell(boardEl, board, row, col, config, difficulty, timerInterval, onWin, onLoss) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === '🚩') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === -1) {
                    // Hit a mine - game over
                    cellBtn.textContent = '💣';
                    cellBtn.style.background = 'red';

                    // Reveal all mines
                    const allCells = boardEl.querySelectorAll('button');
                    allCells.forEach(btn => {
                        const r = parseInt(btn.dataset.row);
                        const c = parseInt(btn.dataset.col);
                        if (board[r][c] === -1) {
                            btn.textContent = '💣';
                            btn.disabled = true;
                            btn.style.background = '#c0c0c0';
                        }
                    });

                    setTimeout(() => {
                        alert('Game Over! You hit a mine!');
                        onLoss();
                    }, 100);
                } else if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                                this.revealMinesweeperCellSimple(boardEl, board, nr, nc);
                            }
                        }
                    }
                    // Check for win after revealing
                    this.checkMinesweeperWin(boardEl, board, config, onWin);
                } else {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                    // Check for win
                    this.checkMinesweeperWin(boardEl, board, config, onWin);
                }
            }

            revealMinesweeperCellSimple(boardEl, board, row, col) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === '🚩') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length) {
                                this.revealMinesweeperCellSimple(boardEl, board, nr, nc);
                            }
                        }
                    }
                } else if (value > 0) {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                }
            }

            checkMinesweeperWin(boardEl, board, config, onWin) {
                const allCells = boardEl.querySelectorAll('button');
                let revealedCount = 0;
                let totalCells = config.rows * config.cols;

                allCells.forEach(btn => {
                    if (btn.disabled && btn.textContent !== '💣') {
                        revealedCount++;
                    }
                });

                // Win if all non-mine cells are revealed
                if (revealedCount === totalCells - config.mines) {
                    setTimeout(() => {
                        alert('🎉 Congratulations! You won!');
                        onWin();
                    }, 100);
                }
            }

            revealCell(boardEl, board, row, col) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === '🚩') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === -1) {
                    cellBtn.textContent = '💣';
                    alert('Game Over! You hit a mine!');
                } else if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            this.revealCell(boardEl, board, row + dr, col + dc);
                        }
                    }
                } else {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                }
            }

            toggleFlag(cellBtn) {
                if (cellBtn.disabled) return;
                const flagCount = document.getElementById('flag-count');
                if (cellBtn.textContent === '🚩') {
                    cellBtn.textContent = '';
                    if (flagCount) flagCount.textContent = parseInt(flagCount.textContent) - 1;
                } else {
                    cellBtn.textContent = '🚩';
                    if (flagCount) flagCount.textContent = parseInt(flagCount.textContent) + 1;
                }
            }

            openInternetExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Create IE toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.ieNavigate('back')" title="Back">◀</button>
                    <button class="btn" onclick="emulator.ieNavigate('forward')" title="Forward">▶</button>
                    <button class="btn" onclick="emulator.ieNavigate('refresh')" title="Refresh">🔄</button>
                    <button class="btn" onclick="emulator.ieNavigate('home')" title="Home">🏠</button>
                    <button class="btn" onclick="emulator.ieNavigate('stop')" title="Stop">⏹</button>
                    <div style="flex: 1; display: flex; align-items: center; gap: 4px; margin-left: 4px;">
                        <span style="font-size: 11px; font-weight: bold;">Address:</span>
                        <input type="text" id="ie-address-bar" value="https://example.com"
                            style="flex: 1; padding: 2px 4px; border: 1px solid var(--button-shadow); font-size: 11px;"
                            onkeypress="if(event.key==='Enter') emulator.ieNavigate('go')">
                        <button class="btn" onclick="emulator.ieNavigate('go')">Go</button>
                    </div>
                `;

                // Create status bar
                const statusBar = document.createElement('div');
                statusBar.style.cssText = 'background: var(--button-face); border-top: 1px solid var(--button-highlight); padding: 2px 4px; font-size: 11px; display: flex; align-items: center; gap: 8px;';
                statusBar.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div class="led" id="ie-status-led"></div>
                        <span id="ie-status-text">Ready</span>
                    </div>
                    <div style="flex: 1;"></div>
                    <span style="font-size: 10px;">Internet zone</span>
                `;

                // Create iframe container
                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = 'flex: 1; background: white; position: relative; overflow: hidden;';

                const iframe = document.createElement('iframe');
                iframe.id = 'ie-browser-frame';
                iframe.src = 'https://example.com';
                iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
                iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox';

                // Loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'ie-loading';
                loadingDiv.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; background: #ffffcc; padding: 4px 8px; font-size: 11px; border-bottom: 1px solid #808080; display: none;';
                loadingDiv.innerHTML = '⏳ Loading page...';

                iframeContainer.appendChild(loadingDiv);
                iframeContainer.appendChild(iframe);

                // Assemble the browser
                content.appendChild(toolbar);
                content.appendChild(iframeContainer);
                content.appendChild(statusBar);

                // Create window
                const win = this.windowManager.createWindow('Internet Explorer', content, {
                    width: 600,
                    height: 500,
                    x: 50,
                    y: 50
                });

                // Store current window ID for navigation
                this.currentIEWindowId = win.id;

                // Setup iframe event listeners
                iframe.addEventListener('load', () => {
                    const led = document.getElementById('ie-status-led');
                    const statusText = document.getElementById('ie-status-text');
                    const loading = document.getElementById('ie-loading');

                    if (led) led.classList.remove('active');
                    if (statusText) statusText.textContent = 'Done';
                    if (loading) loading.style.display = 'none';

                    // Try to update address bar with current URL (won't work for cross-origin)
                    try {
                        const addressBar = document.getElementById('ie-address-bar');
                        if (addressBar && iframe.contentWindow) {
                            addressBar.value = iframe.contentWindow.location.href;
                        }
                    } catch (e) {
                        // Cross-origin, can't access
                    }
                });

                // Show loading state
                const led = document.getElementById('ie-status-led');
                const statusText = document.getElementById('ie-status-text');
                const loading = document.getElementById('ie-loading');
                if (led) led.classList.add('active');
                if (statusText) statusText.textContent = 'Loading...';
                if (loading) loading.style.display = 'block';
            }

            ieNavigate(action) {
                const iframe = document.getElementById('ie-browser-frame');
                const addressBar = document.getElementById('ie-address-bar');
                const led = document.getElementById('ie-status-led');
                const statusText = document.getElementById('ie-status-text');
                const loading = document.getElementById('ie-loading');

                if (!iframe) return;

                try {
                    switch (action) {
                        case 'back':
                            window.history.back();
                            break;
                        case 'forward':
                            window.history.forward();
                            break;
                        case 'refresh':
                            iframe.src = iframe.src;
                            if (led) led.classList.add('active');
                            if (statusText) statusText.textContent = 'Refreshing...';
                            if (loading) loading.style.display = 'block';
                            break;
                        case 'home':
                            iframe.src = 'https://example.com';
                            if (addressBar) addressBar.value = 'https://example.com';
                            if (led) led.classList.add('active');
                            if (statusText) statusText.textContent = 'Loading home page...';
                            if (loading) loading.style.display = 'block';
                            break;
                        case 'stop':
                            iframe.src = '';
                            if (led) led.classList.remove('active');
                            if (statusText) statusText.textContent = 'Stopped';
                            if (loading) loading.style.display = 'none';
                            break;
                        case 'go':
                            if (addressBar) {
                                let url = addressBar.value.trim();

                                // Add protocol if missing
                                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                                    url = 'https://' + url;
                                }

                                iframe.src = url;
                                if (led) led.classList.add('active');
                                if (statusText) statusText.textContent = 'Connecting...';
                                if (loading) loading.style.display = 'block';
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Navigation error:', error);
                    if (statusText) statusText.textContent = 'Error loading page';
                    if (led) led.classList.remove('active');
                    if (loading) loading.style.display = 'none';
                }
            }

            openPaint() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Paint toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; flex-wrap: wrap;';
                toolbar.innerHTML = `
                    <button class="btn" id="tool-pencil" title="Pencil" onclick="emulator.paintSetTool('pencil')" style="background: #e0e0e0;">✏️</button>
                    <button class="btn" id="tool-brush" title="Brush" onclick="emulator.paintSetTool('brush')">🖌️</button>
                    <button class="btn" id="tool-spray" title="Spray Paint" onclick="emulator.paintSetTool('spray')">💨</button>
                    <button class="btn" id="tool-line" title="Line" onclick="emulator.paintSetTool('line')">📏</button>
                    <button class="btn" id="tool-rect" title="Rectangle" onclick="emulator.paintSetTool('rect')">▭</button>
                    <button class="btn" id="tool-filled-rect" title="Filled Rectangle" onclick="emulator.paintSetTool('filled-rect')">◼️</button>
                    <button class="btn" id="tool-circle" title="Circle" onclick="emulator.paintSetTool('circle')">○</button>
                    <button class="btn" id="tool-filled-circle" title="Filled Circle" onclick="emulator.paintSetTool('filled-circle')">⬤</button>
                    <button class="btn" id="tool-fill" title="Fill" onclick="emulator.paintSetTool('fill')">🪣</button>
                    <button class="btn" id="tool-eraser" title="Eraser" onclick="emulator.paintSetTool('eraser')">🧹</button>
                    <button class="btn" onclick="emulator.paintClear()">Clear</button>
                    <button class="btn" onclick="emulator.paintSave()">💾 Save</button>
                    <div style="display: flex; gap: 2px; align-items: center; margin-left: auto;">
                        <span style="font-size: 11px;">Color:</span>
                        <input type="color" id="paint-color" value="#000000" style="width: 40px; height: 22px; border: 1px solid var(--button-shadow);">
                        <span style="font-size: 11px;">Size:</span>
                        <input type="range" id="paint-size" min="1" max="30" value="3" style="width: 80px;">
                        <span id="paint-size-display" style="font-size: 11px; min-width: 25px;">3px</span>
                    </div>
                `;

                // Canvas container
                const canvasContainer = document.createElement('div');
                canvasContainer.style.cssText = 'flex: 1; background: white; overflow: auto; position: relative;';

                const canvas = document.createElement('canvas');
                canvas.id = 'paint-canvas';
                canvas.width = 640;
                canvas.height = 480;
                canvas.style.cssText = 'display: block; cursor: crosshair; background: white;';

                canvasContainer.appendChild(canvas);
                content.appendChild(toolbar);
                content.appendChild(canvasContainer);

                this.windowManager.createWindow('Paint', content, { width: 680, height: 560 });

                // Initialize paint
                this.initPaint(canvas);
            }

            initPaint(canvas) {
                const ctx = canvas.getContext('2d');
                let isDrawing = false;
                let startX, startY;
                let currentTool = 'pencil';
                let tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;

                // Initialize white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                this.paintSetTool = (tool) => {
                    currentTool = tool;
                    // Highlight selected tool
                    document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                        btn.style.background = '';
                    });
                    const toolBtn = document.getElementById(`tool-${tool}`);
                    if (toolBtn) toolBtn.style.background = '#e0e0e0';
                };

                this.paintClear = () => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                };

                this.paintSave = () => {
                    const dataURL = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'paint-' + Date.now() + '.png';
                    link.href = dataURL;
                    link.click();
                };

                // Update size display
                const sizeInput = document.getElementById('paint-size');
                const sizeDisplay = document.getElementById('paint-size-display');
                if (sizeInput && sizeDisplay) {
                    sizeInput.addEventListener('input', (e) => {
                        sizeDisplay.textContent = e.target.value + 'px';
                    });
                }

                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;

                    // Save current canvas state
                    tempCanvas.getContext('2d').drawImage(canvas, 0, 0);

                    const colorInput = document.getElementById('paint-color');
                    const sizeInput = document.getElementById('paint-size');
                    if (colorInput) ctx.strokeStyle = colorInput.value;
                    if (colorInput) ctx.fillStyle = colorInput.value;
                    if (sizeInput) ctx.lineWidth = parseInt(sizeInput.value);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    if (currentTool === 'pencil' || currentTool === 'brush') {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!isDrawing) return;

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (currentTool === 'pencil' || currentTool === 'brush') {
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    } else if (currentTool === 'spray') {
                        // Spray paint effect
                        const density = ctx.lineWidth * 2;
                        for (let i = 0; i < density; i++) {
                            const offsetX = (Math.random() - 0.5) * ctx.lineWidth * 2;
                            const offsetY = (Math.random() - 0.5) * ctx.lineWidth * 2;
                            ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
                        }
                    } else if (currentTool === 'eraser') {
                        ctx.clearRect(x - ctx.lineWidth/2, y - ctx.lineWidth/2, ctx.lineWidth, ctx.lineWidth);
                    } else {
                        // For shapes, restore canvas and draw preview
                        ctx.putImageData(tempCanvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height), 0, 0);

                        if (currentTool === 'line') {
                            ctx.beginPath();
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        } else if (currentTool === 'rect') {
                            ctx.strokeRect(startX, startY, x - startX, y - startY);
                        } else if (currentTool === 'filled-rect') {
                            ctx.fillRect(startX, startY, x - startX, y - startY);
                        } else if (currentTool === 'circle') {
                            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            ctx.beginPath();
                            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        } else if (currentTool === 'filled-circle') {
                            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            ctx.beginPath();
                            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    if (!isDrawing) return;
                    isDrawing = false;

                    const rect = canvas.getBoundingClientRect();
                    const x = Math.floor(e.clientX - rect.left);
                    const y = Math.floor(e.clientY - rect.top);

                    if (currentTool === 'fill') {
                        // Flood fill algorithm
                        const colorInput = document.getElementById('paint-color');
                        if (!colorInput) return;

                        const fillColor = this.hexToRgb(colorInput.value);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const targetColor = this.getPixelColor(imageData, x, y);

                        // Don't fill if target color is same as fill color
                        if (this.colorsMatch(targetColor, fillColor)) return;

                        this.floodFill(imageData, x, y, targetColor, fillColor, canvas.width, canvas.height);
                        ctx.putImageData(imageData, 0, 0);
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    isDrawing = false;
                });

                // Clear canvas initially
                this.paintClear();
            }

            // Paint helper functions
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16),
                    a: 255
                } : null;
            }

            getPixelColor(imageData, x, y) {
                const index = (y * imageData.width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }

            setPixelColor(imageData, x, y, color) {
                const index = (y * imageData.width + x) * 4;
                imageData.data[index] = color.r;
                imageData.data[index + 1] = color.g;
                imageData.data[index + 2] = color.b;
                imageData.data[index + 3] = color.a;
            }

            colorsMatch(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
            }

            floodFill(imageData, x, y, targetColor, fillColor, width, height) {
                // Stack-based flood fill to avoid recursion stack overflow
                const stack = [[x, y]];
                const visited = new Set();

                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    const key = `${cx},${cy}`;

                    if (visited.has(key)) continue;
                    if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;

                    visited.add(key);

                    const currentColor = this.getPixelColor(imageData, cx, cy);
                    if (!this.colorsMatch(currentColor, targetColor)) continue;

                    this.setPixelColor(imageData, cx, cy, fillColor);

                    // Add neighboring pixels
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            openFileExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.explorerNavigate('back')" title="Back">◀</button>
                    <button class="btn" onclick="emulator.explorerNavigate('up')" title="Up">⬆</button>
                    <div style="flex: 1; margin: 0 4px; padding: 2px 4px; border: 1px solid var(--button-shadow); background: white; font-size: 11px;" id="explorer-path">
                        C:\\
                    </div>
                `;

                // Main container with splitter
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; flex: 1; overflow: hidden;';

                // Tree view (left panel)
                const treePanel = document.createElement('div');
                treePanel.id = 'explorer-tree';
                treePanel.style.cssText = 'width: 200px; background: white; border-right: 1px solid #808080; border-top: 2px inset; overflow-y: auto; font-size: 11px; padding: 4px;';

                // Content area (right panel)
                const contentArea = document.createElement('div');
                contentArea.id = 'explorer-content';
                contentArea.style.cssText = 'flex: 1; background: white; padding: 8px; overflow: auto; border-top: 2px inset;';

                mainContainer.appendChild(treePanel);
                mainContainer.appendChild(contentArea);

                content.appendChild(toolbar);
                content.appendChild(mainContainer);

                this.windowManager.createWindow('Windows Explorer', content, { width: 600, height: 450 });

                this.initFileExplorer();
            }

            initFileExplorer() {
                this.fileSystem = {
                    'C:\\': {
                        type: 'folder',
                        contents: {
                            'Windows': { type: 'folder', contents: {} },
                            'Program Files': { type: 'folder', contents: {} },
                            'My Documents': {
                                type: 'folder',
                                contents: {
                                    'readme.txt': { type: 'file', size: '1 KB' },
                                    'notes.txt': { type: 'file', size: '2 KB' }
                                }
                            },
                            'autoexec.bat': { type: 'file', size: '156 bytes' },
                            'config.sys': { type: 'file', size: '89 bytes' }
                        }
                    }
                };

                this.currentPath = 'C:\\';
                this.explorerHistory = ['C:\\'];
                this.explorerHistoryIndex = 0;

                this.explorerNavigate = (action) => {
                    if (action === 'back' && this.explorerHistoryIndex > 0) {
                        this.explorerHistoryIndex--;
                        this.currentPath = this.explorerHistory[this.explorerHistoryIndex];
                        this.renderExplorer();
                    } else if (action === 'up') {
                        const parts = this.currentPath.split('\\').filter(p => p);
                        if (parts.length > 1) {
                            parts.pop();
                            this.currentPath = parts.join('\\') + '\\';
                            if (!this.currentPath.includes(':\\')) {
                                this.currentPath = parts[0] + ':\\' + this.currentPath.split(':\\')[1];
                            }
                            this.addToHistory(this.currentPath);
                            this.renderExplorer();
                        }
                    }
                };

                this.explorerOpenFolder = (name) => {
                    this.currentPath = this.currentPath + name + '\\';
                    this.addToHistory(this.currentPath);
                    this.renderExplorer();
                };

                this.addToHistory = (path) => {
                    this.explorerHistory = this.explorerHistory.slice(0, this.explorerHistoryIndex + 1);
                    this.explorerHistory.push(path);
                    this.explorerHistoryIndex = this.explorerHistory.length - 1;
                };

                this.renderExplorer();
                this.buildExplorerTree();
            }

            buildExplorerTree() {
                const treePanel = document.getElementById('explorer-tree');
                if (!treePanel) return;

                treePanel.innerHTML = '';

                const buildNode = (name, item, path, indent = 0) => {
                    const node = document.createElement('div');
                    node.style.cssText = `padding: 2px 2px 2px ${indent * 12 + 4}px; cursor: pointer; user-select: none;`;
                    node.innerHTML = (item.type === 'folder' ? '📁 ' : '📄 ') + name;

                    node.onclick = () => {
                        if (item.type === 'folder') {
                            this.currentPath = path;
                            this.addToHistory(path);
                            this.renderExplorer();

                            // Highlight selected
                            treePanel.querySelectorAll('div').forEach(d => d.style.background = 'white');
                            node.style.background = '#000080';
                            node.style.color = 'white';
                        }
                    };

                    treePanel.appendChild(node);

                    // Recursively build children
                    if (item.type === 'folder' && item.contents) {
                        Object.keys(item.contents).sort().forEach(childName => {
                            const childPath = path + childName + (item.contents[childName].type === 'folder' ? '\\' : '');
                            buildNode(childName, item.contents[childName], childPath, indent + 1);
                        });
                    }
                };

                // Build root
                const rootNode = document.createElement('div');
                rootNode.style.cssText = 'padding: 2px 4px; cursor: pointer; font-weight: bold; user-select: none; background: #000080; color: white;';
                rootNode.innerHTML = '💻 My Computer';
                rootNode.onclick = () => {
                    this.currentPath = 'C:\\';
                    this.addToHistory('C:\\');
                    this.renderExplorer();
                };
                treePanel.appendChild(rootNode);

                // Build C:\ and its contents
                const cDrive = this.fileSystem['C:\\'];
                if (cDrive.contents) {
                    Object.keys(cDrive.contents).sort().forEach(name => {
                        buildNode(name, cDrive.contents[name], 'C:\\' + name + (cDrive.contents[name].type === 'folder' ? '\\' : ''), 1);
                    });
                }
            }

            renderExplorer() {
                const contentArea = document.getElementById('explorer-content');
                const pathDisplay = document.getElementById('explorer-path');

                if (!contentArea || !pathDisplay) return;

                pathDisplay.textContent = this.currentPath;

                // Get current folder contents
                const parts = this.currentPath.split('\\').filter(p => p);
                let current = this.fileSystem['C:\\'];

                for (let i = 1; i < parts.length; i++) {
                    if (current.contents && current.contents[parts[i]]) {
                        current = current.contents[parts[i]];
                    }
                }

                // Render contents as detailed list
                contentArea.innerHTML = '';

                // Header
                const header = document.createElement('div');
                header.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 4px; background: #c0c0c0; border-bottom: 1px solid #808080; font-weight: bold;';
                header.innerHTML = `
                    <div>Name</div>
                    <div>Type</div>
                    <div>Size</div>
                `;
                contentArea.appendChild(header);

                if (current.contents) {
                    Object.keys(current.contents).sort().forEach(name => {
                        const item = current.contents[name];
                        const itemEl = document.createElement('div');
                        itemEl.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        itemEl.innerHTML = `
                            <div>${item.type === 'folder' ? '📁' : '📄'} ${name}</div>
                            <div>${item.type === 'folder' ? 'File Folder' : 'Text Document'}</div>
                            <div>${item.size || ''}</div>
                        `;

                        itemEl.onclick = () => {
                            // Highlight selected
                            contentArea.querySelectorAll('div[style*="grid"]').forEach(d => {
                                if (d !== header) d.style.background = 'white';
                            });
                            itemEl.style.background = '#000080';
                            itemEl.style.color = 'white';
                        };

                        if (item.type === 'folder') {
                            itemEl.addEventListener('dblclick', () => this.explorerOpenFolder(name));
                        } else {
                            itemEl.addEventListener('dblclick', () => {
                                this.openNotepad();
                            });
                        }

                        contentArea.appendChild(itemEl);
                    });
                } else {
                    contentArea.innerHTML += '<div style="padding: 20px; color: #808080;">Folder is empty</div>';
                }
            }

            openDOSPrompt() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';

                const output = document.createElement('div');
                output.id = 'terminal-output';
                output.style.cssText = 'flex: 1; padding: 8px; overflow-y: auto; white-space: pre-wrap;';
                output.innerHTML = `Linux Terminal Emulator v1.0
Type 'help' for available commands

user@win95:~$ `;

                const inputLine = document.createElement('div');
                inputLine.style.cssText = 'display: flex; padding: 0 8px 8px 8px;';
                inputLine.innerHTML = `
                    <span id="terminal-prompt" style="margin-right: 4px; color: #0f0;">user@win95:~$</span>
                    <input type="text" id="terminal-input" style="flex: 1; background: #000; color: #0f0; border: none; outline: none; font-family: 'Courier New', monospace; font-size: 13px;">
                `;

                content.appendChild(output);
                content.appendChild(inputLine);

                this.windowManager.createWindow('Linux Terminal', content, { width: 700, height: 450 });

                // Initialize Linux terminal
                this.initLinuxTerminal();
            }

            initLinuxTerminal() {
                // Load filesystem from localStorage or use default
                const savedFS = SafeStorage.getItem('win95-linux-filesystem');

                if (savedFS) {
                    try {
                        this.linuxFS = JSON.parse(savedFS);
                        console.log('Loaded persistent filesystem from storage');
                    } catch (error) {
                        console.error('Failed to load filesystem, using default:', error);
                        this.initDefaultLinuxFS();
                    }
                } else {
                    this.initDefaultLinuxFS();
                }

                // Load terminal history
                const savedHistory = SafeStorage.getItem('win95-terminal-history');
                if (savedHistory) {
                    try {
                        this.terminalHistory = JSON.parse(savedHistory);
                    } catch (error) {
                        this.terminalHistory = [];
                    }
                } else {
                    this.terminalHistory = [];
                }

                this.terminalCwd = '/home/user';
                this.terminalHistoryIndex = -1;
                this.terminalEnv = {
                    USER: 'user',
                    HOME: '/home/user',
                    PATH: '/bin:/usr/bin',
                    PWD: '/home/user'
                };

                const input = document.getElementById('terminal-input');
                const prompt = document.getElementById('terminal-prompt');

                if (input) {
                    input.focus();

                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            const command = input.value.trim();
                            if (command) {
                                this.terminalHistory.push(command);
                                this.terminalHistoryIndex = this.terminalHistory.length;
                                this.saveTerminalHistory(); // Save history after each command
                                this.executeLinuxCommand(command);
                            } else {
                                this.terminalPrint('');
                            }
                            input.value = '';
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            if (this.terminalHistoryIndex > 0) {
                                this.terminalHistoryIndex--;
                                input.value = this.terminalHistory[this.terminalHistoryIndex];
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (this.terminalHistoryIndex < this.terminalHistory.length - 1) {
                                this.terminalHistoryIndex++;
                                input.value = this.terminalHistory[this.terminalHistoryIndex];
                            } else {
                                this.terminalHistoryIndex = this.terminalHistory.length;
                                input.value = '';
                            }
                        } else if (e.key === 'Tab') {
                            e.preventDefault();
                            // Tab completion could be added here
                        }
                    });
                }
            }

            initDefaultLinuxFS() {
                // Initialize default filesystem structure
                this.linuxFS = {
                    '/': {
                        type: 'dir',
                        contents: {
                            'home': {
                                type: 'dir',
                                contents: {
                                    'user': {
                                        type: 'dir',
                                        contents: {
                                            'welcome.txt': { type: 'file', content: 'Welcome to the Linux Terminal Emulator!\nType commands like ls, cat, echo, etc.\nFiles you create will be saved automatically.' },
                                            'notes.txt': { type: 'file', content: 'This is a persistent text file.\nYour changes are saved automatically!' }
                                        }
                                    }
                                }
                            },
                            'bin': { type: 'dir', contents: {} },
                            'etc': { type: 'dir', contents: {} },
                            'var': { type: 'dir', contents: {} },
                            'tmp': { type: 'dir', contents: {} }
                        }
                    }
                };
                this.saveLinuxFilesystem();
            }

            saveLinuxFilesystem() {
                // Save filesystem to localStorage
                try {
                    SafeStorage.setItem('win95-linux-filesystem', JSON.stringify(this.linuxFS));
                    console.log('Filesystem saved to storage');
                } catch (error) {
                    console.error('Failed to save filesystem:', error);
                }
            }

            saveTerminalHistory() {
                // Save terminal history to localStorage
                try {
                    // Keep only last 100 commands to avoid storage limits
                    const historyToSave = this.terminalHistory.slice(-100);
                    SafeStorage.setItem('win95-terminal-history', JSON.stringify(historyToSave));
                } catch (error) {
                    console.error('Failed to save terminal history:', error);
                }
            }

            resetLinuxFilesystem() {
                // Reset to default filesystem (utility command)
                if (confirm('Reset filesystem to default? All files will be lost.')) {
                    this.initDefaultLinuxFS();
                    return 'Filesystem reset to default';
                }
                return 'Reset cancelled';
            }

            terminalPrint(text, color = '#0f0') {
                const output = document.getElementById('terminal-output');
                if (!output) return;

                const promptText = this.getTerminalPrompt();
                output.innerHTML += `<span style="color: ${color}">${text}</span>\n${promptText}`;
                output.scrollTop = output.scrollHeight;
            }

            getTerminalPrompt() {
                const shortPath = this.terminalCwd.replace('/home/user', '~');
                return `<span style="color: #0f0;">user@win95</span>:<span style="color: #00f;">${shortPath}</span>$ `;
            }

            executeLinuxCommand(cmdLine) {
                const output = document.getElementById('terminal-output');
                const prompt = document.getElementById('terminal-prompt');

                if (!output) return;

                // Echo command
                output.innerHTML += cmdLine + '\n';

                const parts = cmdLine.trim().split(/\s+/);
                const cmd = parts[0];
                const args = parts.slice(1);

                let response = '';

                switch (cmd) {
                    case 'help':
                        response = `Available commands:

File Operations:
  ls [-la]          - List directory contents
  cd <dir>          - Change directory
  pwd               - Print working directory
  cat <file>        - Display file contents
  mkdir <dir>       - Create directory
  touch <file>      - Create empty file
  rm <file>         - Remove file
  tree              - Show directory tree
  find <dir>        - Search for files
  grep <pat> <file> - Search in files

System Info:
  whoami            - Print current user
  hostname          - Print system name
  uname [-a]        - Print system information
  date              - Display date and time
  uptime            - Show system uptime
  env               - Show environment variables
  export VAR=value  - Set environment variable

Process Management:
  ps                - Show processes
  top               - Display system resource usage
  df                - Show disk usage
  free              - Display memory usage
  which <cmd>       - Locate command

Utilities:
  echo <text>       - Print text
  history           - Show command history
  cal               - Display calendar
  cowsay <text>     - ASCII cow speaks
  fortune           - Random fortune cookie
  clear             - Clear screen
  reset             - Reset filesystem to default
  exit              - Close terminal`;
                        break;

                    case 'ls':
                        response = this.terminalLs(args);
                        break;

                    case 'cd':
                        response = this.terminalCd(args[0] || this.terminalEnv.HOME);
                        break;

                    case 'pwd':
                        response = this.terminalCwd;
                        break;

                    case 'cat':
                        response = this.terminalCat(args[0]);
                        break;

                    case 'echo':
                        response = args.join(' ');
                        break;

                    case 'mkdir':
                        response = this.terminalMkdir(args[0]);
                        break;

                    case 'touch':
                        response = this.terminalTouch(args[0]);
                        break;

                    case 'rm':
                        response = this.terminalRm(args[0]);
                        break;

                    case 'clear':
                        output.innerHTML = this.getTerminalPrompt();
                        if (prompt) prompt.innerHTML = this.getTerminalPrompt();
                        return;

                    case 'whoami':
                        response = this.terminalEnv.USER;
                        break;

                    case 'uname':
                        if (args[0] === '-a') {
                            response = 'Linux win95 5.15.0 #1 SMP x86_64 GNU/Linux';
                        } else {
                            response = 'Linux';
                        }
                        break;

                    case 'date':
                        response = new Date().toString();
                        break;

                    case 'env':
                        response = Object.entries(this.terminalEnv)
                            .map(([k, v]) => `${k}=${v}`)
                            .join('\n');
                        break;

                    case 'export':
                        if (args[0]) {
                            const [key, value] = args[0].split('=');
                            this.terminalEnv[key] = value || '';
                            response = '';
                        } else {
                            response = 'Usage: export VAR=value';
                        }
                        break;

                    case 'tree':
                        response = this.terminalTree();
                        break;

                    case 'grep':
                        response = this.terminalGrep(args);
                        break;

                    case 'find':
                        response = this.terminalFind(args[0] || this.terminalCwd);
                        break;

                    case 'ps':
                        response = this.terminalPs();
                        break;

                    case 'top':
                        response = this.terminalTop();
                        break;

                    case 'df':
                        response = this.terminalDf();
                        break;

                    case 'free':
                        response = this.terminalFree();
                        break;

                    case 'history':
                        response = this.terminalHistory.map((h, i) => `  ${i + 1}  ${h}`).join('\n');
                        break;

                    case 'hostname':
                        response = 'win95';
                        break;

                    case 'uptime':
                        const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                        const hours = Math.floor(uptime / 3600);
                        const mins = Math.floor((uptime % 3600) / 60);
                        response = `up ${hours}:${String(mins).padStart(2, '0')}, 1 user, load average: 0.15, 0.10, 0.05`;
                        break;

                    case 'which':
                        if (args[0]) {
                            const cmds = ['ls', 'cd', 'pwd', 'cat', 'echo', 'mkdir', 'touch', 'rm', 'clear', 'help'];
                            response = cmds.includes(args[0]) ? `/bin/${args[0]}` : `${args[0]} not found`;
                        } else {
                            response = 'which: missing argument';
                        }
                        break;

                    case 'cal':
                        response = this.terminalCal();
                        break;

                    case 'cowsay':
                        response = this.terminalCowsay(args.join(' '));
                        break;

                    case 'fortune':
                        const fortunes = [
                            'You will have a pleasant surprise today.',
                            'A new opportunity is coming your way.',
                            'Good things come to those who code.',
                            'Your hard work will pay off soon.',
                            'Today is a perfect day to learn something new.'
                        ];
                        response = fortunes[Math.floor(Math.random() * fortunes.length)];
                        break;

                    case 'reset':
                        response = this.resetLinuxFilesystem();
                        break;

                    case 'exit':
                        const win = output?.closest('.window');
                        if (win) this.windowManager.closeWindow(win);
                        return;

                    case '':
                        response = '';
                        break;

                    default:
                        response = `bash: ${cmd}: command not found`;
                        break;
                }

                this.terminalPrint(response);

                // Update prompt
                if (prompt) {
                    const shortPath = this.terminalCwd.replace('/home/user', '~');
                    prompt.innerHTML = `<span style="color: #0f0;">user@win95</span>:<span style="color: #00f;">${shortPath}</span>$ `;
                }
            }

            terminalLs(args) {
                const showAll = args.includes('-a') || args.includes('-la');
                const longFormat = args.includes('-l') || args.includes('-la');

                const current = this.terminalGetDir(this.terminalCwd);
                if (!current || current.type !== 'dir') {
                    return 'ls: cannot access directory';
                }

                const items = Object.keys(current.contents || {});
                if (items.length === 0) return '';

                if (longFormat) {
                    return items.map(name => {
                        const item = current.contents[name];
                        const type = item.type === 'dir' ? 'd' : '-';
                        const perms = item.type === 'dir' ? 'rwxr-xr-x' : 'rw-r--r--';
                        const size = item.type === 'file' ? (item.content?.length || 0) : 4096;
                        const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        return `${type}${perms} 1 user user ${size.toString().padStart(5)} ${date} ${name}`;
                    }).join('\n');
                } else {
                    return items.join('  ');
                }
            }

            terminalCd(path) {
                if (!path) path = this.terminalEnv.HOME;

                let newPath;
                if (path.startsWith('/')) {
                    newPath = path;
                } else if (path === '..') {
                    const parts = this.terminalCwd.split('/').filter(p => p);
                    parts.pop();
                    newPath = '/' + parts.join('/');
                    if (newPath === '/') newPath = '/';
                } else if (path === '.') {
                    return '';
                } else if (path === '~') {
                    newPath = this.terminalEnv.HOME;
                } else {
                    newPath = this.terminalCwd + (this.terminalCwd.endsWith('/') ? '' : '/') + path;
                }

                const dir = this.terminalGetDir(newPath);
                if (!dir || dir.type !== 'dir') {
                    return `cd: ${path}: No such file or directory`;
                }

                this.terminalCwd = newPath === '' ? '/' : newPath;
                this.terminalEnv.PWD = this.terminalCwd;
                return '';
            }

            terminalCat(filename) {
                if (!filename) return 'cat: missing file operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const file = this.terminalGetDir(path);

                if (!file) {
                    return `cat: ${filename}: No such file or directory`;
                }

                if (file.type === 'dir') {
                    return `cat: ${filename}: Is a directory`;
                }

                return file.content || '';
            }

            terminalMkdir(dirname) {
                if (!dirname) return 'mkdir: missing operand';

                const path = dirname.startsWith('/') ? dirname : this.terminalCwd + '/' + dirname;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `mkdir: cannot create directory '${dirname}': No such file or directory`;
                }

                if (parent.contents[name]) {
                    return `mkdir: cannot create directory '${dirname}': File exists`;
                }

                parent.contents[name] = { type: 'dir', contents: {} };
                this.saveLinuxFilesystem(); // Save after modification
                return '';
            }

            terminalTouch(filename) {
                if (!filename) return 'touch: missing file operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `touch: cannot touch '${filename}': No such file or directory`;
                }

                if (!parent.contents[name]) {
                    parent.contents[name] = { type: 'file', content: '' };
                    this.saveLinuxFilesystem(); // Save after modification
                }

                return '';
            }

            terminalRm(filename) {
                if (!filename) return 'rm: missing operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `rm: cannot remove '${filename}': No such file or directory`;
                }

                if (!parent.contents[name]) {
                    return `rm: cannot remove '${filename}': No such file or directory`;
                }

                if (parent.contents[name].type === 'dir') {
                    return `rm: cannot remove '${filename}': Is a directory`;
                }

                delete parent.contents[name];
                this.saveLinuxFilesystem(); // Save after modification
                return '';
            }

            terminalTree(dir = this.terminalCwd, prefix = '', isLast = true) {
                const current = this.terminalGetDir(dir);
                if (!current || current.type !== 'dir') return '';

                let result = '';
                const items = Object.keys(current.contents || {});

                items.forEach((name, index) => {
                    const item = current.contents[name];
                    const isLastItem = index === items.length - 1;
                    const connector = isLastItem ? '└── ' : '├── ';
                    const icon = item.type === 'dir' ? '📁' : '📄';

                    result += prefix + connector + icon + ' ' + name + '\n';

                    if (item.type === 'dir') {
                        const newPrefix = prefix + (isLastItem ? '    ' : '│   ');
                        const subPath = dir + (dir.endsWith('/') ? '' : '/') + name;
                        result += this.terminalTree(subPath, newPrefix, isLastItem);
                    }
                });

                return result;
            }

            terminalGetDir(path) {
                if (!path || path === '/') return this.linuxFS['/'];

                const parts = path.split('/').filter(p => p);
                let current = this.linuxFS['/'];

                for (const part of parts) {
                    if (!current.contents || !current.contents[part]) {
                        return null;
                    }
                    current = current.contents[part];
                }

                return current;
            }

            terminalGrep(args) {
                if (args.length < 2) return 'grep: usage: grep PATTERN FILE';

                const pattern = args[0];
                const filename = args[1];

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const file = this.terminalGetDir(path);

                if (!file) return `grep: ${filename}: No such file or directory`;
                if (file.type === 'dir') return `grep: ${filename}: Is a directory`;

                const lines = (file.content || '').split('\n');
                const matches = lines.filter(line => line.includes(pattern));

                return matches.length > 0 ? matches.join('\n') : '';
            }

            terminalFind(dir) {
                const results = [];
                const search = (path, item) => {
                    results.push(path);
                    if (item.type === 'dir' && item.contents) {
                        Object.keys(item.contents).forEach(name => {
                            const newPath = path + (path.endsWith('/') ? '' : '/') + name;
                            search(newPath, item.contents[name]);
                        });
                    }
                };

                const startDir = this.terminalGetDir(dir);
                if (startDir) {
                    search(dir, startDir);
                }

                return results.join('\n');
            }

            terminalPs() {
                const processes = [
                    '  PID TTY          TIME CMD',
                    '    1 ?        00:00:01 init',
                    '    2 ?        00:00:00 kthreadd',
                    '  123 pts/0    00:00:00 bash',
                    '  456 pts/0    00:00:00 ps'
                ];
                return processes.join('\n');
            }

            terminalTop() {
                return `top - ${new Date().toLocaleTimeString()} up ${Math.floor((Date.now() - this.startTime) / 60000)} min, 1 user, load average: 0.15, 0.10, 0.05

Tasks:  85 total,   1 running,  84 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.3 us,  1.0 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  ${this.settings.memory / 1024 / 1024} total,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.6)} free,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.3)} used,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.1)} buff/cache

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0    2048    512    448 S   0.0   0.1   0:01.23 init
  123 user      20   0    4096   1024    896 S   0.0   0.3   0:00.45 bash
  456 user      20   0    2560    768    640 R   1.3   0.2   0:00.01 top`;
            }

            terminalDf() {
                return `Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda1       ${Math.floor(this.settings.memory / 1024)}    ${Math.floor(this.settings.memory / 1024 * 0.4)}    ${Math.floor(this.settings.memory / 1024 * 0.6)}  40% /
tmpfs               1024     128       896  13% /tmp`;
            }

            terminalFree() {
                const total = Math.floor(this.settings.memory / 1024);
                const used = Math.floor(total * 0.3);
                const free = total - used;

                return `              total        used        free      shared  buff/cache   available
Mem:          ${total}        ${used}        ${free}           0           0        ${free}
Swap:             0           0           0`;
            }

            terminalCal() {
                const now = new Date();
                const month = now.toLocaleString('default', { month: 'long' });
                const year = now.getFullYear();
                const firstDay = new Date(year, now.getMonth(), 1).getDay();
                const daysInMonth = new Date(year, now.getMonth() + 1, 0).getDate();

                let cal = `   ${month} ${year}\n`;
                cal += 'Su Mo Tu We Th Fr Sa\n';

                let day = 1;
                let week = '';

                // Add spaces for days before first day of month
                for (let i = 0; i < firstDay; i++) {
                    week += '   ';
                }

                // Add days
                for (let d = firstDay; d < 7 && day <= daysInMonth; d++) {
                    week += String(day).padStart(2, ' ') + ' ';
                    day++;
                }
                cal += week + '\n';

                // Rest of the weeks
                while (day <= daysInMonth) {
                    week = '';
                    for (let d = 0; d < 7 && day <= daysInMonth; d++) {
                        week += String(day).padStart(2, ' ') + ' ';
                        day++;
                    }
                    cal += week + '\n';
                }

                return cal;
            }

            terminalCowsay(message) {
                if (!message) message = 'Moo!';

                const len = message.length;
                const border = '-'.repeat(len + 2);

                return ` ${border}
< ${message} >
 ${border}
        \\   ^__^
         \\  (oo)\\_______
            (__)\\       )\\/\\
                ||----w |
                ||     ||`;
            }

            openSolitaire() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: linear-gradient(135deg, #0a5f0a 0%, #0d7d0d 100%); display: flex; flex-direction: column; height: 100%;';

                content.innerHTML = `
                    <style>
                        .sol-card {
                            transition: transform 0.2s, box-shadow 0.2s;
                            cursor: pointer;
                        }
                        .sol-card:hover {
                            transform: translateY(-5px);
                            box-shadow: 3px 3px 10px rgba(0,0,0,0.5) !important;
                        }
                        .sol-card.selected {
                            transform: translateY(-10px);
                            box-shadow: 0 0 15px rgba(255,255,100,0.8) !important;
                        }
                        .sol-pile.valid-drop {
                            background: rgba(100,255,100,0.3) !important;
                            border-color: #0f0 !important;
                        }
                    </style>
                    <div style="background: var(--button-face); padding: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border: 2px outset;">
                        <div>
                            <button class="btn" onclick="emulator.solitaireNewGame()">New Game</button>
                            <button class="btn" onclick="emulator.solitaireUndo()">Undo</button>
                            <button class="btn" onclick="emulator.solitaireHint()">Hint</button>
                        </div>
                        <div style="display: flex; gap: 12px; font-weight: bold;">
                            <span>Score: <span id="sol-score">0</span></span>
                            <span>Moves: <span id="sol-moves">0</span></span>
                            <span>Time: <span id="sol-time">0:00</span></span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 16px; justify-content: space-between;">
                        <div style="display: flex; gap: 10px;">
                            <div id="sol-stock" class="sol-pile" style="width: 70px; height: 100px; border: 2px dashed white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer;">🂠</div>
                            <div id="sol-waste" class="sol-pile" style="width: 70px; height: 100px; border: 2px dashed white; background: rgba(0,0,0,0.2); border-radius: 4px; position: relative;"></div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <div class="sol-foundation" data-suit="spades" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♠</div>
                            <div class="sol-foundation" data-suit="hearts" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♥</div>
                            <div class="sol-foundation" data-suit="clubs" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♣</div>
                            <div class="sol-foundation" data-suit="diamonds" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♦</div>
                        </div>
                    </div>

                    <div id="sol-tableau" style="display: flex; gap: 10px; flex: 1;">
                        ${Array.from({length: 7}, (_, i) => `
                            <div class="sol-column" data-column="${i}" style="flex: 1; min-height: 300px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 4px; padding: 4px; cursor: pointer; position: relative;">
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 12px; color: white; text-align: center; font-size: 11px;">
                        Goal: Move all cards to foundations (top right), building from Ace to King by suit.<br>
                        Build tableau in descending order, alternating colors. Double-click to auto-move to foundation.
                    </div>
                `;

                this.windowManager.createWindow('Solitaire', content, { width: 750, height: 600 });
                this.initSolitaire();
            }

            initSolitaire() {
                this.solitaireState = {
                    stock: [],
                    waste: [],
                    foundations: { spades: [], hearts: [], clubs: [], diamonds: [] },
                    tableau: Array.from({length: 7}, () => []),
                    selected: null,
                    moves: 0,
                    score: 0,
                    history: [],
                    startTime: Date.now(),
                    timerInterval: null
                };

                this.solitaireState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.solitaireState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    const timeEl = document.getElementById('sol-time');
                    if (timeEl) timeEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                this.solitaireNewGame();
            }

            solitaireNewGame() {
                if (!this.solitaireState) return;

                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const suitSymbols = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
                const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let deck = [];

                suits.forEach(suit => {
                    values.forEach((value, index) => {
                        deck.push({
                            suit, value,
                            rank: index + 1,
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            symbol: suitSymbols[suit],
                            faceUp: false
                        });
                    });
                });

                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                this.solitaireState.stock = [];
                this.solitaireState.waste = [];
                this.solitaireState.foundations = { spades: [], hearts: [], clubs: [], diamonds: [] };
                this.solitaireState.tableau = Array.from({length: 7}, () => []);
                this.solitaireState.selected = null;
                this.solitaireState.moves = 0;
                this.solitaireState.score = 0;
                this.solitaireState.history = [];
                this.solitaireState.startTime = Date.now();

                let cardIndex = 0;
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row <= col; row++) {
                        const card = deck[cardIndex++];
                        card.faceUp = (row === col);
                        this.solitaireState.tableau[col].push(card);
                    }
                }

                this.solitaireState.stock = deck.slice(cardIndex);
                this.playSoundEffect('deal');
                this.renderSolitaire();
            }

            solitaireUndo() {
                if (!this.solitaireState || this.solitaireState.history.length === 0) {
                    this.playSoundEffect('invalid');
                    return;
                }

                const lastState = this.solitaireState.history.pop();
                this.solitaireState.stock = JSON.parse(JSON.stringify(lastState.stock));
                this.solitaireState.waste = JSON.parse(JSON.stringify(lastState.waste));
                this.solitaireState.foundations = JSON.parse(JSON.stringify(lastState.foundations));
                this.solitaireState.tableau = JSON.parse(JSON.stringify(lastState.tableau));
                this.solitaireState.selected = null;
                this.solitaireState.moves = lastState.moves;
                this.solitaireState.score = lastState.score;
                this.playSoundEffect('place');
                this.renderSolitaire();
            }

            solitaireHint() {
                if (!this.solitaireState) return;

                for (let col = 0; col < 7; col++) {
                    const column = this.solitaireState.tableau[col];
                    if (column.length > 0) {
                        const card = column[column.length - 1];
                        if (card.faceUp && this.canMoveToFoundation(card)) {
                            alert(`Try moving the ${card.value}${card.symbol} from column ${col + 1} to its foundation!`);
                            return;
                        }
                    }
                }

                if (this.solitaireState.waste.length > 0) {
                    const card = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                    if (this.canMoveToFoundation(card)) {
                        alert(`Try moving the ${card.value}${card.symbol} from the waste pile to its foundation!`);
                        return;
                    }
                }

                alert('Try dealing from the stock, or look for cards that can be moved between tableau columns!');
            }

            renderSolitaire() {
                if (!this.solitaireState) return;

                const scoreEl = document.getElementById('sol-score');
                const movesEl = document.getElementById('sol-moves');
                if (scoreEl) scoreEl.textContent = this.solitaireState.score;
                if (movesEl) movesEl.textContent = this.solitaireState.moves;

                const stockEl = document.getElementById('sol-stock');
                if (stockEl) {
                    if (this.solitaireState.stock.length > 0) {
                        stockEl.innerHTML = '🂠';
                        stockEl.style.cursor = 'pointer';
                        stockEl.onclick = () => this.solitaireDealFromStock();
                    } else {
                        stockEl.innerHTML = '↻';
                        stockEl.style.cursor = 'pointer';
                        stockEl.onclick = () => this.solitaireResetStock();
                    }
                }

                const wasteEl = document.getElementById('sol-waste');
                if (wasteEl) {
                    wasteEl.innerHTML = '';
                    if (this.solitaireState.waste.length > 0) {
                        const topCard = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                        const cardEl = document.createElement('div');
                        cardEl.innerHTML = this.renderCard(topCard);
                        cardEl.onclick = () => this.solitaireClickWaste();
                        cardEl.ondblclick = () => this.solitaireAutoMoveToFoundation('waste', -1);
                        wasteEl.appendChild(cardEl);
                    }
                }

                document.querySelectorAll('.sol-foundation').forEach(foundationEl => {
                    const suit = foundationEl.dataset.suit;
                    const cards = this.solitaireState.foundations[suit];
                    const topCard = cards[cards.length - 1];
                    if (topCard) {
                        foundationEl.innerHTML = this.renderCard(topCard);
                    } else {
                        const symbols = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
                        const color = (suit === 'hearts' || suit === 'diamonds') ? '#ff4444' : 'white';
                        foundationEl.innerHTML = `<span style="color: ${color}; font-size: 30px;">${symbols[suit]}</span>`;
                    }
                    foundationEl.onclick = () => this.solitaireClickFoundation(suit);
                });

                document.querySelectorAll('.sol-column').forEach((columnEl, colIndex) => {
                    const cards = this.solitaireState.tableau[colIndex];
                    columnEl.innerHTML = '';

                    if (cards.length === 0) {
                        columnEl.onclick = () => this.solitaireClickColumn(colIndex);
                    } else {
                        cards.forEach((card, cardIndex) => {
                            const cardEl = document.createElement('div');
                            cardEl.style.cssText = `position: absolute; top: ${cardIndex * 25}px; left: 4px;`;
                            cardEl.className = 'sol-card';

                            if (card.faceUp) {
                                cardEl.innerHTML = this.renderCard(card);
                                cardEl.onclick = (e) => {
                                    e.stopPropagation();
                                    this.solitaireClickTableauCard(colIndex, cardIndex);
                                };
                                cardEl.ondblclick = (e) => {
                                    e.stopPropagation();
                                    this.solitaireAutoMoveToFoundation('tableau', colIndex);
                                };
                            } else {
                                cardEl.innerHTML = `<div style="width: 60px; height: 85px; background: linear-gradient(135deg, #1e3a8a, #1e40af); border: 2px solid #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);"><div style="font-size: 40px; color: rgba(255,255,255,0.3);">🂠</div></div>`;
                            }
                            columnEl.appendChild(cardEl);
                        });
                    }
                });

                const totalInFoundations = Object.values(this.solitaireState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundations === 52) {
                    clearInterval(this.solitaireState.timerInterval);
                    this.playSoundEffect('win');
                    setTimeout(() => {
                        alert(`🎉 You Won! Score: ${this.solitaireState.score}, Moves: ${this.solitaireState.moves}`);
                    }, 300);
                }
            }

            solitaireDealFromStock() {
                if (!this.solitaireState || this.solitaireState.stock.length === 0) return;
                this.saveHistory();
                const card = this.solitaireState.stock.pop();
                card.faceUp = true;
                this.solitaireState.waste.push(card);
                this.playSoundEffect('flip');
                this.renderSolitaire();
            }

            solitaireResetStock() {
                if (!this.solitaireState || this.solitaireState.waste.length === 0) return;
                this.saveHistory();
                this.solitaireState.stock = this.solitaireState.waste.reverse().map(card => {
                    card.faceUp = false;
                    return card;
                });
                this.solitaireState.waste = [];
                this.playSoundEffect('place');
                this.renderSolitaire();
            }

            solitaireClickWaste() {
                if (!this.solitaireState || this.solitaireState.waste.length === 0) return;
                const topCard = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                if (this.solitaireState.selected) {
                    this.solitaireState.selected = null;
                } else {
                    this.solitaireState.selected = { type: 'waste', card: topCard };
                }
                this.renderSolitaire();
            }

            solitaireClickFoundation(suit) {
                if (!this.solitaireState || !this.solitaireState.selected) return;
                const card = this.solitaireState.selected.card;
                const foundation = this.solitaireState.foundations[suit];
                if (card.suit === suit) {
                    const expectedRank = foundation.length + 1;
                    if (card.rank === expectedRank) {
                        this.saveHistory();
                        this.solitaireMoveCardToFoundation(this.solitaireState.selected, suit);
                        this.solitaireState.score += 10;
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                }
                this.renderSolitaire();
            }

            solitaireClickColumn(colIndex) {
                if (!this.solitaireState || !this.solitaireState.selected) return;
                const card = this.solitaireState.selected.card;
                if (card.rank === 13) {
                    this.saveHistory();
                    this.solitaireMoveCard(this.solitaireState.selected, { type: 'tableau', index: colIndex });
                    this.playSoundEffect('place');
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderSolitaire();
            }

            solitaireClickTableauCard(colIndex, cardIndex) {
                if (!this.solitaireState) return;
                const column = this.solitaireState.tableau[colIndex];
                const card = column[cardIndex];
                if (!card.faceUp) return;

                if (this.solitaireState.selected) {
                    const selectedCard = this.solitaireState.selected.card;
                    const targetCard = column[column.length - 1];
                    if (selectedCard.rank === targetCard.rank - 1 && selectedCard.color !== targetCard.color) {
                        this.saveHistory();
                        this.solitaireMoveCard(this.solitaireState.selected, { type: 'tableau', index: colIndex });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    if (cardIndex === column.length - 1) {
                        this.solitaireState.selected = { type: 'tableau', index: colIndex, card: card };
                    }
                }
                this.renderSolitaire();
            }

            solitaireAutoMoveToFoundation(type, index) {
                if (!this.solitaireState) return;
                let card;
                if (type === 'waste') {
                    if (this.solitaireState.waste.length === 0) return;
                    card = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                } else if (type === 'tableau') {
                    const column = this.solitaireState.tableau[index];
                    if (column.length === 0) return;
                    card = column[column.length - 1];
                    if (!card.faceUp) return;
                }

                if (this.canMoveToFoundation(card)) {
                    this.saveHistory();
                    const source = { type, index, card };
                    this.solitaireMoveCardToFoundation(source, card.suit);
                    this.solitaireState.score += 10;
                    this.playSoundEffect('place');
                    this.renderSolitaire();
                } else {
                    this.playSoundEffect('invalid');
                }
            }

            canMoveToFoundation(card) {
                const foundation = this.solitaireState.foundations[card.suit];
                const expectedRank = foundation.length + 1;
                return card.rank === expectedRank;
            }

            solitaireMoveCard(from, to) {
                if (from.type === 'waste') {
                    this.solitaireState.waste.pop();
                } else if (from.type === 'tableau') {
                    this.solitaireState.tableau[from.index].pop();
                    const column = this.solitaireState.tableau[from.index];
                    if (column.length > 0) {
                        column[column.length - 1].faceUp = true;
                    }
                }

                this.solitaireState.tableau[to.index].push(from.card);
                this.solitaireState.selected = null;
                this.solitaireState.moves++;
            }

            solitaireMoveCardToFoundation(from, suit) {
                if (from.type === 'waste') {
                    this.solitaireState.waste.pop();
                } else if (from.type === 'tableau') {
                    this.solitaireState.tableau[from.index].pop();
                    const column = this.solitaireState.tableau[from.index];
                    if (column.length > 0) {
                        column[column.length - 1].faceUp = true;
                    }
                }

                this.solitaireState.foundations[suit].push(from.card);
                this.solitaireState.selected = null;
                this.solitaireState.moves++;
            }

            saveHistory() {
                if (!this.solitaireState) return;
                if (this.solitaireState.history.length >= 20) {
                    this.solitaireState.history.shift();
                }
                this.solitaireState.history.push({
                    stock: JSON.parse(JSON.stringify(this.solitaireState.stock)),
                    waste: JSON.parse(JSON.stringify(this.solitaireState.waste)),
                    foundations: JSON.parse(JSON.stringify(this.solitaireState.foundations)),
                    tableau: JSON.parse(JSON.stringify(this.solitaireState.tableau)),
                    moves: this.solitaireState.moves,
                    score: this.solitaireState.score
                });
            }

            openFreeCell() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: linear-gradient(135deg, #0a5f0a 0%, #0d7d0d 100%); display: flex; flex-direction: column; height: 100%;';

                content.innerHTML = `
                    <div style="background: var(--button-face); padding: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border: 2px outset;">
                        <div>
                            <button class="btn" onclick="emulator.freeCellNewGame()">New Game</button>
                            <button class="btn" onclick="emulator.freeCellUndo()">Undo</button>
                            <button class="btn" onclick="emulator.freeCellHint()">Hint</button>
                        </div>
                        <div style="display: flex; gap: 12px; font-weight: bold;">
                            <span>Moves: <span id="freecell-moves">0</span></span>
                            <span>Time: <span id="freecell-time">0:00</span></span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 8px; margin-bottom: 16px; justify-content: space-between;">
                        <!-- Free Cells -->
                        <div style="display: flex; gap: 8px;">
                            <div class="freecell-cell" data-cell="0" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="1" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="2" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="3" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                        </div>

                        <!-- Foundation Piles -->
                        <div style="display: flex; gap: 8px;">
                            <div class="freecell-foundation" data-suit="spades" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♠</div>
                            <div class="freecell-foundation" data-suit="hearts" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♥</div>
                            <div class="freecell-foundation" data-suit="clubs" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">♣</div>
                            <div class="freecell-foundation" data-suit="diamonds" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">♦</div>
                        </div>
                    </div>

                    <!-- Tableau (8 columns) -->
                    <div id="freecell-tableau" style="display: flex; gap: 8px; flex: 1;">
                        ${Array.from({length: 8}, (_, i) => `
                            <div class="freecell-column" data-column="${i}" style="flex: 1; min-height: 300px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 4px; padding: 4px; cursor: pointer;">
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 12px; color: white; text-align: center; font-size: 11px;">
                        Goal: Move all cards to foundations (top right), building from Ace to King by suit.<br>
                        Build tableau in descending order, alternating colors. Free cells can hold one card each.
                    </div>
                `;

                this.windowManager.createWindow('FreeCell', content, { width: 700, height: 600 });

                // Initialize FreeCell game
                this.initFreeCell();
            }

            initFreeCell() {
                this.freeCellState = {
                    cells: [null, null, null, null], // 4 free cells
                    foundations: { spades: [], hearts: [], clubs: [], diamonds: [] }, // 4 foundation piles
                    tableau: Array.from({length: 8}, () => []), // 8 columns
                    selected: null, // Selected card {from: 'cell'|'column'|'foundation', index: number, card: object}
                    moves: 0,
                    history: [],
                    startTime: Date.now(),
                    timerInterval: null
                };

                // Start timer
                this.freeCellState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.freeCellState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    const timeEl = document.getElementById('freecell-time');
                    if (timeEl) timeEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                // Generate and shuffle deck
                this.freeCellNewGame();
            }

            freeCellNewGame() {
                if (!this.freeCellState) return;

                // Create deck
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const suitSymbols = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
                const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let deck = [];

                suits.forEach(suit => {
                    values.forEach((value, index) => {
                        deck.push({
                            suit: suit,
                            value: value,
                            rank: index + 1,
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            symbol: suitSymbols[suit]
                        });
                    });
                });

                // Shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                // Reset state
                this.freeCellState.cells = [null, null, null, null];
                this.freeCellState.foundations = { spades: [], hearts: [], clubs: [], diamonds: [] };
                this.freeCellState.tableau = Array.from({length: 8}, () => []);
                this.freeCellState.selected = null;
                this.freeCellState.moves = 0;
                this.freeCellState.startTime = Date.now();

                // Deal cards to tableau (first 4 columns get 7 cards, last 4 get 6)
                let cardIndex = 0;
                for (let col = 0; col < 8; col++) {
                    const cardsInColumn = col < 4 ? 7 : 6;
                    for (let i = 0; i < cardsInColumn; i++) {
                        this.freeCellState.tableau[col].push(deck[cardIndex++]);
                    }
                }

                this.renderFreeCell();
            }

            renderFreeCell() {
                if (!this.freeCellState) return;

                // Update moves counter
                const movesEl = document.getElementById('freecell-moves');
                if (movesEl) movesEl.textContent = this.freeCellState.moves;

                // Render free cells with double-click auto-move
                document.querySelectorAll('.freecell-cell').forEach((cellEl, index) => {
                    const card = this.freeCellState.cells[index];
                    cellEl.innerHTML = card ? this.renderCard(card) : '';
                    cellEl.onclick = () => this.freeCellClickCell(index);
                    if (card) {
                        cellEl.ondblclick = () => this.freeCellAutoMoveToFoundation('cell', index);
                    }
                });

                // Render foundations
                document.querySelectorAll('.freecell-foundation').forEach(foundationEl => {
                    const suit = foundationEl.dataset.suit;
                    const cards = this.freeCellState.foundations[suit];
                    const topCard = cards[cards.length - 1];
                    foundationEl.innerHTML = topCard ? this.renderCard(topCard) : foundationEl.textContent;
                    foundationEl.onclick = () => this.freeCellClickFoundation(suit);
                });

                // Render tableau columns with double-click auto-move
                document.querySelectorAll('.freecell-column').forEach((columnEl, colIndex) => {
                    const cards = this.freeCellState.tableau[colIndex];
                    columnEl.innerHTML = '';

                    if (cards.length === 0) {
                        columnEl.onclick = () => this.freeCellClickColumn(colIndex);
                    } else {
                        cards.forEach((card, cardIndex) => {
                            const cardEl = document.createElement('div');
                            cardEl.style.cssText = 'margin-bottom: 20px; transition: transform 0.2s, box-shadow 0.2s; cursor: pointer;';
                            cardEl.innerHTML = this.renderCard(card);

                            // Add hover effect for last card
                            if (cardIndex === cards.length - 1) {
                                cardEl.onmouseover = () => {
                                    cardEl.style.transform = 'translateY(-5px)';
                                };
                                cardEl.onmouseout = () => {
                                    cardEl.style.transform = 'translateY(0)';
                                };
                            }

                            cardEl.onclick = (e) => {
                                e.stopPropagation();
                                this.freeCellClickTableauCard(colIndex, cardIndex);
                            };

                            // Double-click auto-move for last card
                            if (cardIndex === cards.length - 1) {
                                cardEl.ondblclick = (e) => {
                                    e.stopPropagation();
                                    this.freeCellAutoMoveToFoundation('column', colIndex);
                                };
                            }

                            columnEl.appendChild(cardEl);
                        });
                    }
                });

                // Check for win
                const totalInFoundations = Object.values(this.freeCellState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundations === 52) {
                    clearInterval(this.freeCellState.timerInterval);
                    this.playSoundEffect('win');
                    setTimeout(() => {
                        alert(`🎉 You Won! Moves: ${this.freeCellState.moves}`);
                    }, 300);
                }
            }

            renderCard(card) {
                const color = card.color === 'red' ? '#ff4444' : '#000';
                return `
                    <div style="width: 50px; height: 70px; background: white; border: 2px solid #333; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 20px; color: ${color}; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-weight: bold;">
                        <div>${card.value}</div>
                        <div style="font-size: 24px;">${card.symbol}</div>
                    </div>
                `;
            }

            freeCellClickCell(index) {
                if (!this.freeCellState) return;

                if (this.freeCellState.selected) {
                    // Try to move selected card to this cell
                    if (!this.freeCellState.cells[index]) {
                        this.freeCellMoveCard(this.freeCellState.selected, { type: 'cell', index });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else if (this.freeCellState.cells[index]) {
                    // Select card from cell
                    this.freeCellState.selected = { type: 'cell', index, card: this.freeCellState.cells[index] };
                }
                this.renderFreeCell();
            }

            freeCellClickFoundation(suit) {
                if (!this.freeCellState || !this.freeCellState.selected) return;

                const selected = this.freeCellState.selected;
                const card = selected.card;
                const foundation = this.freeCellState.foundations[suit];

                // Check if card can be placed on foundation
                if (card.suit === suit) {
                    const expectedRank = foundation.length + 1;
                    if (card.rank === expectedRank) {
                        this.freeCellMoveCard(selected, { type: 'foundation', suit });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderFreeCell();
            }

            freeCellClickColumn(colIndex) {
                if (!this.freeCellState || !this.freeCellState.selected) return;

                // Try to move selected card to empty column
                if (this.freeCellState.tableau[colIndex].length === 0) {
                    this.freeCellMoveCard(this.freeCellState.selected, { type: 'column', index: colIndex });
                    this.playSoundEffect('place');
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderFreeCell();
            }

            freeCellClickTableauCard(colIndex, cardIndex) {
                if (!this.freeCellState) return;

                const column = this.freeCellState.tableau[colIndex];

                // Can only select the last card in a column
                if (cardIndex !== column.length - 1) return;

                if (this.freeCellState.selected) {
                    // Try to move selected card here
                    const targetCard = column[column.length - 1];
                    const selectedCard = this.freeCellState.selected.card;

                    // Check if move is valid (descending rank, alternating color)
                    if (selectedCard.rank === targetCard.rank - 1 && selectedCard.color !== targetCard.color) {
                        this.freeCellMoveCard(this.freeCellState.selected, { type: 'column', index: colIndex });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    // Select this card
                    this.freeCellState.selected = { type: 'column', index: colIndex, card: column[cardIndex] };
                }
                this.renderFreeCell();
            }

            freeCellAutoMoveToFoundation(type, index) {
                if (!this.freeCellState) return;

                let card;
                if (type === 'cell') {
                    card = this.freeCellState.cells[index];
                    if (!card) return;
                } else if (type === 'column') {
                    const column = this.freeCellState.tableau[index];
                    if (column.length === 0) return;
                    card = column[column.length - 1];
                }

                // Check if card can move to its foundation
                const foundation = this.freeCellState.foundations[card.suit];
                const expectedRank = foundation.length + 1;

                if (card.rank === expectedRank) {
                    const from = { type, index, card };
                    this.freeCellMoveCard(from, { type: 'foundation', suit: card.suit });
                    this.playSoundEffect('place');
                    this.renderFreeCell();
                } else {
                    this.playSoundEffect('invalid');
                }
            }

            freeCellMoveCard(from, to) {
                if (!this.freeCellState) return;

                const card = from.card;

                // Remove card from source
                if (from.type === 'cell') {
                    this.freeCellState.cells[from.index] = null;
                } else if (from.type === 'column') {
                    this.freeCellState.tableau[from.index].pop();
                } else if (from.type === 'foundation') {
                    this.freeCellState.foundations[from.suit].pop();
                }

                // Add card to destination
                if (to.type === 'cell') {
                    this.freeCellState.cells[to.index] = card;
                } else if (to.type === 'column') {
                    this.freeCellState.tableau[to.index].push(card);
                } else if (to.type === 'foundation') {
                    this.freeCellState.foundations[to.suit].push(card);
                }

                this.freeCellState.selected = null;
                this.freeCellState.moves++;
            }

            freeCellUndo() {
                this.playSoundEffect('invalid');
                alert('Undo feature coming soon!');
            }

            freeCellHint() {
                alert('Check if any cards can move to foundations, or try moving cards to free cells to unblock tableau columns!');
            }

            openMediaPlayer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                content.innerHTML = `
                    <div style="flex: 1; background: black; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <video id="media-player-video" style="max-width: 100%; max-height: 100%;" controls>
                            <source src="" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div id="media-visualization" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 48px; color: #00ff00;">
                            ♪♫♪
                        </div>
                    </div>
                    <div style="background: var(--button-face); padding: 8px; border-top: 1px solid var(--button-shadow);">
                        <div style="display: flex; gap: 4px; margin-bottom: 8px; justify-content: center;">
                            <button class="btn" onclick="emulator.mediaControl('prev')" title="Previous">⏮</button>
                            <button class="btn" onclick="emulator.mediaControl('play')" title="Play">▶</button>
                            <button class="btn" onclick="emulator.mediaControl('pause')" title="Pause">⏸</button>
                            <button class="btn" onclick="emulator.mediaControl('stop')" title="Stop">⏹</button>
                            <button class="btn" onclick="emulator.mediaControl('next')" title="Next">⏭</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 11px;">
                            <span>Volume:</span>
                            <input type="range" id="media-volume" min="0" max="100" value="70" style="flex: 1;" onchange="emulator.mediaSetVolume(this.value)">
                            <span id="media-volume-label">70%</span>
                        </div>
                        <div style="margin-top: 8px; padding: 4px; background: white; border: 1px inset; min-height: 20px; font-size: 11px;" id="media-status">
                            Ready - No media loaded
                        </div>
                    </div>
                    <div style="background: var(--button-face); padding: 4px; border-top: 1px solid var(--button-highlight); font-size: 10px; text-align: center;">
                        Drop audio/video files here to play (Feature demonstration - File API would be needed)
                    </div>
                `;

                this.windowManager.createWindow('Media Player', content, { width: 480, height: 400 });
            }

            mediaControl(action) {
                const video = document.getElementById('media-player-video');
                const status = document.getElementById('media-status');

                if (!video || !status) return;

                switch (action) {
                    case 'play':
                        if (video.src) {
                            video.play();
                            status.textContent = 'Playing...';
                        } else {
                            status.textContent = 'No media loaded';
                        }
                        break;
                    case 'pause':
                        video.pause();
                        status.textContent = 'Paused';
                        break;
                    case 'stop':
                        video.pause();
                        video.currentTime = 0;
                        status.textContent = 'Stopped';
                        break;
                    case 'prev':
                        status.textContent = 'Previous track (demo)';
                        break;
                    case 'next':
                        status.textContent = 'Next track (demo)';
                        break;
                }
            }

            mediaSetVolume(value) {
                const video = document.getElementById('media-player-video');
                const label = document.getElementById('media-volume-label');

                if (video) video.volume = value / 100;
                if (label) label.textContent = value + '%';
            }

            openSystemProperties() {
                const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                const hours = Math.floor(uptime / 3600);
                const mins = Math.floor((uptime % 3600) / 60);
                const secs = uptime % 60;

                const content = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 48px; margin-bottom: 10px;">⚙️</div>
                            <h3 style="margin: 0;">System Properties</h3>
                        </div>

                        <div style="background: white; padding: 12px; border: 2px inset; margin-bottom: 12px;">
                            <table style="width: 100%; font-size: 11px;">
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">System:</td>
                                    <td style="padding: 4px;">Microsoft Windows 95</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Version:</td>
                                    <td style="padding: 4px;">4.00.950 (Simulator)</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Computer:</td>
                                    <td style="padding: 4px;">win95-simulator</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Processor:</td>
                                    <td style="padding: 4px;">Browser JavaScript Engine</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Memory:</td>
                                    <td style="padding: 4px;">${Math.floor(this.settings.memory / 1024 / 1024)} MB RAM</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">User:</td>
                                    <td style="padding: 4px;">user</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Uptime:</td>
                                    <td style="padding: 4px;">${hours}h ${mins}m ${secs}s</td>
                                </tr>
                            </table>
                        </div>

                        <div style="background: #ffffc0; padding: 8px; border: 1px solid #808080; font-size: 10px; margin-bottom: 12px;">
                            <strong>ℹ️ Note:</strong> This is a browser-based simulator. System information reflects the simulated environment.
                        </div>

                        <div style="text-align: center;">
                            <button class="btn primary" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 100px;">OK</button>
                        </div>
                    </div>
                `;

                this.windowManager.createWindow('System Properties', content, { width: 420, height: 440 });
            }

            openRegistryEditor() {
                // Load or initialize registry from localStorage
                const registry = this.loadRegistry();

                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Menu bar
                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px 4px; border-bottom: 1px solid #808080; font-size: 11px;';
                menuBar.innerHTML = `
                    <span style="padding: 2px 8px; cursor: pointer;">Registry</span>
                    <span style="padding: 2px 8px; cursor: pointer;">Edit</span>
                    <span style="padding: 2px 8px; cursor: pointer;">View</span>
                    <span style="padding: 2px 8px; cursor: pointer;">Help</span>
                `;

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 1px solid #808080; display: flex; gap: 4px;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.registryAddKey()" title="New Key">📁+</button>
                    <button class="btn" onclick="emulator.registryAddValue()" title="New Value">📝+</button>
                    <button class="btn" onclick="emulator.registryDelete()" title="Delete">🗑️</button>
                    <button class="btn" onclick="emulator.registryRefresh()" title="Refresh">🔄</button>
                `;

                // Main container
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; flex: 1; overflow: hidden;';

                // Tree view (left panel)
                const treePanel = document.createElement('div');
                treePanel.id = 'registry-tree';
                treePanel.style.cssText = 'width: 250px; background: white; border: 2px inset; overflow-y: auto; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';

                // Details view (right panel)
                const detailsPanel = document.createElement('div');
                detailsPanel.id = 'registry-details';
                detailsPanel.style.cssText = 'flex: 1; margin-left: 4px; background: white; border: 2px inset; overflow-y: auto;';

                // Build tree view
                this.buildRegistryTree(treePanel, registry);

                // Build details view header
                detailsPanel.innerHTML = `
                    <div style="background: #000080; color: white; padding: 4px; font-size: 11px; display: flex; border-bottom: 1px solid #808080;">
                        <div style="flex: 1; padding: 2px;">Name</div>
                        <div style="flex: 1; padding: 2px;">Type</div>
                        <div style="flex: 2; padding: 2px;">Data</div>
                    </div>
                    <div id="registry-values" style="font-size: 11px;"></div>
                `;

                mainContainer.appendChild(treePanel);
                mainContainer.appendChild(detailsPanel);

                content.appendChild(menuBar);
                content.appendChild(toolbar);
                content.appendChild(mainContainer);

                this.registryState = { currentKey: null, registry: registry };
                this.windowManager.createWindow('Registry Editor', content, { width: 700, height: 500 });
            }

            loadRegistry() {
                const saved = SafeStorage.getItem('win95-registry');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return this.getDefaultRegistry();
                    }
                }
                return this.getDefaultRegistry();
            }

            getDefaultRegistry() {
                return {
                    'HKEY_CLASSES_ROOT': {
                        '.txt': { '(Default)': 'txtfile' },
                        'txtfile': { '(Default)': 'Text Document' }
                    },
                    'HKEY_CURRENT_USER': {
                        'Software': {
                            'Microsoft': {
                                'Windows': { 'CurrentVersion': 'Windows 95 Simulator' }
                            }
                        },
                        'Control Panel': {
                            'Desktop': { 'Wallpaper': 'None' },
                            'Mouse': { 'DoubleClickSpeed': '500' }
                        }
                    },
                    'HKEY_LOCAL_MACHINE': {
                        'SOFTWARE': {
                            'Microsoft': {
                                'Windows': {
                                    'CurrentVersion': { 'Version': '4.00.950' }
                                }
                            }
                        },
                        'SYSTEM': {
                            'CurrentControlSet': { 'Control': { 'ComputerName': 'WIN95-SIM' } }
                        }
                    },
                    'HKEY_USERS': {
                        '.DEFAULT': { '(Default)': 'Default User Settings' }
                    },
                    'HKEY_CURRENT_CONFIG': {
                        'Software': { 'Fonts': { '(Default)': 'MS Sans Serif' } }
                    }
                };
            }

            saveRegistry(registry) {
                try {
                    SafeStorage.setItem('win95-registry', JSON.stringify(registry));
                } catch (e) {
                    alert('Error saving registry: ' + e.message);
                }
            }

            buildRegistryTree(container, registry, path = []) {
                container.innerHTML = '';

                const buildNode = (obj, parent, currentPath) => {
                    Object.keys(obj).sort().forEach(key => {
                        const fullPath = [...currentPath, key];
                        const pathStr = fullPath.join('\\');

                        const nodeDiv = document.createElement('div');
                        nodeDiv.style.cssText = 'padding: 2px 2px 2px ' + (currentPath.length * 16 + 4) + 'px; cursor: pointer; user-select: none;';

                        const hasChildren = typeof obj[key] === 'object' && obj[key] !== null && !obj[key].hasOwnProperty('(Default)') && Object.keys(obj[key]).length > 0;

                        nodeDiv.innerHTML = (hasChildren ? '📁 ' : '📄 ') + key;

                        nodeDiv.onclick = (e) => {
                            e.stopPropagation();
                            // Highlight selected
                            container.querySelectorAll('div').forEach(d => d.style.background = 'white');
                            nodeDiv.style.background = '#000080';
                            nodeDiv.style.color = 'white';

                            // Update details panel
                            this.registryState.currentKey = fullPath;
                            this.displayRegistryValues(obj[key]);
                        };

                        parent.appendChild(nodeDiv);

                        // Recursively build child nodes
                        if (typeof obj[key] === 'object' && obj[key] !== null) {
                            buildNode(obj[key], parent, fullPath);
                        }
                    });
                };

                // Build root nodes
                Object.keys(registry).sort().forEach(rootKey => {
                    const rootDiv = document.createElement('div');
                    rootDiv.style.cssText = 'padding: 2px 4px; cursor: pointer; font-weight: bold; user-select: none;';
                    rootDiv.innerHTML = '🖥️ ' + rootKey;

                    rootDiv.onclick = (e) => {
                        e.stopPropagation();
                        container.querySelectorAll('div').forEach(d => {
                            d.style.background = 'white';
                            d.style.color = 'black';
                        });
                        rootDiv.style.background = '#000080';
                        rootDiv.style.color = 'white';

                        this.registryState.currentKey = [rootKey];
                        this.displayRegistryValues(registry[rootKey]);
                    };

                    container.appendChild(rootDiv);

                    if (typeof registry[rootKey] === 'object') {
                        buildNode(registry[rootKey], container, [rootKey]);
                    }
                });
            }

            displayRegistryValues(keyData) {
                const valuesContainer = document.getElementById('registry-values');
                if (!valuesContainer) return;

                valuesContainer.innerHTML = '';

                if (!keyData || typeof keyData !== 'object') return;

                // Display values (leaf nodes)
                Object.keys(keyData).forEach(valueName => {
                    const valueData = keyData[valueName];

                    if (typeof valueData === 'string' || typeof valueData === 'number') {
                        const row = document.createElement('div');
                        row.style.cssText = 'display: flex; padding: 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        row.innerHTML = `
                            <div style="flex: 1; padding: 2px;">${valueName}</div>
                            <div style="flex: 1; padding: 2px;">REG_SZ</div>
                            <div style="flex: 2; padding: 2px;">${valueData}</div>
                        `;

                        row.onclick = () => {
                            const newValue = prompt('Edit value for: ' + valueName, valueData);
                            if (newValue !== null) {
                                this.registryUpdateValue(valueName, newValue);
                            }
                        };

                        valuesContainer.appendChild(row);
                    }
                });
            }

            registryAddKey() {
                if (!this.registryState || !this.registryState.currentKey) {
                    alert('Please select a location in the registry tree first.');
                    return;
                }

                const keyName = prompt('Enter new key name:');
                if (keyName && keyName.trim()) {
                    let current = this.registryState.registry;
                    this.registryState.currentKey.forEach(part => {
                        if (!current[part]) current[part] = {};
                        current = current[part];
                    });

                    current[keyName.trim()] = {};
                    this.saveRegistry(this.registryState.registry);
                    this.registryRefresh();
                }
            }

            registryAddValue() {
                if (!this.registryState || !this.registryState.currentKey) {
                    alert('Please select a location in the registry tree first.');
                    return;
                }

                const valueName = prompt('Enter value name:');
                if (valueName !== null) {
                    const valueData = prompt('Enter value data:');
                    if (valueData !== null) {
                        let current = this.registryState.registry;
                        this.registryState.currentKey.forEach(part => {
                            if (!current[part]) current[part] = {};
                            current = current[part];
                        });

                        current[valueName || '(Default)'] = valueData;
                        this.saveRegistry(this.registryState.registry);
                        this.displayRegistryValues(current);
                    }
                }
            }

            registryUpdateValue(valueName, newValue) {
                if (!this.registryState || !this.registryState.currentKey) return;

                let current = this.registryState.registry;
                this.registryState.currentKey.forEach(part => {
                    current = current[part];
                });

                current[valueName] = newValue;
                this.saveRegistry(this.registryState.registry);
                this.displayRegistryValues(current);
            }

            registryDelete() {
                if (!this.registryState || !this.registryState.currentKey) {
                    alert('Please select an item to delete.');
                    return;
                }

                if (confirm('Are you sure you want to delete this key and all its subkeys?')) {
                    let parent = this.registryState.registry;
                    const path = [...this.registryState.currentKey];
                    const keyToDelete = path.pop();

                    path.forEach(part => {
                        parent = parent[part];
                    });

                    delete parent[keyToDelete];
                    this.saveRegistry(this.registryState.registry);
                    this.registryRefresh();
                }
            }

            registryRefresh() {
                const treePanel = document.getElementById('registry-tree');
                if (treePanel) {
                    this.registryState.registry = this.loadRegistry();
                    this.buildRegistryTree(treePanel, this.registryState.registry);
                }
            }

            openTaskManager() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Title bar area
                const header = document.createElement('div');
                header.style.cssText = 'background: var(--button-face); padding: 8px; border-bottom: 2px solid #808080;';
                header.innerHTML = `
                    <h3 style="margin: 0; font-size: 13px;">Task Manager</h3>
                    <div style="font-size: 10px; color: #666; margin-top: 4px;">Windows 95 Simulator</div>
                `;

                // Task list container
                const taskList = document.createElement('div');
                taskList.id = 'task-manager-list';
                taskList.style.cssText = 'flex: 1; overflow-y: auto; background: white; border: 2px inset; margin: 8px;';

                // Buttons
                const buttons = document.createElement('div');
                buttons.style.cssText = 'padding: 8px; border-top: 1px solid #808080; display: flex; gap: 8px; justify-content: flex-end; background: var(--button-face);';
                buttons.innerHTML = `
                    <button class="btn" onclick="emulator.taskManagerRefresh()" style="min-width: 80px;">Refresh</button>
                    <button class="btn" onclick="emulator.taskManagerEndTask()" style="min-width: 80px;">End Task</button>
                    <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px;">Close</button>
                `;

                content.appendChild(header);
                content.appendChild(taskList);
                content.appendChild(buttons);

                const win = this.windowManager.createWindow('Task Manager', content, { width: 450, height: 400 });

                // Populate task list
                this.taskManagerRefresh();

                // Auto-refresh every 2 seconds
                this.taskManagerInterval = setInterval(() => {
                    if (document.getElementById('task-manager-list')) {
                        this.taskManagerRefresh();
                    } else {
                        clearInterval(this.taskManagerInterval);
                    }
                }, 2000);
            }

            taskManagerRefresh() {
                const taskList = document.getElementById('task-manager-list');
                if (!taskList) return;

                taskList.innerHTML = `
                    <div style="background: #000080; color: white; padding: 6px; font-size: 11px; display: grid; grid-template-columns: 2fr 1fr 1fr; font-weight: bold; border-bottom: 1px solid #808080;">
                        <div>Task</div>
                        <div style="text-align: center;">Status</div>
                        <div style="text-align: center;">CPU</div>
                    </div>
                `;

                // Add running windows
                this.windowManager.windows.forEach((win, index) => {
                    const row = document.createElement('div');
                    row.className = 'task-manager-row';
                    row.dataset.windowId = win.id;
                    row.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 6px; font-size: 11px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                    row.innerHTML = `
                        <div>${win.title}</div>
                        <div style="text-align: center;">${win.minimized ? 'Minimized' : 'Running'}</div>
                        <div style="text-align: center;">${Math.floor(Math.random() * 15 + 1)}%</div>
                    `;

                    row.onclick = () => {
                        // Highlight selected
                        taskList.querySelectorAll('.task-manager-row').forEach(r => r.style.background = 'white');
                        row.style.background = '#000080';
                        row.style.color = 'white';
                        this.selectedTaskId = win.id;
                    };

                    taskList.appendChild(row);
                });

                // Add system process
                const systemRow = document.createElement('div');
                systemRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 6px; font-size: 11px; border-bottom: 1px solid #e0e0e0; color: #666;';
                systemRow.innerHTML = `
                    <div>System Idle Process</div>
                    <div style="text-align: center;">Running</div>
                    <div style="text-align: center;">${Math.floor(100 - this.windowManager.windows.length * 5)}%</div>
                `;
                taskList.appendChild(systemRow);
            }

            taskManagerEndTask() {
                if (!this.selectedTaskId) {
                    alert('Please select a task to end.');
                    return;
                }

                const windowObj = this.windowManager.windows.find(w => w.id === this.selectedTaskId);
                if (windowObj) {
                    if (confirm(`End task "${windowObj.title}"?`)) {
                        this.windowManager.closeWindow(windowObj.element);
                        this.selectedTaskId = null;
                        this.taskManagerRefresh();
                    }
                }
            }

            openControlPanel() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Tabs
                const tabs = document.createElement('div');
                tabs.style.cssText = 'display: flex; border-bottom: 2px solid #808080; background: var(--button-face);';
                tabs.innerHTML = `
                    <button class="cp-tab active" data-tab="display" style="padding: 8px 16px; background: white; border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Display</button>
                    <button class="cp-tab" data-tab="desktop" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Desktop</button>
                    <button class="cp-tab" data-tab="mouse" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Mouse</button>
                    <button class="cp-tab" data-tab="sound" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Sound</button>
                `;

                // Tab content container
                const tabContent = document.createElement('div');
                tabContent.style.cssText = 'flex: 1; overflow-y: auto; padding: 16px;';
                tabContent.innerHTML = this.getControlPanelTabContent('display');

                // Tab switching logic
                tabs.querySelectorAll('.cp-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        tabs.querySelectorAll('.cp-tab').forEach(t => {
                            t.classList.remove('active');
                            t.style.background = 'var(--button-face)';
                        });
                        tab.classList.add('active');
                        tab.style.background = 'white';
                        const tabName = tab.dataset.tab;
                        tabContent.innerHTML = this.getControlPanelTabContent(tabName);
                        this.initControlPanelHandlers(tabName);
                    });
                });

                // Bottom buttons
                const buttons = document.createElement('div');
                buttons.style.cssText = 'padding: 12px; border-top: 2px solid #808080; text-align: right; background: var(--button-face);';
                buttons.innerHTML = `
                    <button class="btn" onclick="emulator.saveControlPanelSettings(); emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px; margin-left: 4px;">OK</button>
                    <button class="btn" onclick="emulator.saveControlPanelSettings()" style="min-width: 80px; margin-left: 4px;">Apply</button>
                    <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px; margin-left: 4px;">Cancel</button>
                `;

                content.appendChild(tabs);
                content.appendChild(tabContent);
                content.appendChild(buttons);

                this.windowManager.createWindow('Control Panel', content, { width: 500, height: 450 });
                this.initControlPanelHandlers('display');
            }

            getControlPanelTabContent(tab) {
                const bgColor = SafeStorage.getItem('win95-desktop-color') || '#008080';
                const iconSpacing = SafeStorage.getItem('win95-icon-spacing') || '80';

                switch (tab) {
                    case 'display':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Display Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Desktop Background Color:</label>
                                    <input type="color" id="cp-bg-color" value="${bgColor}" style="width: 100px; height: 30px; cursor: pointer;">
                                    <span id="cp-bg-preview" style="margin-left: 12px; padding: 4px 12px; background: ${bgColor}; border: 1px solid #000; color: white;">${bgColor}</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Screen Resolution:</label>
                                    <select id="cp-resolution" style="padding: 4px;">
                                        <option value="640x480">640 x 480 (Default)</option>
                                        <option value="800x600">800 x 600</option>
                                        <option value="1024x768">1024 x 768</option>
                                    </select>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ℹ️ Resolution changes require restart
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'desktop':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Desktop Customization</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Wallpaper:</label>
                                    <button class="btn" onclick="emulator.uploadWallpaper()">📁 Choose Wallpaper...</button>
                                    <button class="btn" onclick="emulator.removeWallpaper()" style="margin-left: 8px;">🗑️ Remove</button>
                                    <div id="wallpaper-preview" style="margin-top: 8px; padding: 8px; background: #f0f0f0; border: 1px solid #808080; font-size: 10px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                                        <span>No wallpaper set</span>
                                    </div>
                                    <input type="file" id="wallpaper-file-input" accept="image/*" style="display: none;">
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Icon Spacing:</label>
                                    <input type="range" id="cp-icon-spacing" min="60" max="120" value="${iconSpacing}" style="width: 200px;">
                                    <span id="cp-spacing-value" style="margin-left: 12px;">${iconSpacing}px</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-show-icons" checked style="margin-right: 8px;">
                                        <span>Show desktop icons</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-show-clock" checked style="margin-right: 8px;">
                                        <span>Show taskbar clock</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <button class="btn" onclick="emulator.arrangeIconsGrid()">
                                        🔲 Arrange Icons in Grid
                                    </button>
                                </div>
                            </div>
                        `;

                    case 'mouse':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Mouse Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-enable-mouse-lock" style="margin-right: 8px;">
                                        <span>Enable Mouse Lock (for FPS navigation)</span>
                                    </label>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ℹ️ Keep OFF for normal desktop interaction
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Double-Click Speed:</label>
                                    <input type="range" id="cp-dblclick-speed" min="200" max="800" value="400" style="width: 200px;">
                                    <div style="display: inline-block; margin-left: 12px;">
                                        <span style="margin: 0 8px;">Fast</span>
                                        <span>⟷</span>
                                        <span style="margin: 0 8px;">Slow</span>
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'sound':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Sound Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-enable-sound" style="margin-right: 8px;">
                                        <span>Enable system sounds</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Volume:</label>
                                    <input type="range" id="cp-volume" min="0" max="100" value="70" style="width: 200px;">
                                    <span id="cp-volume-value" style="margin-left: 12px;">70%</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-sound-startup" checked style="margin-right: 8px;">
                                        <span>Play Windows startup sound</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-sound-shutdown" checked style="margin-right: 8px;">
                                        <span>Play Windows shutdown sound</span>
                                    </label>
                                </div>
                            </div>
                        `;

                    default:
                        return '<div>Unknown tab</div>';
                }
            }

            initControlPanelHandlers(tab) {
                if (tab === 'display') {
                    const bgColorInput = document.getElementById('cp-bg-color');
                    const bgPreview = document.getElementById('cp-bg-preview');

                    if (bgColorInput && bgPreview) {
                        bgColorInput.addEventListener('input', (e) => {
                            bgPreview.style.background = e.target.value;
                            bgPreview.textContent = e.target.value;
                        });
                    }
                } else if (tab === 'desktop') {
                    const spacingInput = document.getElementById('cp-icon-spacing');
                    const spacingValue = document.getElementById('cp-spacing-value');

                    if (spacingInput && spacingValue) {
                        spacingInput.addEventListener('input', (e) => {
                            spacingValue.textContent = e.target.value + 'px';
                        });
                    }

                    // Wallpaper file input handler
                    const wallpaperInput = document.getElementById('wallpaper-file-input');
                    if (wallpaperInput) {
                        wallpaperInput.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file && file.type.startsWith('image/')) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    const imageData = event.target.result;
                                    SafeStorage.setItem('win95-wallpaper', imageData);
                                    this.updateWallpaperPreview(imageData);
                                    this.applyWallpaper(imageData);
                                };
                                reader.readAsDataURL(file);
                            }
                        });
                    }

                    // Load and display current wallpaper preview
                    const savedWallpaper = SafeStorage.getItem('win95-wallpaper');
                    if (savedWallpaper) {
                        this.updateWallpaperPreview(savedWallpaper);
                    }
                } else if (tab === 'sound') {
                    const volumeInput = document.getElementById('cp-volume');
                    const volumeValue = document.getElementById('cp-volume-value');

                    if (volumeInput && volumeValue) {
                        volumeInput.addEventListener('input', (e) => {
                            volumeValue.textContent = e.target.value + '%';
                        });
                    }
                }
            }

            saveControlPanelSettings() {
                // Display settings
                const bgColor = document.getElementById('cp-bg-color')?.value;
                if (bgColor) {
                    SafeStorage.setItem('win95-desktop-color', bgColor);
                    const desktop = document.querySelector('.desktop');
                    if (desktop) desktop.style.background = bgColor;
                }

                // Desktop settings
                const iconSpacing = document.getElementById('cp-icon-spacing')?.value;
                if (iconSpacing) {
                    SafeStorage.setItem('win95-icon-spacing', iconSpacing);
                }

                const showIcons = document.getElementById('cp-show-icons')?.checked;
                if (showIcons !== undefined) {
                    const desktopIcons = document.getElementById('desktop-icons');
                    if (desktopIcons) {
                        desktopIcons.style.display = showIcons ? 'flex' : 'none';
                    }
                }

                console.log('Control Panel settings saved');
                alert('Settings have been applied!');
            }

            arrangeIconsGrid() {
                // Arrange desktop icons in a neat grid
                const icons = document.querySelectorAll('.desktop-icon');
                const spacing = parseInt(SafeStorage.getItem('win95-icon-spacing') || '80');
                let x = 20, y = 20;

                icons.forEach((icon, index) => {
                    icon.style.left = x + 'px';
                    icon.style.top = y + 'px';

                    y += spacing;
                    if (y > 400) {
                        y = 20;
                        x += spacing + 20;
                    }
                });

                alert('Icons arranged in grid!');
            }

            uploadWallpaper() {
                const fileInput = document.getElementById('wallpaper-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            removeWallpaper() {
                SafeStorage.removeItem('win95-wallpaper');
                const screenContainer = document.getElementById('screen_container');
                if (screenContainer) {
                    screenContainer.style.backgroundImage = 'none';
                    screenContainer.style.background = SafeStorage.getItem('win95-desktop-color') || '#008080';
                }

                // Update preview if in control panel
                const preview = document.getElementById('wallpaper-preview');
                if (preview) {
                    preview.innerHTML = '<span>No wallpaper set</span>';
                }

                alert('Wallpaper removed!');
            }

            updateWallpaperPreview(imageData) {
                const preview = document.getElementById('wallpaper-preview');
                if (preview) {
                    preview.innerHTML = `<img src="${imageData}" style="max-width: 100%; max-height: 100px; object-fit: contain;">`;
                }
            }

            applyWallpaper(imageData) {
                const screenContainer = document.getElementById('screen_container');
                if (screenContainer && imageData) {
                    screenContainer.style.backgroundImage = `url(${imageData})`;
                    screenContainer.style.backgroundSize = 'cover';
                    screenContainer.style.backgroundPosition = 'center';
                    screenContainer.style.backgroundRepeat = 'no-repeat';
                }
            }

            loadWallpaper() {
                const wallpaper = SafeStorage.getItem('win95-wallpaper');
                if (wallpaper) {
                    this.applyWallpaper(wallpaper);
                }
            }

            openAbout() {
                const content = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">💻</div>
                        <h3 style="margin: 10px 0;">Windows 95 Desktop Simulator</h3>
                        <p style="margin: 10px 0;">Interactive Edition v4.0</p>
                        <hr style="margin: 15px 0;">
                        <p style="margin: 10px 0; text-align: left;">
                            <strong>Programs:</strong><br>
                            • Internet Explorer - Browse real websites<br>
                            • Paint - Drawing application<br>
                            • Media Player - Audio/Video player<br>
                            • File Explorer - Browse mock file system<br>
                            • Linux Terminal - Full bash emulation<br>
                            • Notepad - Text editor<br>
                            • Calculator - Math operations<br>
                            • Minesweeper - Classic game<br>
                            • Solitaire - Card game<br>
                            • System Properties - View system info
                        </p>
                        <hr style="margin: 15px 0;">
                        <p style="margin: 10px 0; text-align: left;">
                            <strong>Features:</strong><br>
                            • Draggable windows<br>
                            • Functional Start menu<br>
                            • Real-time clock<br>
                            • Desktop icons & context menus<br>
                            • 20+ Linux commands<br>
                            • Command history (↑/↓ arrows)<br>
                            • Virtual filesystem<br>
                            • Authentic Win95 aesthetics
                        </p>
                        <hr style="margin: 15px 0;">
                        <p style="font-size: 10px; color: #808080;">
                            Built with pure HTML, CSS, and JavaScript<br>
                            No external dependencies • Local-first design<br>
                            <br>
                            Created by Claude Code
                        </p>
                    </div>
                `;
                this.windowManager.createWindow('About Windows 95', content, { width: 400, height: 600 });
            }

            // Taskbar management
            addTaskbarButton(windowObj) {
                const button = document.createElement('button');
                button.className = 'taskbar-button';
                button.textContent = windowObj.title;
                button.dataset.windowId = windowObj.id;
                button.onclick = () => {
                    if (windowObj.minimized) {
                        this.windowManager.restoreWindow(windowObj.element);
                    } else {
                        this.windowManager.focusWindow(windowObj.element);
                    }
                };

                // Insert before system tray
                const canvas = document.getElementById('screen');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    // Add to taskbar visually (this is a simplification)
                }

                this.taskbarButtons.push({ windowObj, button });
            }

            removeTaskbarButton(windowObj) {
                const index = this.taskbarButtons.findIndex(tb => tb.windowObj.id === windowObj.id);
                if (index > -1) {
                    this.taskbarButtons.splice(index, 1);
                }
            }

            updateTaskbarButtons() {
                // Update active state of taskbar buttons
                this.taskbarButtons.forEach(tb => {
                    const isActive = tb.windowObj.element.classList.contains('active');
                    if (isActive) {
                        tb.button.classList.add('active');
                    } else {
                        tb.button.classList.remove('active');
                    }
                });
            }

            initEmulatorCore() {
                console.log("Initializing x86 emulator core...");
                console.log("WebAssembly support:", typeof WebAssembly !== 'undefined');

                // Load saved desktop customization
                this.loadDesktopCustomization();
            }

            loadDesktopCustomization() {
                // Apply saved desktop background color
                const savedBgColor = SafeStorage.getItem('win95-desktop-color');
                if (savedBgColor) {
                    setTimeout(() => {
                        const screenContainer = document.getElementById('screen_container');
                        if (screenContainer) {
                            screenContainer.style.background = savedBgColor;
                            console.log('Applied saved desktop color:', savedBgColor);
                        }
                    }, 100);
                }

                // Load and apply wallpaper
                setTimeout(() => {
                    this.loadWallpaper();
                }, 150);
            }

            detectSystemInfo() {
                // Detect browser
                const ua = navigator.userAgent;
                let browser = 'Unknown';
                if (ua.indexOf('Firefox') > -1) browser = 'Mozilla Firefox';
                else if (ua.indexOf('Chrome') > -1) browser = 'Google Chrome';
                else if (ua.indexOf('Safari') > -1) browser = 'Apple Safari';
                else if (ua.indexOf('Edge') > -1) browser = 'Microsoft Edge';
                else if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) browser = 'Internet Explorer';

                // Check WebAssembly support
                const wasmSupport = typeof WebAssembly !== 'undefined' ? 
                    '<span style="color: green;">✓ Supported</span>' : 
                    '<span style="color: red;">✗ Not Supported</span>';

                // Get screen info
                const screenInfo = `${window.screen.width}x${window.screen.height}`;

                // Update UI
                setTimeout(() => {
                    const browserInfo = document.getElementById('browser-info');
                    const wasmInfo = document.getElementById('wasm-support');
                    const screenInfoEl = document.getElementById('screen-info');
                    
                    if (browserInfo) browserInfo.innerHTML = browser;
                    if (wasmInfo) wasmInfo.innerHTML = wasmSupport;
                    if (screenInfoEl) screenInfoEl.textContent = screenInfo;
                }, 100);
            }

            initDOMCache() {
                if (this.domCache) return;

                try {
                    this.domCache = {
                        fpsCounter: document.getElementById('fps-counter'),
                        timeDisplay: document.getElementById('time-display'),
                        cpuLed: document.getElementById('cpu-led'),
                        cpuStatus: document.getElementById('cpu-status'),
                        hddLed: document.getElementById('hdd-led'),
                        loadingScreen: document.getElementById('loading-screen'),
                        loadingText: document.getElementById('loading-text'),
                        progressFill: document.getElementById('progress-fill'),
                        setupScreen: document.getElementById('setup-screen'),
                        emulatorContainer: document.getElementById('emulator-container'),
                        emulatorTitlebar: document.getElementById('emulator-titlebar'),
                        memoryUsage: document.getElementById('memory-usage'),
                        pauseBtn: document.getElementById('pause-btn')
                    };
                } catch (error) {
                    console.error('Failed to initialize DOM cache:', error);
                    throw new Error('Required DOM elements not found');
                }
            }

            async loadDemo() {
                try {
                    this.showLoading('Initializing emulator...');
                    this.initDOMCache();

                    // Read settings
                    this.updateSettings();

                    this.canvas = document.getElementById('screen');
                    if (!this.canvas) {
                        throw new Error('Canvas element not found');
                    }

                    this.ctx = this.canvas.getContext('2d', {
                        alpha: false,
                        desynchronized: true,
                        willReadFrequently: false
                    });

                    if (!this.ctx) {
                        throw new Error('Could not get 2D rendering context. Canvas may be disabled.');
                    }

                    this.canvas.width = CONFIG.DISPLAY.WIDTH;
                    this.canvas.height = CONFIG.DISPLAY.HEIGHT;

                    this.domCache.setupScreen.classList.add('hidden');
                    this.domCache.emulatorContainer.classList.remove('hidden');

                    await this.simulateBoot();

                    this.hideLoading();
                    this.startEmulation();
                    
                    // Setup mouse capture
                    this.setupMouseCapture();
                } catch (error) {
                    console.error('Failed to load demo:', error);
                    alert(`Failed to start emulator: ${error.message}\n\nPlease check console for details.`);
                    this.hideLoading();
                }
            }

            updateSettings() {
                try {
                    const memorySelect = document.getElementById('memory-size');
                    const cpuSpeedSelect = document.getElementById('cpu-speed');
                    const enableMouse = document.getElementById('enable-mouse');
                    const enableSound = document.getElementById('enable-sound');
                    const enableNetwork = document.getElementById('enable-network');

                    this.settings.memory = parseInt(memorySelect.value) * 1024 * 1024;
                    this.settings.cpuSpeed = parseInt(cpuSpeedSelect.value);
                    this.settings.enableMouse = enableMouse.checked;
                    this.settings.enableSound = enableSound.checked;
                    this.settings.enableNetwork = enableNetwork.checked;

                    console.log('Settings updated:', this.settings);
                } catch (error) {
                    console.error('Failed to update settings:', error);
                }
            }

            setupMouseCapture() {
                // Disabled pointer lock for interactive desktop mode
                // Users need free mouse movement to interact with windows and icons
                return;
            }

            async simulateBoot() {
                const bootMessages = [
                    'PhoenixBIOS 4.0 Release 6.0',
                    'Copyright 1985-1995 Phoenix Technologies Ltd.',
                    'All Rights Reserved',
                    '',
                    'CPU: Intel Pentium ' + (this.settings.cpuSpeed * 75) + 'MHz',
                    'Memory Test: ' + (this.settings.memory / 1024) + 'K OK',
                    'Cache: 256K',
                    '',
                    'Press DEL to enter SETUP, ESC to skip memory test',
                    '',
                    'Detecting IDE drives...',
                    'Primary Master: 540MB Hard Disk',
                    'Primary Slave: None',
                    'Secondary Master: CD-ROM Drive',
                    'Secondary Slave: None',
                    '',
                    'Starting MS-DOS...',
                    '',
                    'HIMEM is testing extended memory...done.',
                    'EMM386 Memory Manager v4.49',
                    '',
                    'C:\\>win',
                    '',
                    'Starting Windows 95...'
                ];

                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);
                this.ctx.font = '14px monospace';
                this.ctx.fillStyle = '#c0c0c0';

                for (let i = 0; i < bootMessages.length; i++) {
                    await this.delay(CONFIG.ANIMATION.BOOT_MESSAGE_DELAY);
                    this.ctx.fillText(bootMessages[i], 10, 20 + i * 16);
                    this.updateProgress((i + 1) / bootMessages.length * 50);
                    this.updateLoadingText('Loading BIOS...');
                }

                await this.delay(500);
                this.updateLoadingText('Loading Windows 95...');

                // Clear screen
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);

                // Draw Windows logo with gradient
                const gradient = this.ctx.createLinearGradient(200, 200, 440, 280);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.25, '#ffff00');
                gradient.addColorStop(0.5, '#00ff00');
                gradient.addColorStop(1, '#0000ff');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(220, 200, 200, 80);

                // Add shine effect
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.fillRect(220, 200, 200, 20);

                // Windows text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 24px Arial';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                this.ctx.shadowBlur = 4;
                this.ctx.fillText('Windows 95', 250, 320);
                this.ctx.shadowBlur = 0;

                // Progress bar
                this.ctx.strokeStyle = '#c0c0c0';
                this.ctx.strokeRect(220, 340, 200, 10);

                // Animate progress
                for (let i = 0; i <= 100; i += 5) {
                    await this.delay(40);
                    this.ctx.fillStyle = '#0000ff';
                    this.ctx.fillRect(221, 341, (198 * i) / 100, 8);
                    this.updateProgress(50 + i / 2);
                }

                this.updateLoadingText('Starting desktop...');
            }

            drawDesktop() {
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;

                // Draw desktop background
                this.ctx.fillStyle = CONFIG.COLORS.DESKTOP;
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);

                // Draw taskbar with gradient
                const taskbarGrad = this.ctx.createLinearGradient(0, taskbarY, 0, CONFIG.DISPLAY.HEIGHT);
                taskbarGrad.addColorStop(0, '#dfdfdf');
                taskbarGrad.addColorStop(1, '#c0c0c0');
                this.ctx.fillStyle = taskbarGrad;
                this.ctx.fillRect(0, taskbarY, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.TASKBAR_HEIGHT);

                // Taskbar border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.moveTo(0, taskbarY);
                this.ctx.lineTo(CONFIG.DISPLAY.WIDTH, taskbarY);
                this.ctx.stroke();

                // Start button with gradient
                const startY = taskbarY + 2;
                const startHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 4;
                const startGrad = this.ctx.createLinearGradient(2, startY, 2, startY + startHeight);
                startGrad.addColorStop(0, '#ffffff');
                startGrad.addColorStop(0.5, '#c0c0c0');
                startGrad.addColorStop(1, '#808080');
                this.ctx.fillStyle = startGrad;
                this.ctx.fillRect(2, startY, 60, startHeight);

                // Start button border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(2, startY, 60, startHeight);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(3, startY + 1, 58, startHeight - 2);

                // Start text
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 11px Arial';
                const textY = startY + (startHeight / 2) + 4;
                this.ctx.fillText('Start', 20, textY);

                // Windows logo on button
                const logoY = startY + (startHeight / 2) - 4;
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(6, logoY, 4, 4);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(10, logoY, 4, 4);
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(6, logoY + 4, 4, 4);
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(10, logoY + 4, 4, 4);

                // System tray
                const trayY = taskbarY + 3;
                const trayHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 6;
                this.ctx.fillStyle = '#808080';
                this.ctx.fillRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);

                // Clock
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '11px Arial';
                const clockY = trayY + (trayHeight / 2) + 4;
                this.ctx.fillText(timeStr, CONFIG.DISPLAY.WIDTH - 50, clockY);
            }

            startEmulation() {
                this.isRunning = true;
                this.startTime = Date.now();
                this.drawDesktop();

                // Create interactive desktop icons
                this.createDesktopIcon(20, 20, 'My Computer', '💻', () => this.openFileExplorer());
                this.createDesktopIcon(20, 90, 'Internet Explorer', '🌐', () => this.openInternetExplorer());
                this.createDesktopIcon(20, 160, 'Recycle Bin', '🗑️', () => alert('Recycle Bin is empty'));
                this.createDesktopIcon(100, 20, 'MS-DOS Prompt', '⬛', () => this.openDOSPrompt());
                this.createDesktopIcon(100, 90, 'Paint', '🎨', () => this.openPaint());
                this.createDesktopIcon(100, 160, 'Notepad', '📝', () => this.openNotepad());

                // Create Start menu
                this.createStartMenu();

                // Setup desktop click handlers
                this.setupDesktopInteractions();

                // Start animation loop
                this.updateStatus();
                this.animate();

                // Start clock update (every second)
                this.clockInterval = setInterval(() => {
                    this.updateSystemClock();
                }, 1000);
            }

            createDesktopIcon(x, y, label, emoji, onClick) {
                const icon = {
                    x, y, label, emoji, onClick,
                    width: 48, height: 64,
                    selected: false
                };
                this.desktop.icons.push(icon);

                // Draw initial icon
                this.drawIcon(x, y, label, emoji, false);

                return icon;
            }

            setupDesktopInteractions() {
                const canvas = document.getElementById('screen');
                if (!canvas) return;

                // Handle icon clicks
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if clicking on an icon
                    let clickedIcon = null;
                    for (const icon of this.desktop.icons) {
                        if (x >= icon.x && x <= icon.x + icon.width &&
                            y >= icon.y && y <= icon.y + icon.height) {
                            clickedIcon = icon;
                            break;
                        }
                    }

                    // Handle icon selection and double-click
                    if (clickedIcon) {
                        const now = Date.now();
                        if (clickedIcon.lastClick && now - clickedIcon.lastClick < 400) {
                            // Double-click
                            if (clickedIcon.onClick) {
                                clickedIcon.onClick();
                            }
                        } else {
                            // Single click - select
                            this.desktop.icons.forEach(ic => {
                                ic.selected = (ic === clickedIcon);
                                this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, ic.selected);
                            });
                        }
                        clickedIcon.lastClick = now;
                    } else {
                        // Deselect all
                        this.desktop.icons.forEach(ic => {
                            if (ic.selected) {
                                ic.selected = false;
                                this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, false);
                            }
                        });
                    }

                    // Check if clicking on Start button
                    const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                    if (y >= taskbarY && y <= CONFIG.DISPLAY.HEIGHT && x >= 2 && x <= 62) {
                        this.toggleStartMenu();
                    } else {
                        // Close start menu if clicking elsewhere
                        const startMenu = document.getElementById('start-menu');
                        if (startMenu && startMenu.classList.contains('active')) {
                            if (x < 0 || x > 200 || y < taskbarY - 200) {
                                startMenu.classList.remove('active');
                            }
                        }
                    }
                });

                // Handle right-click for context menu
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.showContextMenu(x, y);
                    return false;
                });
            }

            createStartMenu() {
                const screenContainer = document.getElementById('screen_container');
                if (!screenContainer) return;

                const startMenu = document.createElement('div');
                startMenu.id = 'start-menu';
                startMenu.className = 'start-menu';
                startMenu.style.cssText = 'display: none;';
                startMenu.innerHTML = `
                    <div style="display: flex; height: 500px;">
                        <div class="start-menu-sidebar">Windows 95</div>
                        <div class="start-menu-items" style="flex: 1;">
                            <div class="start-menu-item" onclick="emulator.openInternetExplorer(); emulator.toggleStartMenu();">
                                🌐 Internet Explorer
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                📁 Programs ►
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openFileExplorer(); emulator.toggleStartMenu();">
                                    💻 My Computer
                                </div>
                                <div class="start-menu-item" onclick="emulator.openPaint(); emulator.toggleStartMenu();">
                                    🎨 Paint
                                </div>
                                <div class="start-menu-item" onclick="emulator.openMediaPlayer(); emulator.toggleStartMenu();">
                                    🎵 Media Player
                                </div>
                                <div class="start-menu-item" onclick="emulator.openNotepad(); emulator.toggleStartMenu();">
                                    📝 Notepad
                                </div>
                                <div class="start-menu-item" onclick="emulator.openCalculator(); emulator.toggleStartMenu();">
                                    🧮 Calculator
                                </div>
                                <div class="start-menu-item" onclick="emulator.openDOSPrompt(); emulator.toggleStartMenu();">
                                    ⬛ Linux Terminal
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                🎮 Games ►
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openMinesweeper(); emulator.toggleStartMenu();">
                                    💣 Minesweeper
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSolitaire(); emulator.toggleStartMenu();">
                                    🃏 Solitaire
                                </div>
                                <div class="start-menu-item" onclick="emulator.openFreeCell(); emulator.toggleStartMenu();">
                                    🎴 FreeCell
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                ⚙️ Settings ►
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openControlPanel(); emulator.toggleStartMenu();">
                                    🎛️ Control Panel
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSystemProperties(); emulator.toggleStartMenu();">
                                    🖥️ System Properties
                                </div>
                                <div class="start-menu-item" onclick="emulator.openRegistryEditor(); emulator.toggleStartMenu();">
                                    📋 Registry Editor
                                </div>
                                <div class="start-menu-item" onclick="emulator.openTaskManager(); emulator.toggleStartMenu();">
                                    📊 Task Manager
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" onclick="emulator.openAbout(); emulator.toggleStartMenu();">
                                ℹ️ About
                            </div>
                            <div class="start-menu-item" onclick="emulator.showHelp(); emulator.toggleStartMenu();">
                                ❓ Help
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" onclick="emulator.restart();">
                                🔄 Shut Down...
                            </div>
                        </div>
                    </div>
                `;
                screenContainer.appendChild(startMenu);
            }

            toggleStartMenu() {
                const startMenu = document.getElementById('start-menu');
                if (startMenu) {
                    if (startMenu.classList.contains('active')) {
                        startMenu.classList.remove('active');
                        startMenu.style.display = 'none';
                    } else {
                        startMenu.classList.add('active');
                        startMenu.style.display = 'block';

                        // Play start menu sound
                        this.playSoundEffect('start-menu');
                    }
                }
            }

            showContextMenu(x, y) {
                // Remove existing context menu
                const existing = document.getElementById('context-menu');
                if (existing) existing.remove();

                const screenContainer = document.getElementById('screen_container');
                if (!screenContainer) return;

                const contextMenu = document.createElement('div');
                contextMenu.id = 'context-menu';
                contextMenu.className = 'context-menu active';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="emulator.openInternetExplorer(); document.getElementById('context-menu').remove();">
                        Open Internet Explorer
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.openNotepad(); document.getElementById('context-menu').remove();">
                        New &gt; Text Document
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.refreshDesktop(); document.getElementById('context-menu').remove();">
                        Refresh
                    </div>
                    <div class="context-menu-item" onclick="alert('Properties'); document.getElementById('context-menu').remove();">
                        Properties
                    </div>
                `;
                screenContainer.appendChild(contextMenu);

                // Close on next click
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        contextMenu.remove();
                        document.removeEventListener('click', closeMenu);
                    }, { once: true });
                }, 100);
            }

            refreshDesktop() {
                // Redraw entire desktop
                this.drawDesktop();

                // Redraw icons
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }

            drawStartButton() {
                const startGrad = this.ctx.createLinearGradient(2, 452, 2, 478);
                startGrad.addColorStop(0, '#ffffff');
                startGrad.addColorStop(0.5, '#c0c0c0');
                startGrad.addColorStop(1, '#808080');
                this.ctx.fillStyle = startGrad;
                this.ctx.fillRect(2, 452, 60, 26);

                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(2, 452, 60, 26);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(3, 453, 58, 24);

                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText('Start', 20, 468);

                // Windows logo on button
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(6, 458, 4, 4);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(10, 458, 4, 4);
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(6, 462, 4, 4);
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(10, 462, 4, 4);
            }

            drawSystemTray() {
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                const trayY = taskbarY + 3;
                const trayHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 6;

                this.ctx.fillStyle = '#808080';
                this.ctx.fillRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);

                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '11px Arial';
                const clockY = trayY + (trayHeight / 2) + 4;
                this.ctx.fillText(timeStr, CONFIG.DISPLAY.WIDTH - 50, clockY);
            }

            updateSystemClock() {
                // Redraw just the system tray area every second
                if (!this.ctx) return;
                this.drawSystemTray();
            }

            drawIcon(x, y, label, emoji, selected) {
                // Icon background (for selection)
                if (selected) {
                    this.ctx.fillStyle = 'rgba(0, 0, 128, 0.3)';
                    this.ctx.fillRect(x, y, 48, 64);
                    this.ctx.strokeStyle = 'rgba(0, 0, 128, 0.6)';
                    this.ctx.setLineDash([2, 2]);
                    this.ctx.strokeRect(x, y, 48, 64);
                    this.ctx.setLineDash([]);
                }

                // Draw icon image (simplified)
                this.ctx.font = '32px Arial';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText(emoji, x + 8, y + 32);

                // Icon label with background
                if (selected) {
                    this.ctx.fillStyle = '#000080';
                    const textWidth = this.ctx.measureText(label).width + 4;
                    this.ctx.fillRect(x + 24 - textWidth/2, y + 42, textWidth, 14);
                }

                // Icon label
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 2;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, x + 24, y + 53);
                this.ctx.shadowBlur = 0;
                this.ctx.textAlign = 'left';
            }

            drawWindow(x, y, width, height, title) {
                // Window outer border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(x, y, width, height);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);

                // Window background
                this.ctx.fillStyle = '#c0c0c0';
                this.ctx.fillRect(x + 2, y + 2, width - 4, height - 4);

                // Title bar
                const titleGrad = this.ctx.createLinearGradient(x + 2, y + 2, x + 2, y + 20);
                titleGrad.addColorStop(0, '#0000ff');
                titleGrad.addColorStop(1, '#000080');
                this.ctx.fillStyle = titleGrad;
                this.ctx.fillRect(x + 2, y + 2, width - 4, 18);

                // Title bar text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText(title, x + 6, y + 14);

                // Window control buttons
                const btnSize = 16;
                const btnY = y + 4;
                
                // Minimize button
                this.drawWindowButton(x + width - 60, btnY, btnSize, '_');
                // Maximize button
                this.drawWindowButton(x + width - 40, btnY, btnSize, '□');
                // Close button
                this.drawWindowButton(x + width - 20, btnY, btnSize, 'X');

                // Window content area
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(x + 3, y + 22, width - 6, height - 25);

                // Draw some content
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '12px Arial';
                this.ctx.fillText('Welcome to Windows 95 Emulator!', x + 10, y + 40);
                this.ctx.font = '11px Arial';
                this.ctx.fillText('This is a WebAssembly-powered x86 emulation.', x + 10, y + 60);
                this.ctx.fillText('', x + 10, y + 75);
                this.ctx.fillText('Features:', x + 10, y + 90);
                this.ctx.fillText('• Full desktop environment simulation', x + 20, y + 105);
                this.ctx.fillText('• Mouse and keyboard support', x + 20, y + 120);
                this.ctx.fillText('• Load custom disk images', x + 20, y + 135);
                this.ctx.fillText('• Save and restore state', x + 20, y + 150);
                this.ctx.fillText('', x + 10, y + 165);
                this.ctx.fillStyle = '#000080';
                this.ctx.fillText('Click "Load Disk" to load a Windows 95 image.', x + 10, y + 180);
            }

            drawWindowButton(x, y, size, label) {
                // Button background
                this.ctx.fillStyle = '#c0c0c0';
                this.ctx.fillRect(x, y, size, 14);
                
                // Button border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(x, y, size, 14);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(x + 1, y + 1, size - 2, 12);

                // Button label
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, x + size / 2, y + 10);
                this.ctx.textAlign = 'left';
            }

            animate() {
                if (!this.isRunning) return;

                const now = Date.now();
                const deltaTime = now - this.lastFrameTime;

                // Frame rate limiting
                if (deltaTime < CONFIG.PERFORMANCE.FRAME_TIME) {
                    requestAnimationFrame(() => this.animate());
                    return;
                }

                this.lastFrameTime = now;
                this.frameCount++;

                // Update FPS and stats
                if (now - this.lastFpsUpdate > CONFIG.ANIMATION.FPS_UPDATE_INTERVAL) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsUpdate));
                    this.domCache.fpsCounter.textContent = fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;

                    // Update uptime
                    const elapsed = Math.floor((now - this.startTime) / 1000);
                    const hours = Math.floor(elapsed / 3600);
                    const minutes = Math.floor((elapsed % 3600) / 60);
                    const seconds = elapsed % 60;

                    const pad = (num) => num < 10 ? '0' + num : '' + num;
                    this.domCache.timeDisplay.textContent =
                        `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;

                    // Update memory usage simulation
                    this.memoryUsage = Math.floor(this.settings.memory / 1024 / 1024 * (0.3 + Math.random() * 0.2));
                    this.domCache.memoryUsage.textContent = this.memoryUsage + ' MB';
                }

                // Update LED indicators (throttled)
                if (this.frameCount % CONFIG.ANIMATION.LED_THROTTLE_FRAMES === 0) {
                    // CPU activity
                    if (Math.random() > 0.6) {
                        this.domCache.cpuLed.classList.add('active');
                        this.domCache.cpuStatus.textContent = 'Active';
                        this.cpuUsage = Math.floor(Math.random() * 40 + 10);
                    } else {
                        this.domCache.cpuLed.classList.remove('active');
                        this.domCache.cpuStatus.textContent = 'Idle';
                        this.cpuUsage = Math.floor(Math.random() * 10);
                    }

                    // HDD activity
                    if (Math.random() > 0.85) {
                        if (this.hddLedTimeout) {
                            clearTimeout(this.hddLedTimeout);
                        }

                        this.domCache.hddLed.classList.add('active');
                        this.hddLedTimeout = setTimeout(() => {
                            this.domCache.hddLed.classList.remove('active');
                            this.hddLedTimeout = null;
                        }, 100);
                    }
                }

                requestAnimationFrame(() => this.animate());
            }

            updateStatus() {
                this.updateSettings();
            }

            updateProgress(percent) {
                if (this.domCache && this.domCache.progressFill) {
                    this.domCache.progressFill.style.width = Math.min(100, percent) + '%';
                    this.domCache.progressFill.parentElement.setAttribute('aria-valuenow', Math.round(percent));
                }
            }

            updateLoadingText(text) {
                if (this.domCache && this.domCache.loadingText) {
                    this.domCache.loadingText.textContent = text;
                }
            }

            showLoading(text = 'Starting Windows 95...') {
                this.initDOMCache();
                this.domCache.loadingScreen.classList.add('active');
                this.updateProgress(0);
                this.updateLoadingText(text);
            }

            hideLoading() {
                setTimeout(() => {
                    if (this.domCache && this.domCache.loadingScreen) {
                        this.domCache.loadingScreen.classList.remove('active');
                    }
                }, 500);
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    this.isRunning = false;
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">▶</span> Resume';
                    this.domCache.emulatorTitlebar.classList.add('inactive');
                    
                    // Show paused message
                    const pauseText = 'PAUSED';
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(pauseText, CONFIG.DISPLAY.WIDTH / 2, CONFIG.DISPLAY.HEIGHT / 2);
                    this.ctx.textAlign = 'left';
                } else {
                    this.isRunning = true;
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">⏸</span> Pause';
                    this.domCache.emulatorTitlebar.classList.remove('inactive');
                    this.lastFrameTime = Date.now();
                    this.animate();
                }
            }

            restart() {
                if (!confirm('Are you sure you want to restart? Any unsaved changes will be lost.')) {
                    return;
                }

                this.isRunning = false;
                this.isPaused = false;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastFrameTime = 0;

                if (this.hddLedTimeout) {
                    clearTimeout(this.hddLedTimeout);
                    this.hddLedTimeout = null;
                }

                // Reset UI
                this.initDOMCache();
                this.domCache.emulatorContainer.classList.add('hidden');
                this.domCache.setupScreen.classList.remove('hidden');
                
                if (this.domCache.pauseBtn) {
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">⏸</span> Pause';
                }
            }

            fullscreen() {
                try {
                    const container = document.getElementById('emulator-container');
                    const frame = document.querySelector('.emulator-frame');

                    if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled &&
                        !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                        alert('Fullscreen not supported in this browser');
                        return;
                    }

                    if (document.fullscreenElement || document.webkitFullscreenElement ||
                        document.mozFullScreenElement || document.msFullscreenElement) {
                        // Exit fullscreen
                        const exitFullscreen = document.exitFullscreen ||
                                             document.webkitExitFullscreen ||
                                             document.mozCancelFullScreen ||
                                             document.msExitFullscreen;
                        if (exitFullscreen) {
                            exitFullscreen.call(document);
                        }
                        // Remove fullscreen class
                        if (frame) {
                            frame.classList.remove('fullscreen-mode');
                        }
                        // Restore original canvas size
                        this.resizeCanvas(640, 480);
                    } else {
                        // Enter fullscreen
                        const requestFullscreen = container.requestFullscreen ||
                                                container.webkitRequestFullscreen ||
                                                container.webkitRequestFullScreen ||
                                                container.mozRequestFullScreen ||
                                                container.msRequestFullscreen;

                        if (requestFullscreen) {
                            requestFullscreen.call(container).then(() => {
                                // Add fullscreen class when successfully entered
                                if (frame) {
                                    frame.classList.add('fullscreen-mode');
                                }
                                // Resize canvas to fill screen
                                setTimeout(() => {
                                    const screenContainer = document.getElementById('screen_container');
                                    if (screenContainer) {
                                        const width = screenContainer.clientWidth;
                                        const height = screenContainer.clientHeight;
                                        this.resizeCanvas(width, height);
                                    }
                                }, 100);
                            }).catch(err => {
                                console.error('Fullscreen request failed:', err);
                                alert('Could not enter fullscreen mode');
                            });
                        }
                    }
                } catch (error) {
                    console.error('Fullscreen error:', error);
                    alert('Fullscreen failed: ' + error.message);
                }
            }

            resizeCanvas(width, height) {
                if (!this.canvas || !this.ctx) return;

                // Store old dimensions
                const oldWidth = this.canvas.width;
                const oldHeight = this.canvas.height;

                // Set new canvas dimensions
                this.canvas.width = width;
                this.canvas.height = height;

                // Update CONFIG for rendering
                CONFIG.DISPLAY.WIDTH = width;
                CONFIG.DISPLAY.HEIGHT = height;
                CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(height * 0.0625)); // 6.25% of height

                // Redraw desktop
                this.drawDesktop();

                // Update window manager bounds
                if (this.windowManager) {
                    this.windowManager.updateBounds(width, height);
                }
            }

            screenshot() {
                try {
                    const canvas = document.getElementById('screen');
                    if (!canvas) {
                        throw new Error('Canvas not found');
                    }

                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const link = document.createElement('a');
                    link.download = `windows95-screenshot-${timestamp}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    // Show feedback
                    this.showNotification('Screenshot saved!');
                } catch (error) {
                    console.error('Screenshot failed:', error);
                    alert('Screenshot failed. Canvas may be tainted by cross-origin content.');
                }
            }

            showNotification(message) {
                // Simple notification in the emulator
                const prevFill = this.ctx.fillStyle;
                const prevFont = this.ctx.font;
                
                this.ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                this.ctx.fillRect(200, 200, 240, 80);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(200, 200, 240, 80);
                
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(message, 320, 240);
                this.ctx.textAlign = 'left';
                
                this.ctx.fillStyle = prevFill;
                this.ctx.font = prevFont;
            }

            showHelp() {
                alert(`Windows 95 Desktop Simulator Help

DESKTOP INTERACTIONS:
• Single-click icons to select them
• Double-click icons to open programs
• Right-click desktop for context menu
• Click Start button to open program menu

WINDOWS:
• Drag windows by their title bars
• Click minimize (_) to minimize to taskbar
• Click maximize (□) to toggle full screen
• Click close (X) to close windows
• Click taskbar buttons to restore windows

KEYBOARD SHORTCUTS:
• F11 - Toggle fullscreen mode
• Ctrl+P - Pause/Resume desktop
• Ctrl+R - Restart desktop
• Ctrl+S - Take screenshot
• ESC - Release mouse cursor (if locked)

PROGRAMS:
• Internet Explorer - Real web browser (loads live sites!)
• Notepad - Text editor with basic functionality
• Calculator - Working calculator with basic operations
• Minesweeper - Classic game (right-click to flag)
• About - Information about this simulator

FEATURES:
• All interactions happen locally in your browser
• No data is sent to any server
• State persists in browser storage
• Works completely offline
• Authentic Windows 95 look and feel

TIP: Try opening multiple windows and arranging them!`);
            }

            loadDisk() {
                document.getElementById('disk-input').click();
            }

            handleDiskUpload(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) return;

                    const validExtensions = ['.img', '.iso', '.ima'];
                    const fileName = file.name.toLowerCase();
                    const isValid = validExtensions.some(ext => fileName.endsWith(ext));

                    if (!isValid) {
                        alert('Invalid file type. Please select an IMG, ISO, or IMA file.');
                        return;
                    }

                    if (file.size > 100 * 1024 * 1024) {
                        alert('File too large. Maximum size is 100MB for this demo.');
                        return;
                    }

                    // Show file name
                    const fileNameDisplay = document.getElementById('file-name');
                    if (fileNameDisplay) {
                        fileNameDisplay.textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                    }

                    console.log('Loading disk image:', file.name, 'Size:', file.size, 'bytes');
                    alert(`Disk image "${file.name}" selected.\n\nNote: Full Windows 95 emulation requires the v86 WASM library.\nThis demo shows a simulated environment.\n\nFor actual Windows 95, you would need:\n• A complete v86 library implementation\n• Valid Windows 95 disk image\n• Additional ROM files`);
                    
                    this.loadDemo();
                } catch (error) {
                    console.error('Failed to handle disk upload:', error);
                    alert('Failed to load disk image: ' + error.message);
                }
            }

            loadFromURL() {
                try {
                    const url = document.getElementById('disk-url').value.trim();
                    if (!url) {
                        alert('Please enter a URL');
                        return;
                    }

                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        alert('Invalid URL. Must start with http:// or https://');
                        return;
                    }

                    console.log('Loading from URL:', url);
                    alert(`Loading from URL: ${url}\n\nNote: Full emulation requires the v86 WASM library.\nThis demo shows a simulated environment.\n\nRequirements:\n• Server must support CORS\n• Valid disk image format (IMG/ISO)\n• Stable network connection`);
                    
                    this.loadDemo();
                } catch (error) {
                    console.error('Failed to load from URL:', error);
                    alert('Failed to load from URL: ' + error.message);
                }
            }

            minimize() {
                const container = document.getElementById('emulator-container');
                container.style.transition = 'transform 0.3s ease';
                container.style.transform = 'scale(0.1)';
                container.style.opacity = '0';
                
                setTimeout(() => {
                    container.style.transform = 'scale(1)';
                    container.style.opacity = '1';
                }, 300);
            }

            maximize() {
                this.fullscreen();
            }

            close() {
                if (confirm('Are you sure you want to close Windows 95?\n\nAny unsaved changes will be lost.')) {
                    this.restart();
                }
            }
        }

        // Safe localStorage wrapper
        class SafeStorage {
            static setItem(key, value) {
                try {
                    localStorage.setItem(key, value);
                    return true;
                } catch (e) {
                    console.warn('localStorage unavailable:', e);
                    return false;
                }
            }

            static getItem(key) {
                try {
                    return localStorage.getItem(key);
                } catch (e) {
                    console.warn('localStorage unavailable:', e);
                    return null;
                }
            }

            static removeItem(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (e) {
                    console.warn('localStorage unavailable:', e);
                    return false;
                }
            }
        }

        // Initialize emulator
        const emulator = new Windows95Emulator();

        // Global mouse handlers for window dragging
        document.addEventListener('mousemove', (e) => {
            if (emulator.windowManager) {
                emulator.windowManager.handleMouseMove(e);
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (emulator.windowManager) {
                emulator.windowManager.handleMouseUp(e);
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // ESC - Release mouse
            if (e.key === 'Escape') {
                const isLocked = document.pointerLockElement ||
                                document.webkitPointerLockElement ||
                                document.mozPointerLockElement;

                if (isLocked) {
                    const exitPointerLock = document.exitPointerLock ||
                                          document.webkitExitPointerLock ||
                                          document.mozExitPointerLock;
                    if (exitPointerLock) {
                        exitPointerLock.call(document);
                    }
                }
            }

            // F11 - Fullscreen
            if (e.key === 'F11') {
                e.preventDefault();
                emulator.fullscreen();
            }

            // Ctrl+P - Pause
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                emulator.togglePause();
            }

            // Ctrl+S - Screenshot
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                emulator.screenshot();
            }

            // Ctrl+R - Restart
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                emulator.restart();
            }

            // Alt+F4 - Close active window
            if (e.altKey && e.key === 'F4') {
                e.preventDefault();
                const activeWindow = document.querySelector('.window.active');
                if (activeWindow && emulator.windowManager) {
                    emulator.windowManager.closeWindow(activeWindow);
                }
            }

            // Ctrl+Escape or Windows key - Toggle Start Menu
            if ((e.ctrlKey && e.key === 'Escape') || e.key === 'Meta' || e.key === 'OS') {
                e.preventDefault();
                emulator.toggleStartMenu();
            }

            // F1 - Help
            if (e.key === 'F1') {
                e.preventDefault();
                emulator.showHelp();
            }

            // Ctrl+N - New Notepad
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                emulator.openNotepad();
            }

            // Ctrl+Shift+Esc - Task Manager
            if (e.ctrlKey && e.shiftKey && e.key === 'Escape') {
                e.preventDefault();
                emulator.openTaskManager();
            }

            // Windows+E - File Explorer
            if ((e.metaKey || e.key === 'OS') && e.key === 'e') {
                e.preventDefault();
                emulator.openFileExplorer();
            }

            // Windows+R - Run dialog (open DOS prompt for now)
            if ((e.metaKey || e.key === 'OS') && e.key === 'r') {
                e.preventDefault();
                emulator.openDOSPrompt();
            }
        });

        // Auto-save settings
        window.addEventListener('beforeunload', () => {
            const settings = {
                memory: document.getElementById('memory-size').value,
                cpuSpeed: document.getElementById('cpu-speed').value,
                enableMouse: document.getElementById('enable-mouse').checked,
                enableSound: document.getElementById('enable-sound').checked,
                enableNetwork: document.getElementById('enable-network').checked
            };
            SafeStorage.setItem('win95-emulator-settings', JSON.stringify(settings));
        });

        // Load saved settings
        window.addEventListener('load', () => {
            const saved = SafeStorage.getItem('win95-emulator-settings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    document.getElementById('memory-size').value = settings.memory || '32';
                    document.getElementById('cpu-speed').value = settings.cpuSpeed || '2';
                    document.getElementById('enable-mouse').checked = settings.enableMouse !== false;
                    document.getElementById('enable-sound').checked = settings.enableSound !== false;
                    document.getElementById('enable-network').checked = settings.enableNetwork !== false;
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            }
        });

        // Handle file input label update
        document.getElementById('disk-input').addEventListener('change', function(e) {
            const fileName = e.target.files[0]?.name;
            if (fileName) {
                const label = document.querySelector('.file-input-label');
                label.textContent = fileName;
            }
        });

        // Fullscreen change handler with cross-browser support
        function handleFullscreenChange() {
            const frame = document.querySelector('.emulator-frame');
            const isFullscreen = document.fullscreenElement ||
                               document.webkitFullscreenElement ||
                               document.mozFullScreenElement ||
                               document.msFullscreenElement;

            if (isFullscreen) {
                console.log('Entered fullscreen mode');
                if (frame) {
                    frame.classList.add('fullscreen-mode');
                }
                // Resize canvas to fill screen
                setTimeout(() => {
                    if (emulator && emulator.resizeCanvas) {
                        const screenContainer = document.getElementById('screen_container');
                        if (screenContainer) {
                            const width = screenContainer.clientWidth;
                            const height = screenContainer.clientHeight;
                            emulator.resizeCanvas(width, height);
                        }
                    }
                }, 100);
            } else {
                console.log('Exited fullscreen mode');
                if (frame) {
                    frame.classList.remove('fullscreen-mode');
                }
                // Restore original canvas size
                if (emulator && emulator.resizeCanvas) {
                    emulator.resizeCanvas(640, 480);
                }
            }
        }

        // Add event listeners for all browser prefixes
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        // Log initialization
        console.log('Windows 95 WASM Emulator initialized');
        console.log('WebAssembly support:', typeof WebAssembly !== 'undefined');
    </script>

    <!-- Multi-Clippy Autonomous Assistant System -->
    <div id="clippy-swarm"></div>

    <script>
        // ========================================
        // CLIPPY GOVERNOR - Multi-Agent Coordination System
        // ========================================

        class ClippyGovernor {
            constructor() {
                this.instances = [];
                this.state = {
                    user: {
                        activity: 'idle',
                        focus: null,
                        mousePos: { x: 0, y: 0 },
                        lastAction: Date.now(),
                        openWindows: [],
                        keystrokes: 0,
                        clicks: 0,
                        pattern: 'exploring' // exploring, gaming, working, browsing
                    },
                    system: {
                        uptime: 0,
                        windowCount: 0,
                        lastWindowOpened: null
                    },
                    conversation: {
                        active: false,
                        speaker: null,
                        topic: null,
                        participants: []
                    }
                };
                this.messageQueue = [];
                this.stateUpdateInterval = null;
                this.personalities = this.definePersonalities();
                this.init();
            }

            definePersonalities() {
                return {
                    helper: {
                        name: 'Clippit',
                        icon: '📎',
                        traits: { helpfulness: 0.9, humor: 0.3, technical: 0.5, patience: 0.9 },
                        catchphrases: [
                            "It looks like you're trying to",
                            "Would you like help with that?",
                            "Need assistance?",
                            "I can help with that!"
                        ],
                        position: { bottom: 80, right: 30 }
                    }
                };
            }

            init() {
                // Create only the single Clippy instance
                Object.keys(this.personalities).forEach(role => {
                    this.createClippy(role);
                });

                // Start state monitoring
                this.startStateTracking();

                // Subtle first appearance - only after user has been active for a bit
                setTimeout(() => {
                    if (this.state.user.clicks > 3 || this.state.user.keystrokes > 5) {
                        this.showClippy('helper', "👋 Hi! I'm Clippit. Click me if you need help with Windows 95.");
                    }
                }, 20000); // Wait 20 seconds before first appearance

                console.log('📎 Clippit assistant initialized');
            }

            createClippy(role) {
                const personality = this.personalities[role];
                const clippy = {
                    id: `clippy-${role}`,
                    role: role,
                    personality: personality,
                    active: false,
                    message: null,
                    element: null
                };

                // Determine bubble position based on Clippy location
                let bubblePos = '';
                let bubbleArrow = '';

                if (personality.position.left !== undefined) {
                    // Left side - bubble appears to the right
                    bubblePos = 'bottom: 130px; left: 0;';
                    bubbleArrow = 'left: 30px;';
                } else if (personality.position.right !== undefined) {
                    // Right side - bubble appears to the left
                    bubblePos = 'bottom: 130px; right: 0;';
                    bubbleArrow = 'right: 30px;';
                }

                if (personality.position.top !== undefined) {
                    // Top positioned - bubble appears below
                    bubblePos = 'top: 130px; right: 0;';
                    bubbleArrow = 'top: -20px; right: 30px; border-bottom-color: #000; border-top-color: transparent;';
                }

                // Create DOM element
                const container = document.createElement('div');
                container.id = clippy.id;
                container.className = 'clippy-instance';
                container.style.cssText = `
                    position: fixed;
                    ${personality.position.top ? `top: ${personality.position.top}px;` : ''}
                    ${personality.position.bottom ? `bottom: ${personality.position.bottom}px;` : ''}
                    ${personality.position.left ? `left: ${personality.position.left}px;` : ''}
                    ${personality.position.right ? `right: ${personality.position.right}px;` : ''}
                    z-index: 9999;
                    font-family: 'Comic Sans MS', cursive, sans-serif;
                `;

                container.innerHTML = `
                    <div class="clippy-bubble" style="display: none; position: absolute; ${bubblePos} max-width: 220px; background: #ffffcc; border: 2px solid #000; border-radius: 8px; padding: 10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.25);">
                        <div class="bubble-arrow" style="position: absolute; ${bubbleArrow} border: 8px solid transparent; border-top-color: #000;"></div>
                        <div style="position: absolute; top: 2px; right: 2px; background: #c0c0c0; border: 1px solid #000; width: 16px; height: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold;" onclick="window.clippyGovernor.hideClippy('${role}')">×</div>
                        <div class="clippy-message" style="font-size: 11px; line-height: 1.3; color: #000; margin-top: 4px;"></div>
                    </div>
                    <div class="clippy-character" onclick="window.clippyGovernor.toggleClippy('${role}')" style="width: 80px; height: 100px; background: #fff; border: 2px solid #000; border-radius: 50% 50% 40% 40%; position: relative; cursor: pointer; transition: transform 0.2s; box-shadow: 2px 2px 6px rgba(0,0,0,0.2);">
                        <div style="font-size: 50px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">${personality.icon}</div>
                    </div>
                `;

                document.getElementById('clippy-swarm').appendChild(container);
                clippy.element = container;

                this.instances.push(clippy);
                return clippy;
            }

            startStateTracking() {
                // Track mouse movement
                document.addEventListener('mousemove', (e) => {
                    this.state.user.mousePos = { x: e.clientX, y: e.clientY };
                });

                // Track clicks
                document.addEventListener('click', () => {
                    this.state.user.clicks++;
                    this.state.user.lastAction = Date.now();
                    this.updateUserPattern();
                });

                // Track keypresses
                document.addEventListener('keypress', () => {
                    this.state.user.keystrokes++;
                    this.state.user.lastAction = Date.now();
                    this.updateUserPattern();
                });

                // Track window changes
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('window')) {
                                const title = node.querySelector('.window-title')?.textContent || 'Unknown';
                                this.state.system.windowCount++;
                                this.state.system.lastWindowOpened = title;
                                this.state.user.openWindows.push(title);
                                this.reactToWindowOpen(title);
                            }
                        });
                        mutation.removedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('window')) {
                                this.state.system.windowCount--;
                            }
                        });
                    });
                });

                observer.observe(document.body, { childList: true, subtree: true });

                // Update state every 500ms
                this.stateUpdateInterval = setInterval(() => {
                    this.updateState();
                }, 500);
            }

            updateState() {
                const timeSinceAction = Date.now() - this.state.user.lastAction;

                if (timeSinceAction > 30000) {
                    this.state.user.activity = 'idle';
                } else if (timeSinceAction < 2000) {
                    this.state.user.activity = 'active';
                } else {
                    this.state.user.activity = 'moderate';
                }

                this.state.system.uptime = Math.floor((Date.now() - window.clippyGovernor.startTime) / 1000);
            }

            updateUserPattern() {
                const { clicks, keystrokes, openWindows } = this.state.user;

                // Detect patterns based on behavior
                if (openWindows.some(w => w.includes('FreeCell') || w.includes('Minesweeper') || w.includes('Solitaire'))) {
                    this.state.user.pattern = 'gaming';
                } else if (openWindows.some(w => w.includes('Terminal') || w.includes('Notepad'))) {
                    this.state.user.pattern = 'working';
                } else if (openWindows.some(w => w.includes('Internet Explorer'))) {
                    this.state.user.pattern = 'browsing';
                } else {
                    this.state.user.pattern = 'exploring';
                }
            }

            reactToWindowOpen(title) {
                // Only show Clippy 30% of the time to avoid being annoying
                if (Math.random() > 0.3) return;

                let message = '';

                if (title.includes('FreeCell')) {
                    message = "It looks like you're playing FreeCell. Would you like tips on strategy?";
                } else if (title.includes('Minesweeper')) {
                    message = "Playing Minesweeper! Remember: numbers show how many mines are adjacent.";
                } else if (title.includes('Terminal')) {
                    message = "It looks like you're using the Terminal. Type 'help' to see all commands.";
                } else if (title.includes('Paint')) {
                    message = "Working on some art? Paint has many tools in the toolbar!";
                } else if (title.includes('Control Panel')) {
                    message = "Need help customizing? The Display tab lets you change colors!";
                } else if (title.includes('Internet Explorer')) {
                    message = "Browsing the web? You can enter any URL in the address bar.";
                } else {
                    // Don't show for other programs
                    return;
                }

                setTimeout(() => {
                    this.showClippy('helper', message);
                }, 2000);
            }

            generateGameMessage(game) {
                const messages = {
                    'FreeCell': [
                        "🎴 FreeCell! Strategy is key - plan your moves ahead!",
                        "🏆 Ready to win? Remember: Ace goes first on foundations!",
                        "🎯 Pro tip: Keep free cells available for complex moves!"
                    ],
                    'Minesweeper': [
                        "💣 Minesweeper! Logic puzzle time! You got this!",
                        "🏆 Flag those mines! Right-click to mark suspicious spots!",
                        "🎯 Numbers show adjacent mines - use them wisely!"
                    ],
                    'Solitaire': [
                        "🃏 Solitaire! Classic patience game - enjoy!",
                        "🏆 Build those foundations! Ace to King!",
                        "🎯 Sometimes you need to move cards back down to progress!"
                    ]
                };

                for (let key in messages) {
                    if (game.includes(key)) {
                        return messages[key][Math.floor(Math.random() * messages[key].length)];
                    }
                }

                return "🎮 Game on! Have fun!";
            }

            generateTerminalMessage() {
                const messages = [
                    "💻 Terminal opened! Type 'help' to see all available commands.",
                    "🎓 Pro tip: Your files persist between sessions automatically!",
                    "📁 Try 'tree' to visualize your directory structure.",
                    "🐮 Fun command: Try 'cowsay hello' for a surprise!"
                ];
                return messages[Math.floor(Math.random() * messages.length)];
            }

            showClippy(role, message) {
                const clippy = this.instances.find(c => c.role === role);
                if (!clippy) return;

                // Don't show if already active
                if (clippy.active) return;

                const bubble = clippy.element.querySelector('.clippy-bubble');
                const msgEl = clippy.element.querySelector('.clippy-message');

                msgEl.textContent = message;
                bubble.style.display = 'block';
                clippy.active = true;
                clippy.message = message;

                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (clippy.active) {
                        bubble.style.display = 'none';
                        clippy.active = false;
                    }
                }, 10000);
            }

            hideClippy(role) {
                const clippy = this.instances.find(c => c.role === role);
                if (!clippy) return;

                const bubble = clippy.element.querySelector('.clippy-bubble');
                bubble.style.display = 'none';
                clippy.active = false;
            }

            toggleClippy(role) {
                const clippy = this.instances.find(c => c.role === role);
                if (!clippy) return;

                if (clippy.active) {
                    this.hideClippy(role);
                } else {
                    const randomTip = this.generateRandomTip(role);
                    this.showClippy(role, randomTip);
                }
            }

            generateRandomTip(role) {
                const tips = [
                    "Need help? Click the Start button to see all programs!",
                    "Right-click the desktop to see more options.",
                    "You can drag windows by their title bars.",
                    "Try the games in the Start menu!",
                    "The Terminal has many commands - type 'help' to see them.",
                    "Control Panel lets you customize your desktop.",
                    "Your files in Terminal are saved automatically.",
                    "Paint has drawing tools you can use!",
                    "Internet Explorer can browse real websites.",
                    "Double-click desktop icons to open programs."
                ];

                return tips[Math.floor(Math.random() * tips.length)];
            }

            // ========================================
            // CONTEXTUAL REACTIONS
            // ========================================

            detectStruggle() {
                // If user has been clicking excessively, they might be struggling
                if (this.state.user.clicks > 80) {
                    this.showClippy('helper', "Need help? Click me if you'd like assistance!");
                    this.state.user.clicks = 0; // Reset counter
                }
            }
        }

        // ========================================
        // INITIALIZE CLIPPY ASSISTANT
        // ========================================

        let clippyGovernor;
        window.addEventListener('load', () => {
            setTimeout(() => {
                clippyGovernor = new ClippyGovernor();
                clippyGovernor.startTime = Date.now();
                window.clippyGovernor = clippyGovernor; // Make globally accessible

                // Occasionally check if user needs help (every minute)
                setInterval(() => {
                    clippyGovernor.detectStruggle();
                }, 60000);

                console.log('📎 Clippit assistant ready');
            }, 1000);
        });
    </script>
</body>
</html>
